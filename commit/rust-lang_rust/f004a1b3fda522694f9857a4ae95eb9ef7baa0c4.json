{"sha": "f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "node_id": "C_kwDOAAsO6NoAKGYwMDRhMWIzZmRhNTIyNjk0Zjk4NTdhNGFlOTVlYjllZjdiYWEwYzQ", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-12-06T11:33:31Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-12-06T11:33:31Z"}, "message": "Merge commit 'a5d597637dcb78dc73f93561ce474f23d4177c35' into clippyup", "tree": {"sha": "d31fb39ca3aa1c174ced8e6bdd0128d5cf69125b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d31fb39ca3aa1c174ced8e6bdd0128d5cf69125b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmGt9Q4ACgkQHKDfKvWd\naKUa9xAA1Q1Exn8PCLxaXuPX5JODwjpW+yPkK5Mht4b28st9J06m6pOXombF0FmN\nYKnCGg8g+agdSxj5nIH1p3BdiqFF8sD8qDcl5ewqRASGFw4I7Sydm8SBZ/LpgIrF\nFWCB/FJGKfMkqJx4DeK2tJpLies4gMesQzeB6GhHuQilp7f5rc4GvYoS67Dzfgzb\nYL6hgihxy/F76ukOkFfyF4m5YTyzI3KRiRqJAwTfPIhImUatofuhY1jDrHO+TUMZ\n8abBCyqFHsQnXa1iPSz2ymuWcNNdZ+LVLugjHctkkNBpT+MiupvsU/wj7q5QrOTw\n+GoYVJcIiqWZMzaF9qza0WE/CSCffMLemoJoFLEeeFT9TACBkFnkZOy9ttEfpPS7\n+xpnN5GyCMqjKjPqmlcXgIo1asUNBC6ykqjrFcZBmamnuFU59b+EiMEHoAxvFQAU\nZIo0gcpNjSL+W8HO/Q7XNQQDpShKTJXZ6SwQ1ENLXsWniMB/vfzNxqSZE9ezaEyh\nZ6x88x2EiRYqO55RKYl9UreA0vVkUJmWr1Ip517nRFsOSZ4WmGKzSWCjYFRA4nyU\nqVRN6CbMo4EJOX/i6g2NEwIPr6QJ60pWnKBxUWdv4N5Tsf49F0ubAB0oDmU1spIn\nTxPcnJ1E5On4MlUBqc0B/6fYLbFhuj1RMsRrTAkcXMpxdh2U4I0=\n=VOv3\n-----END PGP SIGNATURE-----", "payload": "tree d31fb39ca3aa1c174ced8e6bdd0128d5cf69125b\nparent ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75\nparent a5d597637dcb78dc73f93561ce474f23d4177c35\nauthor flip1995 <philipp.krones@embecosm.com> 1638790411 +0100\ncommitter flip1995 <philipp.krones@embecosm.com> 1638790411 +0100\n\nMerge commit 'a5d597637dcb78dc73f93561ce474f23d4177c35' into clippyup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "html_url": "https://github.com/rust-lang/rust/commit/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "html_url": "https://github.com/rust-lang/rust/commit/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75"}, {"sha": "a5d597637dcb78dc73f93561ce474f23d4177c35", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5d597637dcb78dc73f93561ce474f23d4177c35", "html_url": "https://github.com/rust-lang/rust/commit/a5d597637dcb78dc73f93561ce474f23d4177c35"}], "stats": {"total": 13119, "additions": 9876, "deletions": 3243}, "files": [{"sha": "866303a1f9fd58d3a7e653237843ecc5dbd8db49", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/blank_issue.md", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md?ref=ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "patch": "@@ -1,18 +0,0 @@\n----\n-name: Blank Issue\n-about: Create a blank issue.\n----\n-\n-\n-<!--\n-Additional labels can be added to this issue by including the following command\n-(without the space after the @ symbol):\n-\n-@ rustbot label +<label>\n-\n-Common labels for this issue type are:\n-* C-an-interesting-project\n-* C-enhancement\n-* C-question\n-* C-tracking-issue\n--->"}, {"sha": "d610e8c7bc478ee1fc9b98ed6e0bef9debe1355a", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/blank_issue.yml", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.yml?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -0,0 +1,44 @@\n+name: Blank Issue\n+description: Create a blank issue.\n+body:\n+  - type: markdown\n+    attributes:\n+      value: Thank you for filing an issue!\n+  - type: textarea\n+    id: problem\n+    attributes:\n+      label: Description\n+      description: >\n+        Please provide a discription of the issue, along with any information\n+        you feel relevant to replicate it.\n+    validations:\n+      required: true\n+  - type: textarea\n+    id: version\n+    attributes:\n+      label: Version\n+      description: \"Rust version (`rustc -Vv`)\"\n+      placeholder: |\n+        rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+        binary: rustc\n+        commit-hash: f455e46eae1a227d735091091144601b467e1565\n+        commit-date: 2020-06-20\n+        host: x86_64-unknown-linux-gnu\n+        release: 1.46.0-nightly\n+        LLVM version: 10.0\n+      render: text\n+  - type: textarea\n+    id: labels\n+    attributes:\n+      label: Additional Labels\n+      description: >\n+        Additional labels can be added to this issue by including the following\n+        command\n+      placeholder: |\n+        @rustbot label +<label>\n+\n+        Common labels for this issue type are:\n+        * C-an-interesting-project\n+        * C-enhancement\n+        * C-question\n+        * C-tracking-issue"}, {"sha": "119a498fb99eb9fdee894f2d08b853701e5b60a0", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/bug_report.md", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "patch": "@@ -1,43 +0,0 @@\n----\n-name: Bug Report\n-about: Create a bug report for Clippy\n-labels: C-bug\n----\n-<!--\n-Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n-along with any information you feel relevant to replicating the bug.\n--->\n-\n-I tried this code:\n-\n-```rust\n-<code>\n-```\n-\n-I expected to see this happen: *explanation*\n-\n-Instead, this happened: *explanation*\n-\n-### Meta\n-\n-**Rust version (`rustc -Vv`):**\n-\n-```\n-rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n-binary: rustc\n-commit-hash: f455e46eae1a227d735091091144601b467e1565\n-commit-date: 2020-06-20\n-host: x86_64-unknown-linux-gnu\n-release: 1.46.0-nightly\n-LLVM version: 10.0\n-```\n-\n-<!--\n-Additional labels can be added to this issue by including the following command\n-(without the space after the @ symbol):\n-\n-@ rustbot label +<label>\n-\n-Common labels for this issue type are:\n-* `I-suggestion-causes-error`\n--->"}, {"sha": "68877efc9e12fbf57ce19eee38312f43738dd54e", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/bug_report.yml", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.yml?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -0,0 +1,57 @@\n+name: Bug Report\n+description: Create a bug report for Clippy\n+labels: [\"C-bug\"]\n+body:\n+  - type: markdown\n+    attributes:\n+      value: Thank you for filing a bug report! \ud83d\udc1b\n+  - type: textarea\n+    id: problem\n+    attributes:\n+      label: Summary\n+      description: >\n+        Please provide a short summary of the bug, along with any information\n+        you feel relevant to replicate the bug.\n+    validations:\n+      required: true\n+  - type: textarea\n+    id: reproducer\n+    attributes:\n+      label: Reproducer\n+      description: Please provide the code and steps to repoduce the bug\n+      value: |\n+        I tried this code:\n+\n+        ```rust\n+        <code>\n+        ```\n+\n+        I expected to see this happen:\n+\n+        Instead, this happened:\n+  - type: textarea\n+    id: version\n+    attributes:\n+      label: Version\n+      description: \"Rust version (`rustc -Vv`)\"\n+      placeholder: |\n+        rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+        binary: rustc\n+        commit-hash: f455e46eae1a227d735091091144601b467e1565\n+        commit-date: 2020-06-20\n+        host: x86_64-unknown-linux-gnu\n+        release: 1.46.0-nightly\n+        LLVM version: 10.0\n+      render: text\n+  - type: textarea\n+    id: labels\n+    attributes:\n+      label: Additional Labels\n+      description: >\n+        Additional labels can be added to this issue by including the following\n+        command\n+      placeholder: |\n+        @rustbot label +<label>\n+\n+        Common labels for this issue type are:\n+        * `I-suggestion-causes-error`"}, {"sha": "d9ea2db34edd7cf74a9789f17801005a3e0762e9", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/false_negative.md", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_negative.md", "raw_url": "https://github.com/rust-lang/rust/raw/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_negative.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_negative.md?ref=ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "patch": "@@ -1,35 +0,0 @@\n----\n-name: Bug Report (False Negative)\n-about: Create a bug report about missing warnings from a lint\n-labels: C-bug, I-false-negative\n----\n-<!--\n-Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n-along with any information you feel relevant to replicating the bug.\n--->\n-Lint name:\n-\n-\n-I tried this code:\n-\n-```rust\n-<code>\n-```\n-\n-I expected to see this happen: *explanation*\n-\n-Instead, this happened: *explanation*\n-\n-### Meta\n-\n-**Rust version (`rustc -Vv`):**\n-\n-```\n-rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n-binary: rustc\n-commit-hash: f455e46eae1a227d735091091144601b467e1565\n-commit-date: 2020-06-20\n-host: x86_64-unknown-linux-gnu\n-release: 1.46.0-nightly\n-LLVM version: 10.0\n-```"}, {"sha": "9357ccc4f4e76f26d013ac115fae3fba71a175c6", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/false_negative.yml", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_negative.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_negative.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_negative.yml?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -0,0 +1,50 @@\n+name: Bug Report (False Negative)\n+description: Create a bug report about missing warnings from a lint\n+labels: [\"C-bug\", \"I-false-negative\"]\n+body:\n+  - type: markdown\n+    attributes:\n+      value: Thank you for filing a bug report! \ud83d\udc1b\n+  - type: textarea\n+    id: problem\n+    attributes:\n+      label: Summary\n+      description: >\n+        Please provide a short summary of the bug, along with any information\n+        you feel relevant to replicate the bug.\n+    validations:\n+      required: true\n+  - type: input\n+    id: lint-name\n+    attributes:\n+      label: Lint Name\n+      description: Please provide the lint name.\n+  - type: textarea\n+    id: reproducer\n+    attributes:\n+      label: Reproducer\n+      description: Please provide the code and steps to repoduce the bug\n+      value: |\n+        I tried this code:\n+\n+        ```rust\n+        <code>\n+        ```\n+\n+        I expected to see this happen:\n+\n+        Instead, this happened:\n+  - type: textarea\n+    id: version\n+    attributes:\n+      label: Version\n+      description: \"Rust version (`rustc -Vv`)\"\n+      placeholder: |\n+        rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+        binary: rustc\n+        commit-hash: f455e46eae1a227d735091091144601b467e1565\n+        commit-date: 2020-06-20\n+        host: x86_64-unknown-linux-gnu\n+        release: 1.46.0-nightly\n+        LLVM version: 10.0\n+      render: text"}, {"sha": "82158e02f085eacc65c248fb3e86e68a24f7aad7", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/false_positive.md", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_positive.md", "raw_url": "https://github.com/rust-lang/rust/raw/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_positive.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_positive.md?ref=ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "patch": "@@ -1,44 +0,0 @@\n----\n-name: Bug Report (False Positive)\n-about: Create a bug report about a wrongly emitted lint warning\n-labels: C-bug, I-false-positive\n----\n-<!--\n-Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n-along with any information you feel relevant to replicating the bug.\n--->\n-Lint name:\n-\n-\n-I tried this code:\n-\n-```rust\n-<code>\n-```\n-\n-I expected to see this happen: *explanation*\n-\n-Instead, this happened: *explanation*\n-\n-### Meta\n-\n-**Rust version (`rustc -Vv`):**\n-```\n-rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n-binary: rustc\n-commit-hash: f455e46eae1a227d735091091144601b467e1565\n-commit-date: 2020-06-20\n-host: x86_64-unknown-linux-gnu\n-release: 1.46.0-nightly\n-LLVM version: 10.0\n-```\n-\n-<!--\n-Additional labels can be added to this issue by including the following command\n-(without the space after the @ symbol):\n-\n-@ rustbot label +<label>\n-\n-Common labels for this issue type are:\n-* I-suggestion-causes-error\n--->"}, {"sha": "b7dd400ee7333efa6ea35295abb6e2624519128d", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/false_positive.yml", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_positive.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_positive.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Ffalse_positive.yml?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -0,0 +1,68 @@\n+name: Bug Report (False Positive)\n+description: Create a bug report about a wrongly emitted lint warning\n+labels: [\"C-bug\", \"I-false-positive\"]\n+body:\n+  - type: markdown\n+    attributes:\n+      value: Thank you for filing a bug report! \ud83d\udc1b\n+  - type: textarea\n+    id: problem\n+    attributes:\n+      label: Summary\n+      description: >\n+        Please provide a short summary of the bug, along with any information\n+        you feel relevant to replicate the bug.\n+    validations:\n+      required: true\n+  - type: input\n+    id: lint-name\n+    attributes:\n+      label: Lint Name\n+      description: Please provide the lint name.\n+  - type: textarea\n+    id: reproducer\n+    attributes:\n+      label: Reproducer\n+      description: >\n+        Please provide the code and steps to repoduce the bug together with the\n+        output from Clippy.\n+      value: |\n+        I tried this code:\n+\n+        ```rust\n+        <code>\n+        ```\n+\n+        I saw this happen:\n+\n+        ```\n+        <output>\n+        ```\n+\n+        I expected to see this happen:\n+  - type: textarea\n+    id: version\n+    attributes:\n+      label: Version\n+      description: \"Rust version (`rustc -Vv`)\"\n+      placeholder: |\n+        rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+        binary: rustc\n+        commit-hash: f455e46eae1a227d735091091144601b467e1565\n+        commit-date: 2020-06-20\n+        host: x86_64-unknown-linux-gnu\n+        release: 1.46.0-nightly\n+        LLVM version: 10.0\n+      render: text\n+  - type: textarea\n+    id: labels\n+    attributes:\n+      label: Additional Labels\n+      description: >\n+        Additional labels can be added to this issue by including the following\n+        command\n+      placeholder: |\n+        @rustbot label +<label>\n+\n+        Common labels for this issue type are:\n+        * `I-suggestion-causes-error`"}, {"sha": "6c1bed663c6cb37f74bb9dfd9f4226560bc8837c", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/ice.md", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fice.md?ref=ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "patch": "@@ -1,52 +0,0 @@\n----\n-name: Internal Compiler Error\n-about: Create a report for an internal compiler error in Clippy.\n-labels: C-bug, I-ICE\n----\n-<!--\n-Thank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\n-a minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\n-how to create smaller examples.\n-\n-http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n-\n--->\n-\n-### Code\n-\n-```rust\n-<code>\n-```\n-\n-### Meta\n-\n-**Rust version (`rustc -Vv`):**\n-```\n-rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n-binary: rustc\n-commit-hash: f455e46eae1a227d735091091144601b467e1565\n-commit-date: 2020-06-20\n-host: x86_64-unknown-linux-gnu\n-release: 1.46.0-nightly\n-LLVM version: 10.0\n-```\n-\n-### Error output\n-\n-```\n-<output>\n-```\n-\n-<!--\n-Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\n-environment. E.g. `RUST_BACKTRACE=1 cargo clippy`.\n--->\n-<details><summary>Backtrace</summary>\n-  <p>\n-  \n-  ```\n-  <backtrace>\n-  ```\n-  \n-  </p>\n-</details>"}, {"sha": "2a5b8b3c8914163382f63d964f5d14d9cdb3dbe6", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/ice.yml", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fice.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fice.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fice.yml?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -0,0 +1,48 @@\n+name: Internal Compiler Error\n+description: Create a report for an internal compiler error (ICE) in Clippy.\n+labels: [\"C-bug\", \"I-ICE\"]\n+body:\n+  - type: markdown\n+    attributes:\n+      value: Thank you for finding an Internal Compiler Error! \ud83e\uddca\n+  - type: textarea\n+    id: problem\n+    attributes:\n+      label: Summary\n+      description: |\n+        If possible, try to provide a minimal verifiable example. You can read [\"Rust Bug Minimization Patterns\"][mve] for how to create smaller examples. Otherwise, provide the crate where the ICE occured.\n+\n+        [mve]: http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n+    validations:\n+      required: true\n+  - type: textarea\n+    id: version\n+    attributes:\n+      label: Version\n+      description: \"Rust version (`rustc -Vv`)\"\n+      placeholder: |\n+        rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+        binary: rustc\n+        commit-hash: f455e46eae1a227d735091091144601b467e1565\n+        commit-date: 2020-06-20\n+        host: x86_64-unknown-linux-gnu\n+        release: 1.46.0-nightly\n+        LLVM version: 10.0\n+      render: text\n+  - type: textarea\n+    id: error\n+    attributes:\n+      label: Error output\n+      description: >\n+        Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in\n+        your environment. E.g. `RUST_BACKTRACE=1 cargo clippy`.\n+      value: |\n+        <details><summary>Backtrace</summary>\n+          <p>\n+\n+          ```\n+          <backtrace>\n+          ```\n+\n+          </p>\n+        </details>"}, {"sha": "2216bb9f293d790506a5d116b4120018a34306a0", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/new_lint.md", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.md", "raw_url": "https://github.com/rust-lang/rust/raw/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.md?ref=ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "patch": "@@ -1,36 +0,0 @@\n----\n-name: New lint suggestion\n-about: Suggest a new Clippy lint.\n-labels: A-lint\n----\n-\n-### What it does\n-\n-*What does this lint do?*\n-\n-### Categories (optional)\n-\n-- Kind: *See <https://github.com/rust-lang/rust-clippy/blob/master/README.md#clippy> for list of lint kinds*\n-\n-*What is the advantage of the recommended code over the original code*\n-\n-For example:\n-- Remove bounds check inserted by ...\n-- Remove the need to duplicate/store ...\n-- Remove typo ...\n-\n-### Drawbacks\n-\n-None.\n-\n-### Example\n-\n-```rust\n-<code>\n-```\n-\n-Could be written as:\n-\n-```rust\n-<code>\n-```"}, {"sha": "0b43d8d70c007ab46645b2fe1085ef84953a6d6b", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/new_lint.yml", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.yml?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -0,0 +1,71 @@\n+name: New lint suggestion\n+description: Suggest a new Clippy lint.\n+labels: [\"A-lint\"]\n+body:\n+  - type: markdown\n+    attributes:\n+      value: Thank you for your lint idea!\n+  - type: textarea\n+    id: what\n+    attributes:\n+      label: What it does\n+      description: What does this lint do?\n+    validations:\n+      required: true\n+  - type: input\n+    id: lint-name\n+    attributes:\n+      label: Lint Name\n+      description: Please provide the lint name.\n+  - type: dropdown\n+    id: category\n+    attributes:\n+      label: Category\n+      description: >\n+        What category should this lint go into? If you're unsure you can select\n+        multiple categories. You can find a category description in the\n+        `README`.\n+      multiple: true\n+      options:\n+        - correctness\n+        - suspicious\n+        - style\n+        - complexity\n+        - perf\n+        - pedantic\n+        - restriction\n+        - cargo\n+  - type: textarea\n+    id: advantage\n+    attributes:\n+      label: Advantage\n+      description: >\n+        What is the advantage of the recommended code over the original code?\n+      placeholder: |\n+        - Remove bounds check inserted by ...\n+        - Remove the need to duplicate/store ...\n+        - Remove typo ...\n+  - type: textarea\n+    id: drawbacks\n+    attributes:\n+      label: Drawbacks\n+      description: What might be possible drawbacks of such a lint?\n+  - type: textarea\n+    id: example\n+    attributes:\n+      label: Example\n+      description: >\n+        Include a short example showing when the lint should trigger together\n+        with the improved code.\n+      value: |\n+        ```rust\n+        <code>\n+        ```\n+\n+        Could be written as:\n+\n+        ```rust\n+        <code>\n+        ```\n+    validations:\n+      required: true"}, {"sha": "fe8bce00fa82e162ebcffca2944482dcefe1ffe9", "filename": "src/tools/clippy/.github/workflows/clippy_dev.yml", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -25,18 +25,6 @@ jobs:\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n \n-    - name: remove toolchain file\n-      run: rm rust-toolchain\n-\n-    - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.6\n-      with:\n-        toolchain: nightly\n-        target: x86_64-unknown-linux-gnu\n-        profile: minimal\n-        components: rustfmt\n-        default: true\n-\n     # Run\n     - name: Build\n       run: cargo build --features deny-warnings"}, {"sha": "157ea0c963afc5d1d8748ebe79ce250c2343914d", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -70,7 +70,7 @@ Current beta, release 2021-12-02\n   [#7560](https://github.com/rust-lang/rust-clippy/pull/7560)\n * [`unnecessary_unwrap`]: Now also checks for `expect`s\n   [#7584](https://github.com/rust-lang/rust-clippy/pull/7584)\n-* [`disallowed_method`]: Allow adding a reason that will be displayed with the\n+* [`disallowed_methods`]: Allow adding a reason that will be displayed with the\n   lint message\n   [#7621](https://github.com/rust-lang/rust-clippy/pull/7621)\n * [`approx_constant`]: Now checks the MSRV for `LOG10_2` and `LOG2_10`\n@@ -174,7 +174,7 @@ Current stable, released 2021-10-21\n \n * [`needless_continue`]: Now also lints in `loop { continue; }` case\n   [#7477](https://github.com/rust-lang/rust-clippy/pull/7477)\n-* [`disallowed_type`]: Now also primitive types can be disallowed\n+* [`disallowed_types`]: Now also primitive types can be disallowed\n   [#7488](https://github.com/rust-lang/rust-clippy/pull/7488)\n * [`manual_swap`]: Now also lints on xor swaps\n   [#7506](https://github.com/rust-lang/rust-clippy/pull/7506)\n@@ -248,7 +248,7 @@ Released 2021-09-09\n   [#7403](https://github.com/rust-lang/rust-clippy/pull/7403)\n * [`disallowed_script_idents`]\n   [#7400](https://github.com/rust-lang/rust-clippy/pull/7400)\n-* [`disallowed_type`]\n+* [`disallowed_types`]\n   [#7315](https://github.com/rust-lang/rust-clippy/pull/7315)\n * [`missing_enforced_import_renames`]\n   [#7300](https://github.com/rust-lang/rust-clippy/pull/7300)\n@@ -294,7 +294,7 @@ Released 2021-09-09\n   [#7379](https://github.com/rust-lang/rust-clippy/pull/7379)\n * [`redundant_closure`]: Suggests `&mut` for `FnMut`\n   [#7437](https://github.com/rust-lang/rust-clippy/pull/7437)\n-* [`disallowed_method`], [`disallowed_type`]: The configuration values `disallowed-method` and `disallowed-type`\n+* [`disallowed_methods`], [`disallowed_types`]: The configuration values `disallowed-method` and `disallowed-type`\n   no longer require fully qualified paths\n   [#7345](https://github.com/rust-lang/rust-clippy/pull/7345)\n * [`zst_offset`]: Fixed lint invocation after it was accidentally suppressed\n@@ -703,7 +703,7 @@ Released 2021-05-06\n \n ### Enhancements\n \n-* [`disallowed_method`]: Now supports functions in addition to methods\n+* [`disallowed_methods`]: Now supports functions in addition to methods\n   [#6674](https://github.com/rust-lang/rust-clippy/pull/6674)\n * [`upper_case_acronyms`]: Added a new configuration `upper-case-acronyms-aggressive` to\n   trigger the lint if there is more than one uppercase character next to each other\n@@ -1044,7 +1044,7 @@ Released 2020-12-31\n \n * [`field_reassign_with_default`] [#5911](https://github.com/rust-lang/rust-clippy/pull/5911)\n * [`await_holding_refcell_ref`] [#6029](https://github.com/rust-lang/rust-clippy/pull/6029)\n-* [`disallowed_method`] [#6081](https://github.com/rust-lang/rust-clippy/pull/6081)\n+* [`disallowed_methods`] [#6081](https://github.com/rust-lang/rust-clippy/pull/6081)\n * [`inline_asm_x86_att_syntax`] [#6092](https://github.com/rust-lang/rust-clippy/pull/6092)\n * [`inline_asm_x86_intel_syntax`] [#6092](https://github.com/rust-lang/rust-clippy/pull/6092)\n * [`from_iter_instead_of_collect`] [#6101](https://github.com/rust-lang/rust-clippy/pull/6101)\n@@ -2821,9 +2821,9 @@ Released 2018-09-13\n [`derivable_impls`]: https://rust-lang.github.io/rust-clippy/master/index.html#derivable_impls\n [`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n [`derive_ord_xor_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_ord_xor_partial_ord\n-[`disallowed_method`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_method\n+[`disallowed_methods`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_methods\n [`disallowed_script_idents`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_script_idents\n-[`disallowed_type`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_type\n+[`disallowed_types`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_types\n [`diverging_sub_expression`]: https://rust-lang.github.io/rust-clippy/master/index.html#diverging_sub_expression\n [`doc_markdown`]: https://rust-lang.github.io/rust-clippy/master/index.html#doc_markdown\n [`double_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_comparisons\n@@ -2904,6 +2904,7 @@ Released 2018-09-13\n [`imprecise_flops`]: https://rust-lang.github.io/rust-clippy/master/index.html#imprecise_flops\n [`inconsistent_digit_grouping`]: https://rust-lang.github.io/rust-clippy/master/index.html#inconsistent_digit_grouping\n [`inconsistent_struct_constructor`]: https://rust-lang.github.io/rust-clippy/master/index.html#inconsistent_struct_constructor\n+[`index_refutable_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#index_refutable_slice\n [`indexing_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#indexing_slicing\n [`ineffective_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#ineffective_bit_mask\n [`inefficient_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#inefficient_to_string\n@@ -3032,12 +3033,14 @@ Released 2018-09-13\n [`needless_continue`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_continue\n [`needless_doctest_main`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_doctest_main\n [`needless_for_each`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_for_each\n+[`needless_late_init`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_late_init\n [`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n [`needless_option_as_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_option_as_deref\n [`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n [`needless_question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark\n [`needless_range_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_range_loop\n [`needless_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_return\n+[`needless_splitn`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_splitn\n [`needless_update`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_update\n [`neg_cmp_op_on_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#neg_cmp_op_on_partial_ord\n [`neg_multiply`]: https://rust-lang.github.io/rust-clippy/master/index.html#neg_multiply\n@@ -3054,6 +3057,7 @@ Released 2018-09-13\n [`nonsensical_open_options`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonsensical_open_options\n [`nonstandard_macro_braces`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonstandard_macro_braces\n [`not_unsafe_ptr_arg_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n+[`octal_escapes`]: https://rust-lang.github.io/rust-clippy/master/index.html#octal_escapes\n [`ok_expect`]: https://rust-lang.github.io/rust-clippy/master/index.html#ok_expect\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref"}, {"sha": "8661a86775887285bc953c4ec7afbbb68a313830", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.58\"\n+version = \"0.1.59\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n@@ -47,6 +47,7 @@ itertools = \"0.10\"\n quote = \"1.0\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n syn = { version = \"1.0\", features = [\"full\"] }\n+parking_lot = \"0.11.2\"\n \n [build-dependencies]\n rustc_tools_util = { version = \"0.2\", path = \"rustc_tools_util\" }"}, {"sha": "d350d9a001827e899b183fc19bcf5952eb43bb29", "filename": "src/tools/clippy/clippy_dev/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -12,6 +12,7 @@ opener = \"0.5\"\n regex = \"1.5\"\n shell-escape = \"0.1\"\n walkdir = \"2.3\"\n+cargo_metadata = \"0.14\"\n \n [features]\n deny-warnings = []"}, {"sha": "9ceadee58ea5981777ff171d7a94ad7c9f09e41d", "filename": "src/tools/clippy/clippy_dev/src/fmt.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,7 @@\n use crate::clippy_project_root;\n+use itertools::Itertools;\n use shell_escape::escape;\n-use std::ffi::OsStr;\n+use std::ffi::{OsStr, OsString};\n use std::path::Path;\n use std::process::{self, Command};\n use std::{fs, io};\n@@ -56,15 +57,22 @@ pub fn run(check: bool, verbose: bool) {\n         success &= cargo_fmt(context, &project_root.join(\"rustc_tools_util\"))?;\n         success &= cargo_fmt(context, &project_root.join(\"lintcheck\"))?;\n \n-        for entry in WalkDir::new(project_root.join(\"tests\")) {\n-            let entry = entry?;\n-            let path = entry.path();\n-\n-            if path.extension() != Some(\"rs\".as_ref()) || entry.file_name() == \"ice-3891.rs\" {\n-                continue;\n-            }\n-\n-            success &= rustfmt(context, path)?;\n+        let chunks = WalkDir::new(project_root.join(\"tests\"))\n+            .into_iter()\n+            .filter_map(|entry| {\n+                let entry = entry.expect(\"failed to find tests\");\n+                let path = entry.path();\n+\n+                if path.extension() != Some(\"rs\".as_ref()) || entry.file_name() == \"ice-3891.rs\" {\n+                    None\n+                } else {\n+                    Some(entry.into_path().into_os_string())\n+                }\n+            })\n+            .chunks(250);\n+\n+        for chunk in &chunks {\n+            success &= rustfmt(context, chunk)?;\n         }\n \n         Ok(success)\n@@ -149,7 +157,7 @@ fn exec(\n }\n \n fn cargo_fmt(context: &FmtContext, path: &Path) -> Result<bool, CliError> {\n-    let mut args = vec![\"+nightly\", \"fmt\", \"--all\"];\n+    let mut args = vec![\"fmt\", \"--all\"];\n     if context.check {\n         args.push(\"--\");\n         args.push(\"--check\");\n@@ -162,7 +170,7 @@ fn cargo_fmt(context: &FmtContext, path: &Path) -> Result<bool, CliError> {\n fn rustfmt_test(context: &FmtContext) -> Result<(), CliError> {\n     let program = \"rustfmt\";\n     let dir = std::env::current_dir()?;\n-    let args = &[\"+nightly\", \"--version\"];\n+    let args = &[\"--version\"];\n \n     if context.verbose {\n         println!(\"{}\", format_command(&program, &dir, args));\n@@ -185,14 +193,14 @@ fn rustfmt_test(context: &FmtContext) -> Result<(), CliError> {\n     }\n }\n \n-fn rustfmt(context: &FmtContext, path: &Path) -> Result<bool, CliError> {\n-    let mut args = vec![\"+nightly\".as_ref(), path.as_os_str()];\n+fn rustfmt(context: &FmtContext, paths: impl Iterator<Item = OsString>) -> Result<bool, CliError> {\n+    let mut args = Vec::new();\n     if context.check {\n-        args.push(\"--check\".as_ref());\n+        args.push(OsString::from(\"--check\"));\n     }\n+    args.extend(paths);\n+\n     let success = exec(context, \"rustfmt\", std::env::current_dir()?, &args)?;\n-    if !success {\n-        eprintln!(\"rustfmt failed on {}\", path.display());\n-    }\n+\n     Ok(success)\n }"}, {"sha": "59fde447547145f3093b5054112bd58dd6ec8b7e", "filename": "src/tools/clippy/clippy_dev/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -7,6 +7,7 @@ use std::path::PathBuf;\n \n pub mod bless;\n pub mod fmt;\n+pub mod lint;\n pub mod new_lint;\n pub mod serve;\n pub mod setup;"}, {"sha": "dfd16f7105438c3b8df74cf26b875e8491509675", "filename": "src/tools/clippy/clippy_dev/src/lint.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flint.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -0,0 +1,20 @@\n+use std::process::{self, Command};\n+\n+pub fn run(filename: &str) {\n+    let code = Command::new(\"cargo\")\n+        .args([\"run\", \"--bin\", \"clippy-driver\", \"--\"])\n+        .args([\"-L\", \"./target/debug\"])\n+        .args([\"-Z\", \"no-codegen\"])\n+        .args([\"--edition\", \"2021\"])\n+        .arg(filename)\n+        .env(\"__CLIPPY_INTERNAL_TESTS\", \"true\")\n+        .status()\n+        .expect(\"failed to run cargo\")\n+        .code();\n+\n+    if code.is_none() {\n+        eprintln!(\"Killed by signal\");\n+    }\n+\n+    process::exit(code.unwrap_or(1));\n+}"}, {"sha": "30a241c8ba151e1cfa3b1385156f13ddd892eb06", "filename": "src/tools/clippy/clippy_dev/src/main.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -3,7 +3,7 @@\n #![warn(rust_2018_idioms, unused_lifetimes)]\n \n use clap::{App, AppSettings, Arg, ArgMatches, SubCommand};\n-use clippy_dev::{bless, fmt, new_lint, serve, setup, update_lints};\n+use clippy_dev::{bless, fmt, lint, new_lint, serve, setup, update_lints};\n fn main() {\n     let matches = get_clap_config();\n \n@@ -55,6 +55,10 @@ fn main() {\n             let lint = matches.value_of(\"lint\");\n             serve::run(port, lint);\n         },\n+        (\"lint\", Some(matches)) => {\n+            let filename = matches.value_of(\"filename\").unwrap();\n+            lint::run(filename);\n+        },\n         _ => {},\n     }\n }\n@@ -219,5 +223,14 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                 )\n                 .arg(Arg::with_name(\"lint\").help(\"Which lint's page to load initially (optional)\")),\n         )\n+        .subcommand(\n+            SubCommand::with_name(\"lint\")\n+                .about(\"Manually run clippy on a file\")\n+                .arg(\n+                    Arg::with_name(\"filename\")\n+                        .required(true)\n+                        .help(\"The path to a file to lint\"),\n+                ),\n+        )\n         .get_matches()\n }"}, {"sha": "59658b42c79b14405773817052214034e13cedbc", "filename": "src/tools/clippy/clippy_dev/src/new_lint.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -132,6 +132,18 @@ fn to_camel_case(name: &str) -> String {\n         .collect()\n }\n \n+fn get_stabilisation_version() -> String {\n+    let mut command = cargo_metadata::MetadataCommand::new();\n+    command.no_deps();\n+    if let Ok(metadata) = command.exec() {\n+        if let Some(pkg) = metadata.packages.iter().find(|pkg| pkg.name == \"clippy\") {\n+            return format!(\"{}.{}.0\", pkg.version.minor, pkg.version.patch);\n+        }\n+    }\n+\n+    String::from(\"<TODO set version(see doc/adding_lints.md)>\")\n+}\n+\n fn get_test_file_contents(lint_name: &str, header_commands: Option<&str>) -> String {\n     let mut contents = format!(\n         indoc! {\"\n@@ -178,6 +190,7 @@ fn get_lint_file_contents(lint: &LintData<'_>, enable_msrv: bool) -> String {\n         },\n     };\n \n+    let version = get_stabilisation_version();\n     let lint_name = lint.name;\n     let category = lint.category;\n     let name_camel = to_camel_case(lint.name);\n@@ -212,7 +225,7 @@ fn get_lint_file_contents(lint: &LintData<'_>, enable_msrv: bool) -> String {\n     });\n \n     result.push_str(&format!(\n-        indoc! {\"\n+        indoc! {r#\"\n             declare_clippy_lint! {{\n                 /// ### What it does\n                 ///\n@@ -226,11 +239,13 @@ fn get_lint_file_contents(lint: &LintData<'_>, enable_msrv: bool) -> String {\n                 /// ```rust\n                 /// // example code which does not raise clippy warning\n                 /// ```\n+                #[clippy::version = \"{version}\"]\n                 pub {name_upper},\n                 {category},\n-                \\\"default lint description\\\"\n+                \"default lint description\"\n             }}\n-        \"},\n+        \"#},\n+        version = version,\n         name_upper = name_upper,\n         category = category,\n     ));"}, {"sha": "8dd073ef405a172960a8886488ec61b183c6d906", "filename": "src/tools/clippy/clippy_dev/src/update_lints.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -18,6 +18,7 @@ static DEC_CLIPPY_LINT_RE: SyncLazy<Regex> = SyncLazy::new(|| {\n         r#\"(?x)\n     declare_clippy_lint!\\s*[\\{(]\n     (?:\\s+///.*)*\n+    (?:\\s*\\#\\[clippy::version\\s*=\\s*\"[^\"]*\"\\])?\n     \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n     (?P<cat>[a-z_]+)\\s*,\\s*\n     \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n@@ -31,6 +32,7 @@ static DEC_DEPRECATED_LINT_RE: SyncLazy<Regex> = SyncLazy::new(|| {\n         r#\"(?x)\n     declare_deprecated_lint!\\s*[{(]\\s*\n     (?:\\s+///.*)*\n+    (?:\\s*\\#\\[clippy::version\\s*=\\s*\"[^\"]*\"\\])?\n     \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n     \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n \"#,\n@@ -495,20 +497,23 @@ fn test_parse_contents() {\n     let result: Vec<Lint> = parse_contents(\n         r#\"\n declare_clippy_lint! {\n+    #[clippy::version = \"Hello Clippy!\"]\n     pub PTR_ARG,\n     style,\n     \"really long \\\n      text\"\n }\n \n declare_clippy_lint!{\n+    #[clippy::version = \"Test version\"]\n     pub DOC_MARKDOWN,\n     pedantic,\n     \"single line\"\n }\n \n /// some doc comment\n declare_deprecated_lint! {\n+    #[clippy::version = \"I'm a version\"]\n     pub SHOULD_ASSERT_EQ,\n     \"`assert!()` will be more flexible with RFC 2011\"\n }"}, {"sha": "0661c2803864c15545b050f15a2ddb9a3fd43634", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_lints\"\n-version = \"0.1.58\"\n+version = \"0.1.59\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "7665aa8380b3c396594f5af3a066bd9b72eef463", "filename": "src/tools/clippy/clippy_lints/src/absurd_extreme_comparisons.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -36,6 +36,7 @@ declare_clippy_lint! {\n     /// if vec.len() <= 0 {}\n     /// if 100 > i32::MAX {}\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ABSURD_EXTREME_COMPARISONS,\n     correctness,\n     \"a comparison with a maximum or minimum value that is always true or false\""}, {"sha": "12435eefbc4eeaf89816d09a1493c8049f85c61b", "filename": "src/tools/clippy/clippy_lints/src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fapprox_const.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -33,6 +33,7 @@ declare_clippy_lint! {\n     /// let x = std::f32::consts::PI;\n     /// let y = std::f64::consts::FRAC_1_PI;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub APPROX_CONSTANT,\n     correctness,\n     \"the approximate of a known float constant (in `std::fXX::consts`)\""}, {"sha": "e0c1d6ab6e12235577859c606f9e572dcbaf9f0f", "filename": "src/tools/clippy/clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -25,6 +25,7 @@ declare_clippy_lint! {\n     /// # let a = 0;\n     /// a + 1;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub INTEGER_ARITHMETIC,\n     restriction,\n     \"any integer arithmetic expression which could overflow or panic\"\n@@ -43,6 +44,7 @@ declare_clippy_lint! {\n     /// # let a = 0.0;\n     /// a + 1.0;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub FLOAT_ARITHMETIC,\n     restriction,\n     \"any floating-point arithmetic statement\""}, {"sha": "53704da1046bcf236a5a511c0b83a5557b6ba4ab", "filename": "src/tools/clippy/clippy_lints/src/as_conversions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fas_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fas_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fas_conversions.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -38,6 +38,7 @@ declare_clippy_lint! {\n     /// f(a.try_into().expect(\"Unexpected u16 overflow in f\"));\n     /// ```\n     ///\n+    #[clippy::version = \"1.41.0\"]\n     pub AS_CONVERSIONS,\n     restriction,\n     \"using a potentially dangerous silent `as` conversion\""}, {"sha": "0322698f029556d3e0fc341ddc3e4f2df3f9db42", "filename": "src/tools/clippy/clippy_lints/src/asm_syntax.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fasm_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fasm_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fasm_syntax.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -75,6 +75,7 @@ declare_clippy_lint! {\n     /// asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n     /// # }\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub INLINE_ASM_X86_INTEL_SYNTAX,\n     restriction,\n     \"prefer AT&T x86 assembly syntax\"\n@@ -111,6 +112,7 @@ declare_clippy_lint! {\n     /// asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n     /// # }\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub INLINE_ASM_X86_ATT_SYNTAX,\n     restriction,\n     \"prefer Intel x86 assembly syntax\""}, {"sha": "521fc84ee9c375ae3d74416afd0b8a60bb1fc86c", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -26,6 +26,7 @@ declare_clippy_lint! {\n     /// const B: bool = false;\n     /// assert!(B)\n     /// ```\n+    #[clippy::version = \"1.34.0\"]\n     pub ASSERTIONS_ON_CONSTANTS,\n     style,\n     \"`assert!(true)` / `assert!(false)` will be optimized out by the compiler, and should probably be replaced by a `panic!()` or `unreachable!()`\""}, {"sha": "e16f4369da9fcdd488063d232f2f70890e86bef4", "filename": "src/tools/clippy/clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -34,6 +34,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// a += b;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ASSIGN_OP_PATTERN,\n     style,\n     \"assigning the result of an operation on a variable to that same variable\"\n@@ -60,6 +61,7 @@ declare_clippy_lint! {\n     /// // ...\n     /// a += a + b;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MISREFACTORED_ASSIGN_OP,\n     suspicious,\n     \"having a variable on both sides of an assign op\""}, {"sha": "0619490e73c4361da3284406b0b8bdceff50a128", "filename": "src/tools/clippy/clippy_lints/src/async_yields_async.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fasync_yields_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fasync_yields_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fasync_yields_async.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -34,6 +34,7 @@ declare_clippy_lint! {\n     ///   };\n     /// }\n     /// ```\n+    #[clippy::version = \"1.48.0\"]\n     pub ASYNC_YIELDS_ASYNC,\n     correctness,\n     \"async blocks that return a type that can be awaited\""}, {"sha": "1edb7c950e7b1d0bd141654178cf032d731b3a59", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,8 +1,9 @@\n //! checks for attributes\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::match_panic_def_id;\n+use clippy_utils::msrvs;\n use clippy_utils::source::{first_line_of_span, is_present_in_source, snippet_opt, without_block_comments};\n+use clippy_utils::{extract_msrv_attr, match_panic_def_id, meets_msrv};\n use if_chain::if_chain;\n use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_errors::Applicability;\n@@ -12,7 +13,8 @@ use rustc_hir::{\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::sym;\n use rustc_span::symbol::{Symbol, SymbolStr};\n@@ -64,6 +66,7 @@ declare_clippy_lint! {\n     /// #[inline(always)]\n     /// fn not_quite_hot_code(..) { ... }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub INLINE_ALWAYS,\n     pedantic,\n     \"use of `#[inline(always)]`\"\n@@ -98,6 +101,7 @@ declare_clippy_lint! {\n     /// #[macro_use]\n     /// extern crate baz;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub USELESS_ATTRIBUTE,\n     correctness,\n     \"use of lint attributes on `extern crate` items\"\n@@ -117,6 +121,7 @@ declare_clippy_lint! {\n     /// #[deprecated(since = \"forever\")]\n     /// fn something_else() { /* ... */ }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DEPRECATED_SEMVER,\n     correctness,\n     \"use of `#[deprecated(since = \\\"x\\\")]` where x is not semver\"\n@@ -154,6 +159,7 @@ declare_clippy_lint! {\n     /// #[allow(dead_code)]\n     /// fn this_is_fine_too() { }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EMPTY_LINE_AFTER_OUTER_ATTR,\n     nursery,\n     \"empty line after outer attribute\"\n@@ -177,6 +183,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// #![deny(clippy::as_conversions)]\n     /// ```\n+    #[clippy::version = \"1.47.0\"]\n     pub BLANKET_CLIPPY_RESTRICTION_LINTS,\n     suspicious,\n     \"enabling the complete restriction group\"\n@@ -208,6 +215,7 @@ declare_clippy_lint! {\n     /// #[rustfmt::skip]\n     /// fn main() { }\n     /// ```\n+    #[clippy::version = \"1.32.0\"]\n     pub DEPRECATED_CFG_ATTR,\n     complexity,\n     \"usage of `cfg_attr(rustfmt)` instead of tool attributes\"\n@@ -240,6 +248,7 @@ declare_clippy_lint! {\n     /// fn conditional() { }\n     /// ```\n     /// Check the [Rust Reference](https://doc.rust-lang.org/reference/conditional-compilation.html#target_os) for more details.\n+    #[clippy::version = \"1.45.0\"]\n     pub MISMATCHED_TARGET_OS,\n     correctness,\n     \"usage of `cfg(operating_system)` instead of `cfg(target_os = \\\"operating_system\\\")`\"\n@@ -497,7 +506,11 @@ fn is_word(nmi: &NestedMetaItem, expected: Symbol) -> bool {\n     }\n }\n \n-declare_lint_pass!(EarlyAttributes => [\n+pub struct EarlyAttributes {\n+    pub msrv: Option<RustcVersion>,\n+}\n+\n+impl_lint_pass!(EarlyAttributes => [\n     DEPRECATED_CFG_ATTR,\n     MISMATCHED_TARGET_OS,\n     EMPTY_LINE_AFTER_OUTER_ATTR,\n@@ -509,9 +522,11 @@ impl EarlyLintPass for EarlyAttributes {\n     }\n \n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &Attribute) {\n-        check_deprecated_cfg_attr(cx, attr);\n+        check_deprecated_cfg_attr(cx, attr, self.msrv);\n         check_mismatched_target_os(cx, attr);\n     }\n+\n+    extract_msrv_attr!(EarlyContext);\n }\n \n fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::Item) {\n@@ -548,8 +563,9 @@ fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::It\n     }\n }\n \n-fn check_deprecated_cfg_attr(cx: &EarlyContext<'_>, attr: &Attribute) {\n+fn check_deprecated_cfg_attr(cx: &EarlyContext<'_>, attr: &Attribute, msrv: Option<RustcVersion>) {\n     if_chain! {\n+        if meets_msrv(msrv.as_ref(), &msrvs::TOOL_ATTRIBUTES);\n         // check cfg_attr\n         if attr.has_name(sym::cfg_attr);\n         if let Some(items) = attr.meta_item_list();"}, {"sha": "1cc3418d4748c98728116538fba64a80949abefc", "filename": "src/tools/clippy/clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -47,6 +47,7 @@ declare_clippy_lint! {\n     ///   bar.await;\n     /// }\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub AWAIT_HOLDING_LOCK,\n     pedantic,\n     \"Inside an async function, holding a MutexGuard while calling await\"\n@@ -88,6 +89,7 @@ declare_clippy_lint! {\n     ///   bar.await;\n     /// }\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub AWAIT_HOLDING_REFCELL_REF,\n     pedantic,\n     \"Inside an async function, holding a RefCell ref while calling await\""}, {"sha": "0977cf22b2c4e00343756b8ef381f66291ae24f5", "filename": "src/tools/clippy/clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbit_mask.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -41,6 +41,7 @@ declare_clippy_lint! {\n     /// # let x = 1;\n     /// if (x & 1 == 2) { }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub BAD_BIT_MASK,\n     correctness,\n     \"expressions of the form `_ & mask == select` that will only ever return `true` or `false`\"\n@@ -73,6 +74,7 @@ declare_clippy_lint! {\n     /// # let x = 1;\n     /// if (x | 1 > 3) {  }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub INEFFECTIVE_BIT_MASK,\n     correctness,\n     \"expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`\"\n@@ -95,6 +97,7 @@ declare_clippy_lint! {\n     /// # let x = 1;\n     /// if x & 0b1111 == 0 { }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub VERBOSE_BIT_MASK,\n     pedantic,\n     \"expressions where a bit mask is less readable than the corresponding method call\""}, {"sha": "1600fb25d89e24cec4b9935477b1d19f25a4987d", "filename": "src/tools/clippy/clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -17,6 +17,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let foo = 3.14;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub BLACKLISTED_NAME,\n     style,\n     \"usage of a blacklisted/placeholder name\""}, {"sha": "b59f49357df241c9f6a0cd33a9cebb26d142aeee", "filename": "src/tools/clippy/clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -41,6 +41,7 @@ declare_clippy_lint! {\n     /// let res = { let x = somefunc(); x };\n     /// if res { /* ... */ }\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub BLOCKS_IN_IF_CONDITIONS,\n     style,\n     \"useless or complex blocks that can be eliminated in conditions\""}, {"sha": "d0b8c52a36a92e9891c33dd1bee45e7ef6fab7b5", "filename": "src/tools/clippy/clippy_lints/src/bool_assert_comparison.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_assert_comparison.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -23,6 +23,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// assert!(!\"a\".is_empty());\n     /// ```\n+    #[clippy::version = \"1.53.0\"]\n     pub BOOL_ASSERT_COMPARISON,\n     style,\n     \"Using a boolean as comparison value in an assert_* macro when there is no need\"\n@@ -72,7 +73,7 @@ impl<'tcx> LateLintPass<'tcx> for BoolAssertComparison {\n             if let Some(span) = is_direct_expn_of(expr.span, mac) {\n                 if let Some(args) = higher::extract_assert_macro_args(expr) {\n                     if let [a, b, ..] = args[..] {\n-                        let nb_bool_args = is_bool_lit(a) as usize + is_bool_lit(b) as usize;\n+                        let nb_bool_args = usize::from(is_bool_lit(a)) + usize::from(is_bool_lit(b));\n \n                         if nb_bool_args != 1 {\n                             // If there are two boolean arguments, we definitely don't understand"}, {"sha": "51835ee7488fb01fe3090b45633eb0039dbb6743", "filename": "src/tools/clippy/clippy_lints/src/booleans.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{eq_expr_value, get_trait_def_id, in_macro, paths};\n+use clippy_utils::{eq_expr_value, get_trait_def_id, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -31,6 +31,7 @@ declare_clippy_lint! {\n     /// if a && true  // should be: if a\n     /// if !(a == b)  // should be: if a != b\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NONMINIMAL_BOOL,\n     complexity,\n     \"boolean expressions that can be written more concisely\"\n@@ -52,6 +53,7 @@ declare_clippy_lint! {\n     /// if a && b || a { ... }\n     /// ```\n     /// The `b` is unnecessary, the expression is equivalent to `if a`.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub LOGIC_BUG,\n     correctness,\n     \"boolean expressions that contain terminals which can be eliminated\"\n@@ -453,22 +455,20 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-        if in_macro(e.span) {\n-            return;\n-        }\n-        match &e.kind {\n-            ExprKind::Binary(binop, _, _) if binop.node == BinOpKind::Or || binop.node == BinOpKind::And => {\n-                self.bool_expr(e);\n-            },\n-            ExprKind::Unary(UnOp::Not, inner) => {\n-                if self.cx.typeck_results().node_types()[inner.hir_id].is_bool() {\n+        if !e.span.from_expansion() {\n+            match &e.kind {\n+                ExprKind::Binary(binop, _, _) if binop.node == BinOpKind::Or || binop.node == BinOpKind::And => {\n                     self.bool_expr(e);\n-                } else {\n-                    walk_expr(self, e);\n-                }\n-            },\n-            _ => walk_expr(self, e),\n+                },\n+                ExprKind::Unary(UnOp::Not, inner) => {\n+                    if self.cx.typeck_results().node_types()[inner.hir_id].is_bool() {\n+                        self.bool_expr(e);\n+                    }\n+                },\n+                _ => {},\n+            }\n         }\n+        walk_expr(self, e);\n     }\n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n         NestedVisitorMap::None"}, {"sha": "afb317421d0773aed78d0fdef2dc27089a6949d1", "filename": "src/tools/clippy/clippy_lints/src/bytecount.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -30,6 +30,7 @@ declare_clippy_lint! {\n     /// # let vec = vec![1_u8];\n     /// &vec.iter().filter(|x| **x == 0u8).count(); // use bytecount::count instead\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NAIVE_BYTECOUNT,\n     pedantic,\n     \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\"\n@@ -73,10 +74,10 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                     if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n                         &args[0]\n                     } else {\n-                        &filter_recv\n+                        filter_recv\n                     }\n                 } else {\n-                    &filter_recv\n+                    filter_recv\n                 };\n                 let mut applicability = Applicability::MaybeIncorrect;\n                 span_lint_and_sugg("}, {"sha": "23f79fdc68238ec24ecb1fe5dd2c6e7c08dd3279", "filename": "src/tools/clippy/clippy_lints/src/cargo_common_metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -42,6 +42,7 @@ declare_clippy_lint! {\n     /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n     /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n     /// ```\n+    #[clippy::version = \"1.32.0\"]\n     pub CARGO_COMMON_METADATA,\n     cargo,\n     \"common metadata is defined in `Cargo.toml`\""}, {"sha": "3f286dd9e2fca893b849ce17450b909caf4d3d02", "filename": "src/tools/clippy/clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -27,6 +27,7 @@ declare_clippy_lint! {\n     ///     filename.rsplit('.').next().map(|ext| ext.eq_ignore_ascii_case(\"rs\")) == Some(true)\n     /// }\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n     pedantic,\n     \"Checks for calls to ends_with with case-sensitive file extensions\""}, {"sha": "4a95bed1148dc4f89df5069527f7d6c0d4b3f7c4", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_lossless.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,16 +1,24 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::in_constant;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_isize_or_usize;\n+use clippy_utils::{in_constant, meets_msrv, msrvs};\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, FloatTy, Ty};\n+use rustc_semver::RustcVersion;\n \n use super::{utils, CAST_LOSSLESS};\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    if !should_lint(cx, expr, cast_from, cast_to) {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    cast_op: &Expr<'_>,\n+    cast_from: Ty<'_>,\n+    cast_to: Ty<'_>,\n+    msrv: &Option<RustcVersion>,\n+) {\n+    if !should_lint(cx, expr, cast_from, cast_to, msrv) {\n         return;\n     }\n \n@@ -32,21 +40,36 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_op: &Expr<'_>, c\n         },\n     );\n \n+    let message = if cast_from.is_bool() {\n+        format!(\n+            \"casting `{0:}` to `{1:}` is more cleanly stated with `{1:}::from(_)`\",\n+            cast_from, cast_to\n+        )\n+    } else {\n+        format!(\n+            \"casting `{}` to `{}` may become silently lossy if you later change the type\",\n+            cast_from, cast_to\n+        )\n+    };\n+\n     span_lint_and_sugg(\n         cx,\n         CAST_LOSSLESS,\n         expr.span,\n-        &format!(\n-            \"casting `{}` to `{}` may become silently lossy if you later change the type\",\n-            cast_from, cast_to\n-        ),\n+        &message,\n         \"try\",\n         format!(\"{}::from({})\", cast_to, sugg),\n         applicability,\n     );\n }\n \n-fn should_lint(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) -> bool {\n+fn should_lint(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    cast_from: Ty<'_>,\n+    cast_to: Ty<'_>,\n+    msrv: &Option<RustcVersion>,\n+) -> bool {\n     // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n     if in_constant(cx, expr.hir_id) {\n         return false;\n@@ -72,7 +95,7 @@ fn should_lint(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to\n             };\n             from_nbits < to_nbits\n         },\n-\n+        (false, true) if matches!(cast_from.kind(), ty::Bool) && meets_msrv(msrv.as_ref(), &msrvs::FROM_BOOL) => true,\n         (_, _) => {\n             matches!(cast_from.kind(), ty::Float(FloatTy::F32)) && matches!(cast_to.kind(), ty::Float(FloatTy::F64))\n         },"}, {"sha": "aee1e50b94a2a549d199daa74d19d7dabbfa0a69", "filename": "src/tools/clippy/clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -40,6 +40,7 @@ declare_clippy_lint! {\n     /// let x = u64::MAX;\n     /// x as f64;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CAST_PRECISION_LOSS,\n     pedantic,\n     \"casts that cause loss of precision, e.g., `x as f32` where `x: u64`\"\n@@ -61,6 +62,7 @@ declare_clippy_lint! {\n     /// let y: i8 = -1;\n     /// y as u128; // will return 18446744073709551615\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CAST_SIGN_LOSS,\n     pedantic,\n     \"casts from signed types to unsigned types, e.g., `x as u32` where `x: i32`\"\n@@ -83,6 +85,7 @@ declare_clippy_lint! {\n     ///     x as u8\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CAST_POSSIBLE_TRUNCATION,\n     pedantic,\n     \"casts that may cause truncation of the value, e.g., `x as u8` where `x: u32`, or `x as i32` where `x: f32`\"\n@@ -106,6 +109,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// u32::MAX as i32; // will yield a value of `-1`\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CAST_POSSIBLE_WRAP,\n     pedantic,\n     \"casts that may cause wrapping around the value, e.g., `x as i32` where `x: u32` and `x > i32::MAX`\"\n@@ -138,6 +142,7 @@ declare_clippy_lint! {\n     ///     u64::from(x)\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CAST_LOSSLESS,\n     pedantic,\n     \"casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\"\n@@ -163,6 +168,7 @@ declare_clippy_lint! {\n     /// let _ = 2_i32;\n     /// let _ = 0.5_f32;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNNECESSARY_CAST,\n     complexity,\n     \"cast to the same type, e.g., `x as i32` where `x: i32`\"\n@@ -190,6 +196,7 @@ declare_clippy_lint! {\n     /// (&1u8 as *const u8).cast::<u16>();\n     /// (&mut 1u8 as *mut u8).cast::<u16>();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CAST_PTR_ALIGNMENT,\n     pedantic,\n     \"cast from a pointer to a more-strictly-aligned pointer\"\n@@ -217,6 +224,7 @@ declare_clippy_lint! {\n     /// fn fun2() -> i32 { 1 }\n     /// let a = fun2 as usize;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub FN_TO_NUMERIC_CAST,\n     style,\n     \"casting a function pointer to a numeric type other than usize\"\n@@ -247,6 +255,7 @@ declare_clippy_lint! {\n     /// let fn_ptr = fn2 as usize;\n     /// let fn_ptr_truncated = fn_ptr as i32;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n     style,\n     \"casting a function pointer to a numeric type not wide enough to store the address\"\n@@ -283,6 +292,7 @@ declare_clippy_lint! {\n     /// }\n     /// let _ = fn3 as fn() -> u16;\n     /// ```\n+    #[clippy::version = \"1.58.0\"]\n     pub FN_TO_NUMERIC_CAST_ANY,\n     restriction,\n     \"casting a function pointer to any integer type\"\n@@ -317,6 +327,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.33.0\"]\n     pub CAST_REF_TO_MUT,\n     correctness,\n     \"a cast of reference to a mutable pointer\"\n@@ -344,6 +355,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// b'x'\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CHAR_LIT_AS_U8,\n     complexity,\n     \"casting a character literal to `u8` truncates\"\n@@ -372,6 +384,7 @@ declare_clippy_lint! {\n     /// let _ = ptr.cast::<i32>();\n     /// let _ = mut_ptr.cast::<i32>();\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub PTR_AS_PTR,\n     pedantic,\n     \"casting using `as` from and to raw pointers that doesn't change its mutability, where `pointer::cast` could take the place of `as`\"\n@@ -426,12 +439,16 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             fn_to_numeric_cast_any::check(cx, expr, cast_expr, cast_from, cast_to);\n             fn_to_numeric_cast::check(cx, expr, cast_expr, cast_from, cast_to);\n             fn_to_numeric_cast_with_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n-            if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n-                cast_possible_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n-                cast_possible_wrap::check(cx, expr, cast_from, cast_to);\n-                cast_precision_loss::check(cx, expr, cast_from, cast_to);\n-                cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to);\n-                cast_sign_loss::check(cx, expr, cast_expr, cast_from, cast_to);\n+\n+            if cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n+                if cast_from.is_numeric() {\n+                    cast_possible_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n+                    cast_possible_wrap::check(cx, expr, cast_from, cast_to);\n+                    cast_precision_loss::check(cx, expr, cast_from, cast_to);\n+                    cast_sign_loss::check(cx, expr, cast_expr, cast_from, cast_to);\n+                }\n+\n+                cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to, &self.msrv);\n             }\n         }\n "}, {"sha": "ffe6340bd77a58efe1ecf0588c306139b400b722", "filename": "src/tools/clippy/clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -36,6 +36,7 @@ declare_clippy_lint! {\n     /// i32::try_from(foo).is_ok()\n     /// # ;\n     /// ```\n+    #[clippy::version = \"1.37.0\"]\n     pub CHECKED_CONVERSIONS,\n     pedantic,\n     \"`try_from` could replace manual bounds checking when casting\""}, {"sha": "84a2373efe15b0adadd14d9361d18638ad084545", "filename": "src/tools/clippy/clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -27,6 +27,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Example\n     /// No. You'll see it when you get the warning.\n+    #[clippy::version = \"1.35.0\"]\n     pub COGNITIVE_COMPLEXITY,\n     nursery,\n     \"functions that should be split up into multiple functions\""}, {"sha": "f03f34e5a4b381e0fc238a252dcafb5d914bf2f4", "filename": "src/tools/clippy/clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -47,6 +47,7 @@ declare_clippy_lint! {\n     ///     \u2026\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub COLLAPSIBLE_IF,\n     style,\n     \"nested `if`s that can be collapsed (e.g., `if x { if y { ... } }`\"\n@@ -82,6 +83,7 @@ declare_clippy_lint! {\n     ///     \u2026\n     /// }\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub COLLAPSIBLE_ELSE_IF,\n     style,\n     \"nested `else`-`if` expressions that can be collapsed (e.g., `else { if x { ... } }`)\""}, {"sha": "626f9971f01e7d678cbc69c22a00d09841109cf7", "filename": "src/tools/clippy/clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -41,6 +41,7 @@ declare_clippy_lint! {\n     ///     };\n     /// }\n     /// ```\n+    #[clippy::version = \"1.50.0\"]\n     pub COLLAPSIBLE_MATCH,\n     style,\n     \"Nested `match` or `if let` expressions where the patterns may be \\\"collapsed\\\" together.\""}, {"sha": "399d11472b09b2a6f49b8346c65a09cdb8368267", "filename": "src/tools/clippy/clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -49,6 +49,7 @@ declare_clippy_lint! {\n     ///      }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub COMPARISON_CHAIN,\n     style,\n     \"`if`s that can be rewritten with `match` and `cmp`\""}, {"sha": "d07bc23235b0f37bdadf0811097775129c8e3802", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_then};\n use clippy_utils::source::{first_line_of_span, indent_of, reindent_multiline, snippet, snippet_opt};\n use clippy_utils::{\n-    both, count_eq, eq_expr_value, get_enclosing_block, get_parent_expr, if_sequence, in_macro, is_else_clause,\n-    is_lint_allowed, search_same, ContainsName, SpanlessEq, SpanlessHash,\n+    both, count_eq, eq_expr_value, get_enclosing_block, get_parent_expr, if_sequence, is_else_clause, is_lint_allowed,\n+    search_same, ContainsName, SpanlessEq, SpanlessHash,\n };\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n@@ -41,6 +41,7 @@ declare_clippy_lint! {\n     ///     \u2026\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub IFS_SAME_COND,\n     correctness,\n     \"consecutive `if`s with the same condition\"\n@@ -88,6 +89,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.41.0\"]\n     pub SAME_FUNCTIONS_IN_IF_CONDITION,\n     pedantic,\n     \"consecutive `if`s with the same function call\"\n@@ -109,6 +111,7 @@ declare_clippy_lint! {\n     ///     42\n     /// };\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub IF_SAME_THEN_ELSE,\n     correctness,\n     \"`if` with the same `then` and `else` blocks\"\n@@ -147,6 +150,7 @@ declare_clippy_lint! {\n     ///     42\n     /// };\n     /// ```\n+    #[clippy::version = \"1.53.0\"]\n     pub BRANCHES_SHARING_CODE,\n     nursery,\n     \"`if` statement with shared code in all blocks\"\n@@ -623,7 +627,7 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n \n     let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool {\n         // Do not lint if any expr originates from a macro\n-        if in_macro(lhs.span) || in_macro(rhs.span) {\n+        if lhs.span.from_expansion() || rhs.span.from_expansion() {\n             return false;\n         }\n         // Do not spawn warning if `IFS_SAME_COND` already produced it."}, {"sha": "026683f6006246e040ee445bd8f910df5db5c38d", "filename": "src/tools/clippy/clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -28,6 +28,7 @@ declare_clippy_lint! {\n     /// let a: Vec<_> = my_iterator.take(1).collect();\n     /// let b: Vec<_> = my_iterator.collect();\n     /// ```\n+    #[clippy::version = \"1.30.0\"]\n     pub COPY_ITERATOR,\n     pedantic,\n     \"implementing `Iterator` on a `Copy` type\""}, {"sha": "6bc4054a5abca5237a689d5d5c46ffa8e0c72b05", "filename": "src/tools/clippy/clippy_lints/src/create_dir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcreate_dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcreate_dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcreate_dir.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -23,6 +23,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// std::fs::create_dir_all(\"foo\");\n     /// ```\n+    #[clippy::version = \"1.48.0\"]\n     pub CREATE_DIR,\n     restriction,\n     \"calling `std::fs::create_dir` instead of `std::fs::create_dir_all`\""}, {"sha": "5a0b60fdfbc01924de5a09c3dc36d62a6b8592c1", "filename": "src/tools/clippy/clippy_lints/src/dbg_macro.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdbg_macro.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -15,6 +15,14 @@ declare_clippy_lint! {\n     /// `dbg!` macro is intended as a debugging tool. It\n     /// should not be in version control.\n     ///\n+    /// ### Known problems\n+    /// * The lint level is unaffected by crate attributes. The level can still\n+    ///   be set for functions, modules and other items. To change the level for\n+    ///   the entire crate, please use command line flags. More information and a\n+    ///   configuration example can be found in [clippy#6610].\n+    ///\n+    /// [clippy#6610]: https://github.com/rust-lang/rust-clippy/issues/6610#issuecomment-977120558\n+    ///\n     /// ### Example\n     /// ```rust,ignore\n     /// // Bad\n@@ -23,6 +31,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// true\n     /// ```\n+    #[clippy::version = \"1.34.0\"]\n     pub DBG_MACRO,\n     restriction,\n     \"`dbg!` macro is intended as a debugging tool\""}, {"sha": "a0b137efe221a3bc8113a2936403bbce99f9b874", "filename": "src/tools/clippy/clippy_lints/src/default.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_sugg};\n use clippy_utils::source::snippet_with_macro_callsite;\n use clippy_utils::ty::{has_drop, is_copy};\n-use clippy_utils::{any_parent_is_automatically_derived, contains_name, in_macro, match_def_path, paths};\n+use clippy_utils::{any_parent_is_automatically_derived, contains_name, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -29,6 +29,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let s = String::default();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DEFAULT_TRAIT_ACCESS,\n     pedantic,\n     \"checks for literal calls to `Default::default()`\"\n@@ -62,6 +63,7 @@ declare_clippy_lint! {\n     ///     .. Default::default()\n     /// };\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub FIELD_REASSIGN_WITH_DEFAULT,\n     style,\n     \"binding initialized with Default should have its fields set in the initializer\"\n@@ -78,7 +80,7 @@ impl_lint_pass!(Default => [DEFAULT_TRAIT_ACCESS, FIELD_REASSIGN_WITH_DEFAULT]);\n impl LateLintPass<'_> for Default {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if !in_macro(expr.span);\n+            if !expr.span.from_expansion();\n             // Avoid cases already linted by `field_reassign_with_default`\n             if !self.reassigned_linted.contains(&expr.span);\n             if let ExprKind::Call(path, ..) = expr.kind;\n@@ -125,7 +127,7 @@ impl LateLintPass<'_> for Default {\n                 if let StmtKind::Local(local) = stmt.kind;\n                 if let Some(expr) = local.init;\n                 if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n-                if !in_macro(expr.span);\n+                if !expr.span.from_expansion();\n                 // only take bindings to identifiers\n                 if let PatKind::Binding(_, binding_id, ident, _) = local.pat.kind;\n                 // only when assigning `... = Default::default()`"}, {"sha": "3573ea5f02671becbce4b4f1ddd00559fe9c84c9", "filename": "src/tools/clippy/clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -46,6 +46,7 @@ declare_clippy_lint! {\n     /// let i = 10i32;\n     /// let f = 1.23f64;\n     /// ```\n+    #[clippy::version = \"1.52.0\"]\n     pub DEFAULT_NUMERIC_FALLBACK,\n     restriction,\n     \"usage of unconstrained numeric literals which may cause default numeric fallback.\""}, {"sha": "bba27576c892737232f7497187caf56e73c2c179", "filename": "src/tools/clippy/clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -21,6 +21,7 @@ declare_deprecated_lint! {\n     /// ### Deprecation reason\n     /// This used to check for `assert!(a == b)` and recommend\n     /// replacement with `assert_eq!(a, b)`, but this is no longer needed after RFC 2011.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SHOULD_ASSERT_EQ,\n     \"`assert!()` will be more flexible with RFC 2011\"\n }\n@@ -32,6 +33,7 @@ declare_deprecated_lint! {\n     /// ### Deprecation reason\n     /// This used to check for `Vec::extend`, which was slower than\n     /// `Vec::extend_from_slice`. Thanks to specialization, this is no longer true.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EXTEND_FROM_SLICE,\n     \"`.extend_from_slice(_)` is a faster way to extend a Vec by a slice\"\n }\n@@ -45,6 +47,7 @@ declare_deprecated_lint! {\n     /// an infinite iterator, which is better expressed by `iter::repeat`,\n     /// but the method has been removed for `Iterator::step_by` which panics\n     /// if given a zero\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub RANGE_STEP_BY_ZERO,\n     \"`iterator.step_by(0)` panics nowadays\"\n }\n@@ -56,6 +59,7 @@ declare_deprecated_lint! {\n     /// ### Deprecation reason\n     /// This used to check for `Vec::as_slice`, which was unstable with good\n     /// stable alternatives. `Vec::as_slice` has now been stabilized.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNSTABLE_AS_SLICE,\n     \"`Vec::as_slice` has been stabilized in 1.7\"\n }\n@@ -67,6 +71,7 @@ declare_deprecated_lint! {\n     /// ### Deprecation reason\n     /// This used to check for `Vec::as_mut_slice`, which was unstable with good\n     /// stable alternatives. `Vec::as_mut_slice` has now been stabilized.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNSTABLE_AS_MUT_SLICE,\n     \"`Vec::as_mut_slice` has been stabilized in 1.7\"\n }\n@@ -80,6 +85,7 @@ declare_deprecated_lint! {\n     /// between non-pointer types of differing alignment is well-defined behavior (it's semantically\n     /// equivalent to a memcpy). This lint has thus been refactored into two separate lints:\n     /// cast_ptr_alignment and transmute_ptr_to_ptr.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MISALIGNED_TRANSMUTE,\n     \"this lint has been split into cast_ptr_alignment and transmute_ptr_to_ptr\"\n }\n@@ -92,6 +98,7 @@ declare_deprecated_lint! {\n     /// This lint is too subjective, not having a good reason for being in clippy.\n     /// Additionally, compound assignment operators may be overloaded separately from their non-assigning\n     /// counterparts, so this lint may suggest a change in behavior or the code may not compile.\n+    #[clippy::version = \"1.30.0\"]\n     pub ASSIGN_OPS,\n     \"using compound assignment operators (e.g., `+=`) is harmless\"\n }\n@@ -104,6 +111,7 @@ declare_deprecated_lint! {\n     /// The original rule will only lint for `if let`. After\n     /// making it support to lint `match`, naming as `if let` is not suitable for it.\n     /// So, this lint is deprecated.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub IF_LET_REDUNDANT_PATTERN_MATCHING,\n     \"this lint has been changed to redundant_pattern_matching\"\n }\n@@ -117,6 +125,7 @@ declare_deprecated_lint! {\n     /// Vec::with_capacity(n); vec.set_len(n);` with `let vec = vec![0; n];`. The\n     /// replacement has very different performance characteristics so the lint is\n     /// deprecated.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNSAFE_VECTOR_INITIALIZATION,\n     \"the replacement suggested by this lint had substantially different behavior\"\n }\n@@ -127,6 +136,7 @@ declare_deprecated_lint! {\n     ///\n     /// ### Deprecation reason\n     /// This lint has been superseded by #[must_use] in rustc.\n+    #[clippy::version = \"1.39.0\"]\n     pub UNUSED_COLLECT,\n     \"`collect` has been marked as #[must_use] in rustc and that covers all cases of this lint\"\n }\n@@ -137,6 +147,7 @@ declare_deprecated_lint! {\n     ///\n     /// ### Deprecation reason\n     /// Associated-constants are now preferred.\n+    #[clippy::version = \"1.44.0\"]\n     pub REPLACE_CONSTS,\n     \"associated-constants `MIN`/`MAX` of integers are preferred to `{min,max}_value()` and module constants\"\n }\n@@ -147,6 +158,7 @@ declare_deprecated_lint! {\n     ///\n     /// ### Deprecation reason\n     /// The regex! macro does not exist anymore.\n+    #[clippy::version = \"1.47.0\"]\n     pub REGEX_MACRO,\n     \"the regex! macro has been removed from the regex crate in 2018\"\n }\n@@ -158,6 +170,7 @@ declare_deprecated_lint! {\n     /// ### Deprecation reason\n     /// This lint has been replaced by `manual_find_map`, a\n     /// more specific lint.\n+    #[clippy::version = \"1.51.0\"]\n     pub FIND_MAP,\n     \"this lint has been replaced by `manual_find_map`, a more specific lint\"\n }\n@@ -169,6 +182,7 @@ declare_deprecated_lint! {\n     /// ### Deprecation reason\n     /// This lint has been replaced by `manual_filter_map`, a\n     /// more specific lint.\n+    #[clippy::version = \"1.53.0\"]\n     pub FILTER_MAP,\n     \"this lint has been replaced by `manual_filter_map`, a more specific lint\"\n }\n@@ -181,6 +195,7 @@ declare_deprecated_lint! {\n     /// The `avoid_breaking_exported_api` config option was added, which\n     /// enables the `enum_variant_names` lint for public items.\n     /// ```\n+    #[clippy::version = \"1.54.0\"]\n     pub PUB_ENUM_VARIANT_NAMES,\n     \"set the `avoid-breaking-exported-api` config option to `false` to enable the `enum_variant_names` lint for public items\"\n }\n@@ -192,6 +207,7 @@ declare_deprecated_lint! {\n     /// ### Deprecation reason\n     /// The `avoid_breaking_exported_api` config option was added, which\n     /// enables the `wrong_self_conversion` lint for public items.\n+    #[clippy::version = \"1.54.0\"]\n     pub WRONG_PUB_SELF_CONVENTION,\n     \"set the `avoid-breaking-exported-api` config option to `false` to enable the `wrong_self_convention` lint for public items\"\n }"}, {"sha": "fa2b348591be4d7a0118095a99734f9297f60900", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 332, "deletions": 6, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,14 +1,20 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_context;\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::peel_mid_ty_refs;\n-use clippy_utils::{get_parent_node, in_macro, is_lint_allowed};\n-use rustc_ast::util::parser::PREC_PREFIX;\n+use clippy_utils::{get_parent_expr, get_parent_node, is_lint_allowed, path_to_local};\n+use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, HirId, MatchSource, Mutability, Node, UnOp};\n+use rustc_hir::{\n+    BindingAnnotation, Body, BodyId, BorrowKind, Destination, Expr, ExprKind, HirId, MatchSource, Mutability, Node,\n+    Pat, PatKind, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::{self, Ty, TyCtxt, TyS, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{symbol::sym, Span};\n+use std::iter;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -34,13 +40,70 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// let _ = d.unwrap().deref();\n     /// ```\n+    #[clippy::version = \"1.44.0\"]\n     pub EXPLICIT_DEREF_METHODS,\n     pedantic,\n     \"Explicit use of deref or deref_mut method while not in a method chain.\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for address of operations (`&`) that are going to\n+    /// be dereferenced immediately by the compiler.\n+    ///\n+    /// ### Why is this bad?\n+    /// Suggests that the receiver of the expression borrows\n+    /// the expression.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn fun(_a: &i32) {}\n+    ///\n+    /// // Bad\n+    /// let x: &i32 = &&&&&&5;\n+    /// fun(&x);\n+    ///\n+    /// // Good\n+    /// let x: &i32 = &5;\n+    /// fun(x);\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub NEEDLESS_BORROW,\n+    style,\n+    \"taking a reference that is going to be automatically dereferenced\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `ref` bindings which create a reference to a reference.\n+    ///\n+    /// ### Why is this bad?\n+    /// The address-of operator at the use site is clearer about the need for a reference.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// // Bad\n+    /// let x = Some(\"\");\n+    /// if let Some(ref x) = x {\n+    ///     // use `x` here\n+    /// }\n+    ///\n+    /// // Good\n+    /// let x = Some(\"\");\n+    /// if let Some(x) = x {\n+    ///     // use `&x` here\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.54.0\"]\n+    pub REF_BINDING_TO_REFERENCE,\n+    pedantic,\n+    \"`ref` binding to a reference\"\n+}\n+\n impl_lint_pass!(Dereferencing => [\n     EXPLICIT_DEREF_METHODS,\n+    NEEDLESS_BORROW,\n+    REF_BINDING_TO_REFERENCE,\n ]);\n \n #[derive(Default)]\n@@ -51,6 +114,18 @@ pub struct Dereferencing {\n     // expression. This is to store the id of that expression so it can be skipped when\n     // `check_expr` is called for it.\n     skip_expr: Option<HirId>,\n+\n+    /// The body the first local was found in. Used to emit lints when the traversal of the body has\n+    /// been finished. Note we can't lint at the end of every body as they can be nested within each\n+    /// other.\n+    current_body: Option<BodyId>,\n+    /// The list of locals currently being checked by the lint.\n+    /// If the value is `None`, then the binding has been seen as a ref pattern, but is not linted.\n+    /// This is needed for or patterns where one of the branches can be linted, but another can not\n+    /// be.\n+    ///\n+    /// e.g. `m!(x) | Foo::Bar(ref x)`\n+    ref_locals: FxIndexMap<HirId, Option<RefPat>>,\n }\n \n struct StateData {\n@@ -67,6 +142,9 @@ enum State {\n         ty_changed_count: usize,\n         is_final_ufcs: bool,\n     },\n+    DerefedBorrow {\n+        count: u32,\n+    },\n }\n \n // A reference operation considered by this lint pass\n@@ -76,15 +154,31 @@ enum RefOp {\n     AddrOf,\n }\n \n+struct RefPat {\n+    /// Whether every usage of the binding is dereferenced.\n+    always_deref: bool,\n+    /// The spans of all the ref bindings for this local.\n+    spans: Vec<Span>,\n+    /// The applicability of this suggestion.\n+    app: Applicability,\n+    /// All the replacements which need to be made.\n+    replacements: Vec<(Span, String)>,\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n+    #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Skip path expressions from deref calls. e.g. `Deref::deref(e)`\n         if Some(expr.hir_id) == self.skip_expr.take() {\n             return;\n         }\n \n+        if let Some(local) = path_to_local(expr) {\n+            self.check_local_usage(cx, expr, local);\n+        }\n+\n         // Stop processing sub expressions when a macro call is seen\n-        if in_macro(expr.span) {\n+        if expr.span.from_expansion() {\n             if let Some((state, data)) = self.state.take() {\n                 report(cx, expr, state, data);\n             }\n@@ -127,6 +221,48 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             },\n                         ));\n                     },\n+                    RefOp::AddrOf => {\n+                        // Find the number of times the borrow is auto-derefed.\n+                        let mut iter = find_adjustments(cx.tcx, typeck, expr).iter();\n+                        if let Some((i, adjust)) = iter.by_ref().enumerate().find_map(|(i, adjust)| {\n+                            if !matches!(adjust.kind, Adjust::Deref(_)) {\n+                                Some((i, adjust))\n+                            } else if !adjust.target.is_ref() {\n+                                // Add one to the number of references found.\n+                                Some((i + 1, adjust))\n+                            } else {\n+                                None\n+                            }\n+                        }) {\n+                            // Found two consecutive derefs. At least one can be removed.\n+                            if i > 1 {\n+                                let target_mut = iter::once(adjust)\n+                                    .chain(iter)\n+                                    .find_map(|adjust| match adjust.kind {\n+                                        Adjust::Borrow(AutoBorrow::Ref(_, m)) => Some(m.into()),\n+                                        _ => None,\n+                                    })\n+                                    // This default should never happen. Auto-deref always reborrows.\n+                                    .unwrap_or(Mutability::Not);\n+                                self.state = Some((\n+                                    // Subtract one for the current borrow expression, and one to cover the last\n+                                    // reference which can't be removed (it's either reborrowed, or needed for\n+                                    // auto-deref to happen).\n+                                    State::DerefedBorrow {\n+                                        count:\n+                                            // Truncation here would require more than a `u32::MAX` level reference. The compiler\n+                                            // does not support this.\n+                                            #[allow(clippy::cast_possible_truncation)]\n+                                            { i as u32 - 2 }\n+                                    },\n+                                    StateData {\n+                                        span: expr.span,\n+                                        target_mut,\n+                                    },\n+                                ));\n+                            }\n+                        }\n+                    },\n                     _ => (),\n                 }\n             },\n@@ -143,10 +279,80 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                     data,\n                 ));\n             },\n+            (Some((State::DerefedBorrow { count }, data)), RefOp::AddrOf) if count != 0 => {\n+                self.state = Some((State::DerefedBorrow { count: count - 1 }, data));\n+            },\n \n             (Some((state, data)), _) => report(cx, expr, state, data),\n         }\n     }\n+\n+    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n+        if let PatKind::Binding(BindingAnnotation::Ref, id, name, _) = pat.kind {\n+            if let Some(opt_prev_pat) = self.ref_locals.get_mut(&id) {\n+                // This binding id has been seen before. Add this pattern to the list of changes.\n+                if let Some(prev_pat) = opt_prev_pat {\n+                    if pat.span.from_expansion() {\n+                        // Doesn't match the context of the previous pattern. Can't lint here.\n+                        *opt_prev_pat = None;\n+                    } else {\n+                        prev_pat.spans.push(pat.span);\n+                        prev_pat.replacements.push((\n+                            pat.span,\n+                            snippet_with_context(cx, name.span, pat.span.ctxt(), \"..\", &mut prev_pat.app)\n+                                .0\n+                                .into(),\n+                        ));\n+                    }\n+                }\n+                return;\n+            }\n+\n+            if_chain! {\n+                if !pat.span.from_expansion();\n+                if let ty::Ref(_, tam, _) = *cx.typeck_results().pat_ty(pat).kind();\n+                // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n+                if let ty::Ref(_, _, Mutability::Not) = *tam.kind();\n+                then {\n+                    let mut app = Applicability::MachineApplicable;\n+                    let snip = snippet_with_context(cx, name.span, pat.span.ctxt(), \"..\", &mut app).0;\n+                    self.current_body = self.current_body.or(cx.enclosing_body);\n+                    self.ref_locals.insert(\n+                        id,\n+                        Some(RefPat {\n+                            always_deref: true,\n+                            spans: vec![pat.span],\n+                            app,\n+                            replacements: vec![(pat.span, snip.into())],\n+                        }),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_body_post(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n+        if Some(body.id()) == self.current_body {\n+            for pat in self.ref_locals.drain(..).filter_map(|(_, x)| x) {\n+                let replacements = pat.replacements;\n+                let app = pat.app;\n+                span_lint_and_then(\n+                    cx,\n+                    if pat.always_deref {\n+                        NEEDLESS_BORROW\n+                    } else {\n+                        REF_BINDING_TO_REFERENCE\n+                    },\n+                    pat.spans,\n+                    \"this pattern creates a reference to a reference\",\n+                    |diag| {\n+                        diag.multipart_suggestion(\"try this\", replacements, app);\n+                    },\n+                );\n+            }\n+            self.current_body = None;\n+        }\n+    }\n }\n \n fn try_parse_ref_op(\n@@ -250,6 +456,48 @@ fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId,\n     }\n }\n \n+/// Adjustments are sometimes made in the parent block rather than the expression itself.\n+fn find_adjustments(\n+    tcx: TyCtxt<'tcx>,\n+    typeck: &'tcx TypeckResults<'_>,\n+    expr: &'tcx Expr<'_>,\n+) -> &'tcx [Adjustment<'tcx>] {\n+    let map = tcx.hir();\n+    let mut iter = map.parent_iter(expr.hir_id);\n+    let mut prev = expr;\n+\n+    loop {\n+        match typeck.expr_adjustments(prev) {\n+            [] => (),\n+            a => break a,\n+        };\n+\n+        match iter.next().map(|(_, x)| x) {\n+            Some(Node::Block(_)) => {\n+                if let Some((_, Node::Expr(e))) = iter.next() {\n+                    prev = e;\n+                } else {\n+                    // This shouldn't happen. Blocks are always contained in an expression.\n+                    break &[];\n+                }\n+            },\n+            Some(Node::Expr(&Expr {\n+                kind: ExprKind::Break(Destination { target_id: Ok(id), .. }, _),\n+                ..\n+            })) => {\n+                if let Some(Node::Expr(e)) = map.find(id) {\n+                    prev = e;\n+                    iter = map.parent_iter(id);\n+                } else {\n+                    // This shouldn't happen. The destination should exist.\n+                    break &[];\n+                }\n+            },\n+            _ => break &[],\n+        }\n+    }\n+}\n+\n #[allow(clippy::needless_pass_by_value)]\n fn report(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data: StateData) {\n     match state {\n@@ -300,5 +548,83 @@ fn report(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data: Stat\n                 app,\n             );\n         },\n+        State::DerefedBorrow { .. } => {\n+            let mut app = Applicability::MachineApplicable;\n+            let snip = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app).0;\n+            span_lint_and_sugg(\n+                cx,\n+                NEEDLESS_BORROW,\n+                data.span,\n+                &format!(\n+                    \"this expression borrows a reference (`{}`) that is immediately dereferenced by the compiler\",\n+                    cx.typeck_results().expr_ty(expr),\n+                ),\n+                \"change this to\",\n+                snip.into(),\n+                app,\n+            );\n+        },\n+    }\n+}\n+\n+impl Dereferencing {\n+    fn check_local_usage(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, local: HirId) {\n+        if let Some(outer_pat) = self.ref_locals.get_mut(&local) {\n+            if let Some(pat) = outer_pat {\n+                // Check for auto-deref\n+                if !matches!(\n+                    cx.typeck_results().expr_adjustments(e),\n+                    [\n+                        Adjustment {\n+                            kind: Adjust::Deref(_),\n+                            ..\n+                        },\n+                        Adjustment {\n+                            kind: Adjust::Deref(_),\n+                            ..\n+                        },\n+                        ..\n+                    ]\n+                ) {\n+                    match get_parent_expr(cx, e) {\n+                        // Field accesses are the same no matter the number of references.\n+                        Some(Expr {\n+                            kind: ExprKind::Field(..),\n+                            ..\n+                        }) => (),\n+                        Some(&Expr {\n+                            span,\n+                            kind: ExprKind::Unary(UnOp::Deref, _),\n+                            ..\n+                        }) if !span.from_expansion() => {\n+                            // Remove explicit deref.\n+                            let snip = snippet_with_context(cx, e.span, span.ctxt(), \"..\", &mut pat.app).0;\n+                            pat.replacements.push((span, snip.into()));\n+                        },\n+                        Some(parent) if !parent.span.from_expansion() => {\n+                            // Double reference might be needed at this point.\n+                            if parent.precedence().order() == PREC_POSTFIX {\n+                                // Parentheses would be needed here, don't lint.\n+                                *outer_pat = None;\n+                            } else {\n+                                pat.always_deref = false;\n+                                let snip = snippet_with_context(cx, e.span, parent.span.ctxt(), \"..\", &mut pat.app).0;\n+                                pat.replacements.push((e.span, format!(\"&{}\", snip)));\n+                            }\n+                        },\n+                        _ if !e.span.from_expansion() => {\n+                            // Double reference might be needed at this point.\n+                            pat.always_deref = false;\n+                            let snip = snippet_with_applicability(cx, e.span, \"..\", &mut pat.app);\n+                            pat.replacements.push((e.span, format!(\"&{}\", snip)));\n+                        },\n+                        // Edge case for macros. The span of the identifier will usually match the context of the\n+                        // binding, but not if the identifier was created in a macro. e.g. `concat_idents` and proc\n+                        // macros\n+                        _ => *outer_pat = None,\n+                    }\n+                }\n+            }\n+        }\n     }\n }"}, {"sha": "d0fab2b48fb074beba10b3e7b864d64eaab74549", "filename": "src/tools/clippy/clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{in_macro, is_automatically_derived, is_default_equivalent, remove_blocks};\n+use clippy_utils::{is_automatically_derived, is_default_equivalent, remove_blocks};\n use rustc_hir::{\n     def::{DefKind, Res},\n     Body, Expr, ExprKind, GenericArg, Impl, ImplItemKind, Item, ItemKind, Node, PathSegment, QPath, TyKind,\n@@ -46,6 +46,7 @@ declare_clippy_lint! {\n     /// has exactly equal bounds, and therefore this lint is disabled for types with\n     /// generic parameters.\n     ///\n+    #[clippy::version = \"1.57.0\"]\n     pub DERIVABLE_IMPLS,\n     complexity,\n     \"manual implementation of the `Default` trait which is equal to a derive\"\n@@ -72,7 +73,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n             }) = item.kind;\n             if let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if !is_automatically_derived(attrs);\n-            if !in_macro(item.span);\n+            if !item.span.from_expansion();\n             if let Some(def_id) = trait_ref.trait_def_id();\n             if cx.tcx.is_diagnostic_item(sym::Default, def_id);\n             if let impl_item_hir = child.id.hir_id();"}, {"sha": "097cb65f56e4e8c63b760cb56bfb32aa30a59a0e", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -37,6 +37,7 @@ declare_clippy_lint! {\n     ///     ...\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DERIVE_HASH_XOR_EQ,\n     correctness,\n     \"deriving `Hash` but implementing `PartialEq` explicitly\"\n@@ -87,6 +88,7 @@ declare_clippy_lint! {\n     /// #[derive(Ord, PartialOrd, PartialEq, Eq)]\n     /// struct Foo;\n     /// ```\n+    #[clippy::version = \"1.47.0\"]\n     pub DERIVE_ORD_XOR_PARTIAL_ORD,\n     correctness,\n     \"deriving `Ord` but implementing `PartialOrd` explicitly\"\n@@ -113,6 +115,7 @@ declare_clippy_lint! {\n     ///     // ..\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EXPL_IMPL_CLONE_ON_COPY,\n     pedantic,\n     \"implementing `Clone` explicitly on `Copy` types\"\n@@ -146,6 +149,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub UNSAFE_DERIVE_DESERIALIZE,\n     pedantic,\n     \"deriving `serde::Deserialize` on a type that has methods using `unsafe`\""}, {"sha": "6d4065907fb458da5ca256d4e1d0e22e9c20d6ab", "filename": "src/tools/clippy/clippy_lints/src/disallowed_methods.rs", "status": "renamed", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -47,18 +47,19 @@ declare_clippy_lint! {\n     /// let mut xs = Vec::new(); // Vec::new is _not_ disallowed in the config.\n     /// xs.push(123); // Vec::push is _not_ disallowed in the config.\n     /// ```\n-    pub DISALLOWED_METHOD,\n+    #[clippy::version = \"1.49.0\"]\n+    pub DISALLOWED_METHODS,\n     nursery,\n     \"use of a disallowed method call\"\n }\n \n #[derive(Clone, Debug)]\n-pub struct DisallowedMethod {\n+pub struct DisallowedMethods {\n     conf_disallowed: Vec<conf::DisallowedMethod>,\n     disallowed: DefIdMap<Option<String>>,\n }\n \n-impl DisallowedMethod {\n+impl DisallowedMethods {\n     pub fn new(conf_disallowed: Vec<conf::DisallowedMethod>) -> Self {\n         Self {\n             conf_disallowed,\n@@ -67,9 +68,9 @@ impl DisallowedMethod {\n     }\n }\n \n-impl_lint_pass!(DisallowedMethod => [DISALLOWED_METHOD]);\n+impl_lint_pass!(DisallowedMethods => [DISALLOWED_METHODS]);\n \n-impl<'tcx> LateLintPass<'tcx> for DisallowedMethod {\n+impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for conf in &self.conf_disallowed {\n             let (path, reason) = match conf {\n@@ -97,7 +98,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethod {\n         };\n         let func_path = cx.tcx.def_path_str(def_id);\n         let msg = format!(\"use of a disallowed method `{}`\", func_path);\n-        span_lint_and_then(cx, DISALLOWED_METHOD, expr.span, &msg, |diag| {\n+        span_lint_and_then(cx, DISALLOWED_METHODS, expr.span, &msg, |diag| {\n             if let Some(reason) = reason {\n                 diag.note(reason);\n             }", "previous_filename": "src/tools/clippy/clippy_lints/src/disallowed_method.rs"}, {"sha": "3c3f3631849e58dc1b44a8da92edf70d84dff02d", "filename": "src/tools/clippy/clippy_lints/src/disallowed_script_idents.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_script_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_script_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_script_idents.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -38,6 +38,7 @@ declare_clippy_lint! {\n     /// let z\u00e4hler = 10; // OK, it's still latin.\n     /// let \u30ab\u30a6\u30f3\u30bf = 10; // Will spawn the lint.\n     /// ```\n+    #[clippy::version = \"1.55.0\"]\n     pub DISALLOWED_SCRIPT_IDENTS,\n     restriction,\n     \"usage of non-allowed Unicode scripts\""}, {"sha": "eaed40327136f75636b013e37ee400b7a9318790", "filename": "src/tools/clippy/clippy_lints/src/disallowed_types.rs", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -42,18 +42,19 @@ declare_clippy_lint! {\n     /// // A similar type that is allowed by the config\n     /// use std::collections::HashMap;\n     /// ```\n-    pub DISALLOWED_TYPE,\n+    #[clippy::version = \"1.55.0\"]\n+    pub DISALLOWED_TYPES,\n     nursery,\n-    \"use of a disallowed type\"\n+    \"use of disallowed types\"\n }\n #[derive(Clone, Debug)]\n-pub struct DisallowedType {\n+pub struct DisallowedTypes {\n     conf_disallowed: Vec<conf::DisallowedType>,\n     def_ids: FxHashMap<DefId, Option<String>>,\n     prim_tys: FxHashMap<PrimTy, Option<String>>,\n }\n \n-impl DisallowedType {\n+impl DisallowedTypes {\n     pub fn new(conf_disallowed: Vec<conf::DisallowedType>) -> Self {\n         Self {\n             conf_disallowed,\n@@ -79,9 +80,9 @@ impl DisallowedType {\n     }\n }\n \n-impl_lint_pass!(DisallowedType => [DISALLOWED_TYPE]);\n+impl_lint_pass!(DisallowedTypes => [DISALLOWED_TYPES]);\n \n-impl<'tcx> LateLintPass<'tcx> for DisallowedType {\n+impl<'tcx> LateLintPass<'tcx> for DisallowedTypes {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for conf in &self.conf_disallowed {\n             let (path, reason) = match conf {\n@@ -124,7 +125,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedType {\n fn emit(cx: &LateContext<'_>, name: &str, span: Span, reason: Option<&str>) {\n     span_lint_and_then(\n         cx,\n-        DISALLOWED_TYPE,\n+        DISALLOWED_TYPES,\n         span,\n         &format!(\"`{}` is not allowed according to config\", name),\n         |diag| {", "previous_filename": "src/tools/clippy/clippy_lints/src/disallowed_type.rs"}, {"sha": "2cdd59c569198755ef24160c9c1e4f7295c52a00", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::attrs::is_doc_hidden;\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_note, span_lint_and_sugg};\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_note, span_lint_and_then};\n use clippy_utils::source::{first_line_of_span, snippet_with_applicability};\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n use clippy_utils::{is_entrypoint_fn, is_expn_of, match_panic_def_id, method_chain_args, return_ty};\n@@ -10,7 +10,7 @@ use rustc_ast::token::CommentKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::EmitterWriter;\n-use rustc_errors::{Applicability, Handler};\n+use rustc_errors::{Applicability, Handler, SuggestionStyle};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{AnonConst, Expr, ExprKind, QPath};\n@@ -67,6 +67,7 @@ declare_clippy_lint! {\n     /// /// [SmallVec]: SmallVec\n     /// fn main() {}\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DOC_MARKDOWN,\n     pedantic,\n     \"presence of `_`, `::` or camel-case outside backticks in documentation\"\n@@ -101,6 +102,7 @@ declare_clippy_lint! {\n     ///     unimplemented!();\n     /// }\n     /// ```\n+    #[clippy::version = \"1.39.0\"]\n     pub MISSING_SAFETY_DOC,\n     style,\n     \"`pub unsafe fn` without `# Safety` docs\"\n@@ -129,6 +131,7 @@ declare_clippy_lint! {\n     ///     unimplemented!();\n     /// }\n     /// ```\n+    #[clippy::version = \"1.41.0\"]\n     pub MISSING_ERRORS_DOC,\n     pedantic,\n     \"`pub fn` returns `Result` without `# Errors` in doc comment\"\n@@ -159,6 +162,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.52.0\"]\n     pub MISSING_PANICS_DOC,\n     pedantic,\n     \"`pub fn` may panic without `# Panics` in doc comment\"\n@@ -187,6 +191,7 @@ declare_clippy_lint! {\n     ///     unimplemented!();\n     /// }\n     /// ``````\n+    #[clippy::version = \"1.40.0\"]\n     pub NEEDLESS_DOCTEST_MAIN,\n     style,\n     \"presence of `fn main() {` in code examples\"\n@@ -639,7 +644,9 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                             | ItemKind::ExternCrate(..)\n                             | ItemKind::ForeignMod(..) => return false,\n                             // We found a main function ...\n-                            ItemKind::Fn(box Fn { sig, body: Some(block), .. }) if item.ident.name == sym::main => {\n+                            ItemKind::Fn(box Fn {\n+                                sig, body: Some(block), ..\n+                            }) if item.ident.name == sym::main => {\n                                 let is_async = matches!(sig.header.asyncness, Async::Yes { .. });\n                                 let returns_nothing = match &sig.decl.output {\n                                     FnRetTy::Default(..) => true,\n@@ -763,14 +770,23 @@ fn check_word(cx: &LateContext<'_>, word: &str, span: Span) {\n     if has_underscore(word) || word.contains(\"::\") || is_camel_case(word) {\n         let mut applicability = Applicability::MachineApplicable;\n \n-        span_lint_and_sugg(\n+        span_lint_and_then(\n             cx,\n             DOC_MARKDOWN,\n             span,\n             \"item in documentation is missing backticks\",\n-            \"try\",\n-            format!(\"`{}`\", snippet_with_applicability(cx, span, \"..\", &mut applicability)),\n-            applicability,\n+            |diag| {\n+                let snippet = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n+                diag.span_suggestion_with_style(\n+                    span,\n+                    \"try\",\n+                    format!(\"`{}`\", snippet),\n+                    applicability,\n+                    // always show the suggestion in a separate line, since the\n+                    // inline presentation adds another pair of backticks\n+                    SuggestionStyle::ShowAlways,\n+                );\n+            },\n         );\n     }\n }"}, {"sha": "176092e5b28003da7671dc77cf1fc03bd40004d5", "filename": "src/tools/clippy/clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -31,6 +31,7 @@ declare_clippy_lint! {\n     /// # let y = 2;\n     /// if x <= y {}\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DOUBLE_COMPARISONS,\n     complexity,\n     \"unnecessary double comparisons that can be simplified\""}, {"sha": "e10f740d24a4193d4c141b7c1f1e96a12239353f", "filename": "src/tools/clippy/clippy_lints/src/double_parens.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_parens.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -32,6 +32,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// foo(0);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DOUBLE_PARENS,\n     complexity,\n     \"Warn on unnecessary double parentheses\""}, {"sha": "a8f8e3d8a42c0bba557b0dc04fdbb9b2f9730a6b", "filename": "src/tools/clippy/clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -25,6 +25,7 @@ declare_clippy_lint! {\n     /// // still locked\n     /// operation_that_requires_mutex_to_be_unlocked();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DROP_REF,\n     correctness,\n     \"calls to `std::mem::drop` with a reference instead of an owned value\"\n@@ -46,6 +47,7 @@ declare_clippy_lint! {\n     /// let x = Box::new(1);\n     /// std::mem::forget(&x) // Should have been forget(x), x will still be dropped\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub FORGET_REF,\n     correctness,\n     \"calls to `std::mem::forget` with a reference instead of an owned value\"\n@@ -67,6 +69,7 @@ declare_clippy_lint! {\n     /// std::mem::drop(x) // A copy of x is passed to the function, leaving the\n     ///                   // original unaffected\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DROP_COPY,\n     correctness,\n     \"calls to `std::mem::drop` with a value that implements Copy\"\n@@ -94,6 +97,7 @@ declare_clippy_lint! {\n     /// std::mem::forget(x) // A copy of x is passed to the function, leaving the\n     ///                     // original unaffected\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub FORGET_COPY,\n     correctness,\n     \"calls to `std::mem::forget` with a value that implements Copy\""}, {"sha": "3070d105014f561ea5274b09c733af42b1f4bbad", "filename": "src/tools/clippy/clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -33,6 +33,7 @@ declare_clippy_lint! {\n     /// let _micros = dur.subsec_micros();\n     /// let _millis = dur.subsec_millis();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DURATION_SUBSEC,\n     complexity,\n     \"checks for calculation of subsecond microseconds or milliseconds\""}, {"sha": "92c56c762aad61624155680f632f127a5f1c683d", "filename": "src/tools/clippy/clippy_lints/src/else_if_without_else.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -40,6 +40,7 @@ declare_clippy_lint! {\n     ///     // We don't care about zero.\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ELSE_IF_WITHOUT_ELSE,\n     restriction,\n     \"`if` expression with an `else if`, but without a final `else` branch\""}, {"sha": "af9e65e636135d8fb186f7390bb89d8047e46230", "filename": "src/tools/clippy/clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -34,6 +34,7 @@ declare_clippy_lint! {\n     ///\n     /// struct Test(!);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EMPTY_ENUM,\n     pedantic,\n     \"enum with no variants\""}, {"sha": "3d92eb16870e3d88c8d9460507d4b15cb20c4236", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -54,6 +54,7 @@ declare_clippy_lint! {\n     /// # let v = 1;\n     /// map.entry(k).or_insert(v);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MAP_ENTRY,\n     perf,\n     \"use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\""}, {"sha": "3b6661c817be7677fe01941e096af0e4f786c1ac", "filename": "src/tools/clippy/clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -28,6 +28,7 @@ declare_clippy_lint! {\n     ///     Y = 0,\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ENUM_CLIKE_UNPORTABLE_VARIANT,\n     correctness,\n     \"C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\""}, {"sha": "fc3a35efaf84db0afa05bffedd3e8f92245a75ef", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -34,6 +34,7 @@ declare_clippy_lint! {\n     ///     Battenberg,\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ENUM_VARIANT_NAMES,\n     style,\n     \"enums where all variants share a prefix/postfix\"\n@@ -59,6 +60,7 @@ declare_clippy_lint! {\n     ///     struct BlackForest;\n     /// }\n     /// ```\n+    #[clippy::version = \"1.33.0\"]\n     pub MODULE_NAME_REPETITIONS,\n     pedantic,\n     \"type names prefixed/postfixed with their containing module's name\"\n@@ -89,6 +91,7 @@ declare_clippy_lint! {\n     ///     ...\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MODULE_INCEPTION,\n     style,\n     \"modules that have the same name as their parent module\""}, {"sha": "101234605273393b13d7754d8ff28e0e1ee37725", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,9 +1,7 @@\n use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{\n-    ast_utils::is_useless_with_eq_exprs, eq_expr_value, higher, in_macro, is_expn_of, is_in_test_function,\n-};\n+use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, higher, is_expn_of, is_in_test_function};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, StmtKind};\n@@ -36,6 +34,7 @@ declare_clippy_lint! {\n     /// # let b = 4;\n     /// assert_eq!(a, a);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EQ_OP,\n     correctness,\n     \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\"\n@@ -61,6 +60,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// x == *y\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub OP_REF,\n     style,\n     \"taking a reference to satisfy the type constraints on `==`\"\n@@ -102,7 +102,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n             }\n             let macro_with_not_op = |expr_kind: &ExprKind<'_>| {\n                 if let ExprKind::Unary(_, expr) = *expr_kind {\n-                    in_macro(expr.span)\n+                    expr.span.from_expansion()\n                 } else {\n                     false\n                 }"}, {"sha": "8905cc0de45779408368701d73cb92f5b80196d1", "filename": "src/tools/clippy/clippy_lints/src/equatable_if_let.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -32,6 +32,7 @@ declare_clippy_lint! {\n     ///     do_thing();\n     /// }\n     /// ```\n+    #[clippy::version = \"1.57.0\"]\n     pub EQUATABLE_IF_LET,\n     nursery,\n     \"using pattern matching instead of equality\""}, {"sha": "d49cec26be5f02c6933c72e50227b5c8501b05ad", "filename": "src/tools/clippy/clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -21,6 +21,7 @@ declare_clippy_lint! {\n     /// 0 * x;\n     /// x & 0;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ERASING_OP,\n     correctness,\n     \"using erasing operations, e.g., `x * 0` or `y & 0`\""}, {"sha": "bc5d2f6278dee7e9c05fd58ce40fc0b80b7d16af", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -41,6 +41,7 @@ declare_clippy_lint! {\n     /// foo(x);\n     /// println!(\"{}\", x);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub BOXED_LOCAL,\n     perf,\n     \"using `Box<T>` where unnecessary\""}, {"sha": "5a4b424710440f03b947c4b03cabb337839df59d", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::higher::VecArgs;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::usage::UsedAfterExprVisitor;\n-use clippy_utils::{get_enclosing_loop_or_closure, higher, path_to_local_id};\n+use clippy_utils::usage::local_used_after_expr;\n+use clippy_utils::{get_enclosing_loop_or_closure, higher, path_to_local, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n@@ -39,6 +39,7 @@ declare_clippy_lint! {\n     /// ```\n     /// where `foo(_)` is a plain function that takes the exact argument type of\n     /// `x`.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub REDUNDANT_CLOSURE,\n     style,\n     \"redundant closures, i.e., `|a| foo(a)` (which can be written as just `foo`)\"\n@@ -60,6 +61,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// Some('a').map(char::to_uppercase);\n     /// ```\n+    #[clippy::version = \"1.35.0\"]\n     pub REDUNDANT_CLOSURE_FOR_METHOD_CALLS,\n     pedantic,\n     \"redundant closures for method calls\"\n@@ -118,7 +120,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n                             if let ty::Closure(_, substs) = callee_ty.peel_refs().kind();\n                             if substs.as_closure().kind() == ClosureKind::FnMut;\n                             if get_enclosing_loop_or_closure(cx.tcx, expr).is_some()\n-                                || UsedAfterExprVisitor::is_found(cx, callee);\n+                                || path_to_local(callee).map_or(false, |l| local_used_after_expr(cx, l, callee));\n \n                             then {\n                                 // Mutable closure is used after current expr; we cannot consume it."}, {"sha": "cdac9f3e6e1776949edb94d07a993b42f0d05c8a", "filename": "src/tools/clippy/clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -40,6 +40,7 @@ declare_clippy_lint! {\n     /// };\n     /// let a = tmp + x;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EVAL_ORDER_DEPENDENCE,\n     suspicious,\n     \"whether a variable read occurs before a write depends on sub-expression evaluation order\"\n@@ -67,6 +68,7 @@ declare_clippy_lint! {\n     /// let x = (a, b, c, panic!());\n     /// // can simply be replaced by `panic!()`\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DIVERGING_SUB_EXPRESSION,\n     complexity,\n     \"whether an expression contains a diverging sub expression\""}, {"sha": "245a4fc12fd4c04c6e305e83103fcc43bbbc0af9", "filename": "src/tools/clippy/clippy_lints/src/excessive_bools.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexcessive_bools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexcessive_bools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexcessive_bools.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::in_macro;\n use rustc_ast::ast::{AssocItemKind, Extern, Fn, FnSig, Impl, Item, ItemKind, Trait, Ty, TyKind};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -38,6 +37,7 @@ declare_clippy_lint! {\n     ///     Finished,\n     /// }\n     /// ```\n+    #[clippy::version = \"1.43.0\"]\n     pub STRUCT_EXCESSIVE_BOOLS,\n     pedantic,\n     \"using too many bools in a struct\"\n@@ -76,6 +76,7 @@ declare_clippy_lint! {\n     ///\n     /// fn f(shape: Shape, temperature: Temperature) { ... }\n     /// ```\n+    #[clippy::version = \"1.43.0\"]\n     pub FN_PARAMS_EXCESSIVE_BOOLS,\n     pedantic,\n     \"using too many bools in function parameters\"\n@@ -135,7 +136,7 @@ fn is_bool_ty(ty: &Ty) -> bool {\n \n impl EarlyLintPass for ExcessiveBools {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if in_macro(item.span) {\n+        if item.span.from_expansion() {\n             return;\n         }\n         match &item.kind {"}, {"sha": "b0f50b5c144bbe45a6487cee425aa3501258169f", "filename": "src/tools/clippy/clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -31,6 +31,7 @@ declare_clippy_lint! {\n     ///     Baz\n     /// }\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub EXHAUSTIVE_ENUMS,\n     restriction,\n     \"detects exported enums that have not been marked #[non_exhaustive]\"\n@@ -60,6 +61,7 @@ declare_clippy_lint! {\n     ///     baz: String,\n     /// }\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub EXHAUSTIVE_STRUCTS,\n     restriction,\n     \"detects exported structs that have not been marked #[non_exhaustive]\""}, {"sha": "d64cc61916c5eb4cf0bf00314253cc8b229d4b97", "filename": "src/tools/clippy/clippy_lints/src/exit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -18,6 +18,7 @@ declare_clippy_lint! {\n     /// ```ignore\n     /// std::process::exit(0)\n     /// ```\n+    #[clippy::version = \"1.41.0\"]\n     pub EXIT,\n     restriction,\n     \"`std::process::exit` is called, terminating the program\""}, {"sha": "6b327b9ce1720aeb1fbde29b499fb174f8a393e5", "filename": "src/tools/clippy/clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -23,6 +23,7 @@ declare_clippy_lint! {\n     /// // this would be clearer as `eprintln!(\"foo: {:?}\", bar);`\n     /// writeln!(&mut std::io::stderr(), \"foo: {:?}\", bar).unwrap();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EXPLICIT_WRITE,\n     complexity,\n     \"using the `write!()` family of functions instead of the `print!()` family of functions, when using the latter would work\""}, {"sha": "05d300058cf4f270ca6e9713c40deb1bbe7b1e8a", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -44,6 +44,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub FALLIBLE_IMPL_FROM,\n     nursery,\n     \"Warn on impls of `From<..>` that contain `panic!()` or `unwrap()`\""}, {"sha": "dc6bef52ddd9fb3256168e3cec80fd9a2bfb0af1", "filename": "src/tools/clippy/clippy_lints/src/feature_name.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffeature_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffeature_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffeature_name.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -31,6 +31,7 @@ declare_clippy_lint! {\n     /// ghi = []\n     /// ```\n     ///\n+    #[clippy::version = \"1.57.0\"]\n     pub REDUNDANT_FEATURE_NAMES,\n     cargo,\n     \"usage of a redundant feature name\"\n@@ -60,6 +61,7 @@ declare_clippy_lint! {\n     /// def = []\n     ///\n     /// ```\n+    #[clippy::version = \"1.57.0\"]\n     pub NEGATIVE_FEATURE_NAMES,\n     cargo,\n     \"usage of a negative feature name\""}, {"sha": "ca8886228de264a042c24c89e2f9688d4c15bb9f", "filename": "src/tools/clippy/clippy_lints/src/float_equality_without_abs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -37,6 +37,7 @@ declare_clippy_lint! {\n     ///     (a - b).abs() < f32::EPSILON\n     /// }\n     /// ```\n+    #[clippy::version = \"1.48.0\"]\n     pub FLOAT_EQUALITY_WITHOUT_ABS,\n     suspicious,\n     \"float equality check without `.abs()`\""}, {"sha": "d30dede833cbf50104651c2112b361d6ffbf5157", "filename": "src/tools/clippy/clippy_lints/src/float_literal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -27,6 +27,7 @@ declare_clippy_lint! {\n     /// let v: f64 = 0.123_456_789_9;\n     /// println!(\"{}\", v); //  0.123_456_789_9\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EXCESSIVE_PRECISION,\n     style,\n     \"excessive precision for float literal\"\n@@ -50,6 +51,7 @@ declare_clippy_lint! {\n     /// let _: f32 = 16_777_216.0;\n     /// let _: f64 = 16_777_217.0;\n     /// ```\n+    #[clippy::version = \"1.43.0\"]\n     pub LOSSY_FLOAT_LITERAL,\n     restriction,\n     \"lossy whole number float literals\""}, {"sha": "3df511ea8e780e20496d0636a3af3435b5fa001e", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::consts::{\n };\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n-use clippy_utils::{eq_expr_value, get_parent_expr, numeric_literal, sugg};\n+use clippy_utils::{eq_expr_value, get_parent_expr, in_constant, numeric_literal, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, UnOp};\n@@ -43,6 +43,7 @@ declare_clippy_lint! {\n     /// let _ = a.ln_1p();\n     /// let _ = a.exp_m1();\n     /// ```\n+    #[clippy::version = \"1.43.0\"]\n     pub IMPRECISE_FLOPS,\n     nursery,\n     \"usage of imprecise floating point operations\"\n@@ -99,6 +100,7 @@ declare_clippy_lint! {\n     /// let _ = a.abs();\n     /// let _ = -a.abs();\n     /// ```\n+    #[clippy::version = \"1.43.0\"]\n     pub SUBOPTIMAL_FLOPS,\n     nursery,\n     \"usage of sub-optimal floating point operations\"\n@@ -685,6 +687,11 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        // All of these operations are currently not const.\n+        if in_constant(cx, expr.hir_id) {\n+            return;\n+        }\n+\n         if let ExprKind::MethodCall(path, _, args, _) = &expr.kind {\n             let recv_ty = cx.typeck_results().expr_ty(&args[0]);\n "}, {"sha": "3f043e5f2f1c55be2ec3b1833297bfb76e8d547b", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -33,6 +33,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// foo.to_owned();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub USELESS_FORMAT,\n     complexity,\n     \"useless use of `format!`\""}, {"sha": "f0e1a67dcddb93d852d21eeae72b812be8280dbe", "filename": "src/tools/clippy/clippy_lints/src/format_args.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -10,7 +10,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_middle::ty::Ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{sym, BytePos, ExpnData, ExpnKind, Span, Symbol};\n+use rustc_span::{sym, ExpnData, ExpnKind, Span, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -31,6 +31,7 @@ declare_clippy_lint! {\n     /// # use std::panic::Location;\n     /// println!(\"error: something failed at {}\", Location::caller());\n     /// ```\n+    #[clippy::version = \"1.58.0\"]\n     pub FORMAT_IN_FORMAT_ARGS,\n     perf,\n     \"`format!` used in a macro that does formatting\"\n@@ -56,6 +57,7 @@ declare_clippy_lint! {\n     /// # use std::panic::Location;\n     /// println!(\"error: something failed at {}\", Location::caller());\n     /// ```\n+    #[clippy::version = \"1.58.0\"]\n     pub TO_STRING_IN_FORMAT_ARGS,\n     perf,\n     \"`to_string` applied to a type that implements `Display` in format args\"\n@@ -128,7 +130,7 @@ fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symb\n             span_lint_and_then(\n                 cx,\n                 FORMAT_IN_FORMAT_ARGS,\n-                trim_semicolon(cx, call_site),\n+                call_site,\n                 &format!(\"`format!` in `{}!` args\", name),\n                 |diag| {\n                     diag.help(&format!(\n@@ -192,13 +194,6 @@ fn is_aliased(args: &[FormatArgsArg<'_>], i: usize) -> bool {\n         .any(|(j, arg)| i != j && std::ptr::eq(value, arg.value))\n }\n \n-fn trim_semicolon(cx: &LateContext<'_>, span: Span) -> Span {\n-    snippet_opt(cx, span).map_or(span, |snippet| {\n-        let snippet = snippet.trim_end_matches(';');\n-        span.with_hi(span.lo() + BytePos(u32::try_from(snippet.len()).unwrap()))\n-    })\n-}\n-\n fn count_needed_derefs<'tcx, I>(mut ty: Ty<'tcx>, mut iter: I) -> (usize, Ty<'tcx>)\n where\n     I: Iterator<Item = &'tcx Adjustment<'tcx>>,"}, {"sha": "3e85c8a9c8071a91bc65f45dbc847207e743e1ff", "filename": "src/tools/clippy/clippy_lints/src/formatting.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -21,6 +21,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// a =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SUSPICIOUS_ASSIGNMENT_FORMATTING,\n     suspicious,\n     \"suspicious formatting of `*=`, `-=` or `!=`\"\n@@ -43,6 +44,7 @@ declare_clippy_lint! {\n     /// if foo &&! bar { // this should be `foo && !bar` but looks like a different operator\n     /// }\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub SUSPICIOUS_UNARY_OP_FORMATTING,\n     suspicious,\n     \"suspicious formatting of unary `-` or `!` on the RHS of a BinOp\"\n@@ -79,6 +81,7 @@ declare_clippy_lint! {\n     /// if bar { // this is the `else` block of the previous `if`, but should it be?\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SUSPICIOUS_ELSE_FORMATTING,\n     suspicious,\n     \"suspicious formatting of `else`\"\n@@ -99,6 +102,7 @@ declare_clippy_lint! {\n     ///     -4, -5, -6\n     /// ];\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub POSSIBLE_MISSING_COMMA,\n     correctness,\n     \"possible missing comma in array\""}, {"sha": "866ff216f84a21df3dc04355760f8d8e4a11e40b", "filename": "src/tools/clippy/clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -34,6 +34,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub FROM_OVER_INTO,\n     style,\n     \"Warns on implementations of `Into<..>` to use `From<..>`\""}, {"sha": "73e800073b03fe6c0f0e6d93ceef01a834f0dd61", "filename": "src/tools/clippy/clippy_lints/src/from_str_radix_10.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_str_radix_10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_str_radix_10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_str_radix_10.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -35,6 +35,7 @@ declare_clippy_lint! {\n     /// let input: &str = get_input();\n     /// let num: u16 = input.parse()?;\n     /// ```\n+    #[clippy::version = \"1.52.0\"]\n     pub FROM_STR_RADIX_10,\n     style,\n     \"from_str_radix with radix 10\""}, {"sha": "ad031cbc09d4d0f631b4fcf87df345aa97924985", "filename": "src/tools/clippy/clippy_lints/src/functions/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -26,6 +26,7 @@ declare_clippy_lint! {\n     ///     // ..\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub TOO_MANY_ARGUMENTS,\n     complexity,\n     \"functions with too many arguments\"\n@@ -49,6 +50,7 @@ declare_clippy_lint! {\n     ///     println!(\"\");\n     /// }\n     /// ```\n+    #[clippy::version = \"1.34.0\"]\n     pub TOO_MANY_LINES,\n     pedantic,\n     \"functions with too many lines\"\n@@ -84,6 +86,7 @@ declare_clippy_lint! {\n     ///     println!(\"{}\", unsafe { *x });\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NOT_UNSAFE_PTR_ARG_DEREF,\n     correctness,\n     \"public functions dereferencing raw pointer arguments but not marked `unsafe`\"\n@@ -103,6 +106,7 @@ declare_clippy_lint! {\n     /// #[must_use]\n     /// fn useless() { }\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub MUST_USE_UNIT,\n     style,\n     \"`#[must_use]` attribute on a unit-returning function / method\"\n@@ -126,6 +130,7 @@ declare_clippy_lint! {\n     ///     unimplemented!();\n     /// }\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub DOUBLE_MUST_USE,\n     style,\n     \"`#[must_use]` attribute on a `#[must_use]`-returning function / method\"\n@@ -155,6 +160,7 @@ declare_clippy_lint! {\n     /// // this could be annotated with `#[must_use]`.\n     /// fn id<T>(t: T) -> T { t }\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub MUST_USE_CANDIDATE,\n     pedantic,\n     \"function or method that could take a `#[must_use]` attribute\"\n@@ -204,6 +210,7 @@ declare_clippy_lint! {\n     ///\n     /// Note that there are crates that simplify creating the error type, e.g.\n     /// [`thiserror`](https://docs.rs/thiserror).\n+    #[clippy::version = \"1.49.0\"]\n     pub RESULT_UNIT_ERR,\n     style,\n     \"public function returning `Result` with an `Err` type of `()`\""}, {"sha": "65efbbab41a460f0ab4f9b2c84a400cbe22efeee", "filename": "src/tools/clippy/clippy_lints/src/functions/too_many_lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -56,8 +56,8 @@ pub(super) fn check_fn(\n                     continue;\n                 }\n             } else {\n-                let multi_idx = line.find(\"/*\").unwrap_or_else(|| line.len());\n-                let single_idx = line.find(\"//\").unwrap_or_else(|| line.len());\n+                let multi_idx = line.find(\"/*\").unwrap_or(line.len());\n+                let single_idx = line.find(\"//\").unwrap_or(line.len());\n                 code_in_line |= multi_idx > 0 && single_idx > 0;\n                 // Implies multi_idx is below line.len()\n                 if multi_idx < single_idx {"}, {"sha": "fefdcfed42f5465fd1235a96a46596368e0b6194", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -41,6 +41,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// async fn is_send(bytes: std::sync::Arc<[u8]>) {}\n     /// ```\n+    #[clippy::version = \"1.44.0\"]\n     pub FUTURE_NOT_SEND,\n     nursery,\n     \"public Futures must be Send\""}, {"sha": "edca701869e0fc2eb89dd14574a9700957f414df", "filename": "src/tools/clippy/clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -39,6 +39,7 @@ declare_clippy_lint! {\n     /// let x = vec![2, 3, 5];\n     /// let last_element = x.last();\n     /// ```\n+    #[clippy::version = \"1.37.0\"]\n     pub GET_LAST_WITH_LEN,\n     complexity,\n     \"Using `x.get(x.len() - 1)` when `x.last()` is correct and simpler\""}, {"sha": "b4e7bbc767135474d1c33d5b3b601e4548a89ad0", "filename": "src/tools/clippy/clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -22,6 +22,7 @@ declare_clippy_lint! {\n     /// # let x = 1;\n     /// x / 1 + 0 * 1 - 0 | 0;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub IDENTITY_OP,\n     complexity,\n     \"using identity operations, e.g., `x + 0` or `y / 1`\""}, {"sha": "e20741d2407e63b21a09ff0b4d40b299dbedcd77", "filename": "src/tools/clippy/clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -36,6 +36,7 @@ declare_clippy_lint! {\n     ///     use_locked(locked);\n     /// }\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub IF_LET_MUTEX,\n     correctness,\n     \"locking a `Mutex` in an `if let` block can cause deadlocks\""}, {"sha": "3d59b783337a441b3ca1151f19667fe0174b41b4", "filename": "src/tools/clippy/clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_not_else.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -39,6 +39,7 @@ declare_clippy_lint! {\n     ///     a()\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub IF_NOT_ELSE,\n     pedantic,\n     \"`if` branches that could be swapped so no negation operation is necessary on the condition\""}, {"sha": "30d222bd7d27de9643047c51f282d05357aadba1", "filename": "src/tools/clippy/clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs};\n+use clippy_utils::{contains_return, higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs};\n use if_chain::if_chain;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::{Expr, ExprKind, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_semver::RustcVersion;\n@@ -36,6 +36,7 @@ declare_clippy_lint! {\n     ///     42\n     /// });\n     /// ```\n+    #[clippy::version = \"1.53.0\"]\n     pub IF_THEN_SOME_ELSE_NONE,\n     restriction,\n     \"Finds if-else that could be written using `bool::then`\"\n@@ -81,6 +82,7 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n             if let Some(els_expr) = els_block.expr;\n             if let ExprKind::Path(ref qpath) = els_expr.kind;\n             if is_lang_ctor(cx, qpath, OptionNone);\n+            if !stmts_contains_early_return(then_block.stmts);\n             then {\n                 let cond_snip = snippet_with_macro_callsite(cx, cond.span, \"[condition]\");\n                 let cond_snip = if matches!(cond.kind, ExprKind::Unary(_, _) | ExprKind::Binary(_, _, _)) {\n@@ -113,3 +115,11 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n \n     extract_msrv_attr!(LateContext);\n }\n+\n+fn stmts_contains_early_return(stmts: &[Stmt<'_>]) -> bool {\n+    stmts.iter().any(|stmt| {\n+        let Stmt { kind: StmtKind::Semi(e), .. } = stmt else { return false };\n+\n+        contains_return(e)\n+    })\n+}"}, {"sha": "6358228dd47f0e421cc06a7f1306655db868234f", "filename": "src/tools/clippy/clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -54,6 +54,7 @@ declare_clippy_lint! {\n     ///\n     /// pub fn foo<S: BuildHasher>(map: &mut HashMap<i32, i32, S>) { }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub IMPLICIT_HASHER,\n     pedantic,\n     \"missing generalization over different hashers\""}, {"sha": "07caeada80d003fa96f48474a741c22bacf121d0", "filename": "src/tools/clippy/clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -2,10 +2,10 @@ use clippy_utils::{\n     diagnostics::span_lint_and_sugg,\n     get_async_fn_body, is_async_fn,\n     source::{snippet_with_applicability, snippet_with_context, walk_span_to_context},\n-    visitors::visit_break_exprs,\n+    visitors::expr_visitor_no_bodies,\n };\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::FnKind;\n+use rustc_hir::intravisit::{FnKind, Visitor};\n use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, FnRetTy, HirId};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -35,6 +35,7 @@ declare_clippy_lint! {\n     ///     return x;\n     /// }\n     /// ```\n+    #[clippy::version = \"1.33.0\"]\n     pub IMPLICIT_RETURN,\n     restriction,\n     \"use a return statement like `return expr` instead of an expression\"\n@@ -144,20 +145,24 @@ fn lint_implicit_returns(\n \n         ExprKind::Loop(block, ..) => {\n             let mut add_return = false;\n-            visit_break_exprs(block, |break_expr, dest, sub_expr| {\n-                if dest.target_id.ok() == Some(expr.hir_id) {\n-                    if call_site_span.is_none() && break_expr.span.ctxt() == ctxt {\n-                        // At this point sub_expr can be `None` in async functions which either diverge, or return the\n-                        // unit type.\n-                        if let Some(sub_expr) = sub_expr {\n-                            lint_break(cx, break_expr.span, sub_expr.span);\n+            expr_visitor_no_bodies(|e| {\n+                if let ExprKind::Break(dest, sub_expr) = e.kind {\n+                    if dest.target_id.ok() == Some(expr.hir_id) {\n+                        if call_site_span.is_none() && e.span.ctxt() == ctxt {\n+                            // At this point sub_expr can be `None` in async functions which either diverge, or return\n+                            // the unit type.\n+                            if let Some(sub_expr) = sub_expr {\n+                                lint_break(cx, e.span, sub_expr.span);\n+                            }\n+                        } else {\n+                            // the break expression is from a macro call, add a return to the loop\n+                            add_return = true;\n                         }\n-                    } else {\n-                        // the break expression is from a macro call, add a return to the loop\n-                        add_return = true;\n                     }\n                 }\n-            });\n+                true\n+            })\n+            .visit_block(block);\n             if add_return {\n                 #[allow(clippy::option_if_let_else)]\n                 if let Some(span) = call_site_span {"}, {"sha": "4088c54623d36a3dc4187589ada0bf02e4345053", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n-use clippy_utils::{in_macro, SpanlessEq};\n+use clippy_utils::SpanlessEq;\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -30,6 +30,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// i = i.saturating_sub(1);\n     /// ```\n+    #[clippy::version = \"1.44.0\"]\n     pub IMPLICIT_SATURATING_SUB,\n     pedantic,\n     \"Perform saturating subtraction instead of implicitly checking lower bound of data type\"\n@@ -39,7 +40,7 @@ declare_lint_pass!(ImplicitSaturatingSub => [IMPLICIT_SATURATING_SUB]);\n \n impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if in_macro(expr.span) {\n+        if expr.span.from_expansion() {\n             return;\n         }\n         if_chain! {"}, {"sha": "1debdef9d86c7b077594bef9115ec3fbf70d8f9b", "filename": "src/tools/clippy/clippy_lints/src/inconsistent_struct_constructor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::in_macro;\n use clippy_utils::source::snippet;\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n@@ -56,6 +55,7 @@ declare_clippy_lint! {\n     /// # let y = 2;\n     /// Foo { x, y };\n     /// ```\n+    #[clippy::version = \"1.52.0\"]\n     pub INCONSISTENT_STRUCT_CONSTRUCTOR,\n     pedantic,\n     \"the order of the field init shorthand is inconsistent with the order in the struct definition\"\n@@ -66,7 +66,7 @@ declare_lint_pass!(InconsistentStructConstructor => [INCONSISTENT_STRUCT_CONSTRU\n impl LateLintPass<'_> for InconsistentStructConstructor {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n-            if !in_macro(expr.span);\n+            if !expr.span.from_expansion();\n             if let ExprKind::Struct(qpath, fields, base) = expr.kind;\n             let ty = cx.typeck_results().expr_ty(expr);\n             if let Some(adt_def) = ty.ty_adt_def();"}, {"sha": "69f1c90beec5d31cc049262194ee7a0526874d02", "filename": "src/tools/clippy/clippy_lints/src/index_refutable_slice.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -0,0 +1,276 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher::IfLet;\n+use clippy_utils::ty::is_copy;\n+use clippy_utils::{is_expn_of, is_lint_allowed, meets_msrv, msrvs, path_to_local};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{symbol::Ident, Span};\n+use std::convert::TryInto;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// The lint checks for slice bindings in patterns that are only used to\n+    /// access individual slice values.\n+    ///\n+    /// ### Why is this bad?\n+    /// Accessing slice values using indices can lead to panics. Using refutable\n+    /// patterns can avoid these. Binding to individual values also improves the\n+    /// readability as they can be named.\n+    ///\n+    /// ### Limitations\n+    /// This lint currently only checks for immutable access inside `if let`\n+    /// patterns.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+    ///\n+    /// if let Some(slice) = slice {\n+    ///     println!(\"{}\", slice[0]);\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+    ///\n+    /// if let Some(&[first, ..]) = slice {\n+    ///     println!(\"{}\", first);\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.58.0\"]\n+    pub INDEX_REFUTABLE_SLICE,\n+    nursery,\n+    \"avoid indexing on slices which could be destructed\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct IndexRefutableSlice {\n+    max_suggested_slice: u64,\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl IndexRefutableSlice {\n+    pub fn new(max_suggested_slice_pattern_length: u64, msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            max_suggested_slice: max_suggested_slice_pattern_length,\n+            msrv,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(IndexRefutableSlice => [INDEX_REFUTABLE_SLICE]);\n+\n+impl LateLintPass<'_> for IndexRefutableSlice {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if_chain! {\n+            if !expr.span.from_expansion() || is_expn_of(expr.span, \"if_chain\").is_some();\n+            if let Some(IfLet {let_pat, if_then, ..}) = IfLet::hir(cx, expr);\n+            if !is_lint_allowed(cx, INDEX_REFUTABLE_SLICE, expr.hir_id);\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::SLICE_PATTERNS);\n+\n+            let found_slices = find_slice_values(cx, let_pat);\n+            if !found_slices.is_empty();\n+            let filtered_slices = filter_lintable_slices(cx, found_slices, self.max_suggested_slice, if_then);\n+            if !filtered_slices.is_empty();\n+            then {\n+                for slice in filtered_slices.values() {\n+                    lint_slice(cx, slice);\n+                }\n+            }\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxHashMap<hir::HirId, SliceLintInformation> {\n+    let mut removed_pat: FxHashSet<hir::HirId> = FxHashSet::default();\n+    let mut slices: FxHashMap<hir::HirId, SliceLintInformation> = FxHashMap::default();\n+    pat.walk_always(|pat| {\n+        if let hir::PatKind::Binding(binding, value_hir_id, ident, sub_pat) = pat.kind {\n+            // We'll just ignore mut and ref mut for simplicity sake right now\n+            if let hir::BindingAnnotation::Mutable | hir::BindingAnnotation::RefMut = binding {\n+                return;\n+            }\n+\n+            // This block catches bindings with sub patterns. It would be hard to build a correct suggestion\n+            // for them and it's likely that the user knows what they are doing in such a case.\n+            if removed_pat.contains(&value_hir_id) {\n+                return;\n+            }\n+            if sub_pat.is_some() {\n+                removed_pat.insert(value_hir_id);\n+                slices.remove(&value_hir_id);\n+                return;\n+            }\n+\n+            let bound_ty = cx.typeck_results().node_type(pat.hir_id);\n+            if let ty::Slice(inner_ty) | ty::Array(inner_ty, _) = bound_ty.peel_refs().kind() {\n+                // The values need to use the `ref` keyword if they can't be copied.\n+                // This will need to be adjusted if the lint want to support multable access in the future\n+                let src_is_ref = bound_ty.is_ref() && binding != hir::BindingAnnotation::Ref;\n+                let needs_ref = !(src_is_ref || is_copy(cx, inner_ty));\n+\n+                let slice_info = slices\n+                    .entry(value_hir_id)\n+                    .or_insert_with(|| SliceLintInformation::new(ident, needs_ref));\n+                slice_info.pattern_spans.push(pat.span);\n+            }\n+        }\n+    });\n+\n+    slices\n+}\n+\n+fn lint_slice(cx: &LateContext<'_>, slice: &SliceLintInformation) {\n+    let used_indices = slice\n+        .index_use\n+        .iter()\n+        .map(|(index, _)| *index)\n+        .collect::<FxHashSet<_>>();\n+\n+    let value_name = |index| format!(\"{}_{}\", slice.ident.name, index);\n+\n+    if let Some(max_index) = used_indices.iter().max() {\n+        let opt_ref = if slice.needs_ref { \"ref \" } else { \"\" };\n+        let pat_sugg_idents = (0..=*max_index)\n+            .map(|index| {\n+                if used_indices.contains(&index) {\n+                    format!(\"{}{}\", opt_ref, value_name(index))\n+                } else {\n+                    \"_\".to_string()\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+        let pat_sugg = format!(\"[{}, ..]\", pat_sugg_idents.join(\", \"));\n+\n+        span_lint_and_then(\n+            cx,\n+            INDEX_REFUTABLE_SLICE,\n+            slice.ident.span,\n+            \"this binding can be a slice pattern to avoid indexing\",\n+            |diag| {\n+                diag.multipart_suggestion(\n+                    \"try using a slice pattern here\",\n+                    slice\n+                        .pattern_spans\n+                        .iter()\n+                        .map(|span| (*span, pat_sugg.clone()))\n+                        .collect(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+\n+                diag.multipart_suggestion(\n+                    \"and replace the index expressions here\",\n+                    slice\n+                        .index_use\n+                        .iter()\n+                        .map(|(index, span)| (*span, value_name(*index)))\n+                        .collect(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+\n+                // The lint message doesn't contain a warning about the removed index expression,\n+                // since `filter_lintable_slices` will only return slices where all access indices\n+                // are known at compile time. Therefore, they can be removed without side effects.\n+            },\n+        );\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct SliceLintInformation {\n+    ident: Ident,\n+    needs_ref: bool,\n+    pattern_spans: Vec<Span>,\n+    index_use: Vec<(u64, Span)>,\n+}\n+\n+impl SliceLintInformation {\n+    fn new(ident: Ident, needs_ref: bool) -> Self {\n+        Self {\n+            ident,\n+            needs_ref,\n+            pattern_spans: Vec::new(),\n+            index_use: Vec::new(),\n+        }\n+    }\n+}\n+\n+fn filter_lintable_slices<'a, 'tcx>(\n+    cx: &'a LateContext<'tcx>,\n+    slice_lint_info: FxHashMap<hir::HirId, SliceLintInformation>,\n+    max_suggested_slice: u64,\n+    scope: &'tcx hir::Expr<'tcx>,\n+) -> FxHashMap<hir::HirId, SliceLintInformation> {\n+    let mut visitor = SliceIndexLintingVisitor {\n+        cx,\n+        slice_lint_info,\n+        max_suggested_slice,\n+    };\n+\n+    intravisit::walk_expr(&mut visitor, scope);\n+\n+    visitor.slice_lint_info\n+}\n+\n+struct SliceIndexLintingVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    slice_lint_info: FxHashMap<hir::HirId, SliceLintInformation>,\n+    max_suggested_slice: u64,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SliceIndexLintingVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n+        if let Some(local_id) = path_to_local(expr) {\n+            let Self {\n+                cx,\n+                ref mut slice_lint_info,\n+                max_suggested_slice,\n+            } = *self;\n+\n+            if_chain! {\n+                // Check if this is even a local we're interested in\n+                if let Some(use_info) = slice_lint_info.get_mut(&local_id);\n+\n+                let map = cx.tcx.hir();\n+\n+                // Checking for slice indexing\n+                let parent_id = map.get_parent_node(expr.hir_id);\n+                if let Some(hir::Node::Expr(parent_expr)) = map.find(parent_id);\n+                if let hir::ExprKind::Index(_, index_expr) = parent_expr.kind;\n+                if let Some((Constant::Int(index_value), _)) = constant(cx, cx.typeck_results(), index_expr);\n+                if let Ok(index_value) = index_value.try_into();\n+                if index_value < max_suggested_slice;\n+\n+                // Make sure that this slice index is read only\n+                let maybe_addrof_id = map.get_parent_node(parent_id);\n+                if let Some(hir::Node::Expr(maybe_addrof_expr)) = map.find(maybe_addrof_id);\n+                if let hir::ExprKind::AddrOf(_kind, hir::Mutability::Not, _inner_expr) = maybe_addrof_expr.kind;\n+                then {\n+                    use_info.index_use.push((index_value, map.span(parent_expr.hir_id)));\n+                    return;\n+                }\n+            }\n+\n+            // The slice was used for something other than indexing\n+            self.slice_lint_info.remove(&local_id);\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n+}"}, {"sha": "9ead4bb27a5881eb3ab43d6def4481f658999b44", "filename": "src/tools/clippy/clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -33,6 +33,7 @@ declare_clippy_lint! {\n     /// x[0];\n     /// x[3];\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub OUT_OF_BOUNDS_INDEXING,\n     correctness,\n     \"out of bounds constant indexing\"\n@@ -85,6 +86,7 @@ declare_clippy_lint! {\n     /// y.get(10..);\n     /// y.get(..100);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub INDEXING_SLICING,\n     restriction,\n     \"indexing/slicing usage\""}, {"sha": "c7db47a552b2cef43093f7af8e4094b3b91025dc", "filename": "src/tools/clippy/clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -20,6 +20,7 @@ declare_clippy_lint! {\n     ///\n     /// iter::repeat(1_u8).collect::<Vec<_>>();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub INFINITE_ITER,\n     correctness,\n     \"infinite iteration\"\n@@ -42,6 +43,7 @@ declare_clippy_lint! {\n     /// let infinite_iter = 0..;\n     /// [0..].iter().zip(infinite_iter.take_while(|x| *x > 5));\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MAYBE_INFINITE_ITER,\n     pedantic,\n     \"possible infinite iteration\""}, {"sha": "254d3f8a4d0f901a672585236c66e19819d963a5", "filename": "src/tools/clippy/clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,7 +1,7 @@\n //! lint on inherent implementations\n \n use clippy_utils::diagnostics::span_lint_and_note;\n-use clippy_utils::{in_macro, is_lint_allowed};\n+use clippy_utils::is_lint_allowed;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{def_id::LocalDefId, Item, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -36,6 +36,7 @@ declare_clippy_lint! {\n     ///     fn other() {}\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MULTIPLE_INHERENT_IMPL,\n     restriction,\n     \"Multiple inherent impl that could be grouped\"\n@@ -123,8 +124,10 @@ fn get_impl_span(cx: &LateContext<'_>, id: LocalDefId) -> Option<Span> {\n         ..\n     }) = cx.tcx.hir().get(id)\n     {\n-        (!in_macro(span) && impl_item.generics.params.is_empty() && !is_lint_allowed(cx, MULTIPLE_INHERENT_IMPL, id))\n-            .then(|| span)\n+        (!span.from_expansion()\n+            && impl_item.generics.params.is_empty()\n+            && !is_lint_allowed(cx, MULTIPLE_INHERENT_IMPL, id))\n+        .then(|| span)\n     } else {\n         None\n     }"}, {"sha": "60d234cd6f08f19fcb904f3b68df5a5ccab418b1", "filename": "src/tools/clippy/clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -41,6 +41,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.38.0\"]\n     pub INHERENT_TO_STRING,\n     style,\n     \"type implements inherent method `to_string()`, but should instead implement the `Display` trait\"\n@@ -88,6 +89,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.38.0\"]\n     pub INHERENT_TO_STRING_SHADOW_DISPLAY,\n     correctness,\n     \"type implements inherent method `to_string()`, which gets shadowed by the implementation of the `Display` trait\""}, {"sha": "df69d3dcc51603fa18e14d8177667c359f3c179a", "filename": "src/tools/clippy/clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -24,6 +24,7 @@ declare_clippy_lint! {\n     ///     fn name(&self) -> &'static str;\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub INLINE_FN_WITHOUT_BODY,\n     correctness,\n     \"use of `#[inline]` on trait methods without bodies\""}, {"sha": "3716d36ad88168a2fb7eb84f1a02484981c3d341", "filename": "src/tools/clippy/clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -28,6 +28,7 @@ declare_clippy_lint! {\n     /// # let y = 1;\n     /// if x > y {}\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub INT_PLUS_ONE,\n     complexity,\n     \"instead of using `x >= y + 1`, use `x > y`\""}, {"sha": "fa78620567880e64488c3d613240e07313907339", "filename": "src/tools/clippy/clippy_lints/src/integer_division.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -23,6 +23,7 @@ declare_clippy_lint! {\n     /// let x = 3f32 / 2f32;\n     /// println!(\"{}\", x);\n     /// ```\n+    #[clippy::version = \"1.37.0\"]\n     pub INTEGER_DIVISION,\n     restriction,\n     \"integer division may cause loss of precision\""}, {"sha": "36e03e50a8e4f4c2c950bb297f88b8d374524f6d", "filename": "src/tools/clippy/clippy_lints/src/invalid_upcast_comparisons.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -30,6 +30,7 @@ declare_clippy_lint! {\n     /// let x: u8 = 1;\n     /// (x as u32) > 300;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub INVALID_UPCAST_COMPARISONS,\n     pedantic,\n     \"a comparison involving an upcast which is always true or false\""}, {"sha": "b118d3c8b8727242427c85d4383eb381458e3ddb", "filename": "src/tools/clippy/clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -45,6 +45,7 @@ declare_clippy_lint! {\n     ///     foo(); // prints \"foo\"\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ITEMS_AFTER_STATEMENTS,\n     pedantic,\n     \"blocks where an item comes after a statement\""}, {"sha": "968bbc524b2514080059f90daa9b04bb3a61d0b9", "filename": "src/tools/clippy/clippy_lints/src/iter_not_returning_iterator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -32,6 +32,7 @@ declare_clippy_lint! {\n     ///    }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.57.0\"]\n     pub ITER_NOT_RETURNING_ITERATOR,\n     pedantic,\n     \"methods named `iter` or `iter_mut` that do not return an `Iterator`\""}, {"sha": "80260e4cd8315f3c42738bdd19cd0afccd2b1c1c", "filename": "src/tools/clippy/clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -27,6 +27,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// pub static a = [0u32; 1_000_000];\n     /// ```\n+    #[clippy::version = \"1.44.0\"]\n     pub LARGE_CONST_ARRAYS,\n     perf,\n     \"large non-scalar const array may cause performance overhead\""}, {"sha": "0191713f60d3f599f773303b61dfa3331c1170ae", "filename": "src/tools/clippy/clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -40,6 +40,7 @@ declare_clippy_lint! {\n     ///     B(Box<[i32; 8000]>),\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub LARGE_ENUM_VARIANT,\n     perf,\n     \"large size difference between variants on an enum\""}, {"sha": "1cc2c28c04ad4dfb0c351091ec550ed753cb0826", "filename": "src/tools/clippy/clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -19,6 +19,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// let a = [0u32; 1_000_000];\n     /// ```\n+    #[clippy::version = \"1.41.0\"]\n     pub LARGE_STACK_ARRAYS,\n     pedantic,\n     \"allocating large arrays on stack may cause stack overflow\""}, {"sha": "09cd0d22d8b0fb3eb45da2f41aa21f28eb3e85c2", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -46,6 +46,7 @@ declare_clippy_lint! {\n     ///     ..\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub LEN_ZERO,\n     style,\n     \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\"\n@@ -71,6 +72,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub LEN_WITHOUT_IS_EMPTY,\n     style,\n     \"traits or impls with a public `len` method but no corresponding `is_empty` method\"\n@@ -108,6 +110,7 @@ declare_clippy_lint! {\n     ///     ..\n     /// }\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub COMPARISON_TO_EMPTY,\n     style,\n     \"checking `x == \\\"\\\"` or `x == []` (or similar) when `.is_empty()` could be used instead\""}, {"sha": "db09d00d7303f3e80cdd876be081a7ac664c2b29", "filename": "src/tools/clippy/clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -48,6 +48,7 @@ declare_clippy_lint! {\n     ///     None\n     /// };\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub USELESS_LET_IF_SEQ,\n     nursery,\n     \"unidiomatic `let mut` declaration followed by initialization in `if`\""}, {"sha": "d03276f7f98ba70912584d40a3256c88c0d86d58", "filename": "src/tools/clippy/clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -26,14 +26,16 @@ declare_clippy_lint! {\n     /// // is_ok() is marked #[must_use]\n     /// let _ = f().is_ok();\n     /// ```\n+    #[clippy::version = \"1.42.0\"]\n     pub LET_UNDERSCORE_MUST_USE,\n     restriction,\n     \"non-binding let on a `#[must_use]` expression\"\n }\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for `let _ = sync_lock`\n+    /// Checks for `let _ = sync_lock`.\n+    /// This supports `mutex` and `rwlock` in `std::sync` and `parking_lot`.\n     ///\n     /// ### Why is this bad?\n     /// This statement immediately drops the lock instead of\n@@ -53,6 +55,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// let _lock = mutex.lock();\n     /// ```\n+    #[clippy::version = \"1.43.0\"]\n     pub LET_UNDERSCORE_LOCK,\n     correctness,\n     \"non-binding let on a synchronization lock\"\n@@ -94,17 +97,20 @@ declare_clippy_lint! {\n     ///     // dropped at end of scope\n     /// }\n     /// ```\n+    #[clippy::version = \"1.50.0\"]\n     pub LET_UNDERSCORE_DROP,\n     pedantic,\n     \"non-binding let on a type that implements `Drop`\"\n }\n \n declare_lint_pass!(LetUnderscore => [LET_UNDERSCORE_MUST_USE, LET_UNDERSCORE_LOCK, LET_UNDERSCORE_DROP]);\n \n-const SYNC_GUARD_PATHS: [&[&str]; 3] = [\n+const SYNC_GUARD_PATHS: [&[&str]; 5] = [\n     &paths::MUTEX_GUARD,\n     &paths::RWLOCK_READ_GUARD,\n     &paths::RWLOCK_WRITE_GUARD,\n+    &paths::PARKING_LOT_RAWMUTEX,\n+    &paths::PARKING_LOT_RAWRWLOCK,\n ];\n \n impl<'tcx> LateLintPass<'tcx> for LetUnderscore {"}, {"sha": "b7b5f059de6fc961f7820bfcfc2bae8ae18f2eb3", "filename": "src/tools/clippy/clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -33,6 +33,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(copies::IFS_SAME_COND),\n     LintId::of(copies::IF_SAME_THEN_ELSE),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n+    LintId::of(dereference::NEEDLESS_BORROW),\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n     LintId::of(derive::DERIVE_HASH_XOR_EQ),\n     LintId::of(derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n@@ -158,7 +159,9 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::MANUAL_SPLIT_ONCE),\n     LintId::of(methods::MANUAL_STR_REPEAT),\n     LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n+    LintId::of(methods::MAP_FLATTEN),\n     LintId::of(methods::MAP_IDENTITY),\n+    LintId::of(methods::NEEDLESS_SPLITN),\n     LintId::of(methods::NEW_RET_NO_SELF),\n     LintId::of(methods::OK_EXPECT),\n     LintId::of(methods::OPTION_AS_REF_DEREF),\n@@ -203,8 +206,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n     LintId::of(needless_bool::BOOL_COMPARISON),\n     LintId::of(needless_bool::NEEDLESS_BOOL),\n-    LintId::of(needless_borrow::NEEDLESS_BORROW),\n     LintId::of(needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n+    LintId::of(needless_late_init::NEEDLESS_LATE_INIT),\n     LintId::of(needless_option_as_deref::NEEDLESS_OPTION_AS_DEREF),\n     LintId::of(needless_question_mark::NEEDLESS_QUESTION_MARK),\n     LintId::of(needless_update::NEEDLESS_UPDATE),\n@@ -218,6 +221,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY),\n+    LintId::of(octal_escapes::OCTAL_ESCAPES),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),"}, {"sha": "a21ddf73a115e6a22a54dbfc2867abdb43cf0228", "filename": "src/tools/clippy/clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -41,7 +41,9 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(methods::MANUAL_FILTER_MAP),\n     LintId::of(methods::MANUAL_FIND_MAP),\n     LintId::of(methods::MANUAL_SPLIT_ONCE),\n+    LintId::of(methods::MAP_FLATTEN),\n     LintId::of(methods::MAP_IDENTITY),\n+    LintId::of(methods::NEEDLESS_SPLITN),\n     LintId::of(methods::OPTION_AS_REF_DEREF),\n     LintId::of(methods::OPTION_FILTER_MAP),\n     LintId::of(methods::SEARCH_IS_SOME),"}, {"sha": "7d4c7d2adb5b9e8063e5bdc2307ff8f33d23f42c", "filename": "src/tools/clippy/clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_internal.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -9,9 +9,11 @@ store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n     LintId::of(utils::internal_lints::DEFAULT_LINT),\n     LintId::of(utils::internal_lints::IF_CHAIN_STYLE),\n     LintId::of(utils::internal_lints::INTERNING_DEFINED_SYMBOL),\n+    LintId::of(utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE),\n     LintId::of(utils::internal_lints::INVALID_PATHS),\n     LintId::of(utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n     LintId::of(utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n+    LintId::of(utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n     LintId::of(utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n     LintId::of(utils::internal_lints::PRODUCE_ICE),\n     LintId::of(utils::internal_lints::UNNECESSARY_SYMBOL_STR),"}, {"sha": "bb159e50373c22d156db89368fcbcb88b5607013", "filename": "src/tools/clippy/clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -16,12 +16,16 @@ store.register_lints(&[\n     #[cfg(feature = \"internal-lints\")]\n     utils::internal_lints::INTERNING_DEFINED_SYMBOL,\n     #[cfg(feature = \"internal-lints\")]\n+    utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE,\n+    #[cfg(feature = \"internal-lints\")]\n     utils::internal_lints::INVALID_PATHS,\n     #[cfg(feature = \"internal-lints\")]\n     utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n     #[cfg(feature = \"internal-lints\")]\n     utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n     #[cfg(feature = \"internal-lints\")]\n+    utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n+    #[cfg(feature = \"internal-lints\")]\n     utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n     #[cfg(feature = \"internal-lints\")]\n     utils::internal_lints::PRODUCE_ICE,\n@@ -88,14 +92,16 @@ store.register_lints(&[\n     default::FIELD_REASSIGN_WITH_DEFAULT,\n     default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK,\n     dereference::EXPLICIT_DEREF_METHODS,\n+    dereference::NEEDLESS_BORROW,\n+    dereference::REF_BINDING_TO_REFERENCE,\n     derivable_impls::DERIVABLE_IMPLS,\n     derive::DERIVE_HASH_XOR_EQ,\n     derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n     derive::EXPL_IMPL_CLONE_ON_COPY,\n     derive::UNSAFE_DERIVE_DESERIALIZE,\n-    disallowed_method::DISALLOWED_METHOD,\n+    disallowed_methods::DISALLOWED_METHODS,\n     disallowed_script_idents::DISALLOWED_SCRIPT_IDENTS,\n-    disallowed_type::DISALLOWED_TYPE,\n+    disallowed_types::DISALLOWED_TYPES,\n     doc::DOC_MARKDOWN,\n     doc::MISSING_ERRORS_DOC,\n     doc::MISSING_PANICS_DOC,\n@@ -164,6 +170,7 @@ store.register_lints(&[\n     implicit_return::IMPLICIT_RETURN,\n     implicit_saturating_sub::IMPLICIT_SATURATING_SUB,\n     inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR,\n+    index_refutable_slice::INDEX_REFUTABLE_SLICE,\n     indexing_slicing::INDEXING_SLICING,\n     indexing_slicing::OUT_OF_BOUNDS_INDEXING,\n     infinite_iter::INFINITE_ITER,\n@@ -288,6 +295,7 @@ store.register_lints(&[\n     methods::MAP_FLATTEN,\n     methods::MAP_IDENTITY,\n     methods::MAP_UNWRAP_OR,\n+    methods::NEEDLESS_SPLITN,\n     methods::NEW_RET_NO_SELF,\n     methods::OK_EXPECT,\n     methods::OPTION_AS_REF_DEREF,\n@@ -351,11 +359,10 @@ store.register_lints(&[\n     needless_bitwise_bool::NEEDLESS_BITWISE_BOOL,\n     needless_bool::BOOL_COMPARISON,\n     needless_bool::NEEDLESS_BOOL,\n-    needless_borrow::NEEDLESS_BORROW,\n-    needless_borrow::REF_BINDING_TO_REFERENCE,\n     needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n     needless_continue::NEEDLESS_CONTINUE,\n     needless_for_each::NEEDLESS_FOR_EACH,\n+    needless_late_init::NEEDLESS_LATE_INIT,\n     needless_option_as_deref::NEEDLESS_OPTION_AS_DEREF,\n     needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n     needless_question_mark::NEEDLESS_QUESTION_MARK,\n@@ -374,6 +381,7 @@ store.register_lints(&[\n     non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS,\n     non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY,\n     nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n+    octal_escapes::OCTAL_ESCAPES,\n     open_options::NONSENSICAL_OPEN_OPTIONS,\n     option_env_unwrap::OPTION_ENV_UNWRAP,\n     option_if_let_else::OPTION_IF_LET_ELSE,"}, {"sha": "59182fd8175d404bfbd9e68b070445419c7fa1bf", "filename": "src/tools/clippy/clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -6,13 +6,14 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n     LintId::of(cognitive_complexity::COGNITIVE_COMPLEXITY),\n     LintId::of(copies::BRANCHES_SHARING_CODE),\n-    LintId::of(disallowed_method::DISALLOWED_METHOD),\n-    LintId::of(disallowed_type::DISALLOWED_TYPE),\n+    LintId::of(disallowed_methods::DISALLOWED_METHODS),\n+    LintId::of(disallowed_types::DISALLOWED_TYPES),\n     LintId::of(equatable_if_let::EQUATABLE_IF_LET),\n     LintId::of(fallible_impl_from::FALLIBLE_IMPL_FROM),\n     LintId::of(floating_point_arithmetic::IMPRECISE_FLOPS),\n     LintId::of(floating_point_arithmetic::SUBOPTIMAL_FLOPS),\n     LintId::of(future_not_send::FUTURE_NOT_SEND),\n+    LintId::of(index_refutable_slice::INDEX_REFUTABLE_SLICE),\n     LintId::of(let_if_seq::USELESS_LET_IF_SEQ),\n     LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n     LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),"}, {"sha": "70a4a624378909dd1040fbe9997927c07fa6d8c2", "filename": "src/tools/clippy/clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -21,6 +21,7 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(copy_iterator::COPY_ITERATOR),\n     LintId::of(default::DEFAULT_TRAIT_ACCESS),\n     LintId::of(dereference::EXPLICIT_DEREF_METHODS),\n+    LintId::of(dereference::REF_BINDING_TO_REFERENCE),\n     LintId::of(derive::EXPL_IMPL_CLONE_ON_COPY),\n     LintId::of(derive::UNSAFE_DERIVE_DESERIALIZE),\n     LintId::of(doc::DOC_MARKDOWN),\n@@ -62,13 +63,11 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(methods::FROM_ITER_INSTEAD_OF_COLLECT),\n     LintId::of(methods::IMPLICIT_CLONE),\n     LintId::of(methods::INEFFICIENT_TO_STRING),\n-    LintId::of(methods::MAP_FLATTEN),\n     LintId::of(methods::MAP_UNWRAP_OR),\n     LintId::of(misc::FLOAT_CMP),\n     LintId::of(misc::USED_UNDERSCORE_BINDING),\n     LintId::of(mut_mut::MUT_MUT),\n     LintId::of(needless_bitwise_bool::NEEDLESS_BITWISE_BOOL),\n-    LintId::of(needless_borrow::REF_BINDING_TO_REFERENCE),\n     LintId::of(needless_continue::NEEDLESS_CONTINUE),\n     LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n     LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),"}, {"sha": "ea87e7e7a73687bb37b9385396c6c4ebc5c2b3a2", "filename": "src/tools/clippy/clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -15,6 +15,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(collapsible_match::COLLAPSIBLE_MATCH),\n     LintId::of(comparison_chain::COMPARISON_CHAIN),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n+    LintId::of(dereference::NEEDLESS_BORROW),\n     LintId::of(doc::MISSING_SAFETY_DOC),\n     LintId::of(doc::NEEDLESS_DOCTEST_MAIN),\n     LintId::of(enum_variants::ENUM_VARIANT_NAMES),\n@@ -81,7 +82,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(misc_early::REDUNDANT_PATTERN),\n     LintId::of(mut_mutex_lock::MUT_MUTEX_LOCK),\n     LintId::of(mut_reference::UNNECESSARY_MUT_PASSED),\n-    LintId::of(needless_borrow::NEEDLESS_BORROW),\n+    LintId::of(needless_late_init::NEEDLESS_LATE_INIT),\n     LintId::of(neg_multiply::NEG_MULTIPLY),\n     LintId::of(new_without_default::NEW_WITHOUT_DEFAULT),\n     LintId::of(non_copy_const::BORROW_INTERIOR_MUTABLE_CONST),"}, {"sha": "414bfc42fdfcdabe6fecf7e701c1474b61ccf774", "filename": "src/tools/clippy/clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -16,6 +16,7 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(methods::SUSPICIOUS_MAP),\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n     LintId::of(non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY),\n+    LintId::of(octal_escapes::OCTAL_ESCAPES),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n ])"}, {"sha": "bd9710ec40750e23b89f2aed7911bbc00df09778", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 106, "deletions": 30, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -8,6 +8,7 @@\n #![feature(rustc_private)]\n #![feature(stmt_expr_attributes)]\n #![feature(control_flow_enum)]\n+#![feature(let_else)]\n #![recursion_limit = \"512\"]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![allow(clippy::missing_docs_in_private_items, clippy::must_use_candidate)]\n@@ -153,6 +154,10 @@ macro_rules! declare_clippy_lint {\n \n #[cfg(feature = \"metadata-collector-lint\")]\n mod deprecated_lints;\n+#[cfg_attr(\n+    any(feature = \"internal-lints\", feature = \"metadata-collector-lint\"),\n+    allow(clippy::missing_clippy_version_attribute)\n+)]\n mod utils;\n \n // begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\n@@ -189,9 +194,9 @@ mod default_numeric_fallback;\n mod dereference;\n mod derivable_impls;\n mod derive;\n-mod disallowed_method;\n+mod disallowed_methods;\n mod disallowed_script_idents;\n-mod disallowed_type;\n+mod disallowed_types;\n mod doc;\n mod double_comparison;\n mod double_parens;\n@@ -233,6 +238,7 @@ mod implicit_hasher;\n mod implicit_return;\n mod implicit_saturating_sub;\n mod inconsistent_struct_constructor;\n+mod index_refutable_slice;\n mod indexing_slicing;\n mod infinite_iter;\n mod inherent_impl;\n@@ -290,10 +296,10 @@ mod mutex_atomic;\n mod needless_arbitrary_self_type;\n mod needless_bitwise_bool;\n mod needless_bool;\n-mod needless_borrow;\n mod needless_borrowed_ref;\n mod needless_continue;\n mod needless_for_each;\n+mod needless_late_init;\n mod needless_option_as_deref;\n mod needless_pass_by_value;\n mod needless_question_mark;\n@@ -307,6 +313,7 @@ mod non_expressive_names;\n mod non_octal_unix_permissions;\n mod non_send_fields_in_send_ty;\n mod nonstandard_macro_braces;\n+mod octal_escapes;\n mod open_options;\n mod option_env_unwrap;\n mod option_if_let_else;\n@@ -404,10 +411,21 @@ use crate::utils::conf::TryConf;\n /// level (i.e `#![cfg_attr(...)]`) will still be expanded even when using a pre-expansion pass.\n ///\n /// Used in `./src/driver.rs`.\n-pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore) {\n+pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, sess: &Session, conf: &Conf) {\n     // NOTE: Do not add any more pre-expansion passes. These should be removed eventually.\n+\n+    let msrv = conf.msrv.as_ref().and_then(|s| {\n+        parse_msrv(s, None, None).or_else(|| {\n+            sess.err(&format!(\n+                \"error reading Clippy's configuration file. `{}` is not a valid Rust version\",\n+                s\n+            ));\n+            None\n+        })\n+    });\n+\n     store.register_pre_expansion_pass(|| Box::new(write::Write::default()));\n-    store.register_pre_expansion_pass(|| Box::new(attrs::EarlyAttributes));\n+    store.register_pre_expansion_pass(move || Box::new(attrs::EarlyAttributes { msrv }));\n     store.register_pre_expansion_pass(|| Box::new(dbg_macro::DbgMacro));\n }\n \n@@ -441,7 +459,6 @@ pub fn read_conf(sess: &Session) -> Conf {\n ///\n /// Used in `./src/driver.rs`.\n #[allow(clippy::too_many_lines)]\n-#[rustfmt::skip]\n pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf: &Conf) {\n     register_removed_non_tool_lints(store);\n \n@@ -493,11 +510,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let vec_box_size_threshold = conf.vec_box_size_threshold;\n     let type_complexity_threshold = conf.type_complexity_threshold;\n     let avoid_breaking_exported_api = conf.avoid_breaking_exported_api;\n-    store.register_late_pass(move || Box::new(types::Types::new(\n-        vec_box_size_threshold,\n-        type_complexity_threshold,\n-        avoid_breaking_exported_api,\n-    )));\n+    store.register_late_pass(move || {\n+        Box::new(types::Types::new(\n+            vec_box_size_threshold,\n+            type_complexity_threshold,\n+            avoid_breaking_exported_api,\n+        ))\n+    });\n     store.register_late_pass(|| Box::new(booleans::NonminimalBool));\n     store.register_late_pass(|| Box::new(needless_bitwise_bool::NeedlessBitwiseBool));\n     store.register_late_pass(|| Box::new(eq_op::EqOp));\n@@ -535,7 +554,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n \n     let msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n-            sess.err(&format!(\"error reading Clippy's configuration file. `{}` is not a valid Rust version\", s));\n+            sess.err(&format!(\n+                \"error reading Clippy's configuration file. `{}` is not a valid Rust version\",\n+                s\n+            ));\n             None\n         })\n     });\n@@ -560,6 +582,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n \n     store.register_late_pass(|| Box::new(size_of_in_element_count::SizeOfInElementCount));\n     store.register_late_pass(|| Box::new(same_name_method::SameNameMethod));\n+    let max_suggested_slice_pattern_length = conf.max_suggested_slice_pattern_length;\n+    store.register_late_pass(move || {\n+        Box::new(index_refutable_slice::IndexRefutableSlice::new(\n+            max_suggested_slice_pattern_length,\n+            msrv,\n+        ))\n+    });\n     store.register_late_pass(|| Box::new(map_clone::MapClone));\n     store.register_late_pass(|| Box::new(map_err_ignore::MapErrIgnore));\n     store.register_late_pass(|| Box::new(shadow::Shadow::default()));\n@@ -573,16 +602,19 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(zero_div_zero::ZeroDiv));\n     store.register_late_pass(|| Box::new(mutex_atomic::Mutex));\n     store.register_late_pass(|| Box::new(needless_update::NeedlessUpdate));\n-    store.register_late_pass(|| Box::new(needless_borrow::NeedlessBorrow::default()));\n     store.register_late_pass(|| Box::new(needless_borrowed_ref::NeedlessBorrowedRef));\n     store.register_late_pass(|| Box::new(no_effect::NoEffect));\n     store.register_late_pass(|| Box::new(temporary_assignment::TemporaryAssignment));\n     store.register_late_pass(|| Box::new(transmute::Transmute));\n     let cognitive_complexity_threshold = conf.cognitive_complexity_threshold;\n-    store.register_late_pass(move || Box::new(cognitive_complexity::CognitiveComplexity::new(cognitive_complexity_threshold)));\n+    store.register_late_pass(move || {\n+        Box::new(cognitive_complexity::CognitiveComplexity::new(\n+            cognitive_complexity_threshold,\n+        ))\n+    });\n     let too_large_for_stack = conf.too_large_for_stack;\n-    store.register_late_pass(move || Box::new(escape::BoxedLocal{too_large_for_stack}));\n-    store.register_late_pass(move || Box::new(vec::UselessVec{too_large_for_stack}));\n+    store.register_late_pass(move || Box::new(escape::BoxedLocal { too_large_for_stack }));\n+    store.register_late_pass(move || Box::new(vec::UselessVec { too_large_for_stack }));\n     store.register_late_pass(|| Box::new(panic_unimplemented::PanicUnimplemented));\n     store.register_late_pass(|| Box::new(strings::StringLitAsBytes));\n     store.register_late_pass(|| Box::new(derive::Derive));\n@@ -603,7 +635,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(blacklisted_name::BlacklistedName::new(blacklisted_names.clone())));\n     let too_many_arguments_threshold = conf.too_many_arguments_threshold;\n     let too_many_lines_threshold = conf.too_many_lines_threshold;\n-    store.register_late_pass(move || Box::new(functions::Functions::new(too_many_arguments_threshold, too_many_lines_threshold)));\n+    store.register_late_pass(move || {\n+        Box::new(functions::Functions::new(\n+            too_many_arguments_threshold,\n+            too_many_lines_threshold,\n+        ))\n+    });\n     let doc_valid_idents = conf.doc_valid_idents.iter().cloned().collect::<FxHashSet<_>>();\n     store.register_late_pass(move || Box::new(doc::DocMarkdown::new(doc_valid_idents.clone())));\n     store.register_late_pass(|| Box::new(neg_multiply::NegMultiply));\n@@ -688,14 +725,32 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(multiple_crate_versions::MultipleCrateVersions));\n     store.register_late_pass(|| Box::new(wildcard_dependencies::WildcardDependencies));\n     let literal_representation_lint_fraction_readability = conf.unreadable_literal_lint_fractions;\n-    store.register_early_pass(move || Box::new(literal_representation::LiteralDigitGrouping::new(literal_representation_lint_fraction_readability)));\n+    store.register_early_pass(move || {\n+        Box::new(literal_representation::LiteralDigitGrouping::new(\n+            literal_representation_lint_fraction_readability,\n+        ))\n+    });\n     let literal_representation_threshold = conf.literal_representation_threshold;\n-    store.register_early_pass(move || Box::new(literal_representation::DecimalLiteralRepresentation::new(literal_representation_threshold)));\n+    store.register_early_pass(move || {\n+        Box::new(literal_representation::DecimalLiteralRepresentation::new(\n+            literal_representation_threshold,\n+        ))\n+    });\n     let enum_variant_name_threshold = conf.enum_variant_name_threshold;\n-    store.register_late_pass(move || Box::new(enum_variants::EnumVariantNames::new(enum_variant_name_threshold, avoid_breaking_exported_api)));\n+    store.register_late_pass(move || {\n+        Box::new(enum_variants::EnumVariantNames::new(\n+            enum_variant_name_threshold,\n+            avoid_breaking_exported_api,\n+        ))\n+    });\n     store.register_early_pass(|| Box::new(tabs_in_doc_comments::TabsInDocComments));\n     let upper_case_acronyms_aggressive = conf.upper_case_acronyms_aggressive;\n-    store.register_late_pass(move || Box::new(upper_case_acronyms::UpperCaseAcronyms::new(avoid_breaking_exported_api, upper_case_acronyms_aggressive)));\n+    store.register_late_pass(move || {\n+        Box::new(upper_case_acronyms::UpperCaseAcronyms::new(\n+            avoid_breaking_exported_api,\n+            upper_case_acronyms_aggressive,\n+        ))\n+    });\n     store.register_late_pass(|| Box::new(default::Default::default()));\n     store.register_late_pass(|| Box::new(unused_self::UnusedSelf));\n     store.register_late_pass(|| Box::new(mutable_debug_assertion::DebugAssertWithMutCall));\n@@ -710,7 +765,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(single_component_path_imports::SingleComponentPathImports));\n     let max_fn_params_bools = conf.max_fn_params_bools;\n     let max_struct_bools = conf.max_struct_bools;\n-    store.register_early_pass(move || Box::new(excessive_bools::ExcessiveBools::new(max_struct_bools, max_fn_params_bools)));\n+    store.register_early_pass(move || {\n+        Box::new(excessive_bools::ExcessiveBools::new(\n+            max_struct_bools,\n+            max_fn_params_bools,\n+        ))\n+    });\n     store.register_early_pass(|| Box::new(option_env_unwrap::OptionEnvUnwrap));\n     let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n     store.register_late_pass(move || Box::new(wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports)));\n@@ -729,9 +789,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(vec_resize_to_zero::VecResizeToZero));\n     store.register_late_pass(|| Box::new(panic_in_result_fn::PanicInResultFn));\n     let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n-    store.register_early_pass(move || Box::new(non_expressive_names::NonExpressiveNames {\n-        single_char_binding_names_threshold,\n-    }));\n+    store.register_early_pass(move || {\n+        Box::new(non_expressive_names::NonExpressiveNames {\n+            single_char_binding_names_threshold,\n+        })\n+    });\n     let macro_matcher = conf.standard_macro_braces.iter().cloned().collect::<FxHashSet<_>>();\n     store.register_early_pass(move || Box::new(nonstandard_macro_braces::MacroBraces::new(&macro_matcher)));\n     store.register_late_pass(|| Box::new(macro_use::MacroUseImports::default()));\n@@ -746,15 +808,17 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n     store.register_late_pass(|| Box::new(async_yields_async::AsyncYieldsAsync));\n     let disallowed_methods = conf.disallowed_methods.clone();\n-    store.register_late_pass(move || Box::new(disallowed_method::DisallowedMethod::new(disallowed_methods.clone())));\n+    store.register_late_pass(move || Box::new(disallowed_methods::DisallowedMethods::new(disallowed_methods.clone())));\n     store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86AttSyntax));\n     store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86IntelSyntax));\n     store.register_late_pass(|| Box::new(undropped_manually_drops::UndroppedManuallyDrops));\n     store.register_late_pass(|| Box::new(strings::StrToString));\n     store.register_late_pass(|| Box::new(strings::StringToString));\n     store.register_late_pass(|| Box::new(zero_sized_map_values::ZeroSizedMapValues));\n     store.register_late_pass(|| Box::new(vec_init_then_push::VecInitThenPush::default()));\n-    store.register_late_pass(|| Box::new(case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons));\n+    store.register_late_pass(|| {\n+        Box::new(case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons)\n+    });\n     store.register_late_pass(|| Box::new(redundant_slicing::RedundantSlicing));\n     store.register_late_pass(|| Box::new(from_str_radix_10::FromStrRadix10));\n     store.register_late_pass(|| Box::new(manual_map::ManualMap));\n@@ -763,9 +827,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(move || Box::new(module_style::ModStyle));\n     store.register_late_pass(|| Box::new(unused_async::UnusedAsync));\n     let disallowed_types = conf.disallowed_types.clone();\n-    store.register_late_pass(move || Box::new(disallowed_type::DisallowedType::new(disallowed_types.clone())));\n+    store.register_late_pass(move || Box::new(disallowed_types::DisallowedTypes::new(disallowed_types.clone())));\n     let import_renames = conf.enforced_import_renames.clone();\n-    store.register_late_pass(move || Box::new(missing_enforced_import_rename::ImportRename::new(import_renames.clone())));\n+    store.register_late_pass(move || {\n+        Box::new(missing_enforced_import_rename::ImportRename::new(\n+            import_renames.clone(),\n+        ))\n+    });\n     let scripts = conf.allowed_scripts.clone();\n     store.register_early_pass(move || Box::new(disallowed_script_idents::DisallowedScriptIdents::new(&scripts)));\n     store.register_late_pass(|| Box::new(strlen_on_c_strings::StrlenOnCStrings));\n@@ -774,11 +842,17 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(iter_not_returning_iterator::IterNotReturningIterator));\n     store.register_late_pass(move || Box::new(manual_assert::ManualAssert));\n     let enable_raw_pointer_heuristic_for_send = conf.enable_raw_pointer_heuristic_for_send;\n-    store.register_late_pass(move || Box::new(non_send_fields_in_send_ty::NonSendFieldInSendTy::new(enable_raw_pointer_heuristic_for_send)));\n+    store.register_late_pass(move || {\n+        Box::new(non_send_fields_in_send_ty::NonSendFieldInSendTy::new(\n+            enable_raw_pointer_heuristic_for_send,\n+        ))\n+    });\n     store.register_late_pass(move || Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks::default()));\n     store.register_late_pass(|| Box::new(match_str_case_mismatch::MatchStrCaseMismatch));\n     store.register_late_pass(move || Box::new(format_args::FormatArgs));\n     store.register_late_pass(|| Box::new(trailing_empty_array::TrailingEmptyArray));\n+    store.register_early_pass(|| Box::new(octal_escapes::OctalEscapes));\n+    store.register_late_pass(|| Box::new(needless_late_init::NeedlessLateInit));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n \n@@ -852,6 +926,8 @@ pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n     ls.register_renamed(\"clippy::zero_width_space\", \"clippy::invisible_characters\");\n     ls.register_renamed(\"clippy::single_char_push_str\", \"clippy::single_char_add_str\");\n     ls.register_renamed(\"clippy::if_let_some_result\", \"clippy::match_result_ok\");\n+    ls.register_renamed(\"clippy::disallowed_type\", \"clippy::disallowed_types\");\n+    ls.register_renamed(\"clippy::disallowed_method\", \"clippy::disallowed_methods\");\n \n     // uplifted lints\n     ls.register_renamed(\"clippy::invalid_ref\", \"invalid_value\");"}, {"sha": "fad3343d128510aca02466f18960f65a251932b2", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{in_macro, trait_ref_of_method};\n+use clippy_utils::trait_ref_of_method;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::intravisit::{\n     walk_fn_decl, walk_generic_param, walk_generics, walk_item, walk_param_bound, walk_poly_trait_ref, walk_ty,\n@@ -45,6 +45,7 @@ declare_clippy_lint! {\n     ///     x\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEEDLESS_LIFETIMES,\n     complexity,\n     \"using explicit lifetimes for references in function arguments when elision rules \\\n@@ -73,6 +74,7 @@ declare_clippy_lint! {\n     ///     // ...\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EXTRA_UNUSED_LIFETIMES,\n     complexity,\n     \"unused lifetimes in function definitions\"\n@@ -128,7 +130,7 @@ fn check_fn_inner<'tcx>(\n     span: Span,\n     report_extra_lifetimes: bool,\n ) {\n-    if in_macro(span) || has_where_lifetimes(cx, &generics.where_clause) {\n+    if span.from_expansion() || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n "}, {"sha": "130543bbbee80ef229aa818188f9bab24e191c2f", "filename": "src/tools/clippy/clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -2,11 +2,8 @@\n //! floating-point literal expressions.\n \n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::numeric_literal::{NumericLiteral, Radix};\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{\n-    in_macro,\n-    numeric_literal::{NumericLiteral, Radix},\n-};\n use if_chain::if_chain;\n use rustc_ast::ast::{Expr, ExprKind, Lit, LitKind};\n use rustc_errors::Applicability;\n@@ -31,6 +28,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let x: u64 = 61_864_918_973_511;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNREADABLE_LITERAL,\n     pedantic,\n     \"long literal without underscores\"\n@@ -56,6 +54,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// 2_i32;\n     /// ```\n+    #[clippy::version = \"1.30.0\"]\n     pub MISTYPED_LITERAL_SUFFIXES,\n     correctness,\n     \"mistyped literal suffix\"\n@@ -78,6 +77,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let x: u64 = 61_864_918_973_511;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub INCONSISTENT_DIGIT_GROUPING,\n     style,\n     \"integer literals with digits grouped inconsistently\"\n@@ -96,6 +96,7 @@ declare_clippy_lint! {\n     /// let x: u32 = 0xFFF_FFF;\n     /// let y: u8 = 0b01_011_101;\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub UNUSUAL_BYTE_GROUPINGS,\n     style,\n     \"binary or hex literals that aren't grouped by four\"\n@@ -114,6 +115,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let x: u64 = 6186491_8973511;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub LARGE_DIGIT_GROUPS,\n     pedantic,\n     \"grouping digits into groups that are too large\"\n@@ -131,6 +133,7 @@ declare_clippy_lint! {\n     /// `255` => `0xFF`\n     /// `65_535` => `0xFFFF`\n     /// `4_042_322_160` => `0xF0F0_F0F0`\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DECIMAL_LITERAL_REPRESENTATION,\n     restriction,\n     \"using decimal representation when hexadecimal would be better\"\n@@ -283,7 +286,7 @@ impl LiteralDigitGrouping {\n                         | WarningType::InconsistentDigitGrouping\n                         | WarningType::UnusualByteGroupings\n                         | WarningType::LargeDigitGroups => {\n-                            !in_macro(lit.span)\n+                            !lit.span.from_expansion()\n                         }\n                         WarningType::DecimalRepresentation | WarningType::MistypedLiteralSuffix => {\n                             true"}, {"sha": "e0150990cfe5fb42ee247f996df71f33d101893b", "filename": "src/tools/clippy/clippy_lints/src/loops/explicit_counter_loop.rs", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,12 +1,13 @@\n use super::{make_iterator_snippet, IncrementVisitor, InitializeVisitor, EXPLICIT_COUNTER_LOOP};\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{get_enclosing_block, is_integer_const};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr};\n use rustc_hir::{Expr, Pat};\n use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, UintTy};\n \n // To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n // incremented exactly once in the loop body, and initialized to zero\n@@ -30,24 +31,59 @@ pub(super) fn check<'tcx>(\n             walk_block(&mut initialize_visitor, block);\n \n             if_chain! {\n-                if let Some((name, initializer)) = initialize_visitor.get_result();\n+                if let Some((name, ty, initializer)) = initialize_visitor.get_result();\n                 if is_integer_const(cx, initializer, 0);\n                 then {\n                     let mut applicability = Applicability::MachineApplicable;\n \n-                    span_lint_and_sugg(\n+                    let int_name = match ty.map(ty::TyS::kind) {\n+                        // usize or inferred\n+                        Some(ty::Uint(UintTy::Usize)) | None => {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                EXPLICIT_COUNTER_LOOP,\n+                                expr.span.with_hi(arg.span.hi()),\n+                                &format!(\"the variable `{}` is used as a loop counter\", name),\n+                                \"consider using\",\n+                                format!(\n+                                    \"for ({}, {}) in {}.enumerate()\",\n+                                    name,\n+                                    snippet_with_applicability(cx, pat.span, \"item\", &mut applicability),\n+                                    make_iterator_snippet(cx, arg, &mut applicability),\n+                                ),\n+                                applicability,\n+                            );\n+                            return;\n+                        }\n+                        Some(ty::Int(int_ty)) => int_ty.name_str(),\n+                        Some(ty::Uint(uint_ty)) => uint_ty.name_str(),\n+                        _ => return,\n+                    };\n+\n+                    span_lint_and_then(\n                         cx,\n                         EXPLICIT_COUNTER_LOOP,\n                         expr.span.with_hi(arg.span.hi()),\n                         &format!(\"the variable `{}` is used as a loop counter\", name),\n-                        \"consider using\",\n-                        format!(\n-                            \"for ({}, {}) in {}.enumerate()\",\n-                            name,\n-                            snippet_with_applicability(cx, pat.span, \"item\", &mut applicability),\n-                            make_iterator_snippet(cx, arg, &mut applicability),\n-                        ),\n-                        applicability,\n+                        |diag| {\n+                            diag.span_suggestion(\n+                                expr.span.with_hi(arg.span.hi()),\n+                                \"consider using\",\n+                                format!(\n+                                    \"for ({}, {}) in (0_{}..).zip({})\",\n+                                    name,\n+                                    snippet_with_applicability(cx, pat.span, \"item\", &mut applicability),\n+                                    int_name,\n+                                    make_iterator_snippet(cx, arg, &mut applicability),\n+                                ),\n+                                applicability,\n+                            );\n+\n+                            diag.note(&format!(\n+                                \"`{}` is of type `{}`, making it ineligible for `Iterator::enumerate`\",\n+                                name, int_name\n+                            ));\n+                        },\n                     );\n                 }\n             }"}, {"sha": "6cda926853438bd63163da747c2d6c1c4f6eafcb", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -445,7 +445,7 @@ fn get_loop_counters<'a, 'tcx>(\n                 let mut initialize_visitor = InitializeVisitor::new(cx, expr, var_id);\n                 walk_block(&mut initialize_visitor, block);\n \n-                initialize_visitor.get_result().map(|(_, initializer)| Start {\n+                initialize_visitor.get_result().map(|(_, _, initializer)| Start {\n                     id: var_id,\n                     kind: StartKind::Counter { initializer },\n                 })"}, {"sha": "e2f9aee063dd2f8dea4f553ff7e3b5af1c77b64b", "filename": "src/tools/clippy/clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -47,6 +47,7 @@ declare_clippy_lint! {\n     /// # let mut dst = vec![0; 65];\n     /// dst[64..(src.len() + 64)].clone_from_slice(&src[..]);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MANUAL_MEMCPY,\n     perf,\n     \"manually copying items between slices\"\n@@ -75,6 +76,7 @@ declare_clippy_lint! {\n     ///     println!(\"{}\", i);\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEEDLESS_RANGE_LOOP,\n     style,\n     \"for-looping over a range of indices where an iterator over items would do\"\n@@ -107,6 +109,7 @@ declare_clippy_lint! {\n     ///     // ..\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EXPLICIT_ITER_LOOP,\n     pedantic,\n     \"for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\"\n@@ -135,6 +138,7 @@ declare_clippy_lint! {\n     ///     // ..\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EXPLICIT_INTO_ITER_LOOP,\n     pedantic,\n     \"for-looping over `_.into_iter()` when `_` would do\"\n@@ -158,6 +162,7 @@ declare_clippy_lint! {\n     ///     ..\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ITER_NEXT_LOOP,\n     correctness,\n     \"for-looping over `_.next()` which is probably not intended\"\n@@ -201,6 +206,7 @@ declare_clippy_lint! {\n     ///     // ..\n     /// }\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub FOR_LOOPS_OVER_FALLIBLES,\n     suspicious,\n     \"for-looping over an `Option` or a `Result`, which is more clearly expressed as an `if let`\"\n@@ -233,6 +239,7 @@ declare_clippy_lint! {\n     ///     // .. do something with x\n     /// };\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub WHILE_LET_LOOP,\n     complexity,\n     \"`loop { if let { ... } else break }`, which can be written as a `while let` loop\"\n@@ -254,6 +261,7 @@ declare_clippy_lint! {\n     /// // should be\n     /// let len = iterator.count();\n     /// ```\n+    #[clippy::version = \"1.30.0\"]\n     pub NEEDLESS_COLLECT,\n     perf,\n     \"collecting an iterator when collect is not needed\"\n@@ -284,6 +292,7 @@ declare_clippy_lint! {\n     /// # fn bar(bar: usize, baz: usize) {}\n     /// for (i, item) in v.iter().enumerate() { bar(i, *item); }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EXPLICIT_COUNTER_LOOP,\n     complexity,\n     \"for-looping with an explicit counter when `_.enumerate()` would do\"\n@@ -317,6 +326,7 @@ declare_clippy_lint! {\n     /// ```no_run\n     /// loop {}\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EMPTY_LOOP,\n     suspicious,\n     \"empty `loop {}`, which should block or sleep\"\n@@ -336,6 +346,7 @@ declare_clippy_lint! {\n     ///     ..\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub WHILE_LET_ON_ITERATOR,\n     style,\n     \"using a `while let` loop instead of a for loop on an iterator\"\n@@ -364,6 +375,7 @@ declare_clippy_lint! {\n     ///     ..\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub FOR_KV_MAP,\n     style,\n     \"looping on a map using `iter` when `keys` or `values` would do\"\n@@ -385,6 +397,7 @@ declare_clippy_lint! {\n     ///     break;\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEVER_LOOP,\n     correctness,\n     \"any loop that will always `break` or `return`\"\n@@ -420,6 +433,7 @@ declare_clippy_lint! {\n     ///     println!(\"{}\", i); // prints numbers from 0 to 42, not 0 to 21\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MUT_RANGE_BOUND,\n     suspicious,\n     \"for loop over a range where one of the bounds is a mutable variable\"\n@@ -446,6 +460,7 @@ declare_clippy_lint! {\n     ///     println!(\"let me loop forever!\");\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub WHILE_IMMUTABLE_CONDITION,\n     correctness,\n     \"variables used within while expression are not mutated in the body\"\n@@ -480,6 +495,7 @@ declare_clippy_lint! {\n     /// let mut vec: Vec<u8> = vec![item1; 20];\n     /// vec.resize(20 + 30, item2);\n     /// ```\n+    #[clippy::version = \"1.47.0\"]\n     pub SAME_ITEM_PUSH,\n     style,\n     \"the same item is pushed inside of a for loop\"\n@@ -506,6 +522,7 @@ declare_clippy_lint! {\n     /// let item = &item1;\n     /// println!(\"{}\", item);\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub SINGLE_ELEMENT_LOOP,\n     complexity,\n     \"there is no reason to have a single element loop\"\n@@ -537,6 +554,7 @@ declare_clippy_lint! {\n     ///     println!(\"{}\", n);\n     /// }\n     /// ```\n+    #[clippy::version = \"1.52.0\"]\n     pub MANUAL_FLATTEN,\n     complexity,\n     \"for loops over `Option`s or `Result`s with a single expression can be simplified\""}, {"sha": "6f3acb45ba4f89e55c24f5600d238b152d4d7940", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 152, "deletions": 26, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -3,13 +3,16 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_trait_method, path_to_local_id};\n+use clippy_utils::{can_move_expr_to_closure, is_trait_method, path_to_local, path_to_local_id, CaptureKind};\n use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, StmtKind};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{self, TyS};\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span};\n \n@@ -83,7 +86,8 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                     is_type_diagnostic_item(cx, ty, sym::VecDeque) ||\n                     is_type_diagnostic_item(cx, ty, sym::BinaryHeap) ||\n                     is_type_diagnostic_item(cx, ty, sym::LinkedList);\n-                if let Some(iter_calls) = detect_iter_and_into_iters(block, id);\n+                let iter_ty = cx.typeck_results().expr_ty(iter_source);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, id, cx, get_captured_ids(cx, iter_ty));\n                 if let [iter_call] = &*iter_calls;\n                 then {\n                     let mut used_count_visitor = UsedCountVisitor {\n@@ -167,37 +171,89 @@ enum IterFunctionKind {\n     Contains(Span),\n }\n \n-struct IterFunctionVisitor {\n-    uses: Vec<IterFunction>,\n+struct IterFunctionVisitor<'a, 'tcx> {\n+    illegal_mutable_capture_ids: HirIdSet,\n+    current_mutably_captured_ids: HirIdSet,\n+    cx: &'a LateContext<'tcx>,\n+    uses: Vec<Option<IterFunction>>,\n+    hir_id_uses_map: FxHashMap<HirId, usize>,\n+    current_statement_hir_id: Option<HirId>,\n     seen_other: bool,\n     target: HirId,\n }\n-impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n+impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n+    fn visit_block(&mut self, block: &'tcx Block<'tcx>) {\n+        for (expr, hir_id) in block.stmts.iter().filter_map(get_expr_and_hir_id_from_stmt) {\n+            self.visit_block_expr(expr, hir_id);\n+        }\n+        if let Some(expr) = block.expr {\n+            self.visit_block_expr(expr, None);\n+        }\n+    }\n+\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n         if let ExprKind::MethodCall(method_name, _, [recv, args @ ..], _) = &expr.kind {\n+            if method_name.ident.name == sym!(collect) && is_trait_method(self.cx, expr, sym::Iterator) {\n+                self.current_mutably_captured_ids = get_captured_ids(self.cx, self.cx.typeck_results().expr_ty(recv));\n+                self.visit_expr(recv);\n+                return;\n+            }\n+\n             if path_to_local_id(recv, self.target) {\n-                match &*method_name.ident.name.as_str() {\n-                    \"into_iter\" => self.uses.push(IterFunction {\n-                        func: IterFunctionKind::IntoIter,\n-                        span: expr.span,\n-                    }),\n-                    \"len\" => self.uses.push(IterFunction {\n-                        func: IterFunctionKind::Len,\n-                        span: expr.span,\n-                    }),\n-                    \"is_empty\" => self.uses.push(IterFunction {\n-                        func: IterFunctionKind::IsEmpty,\n-                        span: expr.span,\n-                    }),\n-                    \"contains\" => self.uses.push(IterFunction {\n-                        func: IterFunctionKind::Contains(args[0].span),\n-                        span: expr.span,\n-                    }),\n-                    _ => self.seen_other = true,\n+                if self\n+                    .illegal_mutable_capture_ids\n+                    .intersection(&self.current_mutably_captured_ids)\n+                    .next()\n+                    .is_none()\n+                {\n+                    if let Some(hir_id) = self.current_statement_hir_id {\n+                        self.hir_id_uses_map.insert(hir_id, self.uses.len());\n+                    }\n+                    match &*method_name.ident.name.as_str() {\n+                        \"into_iter\" => self.uses.push(Some(IterFunction {\n+                            func: IterFunctionKind::IntoIter,\n+                            span: expr.span,\n+                        })),\n+                        \"len\" => self.uses.push(Some(IterFunction {\n+                            func: IterFunctionKind::Len,\n+                            span: expr.span,\n+                        })),\n+                        \"is_empty\" => self.uses.push(Some(IterFunction {\n+                            func: IterFunctionKind::IsEmpty,\n+                            span: expr.span,\n+                        })),\n+                        \"contains\" => self.uses.push(Some(IterFunction {\n+                            func: IterFunctionKind::Contains(args[0].span),\n+                            span: expr.span,\n+                        })),\n+                        _ => {\n+                            self.seen_other = true;\n+                            if let Some(hir_id) = self.current_statement_hir_id {\n+                                self.hir_id_uses_map.remove(&hir_id);\n+                            }\n+                        },\n+                    }\n                 }\n                 return;\n             }\n+\n+            if let Some(hir_id) = path_to_local(recv) {\n+                if let Some(index) = self.hir_id_uses_map.remove(&hir_id) {\n+                    if self\n+                        .illegal_mutable_capture_ids\n+                        .intersection(&self.current_mutably_captured_ids)\n+                        .next()\n+                        .is_none()\n+                    {\n+                        if let Some(hir_id) = self.current_statement_hir_id {\n+                            self.hir_id_uses_map.insert(hir_id, index);\n+                        }\n+                    } else {\n+                        self.uses[index] = None;\n+                    }\n+                }\n+            }\n         }\n         // Check if the collection is used for anything else\n         if path_to_local_id(expr, self.target) {\n@@ -213,6 +269,28 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n     }\n }\n \n+impl<'tcx> IterFunctionVisitor<'_, 'tcx> {\n+    fn visit_block_expr(&mut self, expr: &'tcx Expr<'tcx>, hir_id: Option<HirId>) {\n+        self.current_statement_hir_id = hir_id;\n+        self.current_mutably_captured_ids = get_captured_ids(self.cx, self.cx.typeck_results().expr_ty(expr));\n+        self.visit_expr(expr);\n+    }\n+}\n+\n+fn get_expr_and_hir_id_from_stmt<'v>(stmt: &'v Stmt<'v>) -> Option<(&'v Expr<'v>, Option<HirId>)> {\n+    match stmt.kind {\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => Some((expr, None)),\n+        StmtKind::Item(..) => None,\n+        StmtKind::Local(Local { init, pat, .. }) => {\n+            if let PatKind::Binding(_, hir_id, ..) = pat.kind {\n+                init.map(|init_expr| (init_expr, Some(hir_id)))\n+            } else {\n+                init.map(|init_expr| (init_expr, None))\n+            }\n+        },\n+    }\n+}\n+\n struct UsedCountVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     id: HirId,\n@@ -237,12 +315,60 @@ impl<'a, 'tcx> Visitor<'tcx> for UsedCountVisitor<'a, 'tcx> {\n \n /// Detect the occurrences of calls to `iter` or `into_iter` for the\n /// given identifier\n-fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, id: HirId) -> Option<Vec<IterFunction>> {\n+fn detect_iter_and_into_iters<'tcx: 'a, 'a>(\n+    block: &'tcx Block<'tcx>,\n+    id: HirId,\n+    cx: &'a LateContext<'tcx>,\n+    captured_ids: HirIdSet,\n+) -> Option<Vec<IterFunction>> {\n     let mut visitor = IterFunctionVisitor {\n         uses: Vec::new(),\n         target: id,\n         seen_other: false,\n+        cx,\n+        current_mutably_captured_ids: HirIdSet::default(),\n+        illegal_mutable_capture_ids: captured_ids,\n+        hir_id_uses_map: FxHashMap::default(),\n+        current_statement_hir_id: None,\n     };\n     visitor.visit_block(block);\n-    if visitor.seen_other { None } else { Some(visitor.uses) }\n+    if visitor.seen_other {\n+        None\n+    } else {\n+        Some(visitor.uses.into_iter().flatten().collect())\n+    }\n+}\n+\n+fn get_captured_ids(cx: &LateContext<'tcx>, ty: &'_ TyS<'_>) -> HirIdSet {\n+    fn get_captured_ids_recursive(cx: &LateContext<'tcx>, ty: &'_ TyS<'_>, set: &mut HirIdSet) {\n+        match ty.kind() {\n+            ty::Adt(_, generics) => {\n+                for generic in *generics {\n+                    if let GenericArgKind::Type(ty) = generic.unpack() {\n+                        get_captured_ids_recursive(cx, ty, set);\n+                    }\n+                }\n+            },\n+            ty::Closure(def_id, _) => {\n+                let closure_hir_node = cx.tcx.hir().get_if_local(*def_id).unwrap();\n+                if let Node::Expr(closure_expr) = closure_hir_node {\n+                    can_move_expr_to_closure(cx, closure_expr)\n+                        .unwrap()\n+                        .into_iter()\n+                        .for_each(|(hir_id, capture_kind)| {\n+                            if matches!(capture_kind, CaptureKind::Ref(Mutability::Mut)) {\n+                                set.insert(hir_id);\n+                            }\n+                        });\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    let mut set = HirIdSet::default();\n+\n+    get_captured_ids_recursive(cx, ty, &mut set);\n+\n+    set\n }"}, {"sha": "f6b7e1bc353fd24c6b9c736a52a93fb7d2823f88", "filename": "src/tools/clippy/clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 52, "deletions": 22, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,13 +1,16 @@\n use clippy_utils::ty::{has_iter_method, implements_trait};\n use clippy_utils::{get_parent_expr, is_integer_const, path_to_local, path_to_local_id, sugg};\n use if_chain::if_chain;\n+use rustc_ast::ast::{LitIntType, LitKind};\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n-use rustc_hir::HirIdMap;\n-use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Stmt, StmtKind};\n+use rustc_hir::intravisit::{walk_expr, walk_local, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, HirIdMap, Local, Mutability, Pat, PatKind, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::Ty;\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Symbol};\n+use rustc_typeck::hir_ty_to_ty;\n use std::iter::Iterator;\n \n #[derive(Debug, PartialEq)]\n@@ -105,10 +108,11 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n }\n \n enum InitializeVisitorState<'hir> {\n-    Initial,          // Not examined yet\n-    Declared(Symbol), // Declared but not (yet) initialized\n+    Initial,                            // Not examined yet\n+    Declared(Symbol, Option<Ty<'hir>>), // Declared but not (yet) initialized\n     Initialized {\n         name: Symbol,\n+        ty: Option<Ty<'hir>>,\n         initializer: &'hir Expr<'hir>,\n     },\n     DontWarn,\n@@ -137,9 +141,9 @@ impl<'a, 'tcx> InitializeVisitor<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn get_result(&self) -> Option<(Symbol, &'tcx Expr<'tcx>)> {\n-        if let InitializeVisitorState::Initialized { name, initializer } = self.state {\n-            Some((name, initializer))\n+    pub(super) fn get_result(&self) -> Option<(Symbol, Option<Ty<'tcx>>, &'tcx Expr<'tcx>)> {\n+        if let InitializeVisitorState::Initialized { name, ty, initializer } = self.state {\n+            Some((name, ty, initializer))\n         } else {\n             None\n         }\n@@ -149,22 +153,25 @@ impl<'a, 'tcx> InitializeVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n-    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+    fn visit_local(&mut self, l: &'tcx Local<'_>) {\n         // Look for declarations of the variable\n         if_chain! {\n-            if let StmtKind::Local(local) = stmt.kind;\n-            if local.pat.hir_id == self.var_id;\n-            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n+            if l.pat.hir_id == self.var_id;\n+            if let PatKind::Binding(.., ident, _) = l.pat.kind;\n             then {\n-                self.state = local.init.map_or(InitializeVisitorState::Declared(ident.name), |init| {\n+                let ty = l.ty.map(|ty| hir_ty_to_ty(self.cx.tcx, ty));\n+\n+                self.state = l.init.map_or(InitializeVisitorState::Declared(ident.name, ty), |init| {\n                     InitializeVisitorState::Initialized {\n                         initializer: init,\n+                        ty,\n                         name: ident.name,\n                     }\n                 })\n             }\n         }\n-        walk_stmt(self, stmt);\n+\n+        walk_local(self, l);\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n@@ -194,15 +201,38 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n                         self.state = InitializeVisitorState::DontWarn;\n                     },\n                     ExprKind::Assign(lhs, rhs, _) if lhs.hir_id == expr.hir_id => {\n-                        self.state = if_chain! {\n-                            if self.depth == 0;\n-                            if let InitializeVisitorState::Declared(name)\n-                                | InitializeVisitorState::Initialized { name, ..} = self.state;\n-                            then {\n-                                InitializeVisitorState::Initialized { initializer: rhs, name }\n-                            } else {\n-                                InitializeVisitorState::DontWarn\n+                        self.state = if self.depth == 0 {\n+                            match self.state {\n+                                InitializeVisitorState::Declared(name, mut ty) => {\n+                                    if ty.is_none() {\n+                                        if let ExprKind::Lit(Spanned {\n+                                            node: LitKind::Int(_, LitIntType::Unsuffixed),\n+                                            ..\n+                                        }) = rhs.kind\n+                                        {\n+                                            ty = None;\n+                                        } else {\n+                                            ty = self.cx.typeck_results().expr_ty_opt(rhs);\n+                                        }\n+                                    }\n+\n+                                    InitializeVisitorState::Initialized {\n+                                        initializer: rhs,\n+                                        ty,\n+                                        name,\n+                                    }\n+                                },\n+                                InitializeVisitorState::Initialized { ty, name, .. } => {\n+                                    InitializeVisitorState::Initialized {\n+                                        initializer: rhs,\n+                                        ty,\n+                                        name,\n+                                    }\n+                                },\n+                                _ => InitializeVisitorState::DontWarn,\n                             }\n+                        } else {\n+                            InitializeVisitorState::DontWarn\n                         }\n                     },\n                     ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {"}, {"sha": "5b22b64a370e251ea56ff9f1ee1894428b3b03cb", "filename": "src/tools/clippy/clippy_lints/src/macro_use.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::in_macro;\n use clippy_utils::source::snippet;\n use hir::def::{DefKind, Res};\n use if_chain::if_chain;\n@@ -9,6 +8,7 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::hygiene::ExpnKind;\n use rustc_span::{edition::Edition, sym, Span};\n \n declare_clippy_lint! {\n@@ -24,6 +24,7 @@ declare_clippy_lint! {\n     /// #[macro_use]\n     /// use some_macro;\n     /// ```\n+    #[clippy::version = \"1.44.0\"]\n     pub MACRO_USE_IMPORTS,\n     pedantic,\n     \"#[macro_use] is no longer needed\"\n@@ -212,3 +213,7 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n         }\n     }\n }\n+\n+fn in_macro(span: Span) -> bool {\n+    span.from_expansion() && !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n+}"}, {"sha": "fad8fa467d4b80f23917e969d0a865fdde3a6906", "filename": "src/tools/clippy/clippy_lints/src/main_recursion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmain_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmain_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmain_recursion.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -20,6 +20,7 @@ declare_clippy_lint! {\n     ///     main();\n     /// }\n     /// ```\n+    #[clippy::version = \"1.38.0\"]\n     pub MAIN_RECURSION,\n     style,\n     \"recursion using the entrypoint\""}, {"sha": "ed3166086f7ee05721b5c9e60b7d1109a0850fda", "filename": "src/tools/clippy/clippy_lints/src/manual_assert.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -26,6 +26,7 @@ declare_clippy_lint! {\n     /// let sad_people: Vec<&str> = vec![];\n     /// assert!(sad_people.is_empty(), \"there are sad people: {:?}\", sad_people);\n     /// ```\n+    #[clippy::version = \"1.57.0\"]\n     pub MANUAL_ASSERT,\n     pedantic,\n     \"`panic!` and only a `panic!` in `if`-then statement\""}, {"sha": "86819752f90ffe1753eaa2baa4d681f569bf9046", "filename": "src/tools/clippy/clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -30,6 +30,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// async fn foo() -> i32 { 42 }\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub MANUAL_ASYNC_FN,\n     style,\n     \"manual implementations of `async` functions can be simplified using the dedicated syntax\""}, {"sha": "4d8ad566e6b1d84f6131560c29ead691ec55b99b", "filename": "src/tools/clippy/clippy_lints/src/manual_map.rs", "status": "modified", "additions": 54, "deletions": 27, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -2,7 +2,7 @@ use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n-use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n+use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n use clippy_utils::{\n     can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n     peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n@@ -11,7 +11,8 @@ use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n-    def::Res, Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path, QPath,\n+    def::Res, Arm, BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path,\n+    QPath, UnsafeSource,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -36,6 +37,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// Some(0).map(|x| x + 1);\n     /// ```\n+    #[clippy::version = \"1.52.0\"]\n     pub MANUAL_MAP,\n     style,\n     \"reimplementation of `map`\"\n@@ -92,20 +94,20 @@ impl LateLintPass<'_> for ManualMap {\n             return;\n         }\n \n-        let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n+        let some_expr = match get_some_expr(cx, some_expr, false, expr_ctxt) {\n             Some(expr) => expr,\n             None => return,\n         };\n \n         // These two lints will go back and forth with each other.\n-        if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n+        if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n             && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n         {\n             return;\n         }\n \n         // `map` won't perform any adjustments.\n-        if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n+        if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n             return;\n         }\n \n@@ -119,7 +121,7 @@ impl LateLintPass<'_> for ManualMap {\n             None => \"\",\n         };\n \n-        match can_move_expr_to_closure(cx, some_expr) {\n+        match can_move_expr_to_closure(cx, some_expr.expr) {\n             Some(captures) => {\n                 // Check if captures the closure will need conflict with borrows made in the scrutinee.\n                 // TODO: check all the references made in the scrutinee expression. This will require interacting\n@@ -157,12 +159,14 @@ impl LateLintPass<'_> for ManualMap {\n             };\n \n         let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-            match can_pass_as_func(cx, id, some_expr) {\n-                Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n+            if_chain! {\n+                if !some_expr.needs_unsafe_block;\n+                if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n+                if func.span.ctxt() == some_expr.expr.span.ctxt();\n+                then {\n                     snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-                },\n-                _ => {\n-                    if path_to_local_id(some_expr, id)\n+                } else {\n+                    if path_to_local_id(some_expr.expr, id)\n                         && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n                         && binding_ref.is_some()\n                     {\n@@ -175,21 +179,23 @@ impl LateLintPass<'_> for ManualMap {\n                     } else {\n                         \"\"\n                     };\n-                    format!(\n-                        \"|{}{}| {}\",\n-                        annotation,\n-                        some_binding,\n-                        snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-                    )\n-                },\n+                    let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n+                    if some_expr.needs_unsafe_block {\n+                        format!(\"|{}{}| unsafe {{ {} }}\", annotation, some_binding, expr_snip)\n+                    } else {\n+                        format!(\"|{}{}| {}\", annotation, some_binding, expr_snip)\n+                    }\n+                }\n             }\n         } else if !is_wild_none && explicit_ref.is_none() {\n             // TODO: handle explicit reference annotations.\n-            format!(\n-                \"|{}| {}\",\n-                snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n-                snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-            )\n+            let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n+            let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n+            if some_expr.needs_unsafe_block {\n+                format!(\"|{}| unsafe {{ {} }}\", pat_snip, expr_snip)\n+            } else {\n+                format!(\"|{}| {}\", pat_snip, expr_snip)\n+            }\n         } else {\n             // Refutable bindings and mixed reference annotations can't be handled by `map`.\n             return;\n@@ -216,7 +222,9 @@ impl LateLintPass<'_> for ManualMap {\n fn can_pass_as_func(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     match expr.kind {\n         ExprKind::Call(func, [arg])\n-            if path_to_local_id(arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n+            if path_to_local_id(arg, binding)\n+                && cx.typeck_results().expr_adjustments(arg).is_empty()\n+                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n         {\n             Some(func)\n         },\n@@ -236,6 +244,11 @@ enum OptionPat<'a> {\n     },\n }\n \n+struct SomeExpr<'tcx> {\n+    expr: &'tcx Expr<'tcx>,\n+    needs_unsafe_block: bool,\n+}\n+\n // Try to parse into a recognized `Option` pattern.\n // i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n@@ -256,7 +269,12 @@ fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxCon\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n-fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxContext) -> Option<&'tcx Expr<'tcx>> {\n+fn get_some_expr(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    needs_unsafe_block: bool,\n+    ctxt: SyntaxContext,\n+) -> Option<SomeExpr<'tcx>> {\n     // TODO: Allow more complex expressions.\n     match expr.kind {\n         ExprKind::Call(\n@@ -265,15 +283,24 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxConte\n                 ..\n             },\n             [arg],\n-        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(arg),\n+        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(SomeExpr {\n+            expr: arg,\n+            needs_unsafe_block,\n+        }),\n         ExprKind::Block(\n             Block {\n                 stmts: [],\n                 expr: Some(expr),\n+                rules,\n                 ..\n             },\n             _,\n-        ) => get_some_expr(cx, expr, ctxt),\n+        ) => get_some_expr(\n+            cx,\n+            expr,\n+            needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n+            ctxt,\n+        ),\n         _ => None,\n     }\n }"}, {"sha": "63a72d4fddeb0b4d30a74d0b394fdde062c509b1", "filename": "src/tools/clippy/clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -52,6 +52,7 @@ declare_clippy_lint! {\n     /// #[non_exhaustive]\n     /// struct T(pub i32, pub i32);\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub MANUAL_NON_EXHAUSTIVE,\n     style,\n     \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\""}, {"sha": "b60e2dc366b416e455ea5fe04ea2a38845f22d89", "filename": "src/tools/clippy/clippy_lints/src/manual_ok_or.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -32,6 +32,7 @@ declare_clippy_lint! {\n     /// let foo: Option<i32> = None;\n     /// foo.ok_or(\"error\");\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub MANUAL_OK_OR,\n     pedantic,\n     \"finds patterns that can be encoded more concisely with `Option::ok_or`\""}, {"sha": "f8e28f1671f07cc66b26a6f0dd74570d38595d95", "filename": "src/tools/clippy/clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -42,6 +42,7 @@ declare_clippy_lint! {\n     ///     assert_eq!(end.to_uppercase(), \"WORLD!\");\n     /// }\n     /// ```\n+    #[clippy::version = \"1.48.0\"]\n     pub MANUAL_STRIP,\n     complexity,\n     \"suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing\""}, {"sha": "aac3c6e0de2bb6b12f2bb0f65f3e7de60a9148f7", "filename": "src/tools/clippy/clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -35,6 +35,7 @@ declare_clippy_lint! {\n     /// let foo: Option<i32> = None;\n     /// foo.unwrap_or(1);\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub MANUAL_UNWRAP_OR,\n     complexity,\n     \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\""}, {"sha": "c2b78e21861d7d38b09eb4cf4e12254c58a0ce6d", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -37,6 +37,7 @@ declare_clippy_lint! {\n     /// let y = x.iter();\n     /// let z = y.cloned();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MAP_CLONE,\n     style,\n     \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\""}, {"sha": "61f21d532c5016ffc3b09a6f7b4705f291c4ab7f", "filename": "src/tools/clippy/clippy_lints/src/map_err_ignore.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_err_ignore.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -97,6 +97,7 @@ declare_clippy_lint! {\n     ///         })\n     /// }\n     /// ```\n+    #[clippy::version = \"1.48.0\"]\n     pub MAP_ERR_IGNORE,\n     restriction,\n     \"`map_err` should not ignore the original error\""}, {"sha": "58c686d95b3f91caed5e57466b807e33ca9ab8a7", "filename": "src/tools/clippy/clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -47,6 +47,7 @@ declare_clippy_lint! {\n     ///     log_err_msg(format_msg(msg));\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub OPTION_MAP_UNIT_FN,\n     complexity,\n     \"using `option.map(f)`, where `f` is a function or closure that returns `()`\"\n@@ -87,6 +88,7 @@ declare_clippy_lint! {\n     ///     log_err_msg(format_msg(msg));\n     /// };\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub RESULT_MAP_UNIT_FN,\n     complexity,\n     \"using `result.map(f)`, where `f` is a function or closure that returns `()`\"\n@@ -188,7 +190,7 @@ fn unit_closure<'tcx>(\n /// Anything else will return `a`.\n fn let_binding_name(cx: &LateContext<'_>, var_arg: &hir::Expr<'_>) -> String {\n     match &var_arg.kind {\n-        hir::ExprKind::Field(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n+        hir::ExprKind::Field(_, _) => snippet(cx, var_arg.span, \"_\").replace('.', \"_\"),\n         hir::ExprKind::Path(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n         _ => \"a\".to_string(),\n     }"}, {"sha": "583b577ffe25d51ea72332b2e130b77c07b7ba20", "filename": "src/tools/clippy/clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -40,6 +40,7 @@ declare_clippy_lint! {\n     ///     _ => {},\n     /// }\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub MATCH_ON_VEC_ITEMS,\n     pedantic,\n     \"matching on vector elements can panic\""}, {"sha": "b1839f00aaee95d1922eea1eaf9c68e3c9a584c2", "filename": "src/tools/clippy/clippy_lints/src/match_result_ok.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_result_ok.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -38,6 +38,7 @@ declare_clippy_lint! {\n     ///        vec.push(value)\n     /// }\n     /// ```\n+    #[clippy::version = \"1.57.0\"]\n     pub MATCH_RESULT_OK,\n     style,\n     \"usage of `ok()` in `let Some(pat)` statements is unnecessary, match on `Ok(pat)` instead\""}, {"sha": "3316ebf405109591fdcd3270f26b5639887f71aa", "filename": "src/tools/clippy/clippy_lints/src/match_str_case_mismatch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -39,6 +39,7 @@ declare_clippy_lint! {\n     ///     _ => {},\n     /// }\n     /// ```\n+    #[clippy::version = \"1.58.0\"]\n     pub MATCH_STR_CASE_MISMATCH,\n     correctness,\n     \"creation of a case altering match expression with non-compliant arms\""}, {"sha": "eacbfa54cf70f22ad9480dcf367de28233ad7af5", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 96, "deletions": 95, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -8,9 +8,9 @@ use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n-    get_parent_expr, in_macro, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild,\n-    meets_msrv, msrvs, path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n-    remove_blocks, strip_pat_refs,\n+    get_parent_expr, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n+    path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, remove_blocks,\n+    strip_pat_refs,\n };\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use core::iter::{once, ExactSizeIterator};\n@@ -25,16 +25,13 @@ use rustc_hir::{\n };\n use rustc_hir::{HirIdMap, HirIdSet};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty, TyS, VariantDef};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::sym;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry;\n-use std::iter;\n-use std::ops::Bound;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -59,6 +56,7 @@ declare_clippy_lint! {\n     ///     bar(foo);\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SINGLE_MATCH,\n     style,\n     \"a `match` statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\"\n@@ -100,6 +98,7 @@ declare_clippy_lint! {\n     ///     bar(&other_ref);\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SINGLE_MATCH_ELSE,\n     pedantic,\n     \"a `match` statement with two arms where the second arm's pattern is a placeholder instead of a specific match pattern\"\n@@ -131,6 +130,7 @@ declare_clippy_lint! {\n     ///     _ => frob(x),\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MATCH_REF_PATS,\n     style,\n     \"a `match` or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\"\n@@ -165,6 +165,7 @@ declare_clippy_lint! {\n     ///     bar();\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MATCH_BOOL,\n     pedantic,\n     \"a `match` on a boolean expression instead of an `if..else` block\"\n@@ -187,6 +188,7 @@ declare_clippy_lint! {\n     ///     _ => (),\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MATCH_OVERLAPPING_ARM,\n     style,\n     \"a `match` with overlapping arms\"\n@@ -209,6 +211,7 @@ declare_clippy_lint! {\n     ///     Err(_) => panic!(\"err\"),\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MATCH_WILD_ERR_ARM,\n     pedantic,\n     \"a `match` with `Err(_)` arm and take drastic actions\"\n@@ -235,6 +238,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let r: Option<&()> = x.as_ref();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MATCH_AS_REF,\n     complexity,\n     \"a `match` on an Option value instead of using `as_ref()` or `as_mut`\"\n@@ -267,6 +271,7 @@ declare_clippy_lint! {\n     ///     Foo::B(_) => {},\n     /// }\n     /// ```\n+    #[clippy::version = \"1.34.0\"]\n     pub WILDCARD_ENUM_MATCH_ARM,\n     restriction,\n     \"a wildcard enum match arm using `_`\"\n@@ -301,6 +306,7 @@ declare_clippy_lint! {\n     ///     Foo::C => {},\n     /// }\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n     pedantic,\n     \"a wildcard enum match for a single variant\"\n@@ -328,6 +334,7 @@ declare_clippy_lint! {\n     ///     _ => {},\n     /// }\n     /// ```\n+    #[clippy::version = \"1.42.0\"]\n     pub WILDCARD_IN_OR_PATTERNS,\n     complexity,\n     \"a wildcard pattern used with others patterns in same match arm\"\n@@ -363,6 +370,7 @@ declare_clippy_lint! {\n     /// let wrapper = Wrapper::Data(42);\n     /// let Wrapper::Data(data) = wrapper;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub INFALLIBLE_DESTRUCTURING_MATCH,\n     style,\n     \"a `match` statement with a single infallible arm instead of a `let`\"\n@@ -394,6 +402,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let (c, d) = (a, b);\n     /// ```\n+    #[clippy::version = \"1.43.0\"]\n     pub MATCH_SINGLE_BINDING,\n     complexity,\n     \"a match with a single binding instead of using `let` statement\"\n@@ -424,6 +433,7 @@ declare_clippy_lint! {\n     ///     _ => {},\n     /// }\n     /// ```\n+    #[clippy::version = \"1.43.0\"]\n     pub REST_PAT_IN_FULLY_BOUND_STRUCTS,\n     restriction,\n     \"a match on a struct that binds all fields but still uses the wildcard pattern\"\n@@ -479,6 +489,7 @@ declare_clippy_lint! {\n     /// if IpAddr::V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n     /// Ok::<i32, i32>(42).is_ok();\n     /// ```\n+    #[clippy::version = \"1.31.0\"]\n     pub REDUNDANT_PATTERN_MATCHING,\n     style,\n     \"use the proper utility function avoiding an `if let`\"\n@@ -515,6 +526,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let a = matches!(x, Some(0));\n     /// ```\n+    #[clippy::version = \"1.47.0\"]\n     pub MATCH_LIKE_MATCHES_MACRO,\n     style,\n     \"a match that could be written with the matches! macro\"\n@@ -559,6 +571,7 @@ declare_clippy_lint! {\n     ///     Quz => quz(),\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MATCH_SAME_ARMS,\n     pedantic,\n     \"`match` with identical arm bodies\"\n@@ -601,7 +614,7 @@ impl_lint_pass!(Matches => [\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if in_external_macro(cx.sess(), expr.span) || in_macro(expr.span) {\n+        if expr.span.from_expansion() {\n             return;\n         }\n \n@@ -633,15 +646,11 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         if let ExprKind::Match(ex, arms, _) = expr.kind {\n             check_match_ref_pats(cx, ex, arms.iter().map(|el| el.pat), expr);\n         }\n-        if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(cx, expr) {\n-            check_match_ref_pats(cx, let_expr, once(let_pat), expr);\n-        }\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n         if_chain! {\n-            if !in_external_macro(cx.sess(), local.span);\n-            if !in_macro(local.span);\n+            if !local.span.from_expansion();\n             if let Some(expr) = local.init;\n             if let ExprKind::Match(target, arms, MatchSource::Normal) = expr.kind;\n             if arms.len() == 1 && arms[0].guard.is_none();\n@@ -676,8 +685,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n \n     fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n         if_chain! {\n-            if !in_external_macro(cx.sess(), pat.span);\n-            if !in_macro(pat.span);\n+            if !pat.span.from_expansion();\n             if let PatKind::Struct(QPath::Resolved(_, path), fields, true) = pat.kind;\n             if let Some(def_id) = path.res.opt_def_id();\n             let ty = cx.tcx.type_of(def_id);\n@@ -704,7 +712,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n #[rustfmt::skip]\n fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        if in_macro(expr.span) {\n+        if expr.span.from_expansion() {\n             // Don't lint match expressions present in\n             // macro_rules! block\n             return;\n@@ -1450,7 +1458,7 @@ fn find_bool_lit(ex: &ExprKind<'_>, is_if_let: bool) -> Option<bool> {\n \n #[allow(clippy::too_many_lines)]\n fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if in_macro(expr.span) || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n+    if expr.span.from_expansion() || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n         return;\n     }\n \n@@ -1605,27 +1613,27 @@ fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'\n     None\n }\n \n-/// Gets all arms that are unbounded `PatRange`s.\n+/// Gets the ranges for each range pattern arm. Applies `ty` bounds for open ranges.\n fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<FullInt>> {\n     arms.iter()\n         .filter_map(|arm| {\n             if let Arm { pat, guard: None, .. } = *arm {\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n-                    let lhs = match lhs {\n+                    let lhs_const = match lhs {\n                         Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n                         None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n                     };\n-                    let rhs = match rhs {\n+                    let rhs_const = match rhs {\n                         Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n                         None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n                     };\n \n-                    let lhs_val = lhs.int_value(cx, ty)?;\n-                    let rhs_val = rhs.int_value(cx, ty)?;\n+                    let lhs_val = lhs_const.int_value(cx, ty)?;\n+                    let rhs_val = rhs_const.int_value(cx, ty)?;\n \n                     let rhs_bound = match range_end {\n-                        RangeEnd::Included => Bound::Included(rhs_val),\n-                        RangeEnd::Excluded => Bound::Excluded(rhs_val),\n+                        RangeEnd::Included => EndBound::Included(rhs_val),\n+                        RangeEnd::Excluded => EndBound::Excluded(rhs_val),\n                     };\n                     return Some(SpannedRange {\n                         span: pat.span,\n@@ -1637,7 +1645,7 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                     let value = constant_full_int(cx, cx.typeck_results(), value)?;\n                     return Some(SpannedRange {\n                         span: pat.span,\n-                        node: (value, Bound::Included(value)),\n+                        node: (value, EndBound::Included(value)),\n                     });\n                 }\n             }\n@@ -1646,10 +1654,16 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n         .collect()\n }\n \n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+pub enum EndBound<T> {\n+    Included(T),\n+    Excluded(T),\n+}\n+\n #[derive(Debug, Eq, PartialEq)]\n-pub struct SpannedRange<T> {\n+struct SpannedRange<T> {\n     pub span: Span,\n-    pub node: (T, Bound<T>),\n+    pub node: (T, EndBound<T>),\n }\n \n // Checks if arm has the form `None => None`\n@@ -1698,82 +1712,63 @@ where\n     ref_count > 1\n }\n \n-pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n+fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n where\n     T: Copy + Ord,\n {\n-    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-    enum Kind<'a, T> {\n-        Start(T, &'a SpannedRange<T>),\n-        End(Bound<T>, &'a SpannedRange<T>),\n+    #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+    enum BoundKind {\n+        EndExcluded,\n+        Start,\n+        EndIncluded,\n     }\n \n-    impl<'a, T: Copy> Kind<'a, T> {\n-        fn range(&self) -> &'a SpannedRange<T> {\n-            match *self {\n-                Kind::Start(_, r) | Kind::End(_, r) => r,\n-            }\n-        }\n-\n-        fn value(self) -> Bound<T> {\n-            match self {\n-                Kind::Start(t, _) => Bound::Included(t),\n-                Kind::End(t, _) => t,\n-            }\n-        }\n-    }\n+    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+    struct RangeBound<'a, T>(T, BoundKind, &'a SpannedRange<T>);\n \n-    impl<'a, T: Copy + Ord> PartialOrd for Kind<'a, T> {\n+    impl<'a, T: Copy + Ord> PartialOrd for RangeBound<'a, T> {\n         fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n             Some(self.cmp(other))\n         }\n     }\n \n-    impl<'a, T: Copy + Ord> Ord for Kind<'a, T> {\n-        fn cmp(&self, other: &Self) -> Ordering {\n-            match (self.value(), other.value()) {\n-                (Bound::Included(a), Bound::Included(b)) | (Bound::Excluded(a), Bound::Excluded(b)) => a.cmp(&b),\n-                // Range patterns cannot be unbounded (yet)\n-                (Bound::Unbounded, _) | (_, Bound::Unbounded) => unimplemented!(),\n-                (Bound::Included(a), Bound::Excluded(b)) => match a.cmp(&b) {\n-                    Ordering::Equal => Ordering::Greater,\n-                    other => other,\n-                },\n-                (Bound::Excluded(a), Bound::Included(b)) => match a.cmp(&b) {\n-                    Ordering::Equal => Ordering::Less,\n-                    other => other,\n-                },\n-            }\n+    impl<'a, T: Copy + Ord> Ord for RangeBound<'a, T> {\n+        fn cmp(&self, RangeBound(other_value, other_kind, _): &Self) -> Ordering {\n+            let RangeBound(self_value, self_kind, _) = *self;\n+            (self_value, self_kind).cmp(&(*other_value, *other_kind))\n         }\n     }\n \n     let mut values = Vec::with_capacity(2 * ranges.len());\n \n-    for r in ranges {\n-        values.push(Kind::Start(r.node.0, r));\n-        values.push(Kind::End(r.node.1, r));\n+    for r @ SpannedRange { node: (start, end), .. } in ranges {\n+        values.push(RangeBound(*start, BoundKind::Start, r));\n+        values.push(match end {\n+            EndBound::Excluded(val) => RangeBound(*val, BoundKind::EndExcluded, r),\n+            EndBound::Included(val) => RangeBound(*val, BoundKind::EndIncluded, r),\n+        });\n     }\n \n     values.sort();\n \n-    for (a, b) in iter::zip(&values, values.iter().skip(1)) {\n-        match (a, b) {\n-            (&Kind::Start(_, ra), &Kind::End(_, rb)) => {\n-                if ra.node != rb.node {\n-                    return Some((ra, rb));\n-                }\n-            },\n-            (&Kind::End(a, _), &Kind::Start(b, _)) if a != Bound::Included(b) => (),\n-            _ => {\n-                // skip if the range `a` is completely included into the range `b`\n-                if let Ordering::Equal | Ordering::Less = a.cmp(b) {\n-                    let kind_a = Kind::End(a.range().node.1, a.range());\n-                    let kind_b = Kind::End(b.range().node.1, b.range());\n-                    if let Ordering::Equal | Ordering::Greater = kind_a.cmp(&kind_b) {\n-                        return None;\n+    let mut started = vec![];\n+\n+    for RangeBound(_, kind, range) in values {\n+        match kind {\n+            BoundKind::Start => started.push(range),\n+            BoundKind::EndExcluded | BoundKind::EndIncluded => {\n+                let mut overlap = None;\n+\n+                while let Some(last_started) = started.pop() {\n+                    if last_started == range {\n+                        break;\n                     }\n+                    overlap = Some(last_started);\n+                }\n+\n+                if let Some(first_overlapping) = overlap {\n+                    return Some((range, first_overlapping));\n                 }\n-                return Some((a.range(), b.range()));\n             },\n         }\n     }\n@@ -1785,7 +1780,8 @@ mod redundant_pattern_match {\n     use super::REDUNDANT_PATTERN_MATCHING;\n     use clippy_utils::diagnostics::span_lint_and_then;\n     use clippy_utils::higher;\n-    use clippy_utils::source::{snippet, snippet_with_applicability};\n+    use clippy_utils::source::snippet;\n+    use clippy_utils::sugg::Sugg;\n     use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n     use clippy_utils::{is_lang_ctor, is_qpath_def_path, is_trait_method, paths};\n     use if_chain::if_chain;\n@@ -1795,7 +1791,7 @@ mod redundant_pattern_match {\n     use rustc_hir::LangItem::{OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n     use rustc_hir::{\n         intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n-        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath,\n+        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath, UnOp,\n     };\n     use rustc_lint::LateContext;\n     use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n@@ -2049,8 +2045,10 @@ mod redundant_pattern_match {\n \n         let result_expr = match &let_expr.kind {\n             ExprKind::AddrOf(_, _, borrowed) => borrowed,\n+            ExprKind::Unary(UnOp::Deref, deref) => deref,\n             _ => let_expr,\n         };\n+\n         span_lint_and_then(\n             cx,\n             REDUNDANT_PATTERN_MATCHING,\n@@ -2069,12 +2067,15 @@ mod redundant_pattern_match {\n                 // ^^^^^^^^^^^^^^^^^^^\n                 let span = expr_span.until(op_span.shrink_to_hi());\n \n-                let mut app = if needs_drop {\n+                let app = if needs_drop {\n                     Applicability::MaybeIncorrect\n                 } else {\n                     Applicability::MachineApplicable\n                 };\n-                let sugg = snippet_with_applicability(cx, op_span, \"_\", &mut app);\n+\n+                let sugg = Sugg::hir_with_macro_callsite(cx, result_expr, \"_\")\n+                    .maybe_par()\n+                    .to_string();\n \n                 diag.span_suggestion(span, \"try this\", format!(\"{} {}.{}\", keyword, sugg, good_method), app);\n \n@@ -2224,29 +2225,29 @@ fn test_overlapping() {\n     };\n \n     assert_eq!(None, overlapping::<u8>(&[]));\n-    assert_eq!(None, overlapping(&[sp(1, Bound::Included(4))]));\n+    assert_eq!(None, overlapping(&[sp(1, EndBound::Included(4))]));\n     assert_eq!(\n         None,\n-        overlapping(&[sp(1, Bound::Included(4)), sp(5, Bound::Included(6))])\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(5, EndBound::Included(6))])\n     );\n     assert_eq!(\n         None,\n         overlapping(&[\n-            sp(1, Bound::Included(4)),\n-            sp(5, Bound::Included(6)),\n-            sp(10, Bound::Included(11))\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(10, EndBound::Included(11))\n         ],)\n     );\n     assert_eq!(\n-        Some((&sp(1, Bound::Included(4)), &sp(3, Bound::Included(6)))),\n-        overlapping(&[sp(1, Bound::Included(4)), sp(3, Bound::Included(6))])\n+        Some((&sp(1, EndBound::Included(4)), &sp(3, EndBound::Included(6)))),\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(3, EndBound::Included(6))])\n     );\n     assert_eq!(\n-        Some((&sp(5, Bound::Included(6)), &sp(6, Bound::Included(11)))),\n+        Some((&sp(5, EndBound::Included(6)), &sp(6, EndBound::Included(11)))),\n         overlapping(&[\n-            sp(1, Bound::Included(4)),\n-            sp(5, Bound::Included(6)),\n-            sp(6, Bound::Included(11))\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(6, EndBound::Included(11))\n         ],)\n     );\n }"}, {"sha": "5ffcfd4d2641709c5fa7fd0f8f2fd824e2c5cd24", "filename": "src/tools/clippy/clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -19,6 +19,7 @@ declare_clippy_lint! {\n     /// # use std::rc::Rc;\n     /// mem::forget(Rc::new(55))\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MEM_FORGET,\n     restriction,\n     \"`mem::forget` usage on `Drop` types, likely to cause memory leaks\""}, {"sha": "7fc39f17232fd41050e000e3eead23503d34bea9", "filename": "src/tools/clippy/clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::is_non_aggregate_primitive_type;\n-use clippy_utils::{in_macro, is_default_equivalent, is_lang_ctor, match_def_path, meets_msrv, msrvs, paths};\n+use clippy_utils::{is_default_equivalent, is_lang_ctor, match_def_path, meets_msrv, msrvs, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n@@ -35,6 +35,7 @@ declare_clippy_lint! {\n     /// let mut an_option = Some(0);\n     /// let taken = an_option.take();\n     /// ```\n+    #[clippy::version = \"1.31.0\"]\n     pub MEM_REPLACE_OPTION_WITH_NONE,\n     style,\n     \"replacing an `Option` with `None` instead of `take()`\"\n@@ -66,6 +67,7 @@ declare_clippy_lint! {\n     /// The [take_mut](https://docs.rs/take_mut) crate offers a sound solution,\n     /// at the cost of either lazily creating a replacement value or aborting\n     /// on panic, to ensure that the uninitialized value cannot be observed.\n+    #[clippy::version = \"1.39.0\"]\n     pub MEM_REPLACE_WITH_UNINIT,\n     correctness,\n     \"`mem::replace(&mut _, mem::uninitialized())` or `mem::replace(&mut _, mem::zeroed())`\"\n@@ -90,6 +92,7 @@ declare_clippy_lint! {\n     /// let mut text = String::from(\"foo\");\n     /// let taken = std::mem::take(&mut text);\n     /// ```\n+    #[clippy::version = \"1.42.0\"]\n     pub MEM_REPLACE_WITH_DEFAULT,\n     style,\n     \"replacing a value of type `T` with `T::default()` instead of using `std::mem::take`\"\n@@ -213,7 +216,7 @@ fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<\n             expr_span,\n             \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\",\n             |diag| {\n-                if !in_macro(expr_span) {\n+                if !expr_span.from_expansion() {\n                     let suggestion = format!(\"std::mem::take({})\", snippet(cx, dest.span, \"\"));\n \n                     diag.span_suggestion("}, {"sha": "b7690cf9222cc8be9162ee59b8cff744b686a0e4", "filename": "src/tools/clippy/clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,7 +1,7 @@\n use super::{contains_return, BIND_INSTEAD_OF_MAP};\n use clippy_utils::diagnostics::{multispan_sugg_with_applicability, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n-use clippy_utils::{in_macro, remove_blocks, visitors::find_all_ret_expressions};\n+use clippy_utils::{remove_blocks, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -106,7 +106,7 @@ pub(crate) trait BindInsteadOfMap {\n         let mut suggs = Vec::new();\n         let can_sugg: bool = find_all_ret_expressions(cx, closure_expr, |ret_expr| {\n             if_chain! {\n-                if !in_macro(ret_expr.span);\n+                if !ret_expr.span.from_expansion();\n                 if let hir::ExprKind::Call(func_path, [arg]) = ret_expr.kind;\n                 if let hir::ExprKind::Path(QPath::Resolved(_, path)) = func_path.kind;\n                 if Self::is_variant(cx, path.res);"}, {"sha": "8ea9312c0f7075557211e94575f30d946a4fe040", "filename": "src/tools/clippy/clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -69,7 +69,7 @@ fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'tcx>) -\n                         // i.e.: 2 wildcards in `std::collections::BTreeMap<&i32, &char>`\n                         let ty_str = ty.to_string();\n                         let start = ty_str.find('<').unwrap_or(0);\n-                        let end = ty_str.find('>').unwrap_or_else(|| ty_str.len());\n+                        let end = ty_str.find('>').unwrap_or(ty_str.len());\n                         let nb_wildcard = ty_str[start..end].split(',').count();\n                         let wildcards = format!(\"_{}\", \", _\".repeat(nb_wildcard - 1));\n                         format!(\"{}<{}>\", elements.join(\"::\"), wildcards)"}, {"sha": "30d56113c6c102af9e81b9a9c86857bb491406f3", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_cloned_collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -9,7 +9,7 @@ use rustc_span::sym;\n \n use super::ITER_CLONED_COLLECT;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, recv: &'tcx hir::Expr<'_>) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, method_name: &str, expr: &hir::Expr<'_>, recv: &'tcx hir::Expr<'_>) {\n     if_chain! {\n         if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Vec);\n         if let Some(slice) = derefs_to_slice(cx, recv, cx.typeck_results().expr_ty(recv));\n@@ -20,8 +20,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, recv: &'\n                 cx,\n                 ITER_CLONED_COLLECT,\n                 to_replace,\n-                \"called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n-                more readable\",\n+                &format!(\"called `iter().{}().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n+                more readable\", method_name),\n                 \"try\",\n                 \".to_vec()\".to_string(),\n                 Applicability::MachineApplicable,"}, {"sha": "58ec221353567c7421e9794de3f3090c94b4befc", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 100, "deletions": 7, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -33,7 +33,6 @@ mod iter_nth_zero;\n mod iter_skip_next;\n mod iterator_step_by_zero;\n mod manual_saturating_arithmetic;\n-mod manual_split_once;\n mod manual_str_repeat;\n mod map_collect_result_unit;\n mod map_flatten;\n@@ -50,6 +49,7 @@ mod single_char_insert_string;\n mod single_char_pattern;\n mod single_char_push_string;\n mod skip_while_next;\n+mod str_splitn;\n mod string_extend_chars;\n mod suspicious_map;\n mod suspicious_splitn;\n@@ -68,7 +68,7 @@ use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, meets_msrv, msrvs, paths, return_ty};\n+use clippy_utils::{contains_return, get_trait_def_id, iter_input_pats, meets_msrv, msrvs, paths, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -99,6 +99,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// [1, 2, 3].iter().copied();\n     /// ```\n+    #[clippy::version = \"1.53.0\"]\n     pub CLONED_INSTEAD_OF_COPIED,\n     pedantic,\n     \"used `cloned` where `copied` could be used instead\"\n@@ -121,6 +122,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().filter_map(|x| x.parse().ok()).collect();\n     /// ```\n+    #[clippy::version = \"1.53.0\"]\n     pub FLAT_MAP_OPTION,\n     pedantic,\n     \"used `flat_map` where `filter_map` could be used instead\"\n@@ -166,6 +168,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// res.expect(\"more helpful message\");\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub UNWRAP_USED,\n     restriction,\n     \"using `.unwrap()` on `Result` or `Option`, which should at least get a better message using `expect()`\"\n@@ -208,6 +211,7 @@ declare_clippy_lint! {\n     /// res?;\n     /// # Ok::<(), ()>(())\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub EXPECT_USED,\n     restriction,\n     \"using `.expect()` on `Result` or `Option`, which might be better handled\"\n@@ -237,6 +241,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SHOULD_IMPLEMENT_TRAIT,\n     style,\n     \"defining a method that should be implementing a std trait\"\n@@ -284,6 +289,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub WRONG_SELF_CONVENTION,\n     style,\n     \"defining a method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\"\n@@ -310,6 +316,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// x.expect(\"why did I do this again?\");\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub OK_EXPECT,\n     style,\n     \"using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\"\n@@ -335,6 +342,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// x.unwrap_or_default();\n     /// ```\n+    #[clippy::version = \"1.56.0\"]\n     pub UNWRAP_OR_ELSE_DEFAULT,\n     style,\n     \"using `.unwrap_or_else(Default::default)`, which is more succinctly expressed as `.unwrap_or_default()`\"\n@@ -375,6 +383,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// x.map_or_else(some_function, |a| a + 1);\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub MAP_UNWRAP_OR,\n     pedantic,\n     \"using `.map(f).unwrap_or(a)` or `.map(f).unwrap_or_else(func)`, which are more succinctly expressed as `map_or(a, f)` or `map_or_else(a, f)`\"\n@@ -401,6 +410,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// opt.and_then(|a| Some(a + 1));\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub OPTION_MAP_OR_NONE,\n     style,\n     \"using `Option.map_or(None, f)`, which is more succinctly expressed as `and_then(f)`\"\n@@ -426,6 +436,7 @@ declare_clippy_lint! {\n     /// # let r: Result<u32, &str> = Ok(1);\n     /// assert_eq!(Some(1), r.ok());\n     /// ```\n+    #[clippy::version = \"1.44.0\"]\n     pub RESULT_MAP_OR_INTO_OPTION,\n     style,\n     \"using `Result.map_or(None, Some)`, which is more succinctly expressed as `ok()`\"\n@@ -458,6 +469,7 @@ declare_clippy_lint! {\n     /// let _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });\n     /// let _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub BIND_INSTEAD_OF_MAP,\n     complexity,\n     \"using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\"\n@@ -481,6 +493,7 @@ declare_clippy_lint! {\n     /// # let vec = vec![1];\n     /// vec.iter().find(|x| **x == 0);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub FILTER_NEXT,\n     complexity,\n     \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\"\n@@ -504,6 +517,7 @@ declare_clippy_lint! {\n     /// # let vec = vec![1];\n     /// vec.iter().find(|x| **x != 0);\n     /// ```\n+    #[clippy::version = \"1.42.0\"]\n     pub SKIP_WHILE_NEXT,\n     complexity,\n     \"using `skip_while(p).next()`, which is more succinctly expressed as `.find(!p)`\"\n@@ -527,8 +541,9 @@ declare_clippy_lint! {\n     /// // Good\n     /// vec.iter().flat_map(|x| x.iter());\n     /// ```\n+    #[clippy::version = \"1.31.0\"]\n     pub MAP_FLATTEN,\n-    pedantic,\n+    complexity,\n     \"using combinations of `flatten` and `map` which can usually be written as a single method call\"\n }\n \n@@ -553,6 +568,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// (0_i32..10).filter_map(|n| n.checked_add(1));\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub MANUAL_FILTER_MAP,\n     complexity,\n     \"using `_.filter(_).map(_)` in a way that can be written more simply as `filter_map(_)`\"\n@@ -579,6 +595,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// (0_i32..10).find_map(|n| n.checked_add(1));\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub MANUAL_FIND_MAP,\n     complexity,\n     \"using `_.find(_).map(_)` in a way that can be written more simply as `find_map(_)`\"\n@@ -601,6 +618,7 @@ declare_clippy_lint! {\n     /// ```rust\n     ///  (0..3).find_map(|x| if x == 2 { Some(x) } else { None });\n     /// ```\n+    #[clippy::version = \"1.36.0\"]\n     pub FILTER_MAP_NEXT,\n     pedantic,\n     \"using combination of `filter_map` and `next` which can usually be written as a single method call\"\n@@ -623,6 +641,7 @@ declare_clippy_lint! {\n     /// # let iter = vec![vec![0]].into_iter();\n     /// iter.flatten();\n     /// ```\n+    #[clippy::version = \"1.39.0\"]\n     pub FLAT_MAP_IDENTITY,\n     complexity,\n     \"call to `flat_map` where `flatten` is sufficient\"\n@@ -652,6 +671,7 @@ declare_clippy_lint! {\n     ///\n     /// let _ = !\"hello world\".contains(\"world\");\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SEARCH_IS_SOME,\n     complexity,\n     \"using an iterator or string search followed by `is_some()` or `is_none()`, which is more succinctly expressed as a call to `any()` or `contains()` (with negation in case of `is_none()`)\"\n@@ -676,6 +696,7 @@ declare_clippy_lint! {\n     /// let name = \"foo\";\n     /// if name.starts_with('_') {};\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CHARS_NEXT_CMP,\n     style,\n     \"using `.chars().next()` to check if a string starts with a char\"\n@@ -710,6 +731,7 @@ declare_clippy_lint! {\n     /// # let foo = Some(String::new());\n     /// foo.unwrap_or_default();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub OR_FUN_CALL,\n     perf,\n     \"using any `*or` method with a function call, which suggests `*or_else`\"\n@@ -748,6 +770,7 @@ declare_clippy_lint! {\n     /// # let err_msg = \"I'm a teapot\";\n     /// foo.unwrap_or_else(|| panic!(\"Err {}: {}\", err_code, err_msg));\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub EXPECT_FUN_CALL,\n     perf,\n     \"using any `expect` method with a function call\"\n@@ -765,6 +788,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// 42u64.clone();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CLONE_ON_COPY,\n     complexity,\n     \"using `clone` on a `Copy` type\"\n@@ -792,6 +816,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// Rc::clone(&x);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CLONE_ON_REF_PTR,\n     restriction,\n     \"using 'clone' on a ref-counted pointer\"\n@@ -814,6 +839,7 @@ declare_clippy_lint! {\n     ///     println!(\"{:p} {:p}\", *y, z); // prints out the same pointer\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CLONE_DOUBLE_REF,\n     correctness,\n     \"using `clone` on `&&T`\"\n@@ -837,6 +863,7 @@ declare_clippy_lint! {\n     /// // OK, the specialized impl is used\n     /// [\"foo\", \"bar\"].iter().map(|&s| s.to_string());\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub INEFFICIENT_TO_STRING,\n     pedantic,\n     \"using `to_string` on `&&T` where `T: ToString`\"\n@@ -898,6 +925,7 @@ declare_clippy_lint! {\n     ///     fn new() -> Self;\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEW_RET_NO_SELF,\n     style,\n     \"not returning type containing `Self` in a `new` method\"\n@@ -922,6 +950,7 @@ declare_clippy_lint! {\n     ///\n     /// // Good\n     /// _.split('x');\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SINGLE_CHAR_PATTERN,\n     perf,\n     \"using a single-character str where a char could be used, e.g., `_.split(\\\"x\\\")`\"\n@@ -941,6 +970,7 @@ declare_clippy_lint! {\n     ///     //..\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ITERATOR_STEP_BY_ZERO,\n     correctness,\n     \"using `Iterator::step_by(0)`, which will panic at runtime\"\n@@ -962,6 +992,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let _ = std::iter::empty::<Option<i32>>().flatten();\n     /// ```\n+    #[clippy::version = \"1.53.0\"]\n     pub OPTION_FILTER_MAP,\n     complexity,\n     \"filtering `Option` for `Some` then force-unwrapping, which can be one type-safe operation\"\n@@ -989,6 +1020,7 @@ declare_clippy_lint! {\n     /// # s.insert(1);\n     /// let x = s.iter().next();\n     /// ```\n+    #[clippy::version = \"1.42.0\"]\n     pub ITER_NTH_ZERO,\n     style,\n     \"replace `iter.nth(0)` with `iter.next()`\"\n@@ -1015,6 +1047,7 @@ declare_clippy_lint! {\n     /// let bad_vec = some_vec.get(3);\n     /// let bad_slice = &some_vec[..].get(3);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ITER_NTH,\n     perf,\n     \"using `.iter().nth()` on a standard library type with O(1) element access\"\n@@ -1039,6 +1072,7 @@ declare_clippy_lint! {\n     /// let bad_vec = some_vec.iter().nth(3);\n     /// let bad_slice = &some_vec[..].iter().nth(3);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ITER_SKIP_NEXT,\n     style,\n     \"using `.skip(x).next()` on an iterator\"\n@@ -1075,6 +1109,7 @@ declare_clippy_lint! {\n     /// let last = some_vec[3];\n     /// some_vec[0] = 1;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub GET_UNWRAP,\n     restriction,\n     \"using `.get().unwrap()` or `.get_mut().unwrap()` when using `[]` would work instead\"\n@@ -1098,6 +1133,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// a.append(&mut b);\n     /// ```\n+    #[clippy::version = \"1.55.0\"]\n     pub EXTEND_WITH_DRAIN,\n     perf,\n     \"using vec.append(&mut vec) to move the full range of a vecor to another\"\n@@ -1127,6 +1163,7 @@ declare_clippy_lint! {\n     /// s.push_str(abc);\n     /// s.push_str(&def);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub STRING_EXTEND_CHARS,\n     style,\n     \"using `x.extend(s.chars())` where s is a `&str` or `String`\"\n@@ -1150,6 +1187,7 @@ declare_clippy_lint! {\n     /// let s = [1, 2, 3, 4, 5];\n     /// let s2: Vec<isize> = s.to_vec();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ITER_CLONED_COLLECT,\n     style,\n     \"using `.cloned().collect()` on slice to create a `Vec`\"\n@@ -1174,6 +1212,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// name.ends_with('_') || name.ends_with('-');\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CHARS_LAST_CMP,\n     style,\n     \"using `.chars().last()` or `.chars().next_back()` to check if a string ends with a char\"\n@@ -1199,6 +1238,7 @@ declare_clippy_lint! {\n     /// let x: &[i32] = &[1, 2, 3, 4, 5];\n     /// do_stuff(x);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub USELESS_ASREF,\n     complexity,\n     \"using `as_ref` where the types before and after the call are the same\"\n@@ -1221,6 +1261,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let _ = (0..3).any(|x| x > 2);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNNECESSARY_FOLD,\n     style,\n     \"using `fold` when a more succinct alternative exists\"\n@@ -1250,6 +1291,7 @@ declare_clippy_lint! {\n     /// // As there is no conditional check on the argument this could be written as:\n     /// let _ = (0..4).map(|x| x + 1);\n     /// ```\n+    #[clippy::version = \"1.31.0\"]\n     pub UNNECESSARY_FILTER_MAP,\n     complexity,\n     \"using `filter_map` when a more succinct alternative exists\"\n@@ -1273,6 +1315,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let _ = (&vec![3, 4, 5]).iter();\n     /// ```\n+    #[clippy::version = \"1.32.0\"]\n     pub INTO_ITER_ON_REF,\n     style,\n     \"using `.into_iter()` on a reference\"\n@@ -1292,6 +1335,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let _ = (0..3).map(|x| x + 2).count();\n     /// ```\n+    #[clippy::version = \"1.39.0\"]\n     pub SUSPICIOUS_MAP,\n     suspicious,\n     \"suspicious usage of map\"\n@@ -1326,6 +1370,7 @@ declare_clippy_lint! {\n     ///     MaybeUninit::uninit().assume_init()\n     /// };\n     /// ```\n+    #[clippy::version = \"1.39.0\"]\n     pub UNINIT_ASSUMED_INIT,\n     correctness,\n     \"`MaybeUninit::uninit().assume_init()`\"\n@@ -1354,6 +1399,7 @@ declare_clippy_lint! {\n     /// let add = x.saturating_add(y);\n     /// let sub = x.saturating_sub(y);\n     /// ```\n+    #[clippy::version = \"1.39.0\"]\n     pub MANUAL_SATURATING_ARITHMETIC,\n     style,\n     \"`.chcked_add/sub(x).unwrap_or(MAX/MIN)`\"\n@@ -1371,6 +1417,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// unsafe { (&() as *const ()).offset(1) };\n     /// ```\n+    #[clippy::version = \"1.41.0\"]\n     pub ZST_OFFSET,\n     correctness,\n     \"Check for offset calculations on raw pointers to zero-sized types\"\n@@ -1412,6 +1459,7 @@ declare_clippy_lint! {\n     /// # Ok::<_, std::io::Error>(())\n     /// # };\n     /// ```\n+    #[clippy::version = \"1.42.0\"]\n     pub FILETYPE_IS_FILE,\n     restriction,\n     \"`FileType::is_file` is not recommended to test for readable file type\"\n@@ -1437,6 +1485,7 @@ declare_clippy_lint! {\n     /// opt.as_deref()\n     /// # ;\n     /// ```\n+    #[clippy::version = \"1.42.0\"]\n     pub OPTION_AS_REF_DEREF,\n     complexity,\n     \"using `as_ref().map(Deref::deref)`, which is more succinctly expressed as `as_deref()`\"\n@@ -1463,6 +1512,7 @@ declare_clippy_lint! {\n     /// a.get(2);\n     /// b.get(0);\n     /// ```\n+    #[clippy::version = \"1.46.0\"]\n     pub ITER_NEXT_SLICE,\n     style,\n     \"using `.iter().next()` on a sliced array, which can be shortened to just `.get()`\"\n@@ -1488,6 +1538,7 @@ declare_clippy_lint! {\n     /// string.insert(0, 'R');\n     /// string.push('R');\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub SINGLE_CHAR_ADD_STR,\n     style,\n     \"`push_str()` or `insert_str()` used with a single-character string literal as parameter\"\n@@ -1526,6 +1577,7 @@ declare_clippy_lint! {\n     ///\n     /// opt.unwrap_or(42);\n     /// ```\n+    #[clippy::version = \"1.48.0\"]\n     pub UNNECESSARY_LAZY_EVALUATIONS,\n     style,\n     \"using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\"\n@@ -1546,6 +1598,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// (0..3).try_for_each(|t| Err(t));\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub MAP_COLLECT_RESULT_UNIT,\n     style,\n     \"using `.map(_).collect::<Result<(),_>()`, which can be replaced with `try_for_each`\"\n@@ -1578,6 +1631,7 @@ declare_clippy_lint! {\n     ///\n     /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub FROM_ITER_INSTEAD_OF_COLLECT,\n     pedantic,\n     \"use `.collect()` instead of `::from_iter()`\"\n@@ -1607,6 +1661,7 @@ declare_clippy_lint! {\n     ///     assert!(x >= 0);\n     /// });\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub INSPECT_FOR_EACH,\n     complexity,\n     \"using `.inspect().for_each()`, which can be replaced with `.for_each()`\"\n@@ -1629,6 +1684,7 @@ declare_clippy_lint! {\n     /// # let iter = vec![Some(1)].into_iter();\n     /// iter.flatten();\n     /// ```\n+    #[clippy::version = \"1.52.0\"]\n     pub FILTER_MAP_IDENTITY,\n     complexity,\n     \"call to `filter_map` where `flatten` is sufficient\"\n@@ -1651,6 +1707,7 @@ declare_clippy_lint! {\n     /// let x = [1, 2, 3];\n     /// let y: Vec<_> = x.iter().map(|x| 2*x).collect();\n     /// ```\n+    #[clippy::version = \"1.52.0\"]\n     pub MAP_IDENTITY,\n     complexity,\n     \"using iterator.map(|x| x)\"\n@@ -1672,6 +1729,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let _ = \"Hello\".as_bytes().get(3);\n     /// ```\n+    #[clippy::version = \"1.52.0\"]\n     pub BYTES_NTH,\n     style,\n     \"replace `.bytes().nth()` with `.as_bytes().get()`\"\n@@ -1697,6 +1755,7 @@ declare_clippy_lint! {\n     /// let b = a.clone();\n     /// let c = a.clone();\n     /// ```\n+    #[clippy::version = \"1.52.0\"]\n     pub IMPLICIT_CLONE,\n     pedantic,\n     \"implicitly cloning a value by invoking a function on its dereferenced type\"\n@@ -1722,6 +1781,7 @@ declare_clippy_lint! {\n     /// let _ = some_vec.len();\n     /// let _ = &some_vec[..].len();\n     /// ```\n+    #[clippy::version = \"1.52.0\"]\n     pub ITER_COUNT,\n     complexity,\n     \"replace `.iter().count()` with `.len()`\"\n@@ -1751,6 +1811,7 @@ declare_clippy_lint! {\n     ///     // use x\n     /// }\n     /// ```\n+    #[clippy::version = \"1.54.0\"]\n     pub SUSPICIOUS_SPLITN,\n     correctness,\n     \"checks for `.splitn(0, ..)` and `.splitn(1, ..)`\"\n@@ -1771,6 +1832,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let x: String = \"x\".repeat(10);\n     /// ```\n+    #[clippy::version = \"1.54.0\"]\n     pub MANUAL_STR_REPEAT,\n     perf,\n     \"manual implementation of `str::repeat`\"\n@@ -1793,11 +1855,36 @@ declare_clippy_lint! {\n     /// let (key, value) = _.split_once('=')?;\n     /// let value = _.split_once('=')?.1;\n     /// ```\n+    #[clippy::version = \"1.57.0\"]\n     pub MANUAL_SPLIT_ONCE,\n     complexity,\n     \"replace `.splitn(2, pat)` with `.split_once(pat)`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of `str::splitn` (or `str::rsplitn`) where using `str::split` would be the same.\n+    /// ### Why is this bad?\n+    /// The function `split` is simpler and there is no performance difference in these cases, considering\n+    /// that both functions return a lazy iterator.\n+    /// ### Example\n+    /// ```rust\n+    /// // Bad\n+    /// let str = \"key=value=add\";\n+    /// let _ = str.splitn(3, '=').next().unwrap();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// // Good\n+    /// let str = \"key=value=add\";\n+    /// let _ = str.split('=').next().unwrap();\n+    /// ```\n+    #[clippy::version = \"1.58.0\"]\n+    pub NEEDLESS_SPLITN,\n+    complexity,\n+    \"usages of `str::splitn` that can be replaced with `str::split`\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -1876,7 +1963,8 @@ impl_lint_pass!(Methods => [\n     SUSPICIOUS_SPLITN,\n     MANUAL_STR_REPEAT,\n     EXTEND_WITH_DRAIN,\n-    MANUAL_SPLIT_ONCE\n+    MANUAL_SPLIT_ONCE,\n+    NEEDLESS_SPLITN\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -1900,7 +1988,7 @@ macro_rules! method_call {\n \n impl<'tcx> LateLintPass<'tcx> for Methods {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if in_macro(expr.span) {\n+        if expr.span.from_expansion() {\n             return;\n         }\n \n@@ -2116,7 +2204,9 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n             (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span, msrv),\n             (\"collect\", []) => match method_call!(recv) {\n-                Some((\"cloned\", [recv2], _)) => iter_cloned_collect::check(cx, expr, recv2),\n+                Some((name @ (\"cloned\" | \"copied\"), [recv2], _)) => {\n+                    iter_cloned_collect::check(cx, name, expr, recv2);\n+                },\n                 Some((\"map\", [m_recv, m_arg], _)) => {\n                     map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n                 },\n@@ -2208,7 +2298,10 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n                     suspicious_splitn::check(cx, name, expr, recv, count);\n                     if count == 2 && meets_msrv(msrv, &msrvs::STR_SPLIT_ONCE) {\n-                        manual_split_once::check(cx, name, expr, recv, pat_arg);\n+                        str_splitn::check_manual_split_once(cx, name, expr, recv, pat_arg);\n+                    }\n+                    if count >= 2 {\n+                        str_splitn::check_needless_splitn(cx, name, expr, recv, pat_arg, count);\n                     }\n                 }\n             },"}, {"sha": "5e5c1038e829e76ddfe9a7007f19ca54328f9412", "filename": "src/tools/clippy/clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 89, "deletions": 50, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_lang_ctor, single_segment_path};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -11,6 +11,28 @@ use rustc_span::symbol::sym;\n use super::OPTION_MAP_OR_NONE;\n use super::RESULT_MAP_OR_INTO_OPTION;\n \n+// The expression inside a closure may or may not have surrounding braces\n+// which causes problems when generating a suggestion.\n+fn reduce_unit_expression<'a>(\n+    cx: &LateContext<'_>,\n+    expr: &'a hir::Expr<'_>,\n+) -> Option<(&'a hir::Expr<'a>, &'a [hir::Expr<'a>])> {\n+    match expr.kind {\n+        hir::ExprKind::Call(func, arg_char) => Some((func, arg_char)),\n+        hir::ExprKind::Block(block, _) => {\n+            match (block.stmts, block.expr) {\n+                (&[], Some(inner_expr)) => {\n+                    // If block only contains an expression,\n+                    // reduce `|x| { x + 1 }` to `|x| x + 1`\n+                    reduce_unit_expression(cx, inner_expr)\n+                },\n+                _ => None,\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n@@ -31,58 +53,75 @@ pub(super) fn check<'tcx>(\n         return;\n     }\n \n-    let (lint_name, msg, instead, hint) = {\n-        let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n-            is_lang_ctor(cx, qpath, OptionNone)\n-        } else {\n-            return;\n-        };\n+    let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n+        is_lang_ctor(cx, qpath, OptionNone)\n+    } else {\n+        return;\n+    };\n \n-        if !default_arg_is_none {\n-            // nothing to lint!\n-            return;\n-        }\n+    if !default_arg_is_none {\n+        // nothing to lint!\n+        return;\n+    }\n \n-        let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n-            is_lang_ctor(cx, qpath, OptionSome)\n-        } else {\n-            false\n-        };\n+    let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n+        is_lang_ctor(cx, qpath, OptionSome)\n+    } else {\n+        false\n+    };\n+\n+    if is_option {\n+        let self_snippet = snippet(cx, recv.span, \"..\");\n+        if_chain! {\n+        if let hir::ExprKind::Closure(_, _, id, span, _) = map_arg.kind;\n+            let arg_snippet = snippet(cx, span, \"..\");\n+            let body = cx.tcx.hir().body(id);\n+                if let Some((func, arg_char)) = reduce_unit_expression(cx, &body.value);\n+                if arg_char.len() == 1;\n+                if let hir::ExprKind::Path(ref qpath) = func.kind;\n+                if let Some(segment) = single_segment_path(qpath);\n+                if segment.ident.name == sym::Some;\n+                then {\n+                    let func_snippet = snippet(cx, arg_char[0].span, \"..\");\n+                    let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n+                       `map(..)` instead\";\n+                    return span_lint_and_sugg(\n+                        cx,\n+                        OPTION_MAP_OR_NONE,\n+                        expr.span,\n+                        msg,\n+                        \"try using `map` instead\",\n+                        format!(\"{0}.map({1} {2})\", self_snippet, arg_snippet,func_snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n \n-        if is_option {\n-            let self_snippet = snippet(cx, recv.span, \"..\");\n-            let func_snippet = snippet(cx, map_arg.span, \"..\");\n-            let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n-                       `and_then(..)` instead\";\n-            (\n-                OPTION_MAP_OR_NONE,\n-                msg,\n-                \"try using `and_then` instead\",\n-                format!(\"{0}.and_then({1})\", self_snippet, func_snippet),\n-            )\n-        } else if f_arg_is_some {\n-            let msg = \"called `map_or(None, Some)` on a `Result` value. This can be done more directly by calling \\\n-                       `ok()` instead\";\n-            let self_snippet = snippet(cx, recv.span, \"..\");\n-            (\n-                RESULT_MAP_OR_INTO_OPTION,\n-                msg,\n-                \"try using `ok` instead\",\n-                format!(\"{0}.ok()\", self_snippet),\n-            )\n-        } else {\n-            // nothing to lint!\n-            return;\n         }\n-    };\n \n-    span_lint_and_sugg(\n-        cx,\n-        lint_name,\n-        expr.span,\n-        msg,\n-        instead,\n-        hint,\n-        Applicability::MachineApplicable,\n-    );\n+        let func_snippet = snippet(cx, map_arg.span, \"..\");\n+        let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n+                       `and_then(..)` instead\";\n+        return span_lint_and_sugg(\n+            cx,\n+            OPTION_MAP_OR_NONE,\n+            expr.span,\n+            msg,\n+            \"try using `and_then` instead\",\n+            format!(\"{0}.and_then({1})\", self_snippet, func_snippet),\n+            Applicability::MachineApplicable,\n+        );\n+    } else if f_arg_is_some {\n+        let msg = \"called `map_or(None, Some)` on a `Result` value. This can be done more directly by calling \\\n+                       `ok()` instead\";\n+        let self_snippet = snippet(cx, recv.span, \"..\");\n+        return span_lint_and_sugg(\n+            cx,\n+            RESULT_MAP_OR_INTO_OPTION,\n+            expr.span,\n+            msg,\n+            \"try using `ok` instead\",\n+            format!(\"{0}.ok()\", self_snippet),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n }"}, {"sha": "4e4653dadcafcdc1bfe926c2c9cda0a58eea697b", "filename": "src/tools/clippy/clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 22, "deletions": 37, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,16 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::eager_or_lazy::is_lazyness_candidate;\n-use clippy_utils::is_trait_item;\n+use clippy_utils::eager_or_lazy::switch_to_lazy_eval;\n use clippy_utils::source::{snippet, snippet_with_applicability, snippet_with_macro_callsite};\n-use clippy_utils::ty::implements_trait;\n-use clippy_utils::ty::{is_type_diagnostic_item, match_type};\n-use clippy_utils::{contains_return, last_path_segment, paths};\n+use clippy_utils::ty::{implements_trait, match_type};\n+use clippy_utils::{contains_return, is_trait_item, last_path_segment, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::{BlockCheckMode, UnsafeSource};\n use rustc_lint::LateContext;\n-use rustc_middle::ty;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym};\n use std::borrow::Cow;\n@@ -96,25 +92,10 @@ pub(super) fn check<'tcx>(\n             (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n         ];\n \n-        if let hir::ExprKind::MethodCall(path, _, [self_arg, ..], _) = &arg.kind {\n-            if path.ident.name == sym::len {\n-                let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n-\n-                match ty.kind() {\n-                    ty::Slice(_) | ty::Array(_, _) | ty::Str => return,\n-                    _ => (),\n-                }\n-\n-                if is_type_diagnostic_item(cx, ty, sym::Vec) {\n-                    return;\n-                }\n-            }\n-        }\n-\n         if_chain! {\n             if KNOW_TYPES.iter().any(|k| k.2.contains(&name));\n \n-            if is_lazyness_candidate(cx, arg);\n+            if switch_to_lazy_eval(cx, arg);\n             if !contains_return(arg);\n \n             let self_ty = cx.typeck_results().expr_ty(self_expr);\n@@ -166,26 +147,30 @@ pub(super) fn check<'tcx>(\n         }\n     }\n \n-    if args.len() == 2 {\n-        match args[1].kind {\n+    if let [self_arg, arg] = args {\n+        let inner_arg = if let hir::ExprKind::Block(\n+            hir::Block {\n+                stmts: [],\n+                expr: Some(expr),\n+                ..\n+            },\n+            _,\n+        ) = arg.kind\n+        {\n+            expr\n+        } else {\n+            arg\n+        };\n+        match inner_arg.kind {\n             hir::ExprKind::Call(fun, or_args) => {\n                 let or_has_args = !or_args.is_empty();\n-                if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n+                if !check_unwrap_or_default(cx, name, fun, self_arg, arg, or_has_args, expr.span) {\n                     let fun_span = if or_has_args { None } else { Some(fun.span) };\n-                    check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, fun_span);\n+                    check_general_case(cx, name, method_span, self_arg, arg, expr.span, fun_span);\n                 }\n             },\n             hir::ExprKind::Index(..) | hir::ExprKind::MethodCall(..) => {\n-                check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, None);\n-            },\n-            hir::ExprKind::Block(block, _)\n-                if block.rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided) =>\n-            {\n-                if let Some(block_expr) = block.expr {\n-                    if let hir::ExprKind::MethodCall(..) = block_expr.kind {\n-                        check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, None);\n-                    }\n-                }\n+                check_general_case(cx, name, method_span, self_arg, arg, expr.span, None);\n             },\n             _ => (),\n         }"}, {"sha": "5ed4ba94884e26b627874b7253608150eca9a0a9", "filename": "src/tools/clippy/clippy_lints/src/methods/search_is_some.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n+use clippy_utils::sugg::deref_closure_args;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{is_trait_method, strip_pat_refs};\n use if_chain::if_chain;\n@@ -37,6 +38,7 @@ pub(super) fn check<'tcx>(\n         if search_snippet.lines().count() <= 1 {\n             // suggest `any(|x| ..)` instead of `any(|&x| ..)` for `find(|&x| ..).is_some()`\n             // suggest `any(|..| *..)` instead of `any(|..| **..)` for `find(|..| **..).is_some()`\n+            let mut applicability = Applicability::MachineApplicable;\n             let any_search_snippet = if_chain! {\n                 if search_method == \"find\";\n                 if let hir::ExprKind::Closure(_, _, body_id, ..) = search_arg.kind;\n@@ -45,9 +47,15 @@ pub(super) fn check<'tcx>(\n                 then {\n                     if let hir::PatKind::Ref(..) = closure_arg.pat.kind {\n                         Some(search_snippet.replacen('&', \"\", 1))\n-                    } else if let PatKind::Binding(_, _, ident, _) = strip_pat_refs(closure_arg.pat).kind {\n-                        let name = &*ident.name.as_str();\n-                        Some(search_snippet.replace(&format!(\"*{}\", name), name))\n+                    } else if let PatKind::Binding(..) = strip_pat_refs(closure_arg.pat).kind {\n+                        // `find()` provides a reference to the item, but `any` does not,\n+                        // so we should fix item usages for suggestion\n+                        if let Some(closure_sugg) = deref_closure_args(cx, search_arg) {\n+                            applicability = closure_sugg.applicability;\n+                            Some(closure_sugg.suggestion)\n+                        } else {\n+                            Some(search_snippet.to_string())\n+                        }\n                     } else {\n                         None\n                     }\n@@ -67,7 +75,7 @@ pub(super) fn check<'tcx>(\n                         \"any({})\",\n                         any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n                     ),\n-                    Applicability::MachineApplicable,\n+                    applicability,\n                 );\n             } else {\n                 let iter = snippet(cx, search_recv.span, \"..\");\n@@ -82,7 +90,7 @@ pub(super) fn check<'tcx>(\n                         iter,\n                         any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n                     ),\n-                    Applicability::MachineApplicable,\n+                    applicability,\n                 );\n             }\n         } else {"}, {"sha": "bf9006c690621031f1056c6ee0ac8efb45577d39", "filename": "src/tools/clippy/clippy_lints/src/methods/single_char_pattern.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -9,18 +9,21 @@ use rustc_span::symbol::Symbol;\n \n use super::SINGLE_CHAR_PATTERN;\n \n-const PATTERN_METHODS: [(&str, usize); 19] = [\n+const PATTERN_METHODS: [(&str, usize); 24] = [\n     (\"contains\", 1),\n     (\"starts_with\", 1),\n     (\"ends_with\", 1),\n     (\"find\", 1),\n     (\"rfind\", 1),\n     (\"split\", 1),\n+    (\"split_inclusive\", 1),\n     (\"rsplit\", 1),\n     (\"split_terminator\", 1),\n     (\"rsplit_terminator\", 1),\n     (\"splitn\", 2),\n     (\"rsplitn\", 2),\n+    (\"split_once\", 1),\n+    (\"rsplit_once\", 1),\n     (\"matches\", 1),\n     (\"rmatches\", 1),\n     (\"match_indices\", 1),\n@@ -29,6 +32,8 @@ const PATTERN_METHODS: [(&str, usize); 19] = [\n     (\"strip_suffix\", 1),\n     (\"trim_start_matches\", 1),\n     (\"trim_end_matches\", 1),\n+    (\"replace\", 1),\n+    (\"replacen\", 1),\n ];\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`"}, {"sha": "2595f734f1151acddcfca4b985fbfc5451ec1c2e", "filename": "src/tools/clippy/clippy_lints/src/methods/str_splitn.rs", "status": "renamed", "additions": 131, "deletions": 19, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -11,7 +11,13 @@ use rustc_span::{symbol::sym, Span, SyntaxContext};\n \n use super::MANUAL_SPLIT_ONCE;\n \n-pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, self_arg: &Expr<'_>, pat_arg: &Expr<'_>) {\n+pub(super) fn check_manual_split_once(\n+    cx: &LateContext<'_>,\n+    method_name: &str,\n+    expr: &Expr<'_>,\n+    self_arg: &Expr<'_>,\n+    pat_arg: &Expr<'_>,\n+) {\n     if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n         return;\n     }\n@@ -36,7 +42,7 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n             format!(\"{}.{}({})\", self_snip, method_name, pat_snip)\n         },\n         IterUsageKind::RNextTuple => format!(\"{}.{}({}).map(|(x, y)| (y, x))\", self_snip, method_name, pat_snip),\n-        IterUsageKind::Next => {\n+        IterUsageKind::Next | IterUsageKind::Second => {\n             let self_deref = {\n                 let adjust = cx.typeck_results().expr_adjustments(self_arg);\n                 if adjust.is_empty() {\n@@ -51,26 +57,49 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n                     \"*\".repeat(adjust.len() - 2)\n                 }\n             };\n-            if usage.unwrap_kind.is_some() {\n-                format!(\n-                    \"{}.{}({}).map_or({}{}, |x| x.0)\",\n-                    &self_snip, method_name, pat_snip, self_deref, &self_snip\n-                )\n+            if matches!(usage.kind, IterUsageKind::Next) {\n+                match usage.unwrap_kind {\n+                    Some(UnwrapKind::Unwrap) => {\n+                        if reverse {\n+                            format!(\"{}.{}({}).unwrap().0\", self_snip, method_name, pat_snip)\n+                        } else {\n+                            format!(\n+                                \"{}.{}({}).map_or({}{}, |x| x.0)\",\n+                                self_snip, method_name, pat_snip, self_deref, &self_snip\n+                            )\n+                        }\n+                    },\n+                    Some(UnwrapKind::QuestionMark) => {\n+                        format!(\n+                            \"{}.{}({}).map_or({}{}, |x| x.0)\",\n+                            self_snip, method_name, pat_snip, self_deref, &self_snip\n+                        )\n+                    },\n+                    None => {\n+                        format!(\n+                            \"Some({}.{}({}).map_or({}{}, |x| x.0))\",\n+                            &self_snip, method_name, pat_snip, self_deref, &self_snip\n+                        )\n+                    },\n+                }\n             } else {\n-                format!(\n-                    \"Some({}.{}({}).map_or({}{}, |x| x.0))\",\n-                    &self_snip, method_name, pat_snip, self_deref, &self_snip\n-                )\n+                match usage.unwrap_kind {\n+                    Some(UnwrapKind::Unwrap) => {\n+                        if reverse {\n+                            // In this case, no better suggestion is offered.\n+                            return;\n+                        }\n+                        format!(\"{}.{}({}).unwrap().1\", self_snip, method_name, pat_snip)\n+                    },\n+                    Some(UnwrapKind::QuestionMark) => {\n+                        format!(\"{}.{}({})?.1\", self_snip, method_name, pat_snip)\n+                    },\n+                    None => {\n+                        format!(\"{}.{}({}).map(|x| x.1)\", self_snip, method_name, pat_snip)\n+                    },\n+                }\n             }\n         },\n-        IterUsageKind::Second => {\n-            let access_str = match usage.unwrap_kind {\n-                Some(UnwrapKind::Unwrap) => \".unwrap().1\",\n-                Some(UnwrapKind::QuestionMark) => \"?.1\",\n-                None => \".map(|x| x.1)\",\n-            };\n-            format!(\"{}.{}({}){}\", self_snip, method_name, pat_snip, access_str)\n-        },\n     };\n \n     span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n@@ -209,3 +238,86 @@ fn parse_iter_usage(\n         span,\n     })\n }\n+\n+use super::NEEDLESS_SPLITN;\n+\n+pub(super) fn check_needless_splitn(\n+    cx: &LateContext<'_>,\n+    method_name: &str,\n+    expr: &Expr<'_>,\n+    self_arg: &Expr<'_>,\n+    pat_arg: &Expr<'_>,\n+    count: u128,\n+) {\n+    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n+        return;\n+    }\n+    let ctxt = expr.span.ctxt();\n+    let mut app = Applicability::MachineApplicable;\n+    let (reverse, message) = if method_name == \"splitn\" {\n+        (false, \"unnecessary use of `splitn`\")\n+    } else {\n+        (true, \"unnecessary use of `rsplitn`\")\n+    };\n+    if_chain! {\n+        if count >= 2;\n+        if check_iter(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id), count);\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                NEEDLESS_SPLITN,\n+                expr.span,\n+                message,\n+                \"try this\",\n+                format!(\n+                    \"{}.{}({})\",\n+                    snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0,\n+                    if reverse {\"rsplit\"} else {\"split\"},\n+                    snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0\n+                ),\n+                app,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_iter(\n+    cx: &LateContext<'tcx>,\n+    ctxt: SyntaxContext,\n+    mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n+    count: u128,\n+) -> bool {\n+    match iter.next() {\n+        Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n+            let (name, args) = if let ExprKind::MethodCall(name, _, [_, args @ ..], _) = e.kind {\n+                (name, args)\n+            } else {\n+                return false;\n+            };\n+            if_chain! {\n+                if let Some(did) = cx.typeck_results().type_dependent_def_id(e.hir_id);\n+                if let Some(iter_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+                then {\n+                    match (&*name.ident.as_str(), args) {\n+                        (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n+                            return true;\n+                        },\n+                        (\"next_tuple\", []) if count > 2 => {\n+                            return true;\n+                        },\n+                        (\"nth\", [idx_expr]) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n+                            if let Some((Constant::Int(idx), _)) = constant(cx, cx.typeck_results(), idx_expr) {\n+                                if count > idx + 1 {\n+                                    return true;\n+                                }\n+                            }\n+                        },\n+                        _ =>  return false,\n+                    }\n+                }\n+            }\n+        },\n+        _ => return false,\n+    };\n+    false\n+}", "previous_filename": "src/tools/clippy/clippy_lints/src/methods/manual_split_once.rs"}, {"sha": "1e2765263c87ddb0ed920c8da8a71b74394ee0b3", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check<'tcx>(\n                 return;\n             }\n \n-            if eager_or_lazy::is_eagerness_candidate(cx, body_expr) {\n+            if eager_or_lazy::switch_to_eager_eval(cx, body_expr) {\n                 let msg = if is_option {\n                     \"unnecessary closure used to substitute value for `Option::None`\"\n                 } else {"}, {"sha": "11ad881ee7b95bf1d29b58b89111e85a58b575b7", "filename": "src/tools/clippy/clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -66,7 +66,13 @@ pub(super) fn get_hint_if_single_char_arg(\n                 // for regular string: \"a\"\n                 &snip[1..(snip.len() - 1)]\n             };\n-            let hint = format!(\"'{}'\", if ch == \"'\" { \"\\\\'\" } else { ch });\n+\n+            let hint = format!(\"'{}'\", match ch {\n+                \"'\" => \"\\\\'\" ,\n+                r\"\\\" => \"\\\\\\\\\",\n+                _ => ch,\n+            });\n+\n             Some(hint)\n         } else {\n             None"}, {"sha": "a6450aec4f7d46f4e108fbafa953058c741f17f8", "filename": "src/tools/clippy/clippy_lints/src/minmax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -26,6 +26,7 @@ declare_clippy_lint! {\n     /// ```\n     /// It will always be equal to `0`. Probably the author meant to clamp the value\n     /// between 0 and 100, but has erroneously swapped `min` and `max`.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MIN_MAX,\n     correctness,\n     \"`min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\""}, {"sha": "2299a09991091a60914bdb32cebe8cf752efeb2e", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -56,6 +56,7 @@ declare_clippy_lint! {\n     ///     true\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub TOPLEVEL_REF_ARG,\n     style,\n     \"an entire binding declared as `ref`, in a function argument or a `let` statement\"\n@@ -79,6 +80,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// if x.is_nan() { }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CMP_NAN,\n     correctness,\n     \"comparisons to `NAN`, which will always return false, probably not intended\"\n@@ -112,6 +114,7 @@ declare_clippy_lint! {\n     /// if (y - 1.23f64).abs() < error_margin { }\n     /// if (y - x).abs() > error_margin { }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub FLOAT_CMP,\n     pedantic,\n     \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n@@ -139,6 +142,7 @@ declare_clippy_lint! {\n     /// # let y = String::from(\"foo\");\n     /// if x == y {}\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CMP_OWNED,\n     perf,\n     \"creating owned instances for comparing with others, e.g., `x == \\\"foo\\\".to_string()`\"\n@@ -162,6 +166,7 @@ declare_clippy_lint! {\n     /// let a = x % 1;\n     /// let a = x % -1;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MODULO_ONE,\n     correctness,\n     \"taking a number modulo +/-1, which can either panic/overflow or always returns 0\"\n@@ -187,6 +192,7 @@ declare_clippy_lint! {\n     /// let y = _x + 1; // Here we are using `_x`, even though it has a leading\n     ///                 // underscore. We should rename `_x` to `x`\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub USED_UNDERSCORE_BINDING,\n     pedantic,\n     \"using a binding which is prefixed with an underscore\"\n@@ -207,6 +213,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// f() && g(); // We should write `if f() { g(); }`.\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SHORT_CIRCUIT_STATEMENT,\n     complexity,\n     \"using a short circuit boolean condition as a statement\"\n@@ -228,6 +235,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let a = std::ptr::null::<u32>();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ZERO_PTR,\n     style,\n     \"using `0 as *{const, mut} T`\"\n@@ -259,6 +267,7 @@ declare_clippy_lint! {\n     /// // let error_margin = std::f64::EPSILON;\n     /// if (x - ONE).abs() < error_margin { }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub FLOAT_CMP_CONST,\n     restriction,\n     \"using `==` or `!=` on float constants instead of comparing difference with an epsilon\""}, {"sha": "6e09e25109fbb31e72fc77d87e5ad488c2fde580", "filename": "src/tools/clippy/clippy_lints/src/misc_early/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -46,6 +46,7 @@ declare_clippy_lint! {\n     ///     Foo { .. } => {},\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNNEEDED_FIELD_PATTERN,\n     restriction,\n     \"struct fields bound to a wildcard instead of using `..`\"\n@@ -67,6 +68,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// fn bar(a: i32, _b: i32) {}\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DUPLICATE_UNDERSCORE_ARGUMENT,\n     style,\n     \"function arguments having names which only differ by an underscore\"\n@@ -85,6 +87,7 @@ declare_clippy_lint! {\n     /// let mut x = 3;\n     /// --x;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DOUBLE_NEG,\n     style,\n     \"`--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\"\n@@ -106,6 +109,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let y = 0x1A9BACD;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MIXED_CASE_HEX_LITERALS,\n     style,\n     \"hex literals whose letter digits are not consistently upper- or lowercased\"\n@@ -129,6 +133,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let y = 123832_i32;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNSEPARATED_LITERAL_SUFFIX,\n     restriction,\n     \"literals whose suffix is not separated by an underscore\"\n@@ -151,6 +156,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let y = 123832i32;\n     /// ```\n+    #[clippy::version = \"1.58.0\"]\n     pub SEPARATED_LITERAL_SUFFIX,\n     restriction,\n     \"literals whose suffix is separated by an underscore\"\n@@ -189,6 +195,7 @@ declare_clippy_lint! {\n     /// ```\n     ///\n     /// prints `83` (as `83 == 0o123` while `123 == 0o173`).\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ZERO_PREFIXED_LITERAL,\n     complexity,\n     \"integer literals starting with `0`\"\n@@ -210,6 +217,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub BUILTIN_TYPE_SHADOW,\n     style,\n     \"shadowing a builtin type\"\n@@ -239,6 +247,7 @@ declare_clippy_lint! {\n     ///     y => (),\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub REDUNDANT_PATTERN,\n     style,\n     \"using `name @ _` in a pattern\"\n@@ -273,6 +282,7 @@ declare_clippy_lint! {\n     ///     _ => (),\n     /// }\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub UNNEEDED_WILDCARD_PATTERN,\n     complexity,\n     \"tuple patterns with a wildcard pattern (`_`) is next to a rest pattern (`..`)\""}, {"sha": "a8d410508563c72092cfaa587c014863353ba979", "filename": "src/tools/clippy/clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -63,6 +63,7 @@ declare_clippy_lint! {\n     /// }\n     /// # }\n     /// ```\n+    #[clippy::version = \"1.34.0\"]\n     pub MISSING_CONST_FOR_FN,\n     nursery,\n     \"Lint functions definitions that could be made `const fn`\""}, {"sha": "fc0483a929a7a1e93c3cded4003f6b2835ec2985", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -26,6 +26,7 @@ declare_clippy_lint! {\n     /// allowed-by-default lint for\n     /// public members, but has no way to enforce documentation of private items.\n     /// This lint fixes that.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MISSING_DOCS_IN_PRIVATE_ITEMS,\n     restriction,\n     \"detects missing documentation for public and private members\""}, {"sha": "68d49e0f1503116b21341b0e248d0f5e5444b901", "filename": "src/tools/clippy/clippy_lints/src/missing_enforced_import_rename.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -33,6 +33,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// use serde_json::Value as JsonValue;\n     /// ```\n+    #[clippy::version = \"1.55.0\"]\n     pub MISSING_ENFORCED_IMPORT_RENAMES,\n     restriction,\n     \"enforce import renames\""}, {"sha": "ac2f16b49e3f1cd3fc3bc560b8aac36d268735da", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -52,6 +52,7 @@ declare_clippy_lint! {\n     ///    fn def_bar() {} // missing #[inline]\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MISSING_INLINE_IN_PUBLIC_ITEMS,\n     restriction,\n     \"detects missing `#[inline]` attribute for public callables (functions, trait methods, methods...)\""}, {"sha": "3b65f80cba20aeb057459af04949401b6069d318", "filename": "src/tools/clippy/clippy_lints/src/module_style.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodule_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodule_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodule_style.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -32,6 +32,7 @@ declare_clippy_lint! {\n     ///   stuff.rs\n     ///   lib.rs\n     /// ```\n+    #[clippy::version = \"1.57.0\"]\n     pub MOD_MODULE_FILES,\n     restriction,\n     \"checks that module layout is consistent\"\n@@ -61,6 +62,7 @@ declare_clippy_lint! {\n     ///   lib.rs\n     /// ```\n \n+    #[clippy::version = \"1.57.0\"]\n     pub SELF_NAMED_MODULE_FILES,\n     restriction,\n     \"checks that module layout is consistent\""}, {"sha": "d182a7d52497d45fd59cf8d367f8e84e207d3e10", "filename": "src/tools/clippy/clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -24,6 +24,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let x = -17 % 3;\n     /// ```\n+    #[clippy::version = \"1.42.0\"]\n     pub MODULO_ARITHMETIC,\n     restriction,\n     \"any modulo arithmetic statement\""}, {"sha": "e45cc86d417ac09aa103c518fabb0ec66f6c9880", "filename": "src/tools/clippy/clippy_lints/src/multiple_crate_versions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -33,6 +33,7 @@ declare_clippy_lint! {\n     /// ctrlc = \"=3.1.0\"\n     /// ansi_term = \"=0.11.0\"\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MULTIPLE_CRATE_VERSIONS,\n     cargo,\n     \"multiple versions of the same crate being used\""}, {"sha": "5fe887a4573cccb99b283dab4af6b5e969e9cc1a", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -72,6 +72,7 @@ declare_clippy_lint! {\n     ///     let _: HashSet<Bad> = HashSet::new();\n     /// }\n     /// ```\n+    #[clippy::version = \"1.42.0\"]\n     pub MUTABLE_KEY_TYPE,\n     suspicious,\n     \"Check for mutable `Map`/`Set` key type\""}, {"sha": "bcbea8f1e66b47edadc368481dc4a50584b48597", "filename": "src/tools/clippy/clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -22,6 +22,7 @@ declare_clippy_lint! {\n     /// # let mut y = 1;\n     /// let x = &mut &mut y;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MUT_MUT,\n     pedantic,\n     \"usage of double-mut refs, e.g., `&mut &mut ...`\""}, {"sha": "b1e6308d2e1a006ff7d33a7e2ce27c607cf67454", "filename": "src/tools/clippy/clippy_lints/src/mut_mutex_lock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -38,6 +38,7 @@ declare_clippy_lint! {\n     /// let value = value_mutex.get_mut().unwrap();\n     /// *value += 1;\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub MUT_MUTEX_LOCK,\n     style,\n     \"`&mut Mutex::lock` does unnecessary locking\""}, {"sha": "63a1cf7b7d5bd8492c1fe91da435e106a88d293d", "filename": "src/tools/clippy/clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -23,6 +23,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// my_vec.push(&value)\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNNECESSARY_MUT_PASSED,\n     style,\n     \"an argument passed as a mutable reference although the callee only demands an immutable reference\""}, {"sha": "12e219cd5c8714318c166726acae0c659bb6c32c", "filename": "src/tools/clippy/clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -26,6 +26,7 @@ declare_clippy_lint! {\n     /// fn take_a_mut_parameter(_: &mut u32) -> bool { unimplemented!() }\n     /// debug_assert!(take_a_mut_parameter(&mut 5));\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub DEBUG_ASSERT_WITH_MUT_CALL,\n     nursery,\n     \"mutable arguments in `debug_assert{,_ne,_eq}!`\""}, {"sha": "816377fe65e9f31e61b5458784af40267abd46cc", "filename": "src/tools/clippy/clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -36,6 +36,7 @@ declare_clippy_lint! {\n     /// # use std::sync::atomic::AtomicBool;\n     /// let x = AtomicBool::new(y);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MUTEX_ATOMIC,\n     perf,\n     \"using a mutex where an atomic value could be used instead\"\n@@ -64,6 +65,7 @@ declare_clippy_lint! {\n     /// # use std::sync::atomic::AtomicUsize;\n     /// let x = AtomicUsize::new(0usize);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MUTEX_INTEGER,\n     nursery,\n     \"using a mutex for an integer type\""}, {"sha": "9838d3cad9f02d537732033a0435ffa73281ea1f", "filename": "src/tools/clippy/clippy_lints/src/needless_arbitrary_self_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::in_macro;\n use if_chain::if_chain;\n use rustc_ast::ast::{BindingMode, Lifetime, Mutability, Param, PatKind, Path, TyKind};\n use rustc_errors::Applicability;\n@@ -53,6 +52,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.47.0\"]\n     pub NEEDLESS_ARBITRARY_SELF_TYPE,\n     complexity,\n     \"type of `self` parameter is already by default `Self`\"\n@@ -78,7 +78,7 @@ fn check_param_inner(cx: &EarlyContext<'_>, path: &Path, span: Span, binding_mod\n             let self_param = match (binding_mode, mutbl) {\n                 (Mode::Ref(None), Mutability::Mut) => \"&mut self\".to_string(),\n                 (Mode::Ref(Some(lifetime)), Mutability::Mut) => {\n-                    if in_macro(lifetime.ident.span) {\n+                    if lifetime.ident.span.from_expansion() {\n                         applicability = Applicability::HasPlaceholders;\n                         \"&'_ mut self\".to_string()\n                     } else {\n@@ -87,7 +87,7 @@ fn check_param_inner(cx: &EarlyContext<'_>, path: &Path, span: Span, binding_mod\n                 },\n                 (Mode::Ref(None), Mutability::Not) => \"&self\".to_string(),\n                 (Mode::Ref(Some(lifetime)), Mutability::Not) => {\n-                    if in_macro(lifetime.ident.span) {\n+                    if lifetime.ident.span.from_expansion() {\n                         applicability = Applicability::HasPlaceholders;\n                         \"&'_ self\".to_string()\n                     } else {\n@@ -114,7 +114,7 @@ fn check_param_inner(cx: &EarlyContext<'_>, path: &Path, span: Span, binding_mod\n impl EarlyLintPass for NeedlessArbitrarySelfType {\n     fn check_param(&mut self, cx: &EarlyContext<'_>, p: &Param) {\n         // Bail out if the parameter it's not a receiver or was not written by the user\n-        if !p.is_self() || in_macro(p.span) {\n+        if !p.is_self() || p.span.from_expansion() {\n             return;\n         }\n "}, {"sha": "a8a8d174a823e309f088517808464b9a6d8ad4d8", "filename": "src/tools/clippy/clippy_lints/src/needless_bitwise_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::in_macro;\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -31,6 +30,7 @@ declare_clippy_lint! {\n     /// let (x,y) = (true, false);\n     /// if x && !y {}\n     /// ```\n+    #[clippy::version = \"1.54.0\"]\n     pub NEEDLESS_BITWISE_BOOL,\n     pedantic,\n     \"Boolean expressions that use bitwise rather than lazy operators\"\n@@ -41,7 +41,7 @@ declare_lint_pass!(NeedlessBitwiseBool => [NEEDLESS_BITWISE_BOOL]);\n fn is_bitwise_operation(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n     if_chain! {\n-        if !in_macro(expr.span);\n+        if !expr.span.from_expansion();\n         if let (&ExprKind::Binary(ref op, _, right), &ty::Bool) = (&expr.kind, &ty.kind());\n         if op.node == BinOpKind::BitAnd || op.node == BinOpKind::BitOr;\n         if let ExprKind::Call(..) | ExprKind::MethodCall(..) | ExprKind::Binary(..) | ExprKind::Unary(..) = right.kind;"}, {"sha": "3709f3948c2b5f541295eaeaa074d8595aed9256", "filename": "src/tools/clippy/clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -41,6 +41,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// !x\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEEDLESS_BOOL,\n     complexity,\n     \"if-statements with plain booleans in the then- and else-clause, e.g., `if p { true } else { false }`\"\n@@ -65,6 +66,7 @@ declare_clippy_lint! {\n     /// if x {}\n     /// if !y {}\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub BOOL_COMPARISON,\n     complexity,\n     \"comparing a variable to a boolean, e.g., `if x == true` or `if x != true`\""}, {"sha": "f1be90c44f98b998901e0f4b2462722466c99d69", "filename": "src/tools/clippy/clippy_lints/src/needless_borrow.rs", "status": "removed", "additions": 0, "deletions": 282, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=ba9fc4fbfe1ea33271d68c2ee6bd8f5a54197a75", "patch": "@@ -1,282 +0,0 @@\n-//! Checks for needless address of operations (`&`)\n-//!\n-//! This lint is **warn** by default\n-\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::{snippet_opt, snippet_with_applicability, snippet_with_context};\n-use clippy_utils::{get_parent_expr, in_macro, path_to_local};\n-use if_chain::if_chain;\n-use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_data_structures::fx::FxIndexMap;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, Body, BodyId, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, UnOp};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for address of operations (`&`) that are going to\n-    /// be dereferenced immediately by the compiler.\n-    ///\n-    /// ### Why is this bad?\n-    /// Suggests that the receiver of the expression borrows\n-    /// the expression.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// fn fun(_a: &i32) {}\n-    ///\n-    /// // Bad\n-    /// let x: &i32 = &&&&&&5;\n-    /// fun(&x);\n-    ///\n-    /// // Good\n-    /// let x: &i32 = &5;\n-    /// fun(x);\n-    /// ```\n-    pub NEEDLESS_BORROW,\n-    style,\n-    \"taking a reference that is going to be automatically dereferenced\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `ref` bindings which create a reference to a reference.\n-    ///\n-    /// ### Why is this bad?\n-    /// The address-of operator at the use site is clearer about the need for a reference.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// // Bad\n-    /// let x = Some(\"\");\n-    /// if let Some(ref x) = x {\n-    ///     // use `x` here\n-    /// }\n-    ///\n-    /// // Good\n-    /// let x = Some(\"\");\n-    /// if let Some(x) = x {\n-    ///     // use `&x` here\n-    /// }\n-    /// ```\n-    pub REF_BINDING_TO_REFERENCE,\n-    pedantic,\n-    \"`ref` binding to a reference\"\n-}\n-\n-impl_lint_pass!(NeedlessBorrow => [NEEDLESS_BORROW, REF_BINDING_TO_REFERENCE]);\n-#[derive(Default)]\n-pub struct NeedlessBorrow {\n-    /// The body the first local was found in. Used to emit lints when the traversal of the body has\n-    /// been finished. Note we can't lint at the end of every body as they can be nested within each\n-    /// other.\n-    current_body: Option<BodyId>,\n-    /// The list of locals currently being checked by the lint.\n-    /// If the value is `None`, then the binding has been seen as a ref pattern, but is not linted.\n-    /// This is needed for or patterns where one of the branches can be linted, but another can not\n-    /// be.\n-    ///\n-    /// e.g. `m!(x) | Foo::Bar(ref x)`\n-    ref_locals: FxIndexMap<HirId, Option<RefPat>>,\n-}\n-\n-struct RefPat {\n-    /// Whether every usage of the binding is dereferenced.\n-    always_deref: bool,\n-    /// The spans of all the ref bindings for this local.\n-    spans: Vec<Span>,\n-    /// The applicability of this suggestion.\n-    app: Applicability,\n-    /// All the replacements which need to be made.\n-    replacements: Vec<(Span, String)>,\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let Some(local) = path_to_local(e) {\n-            self.check_local_usage(cx, e, local);\n-        }\n-\n-        if e.span.from_expansion() {\n-            return;\n-        }\n-        if let ExprKind::AddrOf(BorrowKind::Ref, mutability, inner) = e.kind {\n-            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty(inner).kind() {\n-                for adj3 in cx.typeck_results().expr_adjustments(e).windows(3) {\n-                    if let [\n-                        Adjustment {\n-                            kind: Adjust::Deref(_), ..\n-                        },\n-                        Adjustment {\n-                            kind: Adjust::Deref(_), ..\n-                        },\n-                        Adjustment {\n-                            kind: Adjust::Borrow(_),\n-                            ..\n-                        },\n-                    ] = *adj3\n-                    {\n-                        let help_msg_ty = if matches!(mutability, Mutability::Not) {\n-                            format!(\"&{}\", ty)\n-                        } else {\n-                            format!(\"&mut {}\", ty)\n-                        };\n-\n-                        span_lint_and_then(\n-                            cx,\n-                            NEEDLESS_BORROW,\n-                            e.span,\n-                            &format!(\n-                                \"this expression borrows a reference (`{}`) that is immediately dereferenced \\\n-                             by the compiler\",\n-                                help_msg_ty\n-                            ),\n-                            |diag| {\n-                                if let Some(snippet) = snippet_opt(cx, inner.span) {\n-                                    diag.span_suggestion(\n-                                        e.span,\n-                                        \"change this to\",\n-                                        snippet,\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                            },\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n-        if let PatKind::Binding(BindingAnnotation::Ref, id, name, _) = pat.kind {\n-            if let Some(opt_prev_pat) = self.ref_locals.get_mut(&id) {\n-                // This binding id has been seen before. Add this pattern to the list of changes.\n-                if let Some(prev_pat) = opt_prev_pat {\n-                    if in_macro(pat.span) {\n-                        // Doesn't match the context of the previous pattern. Can't lint here.\n-                        *opt_prev_pat = None;\n-                    } else {\n-                        prev_pat.spans.push(pat.span);\n-                        prev_pat.replacements.push((\n-                            pat.span,\n-                            snippet_with_context(cx, name.span, pat.span.ctxt(), \"..\", &mut prev_pat.app)\n-                                .0\n-                                .into(),\n-                        ));\n-                    }\n-                }\n-                return;\n-            }\n-\n-            if_chain! {\n-                if !in_macro(pat.span);\n-                if let ty::Ref(_, tam, _) = *cx.typeck_results().pat_ty(pat).kind();\n-                // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n-                if let ty::Ref(_, _, Mutability::Not) = *tam.kind();\n-                then {\n-                    let mut app = Applicability::MachineApplicable;\n-                    let snip = snippet_with_context(cx, name.span, pat.span.ctxt(), \"..\", &mut app).0;\n-                    self.current_body = self.current_body.or(cx.enclosing_body);\n-                    self.ref_locals.insert(\n-                        id,\n-                        Some(RefPat {\n-                            always_deref: true,\n-                            spans: vec![pat.span],\n-                            app,\n-                            replacements: vec![(pat.span, snip.into())],\n-                        }),\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_body_post(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n-        if Some(body.id()) == self.current_body {\n-            for pat in self.ref_locals.drain(..).filter_map(|(_, x)| x) {\n-                let replacements = pat.replacements;\n-                let app = pat.app;\n-                span_lint_and_then(\n-                    cx,\n-                    if pat.always_deref {\n-                        NEEDLESS_BORROW\n-                    } else {\n-                        REF_BINDING_TO_REFERENCE\n-                    },\n-                    pat.spans,\n-                    \"this pattern creates a reference to a reference\",\n-                    |diag| {\n-                        diag.multipart_suggestion(\"try this\", replacements, app);\n-                    },\n-                );\n-            }\n-            self.current_body = None;\n-        }\n-    }\n-}\n-impl NeedlessBorrow {\n-    fn check_local_usage(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, local: HirId) {\n-        if let Some(outer_pat) = self.ref_locals.get_mut(&local) {\n-            if let Some(pat) = outer_pat {\n-                // Check for auto-deref\n-                if !matches!(\n-                    cx.typeck_results().expr_adjustments(e),\n-                    [\n-                        Adjustment {\n-                            kind: Adjust::Deref(_),\n-                            ..\n-                        },\n-                        Adjustment {\n-                            kind: Adjust::Deref(_),\n-                            ..\n-                        },\n-                        ..\n-                    ]\n-                ) {\n-                    match get_parent_expr(cx, e) {\n-                        // Field accesses are the same no matter the number of references.\n-                        Some(Expr {\n-                            kind: ExprKind::Field(..),\n-                            ..\n-                        }) => (),\n-                        Some(&Expr {\n-                            span,\n-                            kind: ExprKind::Unary(UnOp::Deref, _),\n-                            ..\n-                        }) if !in_macro(span) => {\n-                            // Remove explicit deref.\n-                            let snip = snippet_with_context(cx, e.span, span.ctxt(), \"..\", &mut pat.app).0;\n-                            pat.replacements.push((span, snip.into()));\n-                        },\n-                        Some(parent) if !in_macro(parent.span) => {\n-                            // Double reference might be needed at this point.\n-                            if parent.precedence().order() == PREC_POSTFIX {\n-                                // Parentheses would be needed here, don't lint.\n-                                *outer_pat = None;\n-                            } else {\n-                                pat.always_deref = false;\n-                                let snip = snippet_with_context(cx, e.span, parent.span.ctxt(), \"..\", &mut pat.app).0;\n-                                pat.replacements.push((e.span, format!(\"&{}\", snip)));\n-                            }\n-                        },\n-                        _ if !in_macro(e.span) => {\n-                            // Double reference might be needed at this point.\n-                            pat.always_deref = false;\n-                            let snip = snippet_with_applicability(cx, e.span, \"..\", &mut pat.app);\n-                            pat.replacements.push((e.span, format!(\"&{}\", snip)));\n-                        },\n-                        // Edge case for macros. The span of the identifier will usually match the context of the\n-                        // binding, but not if the identifier was created in a macro. e.g. `concat_idents` and proc\n-                        // macros\n-                        _ => *outer_pat = None,\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "0fcc419e722272b3afccf433f60f3afb07974436", "filename": "src/tools/clippy/clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -38,6 +38,7 @@ declare_clippy_lint! {\n     /// let mut v = Vec::<String>::new();\n     /// let _ = v.iter_mut().filter(|a| a.is_empty());\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEEDLESS_BORROWED_REFERENCE,\n     complexity,\n     \"destructuring a reference and borrowing the inner value\""}, {"sha": "98a3bce1ff38a1e9d107b54d8f725af240156c9a", "filename": "src/tools/clippy/clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -110,6 +110,7 @@ declare_clippy_lint! {\n     ///     # break;\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEEDLESS_CONTINUE,\n     pedantic,\n     \"`continue` statements that can be replaced by a rearrangement of code\""}, {"sha": "0c1da0351739a25de814988d9db6da15b5bb554b", "filename": "src/tools/clippy/clippy_lints/src/needless_for_each.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -40,6 +40,7 @@ declare_clippy_lint! {\n     ///     println!(\"{}\", elem);\n     /// }\n     /// ```\n+    #[clippy::version = \"1.53.0\"]\n     pub NEEDLESS_FOR_EACH,\n     pedantic,\n     \"using `for_each` where a `for` loop would be simpler\""}, {"sha": "e0522f3fe0b1affc1bc8043d33c770c5c65d0e0c", "filename": "src/tools/clippy/clippy_lints/src/needless_late_init.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_late_init.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -0,0 +1,349 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::path_to_local;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::visitors::{expr_visitor, is_local_used};\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{Block, Expr, ExprKind, HirId, Local, LocalSource, MatchSource, Node, Pat, PatKind, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for late initializations that can be replaced by a `let` statement\n+    /// with an initializer.\n+    ///\n+    /// ### Why is this bad?\n+    /// Assigning in the `let` statement is less repetitive.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let a;\n+    /// a = 1;\n+    ///\n+    /// let b;\n+    /// match 3 {\n+    ///     0 => b = \"zero\",\n+    ///     1 => b = \"one\",\n+    ///     _ => b = \"many\",\n+    /// }\n+    ///\n+    /// let c;\n+    /// if true {\n+    ///     c = 1;\n+    /// } else {\n+    ///     c = -1;\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let a = 1;\n+    ///\n+    /// let b = match 3 {\n+    ///     0 => \"zero\",\n+    ///     1 => \"one\",\n+    ///     _ => \"many\",\n+    /// };\n+    ///\n+    /// let c = if true {\n+    ///     1\n+    /// } else {\n+    ///     -1\n+    /// };\n+    /// ```\n+    #[clippy::version = \"1.58.0\"]\n+    pub NEEDLESS_LATE_INIT,\n+    style,\n+    \"late initializations that can be replaced by a `let` statement with an initializer\"\n+}\n+declare_lint_pass!(NeedlessLateInit => [NEEDLESS_LATE_INIT]);\n+\n+fn contains_assign_expr<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'tcx>) -> bool {\n+    let mut seen = false;\n+    expr_visitor(cx, |expr| {\n+        if let ExprKind::Assign(..) = expr.kind {\n+            seen = true;\n+        }\n+\n+        !seen\n+    })\n+    .visit_stmt(stmt);\n+\n+    seen\n+}\n+\n+#[derive(Debug)]\n+struct LocalAssign {\n+    lhs_id: HirId,\n+    lhs_span: Span,\n+    rhs_span: Span,\n+    span: Span,\n+}\n+\n+impl LocalAssign {\n+    fn from_expr(expr: &Expr<'_>, span: Span) -> Option<Self> {\n+        if let ExprKind::Assign(lhs, rhs, _) = expr.kind {\n+            if lhs.span.from_expansion() {\n+                return None;\n+            }\n+\n+            Some(Self {\n+                lhs_id: path_to_local(lhs)?,\n+                lhs_span: lhs.span,\n+                rhs_span: rhs.span.source_callsite(),\n+                span,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, binding_id: HirId) -> Option<LocalAssign> {\n+        let assign = match expr.kind {\n+            ExprKind::Block(Block { expr: Some(expr), .. }, _) => Self::from_expr(expr, expr.span),\n+            ExprKind::Block(block, _) => {\n+                if_chain! {\n+                    if let Some((last, other_stmts)) = block.stmts.split_last();\n+                    if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = last.kind;\n+\n+                    let assign = Self::from_expr(expr, last.span)?;\n+\n+                    // avoid visiting if not needed\n+                    if assign.lhs_id == binding_id;\n+                    if other_stmts.iter().all(|stmt| !contains_assign_expr(cx, stmt));\n+\n+                    then {\n+                        Some(assign)\n+                    } else {\n+                        None\n+                    }\n+                }\n+            },\n+            ExprKind::Assign(..) => Self::from_expr(expr, expr.span),\n+            _ => None,\n+        }?;\n+\n+        if assign.lhs_id == binding_id {\n+            Some(assign)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+fn assignment_suggestions<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    binding_id: HirId,\n+    exprs: impl IntoIterator<Item = &'tcx Expr<'tcx>>,\n+) -> Option<(Applicability, Vec<(Span, String)>)> {\n+    let mut assignments = Vec::new();\n+\n+    for expr in exprs {\n+        let ty = cx.typeck_results().expr_ty(expr);\n+\n+        if ty.is_never() {\n+            continue;\n+        }\n+        if !ty.is_unit() {\n+            return None;\n+        }\n+\n+        let assign = LocalAssign::new(cx, expr, binding_id)?;\n+\n+        assignments.push(assign);\n+    }\n+\n+    let suggestions = assignments\n+        .into_iter()\n+        .map(|assignment| Some((assignment.span, snippet_opt(cx, assignment.rhs_span)?)))\n+        .collect::<Option<Vec<(Span, String)>>>()?;\n+\n+    let applicability = if suggestions.len() > 1 {\n+        // multiple suggestions don't work with rustfix in multipart_suggest\n+        // https://github.com/rust-lang/rustfix/issues/141\n+        Applicability::Unspecified\n+    } else {\n+        Applicability::MachineApplicable\n+    };\n+    Some((applicability, suggestions))\n+}\n+\n+struct Usage<'tcx> {\n+    stmt: &'tcx Stmt<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    needs_semi: bool,\n+}\n+\n+fn first_usage<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    binding_id: HirId,\n+    local_stmt_id: HirId,\n+    block: &'tcx Block<'tcx>,\n+) -> Option<Usage<'tcx>> {\n+    block\n+        .stmts\n+        .iter()\n+        .skip_while(|stmt| stmt.hir_id != local_stmt_id)\n+        .skip(1)\n+        .find(|&stmt| is_local_used(cx, stmt, binding_id))\n+        .and_then(|stmt| match stmt.kind {\n+            StmtKind::Expr(expr) => Some(Usage {\n+                stmt,\n+                expr,\n+                needs_semi: true,\n+            }),\n+            StmtKind::Semi(expr) => Some(Usage {\n+                stmt,\n+                expr,\n+                needs_semi: false,\n+            }),\n+            _ => None,\n+        })\n+}\n+\n+fn local_snippet_without_semicolon(cx: &LateContext<'_>, local: &Local<'_>) -> Option<String> {\n+    let span = local.span.with_hi(match local.ty {\n+        // let <pat>: <ty>;\n+        // ~~~~~~~~~~~~~~~\n+        Some(ty) => ty.span.hi(),\n+        // let <pat>;\n+        // ~~~~~~~~~\n+        None => local.pat.span.hi(),\n+    });\n+\n+    snippet_opt(cx, span)\n+}\n+\n+fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    local: &'tcx Local<'tcx>,\n+    local_stmt: &'tcx Stmt<'tcx>,\n+    block: &'tcx Block<'tcx>,\n+    binding_id: HirId,\n+) -> Option<()> {\n+    let usage = first_usage(cx, binding_id, local_stmt.hir_id, block)?;\n+    let binding_name = cx.tcx.hir().opt_name(binding_id)?;\n+    let let_snippet = local_snippet_without_semicolon(cx, local)?;\n+\n+    match usage.expr.kind {\n+        ExprKind::Assign(..) => {\n+            let assign = LocalAssign::new(cx, usage.expr, binding_id)?;\n+\n+            span_lint_and_then(\n+                cx,\n+                NEEDLESS_LATE_INIT,\n+                local_stmt.span,\n+                \"unneeded late initalization\",\n+                |diag| {\n+                    diag.tool_only_span_suggestion(\n+                        local_stmt.span,\n+                        \"remove the local\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+\n+                    diag.span_suggestion(\n+                        assign.lhs_span,\n+                        &format!(\"declare `{}` here\", binding_name),\n+                        let_snippet,\n+                        Applicability::MachineApplicable,\n+                    );\n+                },\n+            );\n+        },\n+        ExprKind::If(_, then_expr, Some(else_expr)) => {\n+            let (applicability, suggestions) = assignment_suggestions(cx, binding_id, [then_expr, else_expr])?;\n+\n+            span_lint_and_then(\n+                cx,\n+                NEEDLESS_LATE_INIT,\n+                local_stmt.span,\n+                \"unneeded late initalization\",\n+                |diag| {\n+                    diag.tool_only_span_suggestion(local_stmt.span, \"remove the local\", String::new(), applicability);\n+\n+                    diag.span_suggestion_verbose(\n+                        usage.stmt.span.shrink_to_lo(),\n+                        &format!(\"declare `{}` here\", binding_name),\n+                        format!(\"{} = \", let_snippet),\n+                        applicability,\n+                    );\n+\n+                    diag.multipart_suggestion(\"remove the assignments from the branches\", suggestions, applicability);\n+\n+                    if usage.needs_semi {\n+                        diag.span_suggestion(\n+                            usage.stmt.span.shrink_to_hi(),\n+                            \"add a semicolon after the `if` expression\",\n+                            \";\".to_string(),\n+                            applicability,\n+                        );\n+                    }\n+                },\n+            );\n+        },\n+        ExprKind::Match(_, arms, MatchSource::Normal) => {\n+            let (applicability, suggestions) = assignment_suggestions(cx, binding_id, arms.iter().map(|arm| arm.body))?;\n+\n+            span_lint_and_then(\n+                cx,\n+                NEEDLESS_LATE_INIT,\n+                local_stmt.span,\n+                \"unneeded late initalization\",\n+                |diag| {\n+                    diag.tool_only_span_suggestion(local_stmt.span, \"remove the local\", String::new(), applicability);\n+\n+                    diag.span_suggestion_verbose(\n+                        usage.stmt.span.shrink_to_lo(),\n+                        &format!(\"declare `{}` here\", binding_name),\n+                        format!(\"{} = \", let_snippet),\n+                        applicability,\n+                    );\n+\n+                    diag.multipart_suggestion(\n+                        \"remove the assignments from the `match` arms\",\n+                        suggestions,\n+                        applicability,\n+                    );\n+\n+                    if usage.needs_semi {\n+                        diag.span_suggestion(\n+                            usage.stmt.span.shrink_to_hi(),\n+                            \"add a semicolon after the `match` expression\",\n+                            \";\".to_string(),\n+                            applicability,\n+                        );\n+                    }\n+                },\n+            );\n+        },\n+        _ => {},\n+    };\n+\n+    Some(())\n+}\n+\n+impl LateLintPass<'tcx> for NeedlessLateInit {\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n+        let mut parents = cx.tcx.hir().parent_iter(local.hir_id);\n+\n+        if_chain! {\n+            if let Local {\n+                init: None,\n+                pat: &Pat {\n+                    kind: PatKind::Binding(_, binding_id, _, None),\n+                    ..\n+                },\n+                source: LocalSource::Normal,\n+                ..\n+            } = local;\n+            if let Some((_, Node::Stmt(local_stmt))) = parents.next();\n+            if let Some((_, Node::Block(block))) = parents.next();\n+\n+            then {\n+                check(cx, local, local_stmt, block, binding_id);\n+            }\n+        }\n+    }\n+}"}, {"sha": "a28b08c33ec46c533d4d4cfa361d80acd9b3c099", "filename": "src/tools/clippy/clippy_lints/src/needless_option_as_deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_option_as_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_option_as_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_option_as_deref.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::in_macro;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_type_diagnostic_item;\n use rustc_errors::Applicability;\n@@ -27,6 +26,7 @@ declare_clippy_lint! {\n     /// let a = Some(&1);\n     /// let b = a;\n     /// ```\n+    #[clippy::version = \"1.57.0\"]\n     pub NEEDLESS_OPTION_AS_DEREF,\n     complexity,\n     \"no-op use of `deref` or `deref_mut` method to `Option`.\"\n@@ -38,7 +38,7 @@ declare_lint_pass!(OptionNeedlessDeref=> [\n \n impl<'tcx> LateLintPass<'tcx> for OptionNeedlessDeref {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() || in_macro(expr.span) {\n+        if expr.span.from_expansion() {\n             return;\n         }\n         let typeck = cx.typeck_results();"}, {"sha": "35877d51c0c166c89ec0e70598ed377a84b70a96", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -51,6 +51,7 @@ declare_clippy_lint! {\n     ///     assert_eq!(v.len(), 42);\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEEDLESS_PASS_BY_VALUE,\n     pedantic,\n     \"functions taking arguments by value, but not consuming them in its body\""}, {"sha": "1ffed6a052499119e5bda1293034958b4dce05b8", "filename": "src/tools/clippy/clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -53,6 +53,7 @@ declare_clippy_lint! {\n     ///     tr.and_then(|t| t.magic)\n     /// }\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub NEEDLESS_QUESTION_MARK,\n     complexity,\n     \"Suggest `value.inner_option` instead of `Some(value.inner_option?)`. The same goes for `Result<T, E>`.\"\n@@ -92,26 +93,33 @@ impl LateLintPass<'_> for NeedlessQuestionMark {\n }\n \n fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-    let inner_expr = if_chain! {\n+    if_chain! {\n         if let ExprKind::Call(path, [arg]) = &expr.kind;\n         if let ExprKind::Path(ref qpath) = &path.kind;\n-        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n+        let sugg_remove = if is_lang_ctor(cx, qpath, OptionSome) {\n+            \"Some()\"\n+        } else if is_lang_ctor(cx, qpath, ResultOk) {\n+            \"Ok()\"\n+        } else {\n+            return;\n+        };\n         if let ExprKind::Match(inner_expr_with_q, _, MatchSource::TryDesugar) = &arg.kind;\n         if let ExprKind::Call(called, [inner_expr]) = &inner_expr_with_q.kind;\n         if let ExprKind::Path(QPath::LangItem(LangItem::TryTraitBranch, _)) = &called.kind;\n         if expr.span.ctxt() == inner_expr.span.ctxt();\n         let expr_ty = cx.typeck_results().expr_ty(expr);\n         let inner_ty = cx.typeck_results().expr_ty(inner_expr);\n         if TyS::same_type(expr_ty, inner_ty);\n-        then { inner_expr } else { return; }\n-    };\n-    span_lint_and_sugg(\n-        cx,\n-        NEEDLESS_QUESTION_MARK,\n-        expr.span,\n-        \"question mark operator is useless here\",\n-        \"try\",\n-        format!(\"{}\", snippet(cx, inner_expr.span, r#\"\"...\"\"#)),\n-        Applicability::MachineApplicable,\n-    );\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                NEEDLESS_QUESTION_MARK,\n+                expr.span,\n+                \"question mark operator is useless here\",\n+                &format!(\"try removing question mark and `{}`\", sugg_remove),\n+                format!(\"{}\", snippet(cx, inner_expr.span, r#\"\"...\"\"#)),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n }"}, {"sha": "ed315efaa2fa7c546de3a7fabce42dc2997a80f5", "filename": "src/tools/clippy/clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -40,6 +40,7 @@ declare_clippy_lint! {\n     ///     ..zero_point\n     /// };\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEEDLESS_UPDATE,\n     complexity,\n     \"using `Foo { ..base }` when there are no missing fields\""}, {"sha": "efe31a1544187ebeec7ca98fb3e6e034272f9312", "filename": "src/tools/clippy/clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -36,6 +36,7 @@ declare_clippy_lint! {\n     ///     _ => false,\n     /// };\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEG_CMP_OP_ON_PARTIAL_ORD,\n     complexity,\n     \"The use of negated comparison operators on partially ordered types may produce confusing code.\""}, {"sha": "cb67fab17400590a04c008afd701f66047f64d6a", "filename": "src/tools/clippy/clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -20,6 +20,7 @@ declare_clippy_lint! {\n     /// ```ignore\n     /// x * -1\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEG_MULTIPLY,\n     style,\n     \"multiplying integers with `-1`\""}, {"sha": "f0c0c89ca8f3b5bfff8df170daa76273a47b3566", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -45,6 +45,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEW_WITHOUT_DEFAULT,\n     style,\n     \"`fn new() -> Self` method without `Default` implementation\""}, {"sha": "6fcc9ca29b923b166bf7009a4d57b1725473b388", "filename": "src/tools/clippy/clippy_lints/src/no_effect.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -22,6 +22,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// 0;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NO_EFFECT,\n     complexity,\n     \"statements with no effect\"\n@@ -44,6 +45,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// let _i_serve_no_purpose = 1;\n     /// ```\n+    #[clippy::version = \"1.58.0\"]\n     pub NO_EFFECT_UNDERSCORE_BINDING,\n     pedantic,\n     \"binding to `_` prefixed variable with no side-effect\"\n@@ -62,6 +64,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// compute_array()[0];\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNNECESSARY_OPERATION,\n     complexity,\n     \"outer expressions with no effect\"\n@@ -130,9 +133,12 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         },\n         ExprKind::Call(callee, args) => {\n             if let ExprKind::Path(ref qpath) = callee.kind {\n-                let res = cx.qpath_res(qpath, callee.hir_id);\n+                if cx.typeck_results().type_dependent_def(expr.hir_id).is_some() {\n+                    // type-dependent function call like `impl FnOnce for X`\n+                    return false;\n+                }\n                 let def_matched = matches!(\n-                    res,\n+                    cx.qpath_res(qpath, callee.hir_id),\n                     Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..)\n                 );\n                 if def_matched || is_range_literal(expr) {\n@@ -158,12 +164,13 @@ fn check_unnecessary_operation(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if !&reduced.iter().any(|e| e.span.from_expansion());\n         then {\n             if let ExprKind::Index(..) = &expr.kind {\n-                let snippet;\n-                if let (Some(arr), Some(func)) = (snippet_opt(cx, reduced[0].span), snippet_opt(cx, reduced[1].span)) {\n-                    snippet = format!(\"assert!({}.len() > {});\", &arr, &func);\n+                let snippet = if let (Some(arr), Some(func)) =\n+                    (snippet_opt(cx, reduced[0].span), snippet_opt(cx, reduced[1].span))\n+                {\n+                    format!(\"assert!({}.len() > {});\", &arr, &func)\n                 } else {\n                     return;\n-                }\n+                };\n                 span_lint_hir_and_then(\n                     cx,\n                     UNNECESSARY_OPERATION,\n@@ -235,6 +242,10 @@ fn reduce_expression<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Vec\n         },\n         ExprKind::Call(callee, args) => {\n             if let ExprKind::Path(ref qpath) = callee.kind {\n+                if cx.typeck_results().type_dependent_def(expr.hir_id).is_some() {\n+                    // type-dependent function call like `impl FnOnce for X`\n+                    return None;\n+                }\n                 let res = cx.qpath_res(qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..)"}, {"sha": "074ba9e92ba4dfcea5e8921afbe8139302efe7f1", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -69,6 +69,7 @@ declare_clippy_lint! {\n     /// STATIC_ATOM.store(9, SeqCst);\n     /// assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DECLARE_INTERIOR_MUTABLE_CONST,\n     style,\n     \"declaring `const` with interior mutability\"\n@@ -113,6 +114,7 @@ declare_clippy_lint! {\n     /// STATIC_ATOM.store(9, SeqCst);\n     /// assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub BORROW_INTERIOR_MUTABLE_CONST,\n     style,\n     \"referencing `const` with interior mutability\""}, {"sha": "5559fac0a8a1e7954e45d84e2809864ccd701f9f", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -24,6 +24,7 @@ declare_clippy_lint! {\n     /// let checked_exp = something;\n     /// let checked_expr = something_else;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SIMILAR_NAMES,\n     pedantic,\n     \"similarly named items and bindings\"\n@@ -42,6 +43,7 @@ declare_clippy_lint! {\n     /// ```ignore\n     /// let (a, b, c, d, e, f, g) = (...);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MANY_SINGLE_CHAR_NAMES,\n     pedantic,\n     \"too many single character bindings\"\n@@ -62,6 +64,7 @@ declare_clippy_lint! {\n     /// let ___1 = 1;\n     /// let __1___2 = 11;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub JUST_UNDERSCORES_AND_DIGITS,\n     style,\n     \"unclear name\"\n@@ -357,7 +360,12 @@ impl EarlyLintPass for NonExpressiveNames {\n             return;\n         }\n \n-        if let ItemKind::Fn(box ast::Fn { ref sig, body: Some(ref blk), .. }) = item.kind {\n+        if let ItemKind::Fn(box ast::Fn {\n+            ref sig,\n+            body: Some(ref blk),\n+            ..\n+        }) = item.kind\n+        {\n             do_check(self, cx, &item.attrs, &sig.decl, blk);\n         }\n     }\n@@ -367,7 +375,12 @@ impl EarlyLintPass for NonExpressiveNames {\n             return;\n         }\n \n-        if let AssocItemKind::Fn(box ast::Fn { ref sig, body: Some(ref blk), .. }) = item.kind {\n+        if let AssocItemKind::Fn(box ast::Fn {\n+            ref sig,\n+            body: Some(ref blk),\n+            ..\n+        }) = item.kind\n+        {\n             do_check(self, cx, &item.attrs, &sig.decl, blk);\n         }\n     }"}, {"sha": "4b57dbc4c412a0d117352899f7ec55005cb19184", "filename": "src/tools/clippy/clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -32,6 +32,7 @@ declare_clippy_lint! {\n     /// let mut options = OpenOptions::new();\n     /// options.mode(0o644);\n     /// ```\n+    #[clippy::version = \"1.53.0\"]\n     pub NON_OCTAL_UNIX_PERMISSIONS,\n     correctness,\n     \"use of non-octal value to set unix file permissions, which will be translated into octal\""}, {"sha": "bba542ce8ca7b408a5050963d634052eca559546", "filename": "src/tools/clippy/clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::is_lint_allowed;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::{implements_trait, is_copy};\n+use clippy_utils::{is_lint_allowed, match_def_path, paths};\n use rustc_ast::ImplPolarity;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{FieldDef, Item, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::sym;\n@@ -43,6 +44,7 @@ declare_clippy_lint! {\n     /// ```\n     /// Use thread-safe types like [`std::sync::Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html)\n     /// or specify correct bounds on generic type parameters (`T: Send`).\n+    #[clippy::version = \"1.57.0\"]\n     pub NON_SEND_FIELDS_IN_SEND_TY,\n     suspicious,\n     \"there is field that does not implement `Send` in a `Send` struct\"\n@@ -76,6 +78,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSendFieldInSendTy {\n         // single `AdtDef` may have multiple `Send` impls due to generic\n         // parameters, and the lint is much easier to implement in this way.\n         if_chain! {\n+            if !in_external_macro(cx.tcx.sess, item.span);\n             if let Some(send_trait) = cx.tcx.get_diagnostic_item(sym::Send);\n             if let ItemKind::Impl(hir_impl) = &item.kind;\n             if let Some(trait_ref) = &hir_impl.of_trait;\n@@ -180,7 +183,7 @@ fn ty_allowed_without_raw_pointer_heuristic<'tcx>(cx: &LateContext<'tcx>, ty: Ty\n         return true;\n     }\n \n-    if is_copy(cx, ty) && !contains_raw_pointer(cx, ty) {\n+    if is_copy(cx, ty) && !contains_pointer_like(cx, ty) {\n         return true;\n     }\n \n@@ -200,7 +203,7 @@ fn ty_allowed_with_raw_pointer_heuristic<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'t\n             .all(|ty| ty_allowed_with_raw_pointer_heuristic(cx, ty, send_trait)),\n         ty::Array(ty, _) | ty::Slice(ty) => ty_allowed_with_raw_pointer_heuristic(cx, ty, send_trait),\n         ty::Adt(_, substs) => {\n-            if contains_raw_pointer(cx, ty) {\n+            if contains_pointer_like(cx, ty) {\n                 // descends only if ADT contains any raw pointers\n                 substs.iter().all(|generic_arg| match generic_arg.unpack() {\n                     GenericArgKind::Type(ty) => ty_allowed_with_raw_pointer_heuristic(cx, ty, send_trait),\n@@ -217,14 +220,20 @@ fn ty_allowed_with_raw_pointer_heuristic<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'t\n     }\n }\n \n-/// Checks if the type contains any raw pointers in substs (including nested ones).\n-fn contains_raw_pointer<'tcx>(cx: &LateContext<'tcx>, target_ty: Ty<'tcx>) -> bool {\n+/// Checks if the type contains any pointer-like types in substs (including nested ones)\n+fn contains_pointer_like<'tcx>(cx: &LateContext<'tcx>, target_ty: Ty<'tcx>) -> bool {\n     for ty_node in target_ty.walk(cx.tcx) {\n-        if_chain! {\n-            if let GenericArgKind::Type(inner_ty) = ty_node.unpack();\n-            if let ty::RawPtr(_) = inner_ty.kind();\n-            then {\n-                return true;\n+        if let GenericArgKind::Type(inner_ty) = ty_node.unpack() {\n+            match inner_ty.kind() {\n+                ty::RawPtr(_) => {\n+                    return true;\n+                },\n+                ty::Adt(adt_def, _) => {\n+                    if match_def_path(cx, adt_def.did, &paths::PTR_NON_NULL) {\n+                        return true;\n+                    }\n+                },\n+                _ => (),\n             }\n         }\n     }"}, {"sha": "a04d589f880fa9aca9e43677f0076129bc9cdd69", "filename": "src/tools/clippy/clippy_lints/src/nonstandard_macro_braces.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -3,14 +3,16 @@ use std::{\n     hash::{Hash, Hasher},\n };\n \n-use clippy_utils::{diagnostics::span_lint_and_help, in_macro, is_direct_expn_of, source::snippet_opt};\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::DefId;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n+use rustc_span::hygiene::{ExpnKind, MacroKind};\n+use rustc_span::{Span, Symbol};\n use serde::{de, Deserialize};\n \n declare_clippy_lint! {\n@@ -29,6 +31,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// vec![1, 2, 3];\n     /// ```\n+    #[clippy::version = \"1.55.0\"]\n     pub NONSTANDARD_MACRO_BRACES,\n     nursery,\n     \"check consistent use of braces in macro\"\n@@ -37,7 +40,7 @@ declare_clippy_lint! {\n const BRACES: &[(&str, &str)] = &[(\"(\", \")\"), (\"{\", \"}\"), (\"[\", \"]\")];\n \n /// The (name, (open brace, close brace), source snippet)\n-type MacroInfo<'a> = (&'a str, &'a (String, String), String);\n+type MacroInfo<'a> = (Symbol, &'a (String, String), String);\n \n #[derive(Clone, Debug, Default)]\n pub struct MacroBraces {\n@@ -93,35 +96,34 @@ impl EarlyLintPass for MacroBraces {\n \n fn is_offending_macro<'a>(cx: &EarlyContext<'_>, span: Span, mac_braces: &'a MacroBraces) -> Option<MacroInfo<'a>> {\n     let unnested_or_local = || {\n-        let nested = in_macro(span.ctxt().outer_expn_data().call_site);\n-        !nested\n+        !span.ctxt().outer_expn_data().call_site.from_expansion()\n             || span\n                 .macro_backtrace()\n                 .last()\n                 .map_or(false, |e| e.macro_def_id.map_or(false, DefId::is_local))\n     };\n     if_chain! {\n-        // Make sure we are only one level deep otherwise there are to many FP's\n-        if in_macro(span);\n-        if let Some((name, braces)) = find_matching_macro(span, &mac_braces.macro_braces);\n+        if let ExpnKind::Macro(MacroKind::Bang, mac_name) = span.ctxt().outer_expn_data().kind;\n+        let name = &*mac_name.as_str();\n+        if let Some(braces) = mac_braces.macro_braces.get(name);\n         if let Some(snip) = snippet_opt(cx, span.ctxt().outer_expn_data().call_site);\n         // we must check only invocation sites\n         // https://github.com/rust-lang/rust-clippy/issues/7422\n         if snip.starts_with(&format!(\"{}!\", name));\n         if unnested_or_local();\n         // make formatting consistent\n-        let c = snip.replace(\" \", \"\");\n+        let c = snip.replace(' ', \"\");\n         if !c.starts_with(&format!(\"{}!{}\", name, braces.0));\n         if !mac_braces.done.contains(&span.ctxt().outer_expn_data().call_site);\n         then {\n-            Some((name, braces, snip))\n+            Some((mac_name, braces, snip))\n         } else {\n             None\n         }\n     }\n }\n \n-fn emit_help(cx: &EarlyContext<'_>, snip: String, braces: &(String, String), name: &str, span: Span) {\n+fn emit_help(cx: &EarlyContext<'_>, snip: String, braces: &(String, String), name: Symbol, span: Span) {\n     let with_space = &format!(\"! {}\", braces.0);\n     let without_space = &format!(\"!{}\", braces.0);\n     let mut help = snip;\n@@ -144,15 +146,6 @@ fn emit_help(cx: &EarlyContext<'_>, snip: String, braces: &(String, String), nam\n     );\n }\n \n-fn find_matching_macro(\n-    span: Span,\n-    braces: &FxHashMap<String, (String, String)>,\n-) -> Option<(&String, &(String, String))> {\n-    braces\n-        .iter()\n-        .find(|(macro_name, _)| is_direct_expn_of(span, macro_name).is_some())\n-}\n-\n fn macro_braces(conf: FxHashSet<MacroMatcher>) -> FxHashMap<String, (String, String)> {\n     let mut braces = vec![\n         macro_matcher!("}, {"sha": "9c971437645455c1331dc96ba6c1fdcb92bbaf04", "filename": "src/tools/clippy/clippy_lints/src/octal_escapes.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -0,0 +1,150 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use rustc_ast::ast::{Expr, ExprKind};\n+use rustc_ast::token::{Lit, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+use std::fmt::Write;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `\\0` escapes in string and byte literals that look like octal\n+    /// character escapes in C.\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// C and other languages support octal character escapes in strings, where\n+    /// a backslash is followed by up to three octal digits. For example, `\\033`\n+    /// stands for the ASCII character 27 (ESC). Rust does not support this\n+    /// notation, but has the escape code `\\0` which stands for a null\n+    /// byte/character, and any following digits do not form part of the escape\n+    /// sequence. Therefore, `\\033` is not a compiler error but the result may\n+    /// be surprising.\n+    ///\n+    /// ### Known problems\n+    /// The actual meaning can be the intended one. `\\x00` can be used in these\n+    /// cases to be unambigious.\n+    ///\n+    /// The lint does not trigger for format strings in `print!()`, `write!()`\n+    /// and friends since the string is already preprocessed when Clippy lints\n+    /// can see it.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// // Bad\n+    /// let one = \"\\033[1m Bold? \\033[0m\";  // \\033 intended as escape\n+    /// let two = \"\\033\\0\";                 // \\033 intended as null-3-3\n+    ///\n+    /// // Good\n+    /// let one = \"\\x1b[1mWill this be bold?\\x1b[0m\";\n+    /// let two = \"\\x0033\\x00\";\n+    /// ```\n+    #[clippy::version = \"1.58.0\"]\n+    pub OCTAL_ESCAPES,\n+    suspicious,\n+    \"string escape sequences looking like octal characters\"\n+}\n+\n+declare_lint_pass!(OctalEscapes => [OCTAL_ESCAPES]);\n+\n+impl EarlyLintPass for OctalEscapes {\n+    fn check_expr(&mut self, cx: &EarlyContext<'tcx>, expr: &Expr) {\n+        if in_external_macro(cx.sess, expr.span) {\n+            return;\n+        }\n+\n+        if let ExprKind::Lit(lit) = &expr.kind {\n+            if matches!(lit.token.kind, LitKind::Str) {\n+                check_lit(cx, &lit.token, lit.span, true);\n+            } else if matches!(lit.token.kind, LitKind::ByteStr) {\n+                check_lit(cx, &lit.token, lit.span, false);\n+            }\n+        }\n+    }\n+}\n+\n+fn check_lit(cx: &EarlyContext<'tcx>, lit: &Lit, span: Span, is_string: bool) {\n+    let contents = lit.symbol.as_str();\n+    let mut iter = contents.char_indices().peekable();\n+    let mut found = vec![];\n+\n+    // go through the string, looking for \\0[0-7][0-7]?\n+    while let Some((from, ch)) = iter.next() {\n+        if ch == '\\\\' {\n+            if let Some((_, '0')) = iter.next() {\n+                // collect up to two further octal digits\n+                if let Some((mut to, '0'..='7')) = iter.next() {\n+                    if let Some((_, '0'..='7')) = iter.peek() {\n+                        to += 1;\n+                    }\n+                    found.push((from, to + 1));\n+                }\n+            }\n+        }\n+    }\n+\n+    if found.is_empty() {\n+        return;\n+    }\n+\n+    // construct two suggestion strings, one with \\x escapes with octal meaning\n+    // as in C, and one with \\x00 for null bytes.\n+    let mut suggest_1 = if is_string { \"\\\"\" } else { \"b\\\"\" }.to_string();\n+    let mut suggest_2 = suggest_1.clone();\n+    let mut index = 0;\n+    for (from, to) in found {\n+        suggest_1.push_str(&contents[index..from]);\n+        suggest_2.push_str(&contents[index..from]);\n+\n+        // construct a replacement escape\n+        // the maximum value is \\077, or \\x3f, so u8 is sufficient here\n+        if let Ok(n) = u8::from_str_radix(&contents[from + 1..to], 8) {\n+            write!(&mut suggest_1, \"\\\\x{:02x}\", n).unwrap();\n+        }\n+\n+        // append the null byte as \\x00 and the following digits literally\n+        suggest_2.push_str(\"\\\\x00\");\n+        suggest_2.push_str(&contents[from + 2..to]);\n+\n+        index = to;\n+    }\n+    suggest_1.push_str(&contents[index..]);\n+    suggest_1.push('\"');\n+    suggest_2.push_str(&contents[index..]);\n+    suggest_2.push('\"');\n+\n+    span_lint_and_then(\n+        cx,\n+        OCTAL_ESCAPES,\n+        span,\n+        &format!(\n+            \"octal-looking escape in {} literal\",\n+            if is_string { \"string\" } else { \"byte string\" }\n+        ),\n+        |diag| {\n+            diag.help(&format!(\n+                \"octal escapes are not supported, `\\\\0` is always a null {}\",\n+                if is_string { \"character\" } else { \"byte\" }\n+            ));\n+            // suggestion 1: equivalent hex escape\n+            diag.span_suggestion(\n+                span,\n+                \"if an octal escape was intended, use the hexadecimal representation instead\",\n+                suggest_1,\n+                Applicability::MaybeIncorrect,\n+            );\n+            // suggestion 2: unambiguous null byte\n+            diag.span_suggestion(\n+                span,\n+                &format!(\n+                    \"if the null {} is intended, disambiguate using\",\n+                    if is_string { \"character\" } else { \"byte\" }\n+                ),\n+                suggest_2,\n+                Applicability::MaybeIncorrect,\n+            );\n+        },\n+    );\n+}"}, {"sha": "2c77100bdcfc8837a52b2751fb519a8e674d8bf1", "filename": "src/tools/clippy/clippy_lints/src/open_options.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fopen_options.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -22,6 +22,7 @@ declare_clippy_lint! {\n     ///\n     /// OpenOptions::new().read(true).truncate(true);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NONSENSICAL_OPEN_OPTIONS,\n     correctness,\n     \"nonsensical combination of options for opening a file\""}, {"sha": "3f5286ba097b5970993d6f7027b94c512a556041", "filename": "src/tools/clippy/clippy_lints/src/option_env_unwrap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_env_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_env_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_env_unwrap.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -26,6 +26,7 @@ declare_clippy_lint! {\n     /// ```rust,no_run\n     /// let _ = env!(\"HOME\");\n     /// ```\n+    #[clippy::version = \"1.43.0\"]\n     pub OPTION_ENV_UNWRAP,\n     correctness,\n     \"using `option_env!(...).unwrap()` to get environment variable\""}, {"sha": "262be17f61751d495d862f8d628e13c0a0c1ae79", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::higher;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n-    can_move_expr_to_closure, eager_or_lazy, in_constant, in_macro, is_else_clause, is_lang_ctor, peel_hir_expr_while,\n+    can_move_expr_to_closure, eager_or_lazy, in_constant, is_else_clause, is_lang_ctor, peel_hir_expr_while,\n     CaptureKind,\n };\n use if_chain::if_chain;\n@@ -59,6 +59,7 @@ declare_clippy_lint! {\n     ///     y*y\n     /// }, |foo| foo);\n     /// ```\n+    #[clippy::version = \"1.47.0\"]\n     pub OPTION_IF_LET_ELSE,\n     nursery,\n     \"reimplementation of Option::map_or\"\n@@ -110,7 +111,7 @@ fn extract_body_from_expr<'a>(expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: bool, as_mut: bool) -> String {\n     format!(\n         \"{}{}\",\n-        Sugg::hir(cx, cond_expr, \"..\").maybe_par(),\n+        Sugg::hir_with_macro_callsite(cx, cond_expr, \"..\").maybe_par(),\n         if as_mut {\n             \".as_mut()\"\n         } else if as_ref {\n@@ -126,7 +127,7 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n /// this construct is found, or None if this construct is not found.\n fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionIfLetElseOccurence> {\n     if_chain! {\n-        if !in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n+        if !expr.span.from_expansion(); // Don't lint macros, because it behaves weirdly\n         if !in_constant(cx, expr.hir_id);\n         if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n             = higher::IfLet::hir(cx, expr);\n@@ -146,11 +147,7 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n             let some_body = extract_body_from_expr(if_then)?;\n             let none_body = extract_body_from_expr(if_else)?;\n-            let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) {\n-                \"map_or\"\n-            } else {\n-                \"map_or_else\"\n-            };\n+            let method_sugg = if eager_or_lazy::switch_to_eager_eval(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n             let (as_ref, as_mut) = match &let_expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n@@ -183,8 +180,8 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n             Some(OptionIfLetElseOccurence {\n                 option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n                 method_sugg: method_sugg.to_string(),\n-                some_expr: format!(\"|{}{}| {}\", capture_mut, capture_name, Sugg::hir(cx, some_body, \"..\")),\n-                none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir(cx, none_body, \"..\")),\n+                some_expr: format!(\"|{}{}| {}\", capture_mut, capture_name, Sugg::hir_with_macro_callsite(cx, some_body, \"..\")),\n+                none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir_with_macro_callsite(cx, none_body, \"..\")),\n             })\n         } else {\n             None"}, {"sha": "6dabbd4803117692a025804c9ccdd0302e077cd0", "filename": "src/tools/clippy/clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -19,6 +19,7 @@ declare_clippy_lint! {\n     /// # let b = 2;\n     /// a + b < a;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub OVERFLOW_CHECK_CONDITIONAL,\n     complexity,\n     \"overflow checks inspired by C which are likely to panic\""}, {"sha": "8769c0452146435d1869b0ea30bfa74721052acb", "filename": "src/tools/clippy/clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -30,6 +30,7 @@ declare_clippy_lint! {\n     ///     Err(String::from(\"error\"))\n     /// }\n     /// ```\n+    #[clippy::version = \"1.48.0\"]\n     pub PANIC_IN_RESULT_FN,\n     restriction,\n     \"functions of type `Result<..>` that contain `panic!()`, `todo!()`, `unreachable()`, `unimplemented()` or assertion\""}, {"sha": "edfac824ded987e8c47c5e45493c76b1beb83720", "filename": "src/tools/clippy/clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -17,6 +17,7 @@ declare_clippy_lint! {\n     /// ```no_run\n     /// panic!(\"even with a good reason\");\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub PANIC,\n     restriction,\n     \"usage of the `panic!` macro\"\n@@ -33,6 +34,7 @@ declare_clippy_lint! {\n     /// ```no_run\n     /// unimplemented!();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNIMPLEMENTED,\n     restriction,\n     \"`unimplemented!` should not be present in production code\"\n@@ -49,6 +51,7 @@ declare_clippy_lint! {\n     /// ```no_run\n     /// todo!();\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub TODO,\n     restriction,\n     \"`todo!` should not be present in production code\"\n@@ -65,6 +68,7 @@ declare_clippy_lint! {\n     /// ```no_run\n     /// unreachable!();\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub UNREACHABLE,\n     restriction,\n     \"usage of the `unreachable!` macro\""}, {"sha": "e827cdaae8728922580a9f4e7d9fbc7cafd5b3b6", "filename": "src/tools/clippy/clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -25,6 +25,7 @@ declare_clippy_lint! {\n     ///    fn ne(&self, other: &Foo) -> bool { !(self == other) }\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub PARTIALEQ_NE_IMPL,\n     complexity,\n     \"re-implementing `PartialEq::ne`\""}, {"sha": "3092ab8392a7231b99e23e74f71764ce88c21b1e", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -65,6 +65,7 @@ declare_clippy_lint! {\n     /// // Better\n     /// fn foo(v: u32) {}\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub TRIVIALLY_COPY_PASS_BY_REF,\n     pedantic,\n     \"functions taking small copyable arguments by reference\"\n@@ -98,6 +99,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// fn foo(v: &TooLarge) {}\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub LARGE_TYPES_PASSED_BY_VALUE,\n     pedantic,\n     \"functions taking large arguments by value\""}, {"sha": "8ebee9bd04d3177c8aa8a4f2bfbdee035d41f998", "filename": "src/tools/clippy/clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -35,6 +35,7 @@ declare_clippy_lint! {\n     /// x.push(\"bar\");\n     /// assert_eq!(x, PathBuf::from(\"/foo/bar\"));\n     /// ```\n+    #[clippy::version = \"1.36.0\"]\n     pub PATH_BUF_PUSH_OVERWRITE,\n     nursery,\n     \"calling `push` with file system root on `PathBuf` can overwrite it\""}, {"sha": "c7d77d30927f854e2836665b13a65c43c5ebd53c", "filename": "src/tools/clippy/clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -73,6 +73,7 @@ declare_clippy_lint! {\n     ///     *a += b;\n     /// }\n     /// ```\n+    #[clippy::version = \"1.47.0\"]\n     pub PATTERN_TYPE_MISMATCH,\n     restriction,\n     \"type of pattern does not match the expression type\""}, {"sha": "cc0533c9f5d1aa5b0abfb43e5050b42605f34265", "filename": "src/tools/clippy/clippy_lints/src/precedence.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -42,6 +42,7 @@ declare_clippy_lint! {\n     /// ### Example\n     /// * `1 << 2 + 3` equals 32, while `(1 << 2) + 3` equals 7\n     /// * `-1i32.abs()` equals -1, while `(-1i32).abs()` equals 1\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub PRECEDENCE,\n     complexity,\n     \"operations where precedence may be unclear\""}, {"sha": "c08a19d520b607bac1658b9ce50ab64928d2f5e3", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -70,6 +70,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// fn foo(&[u32]) { .. }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub PTR_ARG,\n     style,\n     \"fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\"\n@@ -96,6 +97,7 @@ declare_clippy_lint! {\n     ///     ..\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CMP_NULL,\n     style,\n     \"comparing a pointer to a null pointer, suggesting to use `.is_null()` instead\"\n@@ -121,6 +123,7 @@ declare_clippy_lint! {\n     /// ```ignore\n     /// fn foo(&Foo) -> &mut Bar { .. }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MUT_FROM_REF,\n     correctness,\n     \"fns that create mutable refs from immutable ref args\"\n@@ -143,6 +146,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// unsafe { std::slice::from_raw_parts(NonNull::dangling().as_ptr(), 0); }\n     /// ```\n+    #[clippy::version = \"1.53.0\"]\n     pub INVALID_NULL_PTR_USAGE,\n     correctness,\n     \"invalid usage of a null pointer, suggesting `NonNull::dangling()` instead\""}, {"sha": "3c126fc1ca69a27cc0862dcb3f44a8cf1f2df211", "filename": "src/tools/clippy/clippy_lints/src/ptr_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_eq.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::in_macro;\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -30,6 +29,7 @@ declare_clippy_lint! {\n     ///\n     /// assert!(std::ptr::eq(a, b));\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub PTR_EQ,\n     style,\n     \"use `std::ptr::eq` when comparing raw pointers\"\n@@ -41,7 +41,7 @@ static LINT_MSG: &str = \"use `std::ptr::eq` when comparing raw pointers\";\n \n impl LateLintPass<'_> for PtrEq {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if in_macro(expr.span) {\n+        if expr.span.from_expansion() {\n             return;\n         }\n "}, {"sha": "964564b57946b5784536ab86e62013fe073b869d", "filename": "src/tools/clippy/clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -38,6 +38,7 @@ declare_clippy_lint! {\n     ///     ptr.add(offset);\n     /// }\n     /// ```\n+    #[clippy::version = \"1.30.0\"]\n     pub PTR_OFFSET_WITH_CAST,\n     complexity,\n     \"unneeded pointer offset cast\""}, {"sha": "a5531993ee6ad36bb038edf750c1f22b993fc6ba", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -32,6 +32,7 @@ declare_clippy_lint! {\n     /// ```ignore\n     /// option?;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub QUESTION_MARK,\n     style,\n     \"checks for expressions that could be replaced by the question mark operator\""}, {"sha": "52c060bc42c7ab7dba51ee740aa1fcaaacdbc7cf", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -35,6 +35,7 @@ declare_clippy_lint! {\n     /// # let x = vec![1];\n     /// x.iter().enumerate();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub RANGE_ZIP_WITH_LEN,\n     complexity,\n     \"zipping iterator with a range when `enumerate()` would do\"\n@@ -72,6 +73,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// for x..=y { .. }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub RANGE_PLUS_ONE,\n     pedantic,\n     \"`x..(y+1)` reads better as `x..=y`\"\n@@ -100,6 +102,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// for x..y { .. }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub RANGE_MINUS_ONE,\n     pedantic,\n     \"`x..=(y-1)` reads better as `x..y`\"\n@@ -132,6 +135,7 @@ declare_clippy_lint! {\n     ///     let sub = &arr[1..3];\n     /// }\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub REVERSED_EMPTY_RANGES,\n     correctness,\n     \"reversing the limits of range expressions, resulting in empty ranges\"\n@@ -158,6 +162,7 @@ declare_clippy_lint! {\n     ///# let x = 6;\n     /// assert!((3..8).contains(&x));\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub MANUAL_RANGE_CONTAINS,\n     style,\n     \"manually reimplementing {`Range`, `RangeInclusive`}`::contains`\""}, {"sha": "1cf349f8aa7c7daa7526a25aee610df890de0904", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -62,6 +62,7 @@ declare_clippy_lint! {\n     ///\n     /// Path::new(\"/a/b\").join(\"c\").to_path_buf();\n     /// ```\n+    #[clippy::version = \"1.32.0\"]\n     pub REDUNDANT_CLONE,\n     perf,\n     \"`clone()` of an owned value that is going to be dropped immediately\""}, {"sha": "0de282542fc3c73fc0e15446364b1505e1b3c3b8", "filename": "src/tools/clippy/clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -30,6 +30,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let a = 42\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub REDUNDANT_CLOSURE_CALL,\n     complexity,\n     \"throwaway closures called in the expression they are defined\""}, {"sha": "93dbe936d5841b2e9b9b289ea3e445c5a1857c4c", "filename": "src/tools/clippy/clippy_lints/src/redundant_else.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_else.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -36,6 +36,7 @@ declare_clippy_lint! {\n     ///     print!(\"Moving on...\");\n     /// }\n     /// ```\n+    #[clippy::version = \"1.50.0\"]\n     pub REDUNDANT_ELSE,\n     pedantic,\n     \"`else` branch that can be removed without changing semantics\""}, {"sha": "0dea4a784b2170829f7f1a7be2c825f4dca7f2fd", "filename": "src/tools/clippy/clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -30,6 +30,7 @@ declare_clippy_lint! {\n     /// ```ignore\n     /// let foo = Foo { bar };\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub REDUNDANT_FIELD_NAMES,\n     style,\n     \"checks for fields in struct literals where shorthands could be used\""}, {"sha": "2cee3c14d7f30f89db58dc7797d8090d4fe6d3a1", "filename": "src/tools/clippy/clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -26,6 +26,7 @@ declare_clippy_lint! {\n     ///     pub fn internal_fn() { }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.44.0\"]\n     pub REDUNDANT_PUB_CRATE,\n     nursery,\n     \"Using `pub(crate)` visibility on items that are not crate visible due to the visibility of the module that contains them.\""}, {"sha": "b2bd0103d1114125f0849b91cb6a7abdb811e194", "filename": "src/tools/clippy/clippy_lints/src/redundant_slicing.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_slicing.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::get_parent_expr;\n use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::is_type_lang_item;\n-use clippy_utils::{get_parent_expr, in_macro};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind, LangItem, Mutability};\n@@ -34,6 +34,7 @@ declare_clippy_lint! {\n     ///     x\n     /// }\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub REDUNDANT_SLICING,\n     complexity,\n     \"redundant slicing of the whole range of a type\"\n@@ -43,7 +44,7 @@ declare_lint_pass!(RedundantSlicing => [REDUNDANT_SLICING]);\n \n impl LateLintPass<'_> for RedundantSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if in_macro(expr.span) {\n+        if expr.span.from_expansion() {\n             return;\n         }\n "}, {"sha": "ea5064217abe55ac47b63a6b91e9ef0369059547", "filename": "src/tools/clippy/clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -27,6 +27,7 @@ declare_clippy_lint! {\n     ///  const FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n     ///  static FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n     /// ```\n+    #[clippy::version = \"1.37.0\"]\n     pub REDUNDANT_STATIC_LIFETIMES,\n     style,\n     \"Using explicit `'static` lifetime for constants or statics when elision rules would allow omitting them.\""}, {"sha": "909d6971a5497305a7937bd7b70984e7ffb729b6", "filename": "src/tools/clippy/clippy_lints/src/ref_option_ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fref_option_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fref_option_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fref_option_ref.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -28,6 +28,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// let x: Option<&u32> = Some(&0u32);\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub REF_OPTION_REF,\n     pedantic,\n     \"use `Option<&T>` instead of `&Option<&T>`\""}, {"sha": "22ae7a291d00e5486e9ef8cb6a7b306aefda8257", "filename": "src/tools/clippy/clippy_lints/src/reference.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::in_macro;\n use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use if_chain::if_chain;\n@@ -31,6 +30,7 @@ declare_clippy_lint! {\n     /// let a = f(b);\n     /// let c = d;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub DEREF_ADDROF,\n     complexity,\n     \"use of `*&` or `*&mut` in an expression\"\n@@ -50,7 +50,7 @@ impl EarlyLintPass for DerefAddrOf {\n         if_chain! {\n             if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.kind;\n             if let ExprKind::AddrOf(_, ref mutability, ref addrof_target) = without_parens(deref_target).kind;\n-            if !in_macro(addrof_target.span);\n+            if !addrof_target.span.from_expansion();\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let sugg = if e.span.from_expansion() {\n@@ -125,6 +125,7 @@ declare_clippy_lint! {\n     /// # let point = Point(30, 20);\n     /// let x = point.0;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub REF_IN_DEREF,\n     complexity,\n     \"Use of reference in auto dereference expression.\""}, {"sha": "8e5983b4773a8cd418d2e26565f42ac2f14ac8a8", "filename": "src/tools/clippy/clippy_lints/src/regex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -22,6 +22,7 @@ declare_clippy_lint! {\n     /// ```ignore\n     /// Regex::new(\"|\")\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub INVALID_REGEX,\n     correctness,\n     \"invalid regular expressions\"\n@@ -46,6 +47,7 @@ declare_clippy_lint! {\n     /// ```ignore\n     /// Regex::new(\"^foobar\")\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub TRIVIAL_REGEX,\n     nursery,\n     \"trivial regular expressions\""}, {"sha": "b5dd2de633742813a9b72347cf1fbc2e09724a44", "filename": "src/tools/clippy/clippy_lints/src/repeat_once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,5 @@\n use clippy_utils::consts::{constant_context, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::in_macro;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n@@ -36,6 +35,7 @@ declare_clippy_lint! {\n     ///     let x = String::from(\"hello world\").clone();\n     /// }\n     /// ```\n+    #[clippy::version = \"1.47.0\"]\n     pub REPEAT_ONCE,\n     complexity,\n     \"using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \"\n@@ -49,7 +49,7 @@ impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n             if let ExprKind::MethodCall(path, _, [receiver, count], _) = &expr.kind;\n             if path.ident.name == sym!(repeat);\n             if constant_context(cx, cx.typeck_results()).expr(count) == Some(Constant::Int(1));\n-            if !in_macro(receiver.span);\n+            if !receiver.span.from_expansion();\n             then {\n                 let ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n                 if ty.is_str() {"}, {"sha": "494bc7dda18e76008aebf3460fb1d64b4a88d0ee", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{fn_def_id, in_macro, path_to_local_id};\n+use clippy_utils::{fn_def_id, path_to_local_id};\n use if_chain::if_chain;\n use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n@@ -37,6 +37,7 @@ declare_clippy_lint! {\n     ///     String::new()\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub LET_AND_RETURN,\n     style,\n     \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n@@ -62,6 +63,7 @@ declare_clippy_lint! {\n     ///     x\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NEEDLESS_RETURN,\n     style,\n     \"using a return statement like `return expr;` where an expression would suffice\"\n@@ -90,8 +92,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n             if !last_statement_borrows(cx, initexpr);\n             if !in_external_macro(cx.sess(), initexpr.span);\n             if !in_external_macro(cx.sess(), retexpr.span);\n-            if !in_external_macro(cx.sess(), local.span);\n-            if !in_macro(local.span);\n+            if !local.span.from_expansion();\n             then {\n                 span_lint_and_then(\n                     cx,"}, {"sha": "1bbaa104e60b17e8ab591e51c6c47fd27e45b258", "filename": "src/tools/clippy/clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -11,7 +11,7 @@ use std::collections::{BTreeMap, BTreeSet};\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// It lints if a struct has two method with same time:\n+    /// It lints if a struct has two methods with the same name:\n     /// one from a trait, another not from trait.\n     ///\n     /// ### Why is this bad?\n@@ -33,6 +33,7 @@ declare_clippy_lint! {\n     ///     fn foo(&self) {}\n     /// }\n     /// ```\n+    #[clippy::version = \"1.57.0\"]\n     pub SAME_NAME_METHOD,\n     restriction,\n     \"two method with same name\"\n@@ -99,7 +100,7 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n                                         cx,\n                                         SAME_NAME_METHOD,\n                                         *impl_span,\n-                                        \"method's name is same to an existing method in a trait\",\n+                                        \"method's name is the same as an existing method in a trait\",\n                                         |diag| {\n                                             diag.span_note(\n                                                 trait_method_span,\n@@ -138,7 +139,7 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n                                         cx,\n                                         SAME_NAME_METHOD,\n                                         impl_span,\n-                                        \"method's name is same to an existing method in a trait\",\n+                                        \"method's name is the same as an existing method in a trait\",\n                                         |diag| {\n                                             // TODO should we `span_note` on every trait?\n                                             // iterate on trait_spans?"}, {"sha": "b14f0518bdb77807751ee8041097a98ef96e10ff", "filename": "src/tools/clippy/clippy_lints/src/self_assignment.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_assignment.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -30,6 +30,7 @@ declare_clippy_lint! {\n     ///     a.y = a.y;\n     /// }\n     /// ```\n+    #[clippy::version = \"1.48.0\"]\n     pub SELF_ASSIGNMENT,\n     correctness,\n     \"explicit self-assignment\""}, {"sha": "d386663e49858eda7d123d04dd2bad7fb0de7a82", "filename": "src/tools/clippy/clippy_lints/src/self_named_constructors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -32,6 +32,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.55.0\"]\n     pub SELF_NAMED_CONSTRUCTORS,\n     style,\n     \"method should not have the same name as the type it is implemented for\"\n@@ -75,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for SelfNamedConstructors {\n             let self_id = cx.tcx.hir().local_def_id_to_hir_id(self_local_did);\n             if let Some(Node::Item(x)) = cx.tcx.hir().find(self_id);\n             let type_name = x.ident.name.as_str().to_lowercase();\n-            if impl_item.ident.name.as_str() == type_name || impl_item.ident.name.as_str().replace(\"_\", \"\") == type_name;\n+            if impl_item.ident.name.as_str() == type_name || impl_item.ident.name.as_str().replace('_', \"\") == type_name;\n \n             then {\n                 span_lint("}, {"sha": "0b3bbbc815580841e701e22d419e37e6ecc336e3", "filename": "src/tools/clippy/clippy_lints/src/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -29,6 +29,7 @@ declare_clippy_lint! {\n     ///     println!(\"Hello world\");\n     /// }\n     /// ```\n+    #[clippy::version = \"1.52.0\"]\n     pub SEMICOLON_IF_NOTHING_RETURNED,\n     pedantic,\n     \"add a semicolon if nothing is returned\"\n@@ -44,7 +45,7 @@ impl LateLintPass<'_> for SemicolonIfNothingReturned {\n             let t_expr = cx.typeck_results().expr_ty(expr);\n             if t_expr.is_unit();\n             if let snippet = snippet_with_macro_callsite(cx, expr.span, \"}\");\n-            if !snippet.ends_with('}');\n+            if !snippet.ends_with('}') && !snippet.ends_with(';');\n             if cx.sess().source_map().is_multiline(block.span);\n             then {\n                 // filter out the desugared `for` loop"}, {"sha": "a38b3c4ab69b70fe10c49e8d73712720661a6226", "filename": "src/tools/clippy/clippy_lints/src/serde_api.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fserde_api.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -15,6 +15,7 @@ declare_clippy_lint! {\n     /// ### Example\n     /// Implementing `Visitor::visit_string` but not\n     /// `Visitor::visit_str`.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SERDE_API_MISUSE,\n     correctness,\n     \"various things that will negatively affect your serde experience\""}, {"sha": "f6880af0cab28a068709a113ab03b81479db97c3", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -29,6 +29,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let y = &x; // use different variable name\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SHADOW_SAME,\n     restriction,\n     \"rebinding a name to itself, e.g., `let mut x = &mut x`\"\n@@ -55,6 +56,7 @@ declare_clippy_lint! {\n     /// let x = 2;\n     /// let y = x + 1;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SHADOW_REUSE,\n     restriction,\n     \"rebinding a name to an expression that re-uses the original value, e.g., `let x = x + 1`\"\n@@ -84,6 +86,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let w = z; // use different variable name\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SHADOW_UNRELATED,\n     restriction,\n     \"rebinding a name without even using the original value\"\n@@ -102,11 +105,16 @@ impl<'tcx> LateLintPass<'tcx> for Shadow {\n             PatKind::Binding(_, hir_id, ident, _) => (hir_id, ident),\n             _ => return,\n         };\n+\n+        if pat.span.desugaring_kind().is_some() {\n+            return;\n+        }\n+\n         if ident.span.from_expansion() || ident.span.is_dummy() {\n             return;\n         }\n-        let HirId { owner, local_id } = id;\n \n+        let HirId { owner, local_id } = id;\n         // get (or insert) the list of items for this owner and symbol\n         let data = self.bindings.last_mut().unwrap();\n         let items_with_name = data.entry(ident.name).or_default();"}, {"sha": "28d32203da9d73136f7b0c0a69a75af8690e8b21", "filename": "src/tools/clippy/clippy_lints/src/single_component_path_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n-use clippy_utils::in_macro;\n use rustc_ast::{ptr::P, Crate, Item, ItemKind, MacroDef, ModKind, UseTreeKind, VisibilityKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n@@ -28,6 +27,7 @@ declare_clippy_lint! {\n     ///     regex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\").unwrap();\n     /// }\n     /// ```\n+    #[clippy::version = \"1.43.0\"]\n     pub SINGLE_COMPONENT_PATH_IMPORTS,\n     style,\n     \"imports with single component path are redundant\"\n@@ -110,7 +110,7 @@ fn track_uses(\n     single_use_usages: &mut Vec<(Symbol, Span, bool)>,\n     macros: &mut Vec<Symbol>,\n ) {\n-    if in_macro(item.span) || item.vis.kind.is_pub() {\n+    if item.span.from_expansion() || item.vis.kind.is_pub() {\n         return;\n     }\n "}, {"sha": "df1e85afdd799a917fad95e4325de826050faa36", "filename": "src/tools/clippy/clippy_lints/src/size_of_in_element_count.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -29,6 +29,7 @@ declare_clippy_lint! {\n     /// let mut y = [2u8; SIZE];\n     /// unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n     /// ```\n+    #[clippy::version = \"1.50.0\"]\n     pub SIZE_OF_IN_ELEMENT_COUNT,\n     correctness,\n     \"using `size_of::<T>` or `size_of_val::<T>` where a count of elements of `T` is expected\""}, {"sha": "1ae772ef70b124ae31244efd4ca23cc2058b7e38", "filename": "src/tools/clippy/clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -36,6 +36,7 @@ declare_clippy_lint! {\n     /// let mut vec1 = vec![0; len];\n     /// let mut vec2 = vec![0; len];\n     /// ```\n+    #[clippy::version = \"1.32.0\"]\n     pub SLOW_VECTOR_INITIALIZATION,\n     perf,\n     \"slow vector initialization\""}, {"sha": "953d21e07a3908063d2ab59f13051ffa942f4f74", "filename": "src/tools/clippy/clippy_lints/src/stable_sort_primitive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstable_sort_primitive.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -28,6 +28,7 @@ declare_clippy_lint! {\n     /// let mut vec = vec![2, 1, 3];\n     /// vec.sort_unstable();\n     /// ```\n+    #[clippy::version = \"1.47.0\"]\n     pub STABLE_SORT_PRIMITIVE,\n     perf,\n     \"use of sort() when sort_unstable() is equivalent\""}, {"sha": "368274440d5dcb23551ed30be7d4a8ba5f808ece", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -31,6 +31,7 @@ declare_clippy_lint! {\n     /// x += \", World\";\n     /// x.push_str(\", World\");\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub STRING_ADD_ASSIGN,\n     pedantic,\n     \"using `x = x + ..` where x is a `String` instead of `push_str()`\"\n@@ -58,6 +59,7 @@ declare_clippy_lint! {\n     /// let x = \"Hello\".to_owned();\n     /// x + \", World\";\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub STRING_ADD,\n     restriction,\n     \"using `x + ..` where x is a `String` instead of `push_str()`\"\n@@ -102,6 +104,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let bs = b\"a byte string\";\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub STRING_LIT_AS_BYTES,\n     nursery,\n     \"calling `as_bytes` on a string literal instead of using a byte string literal\"\n@@ -125,6 +128,7 @@ declare_clippy_lint! {\n     /// ```rust,should_panic\n     /// &\"\u00d6lkanne\"[1..];\n     /// ```\n+    #[clippy::version = \"1.58.0\"]\n     pub STRING_SLICE,\n     restriction,\n     \"slicing a string\"\n@@ -227,6 +231,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let _ = &\"Hello World!\"[6..11];\n     /// ```\n+    #[clippy::version = \"1.50.0\"]\n     pub STRING_FROM_UTF8_AS_BYTES,\n     complexity,\n     \"casting string slices to byte slices and back\"\n@@ -371,6 +376,7 @@ declare_clippy_lint! {\n     /// // example code which does not raise clippy warning\n     /// let _ = \"str\".to_owned();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub STR_TO_STRING,\n     restriction,\n     \"using `to_string()` on a `&str`, which should be `to_owned()`\"\n@@ -420,6 +426,7 @@ declare_clippy_lint! {\n     /// let msg = String::from(\"Hello World\");\n     /// let _ = msg.clone();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub STRING_TO_STRING,\n     restriction,\n     \"using `to_string()` on a `String`, which should be `clone()`\""}, {"sha": "fee01fb0bd186db7999e817c8f3751e0d2cf6d82", "filename": "src/tools/clippy/clippy_lints/src/strlen_on_c_strings.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,14 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::in_macro;\n-use clippy_utils::paths;\n-use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::ty::{is_type_diagnostic_item, is_type_ref_to_diagnostic_item};\n+use clippy_utils::source::snippet_with_context;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::is_expr_unsafe;\n+use clippy_utils::{get_parent_node, match_libc_symbol};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir as hir;\n+use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, Node, UnsafeSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -31,6 +31,7 @@ declare_clippy_lint! {\n     /// let cstring = CString::new(\"foo\").expect(\"CString::new failed\");\n     /// let len = cstring.as_bytes().len();\n     /// ```\n+    #[clippy::version = \"1.55.0\"]\n     pub STRLEN_ON_C_STRINGS,\n     complexity,\n     \"using `libc::strlen` on a `CString` or `CStr` value, while `as_bytes().len()` or `to_bytes().len()` respectively can be used instead\"\n@@ -39,41 +40,47 @@ declare_clippy_lint! {\n declare_lint_pass!(StrlenOnCStrings => [STRLEN_ON_C_STRINGS]);\n \n impl LateLintPass<'tcx> for StrlenOnCStrings {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if in_macro(expr.span) {\n-            return;\n-        }\n-\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let hir::ExprKind::Call(func, [recv]) = expr.kind;\n-            if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = func.kind;\n-\n-            if (&paths::LIBC_STRLEN).iter().map(|x| Symbol::intern(x)).eq(\n-                path.segments.iter().map(|seg| seg.ident.name));\n-            if let hir::ExprKind::MethodCall(path, _, args, _) = recv.kind;\n-            if args.len() == 1;\n-            if !args.iter().any(|e| e.span.from_expansion());\n+            if !expr.span.from_expansion();\n+            if let ExprKind::Call(func, [recv]) = expr.kind;\n+            if let ExprKind::Path(path) = &func.kind;\n+            if let Some(did) = cx.qpath_res(path, func.hir_id).opt_def_id();\n+            if match_libc_symbol(cx, did, \"strlen\");\n+            if let ExprKind::MethodCall(path, _, [self_arg], _) = recv.kind;\n+            if !recv.span.from_expansion();\n             if path.ident.name == sym::as_ptr;\n             then {\n-                let cstring = &args[0];\n-                let ty = cx.typeck_results().expr_ty(cstring);\n-                let val_name = snippet_with_macro_callsite(cx, cstring.span, \"..\");\n-                let sugg = if is_type_diagnostic_item(cx, ty, sym::cstring_type){\n-                    format!(\"{}.as_bytes().len()\", val_name)\n-                } else if is_type_ref_to_diagnostic_item(cx, ty, sym::CStr){\n-                    format!(\"{}.to_bytes().len()\", val_name)\n+                let ctxt = expr.span.ctxt();\n+                let span = match get_parent_node(cx.tcx, expr.hir_id) {\n+                    Some(Node::Block(&Block {\n+                        rules: BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided), span, ..\n+                    }))\n+                    if span.ctxt() == ctxt && !is_expr_unsafe(cx, self_arg) => {\n+                        span\n+                    }\n+                    _ => expr.span,\n+                };\n+\n+                let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n+                let mut app = Applicability::MachineApplicable;\n+                let val_name = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n+                let method_name = if is_type_diagnostic_item(cx, ty, sym::cstring_type) {\n+                    \"as_bytes\"\n+                } else if is_type_diagnostic_item(cx, ty, sym::CStr) {\n+                    \"to_bytes\"\n                 } else {\n                     return;\n                 };\n \n                 span_lint_and_sugg(\n                     cx,\n                     STRLEN_ON_C_STRINGS,\n-                    expr.span,\n+                    span,\n                     \"using `libc::strlen` on a `CString` or `CStr` value\",\n-                    \"try this (you might also need to get rid of `unsafe` block in some cases):\",\n-                    sugg,\n-                    Applicability::Unspecified // Sometimes unnecessary `unsafe` block\n+                    \"try this\",\n+                    format!(\"{}.{}().len()\", val_name, method_name),\n+                    app,\n                 );\n             }\n         }"}, {"sha": "faf43fd9fc1ad536ff934eb4cd1d4d5f116e2931", "filename": "src/tools/clippy/clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -59,6 +59,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.50.0\"]\n     pub SUSPICIOUS_OPERATION_GROUPINGS,\n     nursery,\n     \"groupings of binary operations that look suspiciously like typos\""}, {"sha": "a3195de81d15c7415be7d5f95a3626ad1c0ba54a", "filename": "src/tools/clippy/clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -25,6 +25,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SUSPICIOUS_ARITHMETIC_IMPL,\n     suspicious,\n     \"suspicious use of operators in impl of arithmetic trait\"\n@@ -46,6 +47,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub SUSPICIOUS_OP_ASSIGN_IMPL,\n     suspicious,\n     \"suspicious use of operators in impl of OpAssign trait\""}, {"sha": "4c10b12437d7b5e3465c5e520529b626f5fc8a3a", "filename": "src/tools/clippy/clippy_lints/src/swap.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{can_mut_borrow_both, differing_macro_contexts, eq_expr_value};\n+use clippy_utils::{can_mut_borrow_both, differing_macro_contexts, eq_expr_value, std_or_core};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n@@ -35,6 +35,7 @@ declare_clippy_lint! {\n     /// let mut b = 2;\n     /// std::mem::swap(&mut a, &mut b);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub MANUAL_SWAP,\n     complexity,\n     \"manual swap of two variables\"\n@@ -60,6 +61,7 @@ declare_clippy_lint! {\n     /// # let mut b = 2;\n     /// std::mem::swap(&mut a, &mut b);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ALMOST_SWAPPED,\n     correctness,\n     \"`foo = bar; bar = foo` sequence\"\n@@ -113,6 +115,8 @@ fn generate_swap_warning(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>, spa\n \n     let first = Sugg::hir_with_applicability(cx, e1, \"..\", &mut applicability);\n     let second = Sugg::hir_with_applicability(cx, e2, \"..\", &mut applicability);\n+    let Some(sugg) = std_or_core(cx) else { return };\n+\n     span_lint_and_then(\n         cx,\n         MANUAL_SWAP,\n@@ -122,11 +126,11 @@ fn generate_swap_warning(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>, spa\n             diag.span_suggestion(\n                 span,\n                 \"try\",\n-                format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()),\n+                format!(\"{}::mem::swap({}, {})\", sugg, first.mut_addr(), second.mut_addr()),\n                 applicability,\n             );\n             if !is_xor_based {\n-                diag.note(\"or maybe you should use `std::mem::replace`?\");\n+                diag.note(&format!(\"or maybe you should use `{}::mem::replace`?\", sugg));\n             }\n         },\n     );\n@@ -187,26 +191,30 @@ fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n                 };\n \n                 let span = first.span.to(second.span);\n+                let Some(sugg) = std_or_core(cx) else { return };\n \n                 span_lint_and_then(cx,\n-                                   ALMOST_SWAPPED,\n-                                   span,\n-                                   &format!(\"this looks like you are trying to swap{}\", what),\n-                                   |diag| {\n-                                       if !what.is_empty() {\n-                                           diag.span_suggestion(\n-                                               span,\n-                                               \"try\",\n-                                               format!(\n-                                                   \"std::mem::swap({}, {})\",\n-                                                   lhs,\n-                                                   rhs,\n-                                               ),\n-                                               Applicability::MaybeIncorrect,\n-                                           );\n-                                           diag.note(\"or maybe you should use `std::mem::replace`?\");\n-                                       }\n-                                   });\n+                    ALMOST_SWAPPED,\n+                    span,\n+                    &format!(\"this looks like you are trying to swap{}\", what),\n+                    |diag| {\n+                        if !what.is_empty() {\n+                            diag.span_suggestion(\n+                                span,\n+                                \"try\",\n+                                format!(\n+                                    \"{}::mem::swap({}, {})\",\n+                                    sugg,\n+                                    lhs,\n+                                    rhs,\n+                                ),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                            diag.note(\n+                                &format!(\"or maybe you should use `{}::mem::replace`?\", sugg)\n+                            );\n+                        }\n+                    });\n             }\n         }\n     }"}, {"sha": "c9b4b245f4cc25019d130f05b33151bf80a81bdf", "filename": "src/tools/clippy/clippy_lints/src/tabs_in_doc_comments.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -51,6 +51,7 @@ declare_clippy_lint! {\n     ///    second_string: String,\n     ///}\n     /// ```\n+    #[clippy::version = \"1.41.0\"]\n     pub TABS_IN_DOC_COMMENTS,\n     style,\n     \"using tabs in doc comments is not recommended\""}, {"sha": "3766b8f8ed10d6aed395454ffcaa2f8e1ce12bd8", "filename": "src/tools/clippy/clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -17,6 +17,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// (0, 0).0 = 1\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub TEMPORARY_ASSIGNMENT,\n     complexity,\n     \"assignments to temporaries\""}, {"sha": "5eb58b47838298d493c0c4c88def60ec2e0182c0", "filename": "src/tools/clippy/clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -28,6 +28,7 @@ declare_clippy_lint! {\n     /// # let radix = 10;\n     /// let is_digit = c.is_digit(radix);\n     /// ```\n+    #[clippy::version = \"1.41.0\"]\n     pub TO_DIGIT_IS_SOME,\n     style,\n     \"`char.is_digit()` is clearer\""}, {"sha": "f8b6bdcd3e15ed413e98e9530045fa5bc5e6fc2a", "filename": "src/tools/clippy/clippy_lints/src/to_string_in_display.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -39,6 +39,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.48.0\"]\n     pub TO_STRING_IN_DISPLAY,\n     correctness,\n     \"`to_string` method used while implementing `Display` trait\""}, {"sha": "47c0a84cd4630ee97a94f3ebfc29f7987ea4e3ff", "filename": "src/tools/clippy/clippy_lints/src/trailing_empty_array.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -28,6 +28,7 @@ declare_clippy_lint! {\n     ///     last: [u32; 0],\n     /// }\n     /// ```\n+    #[clippy::version = \"1.58.0\"]\n     pub TRAILING_EMPTY_ARRAY,\n     nursery,\n     \"struct with a trailing zero-sized array but without `#[repr(C)]` or another `repr` attribute\""}, {"sha": "fb4abceac25e2ccab72372e32f4094c1d8742e81", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::{in_macro, SpanlessHash};\n+use clippy_utils::SpanlessHash;\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n@@ -28,6 +28,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// pub fn foo<T>(t: T) where T: Copy + Clone {}\n     /// ```\n+    #[clippy::version = \"1.38.0\"]\n     pub TYPE_REPETITION_IN_BOUNDS,\n     pedantic,\n     \"Types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\"\n@@ -57,6 +58,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// fn func<T>(arg: T) where T: Clone + Default {}\n     /// ```\n+    #[clippy::version = \"1.47.0\"]\n     pub TRAIT_DUPLICATION_IN_BOUNDS,\n     pedantic,\n     \"Check if the same trait bounds are specified twice during a function declaration\"\n@@ -93,7 +95,7 @@ fn get_trait_res_span_from_bound(bound: &GenericBound<'_>) -> Option<(Res, Span)\n \n impl TraitBounds {\n     fn check_type_repetition(self, cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n-        if in_macro(gen.span) {\n+        if gen.span.from_expansion() {\n             return;\n         }\n         let hash = |ty| -> u64 {\n@@ -107,7 +109,7 @@ impl TraitBounds {\n             if_chain! {\n                 if let WherePredicate::BoundPredicate(ref p) = bound;\n                 if p.bounds.len() as u64 <= self.max_trait_bounds;\n-                if !in_macro(p.span);\n+                if !p.span.from_expansion();\n                 let h = hash(p.bounded_ty);\n                 if let Some(ref v) = map.insert(h, p.bounds.iter().collect::<Vec<_>>());\n \n@@ -151,7 +153,7 @@ impl TraitBounds {\n }\n \n fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n-    if in_macro(gen.span) || gen.params.is_empty() || gen.where_clause.predicates.is_empty() {\n+    if gen.span.from_expansion() || gen.params.is_empty() || gen.where_clause.predicates.is_empty() {\n         return;\n     }\n \n@@ -170,7 +172,7 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n     for predicate in gen.where_clause.predicates {\n         if_chain! {\n             if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n-            if !in_macro(bound_predicate.span);\n+            if !bound_predicate.span.from_expansion();\n             if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n             if let Some(segment) = segments.first();\n             if let Some(trait_resolutions_direct) = map.get(&segment.ident);"}, {"sha": "3ad4ec74bf51c1bdde228e00f451c3685fa92e31", "filename": "src/tools/clippy/clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -36,6 +36,7 @@ declare_clippy_lint! {\n     /// ```ignore\n     /// let ptr: *const T = core::intrinsics::transmute('x')\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub WRONG_TRANSMUTE,\n     correctness,\n     \"transmutes that are confusing at best, undefined behaviour at worst and always useless\"\n@@ -55,6 +56,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// core::intrinsics::transmute(t); // where the result type is the same as `t`'s\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub USELESS_TRANSMUTE,\n     nursery,\n     \"transmutes that have the same to and from types or could be a cast/coercion\"\n@@ -80,6 +82,7 @@ declare_clippy_lint! {\n     /// # let p: *const [i32] = &[];\n     /// p as *const [u16];\n     /// ```\n+    #[clippy::version = \"1.47.0\"]\n     pub TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n     complexity,\n     \"transmutes that could be a pointer cast\"\n@@ -98,6 +101,7 @@ declare_clippy_lint! {\n     /// core::intrinsics::transmute(t) // where the result type is the same as\n     ///                                // `*t` or `&t`'s\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub CROSSPOINTER_TRANSMUTE,\n     complexity,\n     \"transmutes that have to or from types that are a pointer to the other\"\n@@ -125,6 +129,7 @@ declare_clippy_lint! {\n     /// // can be written:\n     /// let _: &T = &*p;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub TRANSMUTE_PTR_TO_REF,\n     complexity,\n     \"transmutes from a pointer to a reference type\"\n@@ -158,6 +163,7 @@ declare_clippy_lint! {\n     /// // should be:\n     /// let _ = std::char::from_u32(x).unwrap();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub TRANSMUTE_INT_TO_CHAR,\n     complexity,\n     \"transmutes from an integer to a `char`\"\n@@ -191,6 +197,7 @@ declare_clippy_lint! {\n     /// // should be:\n     /// let _ = std::str::from_utf8(b).unwrap();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub TRANSMUTE_BYTES_TO_STR,\n     complexity,\n     \"transmutes from a `&[u8]` to a `&str`\"\n@@ -213,6 +220,7 @@ declare_clippy_lint! {\n     /// // should be:\n     /// let _: bool = x != 0;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub TRANSMUTE_INT_TO_BOOL,\n     complexity,\n     \"transmutes from an integer to a `bool`\"\n@@ -235,6 +243,7 @@ declare_clippy_lint! {\n     /// // should be:\n     /// let _: f32 = f32::from_bits(1_u32);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub TRANSMUTE_INT_TO_FLOAT,\n     complexity,\n     \"transmutes from an integer to a float\"\n@@ -257,6 +266,7 @@ declare_clippy_lint! {\n     /// // should be:\n     /// let _: u32 = 1f32.to_bits();\n     /// ```\n+    #[clippy::version = \"1.41.0\"]\n     pub TRANSMUTE_FLOAT_TO_INT,\n     complexity,\n     \"transmutes from a float to an integer\"\n@@ -279,6 +289,7 @@ declare_clippy_lint! {\n     /// // should be\n     /// let x: [u8; 8] = 0i64.to_ne_bytes();\n     /// ```\n+    #[clippy::version = \"1.58.0\"]\n     pub TRANSMUTE_NUM_TO_BYTES,\n     complexity,\n     \"transmutes from a number to an array of `u8`\"\n@@ -306,6 +317,7 @@ declare_clippy_lint! {\n     /// let _ = ptr as *const f32;\n     /// let _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub TRANSMUTE_PTR_TO_PTR,\n     pedantic,\n     \"transmutes from a pointer to a pointer / a reference to a reference\"\n@@ -337,6 +349,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// vec![2_u16].into_iter().map(u32::from).collect::<Vec<_>>();\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub UNSOUND_COLLECTION_TRANSMUTE,\n     correctness,\n     \"transmute between collections of layout-incompatible types\""}, {"sha": "7939dfedc3a2b4fb6d39555f29a3596828895861", "filename": "src/tools/clippy/clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -25,6 +25,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let null_ref: &u64 = unsafe { std::mem::transmute(0 as *const u64) };\n     /// ```\n+    #[clippy::version = \"1.35.0\"]\n     pub TRANSMUTING_NULL,\n     correctness,\n     \"transmutes from a null pointer to a reference, which is undefined behavior\""}, {"sha": "e0e7ec9a452c139b19d4aeabe0dc99d4981935bb", "filename": "src/tools/clippy/clippy_lints/src/try_err.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n+use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, get_parent_expr, in_macro, is_lang_ctor, match_def_path, paths};\n+use clippy_utils::{get_parent_expr, is_lang_ctor, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::ResultErr;\n@@ -10,7 +10,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n+use rustc_span::{hygiene, sym};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -41,6 +41,7 @@ declare_clippy_lint! {\n     ///     Ok(0)\n     /// }\n     /// ```\n+    #[clippy::version = \"1.38.0\"]\n     pub TRY_ERR,\n     style,\n     \"return errors explicitly rather than hiding them behind a `?`\"\n@@ -93,15 +94,9 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n                 };\n \n                 let expr_err_ty = cx.typeck_results().expr_ty(err_arg);\n-                let differing_contexts = differing_macro_contexts(expr.span, err_arg.span);\n-\n-                let origin_snippet = if in_macro(expr.span) && in_macro(err_arg.span) && differing_contexts {\n-                    snippet(cx, err_arg.span.ctxt().outer_expn_data().call_site, \"_\")\n-                } else if err_arg.span.from_expansion() && !in_macro(expr.span) {\n-                    snippet_with_macro_callsite(cx, err_arg.span, \"_\")\n-                } else {\n-                    snippet(cx, err_arg.span, \"_\")\n-                };\n+                let span = hygiene::walk_chain(err_arg.span, try_arg.span.ctxt());\n+                let mut applicability = Applicability::MachineApplicable;\n+                let origin_snippet = snippet_with_applicability(cx, span, \"_\", &mut applicability);\n                 let ret_prefix = if get_parent_expr(cx, expr).map_or(false, |e| matches!(e.kind, ExprKind::Ret(_))) {\n                     \"\" // already returns\n                 } else {\n@@ -120,7 +115,7 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n                     \"returning an `Err(_)` with the `?` operator\",\n                     \"try this\",\n                     suggestion,\n-                    Applicability::MachineApplicable\n+                    applicability,\n                 );\n             }\n         }"}, {"sha": "5a7ef760a3025dcbf890a3175fe1d31200fed05c", "filename": "src/tools/clippy/clippy_lints/src/types/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -43,6 +43,7 @@ declare_clippy_lint! {\n     ///     values: Vec<Foo>,\n     /// }\n     /// ```\n+    #[clippy::version = \"1.57.0\"]\n     pub BOX_COLLECTION,\n     perf,\n     \"usage of `Box<Vec<T>>`, vector elements are already on the heap\"\n@@ -75,6 +76,7 @@ declare_clippy_lint! {\n     ///     values: Vec<i32>,\n     /// }\n     /// ```\n+    #[clippy::version = \"1.33.0\"]\n     pub VEC_BOX,\n     complexity,\n     \"usage of `Vec<Box<T>>` where T: Sized, vector elements are already on the heap\"\n@@ -113,6 +115,7 @@ declare_clippy_lint! {\n     ///     Contents::None\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub OPTION_OPTION,\n     pedantic,\n     \"usage of `Option<Option<T>>`\"\n@@ -152,6 +155,7 @@ declare_clippy_lint! {\n     /// # use std::collections::LinkedList;\n     /// let x: LinkedList<usize> = LinkedList::new();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub LINKEDLIST,\n     pedantic,\n     \"usage of LinkedList, usually a vector is faster, or a more specialized data structure like a `VecDeque`\"\n@@ -176,6 +180,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// fn foo(bar: &T) { ... }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub BORROWED_BOX,\n     complexity,\n     \"a borrow of a boxed type\"\n@@ -200,6 +205,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// fn foo(bar: &usize) {}\n     /// ```\n+    #[clippy::version = \"1.44.0\"]\n     pub REDUNDANT_ALLOCATION,\n     perf,\n     \"redundant allocation\"\n@@ -234,6 +240,7 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// fn foo(interned: Rc<str>) { ... }\n     /// ```\n+    #[clippy::version = \"1.48.0\"]\n     pub RC_BUFFER,\n     restriction,\n     \"shared ownership of a buffer type\"\n@@ -255,6 +262,7 @@ declare_clippy_lint! {\n     ///     inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub TYPE_COMPLEXITY,\n     complexity,\n     \"usage of very complex types that might be better factored into `type` definitions\"\n@@ -287,6 +295,7 @@ declare_clippy_lint! {\n     /// use std::cell::RefCell\n     /// fn foo(interned: Rc<RefCell<i32>>) { ... }\n     /// ```\n+    #[clippy::version = \"1.55.0\"]\n     pub RC_MUTEX,\n     restriction,\n     \"usage of `Rc<Mutex<T>>`\""}, {"sha": "ccc49caf47c7a581dbc3ead8e898c21a24d3cdb8", "filename": "src/tools/clippy/clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::is_lint_allowed;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet};\n-use clippy_utils::{in_macro, is_lint_allowed};\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, HirId, Local, UnsafeSource};\n@@ -39,6 +39,7 @@ declare_clippy_lint! {\n     /// // Safety: references are guaranteed to be non-null.\n     /// let ptr = unsafe { NonNull::new_unchecked(a) };\n     /// ```\n+    #[clippy::version = \"1.58.0\"]\n     pub UNDOCUMENTED_UNSAFE_BLOCKS,\n     restriction,\n     \"creating an unsafe block without explaining why it is safe\"\n@@ -134,12 +135,12 @@ impl UndocumentedUnsafeBlocks {\n \n         let enclosing_scope_span = map.opt_span(enclosing_hir_id)?;\n \n-        let between_span = if in_macro(block_span) {\n+        let between_span = if block_span.from_expansion() {\n             self.macro_expansion = true;\n-            enclosing_scope_span.with_hi(block_span.hi())\n+            enclosing_scope_span.with_hi(block_span.hi()).source_callsite()\n         } else {\n             self.macro_expansion = false;\n-            enclosing_scope_span.to(block_span)\n+            enclosing_scope_span.to(block_span).source_callsite()\n         };\n \n         let file_name = source_map.span_to_filename(between_span);\n@@ -149,6 +150,8 @@ impl UndocumentedUnsafeBlocks {\n         let lex_end = (between_span.hi().0 - source_file.start_pos.0) as usize;\n         let src_str = source_file.src.as_ref()?[lex_start..lex_end].to_string();\n \n+        let source_start_pos = source_file.start_pos.0 as usize + lex_start;\n+\n         let mut pos = 0;\n         let mut comment = false;\n \n@@ -171,7 +174,7 @@ impl UndocumentedUnsafeBlocks {\n                     if comment {\n                         // Get the line number of the \"comment\" (really wherever the trailing whitespace ended)\n                         let comment_line_num = source_file\n-                            .lookup_file_pos_with_col_display(BytePos((lex_start + pos).try_into().unwrap()))\n+                            .lookup_file_pos(BytePos((source_start_pos + pos).try_into().unwrap()))\n                             .0;\n                         // Find the block/local's line number\n                         let block_line_num = tcx.sess.source_map().lookup_char_pos(block_span.lo()).line;"}, {"sha": "c58fa67a023881c6a74255f5adb80b6bc9204761", "filename": "src/tools/clippy/clippy_lints/src/undropped_manually_drops.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundropped_manually_drops.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -28,6 +28,7 @@ declare_clippy_lint! {\n     ///     std::mem::ManuallyDrop::drop(&mut std::mem::ManuallyDrop::new(S));\n     /// }\n     /// ```\n+    #[clippy::version = \"1.49.0\"]\n     pub UNDROPPED_MANUALLY_DROPS,\n     correctness,\n     \"use of safe `std::mem::drop` function to drop a std::mem::ManuallyDrop, which will not drop the inner value\""}, {"sha": "afd7be89a4e289c94764d31c0eb27f12de4ff5de", "filename": "src/tools/clippy/clippy_lints/src/unicode.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funicode.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -20,14 +20,15 @@ declare_clippy_lint! {\n     /// ### Example\n     /// You don't see it, but there may be a zero-width space or soft hyphen\n     /// some\u00adwhere in this text.\n+    #[clippy::version = \"1.49.0\"]\n     pub INVISIBLE_CHARACTERS,\n     correctness,\n     \"using an invisible character in a string literal, which is confusing\"\n }\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for non-ASCII characters in string literals.\n+    /// Checks for non-ASCII characters in string and char literals.\n     ///\n     /// ### Why is this bad?\n     /// Yeah, we know, the 90's called and wanted their charset\n@@ -44,6 +45,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let x = String::from(\"\\u{20ac}\");\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub NON_ASCII_LITERAL,\n     restriction,\n     \"using any literal non-ASCII chars in a string literal instead of using the `\\\\u` escape\"\n@@ -62,6 +64,7 @@ declare_clippy_lint! {\n     /// ### Example\n     /// You may not see it, but \"a\u0300\"\" and \"\u00e0\"\" aren't the same string. The\n     /// former when escaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNICODE_NOT_NFC,\n     pedantic,\n     \"using a Unicode literal not in NFC normal form (see [Unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\"\n@@ -72,7 +75,7 @@ declare_lint_pass!(Unicode => [INVISIBLE_CHARACTERS, NON_ASCII_LITERAL, UNICODE_\n impl LateLintPass<'_> for Unicode {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n         if let ExprKind::Lit(ref lit) = expr.kind {\n-            if let LitKind::Str(_, _) = lit.node {\n+            if let LitKind::Str(_, _) | LitKind::Char(_) = lit.node {\n                 check_str(cx, lit.span, expr.hir_id);\n             }\n         }\n@@ -103,9 +106,9 @@ fn check_str(cx: &LateContext<'_>, span: Span, id: HirId) {\n             \"invisible character detected\",\n             \"consider replacing the string with\",\n             string\n-                .replace(\"\\u{200B}\", \"\\\\u{200B}\")\n-                .replace(\"\\u{ad}\", \"\\\\u{AD}\")\n-                .replace(\"\\u{2060}\", \"\\\\u{2060}\"),\n+                .replace('\\u{200B}', \"\\\\u{200B}\")\n+                .replace('\\u{ad}', \"\\\\u{AD}\")\n+                .replace('\\u{2060}', \"\\\\u{2060}\"),\n             Applicability::MachineApplicable,\n         );\n     }"}, {"sha": "46cc76b150e4a20e5f4b63dd85874c38ce57b987", "filename": "src/tools/clippy/clippy_lints/src/uninit_vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -52,6 +52,7 @@ declare_clippy_lint! {\n     ///    // perform initialization with `remaining`\n     ///    vec.set_len(...);  // Safe to call `set_len()` on initialized part\n     ///    ```\n+    #[clippy::version = \"1.58.0\"]\n     pub UNINIT_VEC,\n     correctness,\n     \"Vec with uninitialized data\""}, {"sha": "26b4e0f58a870beabd074916fad606a8ceb862da", "filename": "src/tools/clippy/clippy_lints/src/unit_hash.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_hash.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -39,6 +39,7 @@ declare_clippy_lint! {\n     /// \tWithValue(x) => x.hash(&mut state),\n     /// }\n     /// ```\n+    #[clippy::version = \"1.58.0\"]\n     pub UNIT_HASH,\n     correctness,\n     \"hashing a unit value, which does nothing\""}, {"sha": "9fb8f2368994a89a2db0dffd348884ea204c5c73", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -30,6 +30,7 @@ declare_clippy_lint! {\n     /// let mut twins = vec!((1, 1), (2, 2));\n     /// twins.sort_by_key(|x| { x.1; });\n     /// ```\n+    #[clippy::version = \"1.47.0\"]\n     pub UNIT_RETURN_EXPECTING_ORD,\n     correctness,\n     \"fn arguments of type Fn(...) -> Ord returning the unit type ().\""}, {"sha": "d9f5b53b413a03dd5734a2edadfa202f7bf7ee98", "filename": "src/tools/clippy/clippy_lints/src/unit_types/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Fmod.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -21,6 +21,7 @@ declare_clippy_lint! {\n     ///     1;\n     /// };\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub LET_UNIT_VALUE,\n     pedantic,\n     \"creating a `let` binding to a value of unit type, which usually can't be used afterwards\"\n@@ -68,6 +69,7 @@ declare_clippy_lint! {\n     /// assert_eq!({ foo(); }, { bar(); });\n     /// ```\n     /// will always succeed\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNIT_CMP,\n     correctness,\n     \"comparing unit values\"\n@@ -88,6 +90,7 @@ declare_clippy_lint! {\n     ///     baz(a);\n     /// })\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNIT_ARG,\n     complexity,\n     \"passing unit to a function\""}, {"sha": "0bcafde658a43046760479f766987764f8c45902", "filename": "src/tools/clippy/clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -24,6 +24,7 @@ declare_clippy_lint! {\n     ///     // ...\n     /// }\n     /// ```\n+    #[clippy::version = \"1.44.0\"]\n     pub FN_ADDRESS_COMPARISONS,\n     correctness,\n     \"comparison with an address of a function item\"\n@@ -47,6 +48,7 @@ declare_clippy_lint! {\n     ///     ...\n     /// }\n     /// ```\n+    #[clippy::version = \"1.44.0\"]\n     pub VTABLE_ADDRESS_COMPARISONS,\n     correctness,\n     \"comparison with an address of a trait vtable\""}, {"sha": "839a4bdab09de36e5a32b4ad335fc66382233be1", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_self_imports.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_self_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_self_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_self_imports.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -26,6 +26,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// use std::io;\n     /// ```\n+    #[clippy::version = \"1.53.0\"]\n     pub UNNECESSARY_SELF_IMPORTS,\n     restriction,\n     \"imports ending in `::{self}`, which can be omitted\""}, {"sha": "d024577f485317b55bb54acbc35f571bff8bf6d7", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -39,6 +39,7 @@ declare_clippy_lint! {\n     /// # let mut vec: Vec<A> = Vec::new();\n     /// vec.sort_by_key(|a| a.foo());\n     /// ```\n+    #[clippy::version = \"1.46.0\"]\n     pub UNNECESSARY_SORT_BY,\n     complexity,\n     \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\""}, {"sha": "1728533f18b858caeb6b9814f37ff2dcdbbc5e78", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n-use clippy_utils::{contains_return, in_macro, is_lang_ctor, return_ty, visitors::find_all_ret_expressions};\n+use clippy_utils::{contains_return, is_lang_ctor, return_ty, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n@@ -49,6 +49,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"1.50.0\"]\n     pub UNNECESSARY_WRAPS,\n     pedantic,\n     \"functions that only return `Ok` or `Some`\"\n@@ -116,7 +117,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n         let mut suggs = Vec::new();\n         let can_sugg = find_all_ret_expressions(cx, &body.value, |ret_expr| {\n             if_chain! {\n-                if !in_macro(ret_expr.span);\n+                if !ret_expr.span.from_expansion();\n                 // Check if a function call.\n                 if let ExprKind::Call(func, [arg]) = ret_expr.kind;\n                 // Check if OPTION_SOME or RESULT_OK, depending on return type."}, {"sha": "0bd151fed91cc57c50c2b0c8ca3a93dd09dd4880", "filename": "src/tools/clippy/clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -39,6 +39,7 @@ declare_clippy_lint! {\n     ///     if let Some(0 | 2) = Some(0) {}\n     /// }\n     /// ```\n+    #[clippy::version = \"1.46.0\"]\n     pub UNNESTED_OR_PATTERNS,\n     pedantic,\n     \"unnested or-patterns, e.g., `Foo(Bar) | Foo(Baz) instead of `Foo(Bar | Baz)`\""}, {"sha": "44b1989dbc68a4a4eb30b01491b0bc018546235d", "filename": "src/tools/clippy/clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -21,6 +21,7 @@ declare_clippy_lint! {\n     /// extern crate crossbeam;\n     /// use crossbeam::{spawn_unsafe as spawn};\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNSAFE_REMOVED_FROM_NAME,\n     style,\n     \"`unsafe` removed from API names on import\""}, {"sha": "1ccb78425c29af05f3415a393603ad08be412012", "filename": "src/tools/clippy/clippy_lints/src/unused_async.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_async.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -29,6 +29,7 @@ declare_clippy_lint! {\n     /// }\n     /// let number_future = async { get_random_number_improved() };\n     /// ```\n+    #[clippy::version = \"1.54.0\"]\n     pub UNUSED_ASYNC,\n     pedantic,\n     \"finds async functions with no await statements\""}, {"sha": "d4b5c9770a271200bb0efc997fe7b77a843bc8cc", "filename": "src/tools/clippy/clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -29,6 +29,7 @@ declare_clippy_lint! {\n     ///     Ok(())\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNUSED_IO_AMOUNT,\n     correctness,\n     \"unused written/read amount\""}, {"sha": "aa105580ee354833284b04ca99d6638183018a9b", "filename": "src/tools/clippy/clippy_lints/src/unused_self.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -29,6 +29,7 @@ declare_clippy_lint! {\n     ///     fn method() {}\n     /// }\n     /// ```\n+    #[clippy::version = \"1.40.0\"]\n     pub UNUSED_SELF,\n     pedantic,\n     \"methods that contain a `self` argument but don't use it\""}, {"sha": "48c17fa2a40b25c543143a12dcd3f38a9f2bb633", "filename": "src/tools/clippy/clippy_lints/src/unused_unit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_unit.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -28,6 +28,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// fn return_unit() {}\n     /// ```\n+    #[clippy::version = \"1.31.0\"]\n     pub UNUSED_UNIT,\n     style,\n     \"needless unit expression\""}, {"sha": "71771aae44b2172c8dc0175474c2f8279d5ef77e", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -39,6 +39,7 @@ declare_clippy_lint! {\n     ///     do_something_with(value)\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub UNNECESSARY_UNWRAP,\n     complexity,\n     \"checks for calls of `unwrap[_err]()` that cannot fail\"\n@@ -65,6 +66,7 @@ declare_clippy_lint! {\n     /// ```\n     ///\n     /// This code will always panic. The if condition should probably be inverted.\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub PANICKING_UNWRAP,\n     correctness,\n     \"checks for calls of `unwrap[_err]()` that will always fail\"\n@@ -229,8 +231,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let ExprKind::MethodCall(method_name, _, args, _) = expr.kind;\n-                if let Some(id) = path_to_local(&args[0]);\n+                if let ExprKind::MethodCall(method_name, _, [self_arg, ..], _) = expr.kind;\n+                if let Some(id) = path_to_local(self_arg);\n                 if [sym::unwrap, sym::expect, sym!(unwrap_err)].contains(&method_name.ident.name);\n                 let call_to_unwrap = [sym::unwrap, sym::expect].contains(&method_name.ident.name);\n                 if let Some(unwrappable) = self.unwrappables.iter()"}, {"sha": "994df85cb8ac4f7c5130275884a75f12e34491f6", "filename": "src/tools/clippy/clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -51,6 +51,7 @@ declare_clippy_lint! {\n     ///     Ok(())\n     /// }\n     /// ```\n+    #[clippy::version = \"1.48.0\"]\n     pub UNWRAP_IN_RESULT,\n     restriction,\n     \"functions of type `Result<..>` or `Option`<...> that contain `expect()` or `unwrap()`\""}, {"sha": "4773e35076057e0bf32a65a507d5e9c71faf4d79", "filename": "src/tools/clippy/clippy_lints/src/upper_case_acronyms.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -33,6 +33,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// struct HttpResponse;\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub UPPER_CASE_ACRONYMS,\n     style,\n     \"capitalized acronyms are against the naming convention\""}, {"sha": "059f7f647f88f0e0f486a400a4608b6fbf422884", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::ty::same_type_and_consts;\n-use clippy_utils::{in_macro, meets_msrv, msrvs};\n+use clippy_utils::{meets_msrv, msrvs};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -51,6 +51,7 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub USE_SELF,\n     nursery,\n     \"unnecessary structure name repetition whereas `Self` is applicable\"\n@@ -197,7 +198,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n \n     fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) {\n         if_chain! {\n-            if !in_macro(hir_ty.span);\n+            if !hir_ty.span.from_expansion();\n             if meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS);\n             if let Some(&StackItem::Check {\n                 impl_id,\n@@ -214,8 +215,8 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             };\n             if same_type_and_consts(ty, cx.tcx.type_of(impl_id));\n             let hir = cx.tcx.hir();\n-            let id = hir.get_parent_node(hir_ty.hir_id);\n-            if !hir.opt_span(id).map_or(false, in_macro);\n+            // prevents false positive on `#[derive(serde::Deserialize)]`\n+            if !hir.span(hir.get_parent_node(hir_ty.hir_id)).in_derive_expansion();\n             then {\n                 span_lint(cx, hir_ty.span);\n             }\n@@ -224,7 +225,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n \n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if !in_macro(expr.span);\n+            if !expr.span.from_expansion();\n             if meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS);\n             if let Some(&StackItem::Check { impl_id, .. }) = self.stack.last();\n             if cx.typeck_results().expr_ty(expr) == cx.tcx.type_of(impl_id);"}, {"sha": "0e4b32541c97785672a65a8e08eb86eda3ee7135", "filename": "src/tools/clippy/clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -28,6 +28,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let s: String = format!(\"hello\");\n     /// ```\n+    #[clippy::version = \"1.45.0\"]\n     pub USELESS_CONVERSION,\n     complexity,\n     \"calls to `Into`, `TryInto`, `From`, `TryFrom`, or `IntoIter` which perform useless conversions to the same type\""}, {"sha": "d20bf3413185c1aa38cf6bed8a77af25a58d4759", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 557, "deletions": 602, "changes": 1159, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,16 +1,16 @@\n //! A group of attributes that can be attached to Rust code in order\n //! to generate a clippy lint detecting said code automatically.\n \n-use clippy_utils::get_attr;\n+use clippy_utils::{get_attr, higher};\n use rustc_ast::ast::{LitFloatType, LitKind};\n-use rustc_ast::walk_list;\n+use rustc_ast::LitIntType;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, Pat, PatKind, QPath, Stmt, StmtKind, TyKind};\n+use rustc_hir::{ExprKind, FnRetTy, HirId, Lit, PatKind, QPath, StmtKind, TyKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::{Ident, Symbol};\n+use std::fmt::{Display, Formatter, Write as _};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -53,6 +53,42 @@ declare_clippy_lint! {\n \n declare_lint_pass!(Author => [LINT_AUTHOR]);\n \n+/// Writes a line of output with indentation added\n+macro_rules! out {\n+    ($($t:tt)*) => {\n+        println!(\"    {}\", format_args!($($t)*))\n+    };\n+}\n+\n+/// The variables passed in are replaced with `&Binding`s where the `value` field is set\n+/// to the original value of the variable. The `name` field is set to the name of the variable\n+/// (using `stringify!`) and is adjusted to avoid duplicate names.\n+/// Note that the `Binding` may be printed directly to output the `name`.\n+macro_rules! bind {\n+    ($self:ident $(, $name:ident)+) => {\n+        $(let $name = & $self.bind(stringify!($name), $name);)+\n+    };\n+}\n+\n+/// Transforms the given `Option<T>` varibles into `OptionPat<Binding<T>>`.\n+/// This displays as `Some($name)` or `None` when printed. The name of the inner binding\n+/// is set to the name of the variable passed to the macro.\n+macro_rules! opt_bind {\n+    ($self:ident $(, $name:ident)+) => {\n+        $(let $name = OptionPat::new($name.map(|o| $self.bind(stringify!($name), o)));)+\n+    };\n+}\n+\n+/// Creates a `Binding` that accesses the field of an existing `Binding`\n+macro_rules! field {\n+    ($binding:ident.$field:ident) => {\n+        &Binding {\n+            name: $binding.name.to_string() + stringify!(.$field),\n+            value: $binding.value.$field,\n+        }\n+    };\n+}\n+\n fn prelude() {\n     println!(\"if_chain! {{\");\n }\n@@ -66,705 +102,624 @@ fn done() {\n \n impl<'tcx> LateLintPass<'tcx> for Author {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        if !has_attr(cx, item.hir_id()) {\n-            return;\n-        }\n-        prelude();\n-        PrintVisitor::new(\"item\").visit_item(item);\n-        done();\n+        check_item(cx, item.hir_id());\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n-        if !has_attr(cx, item.hir_id()) {\n-            return;\n-        }\n-        prelude();\n-        PrintVisitor::new(\"item\").visit_impl_item(item);\n-        done();\n+        check_item(cx, item.hir_id());\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n-        if !has_attr(cx, item.hir_id()) {\n-            return;\n-        }\n-        prelude();\n-        PrintVisitor::new(\"item\").visit_trait_item(item);\n-        done();\n+        check_item(cx, item.hir_id());\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext<'tcx>, var: &'tcx hir::Variant<'_>) {\n-        if !has_attr(cx, var.id) {\n-            return;\n-        }\n-        prelude();\n-        let parent_hir_id = cx.tcx.hir().get_parent_node(var.id);\n-        PrintVisitor::new(\"var\").visit_variant(var, &hir::Generics::empty(), parent_hir_id);\n-        done();\n-    }\n-\n-    fn check_field_def(&mut self, cx: &LateContext<'tcx>, field: &'tcx hir::FieldDef<'_>) {\n-        if !has_attr(cx, field.hir_id) {\n-            return;\n-        }\n-        prelude();\n-        PrintVisitor::new(\"field\").visit_field_def(field);\n-        done();\n+    fn check_arm(&mut self, cx: &LateContext<'tcx>, arm: &'tcx hir::Arm<'_>) {\n+        check_node(cx, arm.hir_id, |v| {\n+            v.arm(&v.bind(\"arm\", arm));\n+        });\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if !has_attr(cx, expr.hir_id) {\n-            return;\n-        }\n-        prelude();\n-        PrintVisitor::new(\"expr\").visit_expr(expr);\n-        done();\n-    }\n-\n-    fn check_arm(&mut self, cx: &LateContext<'tcx>, arm: &'tcx hir::Arm<'_>) {\n-        if !has_attr(cx, arm.hir_id) {\n-            return;\n-        }\n-        prelude();\n-        PrintVisitor::new(\"arm\").visit_arm(arm);\n-        done();\n+        check_node(cx, expr.hir_id, |v| {\n+            v.expr(&v.bind(\"expr\", expr));\n+        });\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n-        if !has_attr(cx, stmt.hir_id) {\n-            return;\n-        }\n         match stmt.kind {\n             StmtKind::Expr(e) | StmtKind::Semi(e) if has_attr(cx, e.hir_id) => return,\n             _ => {},\n         }\n+        check_node(cx, stmt.hir_id, |v| {\n+            v.stmt(&v.bind(\"stmt\", stmt));\n+        });\n+    }\n+}\n+\n+fn check_item(cx: &LateContext<'_>, hir_id: HirId) {\n+    let hir = cx.tcx.hir();\n+    if let Some(body_id) = hir.maybe_body_owned_by(hir_id) {\n+        check_node(cx, hir_id, |v| {\n+            v.expr(&v.bind(\"expr\", &hir.body(body_id).value));\n+        });\n+    }\n+}\n+\n+fn check_node(cx: &LateContext<'_>, hir_id: HirId, f: impl Fn(&PrintVisitor<'_, '_>)) {\n+    if has_attr(cx, hir_id) {\n         prelude();\n-        PrintVisitor::new(\"stmt\").visit_stmt(stmt);\n+        f(&PrintVisitor::new(cx));\n         done();\n     }\n+}\n \n-    fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ForeignItem<'_>) {\n-        if !has_attr(cx, item.hir_id()) {\n-            return;\n+struct Binding<T> {\n+    name: String,\n+    value: T,\n+}\n+\n+impl<T> Display for Binding<T> {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        f.write_str(&self.name)\n+    }\n+}\n+\n+struct OptionPat<T> {\n+    pub opt: Option<T>,\n+}\n+\n+impl<T> OptionPat<T> {\n+    fn new(opt: Option<T>) -> Self {\n+        Self { opt }\n+    }\n+\n+    fn if_some(&self, f: impl Fn(&T)) {\n+        if let Some(t) = &self.opt {\n+            f(t);\n+        }\n+    }\n+}\n+\n+impl<T: Display> Display for OptionPat<T> {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        match &self.opt {\n+            None => f.write_str(\"None\"),\n+            Some(node) => write!(f, \"Some({node})\"),\n         }\n-        prelude();\n-        PrintVisitor::new(\"item\").visit_foreign_item(item);\n-        done();\n     }\n }\n \n-impl PrintVisitor {\n-    #[must_use]\n-    fn new(s: &'static str) -> Self {\n+struct PrintVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    /// Fields are the current index that needs to be appended to pattern\n+    /// binding names\n+    ids: std::cell::Cell<FxHashMap<&'static str, u32>>,\n+}\n+\n+#[allow(clippy::unused_self)]\n+impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n-            ids: FxHashMap::default(),\n-            current: s.to_owned(),\n+            cx,\n+            ids: std::cell::Cell::default(),\n         }\n     }\n \n-    fn next(&mut self, s: &'static str) -> String {\n-        use std::collections::hash_map::Entry::{Occupied, Vacant};\n-        match self.ids.entry(s) {\n-            // already there: start numbering from `1`\n-            Occupied(mut occ) => {\n-                let val = occ.get_mut();\n-                *val += 1;\n-                format!(\"{}{}\", s, *val)\n-            },\n-            // not there: insert and return name as given\n-            Vacant(vac) => {\n-                vac.insert(0);\n-                s.to_owned()\n+    fn next(&self, s: &'static str) -> String {\n+        let mut ids = self.ids.take();\n+        let out = match *ids.entry(s).and_modify(|n| *n += 1).or_default() {\n+            // first usage of the name, use it as is\n+            0 => s.to_string(),\n+            // append a number starting with 1\n+            n => format!(\"{s}{n}\"),\n+        };\n+        self.ids.set(ids);\n+        out\n+    }\n+\n+    fn bind<T>(&self, name: &'static str, value: T) -> Binding<T> {\n+        let name = self.next(name);\n+        Binding { name, value }\n+    }\n+\n+    fn option<T: Copy>(&self, option: &Binding<Option<T>>, name: &'static str, f: impl Fn(&Binding<T>)) {\n+        match option.value {\n+            None => out!(\"if {option}.is_none();\"),\n+            Some(value) => {\n+                let value = &self.bind(name, value);\n+                out!(\"if let Some({value}) = {option};\");\n+                f(value);\n             },\n         }\n     }\n \n-    fn print_qpath(&mut self, path: &QPath<'_>) {\n-        if let QPath::LangItem(lang_item, _) = *path {\n-            println!(\n-                \"    if matches!({}, QPath::LangItem(LangItem::{:?}, _));\",\n-                self.current, lang_item,\n-            );\n+    fn slice<T>(&self, slice: &Binding<&[T]>, f: impl Fn(&Binding<&T>)) {\n+        if slice.value.is_empty() {\n+            out!(\"if {slice}.is_empty();\");\n         } else {\n-            print!(\"    if match_qpath({}, &[\", self.current);\n-            print_path(path, &mut true);\n-            println!(\"]);\");\n+            out!(\"if {slice}.len() == {};\", slice.value.len());\n+            for (i, value) in slice.value.iter().enumerate() {\n+                let name = format!(\"{slice}[{i}]\");\n+                f(&Binding { name, value });\n+            }\n         }\n     }\n-}\n \n-struct PrintVisitor {\n-    /// Fields are the current index that needs to be appended to pattern\n-    /// binding names\n-    ids: FxHashMap<&'static str, usize>,\n-    /// the name that needs to be destructured\n-    current: String,\n-}\n+    fn destination(&self, destination: &Binding<hir::Destination>) {\n+        self.option(field!(destination.label), \"label\", |label| {\n+            self.ident(field!(label.ident));\n+        });\n+    }\n+\n+    fn ident(&self, ident: &Binding<Ident>) {\n+        out!(\"if {ident}.as_str() == {:?};\", ident.value.as_str());\n+    }\n+\n+    fn symbol(&self, symbol: &Binding<Symbol>) {\n+        out!(\"if {symbol}.as_str() == {:?};\", symbol.value.as_str());\n+    }\n \n-impl<'tcx> Visitor<'tcx> for PrintVisitor {\n-    type Map = Map<'tcx>;\n+    fn qpath(&self, qpath: &Binding<&QPath<'_>>) {\n+        if let QPath::LangItem(lang_item, _) = *qpath.value {\n+            out!(\"if matches!({qpath}, QPath::LangItem(LangItem::{lang_item:?}, _));\");\n+        } else {\n+            out!(\"if match_qpath({qpath}, &[{}]);\", path_to_string(qpath.value));\n+        }\n+    }\n+\n+    fn lit(&self, lit: &Binding<&Lit>) {\n+        let kind = |kind| out!(\"if let LitKind::{kind} = {lit}.node;\");\n+        macro_rules! kind {\n+            ($($t:tt)*) => (kind(format_args!($($t)*)));\n+        }\n+\n+        match lit.value.node {\n+            LitKind::Bool(val) => kind!(\"Bool({val:?})\"),\n+            LitKind::Char(c) => kind!(\"Char({c:?})\"),\n+            LitKind::Err(val) => kind!(\"Err({val})\"),\n+            LitKind::Byte(b) => kind!(\"Byte({b})\"),\n+            LitKind::Int(i, suffix) => {\n+                let int_ty = match suffix {\n+                    LitIntType::Signed(int_ty) => format!(\"LitIntType::Signed(IntTy::{int_ty:?})\"),\n+                    LitIntType::Unsigned(uint_ty) => format!(\"LitIntType::Unsigned(UintTy::{uint_ty:?})\"),\n+                    LitIntType::Unsuffixed => String::from(\"LitIntType::Unsuffixed\"),\n+                };\n+                kind!(\"Int({i}, {int_ty})\");\n+            },\n+            LitKind::Float(_, suffix) => {\n+                let float_ty = match suffix {\n+                    LitFloatType::Suffixed(suffix_ty) => format!(\"LitFloatType::Suffixed(FloatTy::{suffix_ty:?})\"),\n+                    LitFloatType::Unsuffixed => String::from(\"LitFloatType::Unsuffixed\"),\n+                };\n+                kind!(\"Float(_, {float_ty})\");\n+            },\n+            LitKind::ByteStr(ref vec) => {\n+                bind!(self, vec);\n+                kind!(\"ByteStr(ref {vec})\");\n+                out!(\"if let [{:?}] = **{vec};\", vec.value);\n+            },\n+            LitKind::Str(s, _) => {\n+                bind!(self, s);\n+                kind!(\"Str({s}, _)\");\n+                self.symbol(s);\n+            },\n+        }\n+    }\n+\n+    fn arm(&self, arm: &Binding<&hir::Arm<'_>>) {\n+        self.pat(field!(arm.pat));\n+        match arm.value.guard {\n+            None => out!(\"if {arm}.guard.is_none();\"),\n+            Some(hir::Guard::If(expr)) => {\n+                bind!(self, expr);\n+                out!(\"if let Some(Guard::If({expr})) = {arm}.guard;\");\n+                self.expr(expr);\n+            },\n+            Some(hir::Guard::IfLet(pat, expr)) => {\n+                bind!(self, pat, expr);\n+                out!(\"if let Some(Guard::IfLet({pat}, {expr}) = {arm}.guard;\");\n+                self.pat(pat);\n+                self.expr(expr);\n+            },\n+        }\n+        self.expr(field!(arm.body));\n+    }\n \n     #[allow(clippy::too_many_lines)]\n-    fn visit_expr(&mut self, expr: &Expr<'_>) {\n-        print!(\"    if let ExprKind::\");\n-        let current = format!(\"{}.kind\", self.current);\n-        match expr.kind {\n+    fn expr(&self, expr: &Binding<&hir::Expr<'_>>) {\n+        if let Some(higher::While { condition, body }) = higher::While::hir(expr.value) {\n+            bind!(self, condition, body);\n+            out!(\n+                \"if let Some(higher::While {{ condition: {condition}, body: {body} }}) \\\n+                = higher::While::hir({expr});\"\n+            );\n+            self.expr(condition);\n+            self.expr(body);\n+            return;\n+        }\n+\n+        if let Some(higher::WhileLet {\n+            let_pat,\n+            let_expr,\n+            if_then,\n+        }) = higher::WhileLet::hir(expr.value)\n+        {\n+            bind!(self, let_pat, let_expr, if_then);\n+            out!(\n+                \"if let Some(higher::WhileLet {{ let_pat: {let_pat}, let_expr: {let_expr}, if_then: {if_then} }}) \\\n+                = higher::WhileLet::hir({expr});\"\n+            );\n+            self.pat(let_pat);\n+            self.expr(let_expr);\n+            self.expr(if_then);\n+            return;\n+        }\n+\n+        if let Some(higher::ForLoop { pat, arg, body, .. }) = higher::ForLoop::hir(expr.value) {\n+            bind!(self, pat, arg, body);\n+            out!(\n+                \"if let Some(higher::ForLoop {{ pat: {pat}, arg: {arg}, body: {body}, .. }}) \\\n+                = higher::ForLoop::hir({expr});\"\n+            );\n+            self.pat(pat);\n+            self.expr(arg);\n+            self.expr(body);\n+            return;\n+        }\n+\n+        let kind = |kind| out!(\"if let ExprKind::{kind} = {expr}.kind;\");\n+        macro_rules! kind {\n+            ($($t:tt)*) => (kind(format_args!($($t)*)));\n+        }\n+\n+        match expr.value.kind {\n             ExprKind::Let(pat, expr, _) => {\n-                let let_pat = self.next(\"pat\");\n-                let let_expr = self.next(\"expr\");\n-                println!(\"    Let(ref {}, ref {}, _) = {};\", let_pat, let_expr, current);\n-                self.current = let_expr;\n-                self.visit_expr(expr);\n-                self.current = let_pat;\n-                self.visit_pat(pat);\n+                bind!(self, pat, expr);\n+                kind!(\"Let({pat}, {expr}, _)\");\n+                self.pat(pat);\n+                self.expr(expr);\n             },\n             ExprKind::Box(inner) => {\n-                let inner_pat = self.next(\"inner\");\n-                println!(\"Box(ref {}) = {};\", inner_pat, current);\n-                self.current = inner_pat;\n-                self.visit_expr(inner);\n+                bind!(self, inner);\n+                kind!(\"Box({inner})\");\n+                self.expr(inner);\n             },\n             ExprKind::Array(elements) => {\n-                let elements_pat = self.next(\"elements\");\n-                println!(\"Array(ref {}) = {};\", elements_pat, current);\n-                println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n-                for (i, element) in elements.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", elements_pat, i);\n-                    self.visit_expr(element);\n-                }\n+                bind!(self, elements);\n+                kind!(\"Array({elements})\");\n+                self.slice(elements, |e| self.expr(e));\n             },\n             ExprKind::Call(func, args) => {\n-                let func_pat = self.next(\"func\");\n-                let args_pat = self.next(\"args\");\n-                println!(\"Call(ref {}, ref {}) = {};\", func_pat, args_pat, current);\n-                self.current = func_pat;\n-                self.visit_expr(func);\n-                println!(\"    if {}.len() == {};\", args_pat, args.len());\n-                for (i, arg) in args.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", args_pat, i);\n-                    self.visit_expr(arg);\n-                }\n+                bind!(self, func, args);\n+                kind!(\"Call({func}, {args})\");\n+                self.expr(func);\n+                self.slice(args, |e| self.expr(e));\n             },\n-            ExprKind::MethodCall(_method_name, ref _generics, _args, ref _fn_span) => {\n-                println!(\n-                    \"MethodCall(ref method_name, ref generics, ref args, ref fn_span) = {};\",\n-                    current\n-                );\n-                println!(\"    // unimplemented: `ExprKind::MethodCall` is not further destructured at the moment\");\n+            ExprKind::MethodCall(method_name, _, args, _) => {\n+                bind!(self, method_name, args);\n+                kind!(\"MethodCall({method_name}, _, {args}, _)\");\n+                self.ident(field!(method_name.ident));\n+                self.slice(args, |e| self.expr(e));\n             },\n             ExprKind::Tup(elements) => {\n-                let elements_pat = self.next(\"elements\");\n-                println!(\"Tup(ref {}) = {};\", elements_pat, current);\n-                println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n-                for (i, element) in elements.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", elements_pat, i);\n-                    self.visit_expr(element);\n-                }\n-            },\n-            ExprKind::Binary(ref op, left, right) => {\n-                let op_pat = self.next(\"op\");\n-                let left_pat = self.next(\"left\");\n-                let right_pat = self.next(\"right\");\n-                println!(\n-                    \"Binary(ref {}, ref {}, ref {}) = {};\",\n-                    op_pat, left_pat, right_pat, current\n-                );\n-                println!(\"    if BinOpKind::{:?} == {}.node;\", op.node, op_pat);\n-                self.current = left_pat;\n-                self.visit_expr(left);\n-                self.current = right_pat;\n-                self.visit_expr(right);\n-            },\n-            ExprKind::Unary(ref op, inner) => {\n-                let inner_pat = self.next(\"inner\");\n-                println!(\"Unary(UnOp::{:?}, ref {}) = {};\", op, inner_pat, current);\n-                self.current = inner_pat;\n-                self.visit_expr(inner);\n+                bind!(self, elements);\n+                kind!(\"Tup({elements})\");\n+                self.slice(elements, |e| self.expr(e));\n+            },\n+            ExprKind::Binary(op, left, right) => {\n+                bind!(self, op, left, right);\n+                kind!(\"Binary({op}, {left}, {right})\");\n+                out!(\"if BinOpKind::{:?} == {op}.node;\", op.value.node);\n+                self.expr(left);\n+                self.expr(right);\n+            },\n+            ExprKind::Unary(op, inner) => {\n+                bind!(self, inner);\n+                kind!(\"Unary(UnOp::{op:?}, {inner})\");\n+                self.expr(inner);\n             },\n             ExprKind::Lit(ref lit) => {\n-                let lit_pat = self.next(\"lit\");\n-                println!(\"Lit(ref {}) = {};\", lit_pat, current);\n-                match lit.node {\n-                    LitKind::Bool(val) => println!(\"    if let LitKind::Bool({:?}) = {}.node;\", val, lit_pat),\n-                    LitKind::Char(c) => println!(\"    if let LitKind::Char({:?}) = {}.node;\", c, lit_pat),\n-                    LitKind::Err(val) => println!(\"    if let LitKind::Err({}) = {}.node;\", val, lit_pat),\n-                    LitKind::Byte(b) => println!(\"    if let LitKind::Byte({}) = {}.node;\", b, lit_pat),\n-                    // FIXME: also check int type\n-                    LitKind::Int(i, _) => println!(\"    if let LitKind::Int({}, _) = {}.node;\", i, lit_pat),\n-                    LitKind::Float(_, LitFloatType::Suffixed(_)) => println!(\n-                        \"    if let LitKind::Float(_, LitFloatType::Suffixed(_)) = {}.node;\",\n-                        lit_pat\n-                    ),\n-                    LitKind::Float(_, LitFloatType::Unsuffixed) => println!(\n-                        \"    if let LitKind::Float(_, LitFloatType::Unsuffixed) = {}.node;\",\n-                        lit_pat\n-                    ),\n-                    LitKind::ByteStr(ref vec) => {\n-                        let vec_pat = self.next(\"vec\");\n-                        println!(\"    if let LitKind::ByteStr(ref {}) = {}.node;\", vec_pat, lit_pat);\n-                        println!(\"    if let [{:?}] = **{};\", vec, vec_pat);\n-                    },\n-                    LitKind::Str(ref text, _) => {\n-                        let str_pat = self.next(\"s\");\n-                        println!(\"    if let LitKind::Str(ref {}, _) = {}.node;\", str_pat, lit_pat);\n-                        println!(\"    if {}.as_str() == {:?}\", str_pat, &*text.as_str());\n-                    },\n+                bind!(self, lit);\n+                kind!(\"Lit(ref {lit})\");\n+                self.lit(lit);\n+            },\n+            ExprKind::Cast(expr, cast_ty) => {\n+                bind!(self, expr, cast_ty);\n+                kind!(\"Cast({expr}, {cast_ty})\");\n+                if let TyKind::Path(ref qpath) = cast_ty.value.kind {\n+                    bind!(self, qpath);\n+                    out!(\"if let TyKind::Path(ref {qpath}) = {cast_ty}.kind;\");\n+                    self.qpath(qpath);\n                 }\n-            },\n-            ExprKind::Cast(expr, ty) => {\n-                let cast_pat = self.next(\"expr\");\n-                let cast_ty = self.next(\"cast_ty\");\n-                let qp_label = self.next(\"qp\");\n-\n-                println!(\"Cast(ref {}, ref {}) = {};\", cast_pat, cast_ty, current);\n-                if let TyKind::Path(ref qp) = ty.kind {\n-                    println!(\"    if let TyKind::Path(ref {}) = {}.kind;\", qp_label, cast_ty);\n-                    self.current = qp_label;\n-                    self.print_qpath(qp);\n-                }\n-                self.current = cast_pat;\n-                self.visit_expr(expr);\n+                self.expr(expr);\n             },\n             ExprKind::Type(expr, _ty) => {\n-                let cast_pat = self.next(\"expr\");\n-                println!(\"Type(ref {}, _) = {};\", cast_pat, current);\n-                self.current = cast_pat;\n-                self.visit_expr(expr);\n-            },\n-            ExprKind::Loop(body, _, des, _) => {\n-                let body_pat = self.next(\"body\");\n-                let label_pat = self.next(\"label\");\n-                println!(\n-                    \"Loop(ref {}, ref {}, LoopSource::{:?}) = {};\",\n-                    body_pat, label_pat, des, current\n-                );\n-                self.current = body_pat;\n-                self.visit_block(body);\n-            },\n-            ExprKind::If(cond, then, ref opt_else) => {\n-                let cond_pat = self.next(\"cond\");\n-                let then_pat = self.next(\"then\");\n-                if let Some(else_) = *opt_else {\n-                    let else_pat = self.next(\"else_\");\n-                    println!(\n-                        \"If(ref {}, ref {}, Some(ref {})) = {};\",\n-                        cond_pat, then_pat, else_pat, current\n-                    );\n-                    self.current = else_pat;\n-                    self.visit_expr(else_);\n-                } else {\n-                    println!(\"If(ref {}, ref {}, None) = {};\", cond_pat, then_pat, current);\n-                }\n-                self.current = cond_pat;\n-                self.visit_expr(cond);\n-                self.current = then_pat;\n-                self.visit_expr(then);\n-            },\n-            ExprKind::Match(expr, arms, des) => {\n-                let expr_pat = self.next(\"expr\");\n-                let arms_pat = self.next(\"arms\");\n-                println!(\n-                    \"Match(ref {}, ref {}, MatchSource::{:?}) = {};\",\n-                    expr_pat, arms_pat, des, current\n-                );\n-                self.current = expr_pat;\n-                self.visit_expr(expr);\n-                println!(\"    if {}.len() == {};\", arms_pat, arms.len());\n-                for (i, arm) in arms.iter().enumerate() {\n-                    self.current = format!(\"{}[{}].body\", arms_pat, i);\n-                    self.visit_expr(arm.body);\n-                    if let Some(ref guard) = arm.guard {\n-                        let guard_pat = self.next(\"guard\");\n-                        println!(\"    if let Some(ref {}) = {}[{}].guard;\", guard_pat, arms_pat, i);\n-                        match guard {\n-                            hir::Guard::If(if_expr) => {\n-                                let if_expr_pat = self.next(\"expr\");\n-                                println!(\"    if let Guard::If(ref {}) = {};\", if_expr_pat, guard_pat);\n-                                self.current = if_expr_pat;\n-                                self.visit_expr(if_expr);\n-                            },\n-                            hir::Guard::IfLet(if_let_pat, if_let_expr) => {\n-                                let if_let_pat_pat = self.next(\"pat\");\n-                                let if_let_expr_pat = self.next(\"expr\");\n-                                println!(\n-                                    \"    if let Guard::IfLet(ref {}, ref {}) = {};\",\n-                                    if_let_pat_pat, if_let_expr_pat, guard_pat\n-                                );\n-                                self.current = if_let_expr_pat;\n-                                self.visit_expr(if_let_expr);\n-                                self.current = if_let_pat_pat;\n-                                self.visit_pat(if_let_pat);\n-                            },\n-                        }\n-                    }\n-                    self.current = format!(\"{}[{}].pat\", arms_pat, i);\n-                    self.visit_pat(arm.pat);\n-                }\n-            },\n-            ExprKind::Closure(ref _capture_clause, _func, _, _, _) => {\n-                println!(\"Closure(ref capture_clause, ref func, _, _, _) = {};\", current);\n-                println!(\"    // unimplemented: `ExprKind::Closure` is not further destructured at the moment\");\n-            },\n-            ExprKind::Yield(sub, _) => {\n-                let sub_pat = self.next(\"sub\");\n-                println!(\"Yield(ref sub) = {};\", current);\n-                self.current = sub_pat;\n-                self.visit_expr(sub);\n-            },\n-            ExprKind::Block(block, _) => {\n-                let block_pat = self.next(\"block\");\n-                println!(\"Block(ref {}) = {};\", block_pat, current);\n-                self.current = block_pat;\n-                self.visit_block(block);\n+                bind!(self, expr);\n+                kind!(\"Type({expr}, _)\");\n+                self.expr(expr);\n+            },\n+            ExprKind::Loop(body, label, des, _) => {\n+                bind!(self, body);\n+                opt_bind!(self, label);\n+                kind!(\"Loop({body}, {label}, LoopSource::{des:?}, _)\");\n+                self.block(body);\n+                label.if_some(|l| self.ident(field!(l.ident)));\n+            },\n+            ExprKind::If(cond, then, else_expr) => {\n+                bind!(self, cond, then);\n+                opt_bind!(self, else_expr);\n+                kind!(\"If({cond}, {then}, {else_expr})\");\n+                self.expr(cond);\n+                self.expr(then);\n+                else_expr.if_some(|e| self.expr(e));\n+            },\n+            ExprKind::Match(scrutinee, arms, des) => {\n+                bind!(self, scrutinee, arms);\n+                kind!(\"Match({scrutinee}, {arms}, MatchSource::{des:?})\");\n+                self.expr(scrutinee);\n+                self.slice(arms, |arm| self.arm(arm));\n+            },\n+            ExprKind::Closure(capture_by, fn_decl, body_id, _, movability) => {\n+                let movability = OptionPat::new(movability.map(|m| format!(\"Movability::{m:?}\")));\n+\n+                let ret_ty = match fn_decl.output {\n+                    FnRetTy::DefaultReturn(_) => \"FnRetTy::DefaultReturn(_)\",\n+                    FnRetTy::Return(_) => \"FnRetTy::Return(_ty)\",\n+                };\n+\n+                bind!(self, fn_decl, body_id);\n+                kind!(\"Closure(CaptureBy::{capture_by:?}, {fn_decl}, {body_id}, _, {movability})\");\n+                out!(\"if let {ret_ty} = {fn_decl}.output;\");\n+                self.body(body_id);\n+            },\n+            ExprKind::Yield(sub, source) => {\n+                bind!(self, sub);\n+                kind!(\"Yield(sub, YieldSource::{source:?})\");\n+                self.expr(sub);\n+            },\n+            ExprKind::Block(block, label) => {\n+                bind!(self, block);\n+                opt_bind!(self, label);\n+                kind!(\"Block({block}, {label})\");\n+                self.block(block);\n+                label.if_some(|l| self.ident(field!(l.ident)));\n             },\n             ExprKind::Assign(target, value, _) => {\n-                let target_pat = self.next(\"target\");\n-                let value_pat = self.next(\"value\");\n-                println!(\n-                    \"Assign(ref {}, ref {}, ref _span) = {};\",\n-                    target_pat, value_pat, current\n-                );\n-                self.current = target_pat;\n-                self.visit_expr(target);\n-                self.current = value_pat;\n-                self.visit_expr(value);\n-            },\n-            ExprKind::AssignOp(ref op, target, value) => {\n-                let op_pat = self.next(\"op\");\n-                let target_pat = self.next(\"target\");\n-                let value_pat = self.next(\"value\");\n-                println!(\n-                    \"AssignOp(ref {}, ref {}, ref {}) = {};\",\n-                    op_pat, target_pat, value_pat, current\n-                );\n-                println!(\"    if BinOpKind::{:?} == {}.node;\", op.node, op_pat);\n-                self.current = target_pat;\n-                self.visit_expr(target);\n-                self.current = value_pat;\n-                self.visit_expr(value);\n-            },\n-            ExprKind::Field(object, ref field_ident) => {\n-                let obj_pat = self.next(\"object\");\n-                let field_name_pat = self.next(\"field_name\");\n-                println!(\"Field(ref {}, ref {}) = {};\", obj_pat, field_name_pat, current);\n-                println!(\"    if {}.as_str() == {:?}\", field_name_pat, field_ident.as_str());\n-                self.current = obj_pat;\n-                self.visit_expr(object);\n+                bind!(self, target, value);\n+                kind!(\"Assign({target}, {value}, _span)\");\n+                self.expr(target);\n+                self.expr(value);\n+            },\n+            ExprKind::AssignOp(op, target, value) => {\n+                bind!(self, op, target, value);\n+                kind!(\"AssignOp({op}, {target}, {value})\");\n+                out!(\"if BinOpKind::{:?} == {op}.node;\", op.value.node);\n+                self.expr(target);\n+                self.expr(value);\n+            },\n+            ExprKind::Field(object, field_name) => {\n+                bind!(self, object, field_name);\n+                kind!(\"Field({object}, {field_name})\");\n+                self.ident(field_name);\n+                self.expr(object);\n             },\n             ExprKind::Index(object, index) => {\n-                let object_pat = self.next(\"object\");\n-                let index_pat = self.next(\"index\");\n-                println!(\"Index(ref {}, ref {}) = {};\", object_pat, index_pat, current);\n-                self.current = object_pat;\n-                self.visit_expr(object);\n-                self.current = index_pat;\n-                self.visit_expr(index);\n-            },\n-            ExprKind::Path(ref path) => {\n-                let path_pat = self.next(\"path\");\n-                println!(\"Path(ref {}) = {};\", path_pat, current);\n-                self.current = path_pat;\n-                self.print_qpath(path);\n+                bind!(self, object, index);\n+                kind!(\"Index({object}, {index})\");\n+                self.expr(object);\n+                self.expr(index);\n+            },\n+            ExprKind::Path(ref qpath) => {\n+                bind!(self, qpath);\n+                kind!(\"Path(ref {qpath})\");\n+                self.qpath(qpath);\n             },\n             ExprKind::AddrOf(kind, mutability, inner) => {\n-                let inner_pat = self.next(\"inner\");\n-                println!(\n-                    \"AddrOf(BorrowKind::{:?}, Mutability::{:?}, ref {}) = {};\",\n-                    kind, mutability, inner_pat, current\n-                );\n-                self.current = inner_pat;\n-                self.visit_expr(inner);\n-            },\n-            ExprKind::Break(ref _destination, ref opt_value) => {\n-                let destination_pat = self.next(\"destination\");\n-                if let Some(value) = *opt_value {\n-                    let value_pat = self.next(\"value\");\n-                    println!(\"Break(ref {}, Some(ref {})) = {};\", destination_pat, value_pat, current);\n-                    self.current = value_pat;\n-                    self.visit_expr(value);\n-                } else {\n-                    println!(\"Break(ref {}, None) = {};\", destination_pat, current);\n-                }\n-                // FIXME: implement label printing\n-            },\n-            ExprKind::Continue(ref _destination) => {\n-                let destination_pat = self.next(\"destination\");\n-                println!(\"Again(ref {}) = {};\", destination_pat, current);\n-                // FIXME: implement label printing\n-            },\n-            ExprKind::Ret(ref opt_value) => {\n-                if let Some(value) = *opt_value {\n-                    let value_pat = self.next(\"value\");\n-                    println!(\"Ret(Some(ref {})) = {};\", value_pat, current);\n-                    self.current = value_pat;\n-                    self.visit_expr(value);\n-                } else {\n-                    println!(\"Ret(None) = {};\", current);\n-                }\n+                bind!(self, inner);\n+                kind!(\"AddrOf(BorrowKind::{kind:?}, Mutability::{mutability:?}, {inner})\");\n+                self.expr(inner);\n+            },\n+            ExprKind::Break(destination, value) => {\n+                bind!(self, destination);\n+                opt_bind!(self, value);\n+                kind!(\"Break({destination}, {value})\");\n+                self.destination(destination);\n+                value.if_some(|e| self.expr(e));\n+            },\n+            ExprKind::Continue(destination) => {\n+                bind!(self, destination);\n+                kind!(\"Continue({destination})\");\n+                self.destination(destination);\n+            },\n+            ExprKind::Ret(value) => {\n+                opt_bind!(self, value);\n+                kind!(\"Ret({value})\");\n+                value.if_some(|e| self.expr(e));\n             },\n             ExprKind::InlineAsm(_) => {\n-                println!(\"InlineAsm(_) = {};\", current);\n-                println!(\"    // unimplemented: `ExprKind::InlineAsm` is not further destructured at the moment\");\n+                kind!(\"InlineAsm(_)\");\n+                out!(\"// unimplemented: `ExprKind::InlineAsm` is not further destructured at the moment\");\n             },\n             ExprKind::LlvmInlineAsm(_) => {\n-                println!(\"LlvmInlineAsm(_) = {};\", current);\n-                println!(\"    // unimplemented: `ExprKind::LlvmInlineAsm` is not further destructured at the moment\");\n-            },\n-            ExprKind::Struct(path, fields, ref opt_base) => {\n-                let path_pat = self.next(\"path\");\n-                let fields_pat = self.next(\"fields\");\n-                if let Some(base) = *opt_base {\n-                    let base_pat = self.next(\"base\");\n-                    println!(\n-                        \"Struct(ref {}, ref {}, Some(ref {})) = {};\",\n-                        path_pat, fields_pat, base_pat, current\n-                    );\n-                    self.current = base_pat;\n-                    self.visit_expr(base);\n-                } else {\n-                    println!(\"Struct(ref {}, ref {}, None) = {};\", path_pat, fields_pat, current);\n-                }\n-                self.current = path_pat;\n-                self.print_qpath(path);\n-                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-                println!(\"    // unimplemented: field checks\");\n-            },\n-            ExprKind::ConstBlock(_) => {\n-                let value_pat = self.next(\"value\");\n-                println!(\"Const({})\", value_pat);\n-                self.current = value_pat;\n-            },\n-            // FIXME: compute length (needs type info)\n-            ExprKind::Repeat(value, _) => {\n-                let value_pat = self.next(\"value\");\n-                println!(\"Repeat(ref {}, _) = {};\", value_pat, current);\n-                println!(\"// unimplemented: repeat count check\");\n-                self.current = value_pat;\n-                self.visit_expr(value);\n-            },\n-            ExprKind::Err => {\n-                println!(\"Err = {}\", current);\n-            },\n+                kind!(\"LlvmInlineAsm(_)\");\n+                out!(\"// unimplemented: `ExprKind::LlvmInlineAsm` is not further destructured at the moment\");\n+            },\n+            ExprKind::Struct(qpath, fields, base) => {\n+                bind!(self, qpath, fields);\n+                opt_bind!(self, base);\n+                kind!(\"Struct({qpath}, {fields}, {base})\");\n+                self.qpath(qpath);\n+                self.slice(fields, |field| {\n+                    self.ident(field!(field.ident));\n+                    self.expr(field!(field.expr));\n+                });\n+                base.if_some(|e| self.expr(e));\n+            },\n+            ExprKind::ConstBlock(_) => kind!(\"ConstBlock(_)\"),\n+            ExprKind::Repeat(value, length) => {\n+                bind!(self, value, length);\n+                kind!(\"Repeat({value}, {length})\");\n+                self.expr(value);\n+                self.body(field!(length.body));\n+            },\n+            ExprKind::Err => kind!(\"Err\"),\n             ExprKind::DropTemps(expr) => {\n-                let expr_pat = self.next(\"expr\");\n-                println!(\"DropTemps(ref {}) = {};\", expr_pat, current);\n-                self.current = expr_pat;\n-                self.visit_expr(expr);\n+                bind!(self, expr);\n+                kind!(\"DropTemps({expr})\");\n+                self.expr(expr);\n             },\n         }\n     }\n \n-    fn visit_block(&mut self, block: &Block<'_>) {\n-        println!(\"    if {}.stmts.len() == {};\", self.current, block.stmts.len());\n-        let block_name = self.current.clone();\n-        for (i, stmt) in block.stmts.iter().enumerate() {\n-            self.current = format!(\"{}.stmts[{}]\", block_name, i);\n-            self.visit_stmt(stmt);\n-        }\n-        if let Some(expr) = block.expr {\n-            self.current = self.next(\"trailing_expr\");\n-            println!(\"    if let Some({}) = &{}.expr;\", self.current, block_name);\n-            self.visit_expr(expr);\n-        } else {\n-            println!(\"    if {}.expr.is_none();\", block_name);\n-        }\n+    fn block(&self, block: &Binding<&hir::Block<'_>>) {\n+        self.slice(field!(block.stmts), |stmt| self.stmt(stmt));\n+        self.option(field!(block.expr), \"trailing_expr\", |expr| {\n+            self.expr(expr);\n+        });\n     }\n \n-    #[allow(clippy::too_many_lines)]\n-    fn visit_pat(&mut self, pat: &Pat<'_>) {\n-        print!(\"    if let PatKind::\");\n-        let current = format!(\"{}.kind\", self.current);\n-        match pat.kind {\n-            PatKind::Wild => println!(\"Wild = {};\", current),\n-            PatKind::Binding(anno, .., ident, ref sub) => {\n-                let anno_pat = &format!(\"BindingAnnotation::{:?}\", anno);\n-                let name_pat = self.next(\"name\");\n-                if let Some(sub) = *sub {\n-                    let sub_pat = self.next(\"sub\");\n-                    println!(\n-                        \"Binding({}, _, {}, Some(ref {})) = {};\",\n-                        anno_pat, name_pat, sub_pat, current\n-                    );\n-                    self.current = sub_pat;\n-                    self.visit_pat(sub);\n-                } else {\n-                    println!(\"Binding({}, _, {}, None) = {};\", anno_pat, name_pat, current);\n-                }\n-                println!(\"    if {}.as_str() == \\\"{}\\\";\", name_pat, ident.as_str());\n-            },\n-            PatKind::Struct(ref path, fields, ignore) => {\n-                let path_pat = self.next(\"path\");\n-                let fields_pat = self.next(\"fields\");\n-                println!(\n-                    \"Struct(ref {}, ref {}, {}) = {};\",\n-                    path_pat, fields_pat, ignore, current\n-                );\n-                self.current = path_pat;\n-                self.print_qpath(path);\n-                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-                println!(\"    // unimplemented: field checks\");\n+    fn body(&self, body_id: &Binding<hir::BodyId>) {\n+        let expr = &self.cx.tcx.hir().body(body_id.value).value;\n+        bind!(self, expr);\n+        out!(\"let {expr} = &cx.tcx.hir().body({body_id}).value;\");\n+        self.expr(expr);\n+    }\n+\n+    fn pat(&self, pat: &Binding<&hir::Pat<'_>>) {\n+        let kind = |kind| out!(\"if let PatKind::{kind} = {pat}.kind;\");\n+        macro_rules! kind {\n+            ($($t:tt)*) => (kind(format_args!($($t)*)));\n+        }\n+\n+        match pat.value.kind {\n+            PatKind::Wild => kind!(\"Wild\"),\n+            PatKind::Binding(anno, .., name, sub) => {\n+                bind!(self, name);\n+                opt_bind!(self, sub);\n+                kind!(\"Binding(BindingAnnotation::{anno:?}, _, {name}, {sub})\");\n+                self.ident(name);\n+                sub.if_some(|p| self.pat(p));\n+            },\n+            PatKind::Struct(ref qpath, fields, ignore) => {\n+                bind!(self, qpath, fields);\n+                kind!(\"Struct(ref {qpath}, {fields}, {ignore})\");\n+                self.qpath(qpath);\n+                self.slice(fields, |field| {\n+                    self.ident(field!(field.ident));\n+                    self.pat(field!(field.pat));\n+                });\n             },\n             PatKind::Or(fields) => {\n-                let fields_pat = self.next(\"fields\");\n-                println!(\"Or(ref {}) = {};\", fields_pat, current);\n-                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-                println!(\"    // unimplemented: field checks\");\n-            },\n-            PatKind::TupleStruct(ref path, fields, skip_pos) => {\n-                let path_pat = self.next(\"path\");\n-                let fields_pat = self.next(\"fields\");\n-                println!(\n-                    \"TupleStruct(ref {}, ref {}, {:?}) = {};\",\n-                    path_pat, fields_pat, skip_pos, current\n-                );\n-                self.current = path_pat;\n-                self.print_qpath(path);\n-                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-                println!(\"    // unimplemented: field checks\");\n-            },\n-            PatKind::Path(ref path) => {\n-                let path_pat = self.next(\"path\");\n-                println!(\"Path(ref {}) = {};\", path_pat, current);\n-                self.current = path_pat;\n-                self.print_qpath(path);\n+                bind!(self, fields);\n+                kind!(\"Or({fields})\");\n+                self.slice(fields, |pat| self.pat(pat));\n+            },\n+            PatKind::TupleStruct(ref qpath, fields, skip_pos) => {\n+                bind!(self, qpath, fields);\n+                kind!(\"TupleStruct(ref {qpath}, {fields}, {skip_pos:?})\");\n+                self.qpath(qpath);\n+                self.slice(fields, |pat| self.pat(pat));\n+            },\n+            PatKind::Path(ref qpath) => {\n+                bind!(self, qpath);\n+                kind!(\"Path(ref {qpath})\");\n+                self.qpath(qpath);\n             },\n             PatKind::Tuple(fields, skip_pos) => {\n-                let fields_pat = self.next(\"fields\");\n-                println!(\"Tuple(ref {}, {:?}) = {};\", fields_pat, skip_pos, current);\n-                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n-                println!(\"    // unimplemented: field checks\");\n+                bind!(self, fields);\n+                kind!(\"Tuple({fields}, {skip_pos:?})\");\n+                self.slice(fields, |field| self.pat(field));\n             },\n             PatKind::Box(pat) => {\n-                let pat_pat = self.next(\"pat\");\n-                println!(\"Box(ref {}) = {};\", pat_pat, current);\n-                self.current = pat_pat;\n-                self.visit_pat(pat);\n+                bind!(self, pat);\n+                kind!(\"Box({pat})\");\n+                self.pat(pat);\n             },\n             PatKind::Ref(pat, muta) => {\n-                let pat_pat = self.next(\"pat\");\n-                println!(\"Ref(ref {}, Mutability::{:?}) = {};\", pat_pat, muta, current);\n-                self.current = pat_pat;\n-                self.visit_pat(pat);\n+                bind!(self, pat);\n+                kind!(\"Ref({pat}, Mutability::{muta:?})\");\n+                self.pat(pat);\n             },\n             PatKind::Lit(lit_expr) => {\n-                let lit_expr_pat = self.next(\"lit_expr\");\n-                println!(\"Lit(ref {}) = {}\", lit_expr_pat, current);\n-                self.current = lit_expr_pat;\n-                self.visit_expr(lit_expr);\n-            },\n-            PatKind::Range(ref start, ref end, end_kind) => {\n-                let start_pat = self.next(\"start\");\n-                let end_pat = self.next(\"end\");\n-                println!(\n-                    \"Range(ref {}, ref {}, RangeEnd::{:?}) = {};\",\n-                    start_pat, end_pat, end_kind, current\n-                );\n-                self.current = start_pat;\n-                walk_list!(self, visit_expr, start);\n-                self.current = end_pat;\n-                walk_list!(self, visit_expr, end);\n-            },\n-            PatKind::Slice(start, ref middle, end) => {\n-                let start_pat = self.next(\"start\");\n-                let end_pat = self.next(\"end\");\n-                if let Some(middle) = middle {\n-                    let middle_pat = self.next(\"middle\");\n-                    println!(\n-                        \"Slice(ref {}, Some(ref {}), ref {}) = {};\",\n-                        start_pat, middle_pat, end_pat, current\n-                    );\n-                    self.current = middle_pat;\n-                    self.visit_pat(middle);\n-                } else {\n-                    println!(\"Slice(ref {}, None, ref {}) = {};\", start_pat, end_pat, current);\n-                }\n-                println!(\"    if {}.len() == {};\", start_pat, start.len());\n-                for (i, pat) in start.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", start_pat, i);\n-                    self.visit_pat(pat);\n-                }\n-                println!(\"    if {}.len() == {};\", end_pat, end.len());\n-                for (i, pat) in end.iter().enumerate() {\n-                    self.current = format!(\"{}[{}]\", end_pat, i);\n-                    self.visit_pat(pat);\n-                }\n+                bind!(self, lit_expr);\n+                kind!(\"Lit({lit_expr})\");\n+                self.expr(lit_expr);\n+            },\n+            PatKind::Range(start, end, end_kind) => {\n+                opt_bind!(self, start, end);\n+                kind!(\"Range({start}, {end}, RangeEnd::{end_kind:?})\");\n+                start.if_some(|e| self.expr(e));\n+                end.if_some(|e| self.expr(e));\n+            },\n+            PatKind::Slice(start, middle, end) => {\n+                bind!(self, start, end);\n+                opt_bind!(self, middle);\n+                kind!(\"Slice({start}, {middle}, {end})\");\n+                middle.if_some(|p| self.pat(p));\n+                self.slice(start, |pat| self.pat(pat));\n+                self.slice(end, |pat| self.pat(pat));\n             },\n         }\n     }\n \n-    fn visit_stmt(&mut self, s: &Stmt<'_>) {\n-        print!(\"    if let StmtKind::\");\n-        let current = format!(\"{}.kind\", self.current);\n-        match s.kind {\n-            // A local (let) binding:\n-            StmtKind::Local(local) => {\n-                let local_pat = self.next(\"local\");\n-                println!(\"Local(ref {}) = {};\", local_pat, current);\n-                if let Some(init) = local.init {\n-                    let init_pat = self.next(\"init\");\n-                    println!(\"    if let Some(ref {}) = {}.init;\", init_pat, local_pat);\n-                    self.current = init_pat;\n-                    self.visit_expr(init);\n-                }\n-                self.current = format!(\"{}.pat\", local_pat);\n-                self.visit_pat(local.pat);\n-            },\n-            // An item binding:\n-            StmtKind::Item(_) => {\n-                println!(\"Item(item_id) = {};\", current);\n-            },\n+    fn stmt(&self, stmt: &Binding<&hir::Stmt<'_>>) {\n+        let kind = |kind| out!(\"if let StmtKind::{kind} = {stmt}.kind;\");\n+        macro_rules! kind {\n+            ($($t:tt)*) => (kind(format_args!($($t)*)));\n+        }\n \n-            // Expr without trailing semi-colon (must have unit type):\n+        match stmt.value.kind {\n+            StmtKind::Local(local) => {\n+                bind!(self, local);\n+                kind!(\"Local({local})\");\n+                self.option(field!(local.init), \"init\", |init| {\n+                    self.expr(init);\n+                });\n+                self.pat(field!(local.pat));\n+            },\n+            StmtKind::Item(_) => kind!(\"Item(item_id)\"),\n             StmtKind::Expr(e) => {\n-                let e_pat = self.next(\"e\");\n-                println!(\"Expr(ref {}, _) = {}\", e_pat, current);\n-                self.current = e_pat;\n-                self.visit_expr(e);\n+                bind!(self, e);\n+                kind!(\"Expr({e})\");\n+                self.expr(e);\n             },\n-\n-            // Expr with trailing semi-colon (may have any type):\n             StmtKind::Semi(e) => {\n-                let e_pat = self.next(\"e\");\n-                println!(\"Semi(ref {}, _) = {}\", e_pat, current);\n-                self.current = e_pat;\n-                self.visit_expr(e);\n+                bind!(self, e);\n+                kind!(\"Semi({e})\");\n+                self.expr(e);\n             },\n         }\n     }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n }\n \n fn has_attr(cx: &LateContext<'_>, hir_id: hir::HirId) -> bool {\n     let attrs = cx.tcx.hir().attrs(hir_id);\n     get_attr(cx.sess(), attrs, \"author\").count() > 0\n }\n \n-fn print_path(path: &QPath<'_>, first: &mut bool) {\n-    match *path {\n-        QPath::Resolved(_, path) => {\n-            for segment in path.segments {\n-                if *first {\n-                    *first = false;\n-                } else {\n-                    print!(\", \");\n-                }\n-                print!(\"{:?}\", segment.ident.as_str());\n-            }\n-        },\n-        QPath::TypeRelative(ty, segment) => match ty.kind {\n-            hir::TyKind::Path(ref inner_path) => {\n-                print_path(inner_path, first);\n-                if *first {\n-                    *first = false;\n-                } else {\n-                    print!(\", \");\n+fn path_to_string(path: &QPath<'_>) -> String {\n+    fn inner(s: &mut String, path: &QPath<'_>) {\n+        match *path {\n+            QPath::Resolved(_, path) => {\n+                for (i, segment) in path.segments.iter().enumerate() {\n+                    if i > 0 {\n+                        *s += \", \";\n+                    }\n+                    write!(s, \"{:?}\", segment.ident.as_str()).unwrap();\n                 }\n-                print!(\"{:?}\", segment.ident.as_str());\n             },\n-            ref other => print!(\"/* unimplemented: {:?}*/\", other),\n-        },\n-        QPath::LangItem(..) => panic!(\"print_path: called for lang item qpath\"),\n+            QPath::TypeRelative(ty, segment) => match &ty.kind {\n+                hir::TyKind::Path(inner_path) => {\n+                    inner(s, inner_path);\n+                    *s += \", \";\n+                    write!(s, \"{:?}\", segment.ident.as_str()).unwrap();\n+                },\n+                other => write!(s, \"/* unimplemented: {:?}*/\", other).unwrap(),\n+            },\n+            QPath::LangItem(..) => panic!(\"path_to_string: called for lang item qpath\"),\n+        }\n     }\n+    let mut s = String::new();\n+    inner(&mut s, path);\n+    s\n }"}, {"sha": "9c83d30eb9cc1a0a691810ff7568a5a6c50bff31", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -15,15 +15,15 @@ pub struct Rename {\n     pub rename: String,\n }\n \n-/// A single disallowed method, used by the `DISALLOWED_METHOD` lint.\n+/// A single disallowed method, used by the `DISALLOWED_METHODS` lint.\n #[derive(Clone, Debug, Deserialize)]\n #[serde(untagged)]\n pub enum DisallowedMethod {\n     Simple(String),\n     WithReason { path: String, reason: Option<String> },\n }\n \n-/// A single disallowed type, used by the `DISALLOWED_TYPE` lint.\n+/// A single disallowed type, used by the `DISALLOWED_TYPES` lint.\n #[derive(Clone, Debug, Deserialize)]\n #[serde(untagged)]\n pub enum DisallowedType {\n@@ -148,7 +148,7 @@ define_Conf! {\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),\n@@ -256,11 +256,11 @@ define_Conf! {\n     ///\n     /// Whether to allow certain wildcard imports (prelude, super in tests).\n     (warn_on_all_wildcard_imports: bool = false),\n-    /// Lint: DISALLOWED_METHOD.\n+    /// Lint: DISALLOWED_METHODS.\n     ///\n     /// The list of disallowed methods, written as fully qualified paths.\n     (disallowed_methods: Vec<crate::utils::conf::DisallowedMethod> = Vec::new()),\n-    /// Lint: DISALLOWED_TYPE.\n+    /// Lint: DISALLOWED_TYPES.\n     ///\n     /// The list of disallowed types, written as fully qualified paths.\n     (disallowed_types: Vec<crate::utils::conf::DisallowedType> = Vec::new()),\n@@ -296,6 +296,12 @@ define_Conf! {\n     ///\n     /// Whether to apply the raw pointer heuristic to determine if a type is `Send`.\n     (enable_raw_pointer_heuristic_for_send: bool = true),\n+    /// Lint: INDEX_REFUTABLE_SLICE.\n+    ///\n+    /// When Clippy suggests using a slice pattern, this is the maximum number of elements allowed in\n+    /// the slice pattern that is suggested. If more elements would be necessary, the lint is suppressed.\n+    /// For example, `[_, _, _, e, ..]` is a slice pattern with 4 elements.\n+    (max_suggested_slice_pattern_length: u64 = 3),\n }\n \n /// Search for the configuration file."}, {"sha": "1f97c8ba7e62cbba28398aa3e43624af357e18ba", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 78, "deletions": 2, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -8,6 +8,7 @@ use clippy_utils::{\n     paths, SpanlessEq,\n };\n use if_chain::if_chain;\n+use rustc_ast as ast;\n use rustc_ast::ast::{Crate, ItemKind, LitKind, ModKind, NodeId};\n use rustc_ast::visit::FnKind;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -25,10 +26,11 @@ use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintCon\n use rustc_middle::hir::map::Map;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty;\n+use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{Symbol, SymbolStr};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{sym, BytePos, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n use std::borrow::{Borrow, Cow};\n@@ -314,6 +316,27 @@ declare_clippy_lint! {\n     \"non-idiomatic `if_chain!` usage\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for invalid `clippy::version` attributes.\n+    ///\n+    /// Valid values are:\n+    /// * \"pre 1.29.0\"\n+    /// * any valid semantic version\n+    pub INVALID_CLIPPY_VERSION_ATTRIBUTE,\n+    internal,\n+    \"found an invalid `clippy::version` attribute\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for declared clippy lints without the `clippy::version` attribute.\n+    ///\n+    pub MISSING_CLIPPY_VERSION_ATTRIBUTE,\n+    internal,\n+    \"found clippy lint without `clippy::version` attribute\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -351,7 +374,7 @@ pub struct LintWithoutLintPass {\n     registered_lints: FxHashSet<Symbol>,\n }\n \n-impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS]);\n+impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE]);\n \n impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n@@ -361,6 +384,8 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n \n         if let hir::ItemKind::Static(ty, Mutability::Not, body_id) = item.kind {\n             if is_lint_ref_type(cx, ty) {\n+                check_invalid_clippy_version_attribute(cx, item);\n+\n                 let expr = &cx.tcx.hir().body(body_id).value;\n                 if_chain! {\n                     if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind;\n@@ -458,6 +483,57 @@ fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &Ty<'_>) -> bool {\n     false\n }\n \n+fn check_invalid_clippy_version_attribute(cx: &LateContext<'_>, item: &'_ Item<'_>) {\n+    if let Some(value) = extract_clippy_version_value(cx, item) {\n+        // The `sym!` macro doesn't work as it only expects a single token.\n+        // It's better to keep it this way and have a direct `Symbol::intern` call here.\n+        if value == Symbol::intern(\"pre 1.29.0\") {\n+            return;\n+        }\n+\n+        if RustcVersion::parse(&*value.as_str()).is_err() {\n+            span_lint_and_help(\n+                cx,\n+                INVALID_CLIPPY_VERSION_ATTRIBUTE,\n+                item.span,\n+                \"this item has an invalid `clippy::version` attribute\",\n+                None,\n+                \"please use a valid sematic version, see `doc/adding_lints.md`\",\n+            );\n+        }\n+    } else {\n+        span_lint_and_help(\n+            cx,\n+            MISSING_CLIPPY_VERSION_ATTRIBUTE,\n+            item.span,\n+            \"this lint is missing the `clippy::version` attribute or version value\",\n+            None,\n+            \"please use a `clippy::version` attribute, see `doc/adding_lints.md`\",\n+        );\n+    }\n+}\n+\n+/// This function extracts the version value of a `clippy::version` attribute if the given value has\n+/// one\n+fn extract_clippy_version_value(cx: &LateContext<'_>, item: &'_ Item<'_>) -> Option<Symbol> {\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    attrs.iter().find_map(|attr| {\n+        if_chain! {\n+            // Identify attribute\n+            if let ast::AttrKind::Normal(ref attr_kind, _) = &attr.kind;\n+            if let [tool_name, attr_name] = &attr_kind.path.segments[..];\n+            if tool_name.ident.name == sym::clippy;\n+            if attr_name.ident.name == sym::version;\n+            if let Some(version) = attr.value_str();\n+            then {\n+                Some(version)\n+            } else {\n+                None\n+            }\n+        }\n+    })\n+}\n+\n struct LintCollector<'a, 'tcx> {\n     output: &'a mut FxHashSet<Symbol>,\n     cx: &'a LateContext<'tcx>,"}, {"sha": "8051c58bad7a2711345098c08abcfa3f873df494", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -25,7 +25,7 @@ use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n use std::path::Path;\n \n-use crate::utils::internal_lints::is_lint_ref_type;\n+use crate::utils::internal_lints::{extract_clippy_version_value, is_lint_ref_type};\n use clippy_utils::{\n     diagnostics::span_lint, last_path_segment, match_def_path, match_function_call, match_path, paths, ty::match_type,\n     ty::walk_ptrs_ty_depth,\n@@ -116,6 +116,8 @@ const DEPRECATED_LINT_TYPE: [&str; 3] = [\"clippy_lints\", \"deprecated_lints\", \"Cl\n const APPLICABILITY_NAME_INDEX: usize = 2;\n /// This applicability will be set for unresolved applicability values.\n const APPLICABILITY_UNRESOLVED_STR: &str = \"Unresolved\";\n+/// The version that will be displayed if none has been defined\n+const VERION_DEFAULT_STR: &str = \"Unknown\";\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -144,6 +146,7 @@ declare_clippy_lint! {\n     ///     \"docs\": \" ### What it does\\nCollects metadata about clippy lints for the website. [...] \"\n     /// }\n     /// ```\n+    #[clippy::version = \"1.56.0\"]\n     pub INTERNAL_METADATA_COLLECTOR,\n     internal_warn,\n     \"A busy bee collection metadata about lints\"\n@@ -215,18 +218,27 @@ struct LintMetadata {\n     group: String,\n     level: String,\n     docs: String,\n+    version: String,\n     /// This field is only used in the output and will only be\n     /// mapped shortly before the actual output.\n     applicability: Option<ApplicabilityInfo>,\n }\n \n impl LintMetadata {\n-    fn new(id: String, id_span: SerializableSpan, group: String, level: &'static str, docs: String) -> Self {\n+    fn new(\n+        id: String,\n+        id_span: SerializableSpan,\n+        group: String,\n+        level: &'static str,\n+        version: String,\n+        docs: String,\n+    ) -> Self {\n         Self {\n             id,\n             id_span,\n             group,\n             level: level.to_string(),\n+            version,\n             docs,\n             applicability: None,\n         }\n@@ -410,12 +422,14 @@ impl<'hir> LateLintPass<'hir> for MetadataCollector {\n                     if let Some(configuration_section) = self.get_lint_configs(&lint_name) {\n                         docs.push_str(&configuration_section);\n                     }\n+                    let version = get_lint_version(cx, item);\n \n                     self.lints.push(LintMetadata::new(\n                         lint_name,\n                         SerializableSpan::from_item(cx, item),\n                         group,\n                         level,\n+                        version,\n                         docs,\n                     ));\n                 }\n@@ -429,11 +443,14 @@ impl<'hir> LateLintPass<'hir> for MetadataCollector {\n                 // Metadata the little we can get from a deprecated lint\n                 if let Some(docs) = extract_attr_docs_or_lint(cx, item);\n                 then {\n+                    let version = get_lint_version(cx, item);\n+\n                     self.lints.push(LintMetadata::new(\n                         lint_name,\n                         SerializableSpan::from_item(cx, item),\n                         DEPRECATED_LINT_GROUP_STR.to_string(),\n                         DEPRECATED_LINT_LEVEL,\n+                        version,\n                         docs,\n                     ));\n                 }\n@@ -552,6 +569,13 @@ fn extract_attr_docs(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n     Some(docs)\n }\n \n+fn get_lint_version(cx: &LateContext<'_>, item: &Item<'_>) -> String {\n+    extract_clippy_version_value(cx, item).map_or_else(\n+        || VERION_DEFAULT_STR.to_string(),\n+        |version| version.as_str().to_string(),\n+    )\n+}\n+\n fn get_lint_group_and_level_or_lint(\n     cx: &LateContext<'_>,\n     lint_name: &str,\n@@ -663,7 +687,6 @@ fn extract_emission_info<'hir>(\n             applicability = resolve_applicability(cx, arg);\n         } else if arg_ty.is_closure() {\n             multi_part |= check_is_multi_part(cx, arg);\n-            // TODO xFrednet 2021-03-01: don't use or_else but rather a comparison\n             applicability = applicability.or_else(|| resolve_applicability(cx, arg));\n         }\n     }"}, {"sha": "79e7410c3a8381183f256da06d11fb7a446db435", "filename": "src/tools/clippy/clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -36,6 +36,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// foo(&[1, 2]);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub USELESS_VEC,\n     perf,\n     \"useless `vec!`\""}, {"sha": "1bc0eb6303c01f692c04d08fdf29f94e86fecf0a", "filename": "src/tools/clippy/clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -27,6 +27,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let v = vec![0];\n     /// ```\n+    #[clippy::version = \"1.51.0\"]\n     pub VEC_INIT_THEN_PUSH,\n     perf,\n     \"`push` immediately after `Vec` creation\""}, {"sha": "3441d9ccdfa25db333ee7a22456b3eb952ddcb4e", "filename": "src/tools/clippy/clippy_lints/src/vec_resize_to_zero.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -20,6 +20,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// vec!(1, 2, 3, 4, 5).resize(0, 5)\n     /// ```\n+    #[clippy::version = \"1.46.0\"]\n     pub VEC_RESIZE_TO_ZERO,\n     correctness,\n     \"emptying a vector with `resize(0, an_int)` instead of `clear()` is probably an argument inversion mistake\""}, {"sha": "ebdaff1e676b7e187511536f6dca84bc38f58804", "filename": "src/tools/clippy/clippy_lints/src/verbose_file_reads.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -27,6 +27,7 @@ declare_clippy_lint! {\n     /// # use std::fs;\n     /// let mut bytes = fs::read(\"foo.txt\").unwrap();\n     /// ```\n+    #[clippy::version = \"1.44.0\"]\n     pub VERBOSE_FILE_READS,\n     restriction,\n     \"use of `File::read_to_end` or `File::read_to_string`\""}, {"sha": "80d7b8a1b6df559820863c39c0199f9abb88615c", "filename": "src/tools/clippy/clippy_lints/src/wildcard_dependencies.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_dependencies.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -20,6 +20,7 @@ declare_clippy_lint! {\n     /// [dependencies]\n     /// regex = \"*\"\n     /// ```\n+    #[clippy::version = \"1.32.0\"]\n     pub WILDCARD_DEPENDENCIES,\n     cargo,\n     \"wildcard dependencies being used\""}, {"sha": "832da66a53695c55287ddda2eb3dc1343cab1b0a", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_test_module_or_function;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::{in_macro, is_test_module_or_function};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n@@ -34,6 +34,7 @@ declare_clippy_lint! {\n     /// use std::cmp::Ordering;\n     /// foo(Ordering::Less)\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ENUM_GLOB_USE,\n     pedantic,\n     \"use items that import all variants of an enum\"\n@@ -86,6 +87,7 @@ declare_clippy_lint! {\n     ///\n     /// foo();\n     /// ```\n+    #[clippy::version = \"1.43.0\"]\n     pub WILDCARD_IMPORTS,\n     pedantic,\n     \"lint `use _::*` statements\"\n@@ -196,7 +198,7 @@ impl LateLintPass<'_> for WildcardImports {\n \n impl WildcardImports {\n     fn check_exceptions(&self, item: &Item<'_>, segments: &[PathSegment<'_>]) -> bool {\n-        in_macro(item.span)\n+        item.span.from_expansion()\n             || is_prelude_import(segments)\n             || (is_super_only_import(segments) && self.test_modules_deep > 0)\n     }"}, {"sha": "5bf0cffdbad16a52983d0f7f48e2ad476c4cd8e4", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -31,6 +31,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// println!();\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub PRINTLN_EMPTY_STRING,\n     style,\n     \"using `println!(\\\"\\\")` with an empty string\"\n@@ -55,6 +56,7 @@ declare_clippy_lint! {\n     /// # let name = \"World\";\n     /// println!(\"Hello {}!\", name);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub PRINT_WITH_NEWLINE,\n     style,\n     \"using `print!()` with a format string that ends in a single newline\"\n@@ -70,12 +72,19 @@ declare_clippy_lint! {\n     /// application and might forget to remove those prints afterward.\n     ///\n     /// ### Known problems\n-    /// Only catches `print!` and `println!` calls.\n+    /// * Only catches `print!` and `println!` calls.\n+    /// * The lint level is unaffected by crate attributes. The level can still\n+    ///   be set for functions, modules and other items. To change the level for\n+    ///   the entire crate, please use command line flags. More information and a\n+    ///   configuration example can be found in [clippy#6610].\n+    ///\n+    /// [clippy#6610]: https://github.com/rust-lang/rust-clippy/issues/6610#issuecomment-977120558\n     ///\n     /// ### Example\n     /// ```rust\n     /// println!(\"Hello world!\");\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub PRINT_STDOUT,\n     restriction,\n     \"printing on stdout\"\n@@ -91,12 +100,19 @@ declare_clippy_lint! {\n     /// application and might forget to remove those prints afterward.\n     ///\n     /// ### Known problems\n-    /// Only catches `eprint!` and `eprintln!` calls.\n+    /// * Only catches `eprint!` and `eprintln!` calls.\n+    /// * The lint level is unaffected by crate attributes. The level can still\n+    ///   be set for functions, modules and other items. To change the level for\n+    ///   the entire crate, please use command line flags. More information and a\n+    ///   configuration example can be found in [clippy#6610].\n+    ///\n+    /// [clippy#6610]: https://github.com/rust-lang/rust-clippy/issues/6610#issuecomment-977120558\n     ///\n     /// ### Example\n     /// ```rust\n     /// eprintln!(\"Hello world!\");\n     /// ```\n+    #[clippy::version = \"1.50.0\"]\n     pub PRINT_STDERR,\n     restriction,\n     \"printing on stderr\"\n@@ -116,6 +132,7 @@ declare_clippy_lint! {\n     /// # let foo = \"bar\";\n     /// println!(\"{:?}\", foo);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub USE_DEBUG,\n     restriction,\n     \"use of `Debug`-based formatting\"\n@@ -142,6 +159,7 @@ declare_clippy_lint! {\n     /// ```rust\n     /// println!(\"foo\");\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub PRINT_LITERAL,\n     style,\n     \"printing a literal with a format string\"\n@@ -165,6 +183,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// writeln!(buf);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub WRITELN_EMPTY_STRING,\n     style,\n     \"using `writeln!(buf, \\\"\\\")` with an empty string\"\n@@ -191,6 +210,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// writeln!(buf, \"Hello {}!\", name);\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub WRITE_WITH_NEWLINE,\n     style,\n     \"using `write!()` with a format string that ends in a single newline\"\n@@ -219,6 +239,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// writeln!(buf, \"foo\");\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub WRITE_LITERAL,\n     style,\n     \"writing a literal with a format string\"\n@@ -562,10 +583,10 @@ impl Write {\n             let replacement: String = match lit.token.kind {\n                 LitKind::Integer | LitKind::Float | LitKind::Err => continue,\n                 LitKind::StrRaw(_) | LitKind::ByteStrRaw(_) if matches!(fmtstr.style, StrStyle::Raw(_)) => {\n-                    lit.token.symbol.as_str().replace(\"{\", \"{{\").replace(\"}\", \"}}\")\n+                    lit.token.symbol.as_str().replace('{', \"{{\").replace('}', \"}}\")\n                 },\n                 LitKind::Str | LitKind::ByteStr if matches!(fmtstr.style, StrStyle::Cooked) => {\n-                    lit.token.symbol.as_str().replace(\"{\", \"{{\").replace(\"}\", \"}}\")\n+                    lit.token.symbol.as_str().replace('{', \"{{\").replace('}', \"}}\")\n                 },\n                 LitKind::StrRaw(_) | LitKind::Str | LitKind::ByteStrRaw(_) | LitKind::ByteStr => continue,\n                 LitKind::Byte | LitKind::Char => match &*lit.token.symbol.as_str() {"}, {"sha": "641681185a2f60a7ad48d672690b88786f2d8ca5", "filename": "src/tools/clippy/clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -20,6 +20,7 @@ declare_clippy_lint! {\n     /// // Good\n     /// let nan = f32::NAN;\n     /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n     pub ZERO_DIVIDED_BY_ZERO,\n     complexity,\n     \"usage of `0.0 / 0.0` to obtain NaN instead of `f32::NAN` or `f64::NAN`\""}, {"sha": "eb8436a501d54b057010db4c95b6f67a68a9452e", "filename": "src/tools/clippy/clippy_lints/src/zero_sized_map_values.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -36,6 +36,7 @@ declare_clippy_lint! {\n     ///     todo!();\n     /// }\n     /// ```\n+    #[clippy::version = \"1.50.0\"]\n     pub ZERO_SIZED_MAP_VALUES,\n     pedantic,\n     \"usage of map with zero-sized value type\""}, {"sha": "0ba0b59ed13daf6f93653f554b03f6a4d0a0076f", "filename": "src/tools/clippy/clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_utils\"\n-version = \"0.1.58\"\n+version = \"0.1.59\"\n edition = \"2021\"\n publish = false\n "}, {"sha": "8400bfbbd99d2550d09021754a61ffc8e4cf5f9b", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 101, "deletions": 14, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -243,15 +243,28 @@ pub fn eq_item<K>(l: &Item<K>, r: &Item<K>, mut eq_kind: impl FnMut(&K, &K) -> b\n     eq_id(l.ident, r.ident) && over(&l.attrs, &r.attrs, eq_attr) && eq_vis(&l.vis, &r.vis) && eq_kind(&l.kind, &r.kind)\n }\n \n+#[allow(clippy::too_many_lines)] // Just a big match statement\n pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n     use ItemKind::*;\n     match (l, r) {\n         (ExternCrate(l), ExternCrate(r)) => l == r,\n         (Use(l), Use(r)) => eq_use_tree(l, r),\n         (Static(lt, lm, le), Static(rt, rm, re)) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n         (Const(ld, lt, le), Const(rd, rt, re)) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n-        (Fn(box ast::Fn { defaultness: ld, sig: lf, generics: lg, body: lb }),\n-         Fn(box ast::Fn { defaultness: rd, sig: rf, generics: rg, body: rb })) => {\n+        (\n+            Fn(box ast::Fn {\n+                defaultness: ld,\n+                sig: lf,\n+                generics: lg,\n+                body: lb,\n+            }),\n+            Fn(box ast::Fn {\n+                defaultness: rd,\n+                sig: rf,\n+                generics: rg,\n+                body: rb,\n+            }),\n+        ) => {\n             eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n         },\n         (Mod(lu, lmk), Mod(ru, rmk)) => {\n@@ -267,8 +280,20 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n         (ForeignMod(l), ForeignMod(r)) => {\n             both(&l.abi, &r.abi, eq_str_lit) && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_foreign_item_kind))\n         },\n-        (TyAlias(box ast::TyAlias { defaultness: ld, generics: lg, bounds: lb, ty: lt }),\n-         TyAlias(box ast::TyAlias { defaultness: rd, generics: rg, bounds: rb, ty: rt })) => {\n+        (\n+            TyAlias(box ast::TyAlias {\n+                defaultness: ld,\n+                generics: lg,\n+                bounds: lb,\n+                ty: lt,\n+            }),\n+            TyAlias(box ast::TyAlias {\n+                defaultness: rd,\n+                generics: rg,\n+                bounds: rb,\n+                ty: rt,\n+            }),\n+        ) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n                 && over(lb, rb, eq_generic_bound)\n@@ -278,8 +303,22 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n         (Struct(lv, lg), Struct(rv, rg)) | (Union(lv, lg), Union(rv, rg)) => {\n             eq_variant_data(lv, rv) && eq_generics(lg, rg)\n         },\n-        (Trait(box ast::Trait { is_auto: la, unsafety: lu, generics: lg, bounds: lb, items: li }),\n-         Trait(box ast::Trait { is_auto: ra, unsafety: ru, generics: rg, bounds: rb, items: ri })) => {\n+        (\n+            Trait(box ast::Trait {\n+                is_auto: la,\n+                unsafety: lu,\n+                generics: lg,\n+                bounds: lb,\n+                items: li,\n+            }),\n+            Trait(box ast::Trait {\n+                is_auto: ra,\n+                unsafety: ru,\n+                generics: rg,\n+                bounds: rb,\n+                items: ri,\n+            }),\n+        ) => {\n             la == ra\n                 && matches!(lu, Unsafe::No) == matches!(ru, Unsafe::No)\n                 && eq_generics(lg, rg)\n@@ -328,12 +367,36 @@ pub fn eq_foreign_item_kind(l: &ForeignItemKind, r: &ForeignItemKind) -> bool {\n     use ForeignItemKind::*;\n     match (l, r) {\n         (Static(lt, lm, le), Static(rt, rm, re)) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n-        (Fn(box ast::Fn { defaultness: ld, sig: lf, generics: lg, body: lb }),\n-         Fn(box ast::Fn { defaultness: rd, sig: rf, generics: rg, body: rb })) => {\n+        (\n+            Fn(box ast::Fn {\n+                defaultness: ld,\n+                sig: lf,\n+                generics: lg,\n+                body: lb,\n+            }),\n+            Fn(box ast::Fn {\n+                defaultness: rd,\n+                sig: rf,\n+                generics: rg,\n+                body: rb,\n+            }),\n+        ) => {\n             eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n         },\n-        (TyAlias(box ast::TyAlias { defaultness: ld, generics: lg, bounds: lb, ty: lt }),\n-         TyAlias(box ast::TyAlias { defaultness: rd, generics: rg, bounds: rb, ty: rt })) => {\n+        (\n+            TyAlias(box ast::TyAlias {\n+                defaultness: ld,\n+                generics: lg,\n+                bounds: lb,\n+                ty: lt,\n+            }),\n+            TyAlias(box ast::TyAlias {\n+                defaultness: rd,\n+                generics: rg,\n+                bounds: rb,\n+                ty: rt,\n+            }),\n+        ) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n                 && over(lb, rb, eq_generic_bound)\n@@ -348,12 +411,36 @@ pub fn eq_assoc_item_kind(l: &AssocItemKind, r: &AssocItemKind) -> bool {\n     use AssocItemKind::*;\n     match (l, r) {\n         (Const(ld, lt, le), Const(rd, rt, re)) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n-        (Fn(box ast::Fn { defaultness: ld, sig: lf, generics: lg, body: lb }),\n-         Fn(box ast::Fn { defaultness: rd, sig: rf, generics: rg, body: rb })) => {\n+        (\n+            Fn(box ast::Fn {\n+                defaultness: ld,\n+                sig: lf,\n+                generics: lg,\n+                body: lb,\n+            }),\n+            Fn(box ast::Fn {\n+                defaultness: rd,\n+                sig: rf,\n+                generics: rg,\n+                body: rb,\n+            }),\n+        ) => {\n             eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n         },\n-        (TyAlias(box ast::TyAlias { defaultness: ld, generics: lg, bounds: lb, ty: lt }),\n-         TyAlias(box ast::TyAlias { defaultness: rd, generics: rg, bounds: rb, ty: rt })) => {\n+        (\n+            TyAlias(box ast::TyAlias {\n+                defaultness: ld,\n+                generics: lg,\n+                bounds: lb,\n+                ty: lt,\n+            }),\n+            TyAlias(box ast::TyAlias {\n+                defaultness: rd,\n+                generics: rg,\n+                bounds: rb,\n+                ty: rt,\n+            }),\n+        ) => {\n             eq_defaultness(*ld, *rd)\n                 && eq_generics(lg, rg)\n                 && over(lb, rb, eq_generic_bound)"}, {"sha": "7ae9615d560b662095a84fd9e64c6f2070adbee7", "filename": "src/tools/clippy/clippy_utils/src/attrs.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -14,15 +14,14 @@ pub enum DeprecationStatus {\n     None,\n }\n \n+#[rustfmt::skip]\n pub const BUILTIN_ATTRIBUTES: &[(&str, DeprecationStatus)] = &[\n-    (\"author\", DeprecationStatus::None),\n-    (\"cognitive_complexity\", DeprecationStatus::None),\n-    (\n-        \"cyclomatic_complexity\",\n-        DeprecationStatus::Replaced(\"cognitive_complexity\"),\n-    ),\n-    (\"dump\", DeprecationStatus::None),\n-    (\"msrv\", DeprecationStatus::None),\n+    (\"author\",                DeprecationStatus::None),\n+    (\"version\",               DeprecationStatus::None),\n+    (\"cognitive_complexity\",  DeprecationStatus::None),\n+    (\"cyclomatic_complexity\", DeprecationStatus::Replaced(\"cognitive_complexity\")),\n+    (\"dump\",                  DeprecationStatus::None),\n+    (\"msrv\",                  DeprecationStatus::None),\n ];\n \n pub struct LimitStack {"}, {"sha": "c2645ac730a44322423b24e07a80930c695d50a4", "filename": "src/tools/clippy/clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 203, "deletions": 104, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -9,128 +9,227 @@\n //!  - or-fun-call\n //!  - option-if-let-else\n \n-use crate::is_ctor_or_promotable_const_function;\n-use crate::ty::is_type_diagnostic_item;\n+use crate::ty::{all_predicates_of, is_copy};\n+use crate::visitors::is_const_evaluatable;\n use rustc_hir::def::{DefKind, Res};\n-\n-use rustc_hir::intravisit;\n-use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n-\n-use rustc_hir::{Block, Expr, ExprKind, Path, QPath};\n+use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n+use rustc_hir::{def_id::DefId, Block, Expr, ExprKind, QPath, UnOp};\n use rustc_lint::LateContext;\n-use rustc_middle::hir::map::Map;\n-use rustc_span::sym;\n-\n-/// Is the expr pure (is it free from side-effects)?\n-/// This function is named so to stress that it isn't exhaustive and returns FNs.\n-fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Lit(..) | ExprKind::ConstBlock(..) | ExprKind::Path(..) | ExprKind::Field(..) => true,\n-        ExprKind::AddrOf(_, _, addr_of_expr) => identify_some_pure_patterns(addr_of_expr),\n-        ExprKind::Tup(tup_exprs) => tup_exprs.iter().all(identify_some_pure_patterns),\n-        ExprKind::Struct(_, fields, expr) => {\n-            fields.iter().all(|f| identify_some_pure_patterns(f.expr)) && expr.map_or(true, identify_some_pure_patterns)\n-        },\n-        ExprKind::Call(\n-            &Expr {\n-                kind:\n-                    ExprKind::Path(QPath::Resolved(\n-                        _,\n-                        Path {\n-                            res: Res::Def(DefKind::Ctor(..) | DefKind::Variant, ..),\n-                            ..\n-                        },\n-                    )),\n-                ..\n-            },\n-            args,\n-        ) => args.iter().all(identify_some_pure_patterns),\n-        ExprKind::Block(\n-            &Block {\n-                stmts,\n-                expr: Some(expr),\n-                ..\n-            },\n-            _,\n-        ) => stmts.is_empty() && identify_some_pure_patterns(expr),\n-        ExprKind::Box(..)\n-        | ExprKind::Array(..)\n-        | ExprKind::Call(..)\n-        | ExprKind::MethodCall(..)\n-        | ExprKind::Binary(..)\n-        | ExprKind::Unary(..)\n-        | ExprKind::Let(..)\n-        | ExprKind::Cast(..)\n-        | ExprKind::Type(..)\n-        | ExprKind::DropTemps(..)\n-        | ExprKind::Loop(..)\n-        | ExprKind::If(..)\n-        | ExprKind::Match(..)\n-        | ExprKind::Closure(..)\n-        | ExprKind::Block(..)\n-        | ExprKind::Assign(..)\n-        | ExprKind::AssignOp(..)\n-        | ExprKind::Index(..)\n-        | ExprKind::Break(..)\n-        | ExprKind::Continue(..)\n-        | ExprKind::Ret(..)\n-        | ExprKind::InlineAsm(..)\n-        | ExprKind::LlvmInlineAsm(..)\n-        | ExprKind::Repeat(..)\n-        | ExprKind::Yield(..)\n-        | ExprKind::Err => false,\n+use rustc_middle::ty::{self, PredicateKind};\n+use rustc_span::{sym, Symbol};\n+use std::cmp;\n+use std::ops;\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+enum EagernessSuggestion {\n+    // The expression is cheap and should be evaluated eagerly\n+    Eager,\n+    // The expression may be cheap, so don't suggested lazy evaluation; or the expression may not be safe to switch to\n+    // eager evaluation.\n+    NoChange,\n+    // The expression is likely expensive and should be evaluated lazily.\n+    Lazy,\n+    // The expression cannot be placed into a closure.\n+    ForceNoChange,\n+}\n+impl ops::BitOr for EagernessSuggestion {\n+    type Output = Self;\n+    fn bitor(self, rhs: Self) -> Self {\n+        cmp::max(self, rhs)\n     }\n }\n-\n-/// Identify some potentially computationally expensive patterns.\n-/// This function is named so to stress that its implementation is non-exhaustive.\n-/// It returns FNs and FPs.\n-fn identify_some_potentially_expensive_patterns<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    // Searches an expression for method calls or function calls that aren't ctors\n-    struct FunCallFinder<'a, 'tcx> {\n-        cx: &'a LateContext<'tcx>,\n-        found: bool,\n+impl ops::BitOrAssign for EagernessSuggestion {\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        *self = *self | rhs;\n     }\n+}\n \n-    impl<'a, 'tcx> intravisit::Visitor<'tcx> for FunCallFinder<'a, 'tcx> {\n-        type Map = Map<'tcx>;\n-\n-        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-            let call_found = match &expr.kind {\n-                // ignore enum and struct constructors\n-                ExprKind::Call(..) => !is_ctor_or_promotable_const_function(self.cx, expr),\n-                ExprKind::Index(obj, _) => {\n-                    let ty = self.cx.typeck_results().expr_ty(obj);\n-                    is_type_diagnostic_item(self.cx, ty, sym::HashMap)\n-                        || is_type_diagnostic_item(self.cx, ty, sym::BTreeMap)\n-                },\n-                ExprKind::MethodCall(..) => true,\n-                _ => false,\n-            };\n+/// Determine the eagerness of the given function call.\n+fn fn_eagerness(cx: &LateContext<'tcx>, fn_id: DefId, name: Symbol, args: &'tcx [Expr<'_>]) -> EagernessSuggestion {\n+    use EagernessSuggestion::{Eager, Lazy, NoChange};\n+    let name = &*name.as_str();\n \n-            if call_found {\n-                self.found |= true;\n-            }\n+    let ty = match cx.tcx.impl_of_method(fn_id) {\n+        Some(id) => cx.tcx.type_of(id),\n+        None => return Lazy,\n+    };\n \n-            if !self.found {\n-                intravisit::walk_expr(self, expr);\n+    if (name.starts_with(\"as_\") || name == \"len\" || name == \"is_empty\") && args.len() == 1 {\n+        if matches!(\n+            cx.tcx.crate_name(fn_id.krate),\n+            sym::std | sym::core | sym::alloc | sym::proc_macro\n+        ) {\n+            Eager\n+        } else {\n+            NoChange\n+        }\n+    } else if let ty::Adt(def, subs) = ty.kind() {\n+        // Types where the only fields are generic types (or references to) with no trait bounds other\n+        // than marker traits.\n+        // Due to the limited operations on these types functions should be fairly cheap.\n+        if def\n+            .variants\n+            .iter()\n+            .flat_map(|v| v.fields.iter())\n+            .any(|x| matches!(cx.tcx.type_of(x.did).peel_refs().kind(), ty::Param(_)))\n+            && all_predicates_of(cx.tcx, fn_id).all(|(pred, _)| match pred.kind().skip_binder() {\n+                PredicateKind::Trait(pred) => cx.tcx.trait_def(pred.trait_ref.def_id).is_marker,\n+                _ => true,\n+            })\n+            && subs.types().all(|x| matches!(x.peel_refs().kind(), ty::Param(_)))\n+        {\n+            // Limit the function to either `(self) -> bool` or `(&self) -> bool`\n+            match &**cx.tcx.fn_sig(fn_id).skip_binder().inputs_and_output {\n+                [arg, res] if !arg.is_mutable_ptr() && arg.peel_refs() == ty && res.is_bool() => NoChange,\n+                _ => Lazy,\n             }\n+        } else {\n+            Lazy\n         }\n+    } else {\n+        Lazy\n+    }\n+}\n \n+#[allow(clippy::too_many_lines)]\n+fn expr_eagerness(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessSuggestion {\n+    struct V<'cx, 'tcx> {\n+        cx: &'cx LateContext<'tcx>,\n+        eagerness: EagernessSuggestion,\n+    }\n+\n+    impl<'cx, 'tcx> Visitor<'tcx> for V<'cx, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n         fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n             NestedVisitorMap::None\n         }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            use EagernessSuggestion::{ForceNoChange, Lazy, NoChange};\n+            if self.eagerness == ForceNoChange {\n+                return;\n+            }\n+            match e.kind {\n+                ExprKind::Call(\n+                    &Expr {\n+                        kind: ExprKind::Path(ref path),\n+                        hir_id,\n+                        ..\n+                    },\n+                    args,\n+                ) => match self.cx.qpath_res(path, hir_id) {\n+                    Res::Def(DefKind::Ctor(..) | DefKind::Variant, _) | Res::SelfCtor(_) => (),\n+                    Res::Def(_, id) if self.cx.tcx.is_promotable_const_fn(id) => (),\n+                    // No need to walk the arguments here, `is_const_evaluatable` already did\n+                    Res::Def(..) if is_const_evaluatable(self.cx, e) => {\n+                        self.eagerness |= NoChange;\n+                        return;\n+                    },\n+                    Res::Def(_, id) => match path {\n+                        QPath::Resolved(_, p) => {\n+                            self.eagerness |= fn_eagerness(self.cx, id, p.segments.last().unwrap().ident.name, args);\n+                        },\n+                        QPath::TypeRelative(_, name) => {\n+                            self.eagerness |= fn_eagerness(self.cx, id, name.ident.name, args);\n+                        },\n+                        QPath::LangItem(..) => self.eagerness = Lazy,\n+                    },\n+                    _ => self.eagerness = Lazy,\n+                },\n+                // No need to walk the arguments here, `is_const_evaluatable` already did\n+                ExprKind::MethodCall(..) if is_const_evaluatable(self.cx, e) => {\n+                    self.eagerness |= NoChange;\n+                    return;\n+                },\n+                ExprKind::MethodCall(name, _, args, _) => {\n+                    self.eagerness |= self\n+                        .cx\n+                        .typeck_results()\n+                        .type_dependent_def_id(e.hir_id)\n+                        .map_or(Lazy, |id| fn_eagerness(self.cx, id, name.ident.name, args));\n+                },\n+                ExprKind::Index(_, e) => {\n+                    let ty = self.cx.typeck_results().expr_ty_adjusted(e);\n+                    if is_copy(self.cx, ty) && !ty.is_ref() {\n+                        self.eagerness |= NoChange;\n+                    } else {\n+                        self.eagerness = Lazy;\n+                    }\n+                },\n+\n+                // Dereferences should be cheap, but dereferencing a raw pointer earlier may not be safe.\n+                ExprKind::Unary(UnOp::Deref, e) if !self.cx.typeck_results().expr_ty(e).is_unsafe_ptr() => (),\n+                ExprKind::Unary(UnOp::Deref, _) => self.eagerness |= NoChange,\n+\n+                ExprKind::Unary(_, e)\n+                    if matches!(\n+                        self.cx.typeck_results().expr_ty(e).kind(),\n+                        ty::Bool | ty::Int(_) | ty::Uint(_),\n+                    ) => {},\n+                ExprKind::Binary(_, lhs, rhs)\n+                    if self.cx.typeck_results().expr_ty(lhs).is_primitive()\n+                        && self.cx.typeck_results().expr_ty(rhs).is_primitive() => {},\n+\n+                // Can't be moved into a closure\n+                ExprKind::Break(..)\n+                | ExprKind::Continue(_)\n+                | ExprKind::Ret(_)\n+                | ExprKind::InlineAsm(_)\n+                | ExprKind::LlvmInlineAsm(_)\n+                | ExprKind::Yield(..)\n+                | ExprKind::Err => {\n+                    self.eagerness = ForceNoChange;\n+                    return;\n+                },\n+\n+                // Memory allocation, custom operator, loop, or call to an unknown function\n+                ExprKind::Box(_)\n+                | ExprKind::Unary(..)\n+                | ExprKind::Binary(..)\n+                | ExprKind::Loop(..)\n+                | ExprKind::Call(..) => self.eagerness = Lazy,\n+\n+                ExprKind::ConstBlock(_)\n+                | ExprKind::Array(_)\n+                | ExprKind::Tup(_)\n+                | ExprKind::Lit(_)\n+                | ExprKind::Cast(..)\n+                | ExprKind::Type(..)\n+                | ExprKind::DropTemps(_)\n+                | ExprKind::Let(..)\n+                | ExprKind::If(..)\n+                | ExprKind::Match(..)\n+                | ExprKind::Closure(..)\n+                | ExprKind::Field(..)\n+                | ExprKind::Path(_)\n+                | ExprKind::AddrOf(..)\n+                | ExprKind::Struct(..)\n+                | ExprKind::Repeat(..)\n+                | ExprKind::Block(Block { stmts: [], .. }, _) => (),\n+\n+                // Assignment might be to a local defined earlier, so don't eagerly evaluate.\n+                // Blocks with multiple statements might be expensive, so don't eagerly evaluate.\n+                // TODO: Actually check if either of these are true here.\n+                ExprKind::Assign(..) | ExprKind::AssignOp(..) | ExprKind::Block(..) => self.eagerness |= NoChange,\n+            }\n+            walk_expr(self, e);\n+        }\n     }\n \n-    let mut finder = FunCallFinder { cx, found: false };\n-    finder.visit_expr(expr);\n-    finder.found\n+    let mut v = V {\n+        cx,\n+        eagerness: EagernessSuggestion::Eager,\n+    };\n+    v.visit_expr(e);\n+    v.eagerness\n }\n \n-pub fn is_eagerness_candidate<'a, 'tcx>(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    !identify_some_potentially_expensive_patterns(cx, expr) && identify_some_pure_patterns(expr)\n+/// Whether the given expression should be changed to evaluate eagerly\n+pub fn switch_to_eager_eval(cx: &'_ LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    expr_eagerness(cx, expr) == EagernessSuggestion::Eager\n }\n \n-pub fn is_lazyness_candidate<'a, 'tcx>(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    identify_some_potentially_expensive_patterns(cx, expr)\n+/// Whether the given expression should be changed to evaluate lazily\n+pub fn switch_to_lazy_eval(cx: &'_ LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    expr_eagerness(cx, expr) == EagernessSuggestion::Lazy\n }"}, {"sha": "f011380c127a25c10939ed22c1cb07796248e5a4", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,6 +1,7 @@\n #![feature(box_patterns)]\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n+#![feature(let_else)]\n #![feature(rustc_private)]\n #![feature(control_flow_enum)]\n #![recursion_limit = \"512\"]\n@@ -68,7 +69,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n-use rustc_hir::intravisit::{self, walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n@@ -96,6 +97,7 @@ use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n use crate::ty::{can_partially_move_ty, is_copy, is_recursively_primitive_type};\n+use crate::visitors::expr_visitor_no_bodies;\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -250,12 +252,6 @@ pub fn is_lang_ctor(cx: &LateContext<'_>, qpath: &QPath<'_>, lang_item: LangItem\n     false\n }\n \n-/// Returns `true` if this `span` was expanded by any macro.\n-#[must_use]\n-pub fn in_macro(span: Span) -> bool {\n-    span.from_expansion() && !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n-}\n-\n pub fn is_unit_expr(expr: &Expr<'_>) -> bool {\n     matches!(\n         expr.kind,\n@@ -1113,63 +1109,30 @@ pub fn contains_name(name: Symbol, expr: &Expr<'_>) -> bool {\n \n /// Returns `true` if `expr` contains a return expression\n pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n-    struct RetCallFinder {\n-        found: bool,\n-    }\n-\n-    impl<'tcx> hir::intravisit::Visitor<'tcx> for RetCallFinder {\n-        type Map = Map<'tcx>;\n-\n-        fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-            if self.found {\n-                return;\n-            }\n+    let mut found = false;\n+    expr_visitor_no_bodies(|expr| {\n+        if !found {\n             if let hir::ExprKind::Ret(..) = &expr.kind {\n-                self.found = true;\n-            } else {\n-                hir::intravisit::walk_expr(self, expr);\n+                found = true;\n             }\n         }\n-\n-        fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n-            hir::intravisit::NestedVisitorMap::None\n-        }\n-    }\n-\n-    let mut visitor = RetCallFinder { found: false };\n-    visitor.visit_expr(expr);\n-    visitor.found\n-}\n-\n-struct FindMacroCalls<'a, 'b> {\n-    names: &'a [&'b str],\n-    result: Vec<Span>,\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for FindMacroCalls<'a, 'b> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.names.iter().any(|fun| is_expn_of(expr.span, fun).is_some()) {\n-            self.result.push(expr.span);\n-        }\n-        // and check sub-expressions\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n+        !found\n+    })\n+    .visit_expr(expr);\n+    found\n }\n \n /// Finds calls of the specified macros in a function body.\n pub fn find_macro_calls(names: &[&str], body: &Body<'_>) -> Vec<Span> {\n-    let mut fmc = FindMacroCalls {\n-        names,\n-        result: Vec::new(),\n-    };\n-    fmc.visit_expr(&body.value);\n-    fmc.result\n+    let mut result = Vec::new();\n+    expr_visitor_no_bodies(|expr| {\n+        if names.iter().any(|fun| is_expn_of(expr.span, fun).is_some()) {\n+            result.push(expr.span);\n+        }\n+        true\n+    })\n+    .visit_expr(&body.value);\n+    result\n }\n \n /// Extends the span to the beginning of the spans line, incl. whitespaces.\n@@ -1439,7 +1402,7 @@ pub fn recurse_or_patterns<'tcx, F: FnMut(&'tcx Pat<'tcx>)>(pat: &'tcx Pat<'tcx>\n /// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n /// implementations have.\n pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(sym::automatically_derived))\n+    has_attr(attrs, sym::automatically_derived)\n }\n \n /// Remove blocks around an expression.\n@@ -1561,20 +1524,29 @@ pub fn clip(tcx: TyCtxt<'_>, u: u128, ity: rustc_ty::UintTy) -> u128 {\n     (u << amt) >> amt\n }\n \n-pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_>, node: HirId) -> bool {\n+pub fn has_attr(attrs: &[ast::Attribute], symbol: Symbol) -> bool {\n+    attrs.iter().any(|attr| attr.has_name(symbol))\n+}\n+\n+pub fn any_parent_has_attr(tcx: TyCtxt<'_>, node: HirId, symbol: Symbol) -> bool {\n     let map = &tcx.hir();\n     let mut prev_enclosing_node = None;\n     let mut enclosing_node = node;\n     while Some(enclosing_node) != prev_enclosing_node {\n-        if is_automatically_derived(map.attrs(enclosing_node)) {\n+        if has_attr(map.attrs(enclosing_node), symbol) {\n             return true;\n         }\n         prev_enclosing_node = Some(enclosing_node);\n         enclosing_node = map.get_parent_item(enclosing_node);\n     }\n+\n     false\n }\n \n+pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_>, node: HirId) -> bool {\n+    any_parent_has_attr(tcx, node, sym::automatically_derived)\n+}\n+\n /// Matches a function call with the given path and returns the arguments.\n ///\n /// Usage:\n@@ -1625,6 +1597,14 @@ pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -\n     syms.iter().map(|x| Symbol::intern(x)).eq(path.iter().copied())\n }\n \n+/// Checks if the given `DefId` matches the `libc` item.\n+pub fn match_libc_symbol(cx: &LateContext<'_>, did: DefId, name: &str) -> bool {\n+    let path = cx.get_def_path(did);\n+    // libc is meant to be used as a flat list of names, but they're all actually defined in different\n+    // modules based on the target platform. Ignore everything but crate name and the item name.\n+    path.first().map_or(false, |s| s.as_str() == \"libc\") && path.last().map_or(false, |s| s.as_str() == name)\n+}\n+\n pub fn match_panic_call(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if let ExprKind::Call(func, [arg]) = expr.kind {\n         expr_path_res(cx, func)\n@@ -1837,6 +1817,16 @@ pub fn is_expr_final_block_expr(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     matches!(get_parent_node(tcx, expr.hir_id), Some(Node::Block(..)))\n }\n \n+pub fn std_or_core(cx: &LateContext<'_>) -> Option<&'static str> {\n+    if !is_no_std_crate(cx) {\n+        Some(\"std\")\n+    } else if !is_no_core_crate(cx) {\n+        Some(\"core\")\n+    } else {\n+        None\n+    }\n+}\n+\n pub fn is_no_std_crate(cx: &LateContext<'_>) -> bool {\n     cx.tcx.hir().attrs(hir::CRATE_HIR_ID).iter().any(|attr| {\n         if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n@@ -1847,6 +1837,16 @@ pub fn is_no_std_crate(cx: &LateContext<'_>) -> bool {\n     })\n }\n \n+pub fn is_no_core_crate(cx: &LateContext<'_>) -> bool {\n+    cx.tcx.hir().attrs(hir::CRATE_HIR_ID).iter().any(|attr| {\n+        if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n+            attr.path == sym::no_core\n+        } else {\n+            false\n+        }\n+    })\n+}\n+\n /// Check if parent of a hir node is a trait implementation block.\n /// For example, `f` in\n /// ```rust,ignore"}, {"sha": "0cec7d6a5e402aa13a05395c23bf5dd630a5d587", "filename": "src/tools/clippy/clippy_utils/src/msrvs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -19,15 +19,16 @@ msrv_aliases! {\n     1,46,0 { CONST_IF_MATCH }\n     1,45,0 { STR_STRIP_PREFIX }\n     1,43,0 { LOG2_10, LOG10_2 }\n-    1,42,0 { MATCHES_MACRO }\n+    1,42,0 { MATCHES_MACRO, SLICE_PATTERNS }\n     1,41,0 { RE_REBALANCING_COHERENCE, RESULT_MAP_OR_ELSE }\n     1,40,0 { MEM_TAKE, NON_EXHAUSTIVE, OPTION_AS_DEREF }\n     1,38,0 { POINTER_CAST }\n     1,37,0 { TYPE_ALIAS_ENUM_VARIANTS }\n     1,36,0 { ITERATOR_COPIED }\n     1,35,0 { OPTION_COPIED, RANGE_CONTAINS }\n     1,34,0 { TRY_FROM }\n-    1,30,0 { ITERATOR_FIND_MAP }\n+    1,30,0 { ITERATOR_FIND_MAP, TOOL_ATTRIBUTES }\n+    1,28,0 { FROM_BOOL }\n     1,17,0 { FIELD_INIT_SHORTHAND, STATIC_IN_CONST }\n     1,16,0 { STR_REPEAT }\n }"}, {"sha": "6171823abbbd04fa7142aecaad1231c654150ff2", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -28,6 +28,7 @@ pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub(super) const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n /// Preferably use the diagnostic item `sym::Borrow` where possible\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n+pub const BORROW_MUT_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"BorrowMut\"];\n pub const BTREEMAP_CONTAINS_KEY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"contains_key\"];\n pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];\n@@ -85,7 +86,6 @@ pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tup\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n #[cfg(feature = \"internal-lints\")]\n pub const LATE_CONTEXT: [&str; 2] = [\"rustc_lint\", \"LateContext\"];\n-pub const LIBC_STRLEN: [&str; 2] = [\"libc\", \"strlen\"];\n #[cfg(any(feature = \"internal-lints\", feature = \"metadata-collector-lint\"))]\n pub const LINT: [&str; 2] = [\"rustc_lint_defs\", \"Lint\"];\n pub const MEM_DISCRIMINANT: [&str; 3] = [\"core\", \"mem\", \"discriminant\"];\n@@ -110,6 +110,8 @@ pub(super) const PANICKING_PANIC: [&str; 3] = [\"core\", \"panicking\", \"panic\"];\n pub(super) const PANICKING_PANIC_FMT: [&str; 3] = [\"core\", \"panicking\", \"panic_fmt\"];\n pub(super) const PANICKING_PANIC_STR: [&str; 3] = [\"core\", \"panicking\", \"panic_str\"];\n pub(super) const PANIC_ANY: [&str; 3] = [\"std\", \"panic\", \"panic_any\"];\n+pub const PARKING_LOT_RAWMUTEX: [&str; 3] = [\"parking_lot\", \"raw_mutex\", \"RawMutex\"];\n+pub const PARKING_LOT_RAWRWLOCK: [&str; 3] = [\"parking_lot\", \"raw_rwlock\", \"RawRwLock\"];\n pub const PARKING_LOT_MUTEX_GUARD: [&str; 2] = [\"parking_lot\", \"MutexGuard\"];\n pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockReadGuard\"];\n pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockWriteGuard\"];\n@@ -204,3 +206,4 @@ pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];\n pub const WRITE_MACRO: [&str; 3] = [\"core\", \"macros\", \"write\"];\n #[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n pub const WRITELN_MACRO: [&str; 3] = [\"core\", \"macros\", \"writeln\"];\n+pub const PTR_NON_NULL: [&str; 4] = [\"core\", \"ptr\", \"non_null\", \"NonNull\"];"}, {"sha": "17d9a505bc9df7a601c81cd8639b3bcb701ae2ac", "filename": "src/tools/clippy/clippy_utils/src/ptr.rs", "status": "modified", "additions": 18, "deletions": 40, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fptr.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -1,9 +1,9 @@\n use crate::source::snippet;\n+use crate::visitors::expr_visitor_no_bodies;\n use crate::{path_to_local_id, strip_pat_refs};\n-use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Body, BodyId, Expr, ExprKind, HirId, PatKind};\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{Body, BodyId, ExprKind, HirId, PatKind};\n use rustc_lint::LateContext;\n-use rustc_middle::hir::map::Map;\n use rustc_span::Span;\n use std::borrow::Cow;\n \n@@ -30,50 +30,28 @@ fn extract_clone_suggestions<'tcx>(\n     replace: &[(&'static str, &'static str)],\n     body: &'tcx Body<'_>,\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n-    let mut visitor = PtrCloneVisitor {\n-        cx,\n-        id,\n-        replace,\n-        spans: vec![],\n-        abort: false,\n-    };\n-    visitor.visit_body(body);\n-    if visitor.abort { None } else { Some(visitor.spans) }\n-}\n-\n-struct PtrCloneVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    id: HirId,\n-    replace: &'a [(&'static str, &'static str)],\n-    spans: Vec<(Span, Cow<'static, str>)>,\n-    abort: bool,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.abort {\n-            return;\n+    let mut abort = false;\n+    let mut spans = Vec::new();\n+    expr_visitor_no_bodies(|expr| {\n+        if abort {\n+            return false;\n         }\n         if let ExprKind::MethodCall(seg, _, [recv], _) = expr.kind {\n-            if path_to_local_id(recv, self.id) {\n+            if path_to_local_id(recv, id) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n-                    self.abort = true;\n-                    return;\n+                    abort = true;\n+                    return false;\n                 }\n-                for &(fn_name, suffix) in self.replace {\n+                for &(fn_name, suffix) in replace {\n                     if seg.ident.name.as_str() == fn_name {\n-                        self.spans.push((expr.span, snippet(self.cx, recv.span, \"_\") + suffix));\n-                        return;\n+                        spans.push((expr.span, snippet(cx, recv.span, \"_\") + suffix));\n+                        return false;\n                     }\n                 }\n             }\n         }\n-        walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n+        !abort\n+    })\n+    .visit_body(body);\n+    if abort { None } else { Some(spans) }\n }"}, {"sha": "d928317259da0f23b875300b02f3fe3c650b20c1", "filename": "src/tools/clippy/clippy_utils/src/source.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f004a1b3fda522694f9857a4ae95eb9ef7baa0c4/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsource.rs?ref=f004a1b3fda522694f9857a4ae95eb9ef7baa0c4", "patch": "@@ -128,7 +128,7 @@ pub fn reindent_multiline(s: Cow<'_, str>, ignore_first: bool, indent: Option<us\n fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>, ch: char) -> String {\n     let x = s\n         .lines()\n-        .skip(ignore_first as usize)\n+        .skip(usize::from(ignore_first))\n         .filter_map(|l| {\n             if l.is_empty() {\n                 None\n@@ -155,14 +155,22 @@ fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>,\n         .join(\"\\n\")\n }\n \n-/// Converts a span to a code snippet if available, otherwise use default.\n+/// Converts a span to a code snippet if available, otherwise returns the default.\n ///\n /// This is useful if you want to provide suggestions for your lint or more generally, if you want\n-/// to convert a given `Span` to a `str`.\n+/// to convert a given `Span` to a `str`. To create suggestions consider using\n+/// [`snippet_with_applicability`] to ensure that the applicability stays correct.\n ///\n /// # Example\n /// ```rust,ignore\n-/// snippet(cx, expr.span, \"..\")\n+/// // Given two spans one for `value` and one for the `init` expression.\n+/// let value = Vec::new();\n+/// //  ^^^^^   ^^^^^^^^^^\n+/// //  span1   span2\n+///\n+/// // The snipped call would return the corresponding code snippet\n+/// snippet(cx, span1, \"..\") // -> \"value\"\n+/// snippet(cx, span2, \"..\") // -> \"Vec::new()\"\n /// ```\n pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     snippet_opt(cx, span).map_or_else(|| Cow::Borrowed(default), From::from)"}]}