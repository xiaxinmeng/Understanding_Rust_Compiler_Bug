{"sha": "28243a5c0ead225f6e7e917d44333359d3428d16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MjQzYTVjMGVhZDIyNWY2ZTdlOTE3ZDQ0MzMzMzU5ZDM0MjhkMTY=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-05-16T00:55:23Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-05-16T21:24:49Z"}, "message": "librustc: Separate NullablePointer into RawNullablePointer and StructWrappedNullablePointer.", "tree": {"sha": "0f6edb97656b5a273ffa67e525a67b64630c6c4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f6edb97656b5a273ffa67e525a67b64630c6c4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28243a5c0ead225f6e7e917d44333359d3428d16", "comment_count": 8, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28243a5c0ead225f6e7e917d44333359d3428d16", "html_url": "https://github.com/rust-lang/rust/commit/28243a5c0ead225f6e7e917d44333359d3428d16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28243a5c0ead225f6e7e917d44333359d3428d16/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d104dabae96dd6b51ab27814f6510bcc25d75ca7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d104dabae96dd6b51ab27814f6510bcc25d75ca7", "html_url": "https://github.com/rust-lang/rust/commit/d104dabae96dd6b51ab27814f6510bcc25d75ca7"}], "stats": {"total": 167, "additions": 92, "deletions": 75}, "files": [{"sha": "9cea6d0249cc4374d8ea550ca31388a310e5acaa", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 88, "deletions": 74, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/28243a5c0ead225f6e7e917d44333359d3428d16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28243a5c0ead225f6e7e917d44333359d3428d16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=28243a5c0ead225f6e7e917d44333359d3428d16", "patch": "@@ -85,20 +85,30 @@ pub enum Repr {\n      * all start with a field for the discriminant.\n      */\n     General(IntType, Vec<Struct>),\n+    /**\n+     * Two cases distinguished by a nullable pointer: the case with discriminant\n+     * `nndiscr` must have single field which is known to be nonnull due to its type.\n+     * The other case is known to be zero sized. Hence we represent the enum\n+     * as simply a nullable pointer: if not null it indicates the `nndiscr` variant,\n+     * otherwise it indicates the other case.\n+     */\n+    RawNullablePointer {\n+        pub nndiscr: Disr,\n+        pub nnty: ty::t,\n+        pub nullfields: Vec<ty::t>\n+    },\n     /**\n      * Two cases distinguished by a nullable pointer: the case with discriminant\n      * `nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\n      * field is known to be nonnull due to its type; if that field is null, then\n      * it represents the other case, which is inhabited by at most one value\n      * (and all other fields are undefined/unused).\n-     * If the case with the nullable pointer has a single field then we don't\n-     * wrap it in a struct and instead just deal with it directly as a pointer.\n      *\n      * For example, `std::option::Option` instantiated at a safe pointer type\n      * is represented such that `None` is a null pointer and `Some` is the\n      * identity function.\n      */\n-    NullablePointer {\n+    StructWrappedNullablePointer {\n         pub nonnull: Struct,\n         pub nndiscr: Disr,\n         pub ptrfield: uint,\n@@ -202,17 +212,23 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                     if cases.get(1 - discr).is_zerolen(cx) {\n                         match cases.get(discr).find_ptr() {\n                             Some(ptrfield) => {\n-                                return NullablePointer {\n-                                    nndiscr: discr as u64,\n-                                    nonnull: mk_struct(cx,\n-                                                       cases.get(discr)\n-                                                            .tys\n-                                                            .as_slice(),\n-                                                       false),\n-                                    ptrfield: ptrfield,\n-                                    nullfields: cases.get(1 - discr).tys\n-                                                                    .clone()\n-                                }\n+                                let st = mk_struct(cx, cases.get(discr).tys.as_slice(),\n+                                                   false);\n+\n+                                return if st.fields.len() == 1 {\n+                                    RawNullablePointer {\n+                                        nndiscr: discr as Disr,\n+                                        nnty: *st.fields.get(0),\n+                                        nullfields: cases.get(1 - discr).tys.clone()\n+                                    }\n+                                } else {\n+                                    StructWrappedNullablePointer {\n+                                        nndiscr: discr as Disr,\n+                                        nonnull: st,\n+                                        ptrfield: ptrfield,\n+                                        nullfields: cases.get(1 - discr).tys.clone()\n+                                    }\n+                                };\n                             }\n                             None => { }\n                         }\n@@ -415,11 +431,8 @@ pub fn incomplete_type_of(cx: &CrateContext, r: &Repr, name: &str) -> Type {\n }\n pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n     match *r {\n-        CEnum(..) | General(..) => {\n-        }\n-        NullablePointer { nonnull: ref st, .. } if st.fields.len() == 1 => {\n-        }\n-        Univariant(ref st, _) | NullablePointer { nonnull: ref st, .. } =>\n+        CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n+        Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n             llty.set_struct_body(struct_llfields(cx, st, false).as_slice(),\n                                  st.packed)\n     }\n@@ -428,14 +441,8 @@ pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool) -> Type {\n     match *r {\n         CEnum(ity, _, _) => ll_inttype(cx, ity),\n-        NullablePointer { nonnull: ref st, .. } if st.fields.len() == 1 => {\n-            if sizing {\n-                type_of::sizing_type_of(cx, *st.fields.get(0))\n-            } else {\n-                type_of::type_of(cx, *st.fields.get(0))\n-            }\n-        }\n-        Univariant(ref st, _) | NullablePointer { nonnull: ref st, .. } => {\n+        RawNullablePointer { nnty, .. } => type_of::sizing_type_of(cx, nnty),\n+        Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n                     Type::struct_(cx, struct_llfields(cx, st, sizing).as_slice(),\n@@ -507,12 +514,10 @@ fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool) -> Vec<Type> {\n pub fn trans_switch(bcx: &Block, r: &Repr, scrutinee: ValueRef)\n     -> (_match::branch_kind, Option<ValueRef>) {\n     match *r {\n-        CEnum(..) | General(..) => {\n+        CEnum(..) | General(..) |\n+        RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n             (_match::switch, Some(trans_get_discr(bcx, r, scrutinee, None)))\n         }\n-        NullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n-            (_match::switch, Some(nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee)))\n-        }\n         Univariant(..) => {\n             (_match::single, None)\n         }\n@@ -540,8 +545,14 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n             val = C_u8(bcx.ccx(), 0);\n             signed = false;\n         }\n-        NullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n-            val = nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee);\n+        RawNullablePointer { nndiscr, nnty, .. } =>  {\n+            let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n+            let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n+            val = ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty));\n+            signed = false;\n+        }\n+        StructWrappedNullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n+            val = struct_wrapped_nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee);\n             signed = false;\n         }\n     }\n@@ -551,13 +562,9 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n     }\n }\n \n-fn nullable_bitdiscr(bcx: &Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n-                     scrutinee: ValueRef) -> ValueRef {\n-    let llptr = if nonnull.fields.len() == 1 {\n-        Load(bcx, scrutinee)\n-    } else {\n-        Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]))\n-    };\n+fn struct_wrapped_nullable_bitdiscr(bcx: &Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n+                                    scrutinee: ValueRef) -> ValueRef {\n+    let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     let llptrty = type_of::type_of(bcx.ccx(), *nonnull.fields.get(ptrfield));\n     ICmp(bcx, cmp, llptr, C_null(llptrty))\n@@ -606,7 +613,8 @@ pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n         Univariant(..) => {\n             bcx.ccx().sess().bug(\"no cases for univariants or structs\")\n         }\n-        NullablePointer { .. } => {\n+        RawNullablePointer { .. } |\n+        StructWrappedNullablePointer { .. } => {\n             assert!(discr == 0 || discr == 1);\n             _match::single_result(Result::new(bcx, C_i1(bcx.ccx(), discr != 0)))\n         }\n@@ -637,13 +645,15 @@ pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n         Univariant(..) => {\n             assert_eq!(discr, 0);\n         }\n-        NullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n+        RawNullablePointer { nndiscr, nnty, ..} => {\n             if discr != nndiscr {\n-                let llptrptr = if nonnull.fields.len() == 1 {\n-                    val\n-                } else {\n-                    GEPi(bcx, val, [0, ptrfield])\n-                };\n+                let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n+                Store(bcx, C_null(llptrty), val)\n+            }\n+        }\n+        StructWrappedNullablePointer { nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n+            if discr != nndiscr {\n+                let llptrptr = GEPi(bcx, val, [0, ptrfield]);\n                 let llptrty = type_of::type_of(bcx.ccx(),\n                                                *nonnull.fields.get(ptrfield));\n                 Store(bcx, C_null(llptrty), llptrptr)\n@@ -671,8 +681,11 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n         General(_, ref cases) => cases.get(discr as uint).fields.len() - 1,\n-        NullablePointer { nonnull: ref nonnull, nndiscr,\n-                         nullfields: ref nullfields, .. } => {\n+        RawNullablePointer { nndiscr, ref nullfields, .. } => {\n+            if discr == nndiscr { 1 } else { nullfields.len() }\n+        }\n+        StructWrappedNullablePointer { nonnull: ref nonnull, nndiscr,\n+                                       nullfields: ref nullfields, .. } => {\n             if discr == nndiscr { nonnull.fields.len() } else { nullfields.len() }\n         }\n     }\n@@ -695,24 +708,25 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n         General(_, ref cases) => {\n             struct_field_ptr(bcx, cases.get(discr as uint), val, ix + 1, true)\n         }\n-        NullablePointer { nonnull: ref nonnull, nullfields: ref nullfields,\n-                         nndiscr, .. } => {\n-            if discr == nndiscr {\n-                if nonnull.fields.len() == 1 {\n-                    assert_eq!(ix, 0);\n-                    val\n-                } else {\n-                    struct_field_ptr(bcx, nonnull, val, ix, false)\n-                }\n-            } else {\n-                // The unit-like case might have a nonzero number of unit-like fields.\n-                // (e.g., Result or Either with () as one side.)\n-                let ty = type_of::type_of(bcx.ccx(), *nullfields.get(ix));\n-                assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n-                // The contents of memory at this pointer can't matter, but use\n-                // the value that's \"reasonable\" in case of pointer comparison.\n-                PointerCast(bcx, val, ty.ptr_to())\n-            }\n+        RawNullablePointer { nndiscr, ref nullfields, .. } |\n+        StructWrappedNullablePointer { nndiscr, ref nullfields, .. } if discr != nndiscr => {\n+            // The unit-like case might have a nonzero number of unit-like fields.\n+            // (e.d., Result of Either with (), as one side.)\n+            let ty = type_of::type_of(bcx.ccx(), *nullfields.get(ix));\n+            assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n+            // The contents of memory at this pointer can't matter, but use\n+            // the value that's \"reasonable\" in case of pointer comparision.\n+            PointerCast(bcx, val, ty.ptr_to())\n+        }\n+        RawNullablePointer { nndiscr, nnty, .. } => {\n+            assert_eq!(ix, 0);\n+            assert_eq!(discr, nndiscr);\n+            let ty = type_of::type_of(bcx.ccx(), nnty);\n+            PointerCast(bcx, val, ty.ptr_to())\n+        }\n+        StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n+            assert_eq!(discr, nndiscr);\n+            struct_field_ptr(bcx, nonnull, val, ix, false)\n         }\n     }\n }\n@@ -784,15 +798,15 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n             let contents = build_const_struct(ccx, st, vals);\n             C_struct(ccx, contents.as_slice(), st.packed)\n         }\n-        NullablePointer { nonnull: ref st, nndiscr, .. } if st.fields.len() == 1 => {\n+        RawNullablePointer { nndiscr, nnty, .. } => {\n             if discr == nndiscr {\n                 assert_eq!(vals.len(), 1);\n                 vals[0]\n             } else {\n-                C_null(type_of::sizing_type_of(ccx, *st.fields.get(0)))\n+                C_null(type_of::sizing_type_of(ccx, nnty))\n             }\n         }\n-        NullablePointer { nonnull: ref nonnull, nndiscr, .. } => {\n+        StructWrappedNullablePointer { nonnull: ref nonnull, nndiscr, .. } => {\n             if discr == nndiscr {\n                 C_struct(ccx, build_const_struct(ccx,\n                                                  nonnull,\n@@ -900,15 +914,15 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n             }\n         }\n         Univariant(..) => 0,\n-        NullablePointer { nonnull: ref st, nndiscr, .. } if st.fields.len() == 1 => {\n+        RawNullablePointer { nndiscr, .. } => {\n             if is_null(val) {\n                 /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n                 (1 - nndiscr) as Disr\n             } else {\n                 nndiscr\n             }\n         }\n-        NullablePointer { nndiscr, ptrfield, .. } => {\n+        StructWrappedNullablePointer { nndiscr, ptrfield, .. } => {\n             if is_null(const_struct_field(ccx, val, ptrfield)) {\n                 /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n                 (1 - nndiscr) as Disr\n@@ -932,11 +946,11 @@ pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n         CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n         Univariant(..) => const_struct_field(ccx, val, ix),\n         General(..) => const_struct_field(ccx, val, ix + 1),\n-        NullablePointer { nonnull: ref st, .. } if st.fields.len() == 1 => {\n+        RawNullablePointer { .. } => {\n             assert_eq!(ix, 0);\n             val\n         }\n-        NullablePointer{ .. } => const_struct_field(ccx, val, ix)\n+        StructWrappedNullablePointer{ .. } => const_struct_field(ccx, val, ix)\n     }\n }\n "}, {"sha": "12c7c22b9a18367e8832e25c7f81490aa2875e0b", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28243a5c0ead225f6e7e917d44333359d3428d16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28243a5c0ead225f6e7e917d44333359d3428d16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=28243a5c0ead225f6e7e917d44333359d3428d16", "patch": "@@ -1657,7 +1657,10 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                 }),\n             }\n         }\n-        adt::NullablePointer { nonnull: ref struct_def, nndiscr, .. } => {\n+        adt::RawNullablePointer { nnty, .. } => {\n+            FinalMetadata(type_metadata(cx, nnty, span))\n+        }\n+        adt::StructWrappedNullablePointer { nonnull: ref struct_def, nndiscr, .. } => {\n             let (metadata_stub,\n                  variant_llvm_type,\n                  member_description_factory) ="}]}