{"sha": "c54cb889509e41f9187831742f49aa1c769fa36a", "node_id": "C_kwDOAAsO6NoAKGM1NGNiODg5NTA5ZTQxZjkxODc4MzE3NDJmNDlhYTFjNzY5ZmEzNmE", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-04-07T16:03:14Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-04-07T16:03:14Z"}, "message": "Add bounds for associated types in derive macro", "tree": {"sha": "51263419120d6b2e9ac789d5291edf96112e9c72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51263419120d6b2e9ac789d5291edf96112e9c72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c54cb889509e41f9187831742f49aa1c769fa36a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c54cb889509e41f9187831742f49aa1c769fa36a", "html_url": "https://github.com/rust-lang/rust/commit/c54cb889509e41f9187831742f49aa1c769fa36a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c54cb889509e41f9187831742f49aa1c769fa36a/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "972f1313eb89a28894655cf40c2aa75d23ce6425", "url": "https://api.github.com/repos/rust-lang/rust/commits/972f1313eb89a28894655cf40c2aa75d23ce6425", "html_url": "https://github.com/rust-lang/rust/commit/972f1313eb89a28894655cf40c2aa75d23ce6425"}], "stats": {"total": 217, "additions": 187, "deletions": 30}, "files": [{"sha": "37cf348c92d7590bc2cc0eecc13b0adb9bb2fe39", "filename": "crates/hir-def/src/macro_expansion_tests/builtin_derive_macro.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c54cb889509e41f9187831742f49aa1c769fa36a/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54cb889509e41f9187831742f49aa1c769fa36a/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs?ref=c54cb889509e41f9187831742f49aa1c769fa36a", "patch": "@@ -16,7 +16,7 @@ struct Foo;\n #[derive(Copy)]\n struct Foo;\n \n-impl < > core::marker::Copy for Foo< > {}\"#]],\n+impl < > core::marker::Copy for Foo< > where {}\"#]],\n     );\n }\n \n@@ -41,7 +41,7 @@ macro Copy {}\n #[derive(Copy)]\n struct Foo;\n \n-impl < > crate ::marker::Copy for Foo< > {}\"#]],\n+impl < > crate ::marker::Copy for Foo< > where {}\"#]],\n     );\n }\n \n@@ -57,7 +57,7 @@ struct Foo<A, B>;\n #[derive(Copy)]\n struct Foo<A, B>;\n \n-impl <T0: core::marker::Copy, T1: core::marker::Copy, > core::marker::Copy for Foo<T0, T1, > {}\"#]],\n+impl <A: core::marker::Copy, B: core::marker::Copy, > core::marker::Copy for Foo<A, B, > where {}\"#]],\n     );\n }\n \n@@ -74,7 +74,7 @@ struct Foo<A, B, 'a, 'b>;\n #[derive(Copy)]\n struct Foo<A, B, 'a, 'b>;\n \n-impl <T0: core::marker::Copy, T1: core::marker::Copy, > core::marker::Copy for Foo<T0, T1, > {}\"#]],\n+impl <A: core::marker::Copy, B: core::marker::Copy, > core::marker::Copy for Foo<A, B, > where {}\"#]],\n     );\n }\n \n@@ -90,7 +90,7 @@ struct Foo<A, B>;\n #[derive(Clone)]\n struct Foo<A, B>;\n \n-impl <T0: core::clone::Clone, T1: core::clone::Clone, > core::clone::Clone for Foo<T0, T1, > {}\"#]],\n+impl <A: core::clone::Clone, B: core::clone::Clone, > core::clone::Clone for Foo<A, B, > where {}\"#]],\n     );\n }\n \n@@ -106,6 +106,6 @@ struct Foo<const X: usize, T>(u32);\n #[derive(Clone)]\n struct Foo<const X: usize, T>(u32);\n \n-impl <const T0: usize, T1: core::clone::Clone, > core::clone::Clone for Foo<T0, T1, > {}\"#]],\n+impl <const X: usize, T: core::clone::Clone, > core::clone::Clone for Foo<X, T, > where {}\"#]],\n     );\n }"}, {"sha": "7e753663c01af5ddce30c79aac1d2adc04ea218d", "filename": "crates/hir-expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 111, "deletions": 20, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c54cb889509e41f9187831742f49aa1c769fa36a/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54cb889509e41f9187831742f49aa1c769fa36a/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=c54cb889509e41f9187831742f49aa1c769fa36a", "patch": "@@ -1,11 +1,12 @@\n //! Builtin derives.\n \n use base_db::{CrateOrigin, LangCrateOrigin};\n+use std::collections::HashSet;\n use tracing::debug;\n \n use crate::tt::{self, TokenId};\n use syntax::{\n-    ast::{self, AstNode, HasGenericParams, HasModuleItem, HasName},\n+    ast::{self, AstNode, HasGenericParams, HasModuleItem, HasName, HasTypeBounds, PathType},\n     match_ast,\n };\n \n@@ -60,8 +61,11 @@ pub fn find_builtin_derive(ident: &name::Name) -> Option<BuiltinDeriveExpander>\n \n struct BasicAdtInfo {\n     name: tt::Ident,\n-    /// `Some(ty)` if it's a const param of type `ty`, `None` if it's a type param.\n-    param_types: Vec<Option<tt::Subtree>>,\n+    /// first field is the name, and\n+    /// second field is `Some(ty)` if it's a const param of type `ty`, `None` if it's a type param.\n+    /// third fields is where bounds, if any\n+    param_types: Vec<(tt::Subtree, Option<tt::Subtree>, Option<tt::Subtree>)>,\n+    associated_types: Vec<tt::Subtree>,\n }\n \n fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n@@ -86,46 +90,126 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n             },\n         }\n     };\n-    let name = name.ok_or_else(|| {\n-        debug!(\"parsed item has no name\");\n-        ExpandError::Other(\"missing name\".into())\n-    })?;\n-    let name_token_id =\n-        token_map.token_by_range(name.syntax().text_range()).unwrap_or_else(TokenId::unspecified);\n-    let name_token = tt::Ident { span: name_token_id, text: name.text().into() };\n+    let mut param_type_set: HashSet<String> = HashSet::new();\n     let param_types = params\n         .into_iter()\n         .flat_map(|param_list| param_list.type_or_const_params())\n         .map(|param| {\n-            if let ast::TypeOrConstParam::Const(param) = param {\n+            let name = {\n+                let this = param.name();\n+                match this {\n+                    Some(x) => {\n+                        param_type_set.insert(x.to_string());\n+                        mbe::syntax_node_to_token_tree(x.syntax()).0\n+                    }\n+                    None => tt::Subtree::empty(),\n+                }\n+            };\n+            let bounds = match &param {\n+                ast::TypeOrConstParam::Type(x) => {\n+                    x.type_bound_list().map(|x| mbe::syntax_node_to_token_tree(x.syntax()).0)\n+                }\n+                ast::TypeOrConstParam::Const(_) => None,\n+            };\n+            let ty = if let ast::TypeOrConstParam::Const(param) = param {\n                 let ty = param\n                     .ty()\n                     .map(|ty| mbe::syntax_node_to_token_tree(ty.syntax()).0)\n                     .unwrap_or_else(tt::Subtree::empty);\n                 Some(ty)\n             } else {\n                 None\n-            }\n+            };\n+            (name, ty, bounds)\n         })\n         .collect();\n-    Ok(BasicAdtInfo { name: name_token, param_types })\n+    let is_associated_type = |p: &PathType| {\n+        if let Some(p) = p.path() {\n+            if let Some(parent) = p.qualifier() {\n+                if let Some(x) = parent.segment() {\n+                    if let Some(x) = x.path_type() {\n+                        if let Some(x) = x.path() {\n+                            if let Some(pname) = x.as_single_name_ref() {\n+                                if param_type_set.contains(&pname.to_string()) {\n+                                    // <T as Trait>::Assoc\n+                                    return true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if let Some(pname) = parent.as_single_name_ref() {\n+                    if param_type_set.contains(&pname.to_string()) {\n+                        // T::Assoc\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        false\n+    };\n+    let associated_types = node\n+        .descendants()\n+        .filter_map(PathType::cast)\n+        .filter(is_associated_type)\n+        .map(|x| mbe::syntax_node_to_token_tree(x.syntax()).0)\n+        .collect::<Vec<_>>();\n+    let name = name.ok_or_else(|| {\n+        debug!(\"parsed item has no name\");\n+        ExpandError::Other(\"missing name\".into())\n+    })?;\n+    let name_token_id =\n+        token_map.token_by_range(name.syntax().text_range()).unwrap_or_else(TokenId::unspecified);\n+    let name_token = tt::Ident { span: name_token_id, text: name.text().into() };\n+    Ok(BasicAdtInfo { name: name_token, param_types, associated_types })\n }\n \n+/// Given that we are deriving a trait `DerivedTrait` for a type like:\n+///\n+/// ```ignore (only-for-syntax-highlight)\n+/// struct Struct<'a, ..., 'z, A, B: DeclaredTrait, C, ..., Z> where C: WhereTrait {\n+///     a: A,\n+///     b: B::Item,\n+///     b1: <B as DeclaredTrait>::Item,\n+///     c1: <C as WhereTrait>::Item,\n+///     c2: Option<<C as WhereTrait>::Item>,\n+///     ...\n+/// }\n+/// ```\n+///\n+/// create an impl like:\n+///\n+/// ```ignore (only-for-syntax-highlight)\n+/// impl<'a, ..., 'z, A, B: DeclaredTrait, C, ... Z> where\n+///     C:                       WhereTrait,\n+///     A: DerivedTrait + B1 + ... + BN,\n+///     B: DerivedTrait + B1 + ... + BN,\n+///     C: DerivedTrait + B1 + ... + BN,\n+///     B::Item:                 DerivedTrait + B1 + ... + BN,\n+///     <C as WhereTrait>::Item: DerivedTrait + B1 + ... + BN,\n+///     ...\n+/// {\n+///     ...\n+/// }\n+/// ```\n+///\n+/// where B1, ..., BN are the bounds given by `bounds_paths`.'. Z is a phantom type, and\n+/// therefore does not get bound by the derived trait.\n fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResult<tt::Subtree> {\n     let info = match parse_adt(tt) {\n         Ok(info) => info,\n         Err(e) => return ExpandResult::with_err(tt::Subtree::empty(), e),\n     };\n+    let mut where_block = vec![];\n     let (params, args): (Vec<_>, Vec<_>) = info\n         .param_types\n         .into_iter()\n-        .enumerate()\n-        .map(|(idx, param_ty)| {\n-            let ident = tt::Leaf::Ident(tt::Ident {\n-                span: tt::TokenId::unspecified(),\n-                text: format!(\"T{idx}\").into(),\n-            });\n+        .map(|(ident, param_ty, bound)| {\n             let ident_ = ident.clone();\n+            if let Some(b) = bound {\n+                let ident = ident.clone();\n+                where_block.push(quote! { #ident : #b , });\n+            }\n             if let Some(ty) = param_ty {\n                 (quote! { const #ident : #ty , }, quote! { #ident_ , })\n             } else {\n@@ -134,9 +218,16 @@ fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResu\n             }\n         })\n         .unzip();\n+\n+    where_block.extend(info.associated_types.iter().map(|x| {\n+        let x = x.clone();\n+        let bound = trait_path.clone();\n+        quote! { #x : #bound , }\n+    }));\n+\n     let name = info.name;\n     let expanded = quote! {\n-        impl < ##params > #trait_path for #name < ##args > {}\n+        impl < ##params > #trait_path for #name < ##args > where ##where_block {}\n     };\n     ExpandResult::ok(expanded)\n }"}, {"sha": "3564ed413346342815263104d2a05c43fd749dd6", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c54cb889509e41f9187831742f49aa1c769fa36a/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54cb889509e41f9187831742f49aa1c769fa36a/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=c54cb889509e41f9187831742f49aa1c769fa36a", "patch": "@@ -4315,3 +4315,63 @@ impl Trait for () {\n     \"#,\n     );\n }\n+\n+#[test]\n+fn derive_macro_bounds() {\n+    check_types(\n+        r#\"\n+        //- minicore: clone, derive\n+        #[derive(Clone)]\n+        struct Copy;\n+        struct NotCopy;\n+        #[derive(Clone)]\n+        struct Generic<T>(T);\n+        trait Tr {\n+            type Assoc;\n+        }\n+        impl Tr for Copy {\n+            type Assoc = NotCopy;\n+        }\n+        #[derive(Clone)]\n+        struct AssocGeneric<T: Tr>(T::Assoc);\n+\n+        #[derive(Clone)]\n+        struct AssocGeneric2<T: Tr>(<T as Tr>::Assoc);\n+\n+        #[derive(Clone)]\n+        struct AssocGeneric3<T: Tr>(Generic<T::Assoc>);\n+\n+        #[derive(Clone)]\n+        struct Vec<T>();\n+\n+        #[derive(Clone)]\n+        struct R1(Vec<R2>);\n+        #[derive(Clone)]\n+        struct R2(R1);\n+\n+        fn f() {\n+            let x = (&Copy).clone();\n+              //^ Copy\n+            let x = (&NotCopy).clone();\n+              //^ &NotCopy\n+            let x = (&Generic(Copy)).clone();\n+              //^ Generic<Copy>\n+            let x = (&Generic(NotCopy)).clone();\n+              //^ &Generic<NotCopy>\n+            let x: &AssocGeneric<Copy> = &AssocGeneric(NotCopy);\n+            let x = x.clone();\n+              //^ &AssocGeneric<Copy>\n+            let x: &AssocGeneric2<Copy> = &AssocGeneric2(NotCopy);\n+            let x = x.clone();\n+              //^ &AssocGeneric2<Copy>\n+            let x: &AssocGeneric3<Copy> = &AssocGeneric3(Generic(NotCopy));\n+            let x = x.clone();\n+              //^ &AssocGeneric3<Copy>\n+            let x = (&R1(Vec())).clone();\n+              //^ R1\n+            let x = (&R2(R1(Vec()))).clone();\n+              //^ R2\n+        }\n+        \"#,\n+    );\n+}"}, {"sha": "91af5716ca54f19861914c1f6b3b10bc4b8e17c3", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c54cb889509e41f9187831742f49aa1c769fa36a/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54cb889509e41f9187831742f49aa1c769fa36a/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=c54cb889509e41f9187831742f49aa1c769fa36a", "patch": "@@ -471,7 +471,7 @@ struct Foo {}\n \"#,\n             expect![[r#\"\n                 Clone\n-                impl < >core::clone::Clone for Foo< >{}\n+                impl < >core::clone::Clone for Foo< >where{}\n             \"#]],\n         );\n     }\n@@ -488,7 +488,7 @@ struct Foo {}\n \"#,\n             expect![[r#\"\n                 Copy\n-                impl < >core::marker::Copy for Foo< >{}\n+                impl < >core::marker::Copy for Foo< >where{}\n             \"#]],\n         );\n     }\n@@ -504,7 +504,7 @@ struct Foo {}\n \"#,\n             expect![[r#\"\n                 Copy\n-                impl < >core::marker::Copy for Foo< >{}\n+                impl < >core::marker::Copy for Foo< >where{}\n             \"#]],\n         );\n         check(\n@@ -516,7 +516,7 @@ struct Foo {}\n \"#,\n             expect![[r#\"\n                 Clone\n-                impl < >core::clone::Clone for Foo< >{}\n+                impl < >core::clone::Clone for Foo< >where{}\n             \"#]],\n         );\n     }"}, {"sha": "167af32a2ea974550c4cb416bdf5cb30aa7f859c", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c54cb889509e41f9187831742f49aa1c769fa36a/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c54cb889509e41f9187831742f49aa1c769fa36a/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=c54cb889509e41f9187831742f49aa1c769fa36a", "patch": "@@ -143,6 +143,12 @@ pub mod clone {\n     pub trait Clone: Sized {\n         fn clone(&self) -> Self;\n     }\n+\n+    impl<T> Clone for &T {\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n     // region:derive\n     #[rustc_builtin_macro]\n     pub macro Clone($item:item) {}"}]}