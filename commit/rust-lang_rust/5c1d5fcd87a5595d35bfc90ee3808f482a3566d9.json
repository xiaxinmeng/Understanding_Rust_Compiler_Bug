{"sha": "5c1d5fcd87a5595d35bfc90ee3808f482a3566d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMWQ1ZmNkODdhNTU5NWQzNWJmYzkwZWUzODA4ZjQ4MmEzNTY2ZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-22T02:22:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-22T02:22:54Z"}, "message": "Auto merge of #31064 - retep998:msvc-host-dlls, r=alexcrichton\n\nFixes https://github.com/rust-lang/rust/issues/31063\n\nr? @alexcrichton", "tree": {"sha": "d24afaa8e6e52240e0695a042c8520069875d5f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d24afaa8e6e52240e0695a042c8520069875d5f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c1d5fcd87a5595d35bfc90ee3808f482a3566d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c1d5fcd87a5595d35bfc90ee3808f482a3566d9", "html_url": "https://github.com/rust-lang/rust/commit/5c1d5fcd87a5595d35bfc90ee3808f482a3566d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c1d5fcd87a5595d35bfc90ee3808f482a3566d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18b851bc521d04cfd21b07725fbd915ad9764a6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/18b851bc521d04cfd21b07725fbd915ad9764a6f", "html_url": "https://github.com/rust-lang/rust/commit/18b851bc521d04cfd21b07725fbd915ad9764a6f"}, {"sha": "a65f5acf5cc3a4951ff7a87f91e7ca09891f5b8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a65f5acf5cc3a4951ff7a87f91e7ca09891f5b8c", "html_url": "https://github.com/rust-lang/rust/commit/a65f5acf5cc3a4951ff7a87f91e7ca09891f5b8c"}], "stats": {"total": 189, "additions": 106, "deletions": 83}, "files": [{"sha": "0f327d5c84cfd80f4f889a84c547079276f64372", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c1d5fcd87a5595d35bfc90ee3808f482a3566d9/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1d5fcd87a5595d35bfc90ee3808f482a3566d9/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=5c1d5fcd87a5595d35bfc90ee3808f482a3566d9", "patch": "@@ -396,6 +396,9 @@ fn command_path(sess: &Session) -> OsString {\n     if let Some(path) = env::var_os(\"PATH\") {\n         new_path.extend(env::split_paths(&path));\n     }\n+    if sess.target.target.options.is_like_msvc {\n+        new_path.extend(msvc::host_dll_path());\n+    }\n     env::join_paths(new_path).unwrap()\n }\n "}, {"sha": "0112da57cc0a6bed711e7ee16618b85b9dc1b406", "filename": "src/librustc_trans/back/msvc/mod.rs", "status": "modified", "additions": 103, "deletions": 83, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/5c1d5fcd87a5595d35bfc90ee3808f482a3566d9/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c1d5fcd87a5595d35bfc90ee3808f482a3566d9/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs?ref=5c1d5fcd87a5595d35bfc90ee3808f482a3566d9", "patch": "@@ -31,98 +31,106 @@\n //! paths/files is based on Microsoft's logic in their vcvars bat files, but\n //! comments can also be found below leading through the various code paths.\n \n-use std::process::Command;\n-use session::Session;\n-\n #[cfg(windows)]\n mod registry;\n \n #[cfg(windows)]\n-pub fn link_exe_cmd(sess: &Session) -> Command {\n+mod platform {\n     use std::env;\n     use std::ffi::OsString;\n     use std::fs;\n     use std::path::{Path, PathBuf};\n-    use self::registry::{LOCAL_MACHINE};\n-\n-    let arch = &sess.target.target.arch;\n-    let (binsub, libsub, vclibsub) =\n-        match (bin_subdir(arch), lib_subdir(arch), vc_lib_subdir(arch)) {\n-        (Some(x), Some(y), Some(z)) => (x, y, z),\n-        _ => return Command::new(\"link.exe\"),\n-    };\n+    use std::process::Command;\n+    use session::Session;\n+    use super::registry::{LOCAL_MACHINE};\n \n-    // First we need to figure out whether the environment is already correctly\n-    // configured by vcvars. We do this by looking at the environment variable\n-    // `VCINSTALLDIR` which is always set by vcvars, and unlikely to be set\n-    // otherwise. If it is defined, then we derive the path to `link.exe` from\n-    // that and trust that everything else is configured correctly.\n-    //\n-    // If `VCINSTALLDIR` wasn't defined (or we couldn't find the linker where it\n-    // claimed it should be), then we resort to finding everything ourselves.\n-    // First we find where the latest version of MSVC is installed and what\n-    // version it is. Then based on the version we find the appropriate SDKs.\n-    //\n-    // For MSVC 14 (VS 2015) we look for the Win10 SDK and failing that we look\n-    // for the Win8.1 SDK. We also look for the Universal CRT.\n-    //\n-    // For MSVC 12 (VS 2013) we look for the Win8.1 SDK.\n-    //\n-    // For MSVC 11 (VS 2012) we look for the Win8 SDK.\n-    //\n-    // For all other versions the user has to execute the appropriate vcvars bat\n-    // file themselves to configure the environment.\n-    //\n-    // If despite our best efforts we are still unable to find MSVC then we just\n-    // blindly call `link.exe` and hope for the best.\n-    return env::var_os(\"VCINSTALLDIR\").and_then(|dir| {\n-        debug!(\"Environment already configured by user. Assuming it works.\");\n-        let mut p = PathBuf::from(dir);\n-        p.push(\"bin\");\n-        p.push(binsub);\n-        p.push(\"link.exe\");\n-        if !p.is_file() { return None }\n-        Some(Command::new(p))\n-    }).or_else(|| {\n-        get_vc_dir().and_then(|(ver, vcdir)| {\n-            debug!(\"Found VC installation directory {:?}\", vcdir);\n-            let mut linker = vcdir.clone();\n-            linker.push(\"bin\");\n-            linker.push(binsub);\n-            linker.push(\"link.exe\");\n-            if !linker.is_file() { return None }\n-            let mut cmd = Command::new(linker);\n-            add_lib(&mut cmd, &vcdir.join(\"lib\").join(vclibsub));\n-            if ver == \"14.0\" {\n-                if let Some(dir) = get_ucrt_dir() {\n-                    debug!(\"Found Universal CRT {:?}\", dir);\n-                    add_lib(&mut cmd, &dir.join(\"ucrt\").join(libsub));\n-                }\n-                if let Some(dir) = get_sdk10_dir() {\n-                    debug!(\"Found Win10 SDK {:?}\", dir);\n-                    add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n-                } else if let Some(dir) = get_sdk81_dir() {\n-                    debug!(\"Found Win8.1 SDK {:?}\", dir);\n-                    add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n-                }\n-            } else if ver == \"12.0\" {\n-                if let Some(dir) = get_sdk81_dir() {\n-                    debug!(\"Found Win8.1 SDK {:?}\", dir);\n-                    add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n-                }\n-            } else { // ver == \"11.0\"\n-                if let Some(dir) = get_sdk8_dir() {\n-                    debug!(\"Found Win8 SDK {:?}\", dir);\n-                    add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n-                }\n-            }\n-            Some(cmd)\n+    // Cross toolchains depend on dlls from the host toolchain\n+    // We can't just add it to the Command's PATH in `link_exe_cmd` because it\n+    // is later overridden so we publicly expose it here instead\n+    pub fn host_dll_path() -> Option<PathBuf> {\n+        get_vc_dir().and_then(|(_, vcdir)| {\n+            host_dll_subdir().map(|sub| {\n+                vcdir.join(\"bin\").join(sub)\n+            })\n         })\n-    }).unwrap_or_else(|| {\n-        debug!(\"Failed to locate linker.\");\n-        Command::new(\"link.exe\")\n-    });\n+    }\n+\n+    pub fn link_exe_cmd(sess: &Session) -> Command {\n+        let arch = &sess.target.target.arch;\n+        let (binsub, libsub, vclibsub) =\n+            match (bin_subdir(arch), lib_subdir(arch), vc_lib_subdir(arch)) {\n+            (Some(x), Some(y), Some(z)) => (x, y, z),\n+            _ => return Command::new(\"link.exe\"),\n+        };\n \n+        // First we need to figure out whether the environment is already correctly\n+        // configured by vcvars. We do this by looking at the environment variable\n+        // `VCINSTALLDIR` which is always set by vcvars, and unlikely to be set\n+        // otherwise. If it is defined, then we derive the path to `link.exe` from\n+        // that and trust that everything else is configured correctly.\n+        //\n+        // If `VCINSTALLDIR` wasn't defined (or we couldn't find the linker where it\n+        // claimed it should be), then we resort to finding everything ourselves.\n+        // First we find where the latest version of MSVC is installed and what\n+        // version it is. Then based on the version we find the appropriate SDKs.\n+        //\n+        // For MSVC 14 (VS 2015) we look for the Win10 SDK and failing that we look\n+        // for the Win8.1 SDK. We also look for the Universal CRT.\n+        //\n+        // For MSVC 12 (VS 2013) we look for the Win8.1 SDK.\n+        //\n+        // For MSVC 11 (VS 2012) we look for the Win8 SDK.\n+        //\n+        // For all other versions the user has to execute the appropriate vcvars bat\n+        // file themselves to configure the environment.\n+        //\n+        // If despite our best efforts we are still unable to find MSVC then we just\n+        // blindly call `link.exe` and hope for the best.\n+        return env::var_os(\"VCINSTALLDIR\").and_then(|dir| {\n+            debug!(\"Environment already configured by user. Assuming it works.\");\n+            let mut p = PathBuf::from(dir);\n+            p.push(\"bin\");\n+            p.push(binsub);\n+            p.push(\"link.exe\");\n+            if !p.is_file() { return None }\n+            Some(Command::new(p))\n+        }).or_else(|| {\n+            get_vc_dir().and_then(|(ver, vcdir)| {\n+                debug!(\"Found VC installation directory {:?}\", vcdir);\n+                let linker = vcdir.clone().join(\"bin\").join(binsub).join(\"link.exe\");\n+                if !linker.is_file() { return None }\n+                let mut cmd = Command::new(linker);\n+                add_lib(&mut cmd, &vcdir.join(\"lib\").join(vclibsub));\n+                if ver == \"14.0\" {\n+                    if let Some(dir) = get_ucrt_dir() {\n+                        debug!(\"Found Universal CRT {:?}\", dir);\n+                        add_lib(&mut cmd, &dir.join(\"ucrt\").join(libsub));\n+                    }\n+                    if let Some(dir) = get_sdk10_dir() {\n+                        debug!(\"Found Win10 SDK {:?}\", dir);\n+                        add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n+                    } else if let Some(dir) = get_sdk81_dir() {\n+                        debug!(\"Found Win8.1 SDK {:?}\", dir);\n+                        add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n+                    }\n+                } else if ver == \"12.0\" {\n+                    if let Some(dir) = get_sdk81_dir() {\n+                        debug!(\"Found Win8.1 SDK {:?}\", dir);\n+                        add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n+                    }\n+                } else { // ver == \"11.0\"\n+                    if let Some(dir) = get_sdk8_dir() {\n+                        debug!(\"Found Win8 SDK {:?}\", dir);\n+                        add_lib(&mut cmd, &dir.join(\"um\").join(libsub));\n+                    }\n+                }\n+                Some(cmd)\n+            })\n+        }).unwrap_or_else(|| {\n+            debug!(\"Failed to locate linker.\");\n+            Command::new(\"link.exe\")\n+        });\n+    }\n     // A convenience function to make the above code simpler\n     fn add_lib(cmd: &mut Command, lib: &Path) {\n         let mut arg: OsString = \"/LIBPATH:\".into();\n@@ -257,11 +265,23 @@ pub fn link_exe_cmd(sess: &Session) -> Command {\n             _ => None,\n         }\n     }\n+    fn host_dll_subdir() -> Option<&'static str> {\n+        if cfg!(target_arch = \"x86_64\") { Some(\"amd64\") }\n+        else if cfg!(target_arch = \"x86\") { Some(\"\") }\n+        else { None }\n+    }\n }\n \n // If we're not on Windows, then there's no registry to search through and MSVC\n // wouldn't be able to run, so we just call `link.exe` and hope for the best.\n #[cfg(not(windows))]\n-pub fn link_exe_cmd(_sess: &Session) -> Command {\n-    Command::new(\"link.exe\")\n+mod platform {\n+    use std::path::PathBuf;\n+    use std::process::Command;\n+    use session::Session;\n+    pub fn link_exe_cmd(_sess: &Session) -> Command {\n+        Command::new(\"link.exe\")\n+    }\n+    pub fn host_dll_path() -> Option<PathBuf> { None }\n }\n+pub use self::platform::*;"}]}