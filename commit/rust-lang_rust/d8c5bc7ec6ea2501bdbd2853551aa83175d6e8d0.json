{"sha": "d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4YzViYzdlYzZlYTI1MDFiZGJkMjg1MzU1MWFhODMxNzVkNmU4ZDA=", "commit": {"author": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2019-07-30T21:10:51Z"}, "committer": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2019-08-21T08:55:16Z"}, "message": "Replace usage of alloc.bytes in interpret\n\nThere is now a dedicate `len` method which avoids the need to access the\nbytes. Access the length as `Size` can also be done by a direct member.\nThe constructors guarantee that these representations are convertable.\n\nAccess which relies on the bytes, such as snapshot, can use direct raw\naccess by reference as it does not care about undef and relocations or\nproperly checks them seperately.", "tree": {"sha": "e718745ef423cb085a7d16039816eab7987854f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e718745ef423cb085a7d16039816eab7987854f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0", "html_url": "https://github.com/rust-lang/rust/commit/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0/comments", "author": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98cff6928925256faffbe3e9ce9f14d0dfdbb6c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/98cff6928925256faffbe3e9ce9f14d0dfdbb6c0", "html_url": "https://github.com/rust-lang/rust/commit/98cff6928925256faffbe3e9ce9f14d0dfdbb6c0"}], "stats": {"total": 51, "additions": 37, "deletions": 14}, "files": [{"sha": "bfbfffeb3b8c6827d4fe46d2f42aec0dabfd5882", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0", "patch": "@@ -13,6 +13,8 @@ use rustc_data_structures::sorted_map::SortedMap;\n use rustc_target::abi::HasDataLayout;\n use std::borrow::Cow;\n \n+// NOTE: When adding new fields, make sure to adjust the Snapshot impl in\n+// `src/librustc_mir/interpret/snapshot.rs`.\n #[derive(\n     Clone,\n     Debug,"}, {"sha": "a48a4abf796b2a511ab1cc9569ea3f0efa19e8a7", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0", "patch": "@@ -81,7 +81,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let alloc = alloc_type_name(self.tcx.tcx, substs.type_at(0));\n                 let name_id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);\n                 let id_ptr = self.memory.tag_static_base_pointer(name_id.into());\n-                let alloc_len = alloc.bytes.len() as u64;\n+                let alloc_len = alloc.size.bytes();\n                 let name_val = Immediate::new_slice(Scalar::Ptr(id_ptr), alloc_len, self);\n                 self.write_immediate(name_val, dest)?;\n             }"}, {"sha": "032d16a49db4baa3d0f181e85c96292bbefa4f3c", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0", "patch": "@@ -221,7 +221,7 @@ pub fn type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx>\n         val: ConstValue::Slice {\n             data: alloc,\n             start: 0,\n-            end: alloc.bytes.len(),\n+            end: alloc.len(),\n         },\n         ty: tcx.mk_static_str(),\n     })"}, {"sha": "15180265ad29ff6b860cf256b1a967533ab92f57", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0", "patch": "@@ -210,7 +210,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let new_ptr = self.allocate(new_size, new_align, kind);\n         let old_size = match old_size_and_align {\n             Some((size, _align)) => size,\n-            None => Size::from_bytes(self.get(ptr.alloc_id)?.bytes.len() as u64),\n+            None => self.get(ptr.alloc_id)?.size,\n         };\n         self.copy(\n             ptr,\n@@ -271,20 +271,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             ))\n         }\n         if let Some((size, align)) = old_size_and_align {\n-            if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n-                let bytes = Size::from_bytes(alloc.bytes.len() as u64);\n+            if size != alloc.size || align != alloc.align {\n+                let bytes = alloc.size;\n                 throw_unsup!(IncorrectAllocationInformation(size, bytes, align, alloc.align))\n             }\n         }\n \n         // Let the machine take some extra action\n-        let size = Size::from_bytes(alloc.bytes.len() as u64);\n+        let size = alloc.size;\n         AllocationExtra::memory_deallocated(&mut alloc, ptr, size)?;\n \n         // Don't forget to remember size and align of this now-dead allocation\n         let old = self.dead_alloc_map.insert(\n             ptr.alloc_id,\n-            (Size::from_bytes(alloc.bytes.len() as u64), alloc.align)\n+            (alloc.size, alloc.align)\n         );\n         if old.is_some() {\n             bug!(\"Nothing can be deallocated twice\");\n@@ -555,7 +555,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // a) cause cycles in case `id` refers to a static\n         // b) duplicate a static's allocation in miri\n         if let Some((_, alloc)) = self.alloc_map.get(id) {\n-            return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n+            return Ok((alloc.size, alloc.align));\n         }\n \n         // # Function pointers\n@@ -583,7 +583,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Memory(alloc)) =>\n                 // Need to duplicate the logic here, because the global allocations have\n                 // different associated types than the interpreter-local ones.\n-                Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align)),\n+                Ok((alloc.size, alloc.align)),\n             Some(GlobalAlloc::Function(_)) =>\n                 bug!(\"We already checked function pointers above\"),\n             // The rest must be dead.\n@@ -645,7 +645,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let prefix_len = msg.len();\n         let mut relocations = vec![];\n \n-        for i in 0..(alloc.bytes.len() as u64) {\n+        for i in 0..alloc.size.bytes() {\n             let i = Size::from_bytes(i);\n             if let Some(&(_, target_id)) = alloc.relocations.get(&i) {\n                 if allocs_seen.insert(target_id) {\n@@ -655,7 +655,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n             if alloc.undef_mask.is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n                 // this `as usize` is fine, since `i` came from a `usize`\n-                write!(msg, \"{:02x} \", alloc.bytes[i.bytes() as usize]).unwrap();\n+                let i = i.bytes() as usize;\n+\n+                // Checked definedness (and thus range) and relocations. This access also doesn't\n+                // influence interpreter execution but is only for debugging.\n+                let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(i..i+1);\n+                write!(msg, \"{:02x} \", bytes[0]).unwrap();\n             } else {\n                 msg.push_str(\"__ \");\n             }\n@@ -664,7 +669,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         trace!(\n             \"{}({} bytes, alignment {}){}\",\n             msg,\n-            alloc.bytes.len(),\n+            alloc.size.bytes(),\n             alloc.align.bytes(),\n             extra\n         );"}, {"sha": "0f0c422d8d3f4668a88724c12c6ad35b117c7698", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=d8c5bc7ec6ea2501bdbd2853551aa83175d6e8d0", "patch": "@@ -15,7 +15,7 @@ use rustc::mir::interpret::{\n };\n \n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::layout::Align;\n+use rustc::ty::layout::{Align, Size};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -276,6 +276,7 @@ struct AllocationSnapshot<'a> {\n     relocations: Relocations<(), AllocIdSnapshot<'a>>,\n     undef_mask: &'a UndefMask,\n     align: &'a Align,\n+    size: &'a Size,\n     mutability: &'a Mutability,\n }\n \n@@ -285,12 +286,27 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n     type Item = AllocationSnapshot<'a>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let Allocation { bytes, relocations, undef_mask, align, mutability, extra: () } = self;\n+        let Allocation {\n+            relocations,\n+            size,\n+            align,\n+            mutability,\n+            extra: (),\n+            ..\n+        } = self;\n+\n+        let all_bytes = 0..self.len();\n+        // This 'inspect' is okay since following access respects undef and relocations. This does\n+        // influence interpreter exeuction, but only to detect the error of cycles in evalution\n+        // dependencies.\n+        let bytes = self.inspect_with_undef_and_ptr_outside_interpreter(all_bytes);\n+        let undef_mask = self.undef_mask();\n \n         AllocationSnapshot {\n             bytes,\n             undef_mask,\n             align,\n+            size,\n             mutability,\n             relocations: relocations.snapshot(ctx),\n         }"}]}