{"sha": "dcf7fbf833130a046c41d58a26567e39a6c001ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZjdmYmY4MzMxMzBhMDQ2YzQxZDU4YTI2NTY3ZTM5YTZjMDAxY2U=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-04T00:09:50Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-04T00:09:50Z"}, "message": "Comments and cleanup.", "tree": {"sha": "22b75574e4f089f0e406ede1e01a9d199f76085f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22b75574e4f089f0e406ede1e01a9d199f76085f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcf7fbf833130a046c41d58a26567e39a6c001ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcf7fbf833130a046c41d58a26567e39a6c001ce", "html_url": "https://github.com/rust-lang/rust/commit/dcf7fbf833130a046c41d58a26567e39a6c001ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcf7fbf833130a046c41d58a26567e39a6c001ce/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb4c969ba6ec61007ac1bbdaeed7eb5f21859949", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb4c969ba6ec61007ac1bbdaeed7eb5f21859949", "html_url": "https://github.com/rust-lang/rust/commit/cb4c969ba6ec61007ac1bbdaeed7eb5f21859949"}], "stats": {"total": 95, "additions": 64, "deletions": 31}, "files": [{"sha": "9cfe8a51fbb20afb40c37bbf78e92ce0415bcf03", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 64, "deletions": 31, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/dcf7fbf833130a046c41d58a26567e39a6c001ce/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf7fbf833130a046c41d58a26567e39a6c001ce/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=dcf7fbf833130a046c41d58a26567e39a6c001ce", "patch": "@@ -160,8 +160,8 @@ state type fn_ctxt = rec(\n     // The three implicit arguments that arrive in the function we're\n     // creating.  For instance, foo(int, int) is really foo(ret*, task*, env*,\n     // int, int).  These are also available via llvm::LLVMGetParam(llfn, uint)\n-    // where uint = 2, 0, 1 respectively, but we unpack them here for\n-    // convenience.\n+    // where uint = 1, 2, 0 respectively, but we unpack them into these fields\n+    // for convenience.\n     ValueRef lltaskptr,\n     ValueRef llenv,\n     ValueRef llretptr,\n@@ -7000,6 +7000,7 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ast::def_id fid,\n             &vec[ast::ty_param] ty_params, &ast::ann ann) {\n     auto llfndecl = cx.ccx.item_ids.get(fid);\n \n+    // Set up arguments to the function.\n     auto fcx = new_fn_ctxt(cx, sp, llfndecl);\n     create_llargs_for_fn_args(fcx, f.proto,\n                               ty_self, ret_ty_of_fn(cx.ccx, ann),\n@@ -7018,9 +7019,10 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ast::def_id fid,\n     auto arg_tys = arg_tys_of_fn(fcx.lcx.ccx, ann);\n     copy_args_to_allocas(fcx, f.decl.inputs, arg_tys);\n \n+    // Create the first basic block in the function and keep a handle on it to\n+    //  pass to finish_fn later.\n     auto bcx = new_top_block_ctxt(fcx);\n     add_cleanups_for_args(bcx, f.decl.inputs, arg_tys);\n-\n     auto lltop = bcx.llbb;\n \n     auto block_ty = node_ann_type(cx.ccx, f.body.node.a);\n@@ -7041,9 +7043,12 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ast::def_id fid,\n         res.bcx.build.RetVoid();\n     }\n \n+    // Insert the mandatory first few basic blocks before lltop.\n     finish_fn(fcx, lltop);\n }\n \n+// Create a vtable for an object being translated.  Returns a pointer into\n+// read-only memory.\n fn create_vtbl(@local_ctxt cx,\n               TypeRef llself_ty,\n               ty::t self_ty,\n@@ -7136,13 +7141,15 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n     // starting with an ast::_obj rather than an ast::_fn, we have some setup\n     // work to do.\n \n-    // Translate obj ctor args to function arguments.\n+    // The fields of our object will become the arguments to the function\n+    // we're creating.\n     let vec[ast::arg] fn_args = [];\n     for (ast::obj_field f in ob.fields) {\n         fn_args += [rec(mode=ast::alias, ty=f.ty, ident=f.ident, id=f.id)];\n     }\n-\n     auto fcx = new_fn_ctxt(cx, sp, llctor_decl);\n+\n+    // Both regular arguments and type parameters are handled here.\n     create_llargs_for_fn_args(fcx, ast::proto_fn,\n                               none[ty_self_pair],\n                               ret_ty_of_fn(ccx, ann),\n@@ -7151,78 +7158,103 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n     let vec[ty::arg] arg_tys = arg_tys_of_fn(ccx, ann);\n     copy_args_to_allocas(fcx, fn_args, arg_tys);\n \n-    //  Make the first block context in the function and keep a handle on it\n+    //  Create the first block context in the function and keep a handle on it\n     //  to pass to finish_fn later.\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n+    // Pick up the type of this object by looking at our own output type, that\n+    // is, the output type of the object constructor we're building.\n     auto self_ty = ret_ty_of_fn(ccx, ann);\n     auto llself_ty = type_of(ccx, sp, self_ty);\n-    auto pair = bcx.fcx.llretptr;\n \n-    auto vtbl = create_vtbl(cx, llself_ty, self_ty, ob, ty_params);\n+    // Set up the two-word pair that we're going to return from the object\n+    // constructor we're building.  The two elements of this pair will be a\n+    // vtable pointer and a body pointer.  (llretptr already points to the\n+    // place where this two-word pair should go; it was pre-allocated by the\n+    // caller of the function.)\n+    auto pair = bcx.fcx.llretptr;\n \n+    // Grab onto the first and second elements of the pair.\n+    // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n+    // of 'pair'.\n     auto pair_vtbl = bcx.build.GEP(pair,\n                                    [C_int(0),\n-                                       C_int(abi::obj_field_vtbl)]);\n+                                    C_int(abi::obj_field_vtbl)]);\n     auto pair_box = bcx.build.GEP(pair,\n                                   [C_int(0),\n-                                      C_int(abi::obj_field_box)]);\n+                                   C_int(abi::obj_field_box)]);\n+\n+    // Make a vtable for this object: a static array of pointers to functions.\n+    // It will be located in the read-only memory of the executable we're\n+    // creating and will contain ValueRefs for all of this object's methods.\n+    // create_vtbl returns a pointer to the vtable, which we store.\n+    auto vtbl = create_vtbl(cx, llself_ty, self_ty, ob, ty_params);\n     bcx.build.Store(vtbl, pair_vtbl);\n \n-    let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n+    // Next we have to take care of the other half of the pair we're\n+    // returning: a boxed (reference-counted) tuple containing a tydesc,\n+    // typarams, and fields.\n \n-    // FIXME we should probably also allocate a box for empty objs that have a\n-    // dtor, since otherwise they are never dropped, and the dtor never runs\n+    // FIXME: What about with_obj?  Do we have to think about it here?\n+    // (Pertains to issue #417.)\n+\n+    let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n+    \n+    // FIXME: we should probably also allocate a box for empty objs that have\n+    // a dtor, since otherwise they are never dropped, and the dtor never\n+    // runs.\n     if (vec::len[ast::ty_param](ty_params) == 0u &&\n         vec::len[ty::arg](arg_tys) == 0u) {\n+        // If the object we're translating has no fields or type parameters,\n+        // there's not much to do.\n+\n         // Store null into pair, if no args or typarams.\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n-        // Malloc a box for the body and copy args in.\n+        // Otherwise, we have to synthesize a big structural type for the\n+        // object body.\n \n         let vec[ty::t] obj_fields = [];\n         for (ty::arg a in arg_tys) {\n             vec::push[ty::t](obj_fields, a.ty);\n         }\n \n-        // Synthesize an obj body type.\n+        // Tuple type for fields: [field, ...]\n+        let ty::t fields_ty = ty::mk_imm_tup(ccx.tcx, obj_fields);\n+\n+        // Tuple type for typarams: [typaram, ...]\n         auto tydesc_ty = ty::mk_type(ccx.tcx);\n         let vec[ty::t] tps = [];\n         for (ast::ty_param tp in ty_params) {\n             vec::push[ty::t](tps, tydesc_ty);\n         }\n-\n-        // typarams_ty = [typaram_ty, ...]\n         let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, tps);\n-\n-        // fields_ty = [field_ty, ...]\n-        let ty::t fields_ty = ty::mk_imm_tup(ccx.tcx, obj_fields); \n-\n-        // body_ty = [tydesc_ty, [typaram_ty, ...], [field_ty, ...]]\n+ \n+        // Tuple type for body: [tydesc_ty, [typaram, ...], [field, ...]]\n         let ty::t body_ty = ty::mk_imm_tup(ccx.tcx,\n                                           [tydesc_ty,\n                                            typarams_ty,\n                                            fields_ty]);\n \n-        // boxed_body_ty = [[tydesc_ty, [typaram_ty, ...], [field_ty, ...]]]\n-        let ty::t boxed_body_ty = ty::mk_imm_box(ccx.tcx, body_ty);\n-\n-        // Malloc a box for the body.\n+        // Hand this thing we've constructed off to trans_malloc_boxed, which\n+        // makes space for the refcount.\n         auto box = trans_malloc_boxed(bcx, body_ty);\n         bcx = box.bcx;\n+\n+        // And mk_imm_box throws a refcount into the type we're synthesizing:\n+        // [rc, [tydesc_ty, [typaram, ...], [field, ...]]]\n+        let ty::t boxed_body_ty = ty::mk_imm_box(ccx.tcx, body_ty);\n+\n         auto rc = GEP_tup_like(bcx, boxed_body_ty, box.val,\n-                               [0, abi::box_rc_field_refcnt]);\n+                               [0, \n+                                abi::box_rc_field_refcnt]);\n         bcx = rc.bcx;\n \n-        // We've now created a structure that looks like:\n-        // [refcount, [tydesc_ty, [typaram_ty, ...], [field_ty, ...]]]\n-\n         auto body = GEP_tup_like(bcx, boxed_body_ty, box.val,\n                                  [0, abi::box_rc_field_body]);\n         bcx = body.bcx;\n \n-\n         bcx.build.Store(C_int(1), rc.val);\n \n         // Put together a tydesc for the body, so that the object can later be\n@@ -7285,6 +7317,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n     }\n     bcx.build.RetVoid();\n \n+    // Insert the mandatory first few basic blocks before lltop.\n     finish_fn(fcx, lltop);\n }\n "}]}