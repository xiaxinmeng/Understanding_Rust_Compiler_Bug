{"sha": "d37a7ab32b4f4f1a0b944abaa3ca104978aecb12", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzN2E3YWIzMmI0ZjRmMWEwYjk0NGFiYWEzY2ExMDQ5NzhhZWNiMTI=", "commit": {"author": {"name": "bobtwinkles", "email": "srkoser+GitHub@gmail.com", "date": "2018-03-25T02:00:38Z"}, "committer": {"name": "bobtwinkles", "email": "srkoser+GitHub@gmail.com", "date": "2018-03-25T02:00:38Z"}, "message": "Extend two-phase borrows to apply to method receiver autorefs\n\nThis is required to compile things like\n\nsrc/test/ui/borrowck/two-phase-method-receivers.rs", "tree": {"sha": "543720e877a7868a4a7dacde107a06f0d0b85c02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/543720e877a7868a4a7dacde107a06f0d0b85c02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12", "html_url": "https://github.com/rust-lang/rust/commit/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/comments", "author": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a04b88d1941644df01fa5e31dd43e0f57c13d938", "url": "https://api.github.com/repos/rust-lang/rust/commits/a04b88d1941644df01fa5e31dd43e0f57c13d938", "html_url": "https://github.com/rust-lang/rust/commit/a04b88d1941644df01fa5e31dd43e0f57c13d938"}], "stats": {"total": 137, "additions": 100, "deletions": 37}, "files": [{"sha": "70fe3afa6d25bbcafded865ae092ce6c214b7342", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=d37a7ab32b4f4f1a0b944abaa3ca104978aecb12", "patch": "@@ -434,7 +434,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                     let f = self.expr_ty.fn_sig(fcx.tcx);\n                     let res = fcx.try_coerce(self.expr,\n                                              self.expr_ty,\n-                                             fcx.tcx.mk_fn_ptr(f));\n+                                             fcx.tcx.mk_fn_ptr(f),\n+                                             false);\n                     if !res.is_ok() {\n                         return Err(CastError::NonScalar);\n                     }\n@@ -616,7 +617,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty).is_ok()\n+        fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty, false).is_ok()\n     }\n }\n "}, {"sha": "255794aeab4322f609c8c7db1a5f181ed1772284", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d37a7ab32b4f4f1a0b944abaa3ca104978aecb12", "patch": "@@ -84,6 +84,12 @@ struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     cause: ObligationCause<'tcx>,\n     use_lub: bool,\n+    /// Determines whether or not allow_two_phase_borrow is set on any\n+    /// autoref adjustments we create while coercing. We don't want to\n+    /// allow deref coercions to create two-phase borrows, at least initially,\n+    /// but we do need two-phase borrows for function argument reborrows.\n+    /// See #47489 and #48598\n+    allow_two_phase: bool,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n@@ -123,10 +129,13 @@ fn success<'tcx>(adj: Vec<Adjustment<'tcx>>,\n }\n \n impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n-    fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>, cause: ObligationCause<'tcx>) -> Self {\n+    fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>,\n+           cause: ObligationCause<'tcx>,\n+           allow_two_phase: bool) -> Self {\n         Coerce {\n             fcx,\n             cause,\n+            allow_two_phase,\n             use_lub: false,\n         }\n     }\n@@ -424,10 +433,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let mutbl = match mt_b.mutbl {\n             hir::MutImmutable => AutoBorrowMutability::Immutable,\n             hir::MutMutable => AutoBorrowMutability::Mutable {\n-                // Deref-coercion is a case where we deliberately\n-                // disallow two-phase borrows in its initial\n-                // deployment; see discussion on PR #47489.\n-                allow_two_phase_borrow: false,\n+                allow_two_phase_borrow: self.allow_two_phase,\n             }\n         };\n         adjustments.push(Adjustment {\n@@ -473,6 +479,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 let mutbl = match mt_b.mutbl {\n                     hir::MutImmutable => AutoBorrowMutability::Immutable,\n                     hir::MutMutable => AutoBorrowMutability::Mutable {\n+                        // We don't allow two-phase borrows here, at least for initial\n+                        // implementation. If it happens that this coercion is a function argument,\n+                        // the reborrow in coerce_borrowed_ptr will pick it up.\n                         allow_two_phase_borrow: false,\n                     }\n                 };\n@@ -751,13 +760,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn try_coerce(&self,\n                       expr: &hir::Expr,\n                       expr_ty: Ty<'tcx>,\n-                      target: Ty<'tcx>)\n+                      target: Ty<'tcx>,\n+                      allow_two_phase: bool)\n                       -> RelateResult<'tcx, Ty<'tcx>> {\n         let source = self.resolve_type_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n-        let coerce = Coerce::new(self, cause);\n+        let coerce = Coerce::new(self, cause, allow_two_phase);\n         let ok = self.commit_if_ok(|_| coerce.coerce(source, target))?;\n \n         let (adjustments, _) = self.register_infer_ok_obligations(ok);\n@@ -771,7 +781,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"coercion::can({:?} -> {:?})\", source, target);\n \n         let cause = self.cause(syntax_pos::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n-        let coerce = Coerce::new(self, cause);\n+        // We don't ever need two-phase here since we throw out the result of the coercion\n+        let coerce = Coerce::new(self, cause, false);\n         self.probe(|_| coerce.coerce(source, target)).is_ok()\n     }\n \n@@ -840,7 +851,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return Ok(fn_ptr);\n         }\n \n-        let mut coerce = Coerce::new(self, cause.clone());\n+        // Configure a Coerce instance to compute the LUB.\n+        // We don't allow two-phase borrows on any autorefs this creates since we\n+        // probably aren't processing function arguments here and even if we were,\n+        // they're going to get autorefed again anyway and we can apply 2-phase borrows\n+        // at that time.\n+        let mut coerce = Coerce::new(self, cause.clone(), false);\n         coerce.use_lub = true;\n \n         // First try to coerce the new expression to the type of the previous ones,\n@@ -1106,7 +1122,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n             if self.pushed == 0 {\n                 // Special-case the first expression we are coercing.\n                 // To be honest, I'm not entirely sure why we do this.\n-                fcx.try_coerce(expression, expression_ty, self.expected_ty)\n+                // We don't allow two-phase borrows, see comment in try_find_coercion_lub for why\n+                fcx.try_coerce(expression, expression_ty, self.expected_ty, false)\n             } else {\n                 match self.expressions {\n                     Expressions::Dynamic(ref exprs) =>"}, {"sha": "ab89e17d81fe6fb542a5bae177da4d6cd72fb2a9", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d37a7ab32b4f4f1a0b944abaa3ca104978aecb12", "patch": "@@ -79,9 +79,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn demand_coerce(&self,\n                          expr: &hir::Expr,\n                          checked_ty: Ty<'tcx>,\n-                         expected: Ty<'tcx>)\n+                         expected: Ty<'tcx>,\n+                         allow_two_phase: bool)\n                          -> Ty<'tcx> {\n-        let (ty, err) = self.demand_coerce_diag(expr, checked_ty, expected);\n+        let (ty, err) = self.demand_coerce_diag(expr, checked_ty, expected, allow_two_phase);\n         if let Some(mut err) = err {\n             err.emit();\n         }\n@@ -96,11 +97,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn demand_coerce_diag(&self,\n                               expr: &hir::Expr,\n                               checked_ty: Ty<'tcx>,\n-                              expected: Ty<'tcx>)\n+                              expected: Ty<'tcx>,\n+                              allow_two_phase: bool)\n                               -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx>>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n \n-        let e = match self.try_coerce(expr, checked_ty, expected) {\n+        let e = match self.try_coerce(expr, checked_ty, expected, allow_two_phase) {\n             Ok(ty) => return (ty, None),\n             Err(e) => e\n         };"}, {"sha": "fe27dd50af472e1a73c52b9c85b5edf6eae515d3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d37a7ab32b4f4f1a0b944abaa3ca104978aecb12", "patch": "@@ -2649,7 +2649,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 //    to, which is `expected_ty` if `rvalue_hint` returns an\n                 //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n                 let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n-                self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty));\n+                self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty), true);\n \n                 // 3. Relate the expected type and the formal one,\n                 //    if the expected type was used for the coercion.\n@@ -2812,7 +2812,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             expr,\n             ExpectHasType(expected),\n             needs);\n-        self.demand_coerce(expr, ty, expected)\n+        self.demand_coerce(expr, ty, expected, false)\n     }\n \n     fn check_expr_with_hint(&self, expr: &'gcx hir::Expr,\n@@ -4112,7 +4112,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   let base_t = self.structurally_resolved_type(expr.span, base_t);\n                   match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n                       Some((index_ty, element_ty)) => {\n-                          self.demand_coerce(idx, idx_t, index_ty);\n+                          // two-phase not needed because index_ty is never mutable\n+                          self.demand_coerce(idx, idx_t, index_ty, false);\n                           element_ty\n                       }\n                       None => {"}, {"sha": "ef39fabda10e62f744b4eb186615c49c036f86da", "filename": "src/test/compile-fail/borrowck/two-phase-nonrecv-autoref.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs?ref=d37a7ab32b4f4f1a0b944abaa3ca104978aecb12", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n+// revisions: ast lxl nll\n+//[ast]compile-flags:\n //[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n //[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n@@ -33,17 +34,14 @@\n \n use std::ops::{Index, IndexMut};\n \n-// This is case outlined by Niko that we want to ensure we reject\n-// (at least initially).\n-\n fn foo(x: &mut u32, y: u32) {\n     *x += y;\n }\n \n fn deref_coercion(x: &mut u32) {\n     foo(x, *x);\n-    //[lxl]~^ ERROR cannot use `*x` because it was mutably borrowed [E0503]\n-    //[nll]~^^ ERROR cannot use `*x` because it was mutably borrowed [E0503]\n+    //[ast]~^ ERROR cannot use `*x` because it was mutably borrowed [E0503]\n+    // Above error is a known limitation of AST borrowck\n }\n \n // While adding a flag to adjustments (indicating whether they\n@@ -74,22 +72,25 @@ fn overloaded_call_traits() {\n         //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n         //[nll]~^^   ERROR cannot borrow `*f` as mutable more than once at a time\n         //[g2p]~^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[ast]~^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n     }\n     fn twice_ten_si<F: Fn(i32) -> i32>(f: &mut F) {\n         f(f(10));\n     }\n     fn twice_ten_so<F: FnOnce(i32) -> i32>(f: Box<F>) {\n         f(f(10));\n-        //[lxl]~^   ERROR use of moved value: `*f`\n-        //[nll]~^^  ERROR use of moved value: `*f`\n-        //[g2p]~^^^ ERROR use of moved value: `*f`\n+        //[lxl]~^    ERROR use of moved value: `*f`\n+        //[nll]~^^   ERROR use of moved value: `*f`\n+        //[g2p]~^^^  ERROR use of moved value: `*f`\n+        //[ast]~^^^^ ERROR use of moved value: `*f`\n     }\n \n     fn twice_ten_om(f: &mut FnMut(i32) -> i32) {\n         f(f(10));\n-        //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[lxl]~^    ERROR cannot borrow `*f` as mutable more than once at a time\n         //[nll]~^^   ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[g2p]~^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[g2p]~^^^  ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[ast]~^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n     }\n     fn twice_ten_oi(f: &mut Fn(i32) -> i32) {\n         f(f(10));\n@@ -105,6 +106,7 @@ fn overloaded_call_traits() {\n         //[g2p]~^^^^^^^       ERROR cannot move a value of type\n         //[g2p]~^^^^^^^^      ERROR cannot move a value of type\n         //[g2p]~^^^^^^^^^     ERROR use of moved value: `*f`\n+        //[ast]~^^^^^^^^^^    ERROR use of moved value: `*f`\n     }\n \n     twice_ten_sm(&mut |x| x + 1);\n@@ -142,12 +144,15 @@ fn coerce_unsized() {\n \n     // This is not okay.\n     double_access(&mut a, &a);\n-    //[lxl]~^   ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n-    //[nll]~^^  ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n-    //[g2p]~^^^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[lxl]~^    ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^^   ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[g2p]~^^^  ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[ast]~^^^^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n \n     // But this is okay.\n     a.m(a.i(10));\n+    //[ast]~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    // Above error is an expected limitation of AST borrowck\n }\n \n struct I(i32);\n@@ -168,21 +173,25 @@ impl IndexMut<i32> for I {\n fn coerce_index_op() {\n     let mut i = I(10);\n     i[i[3]] = 4;\n-    //[lxl]~^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n-    //[nll]~^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[lxl]~^   ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[ast]~^^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n \n     i[3] = i[4];\n \n     i[i[3]] = i[4];\n-    //[lxl]~^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n-    //[nll]~^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[lxl]~^   ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[ast]~^^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n }\n \n fn main() {\n \n     // As a reminder, this is the basic case we want to ensure we handle.\n     let mut v = vec![1, 2, 3];\n     v.push(v.len());\n+    //[ast]~^ ERROR cannot borrow `v` as immutable because it is also borrowed as mutable [E0502]\n+    // Error above is an expected limitation of AST borrowck\n \n     // (as a rule, pnkfelix does not like to write tests with dead code.)\n \n@@ -192,9 +201,13 @@ fn main() {\n \n     let mut s = S;\n     s.m(s.i(10));\n+    //[ast]~^ ERROR cannot borrow `s` as immutable because it is also borrowed as mutable [E0502]\n+    // Error above is an expected limitation of AST borrowck\n \n     let mut t = T;\n     t.m(t.i(10));\n+    //[ast]~^ ERROR cannot borrow `t` as immutable because it is also borrowed as mutable [E0502]\n+    // Error above is an expected limitation of AST borrowck\n \n     coerce_unsized();\n     coerce_index_op();"}, {"sha": "e690263a916f3cf5f42750f229a1fb8f424b25eb", "filename": "src/test/ui/borrowck/two-phase-method-receivers.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-method-receivers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d37a7ab32b4f4f1a0b944abaa3ca104978aecb12/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-method-receivers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-method-receivers.rs?ref=d37a7ab32b4f4f1a0b944abaa3ca104978aecb12", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll\n+//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n+// run-pass\n+\n+struct Foo<'a> {\n+    x: &'a i32\n+}\n+\n+impl<'a> Foo<'a> {\n+    fn method(&mut self, _: &i32) {\n+    }\n+}\n+\n+fn main() {\n+    let a = &mut Foo { x: &22 };\n+    Foo::method(a, a.x);\n+}"}]}