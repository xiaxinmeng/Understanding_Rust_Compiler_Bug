{"sha": "4a89a7c9026dc3df4466f7b10c666186830d38f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhODlhN2M5MDI2ZGMzZGY0NDY2ZjdiMTBjNjY2MTg2ODMwZDM4ZjY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-07T15:47:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-07T15:47:56Z"}, "message": "Merge #1786\n\n1786: Various minor trait improvements r=matklad a=flodiebold\n\n - lower bounds on trait definition, i.e. super traits\r\n - use super traits for associated types\r\n - use traits from where clauses and their super traits for method resolution\r\n - lower fn-like paths (i.e. `Fn(X, Y) -> Z`)\r\n - pass the environment to Chalk in the correct way to make elaboration work, i.e. inferring things like `T: Clone` from `T: Copy`. The clauses need to be wrapped in `FromEnv` clauses for that to work, which I didn't do before.\r\n - add some tests for closure inference already\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "fdf832ba772141368f27d733cd718ee9a599a346", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdf832ba772141368f27d733cd718ee9a599a346"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a89a7c9026dc3df4466f7b10c666186830d38f6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdc9EsCRBK7hj4Ov3rIwAAdHIIAH6eOjvmyl1B9gzUgMVuGU82\njn7EVKMGyU1I7Pwtb3IzRuZ6wxl6RKEaCbeHdIvGK+3fpc4cjq0iG5ru6bTQAEw7\nhUt1GUPdDAbvgqDwpzOl3yhsIoTB3GmRGbZzS5mDc4EVPjZrXQkhp86dZt6zWP/Q\n8luX9KT1guvvQUQTpVBbm1Uc3vqUsPuC2aycRxTEPOaD+B4Tn+7YEt5GVKDUUBG+\nNzZOSV2mERb+Y6LB6lmyu+UMvGWyV9t6o5ydRHQwJ2aw0tu3KGI3sxlRfwhFKsb7\ne80J8SkBdPMIiUmRkXuMqUHEzT7SXq98ENZeNtSx56oEauPDDJPrGpSZECW60XQ=\n=y8mw\n-----END PGP SIGNATURE-----\n", "payload": "tree fdf832ba772141368f27d733cd718ee9a599a346\nparent a73b424e3bcf3e211f87d5a9b175a89231848c6d\nparent 8fb3cab76c60fbff5ae6f5984ac07b09b42b742c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1567871276 +0000\ncommitter GitHub <noreply@github.com> 1567871276 +0000\n\nMerge #1786\n\n1786: Various minor trait improvements r=matklad a=flodiebold\n\n - lower bounds on trait definition, i.e. super traits\r\n - use super traits for associated types\r\n - use traits from where clauses and their super traits for method resolution\r\n - lower fn-like paths (i.e. `Fn(X, Y) -> Z`)\r\n - pass the environment to Chalk in the correct way to make elaboration work, i.e. inferring things like `T: Clone` from `T: Copy`. The clauses need to be wrapped in `FromEnv` clauses for that to work, which I didn't do before.\r\n - add some tests for closure inference already\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a89a7c9026dc3df4466f7b10c666186830d38f6", "html_url": "https://github.com/rust-lang/rust/commit/4a89a7c9026dc3df4466f7b10c666186830d38f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a89a7c9026dc3df4466f7b10c666186830d38f6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a73b424e3bcf3e211f87d5a9b175a89231848c6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a73b424e3bcf3e211f87d5a9b175a89231848c6d", "html_url": "https://github.com/rust-lang/rust/commit/a73b424e3bcf3e211f87d5a9b175a89231848c6d"}, {"sha": "8fb3cab76c60fbff5ae6f5984ac07b09b42b742c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fb3cab76c60fbff5ae6f5984ac07b09b42b742c", "html_url": "https://github.com/rust-lang/rust/commit/8fb3cab76c60fbff5ae6f5984ac07b09b42b742c"}], "stats": {"total": 434, "additions": 394, "deletions": 40}, "files": [{"sha": "1bb2f9f284271b7ba4f6271bcb8d6491781e15b2", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -820,7 +820,52 @@ impl Trait {\n         self.trait_data(db).items().to_vec()\n     }\n \n-    pub fn associated_type_by_name(self, db: &impl DefDatabase, name: Name) -> Option<TypeAlias> {\n+    fn direct_super_traits(self, db: &impl HirDatabase) -> Vec<Trait> {\n+        let resolver = self.resolver(db);\n+        // returning the iterator directly doesn't easily work because of\n+        // lifetime problems, but since there usually shouldn't be more than a\n+        // few direct traits this should be fine (we could even use some kind of\n+        // SmallVec if performance is a concern)\n+        self.generic_params(db)\n+            .where_predicates\n+            .iter()\n+            .filter_map(|pred| match &pred.type_ref {\n+                TypeRef::Path(p) if p.as_ident() == Some(&crate::name::SELF_TYPE) => {\n+                    pred.bound.as_path()\n+                }\n+                _ => None,\n+            })\n+            .filter_map(|path| {\n+                match resolver.resolve_path_without_assoc_items(db, path).take_types() {\n+                    Some(crate::Resolution::Def(ModuleDef::Trait(t))) => Some(t),\n+                    _ => None,\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    /// Returns an iterator over the whole super trait hierarchy (including the\n+    /// trait itself).\n+    pub fn all_super_traits(self, db: &impl HirDatabase) -> Vec<Trait> {\n+        // we need to take care a bit here to avoid infinite loops in case of cycles\n+        // (i.e. if we have `trait A: B; trait B: A;`)\n+        let mut result = vec![self];\n+        let mut i = 0;\n+        while i < result.len() {\n+            let t = result[i];\n+            // yeah this is quadratic, but trait hierarchies should be flat\n+            // enough that this doesn't matter\n+            for tt in t.direct_super_traits(db) {\n+                if !result.contains(&tt) {\n+                    result.push(tt);\n+                }\n+            }\n+            i += 1;\n+        }\n+        result\n+    }\n+\n+    pub fn associated_type_by_name(self, db: &impl DefDatabase, name: &Name) -> Option<TypeAlias> {\n         let trait_data = self.trait_data(db);\n         trait_data\n             .items()\n@@ -829,7 +874,15 @@ impl Trait {\n                 TraitItem::TypeAlias(t) => Some(*t),\n                 _ => None,\n             })\n-            .find(|t| t.name(db) == name)\n+            .find(|t| &t.name(db) == name)\n+    }\n+\n+    pub fn associated_type_by_name_including_super_traits(\n+        self,\n+        db: &impl HirDatabase,\n+        name: &Name,\n+    ) -> Option<TypeAlias> {\n+        self.all_super_traits(db).into_iter().find_map(|t| t.associated_type_by_name(db, name))\n     }\n \n     pub(crate) fn trait_data(self, db: &impl DefDatabase) -> Arc<TraitData> {"}, {"sha": "c76df0698c4a2e10e495531b7da449fbca7548d3", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -87,11 +87,15 @@ impl GenericParams {\n                 // traits get the Self type as an implicit first type parameter\n                 generics.params.push(GenericParam { idx: start, name: SELF_TYPE, default: None });\n                 generics.fill(&it.source(db).ast, start + 1);\n+                // add super traits as bounds on Self\n+                // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n+                let self_param = TypeRef::Path(SELF_TYPE.into());\n+                generics.fill_bounds(&it.source(db).ast, self_param);\n             }\n             GenericDef::TypeAlias(it) => generics.fill(&it.source(db).ast, start),\n             // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n             // type-parameter, but rather is a type-alias for impl's target\n-            // type, so this is handled by the resovler.\n+            // type, so this is handled by the resolver.\n             GenericDef::ImplBlock(it) => generics.fill(&it.source(db).ast, start),\n             GenericDef::EnumVariant(_) => {}\n         }\n@@ -108,6 +112,14 @@ impl GenericParams {\n         }\n     }\n \n+    fn fill_bounds(&mut self, node: &impl ast::TypeBoundsOwner, type_ref: TypeRef) {\n+        for bound in\n+            node.type_bound_list().iter().flat_map(|type_bound_list| type_bound_list.bounds())\n+        {\n+            self.add_where_predicate_from_bound(bound, type_ref.clone());\n+        }\n+    }\n+\n     fn fill_params(&mut self, params: ast::TypeParamList, start: u32) {\n         for (idx, type_param) in params.type_params().enumerate() {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n@@ -117,13 +129,7 @@ impl GenericParams {\n             self.params.push(param);\n \n             let type_ref = TypeRef::Path(name.into());\n-            for bound in type_param\n-                .type_bound_list()\n-                .iter()\n-                .flat_map(|type_bound_list| type_bound_list.bounds())\n-            {\n-                self.add_where_predicate_from_bound(bound, type_ref.clone());\n-            }\n+            self.fill_bounds(&type_param, type_ref);\n         }\n     }\n "}, {"sha": "13bc901bc9f1a58fbfe6f60ae4d6cf4dbac81afb", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -38,11 +38,6 @@ impl Name {\n         Name::new(idx.to_string().into())\n     }\n \n-    // Needed for Deref\n-    pub(crate) fn target() -> Name {\n-        Name::new(\"Target\".into())\n-    }\n-\n     // There's should be no way to extract a string out of `Name`: `Name` in the\n     // future, `Name` will include hygiene information, and you can't encode\n     // hygiene into a String.\n@@ -123,6 +118,7 @@ pub(crate) const FUTURE_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6,\n pub(crate) const RESULT_MOD: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"result\"));\n pub(crate) const RESULT_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Result\"));\n pub(crate) const OUTPUT: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Output\"));\n+pub(crate) const TARGET: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Target\"));\n \n fn resolve_name(text: &SmolStr) -> SmolStr {\n     let raw_start = \"r#\";"}, {"sha": "d6c78593bc55a945fbd3ea8651b91513b1d2ae77", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -1,11 +1,11 @@\n use std::sync::Arc;\n \n use ra_syntax::{\n-    ast::{self, NameOwner},\n+    ast::{self, NameOwner, TypeAscriptionOwner},\n     AstNode,\n };\n \n-use crate::{type_ref::TypeRef, AsName, Name};\n+use crate::{name, type_ref::TypeRef, AsName, Name};\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n@@ -76,8 +76,16 @@ impl Path {\n \n             match segment.kind()? {\n                 ast::PathSegmentKind::Name(name) => {\n-                    let args =\n-                        segment.type_arg_list().and_then(GenericArgs::from_ast).map(Arc::new);\n+                    let args = segment\n+                        .type_arg_list()\n+                        .and_then(GenericArgs::from_ast)\n+                        .or_else(|| {\n+                            GenericArgs::from_fn_like_path_ast(\n+                                segment.param_list(),\n+                                segment.ret_type(),\n+                            )\n+                        })\n+                        .map(Arc::new);\n                     let segment = PathSegment { name: name.as_name(), args_and_bindings: args };\n                     segments.push(segment);\n                 }\n@@ -187,6 +195,34 @@ impl GenericArgs {\n         }\n     }\n \n+    /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n+    /// -> Z` (which desugars to `Fn<(X, Y), Output=Z>`).\n+    pub(crate) fn from_fn_like_path_ast(\n+        params: Option<ast::ParamList>,\n+        ret_type: Option<ast::RetType>,\n+    ) -> Option<GenericArgs> {\n+        let mut args = Vec::new();\n+        let mut bindings = Vec::new();\n+        if let Some(params) = params {\n+            let mut param_types = Vec::new();\n+            for param in params.params() {\n+                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n+                param_types.push(type_ref);\n+            }\n+            let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n+            args.push(arg);\n+        }\n+        if let Some(ret_type) = ret_type {\n+            let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n+            bindings.push((name::OUTPUT, type_ref))\n+        }\n+        if args.is_empty() && bindings.is_empty() {\n+            None\n+        } else {\n+            Some(GenericArgs { args, has_self_type: false, bindings })\n+        }\n+    }\n+\n     pub(crate) fn empty() -> GenericArgs {\n         GenericArgs { args: Vec::new(), has_self_type: false, bindings: Vec::new() }\n     }"}, {"sha": "caa17f64eac36625e32ecd944136976cd9d315cb", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -8,7 +8,7 @@ use std::iter::successors;\n use log::{info, warn};\n \n use super::{traits::Solution, Canonical, Ty, TypeWalk};\n-use crate::{HasGenericParams, HirDatabase, Name, Resolver};\n+use crate::{name, HasGenericParams, HirDatabase, Resolver};\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n \n@@ -42,7 +42,7 @@ fn deref_by_trait(\n         crate::lang_item::LangItemTarget::Trait(t) => t,\n         _ => return None,\n     };\n-    let target = deref_trait.associated_type_by_name(db, Name::target())?;\n+    let target = deref_trait.associated_type_by_name(db, &name::TARGET)?;\n \n     if target.generic_params(db).count_params_including_parent() != 1 {\n         // the Target type + Deref trait should only have one generic parameter,"}, {"sha": "0e6ebd3652c525b8f04a1697ae61ab2c0c58fefa", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -1453,7 +1453,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         match self.resolver.resolve_path_segments(self.db, &into_iter_path).into_fully_resolved() {\n             PerNs { types: Some(Def(Trait(trait_))), .. } => {\n-                Some(trait_.associated_type_by_name(self.db, name::ITEM)?)\n+                Some(trait_.associated_type_by_name(self.db, &name::ITEM)?)\n             }\n             _ => None,\n         }\n@@ -1471,7 +1471,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         match self.resolver.resolve_path_segments(self.db, &ops_try_path).into_fully_resolved() {\n             PerNs { types: Some(Def(Trait(trait_))), .. } => {\n-                Some(trait_.associated_type_by_name(self.db, name::OK)?)\n+                Some(trait_.associated_type_by_name(self.db, &name::OK)?)\n             }\n             _ => None,\n         }\n@@ -1493,7 +1493,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             .into_fully_resolved()\n         {\n             PerNs { types: Some(Def(Trait(trait_))), .. } => {\n-                Some(trait_.associated_type_by_name(self.db, name::OUTPUT)?)\n+                Some(trait_.associated_type_by_name(self.db, &name::OUTPUT)?)\n             }\n             _ => None,\n         }"}, {"sha": "480bae7401e6d57272a3ad2c2d9f6c6f40e81efa", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -132,14 +132,16 @@ impl Ty {\n             if let Some(remaining_index) = remaining_index {\n                 if remaining_index == path.segments.len() - 1 {\n                     let segment = &path.segments[remaining_index];\n-                    let associated_ty =\n-                        match trait_ref.trait_.associated_type_by_name(db, segment.name.clone()) {\n-                            Some(t) => t,\n-                            None => {\n-                                // associated type not found\n-                                return Ty::Unknown;\n-                            }\n-                        };\n+                    let associated_ty = match trait_ref\n+                        .trait_\n+                        .associated_type_by_name_including_super_traits(db, &segment.name)\n+                    {\n+                        Some(t) => t,\n+                        None => {\n+                            // associated type not found\n+                            return Ty::Unknown;\n+                        }\n+                    };\n                     // FIXME handle type parameters on the segment\n                     Ty::Projection(ProjectionTy { associated_ty, parameters: trait_ref.substs })\n                 } else {\n@@ -387,10 +389,11 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         .flat_map(|segment| segment.args_and_bindings.iter())\n         .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n         .map(move |(name, type_ref)| {\n-            let associated_ty = match trait_ref.trait_.associated_type_by_name(db, name.clone()) {\n-                None => return GenericPredicate::Error,\n-                Some(t) => t,\n-            };\n+            let associated_ty =\n+                match trait_ref.trait_.associated_type_by_name_including_super_traits(db, &name) {\n+                    None => return GenericPredicate::Error,\n+                    Some(t) => t,\n+                };\n             let projection_ty =\n                 ProjectionTy { associated_ty, parameters: trait_ref.substs.clone() };\n             let ty = Ty::from_hir(db, resolver, type_ref);"}, {"sha": "cf787bdaad4137fbe5a04e9438e48eae955bcb17", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -212,7 +212,13 @@ fn iterate_trait_method_candidates<T>(\n     // FIXME: maybe put the trait_env behind a query (need to figure out good input parameters for that)\n     let env = lower::trait_env(db, resolver);\n     // if ty is `impl Trait` or `dyn Trait`, the trait doesn't need to be in scope\n-    let traits = ty.value.inherent_trait().into_iter().chain(resolver.traits_in_scope(db));\n+    let inherent_trait = ty.value.inherent_trait().into_iter();\n+    // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n+    let traits_from_env = env\n+        .trait_predicates_for_self_ty(&ty.value)\n+        .map(|tr| tr.trait_)\n+        .flat_map(|t| t.all_super_traits(db));\n+    let traits = inherent_trait.chain(traits_from_env).chain(resolver.traits_in_scope(db));\n     'traits: for t in traits {\n         let data = t.trait_data(db);\n "}, {"sha": "c4bddde85d00de59351bd24bd85ea35ae1dd8004", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -3643,6 +3643,231 @@ fn test<T: Trait1<Type = u32>>(x: T) {\n     \"###\n     );\n }\n+\n+#[test]\n+fn where_clause_trait_in_scope_for_method_resolution() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+mod foo {\n+    trait Trait {\n+        fn foo(&self) -> u32 {}\n+    }\n+}\n+\n+fn test<T: foo::Trait>(x: T) {\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn super_trait_method_resolution() {\n+    assert_snapshot!(\n+        infer(r#\"\n+mod foo {\n+    trait SuperTrait {\n+        fn foo(&self) -> u32 {}\n+    }\n+}\n+trait Trait1: foo::SuperTrait {}\n+trait Trait2 where Self: foo::SuperTrait {}\n+\n+fn test<T: Trait1, U: Trait2>(x: T, y: U) {\n+    x.foo();\n+    y.foo();\n+}\n+\"#),\n+        @r###\"\n+    [50; 54) 'self': &Self\n+    [63; 65) '{}': ()\n+    [182; 183) 'x': T\n+    [188; 189) 'y': U\n+    [194; 223) '{     ...o(); }': ()\n+    [200; 201) 'x': T\n+    [200; 207) 'x.foo()': u32\n+    [213; 214) 'y': U\n+    [213; 220) 'y.foo()': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn super_trait_cycle() {\n+    // This just needs to not crash\n+    assert_snapshot!(\n+        infer(r#\"\n+trait A: B {}\n+trait B: A {}\n+\n+fn test<T: A>(x: T) {\n+    x.foo();\n+}\n+\"#),\n+        @r###\"\n+    [44; 45) 'x': T\n+    [50; 66) '{     ...o(); }': ()\n+    [56; 57) 'x': T\n+    [56; 63) 'x.foo()': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn super_trait_assoc_type_bounds() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait SuperTrait { type Type; }\n+trait Trait where Self: SuperTrait {}\n+\n+fn get2<U, T: Trait<Type = U>>(t: T) -> U {}\n+fn set<T: Trait<Type = u64>>(t: T) -> T {t}\n+\n+struct S<T>;\n+impl<T> SuperTrait for S<T> { type Type = T; }\n+impl<T> Trait for S<T> {}\n+\n+fn test() {\n+    get2(set(S));\n+}\n+\"#),\n+        @r###\"\n+    [103; 104) 't': T\n+    [114; 116) '{}': ()\n+    [146; 147) 't': T\n+    [157; 160) '{t}': T\n+    [158; 159) 't': T\n+    [259; 280) '{     ...S)); }': ()\n+    [265; 269) 'get2': fn get2<u64, S<u64>>(T) -> U\n+    [265; 277) 'get2(set(S))': u64\n+    [270; 273) 'set': fn set<S<u64>>(T) -> T\n+    [270; 276) 'set(S)': S<u64>\n+    [274; 275) 'S': S<u64>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn fn_trait() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait FnOnce<Args> {\n+    type Output;\n+\n+    fn call_once(self, args: Args) -> <Self as FnOnce<Args>>::Output;\n+}\n+\n+fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n+    f.call_once((1, 2));\n+}\n+\"#),\n+        @r###\"\n+    [57; 61) 'self': Self\n+    [63; 67) 'args': Args\n+    [150; 151) 'f': F\n+    [156; 184) '{     ...2)); }': ()\n+    [162; 163) 'f': F\n+    [162; 181) 'f.call...1, 2))': {unknown}\n+    [174; 180) '(1, 2)': (u32, u64)\n+    [175; 176) '1': u32\n+    [178; 179) '2': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_1() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+enum Option<T> { Some(T), None }\n+impl<T> Option<T> {\n+    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> U {}\n+}\n+\n+fn test() {\n+    let x = Option::Some(1i32);\n+    x.map(|v| v + 1);\n+    x.map(|_v| 1u64);\n+    let y: Option<i64> = x.map(|_v| 1);\n+}\n+\"#),\n+        @r###\"\n+    [128; 132) 'self': Option<T>\n+    [134; 135) 'f': F\n+    [145; 147) '{}': ()\n+    [161; 280) '{     ... 1); }': ()\n+    [171; 172) 'x': Option<i32>\n+    [175; 187) 'Option::Some': Some<i32>(T) -> Option<T>\n+    [175; 193) 'Option...(1i32)': Option<i32>\n+    [188; 192) '1i32': i32\n+    [199; 200) 'x': Option<i32>\n+    [199; 215) 'x.map(...v + 1)': {unknown}\n+    [205; 214) '|v| v + 1': {unknown}\n+    [206; 207) 'v': {unknown}\n+    [209; 210) 'v': {unknown}\n+    [209; 214) 'v + 1': i32\n+    [213; 214) '1': i32\n+    [221; 222) 'x': Option<i32>\n+    [221; 237) 'x.map(... 1u64)': {unknown}\n+    [227; 236) '|_v| 1u64': {unknown}\n+    [228; 230) '_v': {unknown}\n+    [232; 236) '1u64': u64\n+    [247; 248) 'y': Option<i64>\n+    [264; 265) 'x': Option<i32>\n+    [264; 277) 'x.map(|_v| 1)': Option<i64>\n+    [270; 276) '|_v| 1': {unknown}\n+    [271; 273) '_v': {unknown}\n+    [275; 276) '1': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn closure_2() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+fn test<F: FnOnce(u32) -> u64>(f: F) {\n+    f(1);\n+    let g = |v| v + 1;\n+    g(1u64);\n+    let h = |v| 1u128 + v;\n+}\n+\"#),\n+        @r###\"\n+    [73; 74) 'f': F\n+    [79; 155) '{     ...+ v; }': ()\n+    [85; 86) 'f': F\n+    [85; 89) 'f(1)': {unknown}\n+    [87; 88) '1': i32\n+    [99; 100) 'g': {unknown}\n+    [103; 112) '|v| v + 1': {unknown}\n+    [104; 105) 'v': {unknown}\n+    [107; 108) 'v': {unknown}\n+    [107; 112) 'v + 1': i32\n+    [111; 112) '1': i32\n+    [118; 119) 'g': {unknown}\n+    [118; 125) 'g(1u64)': {unknown}\n+    [120; 124) '1u64': u64\n+    [135; 136) 'h': {unknown}\n+    [139; 152) '|v| 1u128 + v': {unknown}\n+    [140; 141) 'v': u128\n+    [143; 148) '1u128': u128\n+    [143; 152) '1u128 + v': u128\n+    [151; 152) 'v': u128\n+    \"###\n+    );\n+}\n+\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}, {"sha": "c0c132809b59a9eab609b262442620a8e242713e", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -96,6 +96,21 @@ pub struct TraitEnvironment {\n     pub predicates: Vec<GenericPredicate>,\n }\n \n+impl TraitEnvironment {\n+    /// Returns trait refs with the given self type which are supposed to hold\n+    /// in this trait env. E.g. if we are in `foo<T: SomeTrait>()`, this will\n+    /// find that `T: SomeTrait` if we call it for `T`.\n+    pub(crate) fn trait_predicates_for_self_ty<'a>(\n+        &'a self,\n+        ty: &'a Ty,\n+    ) -> impl Iterator<Item = &'a TraitRef> + 'a {\n+        self.predicates.iter().filter_map(move |pred| match pred {\n+            GenericPredicate::Implemented(tr) if tr.self_ty() == ty => Some(tr),\n+            _ => None,\n+        })\n+    }\n+}\n+\n /// Something (usually a goal), along with an environment.\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct InEnvironment<T> {"}, {"sha": "8a127efa196f81f9ed0d02ef74c4a73453467fd5", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -314,7 +314,8 @@ impl ToChalk for Arc<super::TraitEnvironment> {\n                 // for env, we just ignore errors\n                 continue;\n             }\n-            clauses.push(pred.clone().to_chalk(db).cast());\n+            let program_clause: chalk_ir::ProgramClause = pred.clone().to_chalk(db).cast();\n+            clauses.push(program_clause.into_from_env_clause());\n         }\n         chalk_ir::Environment::new().add_clauses(clauses)\n     }\n@@ -636,7 +637,7 @@ pub(crate) fn impl_datum_query(\n             _ => None,\n         })\n         .filter_map(|t| {\n-            let assoc_ty = trait_.associated_type_by_name(db, t.name(db))?;\n+            let assoc_ty = trait_.associated_type_by_name(db, &t.name(db))?;\n             let ty = db.type_for_def(t.into(), crate::Namespace::Types).subst(&bound_vars);\n             Some(chalk_rust_ir::AssociatedTyValue {\n                 impl_id,"}, {"sha": "bc8acc7eede3e600ede249c9fd3d02c2bb78621f", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -150,4 +150,11 @@ impl TypeBound {\n             ast::TypeBoundKind::ForType(_) | ast::TypeBoundKind::Lifetime(_) => TypeBound::Error,\n         }\n     }\n+\n+    pub fn as_path(&self) -> Option<&Path> {\n+        match self {\n+            TypeBound::Path(p) => Some(p),\n+            _ => None,\n+        }\n+    }\n }"}, {"sha": "d274b6fbc0f0f41a9a1aa9a3f4ab7f3a23fbdc71", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -2312,6 +2312,12 @@ impl PathSegment {\n     pub fn type_arg_list(&self) -> Option<TypeArgList> {\n         AstChildren::new(&self.syntax).next()\n     }\n+    pub fn param_list(&self) -> Option<ParamList> {\n+        AstChildren::new(&self.syntax).next()\n+    }\n+    pub fn ret_type(&self) -> Option<RetType> {\n+        AstChildren::new(&self.syntax).next()\n+    }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathType {"}, {"sha": "993e58e645a12ef5f2bd94934e312d0ba5fcfe8f", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/4a89a7c9026dc3df4466f7b10c666186830d38f6/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=4a89a7c9026dc3df4466f7b10c666186830d38f6", "patch": "@@ -684,7 +684,7 @@ Grammar(\n             ]\n         ),\n         \"PathSegment\": (\n-            options: [ \"NameRef\", \"TypeArgList\" ]\n+            options: [ \"NameRef\", \"TypeArgList\", \"ParamList\", \"RetType\" ]\n         ),\n         \"TypeArgList\": (collections: [\n             (\"type_args\", \"TypeArg\"),"}]}