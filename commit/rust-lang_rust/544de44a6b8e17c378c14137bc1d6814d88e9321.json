{"sha": "544de44a6b8e17c378c14137bc1d6814d88e9321", "node_id": "C_kwDOAAsO6NoAKDU0NGRlNDRhNmI4ZTE3YzM3OGMxNDEzN2JjMWQ2ODE0ZDg4ZTkzMjE", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-28T08:44:49Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-07-28T08:44:49Z"}, "message": "Don't pass (the rather large) `PatCtxt` by value", "tree": {"sha": "698ae894af79dced39be8b8aab2e4d6ba740a5bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/698ae894af79dced39be8b8aab2e4d6ba740a5bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/544de44a6b8e17c378c14137bc1d6814d88e9321", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/544de44a6b8e17c378c14137bc1d6814d88e9321", "html_url": "https://github.com/rust-lang/rust/commit/544de44a6b8e17c378c14137bc1d6814d88e9321", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/544de44a6b8e17c378c14137bc1d6814d88e9321/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "970ff3d45d250a7e58792e7da6ef1cf305f49c29", "url": "https://api.github.com/repos/rust-lang/rust/commits/970ff3d45d250a7e58792e7da6ef1cf305f49c29", "html_url": "https://github.com/rust-lang/rust/commit/970ff3d45d250a7e58792e7da6ef1cf305f49c29"}], "stats": {"total": 34, "additions": 17, "deletions": 17}, "files": [{"sha": "83c1179baecfe8dbf966d352b24160130f2bfdbb", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/544de44a6b8e17c378c14137bc1d6814d88e9321/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/544de44a6b8e17c378c14137bc1d6814d88e9321/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=544de44a6b8e17c378c14137bc1d6814d88e9321", "patch": "@@ -261,7 +261,7 @@ impl IntRange {\n     /// Lint on likely incorrect range patterns (#63987)\n     pub(super) fn lint_overlapping_range_endpoints<'a, 'p: 'a, 'tcx: 'a>(\n         &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        pcx: &PatCtxt<'_, 'p, 'tcx>,\n         pats: impl Iterator<Item = &'a DeconstructedPat<'p, 'tcx>>,\n         column_count: usize,\n         hir_id: HirId,\n@@ -696,7 +696,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// `EvalResult::Deny { .. }`.\n     ///\n     /// This means that the variant has a stdlib unstable feature marking it.\n-    pub(super) fn is_unstable_variant(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> bool {\n+    pub(super) fn is_unstable_variant(&self, pcx: &PatCtxt<'_, '_, 'tcx>) -> bool {\n         if let Constructor::Variant(idx) = self && let ty::Adt(adt, _) = pcx.ty.kind() {\n             let variant_def_id = adt.variant(*idx).def_id;\n             // Filter variants that depend on a disabled unstable feature.\n@@ -710,7 +710,7 @@ impl<'tcx> Constructor<'tcx> {\n \n     /// Checks if the `Constructor` is a `Constructor::Variant` with a `#[doc(hidden)]`\n     /// attribute from a type not local to the current crate.\n-    pub(super) fn is_doc_hidden_variant(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> bool {\n+    pub(super) fn is_doc_hidden_variant(&self, pcx: &PatCtxt<'_, '_, 'tcx>) -> bool {\n         if let Constructor::Variant(idx) = self && let ty::Adt(adt, _) = pcx.ty.kind() {\n             let variant_def_id = adt.variants()[*idx].def_id;\n             return pcx.cx.tcx.is_doc_hidden(variant_def_id) && !variant_def_id.is_local();\n@@ -731,7 +731,7 @@ impl<'tcx> Constructor<'tcx> {\n \n     /// The number of fields for this constructor. This must be kept in sync with\n     /// `Fields::wildcards`.\n-    pub(super) fn arity(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> usize {\n+    pub(super) fn arity(&self, pcx: &PatCtxt<'_, '_, 'tcx>) -> usize {\n         match self {\n             Single | Variant(_) => match pcx.ty.kind() {\n                 ty::Tuple(fs) => fs.len(),\n@@ -775,7 +775,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// matrix, unless all of them are.\n     pub(super) fn split<'a>(\n         &self,\n-        pcx: PatCtxt<'_, '_, 'tcx>,\n+        pcx: &PatCtxt<'_, '_, 'tcx>,\n         ctors: impl Iterator<Item = &'a Constructor<'tcx>> + Clone,\n     ) -> SmallVec<[Self; 1]>\n     where\n@@ -811,7 +811,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// this checks for inclusion.\n     // We inline because this has a single call site in `Matrix::specialize_constructor`.\n     #[inline]\n-    pub(super) fn is_covered_by<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>, other: &Self) -> bool {\n+    pub(super) fn is_covered_by<'p>(&self, pcx: &PatCtxt<'_, 'p, 'tcx>, other: &Self) -> bool {\n         // This must be kept in sync with `is_covered_by_any`.\n         match (self, other) {\n             // Wildcards cover anything\n@@ -865,7 +865,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// assumed to have been split from a wildcard.\n     fn is_covered_by_any<'p>(\n         &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        pcx: &PatCtxt<'_, 'p, 'tcx>,\n         used_ctors: &[Constructor<'tcx>],\n     ) -> bool {\n         if used_ctors.is_empty() {\n@@ -918,7 +918,7 @@ pub(super) struct SplitWildcard<'tcx> {\n }\n \n impl<'tcx> SplitWildcard<'tcx> {\n-    pub(super) fn new<'p>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Self {\n+    pub(super) fn new<'p>(pcx: &PatCtxt<'_, 'p, 'tcx>) -> Self {\n         debug!(\"SplitWildcard::new({:?})\", pcx.ty);\n         let cx = pcx.cx;\n         let make_range = |start, end| {\n@@ -1044,7 +1044,7 @@ impl<'tcx> SplitWildcard<'tcx> {\n     /// do what you want.\n     pub(super) fn split<'a>(\n         &mut self,\n-        pcx: PatCtxt<'_, '_, 'tcx>,\n+        pcx: &PatCtxt<'_, '_, 'tcx>,\n         ctors: impl Iterator<Item = &'a Constructor<'tcx>> + Clone,\n     ) where\n         'tcx: 'a,\n@@ -1056,21 +1056,21 @@ impl<'tcx> SplitWildcard<'tcx> {\n     }\n \n     /// Whether there are any value constructors for this type that are not present in the matrix.\n-    fn any_missing(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> bool {\n+    fn any_missing(&self, pcx: &PatCtxt<'_, '_, 'tcx>) -> bool {\n         self.iter_missing(pcx).next().is_some()\n     }\n \n     /// Iterate over the constructors for this type that are not present in the matrix.\n     pub(super) fn iter_missing<'a, 'p>(\n         &'a self,\n-        pcx: PatCtxt<'a, 'p, 'tcx>,\n+        pcx: &'a PatCtxt<'a, 'p, 'tcx>,\n     ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> {\n         self.all_ctors.iter().filter(move |ctor| !ctor.is_covered_by_any(pcx, &self.matrix_ctors))\n     }\n \n     /// Return the set of constructors resulting from splitting the wildcard. As explained at the\n     /// top of the file, if any constructors are missing we can ignore the present ones.\n-    fn into_ctors(self, pcx: PatCtxt<'_, '_, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n+    fn into_ctors(self, pcx: &PatCtxt<'_, '_, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n         if self.any_missing(pcx) {\n             // Some constructors are missing, thus we can specialize with the special `Missing`\n             // constructor, which stands for those constructors that are not seen in the matrix,\n@@ -1285,7 +1285,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// Construct a pattern that matches everything that starts with this constructor.\n     /// For example, if `ctor` is a `Constructor::Variant` for `Option::Some`, we get the pattern\n     /// `Some(_)`.\n-    pub(super) fn wild_from_ctor(pcx: PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n+    pub(super) fn wild_from_ctor(pcx: &PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n         let fields = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n         DeconstructedPat::new(ctor, fields, pcx.ty, DUMMY_SP)\n     }"}, {"sha": "66b16b50ad084e9c52c6a41f10c59f064f940bf2", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/544de44a6b8e17c378c14137bc1d6814d88e9321/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/544de44a6b8e17c378c14137bc1d6814d88e9321/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=544de44a6b8e17c378c14137bc1d6814d88e9321", "patch": "@@ -469,7 +469,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     fn specialize_constructor(\n         &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        pcx: &PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n     ) -> Matrix<'p, 'tcx> {\n         let mut matrix = Matrix::empty();\n@@ -575,7 +575,7 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n     /// with the results of specializing with the other constructors.\n     fn apply_constructor(\n         self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        pcx: &PatCtxt<'_, 'p, 'tcx>,\n         matrix: &Matrix<'p, 'tcx>, // used to compute missing ctors\n         ctor: &Constructor<'tcx>,\n     ) -> Self {\n@@ -713,7 +713,7 @@ impl<'p, 'tcx> Witness<'p, 'tcx> {\n     ///\n     /// left_ty: struct X { a: (bool, &'static str), b: usize}\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-    fn apply_constructor(mut self, pcx: PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Self {\n+    fn apply_constructor(mut self, pcx: &PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Self {\n         let pat = {\n             let len = self.0.len();\n             let arity = ctor.arity(pcx);\n@@ -830,7 +830,7 @@ fn is_useful<'p, 'tcx>(\n         let ty = v.head().ty();\n         let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n         debug!(\"v.head: {:?}, v.span: {:?}\", v.head(), v.head().span());\n-        let pcx = PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n+        let pcx = &PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n \n         let v_ctor = v.head().ctor();\n         debug!(?v_ctor);"}]}