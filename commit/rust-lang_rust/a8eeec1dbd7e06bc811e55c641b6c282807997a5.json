{"sha": "a8eeec1dbd7e06bc811e55c641b6c282807997a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZWVlYzFkYmQ3ZTA2YmM4MTFlNTVjNjQxYjZjMjgyODA3OTk3YTU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-11T02:18:16Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-11T02:18:16Z"}, "message": "Sketch support for reading multi-file crates in rustc. Add test, not yet working.", "tree": {"sha": "4838ff018e3835ec1203897cd6a1c602d52fbcbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4838ff018e3835ec1203897cd6a1c602d52fbcbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8eeec1dbd7e06bc811e55c641b6c282807997a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8eeec1dbd7e06bc811e55c641b6c282807997a5", "html_url": "https://github.com/rust-lang/rust/commit/a8eeec1dbd7e06bc811e55c641b6c282807997a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8eeec1dbd7e06bc811e55c641b6c282807997a5/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11cbbcf79e0de904eb7f176db7f7587b40637ec8", "url": "https://api.github.com/repos/rust-lang/rust/commits/11cbbcf79e0de904eb7f176db7f7587b40637ec8", "html_url": "https://github.com/rust-lang/rust/commit/11cbbcf79e0de904eb7f176db7f7587b40637ec8"}], "stats": {"total": 183, "additions": 151, "deletions": 32}, "files": [{"sha": "1b29c285c19b9a5f8222beb99f0f1a003ea39201", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 138, "deletions": 32, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/a8eeec1dbd7e06bc811e55c641b6c282807997a5/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8eeec1dbd7e06bc811e55c641b6c282807997a5/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=a8eeec1dbd7e06bc811e55c641b6c282807997a5", "patch": "@@ -1,5 +1,6 @@\n import std._io;\n import std._vec;\n+import std._str;\n import std.option;\n import std.option.some;\n import std.option.none;\n@@ -114,6 +115,18 @@ impure fn parse_ident(parser p) -> ast.ident {\n     }\n }\n \n+\n+impure fn parse_str_lit(parser p) -> ast.ident {\n+    alt (p.peek()) {\n+        case (token.LIT_STR(?s)) { p.bump(); ret s; }\n+        case (_) {\n+            p.err(\"expecting string literal\");\n+            fail;\n+        }\n+    }\n+}\n+\n+\n impure fn parse_ty_fn(parser p, ast.span lo) -> ast.ty_ {\n     impure fn parse_fn_input_ty(parser p) -> rec(ast.mode mode, @ast.ty ty) {\n         auto mode;\n@@ -1405,6 +1418,34 @@ impure fn parse_item_obj(parser p, ast.layer lyr) -> @ast.item {\n     ret @spanned(lo, meths.span, item);\n }\n \n+fn index_mod_item(@ast.item item, ast.mod_index index, uint u) {\n+    alt (item.node) {\n+        case (ast.item_const(?id, _, _, _, _)) {\n+            index.insert(id, ast.mie_item(u));\n+        }\n+        case (ast.item_fn(?id, _, _, _, _)) {\n+            index.insert(id, ast.mie_item(u));\n+        }\n+        case (ast.item_mod(?id, _, _)) {\n+            index.insert(id, ast.mie_item(u));\n+        }\n+        case (ast.item_ty(?id, _, _, _, _)) {\n+            index.insert(id, ast.mie_item(u));\n+        }\n+        case (ast.item_tag(?id, ?variants, _, _)) {\n+            index.insert(id, ast.mie_item(u));\n+            let uint variant_idx = 0u;\n+            for (ast.variant v in variants) {\n+                index.insert(v.name, ast.mie_tag_variant(u, variant_idx));\n+                variant_idx += 1u;\n+            }\n+        }\n+        case (ast.item_obj(?id, _, _, _, _)) {\n+            index.insert(id, ast.mie_item(u));\n+        }\n+    }\n+}\n+\n impure fn parse_mod_items(parser p, token.token term) -> ast._mod {\n     auto index = new_str_hash[ast.mod_index_entry]();\n     auto view_items = parse_view(p, index);\n@@ -1413,38 +1454,11 @@ impure fn parse_mod_items(parser p, token.token term) -> ast._mod {\n     while (p.peek() != term) {\n         auto item = parse_item(p);\n         items += vec(item);\n-\n-        // Index the item.\n-        alt (item.node) {\n-            case (ast.item_const(?id, _, _, _, _)) {\n-                index.insert(id, ast.mie_item(u));\n-            }\n-            case (ast.item_fn(?id, _, _, _, _)) {\n-                index.insert(id, ast.mie_item(u));\n-            }\n-            case (ast.item_mod(?id, _, _)) {\n-                index.insert(id, ast.mie_item(u));\n-            }\n-            case (ast.item_ty(?id, _, _, _, _)) {\n-                index.insert(id, ast.mie_item(u));\n-            }\n-            case (ast.item_tag(?id, ?variants, _, _)) {\n-                index.insert(id, ast.mie_item(u));\n-                let uint variant_idx = 0u;\n-                for (ast.variant v in variants) {\n-                    index.insert(v.name, ast.mie_tag_variant(u, variant_idx));\n-                    variant_idx += 1u;\n-                }\n-            }\n-            case (ast.item_obj(?id, _, _, _, _)) {\n-                index.insert(id, ast.mie_item(u));\n-            }\n-        }\n-\n+        index_mod_item(item, index, u);\n         u += 1u;\n     }\n     ret rec(view_items=view_items, items=items, index=index);\n- }\n+}\n \n impure fn parse_item_const(parser p) -> @ast.item {\n     auto lo = p.get_span();\n@@ -1765,20 +1779,112 @@ impure fn parse_view(parser p, ast.mod_index index) -> vec[@ast.view_item] {\n     ret items;\n }\n \n-impure fn parse_crate_from_crate_file(parser p) -> @ast.crate {\n+impure fn parse_crate_from_source_file(parser p) -> @ast.crate {\n     auto lo = p.get_span();\n     auto hi = lo;\n     auto m = parse_mod_items(p, token.EOF);\n     ret @spanned(lo, hi, rec(module=m));\n }\n \n-impure fn parse_crate_from_source_file(parser p) -> @ast.crate {\n+// Logic for parsing crate files (.rc)\n+//\n+// Each crate file is a sequence of directives.\n+//\n+// Each directive imperatively extends its environment with 0 or more items.\n+\n+impure fn parse_crate_directive(str prefix, parser p,\n+                                &mutable vec[@ast.item] items,\n+                                hashmap[ast.ident,ast.mod_index_entry] index)\n+{\n     auto lo = p.get_span();\n     auto hi = lo;\n-    auto m = parse_mod_items(p, token.EOF);\n+    alt (p.peek()) {\n+        case (token.CONST) {\n+            auto c = parse_item_const(p);\n+            index_mod_item(c, index, _vec.len[@ast.item](items));\n+            append[@ast.item](items, c);\n+         }\n+        case (token.MOD) {\n+            p.bump();\n+            auto id = parse_ident(p);\n+            auto file_path = id;\n+            alt (p.peek()) {\n+                case (token.EQ) {\n+                    p.bump();\n+                    // FIXME: turn this into parse+eval expr\n+                    file_path = parse_str_lit(p);\n+                }\n+                case (_) {}\n+            }\n+\n+            // dir-qualify file path.\n+            auto full_path = prefix + std.os.path_sep() + file_path;\n+\n+            alt (p.peek()) {\n+\n+                // mod x = \"foo.rs\";\n+\n+                case (token.SEMI) {\n+                    hi = p.get_span();\n+                    p.bump();\n+                    if (!_str.ends_with(full_path, \".rs\")) {\n+                        full_path += \".rs\";\n+                    }\n+                    auto p0 = new_parser(p.get_session(), 0, full_path);\n+                    auto m0 = parse_mod_items(p0, token.EOF);\n+                    auto im = ast.item_mod(id, m0, p.next_def_id());\n+                    auto i = @spanned(lo, hi, im);\n+                    index_mod_item(i, index, _vec.len[@ast.item](items));\n+                    append[@ast.item](items, i);\n+                }\n+\n+                // mod x = \"foo_dir\" { ...directives... }\n+\n+                case (token.LBRACE) {\n+                    p.bump();\n+                    auto m0 = parse_crate_directives(full_path, p,\n+                                                     token.RBRACE);\n+                    hi = p.get_span();\n+                    expect(p, token.RBRACE);\n+                    auto im = ast.item_mod(id, m0, p.next_def_id());\n+                    auto i = @spanned(lo, hi, im);\n+                    index_mod_item(i, index, _vec.len[@ast.item](items));\n+                    append[@ast.item](items, i);\n+                }\n+\n+                case (?t) {\n+                    unexpected(p, t);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impure fn parse_crate_directives(str prefix, parser p,\n+                                 token.token term) -> ast._mod {\n+    auto index = new_str_hash[ast.mod_index_entry]();\n+    auto view_items = parse_view(p, index);\n+\n+    let vec[@ast.item] items = vec();\n+\n+    while (p.peek() != term) {\n+        parse_crate_directive(prefix, p, items, index);\n+    }\n+\n+    ret rec(view_items=view_items, items=items, index=index);\n+}\n+\n+impure fn parse_crate_from_crate_file(parser p) -> @ast.crate {\n+    auto lo = p.get_span();\n+    auto hi = lo;\n+    auto prefix = std.path.dirname(lo.filename);\n+    auto m = parse_crate_directives(prefix, p, token.EOF);\n+    hi = p.get_span();\n+    expect(p, token.EOF);\n     ret @spanned(lo, hi, rec(module=m));\n }\n \n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "598fbf3c73327c6f612e2be3c06b86b0cc966b1e", "filename": "src/test/run-pass/multi-src/bar.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8eeec1dbd7e06bc811e55c641b6c282807997a5/src%2Ftest%2Frun-pass%2Fmulti-src%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8eeec1dbd7e06bc811e55c641b6c282807997a5/src%2Ftest%2Frun-pass%2Fmulti-src%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti-src%2Fbar.rs?ref=a8eeec1dbd7e06bc811e55c641b6c282807997a5", "patch": "@@ -0,0 +1,3 @@\n+fn other() {\n+  log \"yes\";\n+}\n\\ No newline at end of file"}, {"sha": "c166958e28fbf8c01dd0e4c6713ed1ab36ca4640", "filename": "src/test/run-pass/multi-src/foo.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8eeec1dbd7e06bc811e55c641b6c282807997a5/src%2Ftest%2Frun-pass%2Fmulti-src%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8eeec1dbd7e06bc811e55c641b6c282807997a5/src%2Ftest%2Frun-pass%2Fmulti-src%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti-src%2Ffoo.rs?ref=a8eeec1dbd7e06bc811e55c641b6c282807997a5", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+  log \"hello, multi-file world.\";\n+  bar.other();\n+}\n\\ No newline at end of file"}, {"sha": "90f03ee99db6bc41ef22c51a3e489ed12cf13f9a", "filename": "src/test/run-pass/multi.rc", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8eeec1dbd7e06bc811e55c641b6c282807997a5/src%2Ftest%2Frun-pass%2Fmulti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a8eeec1dbd7e06bc811e55c641b6c282807997a5/src%2Ftest%2Frun-pass%2Fmulti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti.rc?ref=a8eeec1dbd7e06bc811e55c641b6c282807997a5", "patch": "@@ -0,0 +1,6 @@\n+mod multi = \"multi-src\" {\n+\n+  mod foo; // implicitly = \"foo.rs\"\n+\n+  mod bar = \"bar.rs\";\n+}"}]}