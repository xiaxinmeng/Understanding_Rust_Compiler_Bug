{"sha": "0bb11f43f65e971ee06e649fa496f762d3ad2b27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYjExZjQzZjY1ZTk3MWVlMDZlNjQ5ZmE0OTZmNzYyZDNhZDJiMjc=", "commit": {"author": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-08-12T20:44:40Z"}, "committer": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-08-12T21:11:19Z"}, "message": "Rewrite test from previous commit but without using macros.", "tree": {"sha": "05f34311b6538e2e51ac7b3f822d4ef8902cdb7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05f34311b6538e2e51ac7b3f822d4ef8902cdb7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bb11f43f65e971ee06e649fa496f762d3ad2b27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb11f43f65e971ee06e649fa496f762d3ad2b27", "html_url": "https://github.com/rust-lang/rust/commit/0bb11f43f65e971ee06e649fa496f762d3ad2b27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bb11f43f65e971ee06e649fa496f762d3ad2b27/comments", "author": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31e49f02723fe4631740fce4ef387aad31563bef", "url": "https://api.github.com/repos/rust-lang/rust/commits/31e49f02723fe4631740fce4ef387aad31563bef", "html_url": "https://github.com/rust-lang/rust/commit/31e49f02723fe4631740fce4ef387aad31563bef"}], "stats": {"total": 119, "additions": 55, "deletions": 64}, "files": [{"sha": "4211cd42b02e20f03953bf5afbb892bba0545031", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 55, "deletions": 64, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/0bb11f43f65e971ee06e649fa496f762d3ad2b27/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bb11f43f65e971ee06e649fa496f762d3ad2b27/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=0bb11f43f65e971ee06e649fa496f762d3ad2b27", "patch": "@@ -1,6 +1,7 @@\n use std::cell::Cell;\n use std::cmp::Ordering::{self, Equal, Greater, Less};\n use std::convert::identity;\n+use std::fmt;\n use std::mem;\n use std::panic;\n use std::rc::Rc;\n@@ -995,75 +996,65 @@ fn test_rsplitnator() {\n \n #[test]\n fn test_split_iterators_size_hint() {\n-    for len in 0..=2 {\n-        let mut v: Vec<u8> = (0..len).collect();\n-        fn verify_descending(sequence: &[usize], context: &str) {\n-            let len = sequence.len();\n-            let target: Vec<usize> = (0..len).rev().collect();\n-            assert_eq!(sequence, target, \"while testing: {}\", context);\n-        }\n-\n-        macro_rules! test_size_hint {\n-            ($create_iterator:expr) => {{\n-                // with a predicate always returning false, the split*-iterators\n-                // become maximally short, so the size_hint lower bounds are correct\n-\n-                macro_rules! p {\n-                    () => {\n-                        |_| false\n-                    };\n-                }\n-                let mut short_iterator = $create_iterator;\n-                let mut lower_bounds = vec![short_iterator.size_hint().0];\n-                while let Some(_) = short_iterator.next() {\n-                    lower_bounds.push(short_iterator.size_hint().0);\n+    #[derive(Copy, Clone)]\n+    enum Bounds {\n+        Lower,\n+        Upper,\n+    }\n+    fn assert_precise_size_hints<I: Iterator>(\n+        mut it: I,\n+        which: Bounds,\n+        context: impl fmt::Display,\n+    ) {\n+        match which {\n+            Bounds::Lower => {\n+                let mut lower_bounds = vec![it.size_hint().0];\n+                while let Some(_) = it.next() {\n+                    lower_bounds.push(it.size_hint().0);\n                 }\n-                verify_descending(&lower_bounds, stringify!($create_iterator));\n+                let target: Vec<_> = (0..lower_bounds.len()).rev().collect();\n+                assert_eq!(lower_bounds, target, \"incorrect lower bounds: {}\", context);\n             }\n-            {\n-                // with a predicate always returning true, the split*-iterators\n-                // become maximally long, so the size_hint upper bounds are correct\n-\n-                macro_rules! p {\n-                    () => {\n-                        |_| true\n-                    };\n-                }\n-                let mut long_iterator = $create_iterator;\n-                let mut upper_bounds = vec![\n-                    long_iterator.size_hint().1.expect(\"split*-methods have known upper bound\"),\n-                ];\n-                while let Some(_) = long_iterator.next() {\n-                    upper_bounds.push(\n-                        long_iterator.size_hint().1.expect(\"split*-methods have known upper bound\"),\n-                    );\n+            Bounds::Upper => {\n+                let mut upper_bounds = vec![it.size_hint().1];\n+                while let Some(_) = it.next() {\n+                    upper_bounds.push(it.size_hint().1);\n                 }\n-                verify_descending(&upper_bounds, stringify!($create_iterator));\n-            }};\n+                let target: Vec<_> = (0..upper_bounds.len()).map(Some).rev().collect();\n+                assert_eq!(upper_bounds, target, \"incorrect upper bounds: {}\", context);\n+            }\n         }\n+    }\n \n-        test_size_hint!(v.split(p!()));\n-        test_size_hint!(v.split_mut(p!()));\n-        test_size_hint!(v.splitn(0, p!()));\n-        test_size_hint!(v.splitn(1, p!()));\n-        test_size_hint!(v.splitn(2, p!()));\n-        test_size_hint!(v.splitn(3, p!()));\n-        test_size_hint!(v.splitn_mut(0, p!()));\n-        test_size_hint!(v.splitn_mut(1, p!()));\n-        test_size_hint!(v.splitn_mut(2, p!()));\n-        test_size_hint!(v.splitn_mut(3, p!()));\n-        test_size_hint!(v.split_inclusive(p!()));\n-        test_size_hint!(v.split_inclusive_mut(p!()));\n-        test_size_hint!(v.rsplit(p!()));\n-        test_size_hint!(v.rsplit_mut(p!()));\n-        test_size_hint!(v.rsplitn(0, p!()));\n-        test_size_hint!(v.rsplitn(1, p!()));\n-        test_size_hint!(v.rsplitn(2, p!()));\n-        test_size_hint!(v.rsplitn(3, p!()));\n-        test_size_hint!(v.rsplitn_mut(0, p!()));\n-        test_size_hint!(v.rsplitn_mut(1, p!()));\n-        test_size_hint!(v.rsplitn_mut(2, p!()));\n-        test_size_hint!(v.rsplitn_mut(3, p!()));\n+    for len in 0..=2 {\n+        let mut v: Vec<u8> = (0..len).collect();\n+\n+        // p: predicate, b: bound selection\n+        for (p, b) in [\n+            // with a predicate always returning false, the split*-iterators\n+            // become maximally short, so the size_hint lower bounds are correct\n+            ((|_| false) as fn(&_) -> _, Bounds::Lower),\n+            // with a predicate always returning true, the split*-iterators\n+            // become maximally long, so the size_hint upper bounds are correct\n+            ((|_| true) as fn(&_) -> _, Bounds::Upper),\n+        ] {\n+            use assert_precise_size_hints as a;\n+            use format_args as f;\n+\n+            a(v.split(p), b, \"split\");\n+            a(v.split_mut(p), b, \"split_mut\");\n+            a(v.split_inclusive(p), b, \"split_inclusive\");\n+            a(v.split_inclusive_mut(p), b, \"split_inclusive_mut\");\n+            a(v.rsplit(p), b, \"rsplit\");\n+            a(v.rsplit_mut(p), b, \"rsplit_mut\");\n+\n+            for n in 0..=3 {\n+                a(v.splitn(n, p), b, f!(\"splitn, n = {}\", n));\n+                a(v.splitn_mut(n, p), b, f!(\"splitn_mut, n = {}\", n));\n+                a(v.rsplitn(n, p), b, f!(\"rsplitn, n = {}\", n));\n+                a(v.rsplitn_mut(n, p), b, f!(\"rsplitn_mut, n = {}\", n));\n+            }\n+        }\n     }\n }\n "}]}