{"sha": "1f90f4fb85e9924e24272f6bc12a0c561291c682", "node_id": "C_kwDOAAsO6NoAKDFmOTBmNGZiODVlOTkyNGUyNDI3MmY2YmMxMmEwYzU2MTI5MWM2ODI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-08T05:47:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-08T05:47:37Z"}, "message": "Rollup merge of #93721 - jyn514:less-macro-special-casing, r=petrochenkov\n\nrustdoc: Special-case macro lookups less\n\nPreviously, rustdoc had 3 fallbacks it used:\n1. `resolve_macro_path`\n2. `all_macros`\n3. `resolve_str_path_error`\n\nIdeally, it would only use `resolve_str_path_error`, to be consistent with other namespaces.\nUnfortunately, that doesn't consider macros that aren't defined at module scope;\nconsider for instance\n```rust\n{\n    struct S;\n\n    macro_rules! mac { () => {} }\n    // `mac`'s scope starts here\n\n    /// `mac` <- `resolve_str_path_error` won't see this\n   struct Z;\n\n    //`mac`'s scope ends here\n}\n```\n\nThis changes it to only use `all_macros` and `resolve_str_path_error`, and gives\n`resolve_str_path_error` precedence over `all_macros` in case there are two macros with the same\nname in the same module.\n\nThis is a smaller version of https://github.com/rust-lang/rust/pull/91427.\n\nr? `@petrochenkov`", "tree": {"sha": "802631ca0b5bbdf5274c9862a0e3d485dac9be72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/802631ca0b5bbdf5274c9862a0e3d485dac9be72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f90f4fb85e9924e24272f6bc12a0c561291c682", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiAgP6CRBK7hj4Ov3rIwAAaScIAIvCNY2V7eZ+zqZc9y9WqoZI\nw26lNJRfmheNW6KJB+wZZSpzdPG5bjDnFvlnJC02HGShLHExZ0kZrODkfW5Lg77K\nMug4pZtMBFMSXAqahUSPNp8f/B21+rtGxzIo8wYN+dA97n851im9Wl+e2HZOhtVr\nKK6x5vndOphFbSBpjd+ZQOmvexzyj69fdwKqj35798ZAjOy7vgdX4wrq0ROdaCay\nRDcmzix6Jo64ybJzp68YWowZzXOKPalFLvyCCOHdGhC/9L8WQi1xOkv4NT87KqMx\nZtvJvnX49nMcDCAuQpX9ONJliok0hGarwdyQY+wbYTrk5O7SZuuxvnjsRq5e4os=\n=kPH5\n-----END PGP SIGNATURE-----\n", "payload": "tree 802631ca0b5bbdf5274c9862a0e3d485dac9be72\nparent 7d5e2ac5eb78c5d3054267bbec5c31fcf8193507\nparent f026550113b62b7bbd33faf39a7048f5a34fe289\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1644299257 +0100\ncommitter GitHub <noreply@github.com> 1644299257 +0100\n\nRollup merge of #93721 - jyn514:less-macro-special-casing, r=petrochenkov\n\nrustdoc: Special-case macro lookups less\n\nPreviously, rustdoc had 3 fallbacks it used:\n1. `resolve_macro_path`\n2. `all_macros`\n3. `resolve_str_path_error`\n\nIdeally, it would only use `resolve_str_path_error`, to be consistent with other namespaces.\nUnfortunately, that doesn't consider macros that aren't defined at module scope;\nconsider for instance\n```rust\n{\n    struct S;\n\n    macro_rules! mac { () => {} }\n    // `mac`'s scope starts here\n\n    /// `mac` <- `resolve_str_path_error` won't see this\n   struct Z;\n\n    //`mac`'s scope ends here\n}\n```\n\nThis changes it to only use `all_macros` and `resolve_str_path_error`, and gives\n`resolve_str_path_error` precedence over `all_macros` in case there are two macros with the same\nname in the same module.\n\nThis is a smaller version of https://github.com/rust-lang/rust/pull/91427.\n\nr? `@petrochenkov`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f90f4fb85e9924e24272f6bc12a0c561291c682", "html_url": "https://github.com/rust-lang/rust/commit/1f90f4fb85e9924e24272f6bc12a0c561291c682", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f90f4fb85e9924e24272f6bc12a0c561291c682/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d5e2ac5eb78c5d3054267bbec5c31fcf8193507", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d5e2ac5eb78c5d3054267bbec5c31fcf8193507", "html_url": "https://github.com/rust-lang/rust/commit/7d5e2ac5eb78c5d3054267bbec5c31fcf8193507"}, {"sha": "f026550113b62b7bbd33faf39a7048f5a34fe289", "url": "https://api.github.com/repos/rust-lang/rust/commits/f026550113b62b7bbd33faf39a7048f5a34fe289", "html_url": "https://github.com/rust-lang/rust/commit/f026550113b62b7bbd33faf39a7048f5a34fe289"}], "stats": {"total": 33, "additions": 14, "deletions": 19}, "files": [{"sha": "8621fe6ba1b93a0a19a5bd90ff8edf4791e56d54", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1f90f4fb85e9924e24272f6bc12a0c561291c682/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f90f4fb85e9924e24272f6bc12a0c561291c682/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=1f90f4fb85e9924e24272f6bc12a0c561291c682", "patch": "@@ -2,10 +2,8 @@\n //!\n //! [RFC 1946]: https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md\n \n-use rustc_ast as ast;\n use rustc_data_structures::{fx::FxHashMap, stable_set::FxHashSet};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc_expand::base::SyntaxExtensionKind;\n use rustc_hir::def::{\n     DefKind,\n     Namespace::{self, *},\n@@ -14,7 +12,6 @@ use rustc_hir::def::{\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_ID};\n use rustc_middle::ty::{DefIdTree, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug, ty};\n-use rustc_resolve::ParentScope;\n use rustc_session::lint::Lint;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -486,23 +483,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'a str,\n         module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n-        let path = ast::Path::from_ident(Ident::from_str(path_str));\n         self.cx.enter_resolver(|resolver| {\n-            // FIXME(jynelson): does this really need 3 separate lookups?\n-            if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-                &path,\n-                None,\n-                &ParentScope::module(resolver.graph_root(), resolver),\n-                false,\n-                false,\n-            ) {\n-                if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n-                    return Ok(res.try_into().unwrap());\n-                }\n-            }\n-            if let Some(&res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-                return Ok(res.try_into().unwrap());\n-            }\n+            // NOTE: this needs 2 separate lookups because `resolve_str_path_error` doesn't take\n+            // lexical scope into account (it ignores all macros not defined at the mod-level)\n             debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n             if let Ok((_, res)) =\n                 resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n@@ -512,6 +495,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     return Ok(res);\n                 }\n             }\n+            if let Some(&res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n+                return Ok(res.try_into().unwrap());\n+            }\n             Err(ResolutionFailure::NotResolved {\n                 module_id,\n                 partial_res: None,"}, {"sha": "a14e4bdf1d706195de9551a46c704051349072e8", "filename": "src/test/rustdoc-ui/intra-doc/macro-rules.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1f90f4fb85e9924e24272f6bc12a0c561291c682/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fmacro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f90f4fb85e9924e24272f6bc12a0c561291c682/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fmacro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fmacro-rules.rs?ref=1f90f4fb85e9924e24272f6bc12a0c561291c682", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+#![allow(rustdoc::private_intra_doc_links)]\n+\n+macro_rules! foo {\n+    () => {};\n+}\n+\n+/// [foo!]\n+pub fn baz() {}"}]}