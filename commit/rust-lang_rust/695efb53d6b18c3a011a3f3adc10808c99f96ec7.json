{"sha": "695efb53d6b18c3a011a3f3adc10808c99f96ec7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NWVmYjUzZDZiMThjM2EwMTFhM2YzYWRjMTA4MDhjOTlmOTZlYzc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-18T17:59:58Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-18T17:59:58Z"}, "message": "Rollup merge of #24548 - graydon:reference-tidying, r=steveklabnik\n\nThis just deletes some egregious lies and obsolete terminology -- all of which I originally wrote -- from the reference. I expect the reference itself will be deleted soon enough, but I found myself gritting teeth over these bits too much to let them into a 1.0 release.", "tree": {"sha": "96cb388e2554c6035809f1c066872658246e2700", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96cb388e2554c6035809f1c066872658246e2700"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/695efb53d6b18c3a011a3f3adc10808c99f96ec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/695efb53d6b18c3a011a3f3adc10808c99f96ec7", "html_url": "https://github.com/rust-lang/rust/commit/695efb53d6b18c3a011a3f3adc10808c99f96ec7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/695efb53d6b18c3a011a3f3adc10808c99f96ec7/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb7a12757b9f9214c2b5f38437bf6c717f83eca5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb7a12757b9f9214c2b5f38437bf6c717f83eca5", "html_url": "https://github.com/rust-lang/rust/commit/cb7a12757b9f9214c2b5f38437bf6c717f83eca5"}, {"sha": "a99a8b0a927822bfbbfad1ec0c24378a6a914688", "url": "https://api.github.com/repos/rust-lang/rust/commits/a99a8b0a927822bfbbfad1ec0c24378a6a914688", "html_url": "https://github.com/rust-lang/rust/commit/a99a8b0a927822bfbbfad1ec0c24378a6a914688"}], "stats": {"total": 149, "additions": 53, "deletions": 96}, "files": [{"sha": "f731a78ef1254b27785db30aa7285dd10934e687", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/695efb53d6b18c3a011a3f3adc10808c99f96ec7/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/695efb53d6b18c3a011a3f3adc10808c99f96ec7/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=695efb53d6b18c3a011a3f3adc10808c99f96ec7", "patch": "@@ -124,7 +124,7 @@ Yes. Calling C code from Rust is simple and exactly as efficient as calling C co\n \n Yes. The Rust code has to be exposed via an `extern` declaration, which makes it C-ABI compatible. Such a function can be passed to C code as a function pointer or, if given the `#[no_mangle]` attribute to disable symbol mangling, can be called directly from C code.\n \n-## Why aren't function signatures inferred? Why only local slots?\n+## Why aren't function signatures inferred? Why only local variables?\n \n * Mechanically, it simplifies the inference algorithm; inference only requires looking at one function at a time.\n * The same simplification goes double for human readers. A reader does not need an IDE running an inference algorithm across an entire crate to be able to guess at a function's argument types; it's always explicit and nearby."}, {"sha": "3d9a5bafbd71ea2dba50df0c8c52d4fccd053edb", "filename": "src/doc/grammar.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/695efb53d6b18c3a011a3f3adc10808c99f96ec7/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/695efb53d6b18c3a011a3f3adc10808c99f96ec7/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=695efb53d6b18c3a011a3f3adc10808c99f96ec7", "patch": "@@ -5,8 +5,7 @@\n This document is the primary reference for the Rust programming language grammar. It\n provides only one kind of material:\n \n-  - Chapters that formally define the language grammar and, for each\n-    construct.\n+  - Chapters that formally define the language grammar.\n \n This document does not serve as an introduction to the language. Background\n familiarity with the language is assumed. A separate [guide] is available to\n@@ -427,7 +426,7 @@ meta_seq : meta_item [ ',' meta_seq ] ? ;\n **FIXME:** grammar?\n \n A _declaration statement_ is one that introduces one or more *names* into the\n-enclosing statement block. The declared names may denote new slots or new\n+enclosing statement block. The declared names may denote new variables or new\n items.\n \n #### Item declarations\n@@ -441,7 +440,7 @@ function, enumeration, structure, type, static, trait, implementation or module\n scope to a narrow region containing all of its uses; it is otherwise identical\n in meaning to declaring the item outside the statement block.\n \n-#### Slot declarations\n+#### Variable declarations\n \n ```antlr\n let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n@@ -763,7 +762,7 @@ bound := path | lifetime\n \n ### Memory ownership\n \n-### Memory slots\n+### Variables\n \n ### Boxes\n "}, {"sha": "c159f6164c20554f4b19f973357dfeb7b67d3691", "filename": "src/doc/reference.md", "status": "modified", "additions": 48, "deletions": 90, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/695efb53d6b18c3a011a3f3adc10808c99f96ec7/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/695efb53d6b18c3a011a3f3adc10808c99f96ec7/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=695efb53d6b18c3a011a3f3adc10808c99f96ec7", "patch": "@@ -564,7 +564,7 @@ type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n \n A _path_ is a sequence of one or more path components _logically_ separated by\n a namespace qualifier (`::`). If a path consists of only one component, it may\n-refer to either an [item](#items) or a [slot](#memory-slots) in a local control\n+refer to either an [item](#items) or a [variable](#variables) in a local control\n scope. If a path has multiple components, it refers to an item.\n \n Every item has a _canonical path_ within its crate, but the path naming an item\n@@ -735,13 +735,11 @@ Rust syntax is restricted in two ways:\n \n # Crates and source files\n \n-Rust is a *compiled* language. Its semantics obey a *phase distinction*\n-between compile-time and run-time. Those semantic rules that have a *static\n-interpretation* govern the success or failure of compilation. We refer to\n-these rules as \"static semantics\". Semantic rules called \"dynamic semantics\"\n-govern the behavior of programs at run-time. A program that fails to compile\n-due to violation of a compile-time rule has no defined dynamic semantics; the\n-compiler should halt with an error report, and produce no executable artifact.\n+Rust is a *compiled* language. Its semantics obey a *phase distinction* between\n+compile-time and run-time. Those semantic rules that have a *static\n+interpretation* govern the success or failure of compilation. Those semantics\n+that have a *dynamic interpretation* govern the behavior of the program at\n+run-time.\n \n The compilation model centers on artifacts called _crates_. Each compilation\n processes a single crate in source form, and if successful, produces a single\n@@ -1064,9 +1062,9 @@ fn main() {}\n A _function item_ defines a sequence of [statements](#statements) and an\n optional final [expression](#expressions), along with a name and a set of\n parameters. Functions are declared with the keyword `fn`. Functions declare a\n-set of *input* [*slots*](#memory-slots) as parameters, through which the caller\n-passes arguments into the function, and an *output* [*slot*](#memory-slots)\n-through which the function passes results back to the caller.\n+set of *input* [*variables*](#variables) as parameters, through which the caller\n+passes arguments into the function, and the *output* [*type*](#types)\n+of the value the function will return to its caller on completion.\n \n A function may also be copied into a first-class *value*, in which case the\n value has the corresponding [*function type*](#function-types), and can be used\n@@ -1229,7 +1227,7 @@ be undesired.\n #### Diverging functions\n \n A special kind of function can be declared with a `!` character where the\n-output slot type would normally be. For example:\n+output type would normally be. For example:\n \n ```\n fn my_err(s: &str) -> ! {\n@@ -1302,18 +1300,11 @@ contiguous stack segments like C.\n \n A _type alias_ defines a new name for an existing [type](#types). Type\n aliases are declared with the keyword `type`. Every value has a single,\n-specific type; the type-specified aspects of a value include:\n+specific type, but may implement several different traits, or be compatible with\n+several different type constraints.\n \n-* Whether the value is composed of sub-values or is indivisible.\n-* Whether the value represents textual or numerical information.\n-* Whether the value represents integral or floating-point information.\n-* The sequence of memory operations required to access the value.\n-* The [kind](#type-kinds) of the type.\n-\n-For example, the type `(u8, u8)` defines the set of immutable values that are\n-composite pairs, each containing two unsigned 8-bit integers accessed by\n-pattern-matching and laid out in memory with the `x` component preceding the\n-`y` component:\n+For example, the following defines the type `Point` as a synonym for the type\n+`(u8, u8)`, the type of pairs of unsigned 8 bit integers.:\n \n ```\n type Point = (u8, u8);\n@@ -2551,7 +2542,7 @@ statements](#expression-statements).\n ### Declaration statements\n \n A _declaration statement_ is one that introduces one or more *names* into the\n-enclosing statement block. The declared names may denote new slots or new\n+enclosing statement block. The declared names may denote new variables or new\n items.\n \n #### Item declarations\n@@ -2566,18 +2557,18 @@ in meaning to declaring the item outside the statement block.\n > **Note**: there is no implicit capture of the function's dynamic environment when\n > declaring a function-local item.\n \n-#### Slot declarations\n+#### Variable declarations\n \n ```{.ebnf .gram}\n let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n init : [ '=' ] expr ;\n ```\n \n-A _slot declaration_ introduces a new set of slots, given by a pattern. The\n+A _variable declaration_ introduces a new set of variable, given by a pattern. The\n pattern may be followed by a type annotation, and/or an initializer expression.\n When no type annotation is given, the compiler will infer the type, or signal\n an error if insufficient type information is available for definite inference.\n-Any slots introduced by a slot declaration are visible from the point of\n+Any variables introduced by a variable declaration are visible from the point of\n declaration until the end of the enclosing block scope.\n \n ### Expression statements\n@@ -2632,7 +2623,7 @@ of any reference that points to it.\n \n #### Moved and copied types\n \n-When a [local variable](#memory-slots) is used as an\n+When a [local variable](#variables) is used as an\n [rvalue](#lvalues,-rvalues-and-temporaries) the variable will either be moved\n or copied, depending on its type. All values whose type implements `Copy` are\n copied, all others are moved.\n@@ -3042,10 +3033,9 @@ paren_expr_list : '(' expr_list ')' ;\n call_expr : expr paren_expr_list ;\n ```\n \n-A _call expression_ invokes a function, providing zero or more input slots and\n-an optional reference slot to serve as the function's output, bound to the\n-`lval` on the right hand side of the call. If the function eventually returns,\n-then the expression completes.\n+A _call expression_ invokes a function, providing zero or more input variables\n+and an optional location to move the function's output into. If the function\n+eventually returns, then the expression completes.\n \n Some examples of call expressions:\n \n@@ -3456,9 +3446,9 @@ return_expr : \"return\" expr ? ;\n ```\n \n Return expressions are denoted with the keyword `return`. Evaluating a `return`\n-expression moves its argument into the output slot of the current function,\n-destroys the current function activation frame, and transfers control to the\n-caller frame.\n+expression moves its argument into the designated output location for the\n+current function call, destroys the current function activation frame, and\n+transfers control to the caller frame.\n \n An example of a `return` expression:\n \n@@ -3475,7 +3465,7 @@ fn max(a: i32, b: i32) -> i32 {\n \n ## Types\n \n-Every slot, item and value in a Rust program has a type. The _type_ of a\n+Every variable, item and value in a Rust program has a type. The _type_ of a\n *value* defines the interpretation of the memory holding it.\n \n Built-in types and type-constructors are tightly integrated into the language,\n@@ -3493,7 +3483,7 @@ The primitive types are the following:\n * The machine-dependent integer and floating-point types.\n \n [^unittype]: The \"unit\" value `()` is *not* a sentinel \"null pointer\" value for\n-    reference slots; the \"unit\" type is the implicit return type from functions\n+    reference variables; the \"unit\" type is the implicit return type from functions\n     otherwise lacking a return type, and can be used in other contexts (such as\n     message-sending or type-parametric code) as a zero-size type.]\n \n@@ -3831,29 +3821,33 @@ impl Printable for String {\n `self` refers to the value of type `String` that is the receiver for a call to\n the method `make_string`.\n \n-# The `Copy` trait\n+# Special traits\n+\n+Several traits define special evaluation behavior.\n \n-Rust has a special trait, `Copy`, which when implemented changes the semantics\n-of a value. Values whose type implements `Copy` are copied rather than moved\n-upon assignment.\n+## The `Copy` trait\n \n-# The `Sized` trait\n+The `Copy` trait changes the semantics of a type implementing it. Values whose\n+type implements `Copy` are copied rather than moved upon assignment.\n \n-`Sized` is a special trait which indicates that the size of this type is known\n-at compile-time.\n+## The `Sized` trait\n \n-# The `Drop` trait\n+The `Sized` trait indicates that the size of this type is known at compile-time.\n+\n+## The `Drop` trait\n \n The `Drop` trait provides a destructor, to be run whenever a value of this type\n is to be destroyed.\n \n # Memory model\n \n A Rust program's memory consists of a static set of *items* and a *heap*.\n-Immutable portions of the heap may be shared between threads, mutable portions\n-may not.\n+Immutable portions of the heap may be safely shared between threads, mutable\n+portions may not be safely shared, but several mechanisms for effectively-safe\n+sharing of mutable values, built on unsafe code but enforcing a safe locking\n+discipline, exist in the standard library.\n \n-Allocations in the stack consist of *slots*, and allocations in the heap\n+Allocations in the stack consist of *variables*, and allocations in the heap\n consist of *boxes*.\n \n ### Memory allocation and lifetime\n@@ -3872,10 +3866,11 @@ in the heap, heap allocations may outlive the frame they are allocated within.\n When a stack frame is exited, its local allocations are all released, and its\n references to boxes are dropped.\n \n-### Memory slots\n+### Variables\n \n-A _slot_ is a component of a stack frame, either a function parameter, a\n-[temporary](#lvalues,-rvalues-and-temporaries), or a local variable.\n+A _variable_ is a component of a stack frame, either a named function parameter,\n+an anonymous [temporary](#lvalues,-rvalues-and-temporaries), or a named local\n+variable.\n \n A _local variable_ (or *stack-local* allocation) holds a value directly,\n allocated within the stack's memory. The value is a part of the stack frame.\n@@ -3888,7 +3883,7 @@ Box<i32>, y: Box<i32>)` declare one mutable variable `x` and one immutable\n variable `y`).\n \n Methods that take either `self` or `Box<Self>` can optionally place them in a\n-mutable slot by prefixing them with `mut` (similar to regular arguments):\n+mutable variable by prefixing them with `mut` (similar to regular arguments):\n \n ```\n trait Changer {\n@@ -3903,44 +3898,7 @@ state. Subsequent statements within a function may or may not initialize the\n local variables. Local variables can be used only after they have been\n initialized; this is enforced by the compiler.\n \n-# Runtime services, linkage and debugging\n-\n-The Rust _runtime_ is a relatively compact collection of Rust code that\n-provides fundamental services and datatypes to all Rust threads at run-time. It\n-is smaller and simpler than many modern language runtimes. It is tightly\n-integrated into the language's execution model of memory, threads, communication\n-and logging.\n-\n-### Memory allocation\n-\n-The runtime memory-management system is based on a _service-provider\n-interface_, through which the runtime requests blocks of memory from its\n-environment and releases them back to its environment when they are no longer\n-needed. The default implementation of the service-provider interface consists\n-of the C runtime functions `malloc` and `free`.\n-\n-The runtime memory-management system, in turn, supplies Rust threads with\n-facilities for allocating releasing stacks, as well as allocating and freeing\n-heap data.\n-\n-### Built in types\n-\n-The runtime provides C and Rust code to assist with various built-in types,\n-such as arrays, strings, and the low level communication system (ports,\n-channels, threads).\n-\n-Support for other built-in types such as simple types, tuples and enums is\n-open-coded by the Rust compiler.\n-\n-### Thread scheduling and communication\n-\n-The runtime provides code to manage inter-thread communication. This includes\n-the system of thread-lifecycle state transitions depending on the contents of\n-queues, as well as code to copy values between queues and their recipients and\n-to serialize values for transmission over operating-system inter-process\n-communication facilities.\n-\n-### Linkage\n+# Linkage\n \n The Rust compiler supports various methods to link crates together both\n statically and dynamically. This section will explore the various methods to"}]}