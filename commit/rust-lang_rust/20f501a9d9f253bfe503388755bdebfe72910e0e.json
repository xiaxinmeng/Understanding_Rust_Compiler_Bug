{"sha": "20f501a9d9f253bfe503388755bdebfe72910e0e", "node_id": "C_kwDOAAsO6NoAKDIwZjUwMWE5ZDlmMjUzYmZlNTAzMzg4NzU1YmRlYmZlNzI5MTBlMGU", "commit": {"author": {"name": "Niki4tap", "email": "rombiklol2@gmail.com", "date": "2022-12-18T19:39:06Z"}, "committer": {"name": "Niki4tap", "email": "rombiklol2@gmail.com", "date": "2022-12-18T19:39:06Z"}, "message": "Improve code style further", "tree": {"sha": "f74e288b7d3fc27c969edcb9bf39ba01500d6d30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f74e288b7d3fc27c969edcb9bf39ba01500d6d30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20f501a9d9f253bfe503388755bdebfe72910e0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20f501a9d9f253bfe503388755bdebfe72910e0e", "html_url": "https://github.com/rust-lang/rust/commit/20f501a9d9f253bfe503388755bdebfe72910e0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20f501a9d9f253bfe503388755bdebfe72910e0e/comments", "author": {"login": "Niki4tap", "id": 66798058, "node_id": "MDQ6VXNlcjY2Nzk4MDU4", "avatar_url": "https://avatars.githubusercontent.com/u/66798058?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Niki4tap", "html_url": "https://github.com/Niki4tap", "followers_url": "https://api.github.com/users/Niki4tap/followers", "following_url": "https://api.github.com/users/Niki4tap/following{/other_user}", "gists_url": "https://api.github.com/users/Niki4tap/gists{/gist_id}", "starred_url": "https://api.github.com/users/Niki4tap/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Niki4tap/subscriptions", "organizations_url": "https://api.github.com/users/Niki4tap/orgs", "repos_url": "https://api.github.com/users/Niki4tap/repos", "events_url": "https://api.github.com/users/Niki4tap/events{/privacy}", "received_events_url": "https://api.github.com/users/Niki4tap/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Niki4tap", "id": 66798058, "node_id": "MDQ6VXNlcjY2Nzk4MDU4", "avatar_url": "https://avatars.githubusercontent.com/u/66798058?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Niki4tap", "html_url": "https://github.com/Niki4tap", "followers_url": "https://api.github.com/users/Niki4tap/followers", "following_url": "https://api.github.com/users/Niki4tap/following{/other_user}", "gists_url": "https://api.github.com/users/Niki4tap/gists{/gist_id}", "starred_url": "https://api.github.com/users/Niki4tap/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Niki4tap/subscriptions", "organizations_url": "https://api.github.com/users/Niki4tap/orgs", "repos_url": "https://api.github.com/users/Niki4tap/repos", "events_url": "https://api.github.com/users/Niki4tap/events{/privacy}", "received_events_url": "https://api.github.com/users/Niki4tap/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b2fc8e2a2da497344d42ccf8ddefc794eb82858", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b2fc8e2a2da497344d42ccf8ddefc794eb82858", "html_url": "https://github.com/rust-lang/rust/commit/9b2fc8e2a2da497344d42ccf8ddefc794eb82858"}], "stats": {"total": 147, "additions": 73, "deletions": 74}, "files": [{"sha": "4f79ce6f8fec48fb30e712d30c96834df0756fbf", "filename": "clippy_lints/src/fn_null_check.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/20f501a9d9f253bfe503388755bdebfe72910e0e/clippy_lints%2Fsrc%2Ffn_null_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20f501a9d9f253bfe503388755bdebfe72910e0e/clippy_lints%2Fsrc%2Ffn_null_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffn_null_check.rs?ref=20f501a9d9f253bfe503388755bdebfe72910e0e", "patch": "@@ -55,50 +55,50 @@ fn is_fn_ptr_cast(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n \n impl<'tcx> LateLintPass<'tcx> for FnNullCheck {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        // Catching:\n-        // (fn_ptr as *<const/mut> <ty>).is_null()\n-        if let ExprKind::MethodCall(method_name, receiver, _, _) = expr.kind\n-            && method_name.ident.as_str() == \"is_null\"\n-            && is_fn_ptr_cast(cx, receiver)\n-        {\n+        match expr.kind {\n+            ExprKind::MethodCall(method_name, receiver, _, _)\n+                if method_name.ident.as_str() == \"is_null\" && is_fn_ptr_cast(cx, receiver) =>\n+            {\n                 lint_expr(cx, expr);\n-                return;\n-        }\n+            },\n \n-        if let ExprKind::Binary(op, left, right) = expr.kind\n-            && let BinOpKind::Eq = op.node\n-        {\n-            let to_check: &Expr<'_>;\n-            if is_fn_ptr_cast(cx, left) {\n-                to_check = right;\n-            } else if is_fn_ptr_cast(cx, right) {\n-                to_check = left;\n-            } else {\n-                return;\n-            }\n+            ExprKind::Binary(op, left, right) if matches!(op.node, BinOpKind::Eq) => {\n+                let to_check: &Expr<'_>;\n+                if is_fn_ptr_cast(cx, left) {\n+                    to_check = right;\n+                } else if is_fn_ptr_cast(cx, right) {\n+                    to_check = left;\n+                } else {\n+                    return;\n+                }\n \n-            // Catching:\n-            // (fn_ptr as *<const/mut> <ty>) == <const that evaluates to null_ptr>\n-            let c = constant(cx, cx.typeck_results(), to_check);\n-            if let Some((Constant::RawPtr(0), _)) = c {\n-                lint_expr(cx, expr);\n-                return;\n-            }\n+                match to_check.kind {\n+                    // Catching:\n+                    // (fn_ptr as *<const/mut> <ty>) == (0 as <ty>)\n+                    ExprKind::Cast(cast_expr, _) if is_integer_literal(cast_expr, 0) => {\n+                        lint_expr(cx, expr);\n+                    },\n \n-            // Catching:\n-            // (fn_ptr as *<const/mut> <ty>) == (0 as <ty>)\n-            if let ExprKind::Cast(cast_expr, _) = to_check.kind && is_integer_literal(cast_expr, 0) {\n-                lint_expr(cx, expr);\n-                return;\n-            }\n+                    // Catching:\n+                    // (fn_ptr as *<const/mut> <ty>) == std::ptr::null()\n+                    ExprKind::Call(func, []) if is_path_diagnostic_item(cx, func, sym::ptr_null) => {\n+                        lint_expr(cx, expr);\n+                    },\n \n-            // Catching:\n-            // (fn_ptr as *<const/mut> <ty>) == std::ptr::null()\n-            if let ExprKind::Call(func, []) = to_check.kind &&\n-                is_path_diagnostic_item(cx, func, sym::ptr_null)\n-            {\n-                lint_expr(cx, expr);\n-            }\n+                    // Catching:\n+                    // (fn_ptr as *<const/mut> <ty>) == <const that evaluates to null_ptr>\n+                    _ if matches!(\n+                        constant(cx, cx.typeck_results(), to_check),\n+                        Some((Constant::RawPtr(0), _))\n+                    ) =>\n+                    {\n+                        lint_expr(cx, expr);\n+                    },\n+\n+                    _ => {},\n+                }\n+            },\n+            _ => {},\n         }\n     }\n }"}, {"sha": "79d8cb084fd5d9d65371f23ed34f340960442a19", "filename": "clippy_lints/src/transmute/transmute_null_to_fn.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/20f501a9d9f253bfe503388755bdebfe72910e0e/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_null_to_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20f501a9d9f253bfe503388755bdebfe72910e0e/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_null_to_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_null_to_fn.rs?ref=20f501a9d9f253bfe503388755bdebfe72910e0e", "patch": "@@ -13,6 +13,13 @@ const NOTE_MSG: &str = \"this transmute results in undefined behavior\";\n const HELP_MSG: &str =\n     \"try wrapping your function pointer type in `Option<T>` instead, and using `None` as a null pointer value\";\n \n+fn lint_expr(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    span_lint_and_then(cx, TRANSMUTE_NULL_TO_FN, expr.span, LINT_MSG, |diag| {\n+        diag.span_label(expr.span, NOTE_MSG);\n+        diag.help(HELP_MSG);\n+    });\n+}\n+\n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'tcx Expr<'_>, to_ty: Ty<'tcx>) -> bool {\n     if !to_ty.is_fn() {\n         return false;\n@@ -21,42 +28,34 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arg: &'t\n     // Catching:\n     // transmute over constants that resolve to `null`.\n     let mut const_eval_context = constant_context(cx, cx.typeck_results());\n-    if let ExprKind::Path(ref _qpath) = arg.kind &&\n-        let Some(Constant::RawPtr(0)) = const_eval_context.expr(arg)\n-    {\n-        span_lint_and_then(cx, TRANSMUTE_NULL_TO_FN, expr.span, LINT_MSG, |diag| {\n-            diag.span_label(expr.span, NOTE_MSG);\n-            diag.help(HELP_MSG);\n-        });\n-        return true;\n-    }\n \n-    // Catching:\n-    // `std::mem::transmute(0 as *const i32)`\n-    if let ExprKind::Cast(inner_expr, _cast_ty) = arg.kind && is_integer_literal(inner_expr, 0) {\n-        span_lint_and_then(cx, TRANSMUTE_NULL_TO_FN, expr.span, LINT_MSG, |diag| {\n-            diag.span_label(expr.span, NOTE_MSG);\n-            diag.help(HELP_MSG);\n-        });\n-        return true;\n-    }\n+    match arg.kind {\n+        ExprKind::Path(ref _qpath) if matches!(const_eval_context.expr(arg), Some(Constant::RawPtr(0))) => {\n+            lint_expr(cx, expr);\n+            true\n+        },\n \n-    // Catching:\n-    // `std::mem::transmute(std::ptr::null::<i32>())`\n-    if let ExprKind::Call(func1, []) = arg.kind &&\n-        is_path_diagnostic_item(cx, func1, sym::ptr_null)\n-    {\n-        span_lint_and_then(cx, TRANSMUTE_NULL_TO_FN, expr.span, LINT_MSG, |diag| {\n-            diag.span_label(expr.span, NOTE_MSG);\n-            diag.help(HELP_MSG);\n-        });\n-        return true;\n-    }\n+        // Catching:\n+        // `std::mem::transmute(0 as *const i32)`\n+        ExprKind::Cast(inner_expr, _cast_ty) if is_integer_literal(inner_expr, 0) => {\n+            lint_expr(cx, expr);\n+            true\n+        },\n \n-    // FIXME:\n-    // Also catch transmutations of variables which are known nulls.\n-    // To do this, MIR const propagation seems to be the better tool.\n-    // Whenever MIR const prop routines are more developed, this will\n-    // become available. As of this writing (25/03/19) it is not yet.\n-    false\n+        // Catching:\n+        // `std::mem::transmute(std::ptr::null::<i32>())`\n+        ExprKind::Call(func1, []) if is_path_diagnostic_item(cx, func1, sym::ptr_null) => {\n+            lint_expr(cx, expr);\n+            true\n+        },\n+\n+        _ => {\n+            // FIXME:\n+            // Also catch transmutations of variables which are known nulls.\n+            // To do this, MIR const propagation seems to be the better tool.\n+            // Whenever MIR const prop routines are more developed, this will\n+            // become available. As of this writing (25/03/19) it is not yet.\n+            false\n+        },\n+    }\n }"}]}