{"sha": "f13e871ac561b54ddeac2b6173b1905fb4b20138", "node_id": "C_kwDOAAsO6NoAKGYxM2U4NzFhYzU2MWI1NGRkZWFjMmI2MTczYjE5MDVmYjRiMjAxMzg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-14T06:47:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-14T06:47:31Z"}, "message": "Rollup merge of #92045 - oli-obk:cleanup, r=petrochenkov\n\nDon't fall back to crate-level opaque type definitions.\n\nThat would just hide bugs, as it works accidentally if the opaque type is defined at the crate level.\n\nOnly works after #90948 which worked by accident for our entire test suite.", "tree": {"sha": "ae5e0158a4d9061bc46684caf098b3ef994d3b2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae5e0158a4d9061bc46684caf098b3ef994d3b2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f13e871ac561b54ddeac2b6173b1905fb4b20138", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh4RyDCRBK7hj4Ov3rIwAA0LMIAGVe5BqBtkCf4Fm56GtzbTYL\nLcXjTobBUNddDyImimAv0OgbKyi7oLydy5NWnvSN6HydZ9k+qNxQYvmGpSfdmCeg\nZOfZg8wlt9b9xIBjmRUS/Yjs9eBffub5txFIxT14gUBoqFH6julz/TST7a8yGX2N\nRmkBK/MRaUNYcJagjeSAfCksnTyTJThTOg9q4164MbgN1OWAN4yzTDR0dXHBht9I\nV5aTw8U5wcEVCusFCYuqVWiE0Q36wnAmRFTOEirWSxmgM0c5tFkMk91wKC2wQYg6\nBN7JdASgPM9+qG3RhQ78iew++PoJgGpPjh6l+db0qs49v9mvjHw8Eg0FAtVxask=\n=zjA4\n-----END PGP SIGNATURE-----\n", "payload": "tree ae5e0158a4d9061bc46684caf098b3ef994d3b2b\nparent f312a5e610d47601e9a3da828002f5e1ffeb272a\nparent 956db072a877284e8d057dae717cf8253505a4ff\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642142851 +0100\ncommitter GitHub <noreply@github.com> 1642142851 +0100\n\nRollup merge of #92045 - oli-obk:cleanup, r=petrochenkov\n\nDon't fall back to crate-level opaque type definitions.\n\nThat would just hide bugs, as it works accidentally if the opaque type is defined at the crate level.\n\nOnly works after #90948 which worked by accident for our entire test suite.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f13e871ac561b54ddeac2b6173b1905fb4b20138", "html_url": "https://github.com/rust-lang/rust/commit/f13e871ac561b54ddeac2b6173b1905fb4b20138", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f13e871ac561b54ddeac2b6173b1905fb4b20138/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f312a5e610d47601e9a3da828002f5e1ffeb272a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f312a5e610d47601e9a3da828002f5e1ffeb272a", "html_url": "https://github.com/rust-lang/rust/commit/f312a5e610d47601e9a3da828002f5e1ffeb272a"}, {"sha": "956db072a877284e8d057dae717cf8253505a4ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/956db072a877284e8d057dae717cf8253505a4ff", "html_url": "https://github.com/rust-lang/rust/commit/956db072a877284e8d057dae717cf8253505a4ff"}], "stats": {"total": 68, "additions": 36, "deletions": 32}, "files": [{"sha": "d3664e53447d04520cbf33233ac907a1dc8e9731", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f13e871ac561b54ddeac2b6173b1905fb4b20138/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f13e871ac561b54ddeac2b6173b1905fb4b20138/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=f13e871ac561b54ddeac2b6173b1905fb4b20138", "patch": "@@ -10,7 +10,6 @@ pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};\n \n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n \n-use hir::def_id::CRATE_DEF_ID;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::Rollback;\n@@ -291,7 +290,12 @@ pub struct InferCtxt<'a, 'tcx> {\n \n     /// The `DefId` of the item in whose context we are performing inference or typeck.\n     /// It is used to check whether an opaque type use is a defining use.\n-    pub defining_use_anchor: LocalDefId,\n+    ///\n+    /// If it is `None`, we can't resolve opaque types here and need to bubble up\n+    /// the obligation. This frequently happens for\n+    /// short lived InferCtxt within queries. The opaque type obligations are forwarded\n+    /// to the outside until the end up in an `InferCtxt` for typeck or borrowck.\n+    pub defining_use_anchor: Option<LocalDefId>,\n \n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n@@ -547,7 +551,7 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n-    defining_use_anchor: LocalDefId,\n+    defining_use_anchor: Option<LocalDefId>,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -556,11 +560,7 @@ pub trait TyCtxtInferExt<'tcx> {\n \n impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n     fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder {\n-            tcx: self,\n-            defining_use_anchor: CRATE_DEF_ID,\n-            fresh_typeck_results: None,\n-        }\n+        InferCtxtBuilder { tcx: self, defining_use_anchor: None, fresh_typeck_results: None }\n     }\n }\n \n@@ -580,7 +580,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// (via `with_fresh_in_progress_typeck_results`) and for the inference context used\n     /// in mir borrowck.\n     pub fn with_opaque_type_inference(mut self, defining_use_anchor: LocalDefId) -> Self {\n-        self.defining_use_anchor = defining_use_anchor;\n+        self.defining_use_anchor = Some(defining_use_anchor);\n         self\n     }\n "}, {"sha": "04b1a42e5beef75345bdf41c5b703d9e6d2ea05e", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f13e871ac561b54ddeac2b6173b1905fb4b20138/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f13e871ac561b54ddeac2b6173b1905fb4b20138/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=f13e871ac561b54ddeac2b6173b1905fb4b20138", "patch": "@@ -328,6 +328,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             },\n         });\n     }\n+\n+    fn opaque_type_origin(&self, def_id: LocalDefId) -> Option<hir::OpaqueTyOrigin> {\n+        let tcx = self.tcx;\n+        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let parent_def_id = self.defining_use_anchor?;\n+        let item_kind = &tcx.hir().expect_item(def_id).kind;\n+        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n+            span_bug!(\n+                tcx.def_span(def_id),\n+                \"weird opaque type: {:#?}\",\n+                item_kind\n+            )\n+        };\n+        let in_definition_scope = match *origin {\n+            // Async `impl Trait`\n+            hir::OpaqueTyOrigin::AsyncFn(parent) => parent == parent_def_id,\n+            // Anonymous `impl Trait`\n+            hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n+            // Named `type Foo = impl Bar;`\n+            hir::OpaqueTyOrigin::TyAlias => {\n+                may_define_opaque_type(tcx, parent_def_id, opaque_hir_id)\n+            }\n+        };\n+        in_definition_scope.then_some(*origin)\n+    }\n }\n \n // Visitor that requires that (almost) all regions in the type visited outlive\n@@ -459,31 +484,10 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     // }\n                     // ```\n                     if let Some(def_id) = def_id.as_local() {\n-                        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                        let parent_def_id = self.infcx.defining_use_anchor;\n-                        let item_kind = &tcx.hir().expect_item(def_id).kind;\n-                        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n-                            span_bug!(\n-                                self.value_span,\n-                                \"weird opaque type: {:#?}, {:#?}\",\n-                                ty.kind(),\n-                                item_kind\n-                            )\n-                        };\n-                        let in_definition_scope = match *origin {\n-                            // Async `impl Trait`\n-                            hir::OpaqueTyOrigin::AsyncFn(parent) => parent == parent_def_id,\n-                            // Anonymous `impl Trait`\n-                            hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n-                            // Named `type Foo = impl Bar;`\n-                            hir::OpaqueTyOrigin::TyAlias => {\n-                                may_define_opaque_type(tcx, parent_def_id, opaque_hir_id)\n-                            }\n-                        };\n-                        if in_definition_scope {\n+                        if let Some(origin) = self.infcx.opaque_type_origin(def_id) {\n                             let opaque_type_key =\n                                 OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                            return self.fold_opaque_ty(ty, opaque_type_key, *origin);\n+                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n                         }\n \n                         debug!("}]}