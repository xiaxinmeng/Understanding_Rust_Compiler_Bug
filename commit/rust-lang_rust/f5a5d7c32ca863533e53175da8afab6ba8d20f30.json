{"sha": "f5a5d7c32ca863533e53175da8afab6ba8d20f30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1YTVkN2MzMmNhODYzNTMzZTUzMTc1ZGE4YWZhYjZiYThkMjBmMzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-24T12:51:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-24T12:51:28Z"}, "message": "auto merge of #13559 : FlaPer87/rust/remove-special-root, r=nikomatsakis\n\nThis patch removes the special auto-rooting for `@` from the borrow checker. With `@` moving into a library, it doesn't make sense to keep this code around anymore. It also simplifies `trans` by removing root checking from there \r\n\r\n@nikomatsakis\r\n\r\nCloses: #11586", "tree": {"sha": "6366d2d4c1aa8b848e54916908c1985fc45f7786", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6366d2d4c1aa8b848e54916908c1985fc45f7786"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5a5d7c32ca863533e53175da8afab6ba8d20f30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5a5d7c32ca863533e53175da8afab6ba8d20f30", "html_url": "https://github.com/rust-lang/rust/commit/f5a5d7c32ca863533e53175da8afab6ba8d20f30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5a5d7c32ca863533e53175da8afab6ba8d20f30/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e01e78fd00c78fd3b7f92fb0d6d58e05801d5d38", "url": "https://api.github.com/repos/rust-lang/rust/commits/e01e78fd00c78fd3b7f92fb0d6d58e05801d5d38", "html_url": "https://github.com/rust-lang/rust/commit/e01e78fd00c78fd3b7f92fb0d6d58e05801d5d38"}, {"sha": "6fa1f48237bc61cabcb63f75700ad7303f152c1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fa1f48237bc61cabcb63f75700ad7303f152c1f", "html_url": "https://github.com/rust-lang/rust/commit/6fa1f48237bc61cabcb63f75700ad7303f152c1f"}], "stats": {"total": 488, "additions": 137, "deletions": 351}, "files": [{"sha": "fe0b6bcfd0f0afea41e730bcaa0fa77a739551c2", "filename": "src/libfourcc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibfourcc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibfourcc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfourcc%2Flib.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -91,7 +91,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) ->\n \n     let s = match expr.node {\n         // expression is a literal\n-        ast::ExprLit(lit) => match lit.node {\n+        ast::ExprLit(ref lit) => match lit.node {\n             // string literal\n             ast::LitStr(ref s, _) => {\n                 if s.get().char_len() != 4 {"}, {"sha": "e4ace2a2b9594fda98d2d2b7d4a90145dc22f124", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -346,8 +346,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     time(time_passes, \"effect checking\", (), |_|\n          middle::effect::check_crate(&ty_cx, krate));\n \n-    let middle::moves::MoveMaps {moves_map, moved_variables_set,\n-                                 capture_map} =\n+    let middle::moves::MoveMaps {moves_map, capture_map} =\n         time(time_passes, \"compute moves\", (), |_|\n              middle::moves::compute_moves(&ty_cx, krate));\n \n@@ -357,14 +356,11 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     time(time_passes, \"liveness checking\", (), |_|\n          middle::liveness::check_crate(&ty_cx, &capture_map, krate));\n \n-    let root_map =\n-        time(time_passes, \"borrow checking\", (), |_|\n-             middle::borrowck::check_crate(&ty_cx, &moves_map,\n-                                           &moved_variables_set,\n-                                           &capture_map, krate));\n+    time(time_passes, \"borrow checking\", (), |_|\n+         middle::borrowck::check_crate(&ty_cx, &moves_map,\n+                                       &capture_map, krate));\n \n     drop(moves_map);\n-    drop(moved_variables_set);\n \n     time(time_passes, \"kind checking\", (), |_|\n          kind::check_crate(&ty_cx, krate));\n@@ -389,7 +385,6 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         exported_items: exported_items,\n         public_items: public_items,\n         maps: astencode::Maps {\n-            root_map: root_map,\n             capture_map: RefCell::new(capture_map)\n         },\n         reachable: reachable_map"}, {"sha": "7f3757c478c02e3b87949b292d82077b563c097d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -54,7 +54,6 @@ use writer = serialize::ebml::writer;\n \n // Auxiliary maps of things to be encoded\n pub struct Maps {\n-    pub root_map: middle::borrowck::root_map,\n     pub capture_map: RefCell<middle::moves::CaptureMap>,\n }\n "}, {"sha": "4c17ddbb31f8604a44180371afa1d0e2b3d62ee8", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 2, "deletions": 118, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -65,9 +65,6 @@ struct GuaranteeLifetimeContext<'a> {\n }\n \n impl<'a> GuaranteeLifetimeContext<'a> {\n-    fn tcx(&self) -> &'a ty::ctxt {\n-        self.bccx.tcx\n-    }\n \n     fn check(&self, cmt: &mc::cmt, discr_scope: Option<ast::NodeId>) -> R {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n@@ -90,29 +87,10 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n                 Ok(())\n             }\n \n-            mc::cat_deref(ref base, derefs, mc::GcPtr) => {\n-                let base_scope = self.scope(base);\n-\n-                // L-Deref-Managed-Imm-User-Root\n-                let omit_root =\n-                    self.bccx.is_subregion_of(self.loan_region, base_scope) &&\n-                    self.is_rvalue_or_immutable(base) &&\n-                    !self.is_moved(base);\n-\n-                if !omit_root {\n-                    // L-Deref-Managed-Imm-Compiler-Root\n-                    // L-Deref-Managed-Mut-Compiler-Root\n-                    self.check_root(cmt, base, derefs, discr_scope)\n-                } else {\n-                    debug!(\"omitting root, base={}, base_scope={:?}\",\n-                           base.repr(self.tcx()), base_scope);\n-                    Ok(())\n-                }\n-            }\n-\n             mc::cat_downcast(ref base) |\n             mc::cat_deref(ref base, _, mc::OwnedPtr) |     // L-Deref-Send\n-            mc::cat_interior(ref base, _) => {             // L-Field\n+            mc::cat_interior(ref base, _) |                // L-Field\n+            mc::cat_deref(ref base, _, mc::GcPtr) => {\n                 self.check(base, discr_scope)\n             }\n \n@@ -174,74 +152,6 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n         }\n     }\n \n-    fn is_rvalue_or_immutable(&self,\n-                              cmt: &mc::cmt) -> bool {\n-        //! We can omit the root on an `@T` value if the location\n-        //! that holds the box is either (1) an rvalue, in which case\n-        //! it is in a non-user-accessible temporary, or (2) an immutable\n-        //! lvalue.\n-\n-        cmt.mutbl.is_immutable() || match cmt.guarantor().cat {\n-            mc::cat_rvalue(..) => true,\n-            _ => false\n-        }\n-    }\n-\n-    fn check_root(&self,\n-                  cmt_deref: &mc::cmt,\n-                  cmt_base: &mc::cmt,\n-                  derefs: uint,\n-                  discr_scope: Option<ast::NodeId>) -> R {\n-        debug!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, \\\n-                discr_scope={:?})\",\n-               cmt_deref.repr(self.tcx()),\n-               cmt_base.repr(self.tcx()),\n-               derefs,\n-               discr_scope);\n-\n-        // Make sure that the loan does not exceed the maximum time\n-        // that we can root the value, dynamically.\n-        let root_region = ty::ReScope(self.root_scope_id);\n-        if !self.bccx.is_subregion_of(self.loan_region, root_region) {\n-            return Err(self.report_error(\n-                err_out_of_root_scope(root_region, self.loan_region)));\n-        }\n-\n-        // Extract the scope id that indicates how long the rooting is required\n-        let root_scope = match self.loan_region {\n-            ty::ReScope(id) => id,\n-            _ => {\n-                // the check above should fail for anything is not ReScope\n-                self.bccx.tcx.sess.span_bug(\n-                    cmt_base.span,\n-                    format!(\"cannot issue root for scope region: {:?}\",\n-                         self.loan_region));\n-            }\n-        };\n-\n-        // If inside of a match arm, expand the rooting to the entire\n-        // match. See the detailed discussion in `check()` above.\n-        let root_scope = match discr_scope {\n-            None => root_scope,\n-            Some(id) => {\n-                if self.bccx.is_subscope_of(root_scope, id) {\n-                    id\n-                } else {\n-                    root_scope\n-                }\n-            }\n-        };\n-\n-        // Add a record of what is required\n-        let rm_key = root_map_key {id: cmt_deref.id, derefs: derefs};\n-        let root_info = RootInfo {scope: root_scope};\n-\n-        self.bccx.root_map.borrow_mut().insert(rm_key, root_info);\n-\n-        debug!(\"root_key: {:?} root_info: {:?}\", rm_key, root_info);\n-        Ok(())\n-    }\n-\n     fn check_scope(&self, max_scope: ty::Region) -> R {\n         //! Reports an error if `loan_region` is larger than `valid_scope`\n \n@@ -252,32 +162,6 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n         }\n     }\n \n-    fn is_moved(&self, cmt: &mc::cmt) -> bool {\n-        //! True if `cmt` is something that is potentially moved\n-        //! out of the current stack frame.\n-\n-        match cmt.guarantor().cat {\n-            mc::cat_local(id) |\n-            mc::cat_arg(id) => {\n-                self.bccx.moved_variables_set.contains(&id)\n-            }\n-            mc::cat_rvalue(..) |\n-            mc::cat_static_item |\n-            mc::cat_copied_upvar(..) |\n-            mc::cat_deref(..) |\n-            mc::cat_upvar(..) => {\n-                false\n-            }\n-            ref r @ mc::cat_downcast(..) |\n-            ref r @ mc::cat_interior(..) |\n-            ref r @ mc::cat_discr(..) => {\n-                self.tcx().sess.span_bug(\n-                    cmt.span,\n-                    format!(\"illegal guarantor category: {:?}\", r));\n-            }\n-        }\n-    }\n-\n     fn scope(&self, cmt: &mc::cmt) -> ty::Region {\n         //! Returns the maximal region scope for the which the\n         //! lvalue `cmt` is guaranteed to be valid without any"}, {"sha": "4d0249a3011bd8369a2625b1c1d36baab76ff4db", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -101,12 +101,18 @@ impl<'a> RestrictionsContext<'a> {\n                 self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::OwnedPtr) => {\n+            mc::cat_deref(cmt_base, _, pk @ mc::OwnedPtr) |\n+            mc::cat_deref(cmt_base, _, pk @ mc::GcPtr) => {\n                 // R-Deref-Send-Pointer\n                 //\n                 // When we borrow the interior of an owned pointer, we\n                 // cannot permit the base to be mutated, because that\n                 // would cause the unique pointer to be freed.\n+                //\n+                // For a managed pointer, the rules are basically the\n+                // same, because this could be the last ref.\n+                // Eventually we should make these non-special and\n+                // just rely on Deref<T> implementation.\n                 let result = self.restrict(\n                     cmt_base,\n                     restrictions | RESTR_MUTATE);\n@@ -134,11 +140,6 @@ impl<'a> RestrictionsContext<'a> {\n                 Safe\n             }\n \n-            mc::cat_deref(_, _, mc::GcPtr) => {\n-                // R-Deref-Imm-Managed\n-                Safe\n-            }\n-\n             mc::cat_deref(cmt_base, _, pk @ mc::BorrowedPtr(ty::MutBorrow, lt)) => {\n                 // R-Deref-Mut-Borrowed\n                 if !self.bccx.is_subregion_of(self.loan_region, lt) {"}, {"sha": "1af0e48c46dd678d5dfa71f24e75250e8c407c90", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 33, "deletions": 69, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -21,11 +21,10 @@ use middle::dataflow::DataFlowOperator;\n use util::nodemap::{NodeMap, NodeSet};\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::ops::{BitOr, BitAnd};\n use std::rc::Rc;\n use std::strbuf::StrBuf;\n-use collections::HashMap;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -77,21 +76,39 @@ impl<'a> Visitor<()> for BorrowckCtxt<'a> {\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    moves_map: &NodeSet,\n-                   moved_variables_set: &NodeSet,\n                    capture_map: &moves::CaptureMap,\n-                   krate: &ast::Crate)\n-                   -> root_map {\n+                   krate: &ast::Crate) {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n         moves_map: moves_map,\n-        moved_variables_set: moved_variables_set,\n         capture_map: capture_map,\n-        root_map: RefCell::new(HashMap::new())\n+        stats: @BorrowStats {\n+            loaned_paths_same: Cell::new(0),\n+            loaned_paths_imm: Cell::new(0),\n+            stable_paths: Cell::new(0),\n+            guaranteed_paths: Cell::new(0),\n+        }\n     };\n \n     visit::walk_crate(&mut bccx, krate, ());\n \n-    return bccx.root_map.unwrap();\n+    if tcx.sess.borrowck_stats() {\n+        println!(\"--- borrowck stats ---\");\n+        println!(\"paths requiring guarantees: {}\",\n+                 bccx.stats.guaranteed_paths.get());\n+        println!(\"paths requiring loans     : {}\",\n+                 make_stat(&bccx, bccx.stats.loaned_paths_same.get()));\n+        println!(\"paths requiring imm loans : {}\",\n+                 make_stat(&bccx, bccx.stats.loaned_paths_imm.get()));\n+        println!(\"stable paths              : {}\",\n+                 make_stat(&bccx, bccx.stats.stable_paths.get()));\n+    }\n+\n+    fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> ~str {\n+        let stat_f = stat as f64;\n+        let total = bccx.stats.guaranteed_paths.get() as f64;\n+        format!(\"{} ({:.0f}%)\", stat  , stat_f * 100.0 / total)\n+    }\n }\n \n fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n@@ -148,28 +165,17 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n pub struct BorrowckCtxt<'a> {\n     tcx: &'a ty::ctxt,\n     moves_map: &'a NodeSet,\n-    moved_variables_set: &'a NodeSet,\n     capture_map: &'a moves::CaptureMap,\n-    root_map: RefCell<root_map>,\n+\n+    // Statistics:\n+    stats: @BorrowStats\n }\n \n-// The keys to the root map combine the `id` of the deref expression\n-// with the number of types that it is *autodereferenced*. So, for\n-// example, imagine I have a variable `x: @@@T` and an expression\n-// `(*x).f`.  This will have 3 derefs, one explicit and then two\n-// autoderefs. These are the relevant `root_map_key` values that could\n-// appear:\n-//\n-//    {id:*x, derefs:0} --> roots `x` (type: @@@T, due to explicit deref)\n-//    {id:*x, derefs:1} --> roots `*x` (type: @@T, due to autoderef #1)\n-//    {id:*x, derefs:2} --> roots `**x` (type: @T, due to autoderef #2)\n-//\n-// Note that there is no entry with derefs:3---the type of that expression\n-// is T, which is not a box.\n-#[deriving(Eq, TotalEq, Hash)]\n-pub struct root_map_key {\n-    pub id: ast::NodeId,\n-    pub derefs: uint\n+pub struct BorrowStats {\n+    loaned_paths_same: Cell<uint>,\n+    loaned_paths_imm: Cell<uint>,\n+    stable_paths: Cell<uint>,\n+    guaranteed_paths: Cell<uint>,\n }\n \n pub type BckResult<T> = Result<T, BckError>;\n@@ -318,39 +324,13 @@ impl Repr for RestrictionSet {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Rooting of managed boxes\n-//\n-// When we borrow the interior of a managed box, it is sometimes\n-// necessary to *root* the box, meaning to stash a copy of the box\n-// somewhere that the garbage collector will find it. This ensures\n-// that the box is not collected for the lifetime of the borrow.\n-//\n-// As part of this rooting, we sometimes also freeze the box at\n-// runtime, meaning that we dynamically detect when the box is\n-// borrowed in incompatible ways.\n-//\n-// Both of these actions are driven through the `root_map`, which maps\n-// from a node to the dynamic rooting action that should be taken when\n-// that node executes. The node is identified through a\n-// `root_map_key`, which pairs a node-id and a deref count---the\n-// problem is that sometimes the box that needs to be rooted is only\n-// uncovered after a certain number of auto-derefs.\n-\n-pub struct RootInfo {\n-    pub scope: ast::NodeId,\n-}\n-\n-pub type root_map = HashMap<root_map_key, RootInfo>;\n-\n ///////////////////////////////////////////////////////////////////////////\n // Errors\n \n // Errors that can occur\n #[deriving(Eq)]\n pub enum bckerr_code {\n     err_mutbl,\n-    err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n     err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n     err_borrowed_pointer_too_short(\n         ty::Region, ty::Region, RestrictionSet), // loan, ptr\n@@ -636,9 +616,6 @@ impl<'a> BorrowckCtxt<'a> {\n                     }\n                 }\n             }\n-            err_out_of_root_scope(..) => {\n-                format!(\"cannot root managed value long enough\")\n-            }\n             err_out_of_scope(..) => {\n                 let msg = match opt_loan_path(&err.cmt) {\n                     None => format!(\"borrowed value\"),\n@@ -718,19 +695,6 @@ impl<'a> BorrowckCtxt<'a> {\n         match code {\n             err_mutbl(..) => { }\n \n-            err_out_of_root_scope(super_scope, sub_scope) => {\n-                note_and_explain_region(\n-                    self.tcx,\n-                    \"managed value would have to be rooted for \",\n-                    sub_scope,\n-                    \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    \"...but can only be rooted for \",\n-                    super_scope,\n-                    \"\");\n-            }\n-\n             err_out_of_scope(super_scope, sub_scope) => {\n                 note_and_explain_region(\n                     self.tcx,"}, {"sha": "6a2262aeaef9f10c5276324bd961ba44d2cae006", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -24,7 +24,6 @@ use syntax::visit;\n use syntax::{ast, ast_map, ast_util};\n \n use std::cell::RefCell;\n-use collections::HashMap;\n use std::rc::Rc;\n \n //\n@@ -127,7 +126,6 @@ pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n             None => {}\n         }\n         let maps = astencode::Maps {\n-            root_map: HashMap::new(),\n             capture_map: RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n@@ -166,7 +164,6 @@ pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n             None => {}\n         }\n         let maps = astencode::Maps {\n-            root_map: HashMap::new(),\n             capture_map: RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, def_id,"}, {"sha": "1e44e1ab7f967b0a335d30e51872c08a135fc047", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -101,11 +101,6 @@ borrow checker and trans, for example, only care about the outermost\n expressions that are moved.  It is more efficient therefore just to\n store those entries.\n \n-Sometimes though we want to know the variables that are moved (in\n-particular in the borrow checker). For these cases, the set\n-`moved_variables_set` just collects the ids of variables that are\n-moved.\n-\n Finally, the `capture_map` maps from the node_id of a closure\n expression to an array of `CaptureVar` structs detailing which\n variables are captured and how (by ref, by copy, by move).\n@@ -170,7 +165,6 @@ pub struct MoveMaps {\n      * pub Note: The `moves_map` stores expression ids that are moves,\n      * whereas this set stores the ids of the variables that are\n      * moved at some point */\n-    pub moved_variables_set: NodeSet,\n     pub capture_map: CaptureMap\n }\n \n@@ -206,7 +200,6 @@ pub fn compute_moves(tcx: &ty::ctxt, krate: &Crate) -> MoveMaps {\n         tcx: tcx,\n         move_maps: MoveMaps {\n             moves_map: NodeSet::new(),\n-            moved_variables_set: NodeSet::new(),\n             capture_map: NodeMap::new()\n         }\n     };\n@@ -326,19 +319,6 @@ impl<'a> VisitContext<'a> {\n         debug!(\"comp_mode = {:?}\", comp_mode);\n \n         match expr.node {\n-            ExprPath(..) => {\n-                match comp_mode {\n-                    Move => {\n-                        let def = self.tcx.def_map.borrow().get_copy(&expr.id);\n-                        let r = moved_variable_node_id_from_def(def);\n-                        for &id in r.iter() {\n-                            self.move_maps.moved_variables_set.insert(id);\n-                        }\n-                    }\n-                    Read => {}\n-                }\n-            }\n-\n             ExprUnary(UnDeref, base) => {      // *base\n                 if !self.use_overloaded_operator(expr, base, []) {\n                     // Moving out of *base moves out of base.\n@@ -475,6 +455,7 @@ impl<'a> VisitContext<'a> {\n                 self.use_expr(base, Read);\n             }\n \n+            ExprPath(..) |\n             ExprInlineAsm(..) |\n             ExprBreak(..) |\n             ExprAgain(..) |"}, {"sha": "ddda95c06cb252db96cea6b019399cfd481f8d33", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -198,7 +198,6 @@ use back::abi;\n use driver::session::FullDebugInfo;\n use lib::llvm::{llvm, ValueRef, BasicBlockRef};\n use middle::const_eval;\n-use middle::borrowck::root_map_key;\n use middle::lang_items::{UniqStrEqFnLangItem, StrEqFnLangItem};\n use middle::pat_util::*;\n use middle::resolve::DefMap;\n@@ -1156,14 +1155,6 @@ fn collect_record_or_struct_fields<'a>(\n     }\n }\n \n-fn pats_require_rooting(bcx: &Block, m: &[Match], col: uint) -> bool {\n-    m.iter().any(|br| {\n-        let pat_id = br.pats.get(col).id;\n-        let key = root_map_key {id: pat_id, derefs: 0u };\n-        bcx.ccx().maps.root_map.contains_key(&key)\n-    })\n-}\n-\n // Macro for deciding whether any of the remaining matches fit a given kind of\n // pattern.  Note that, because the macro is well-typed, either ALL of the\n // matches should fit that sort of pattern or NONE (however, some of the\n@@ -1551,10 +1542,6 @@ fn compile_submatch_continue<'a, 'b>(\n         }\n     }\n \n-    // If we are not matching against an `@T`, we should not be\n-    // required to root any values.\n-    assert!(!pats_require_rooting(bcx, m, col));\n-\n     match collect_record_or_struct_fields(bcx, m, col) {\n         Some(ref rec_fields) => {\n             let pat_ty = node_id_type(bcx, pat_id);"}, {"sha": "0c7d36e0dbedf659fbbfeae312008f984349c7ab", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -640,7 +640,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 }\n             }\n         }\n-        ast_map::NodeMethod(method) => {\n+        ast_map::NodeMethod(ref method) => {\n             (method.ident,\n              method.decl,\n              &method.generics,\n@@ -667,9 +667,9 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                         \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n-        ast_map::NodeTraitMethod(trait_method) => {\n-            match *trait_method {\n-                ast::Provided(method) => {\n+        ast_map::NodeTraitMethod(ref trait_method) => {\n+            match **trait_method {\n+                ast::Provided(ref method) => {\n                     (method.ident,\n                      method.decl,\n                      &method.generics,"}, {"sha": "9bb0375bf44d27b93a1cefc5c0e84194c810a966", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -59,7 +59,6 @@ use middle::trans::meth;\n use middle::trans::inline;\n use middle::trans::tvec;\n use middle::trans::type_of;\n-use middle::trans::write_guard;\n use middle::ty::struct_fields;\n use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoObject, AutoUnsafe};\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef};\n@@ -1676,8 +1675,6 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n                   derefs: uint)\n                   -> DatumBlock<'a, Expr> {\n     let ccx = bcx.ccx();\n-    let bcx = write_guard::root_and_write_guard(&datum, bcx, expr.span,\n-                                                expr.id, derefs);\n \n     debug!(\"deref_once(expr={}, datum={}, derefs={})\",\n            expr.repr(bcx.tcx()),"}, {"sha": "f07adb1ed87c0b95a79cdcf5e5177c33477ddff9", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -15,7 +15,6 @@ pub mod monomorphize;\n pub mod controlflow;\n pub mod glue;\n pub mod datum;\n-pub mod write_guard;\n pub mod callee;\n pub mod expr;\n pub mod common;"}, {"sha": "8f114827bfd27223099eb18fcb41bd2d6a1bd9ab", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e01e78fd00c78fd3b7f92fb0d6d58e05801d5d38/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01e78fd00c78fd3b7f92fb0d6d58e05801d5d38/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=e01e78fd00c78fd3b7f92fb0d6d58e05801d5d38", "patch": "@@ -1,63 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Logic relating to rooting and write guards for managed values.\n-//! This code is primarily for use by datum;\n-//! it exists in its own module both to keep datum.rs bite-sized\n-//! and for each in debugging (e.g., so you can use\n-//! `RUST_LOG=rustc::middle::trans::write_guard`).\n-\n-\n-use middle::borrowck::{RootInfo, root_map_key};\n-use middle::trans::cleanup;\n-use middle::trans::common::*;\n-use middle::trans::datum::*;\n-use syntax::codemap::Span;\n-use syntax::ast;\n-\n-pub fn root_and_write_guard<'a, K:KindOps>(datum: &Datum<K>,\n-                                           bcx: &'a Block<'a>,\n-                                           span: Span,\n-                                           expr_id: ast::NodeId,\n-                                           derefs: uint) -> &'a Block<'a> {\n-    let key = root_map_key { id: expr_id, derefs: derefs };\n-    debug!(\"write_guard::root_and_write_guard(key={:?})\", key);\n-\n-    // root the autoderef'd value, if necessary:\n-    //\n-    // (Note: root'd values are always boxes)\n-    let ccx = bcx.ccx();\n-    match ccx.maps.root_map.find(&key) {\n-        None => bcx,\n-        Some(&root_info) => root(datum, bcx, span, key, root_info)\n-    }\n-}\n-\n-fn root<'a, K:KindOps>(datum: &Datum<K>,\n-                       bcx: &'a Block<'a>,\n-                       _span: Span,\n-                       root_key: root_map_key,\n-                       root_info: RootInfo) -> &'a Block<'a> {\n-    //! In some cases, borrowck will decide that an @T value must be\n-    //! rooted for the program to be safe.  In that case, we will call\n-    //! this function, which will stash a copy away until we exit the\n-    //! scope `scope_id`.\n-\n-    debug!(\"write_guard::root(root_key={:?}, root_info={:?}, datum={:?})\",\n-           root_key, root_info, datum.to_str(bcx.ccx()));\n-\n-    // Root the datum. Note that we must zero this value,\n-    // because sometimes we root on one path but not another.\n-    // See e.g. #4904.\n-    lvalue_scratch_datum(\n-        bcx, datum.ty, \"__write_guard\", true,\n-        cleanup::AstScope(root_info.scope), (),\n-        |(), bcx, llval| datum.shallow_copy_and_take(bcx, llval)).bcx\n-}"}, {"sha": "9f36e903e5886461048e926246456cefa9f26f4f", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -1277,12 +1277,12 @@ fn link_region(rcx: &Rcx,\n             }\n             mc::cat_discr(cmt_base, _) |\n             mc::cat_downcast(cmt_base) |\n+            mc::cat_deref(cmt_base, _, mc::GcPtr(..)) |\n             mc::cat_deref(cmt_base, _, mc::OwnedPtr) |\n             mc::cat_interior(cmt_base, _) => {\n                 // Interior or owned data requires its base to be valid\n                 cmt_borrowed = cmt_base;\n             }\n-            mc::cat_deref(_, _, mc::GcPtr(..)) |\n             mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n             mc::cat_static_item |\n             mc::cat_copied_upvar(..) |"}, {"sha": "df102b8aadf3f455e2731c56d0a1e7a2f61cc2e1", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -674,14 +674,16 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n         let parent = self.tcx.map.get_parent(scope_id);\n         let parent_node = self.tcx.map.find(parent);\n         let node_inner = match parent_node {\n-            Some(node) => match node {\n-                ast_map::NodeItem(item) => match item.node {\n-                    ast::ItemFn(ref fn_decl, ref pur, _, ref gen, _) => {\n-                        Some((fn_decl, gen, *pur, item.ident, None, item.span))\n-                    },\n-                    _ => None\n-                },\n-                ast_map::NodeMethod(m) => {\n+            Some(ref node) => match *node {\n+                ast_map::NodeItem(ref item) => {\n+                    match item.node {\n+                        ast::ItemFn(ref fn_decl, ref pur, _, ref gen, _) => {\n+                            Some((fn_decl, gen, *pur, item.ident, None, item.span))\n+                        },\n+                        _ => None\n+                    }\n+                }\n+                ast_map::NodeMethod(ref m) => {\n                     Some((&m.decl, &m.generics, m.fn_style,\n                           m.ident, Some(m.explicit_self.node), m.span))\n                 },"}, {"sha": "be05ccdfcb41209576d17ad5cc03afd6d22d20f7", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -684,7 +684,8 @@ impl Clean<Type> for ast::Ty {\n     fn clean(&self) -> Type {\n         use syntax::ast::*;\n         debug!(\"cleaning type `{:?}`\", self);\n-        let codemap = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess().codemap();\n+        let ctxt = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+        let codemap = ctxt.sess().codemap();\n         debug!(\"span corresponds to `{}`\", codemap.span_to_str(self.span));\n         match self.node {\n             TyNil => Unit,\n@@ -866,7 +867,8 @@ pub struct Span {\n \n impl Clean<Span> for syntax::codemap::Span {\n     fn clean(&self) -> Span {\n-        let cm = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess().codemap();\n+        let ctxt = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+        let cm = ctxt.sess().codemap();\n         let filename = cm.span_to_filename(*self);\n         let lo = cm.lookup_char_pos(self.lo);\n         let hi = cm.lookup_char_pos(self.hi);\n@@ -1193,7 +1195,8 @@ trait ToSource {\n impl ToSource for syntax::codemap::Span {\n     fn to_src(&self) -> ~str {\n         debug!(\"converting span {:?} to snippet\", self.clean());\n-        let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess().codemap().clone();\n+        let ctxt = local_data::get(super::ctxtkey, |x| x.unwrap().clone());\n+        let cm = ctxt.sess().codemap().clone();\n         let sn = match cm.span_to_snippet(*self) {\n             Some(x) => x,\n             None    => \"\".to_owned()"}, {"sha": "865c3be4ae6469c1a5ee0b00b621d1498a8d4a95", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -363,14 +363,15 @@ impl Map {\n     }\n \n     pub fn with_attrs<T>(&self, id: NodeId, f: |Option<&[Attribute]>| -> T) -> T {\n-        let attrs = match self.get(id) {\n-            NodeItem(i) => Some(i.attrs.as_slice()),\n-            NodeForeignItem(fi) => Some(fi.attrs.as_slice()),\n-            NodeTraitMethod(tm) => match *tm {\n+        let node = self.get(id);\n+        let attrs = match node {\n+            NodeItem(ref i) => Some(i.attrs.as_slice()),\n+            NodeForeignItem(ref fi) => Some(fi.attrs.as_slice()),\n+            NodeTraitMethod(ref tm) => match **tm {\n                 Required(ref type_m) => Some(type_m.attrs.as_slice()),\n-                Provided(m) => Some(m.attrs.as_slice())\n+                Provided(ref m) => Some(m.attrs.as_slice())\n             },\n-            NodeMethod(m) => Some(m.attrs.as_slice()),\n+            NodeMethod(ref m) => Some(m.attrs.as_slice()),\n             NodeVariant(ref v) => Some(v.node.attrs.as_slice()),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition."}, {"sha": "bf886e51885d595452e097938196238139b55c55", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -808,26 +808,25 @@ impl<'a> MethodDef<'a> {\n                                 \"no self match on an enum in \\\n                                 generic `deriving`\");\n             }\n+\n+            // `ref` inside let matches is buggy. Causes havoc wih rusc.\n+            // let (variant_index, ref self_vec) = matches_so_far[0];\n+            let (variant, self_vec) = match matches_so_far.get(0) {\n+                &(_, v, ref s) => (v, s)\n+            };\n+\n             // we currently have a vec of vecs, where each\n             // subvec is the fields of one of the arguments,\n             // but if the variants all match, we want this as\n             // vec of tuples, where each tuple represents a\n             // field.\n \n-            let substructure;\n-\n             // most arms don't have matching variants, so do a\n             // quick check to see if they match (even though\n             // this means iterating twice) instead of being\n             // optimistic and doing a pile of allocations etc.\n-            match matching {\n+            let substructure = match matching {\n                 Some(variant_index) => {\n-                    // `ref` inside let matches is buggy. Causes havoc wih rusc.\n-                    // let (variant_index, ref self_vec) = matches_so_far[0];\n-                    let (variant, self_vec) = match matches_so_far.get(0) {\n-                        &(_, v, ref s) => (v, s)\n-                    };\n-\n                     let mut enum_matching_fields = Vec::from_elem(self_vec.len(), Vec::new());\n \n                     for triple in matches_so_far.tail().iter() {\n@@ -850,12 +849,12 @@ impl<'a> MethodDef<'a> {\n                             other: (*other).clone()\n                         }\n                     }).collect();\n-                    substructure = EnumMatching(variant_index, variant, field_tuples);\n+                    EnumMatching(variant_index, variant, field_tuples)\n                 }\n                 None => {\n-                    substructure = EnumNonMatching(matches_so_far.as_slice());\n+                    EnumNonMatching(matches_so_far.as_slice())\n                 }\n-            }\n+            };\n             self.call_substructure_method(cx, trait_, type_ident,\n                                           self_args, nonself_args,\n                                           &substructure)"}, {"sha": "4695360a688deeee69c8d38fdb9f484a8322f4b9", "filename": "src/test/compile-fail/borrowck-managed-pointer-deref-scope.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fborrowck-managed-pointer-deref-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fborrowck-managed-pointer-deref-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-managed-pointer-deref-scope.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Verify that managed pointers scope is treated like ownoed pointers.\n+// regresion test for #11586\n+\n+#![feature(managed_boxes)]\n+\n+fn foo<'a>(x: &'a @int) -> &'a int {\n+    match x {\n+        &ref y => {\n+            &**y // Do not expect an error here\n+        }\n+    }\n+}\n+\n+fn bar() {\n+    let a = 3;\n+    let mut y = &a;\n+    if true {\n+        let x = @3;\n+        y = &*x; //~ ERROR `*x` does not live long enough\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ff138451e93f2d904de5baf283ec629ad51283e5", "filename": "src/test/compile-fail/borrowck-preserve-box-in-field.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-field.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -26,8 +26,10 @@ struct F { f: ~int }\n pub fn main() {\n     let mut x = @F {f: ~3};\n     borrow(x.f, |b_x| {\n+    //~^ ERROR cannot borrow `x` as mutable because `*x.f` is also borrowed as immutable\n         assert_eq!(*b_x, 3);\n         assert_eq!(&(*x.f) as *int, &(*b_x) as *int);\n+        //~^ NOTE borrow occurs due to use of `x` in closure\n         x = @F {f: ~4};\n \n         println!(\"&*b_x = {:p}\", &(*b_x));", "previous_filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs"}, {"sha": "b06eb0d6ba23a14caa784fa794c335431a2bb684", "filename": "src/test/compile-fail/borrowck-preserve-box-in-uniq.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-uniq.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -26,8 +26,10 @@ struct F { f: ~int }\n pub fn main() {\n     let mut x = ~@F{f: ~3};\n     borrow(x.f, |b_x| {\n+    //~^ ERROR cannot borrow `x` as mutable because `*x.f` is also borrowed as immutable\n         assert_eq!(*b_x, 3);\n         assert_eq!(&(*x.f) as *int, &(*b_x) as *int);\n+        //~^ NOTE  borrow occurs due to use of `x` in closure\n         *x = @F{f: ~4};\n \n         println!(\"&*b_x = {:p}\", &(*b_x));", "previous_filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs"}, {"sha": "1a920c7871e1cecc421141e75fb2561aaca689d2", "filename": "src/test/compile-fail/borrowck-preserve-box.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -24,8 +24,10 @@ fn borrow(x: &int, f: |x: &int|) {\n pub fn main() {\n     let mut x = @3;\n     borrow(x, |b_x| {\n+    //~^ ERROR cannot borrow `x` as mutable because `*x` is also borrowed as immutable\n         assert_eq!(*b_x, 3);\n         assert_eq!(&(*x) as *int, &(*b_x) as *int);\n+        //~^ NOTE borrow occurs due to use of `x` in closure\n         x = @22;\n \n         println!(\"&*b_x = {:p}\", &(*b_x));", "previous_filename": "src/test/run-pass/borrowck-preserve-box.rs"}, {"sha": "7000e2351dd91bacedfb97fe38c1d26f42f15ebd", "filename": "src/test/compile-fail/borrowck-preserve-cond-box.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-cond-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-cond-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-cond-box.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -30,8 +30,8 @@ fn testfn(cond: bool) {\n     println!(\"*r = {}, exp = {}\", *r, exp);\n     assert_eq!(*r, exp);\n \n-    x = @5;\n-    y = @6;\n+    x = @5; //~ERROR cannot assign to `x` because it is borrowed\n+    y = @6; //~ERROR cannot assign to `y` because it is borrowed\n \n     println!(\"*r = {}, exp = {}\", *r, exp);\n     assert_eq!(*r, exp);", "previous_filename": "src/test/run-pass/borrowck-preserve-cond-box.rs"}, {"sha": "aeabf6d9f8b559329119e6717f82f5ba922ab93e", "filename": "src/test/compile-fail/borrowck-preserve-expl-deref.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-expl-deref.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -26,8 +26,10 @@ struct F { f: ~int }\n pub fn main() {\n     let mut x = @F {f: ~3};\n     borrow((*x).f, |b_x| {\n+    //~^ ERROR cannot borrow `x` as mutable because `*x.f` is also borrowed as immutable\n         assert_eq!(*b_x, 3);\n         assert_eq!(&(*x.f) as *int, &(*b_x) as *int);\n+        //~^ NOTE borrow occurs due to use of `x` in closure\n         x = @F {f: ~4};\n \n         println!(\"&*b_x = {:p}\", &(*b_x));", "previous_filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs"}, {"sha": "68bbebb8cb048bafafe685c916816a261c87eae4", "filename": "src/test/compile-fail/regions-appearance-constraint.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fregions-appearance-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fregions-appearance-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-appearance-constraint.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/* Tests conditional rooting of the box y */\n+// Test no-special rooting is used for managed boxes\n \n #![feature(managed_boxes)]\n \n@@ -25,12 +25,11 @@ fn testfn(cond: bool) {\n         exp = 4;\n     }\n \n-    x = @5;\n-    y = @6;\n+    x = @5; //~ERROR cannot assign to `x` because it is borrowed\n+    y = @6; //~ERROR cannot assign to `y` because it is borrowed\n     assert_eq!(*a, exp);\n     assert_eq!(x, @5);\n     assert_eq!(y, @6);\n }\n \n-pub fn main() {\n-}\n+pub fn main() {}", "previous_filename": "src/test/run-pass/regions-appearance-constraint.rs"}, {"sha": "1508349344c9a2125d71ae123fa3820793ef9811", "filename": "src/test/compile-fail/regions-infer-borrow-scope-too-big.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -20,7 +20,7 @@ fn x_coord<'r>(p: &'r point) -> &'r int {\n }\n \n fn foo(p: @point) -> &int {\n-    let xc = x_coord(p); //~ ERROR cannot root\n+    let xc = x_coord(p); //~ ERROR `*p` does not live long enough\n     assert_eq!(*xc, 3);\n     return xc;\n }"}, {"sha": "3cd70ce6c8a31511a141abbc80ac3c7aac6de492", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -19,7 +19,7 @@ fn foo(cond: || -> bool, make_box: || -> @int) {\n \n         // Here we complain because the resulting region\n         // of this borrow is the fn body as a whole.\n-        y = borrow(x); //~ ERROR cannot root\n+        y = borrow(x); //~ ERROR `*x` does not live long enough\n \n         assert_eq!(*x, *y);\n         if cond() { break; }"}, {"sha": "68a17266106561ac4fa3b16cc128224416444726", "filename": "src/test/compile-fail/struct-field-assignability.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fstruct-field-assignability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a5d7c32ca863533e53175da8afab6ba8d20f30/src%2Ftest%2Fcompile-fail%2Fstruct-field-assignability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-field-assignability.rs?ref=f5a5d7c32ca863533e53175da8afab6ba8d20f30", "patch": "@@ -15,6 +15,6 @@ struct Foo<'a> {\n }\n \n pub fn main() {\n-    let f = Foo { x: @3 };\n+    let f = Foo { x: @3 }; //~ ERROR borrowed value does not live long enough\n     assert_eq!(*f.x, 3);\n }", "previous_filename": "src/test/run-pass/struct-field-assignability.rs"}]}