{"sha": "155399382e45d404f208482b61e10f5ac266a4ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NTM5OTM4MmU0NWQ0MDRmMjA4NDgyYjYxZTEwZjVhYzI2NmE0ZWM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-01T09:46:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-09-01T09:46:01Z"}, "message": "Merge pull request #445 from solson/rustup\n\nRustup", "tree": {"sha": "454cbf9c5174e74dff4b4ae4c77ce02324b767b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/454cbf9c5174e74dff4b4ae4c77ce02324b767b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/155399382e45d404f208482b61e10f5ac266a4ec", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbil/ZCRBK7hj4Ov3rIwAAdHIIAAJSADkEcJ55dnWeBEdb2BF/\nzqqaDD98YK4FeilBCZFNBJzuhLTv0nbk1IRTxVk7ahSzAFWwrxBPlbQMHHXbhPV7\nvqs6K6Z/QNVBNAwLImJx8eS9Z24t7KHYwBKPOksX2dxPX7Modv2iBQ4eGKFwBjUD\nE2bhUK0LbcMGM+DyM2DBR5tOHdVQfYHpPJ6r+RlViJ06jP/3ZT/LFMSGLIpIag0K\nTklQ6bckjJwq9Fw2JSD9B9cBhfBndOzIB23CS7I5Jlnk054MK/YAgmmI83QgH+DU\nfK5b9e0rnj/x07kF0vPfhA7od6rT7tpvk65VH+zucJKZzYz6dqR21cN15Un6chU=\n=S2EY\n-----END PGP SIGNATURE-----\n", "payload": "tree 454cbf9c5174e74dff4b4ae4c77ce02324b767b0\nparent ece98ea8b640c8db8d6d9c444989bfaa9be514eb\nparent d3928f6356de808b1df402cc66e9e6d36a9dce8c\nauthor Ralf Jung <post@ralfj.de> 1535795161 +0200\ncommitter GitHub <noreply@github.com> 1535795161 +0200\n\nMerge pull request #445 from solson/rustup\n\nRustup"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/155399382e45d404f208482b61e10f5ac266a4ec", "html_url": "https://github.com/rust-lang/rust/commit/155399382e45d404f208482b61e10f5ac266a4ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/155399382e45d404f208482b61e10f5ac266a4ec/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ece98ea8b640c8db8d6d9c444989bfaa9be514eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ece98ea8b640c8db8d6d9c444989bfaa9be514eb", "html_url": "https://github.com/rust-lang/rust/commit/ece98ea8b640c8db8d6d9c444989bfaa9be514eb"}, {"sha": "d3928f6356de808b1df402cc66e9e6d36a9dce8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3928f6356de808b1df402cc66e9e6d36a9dce8c", "html_url": "https://github.com/rust-lang/rust/commit/d3928f6356de808b1df402cc66e9e6d36a9dce8c"}], "stats": {"total": 356, "additions": 158, "deletions": 198}, "files": [{"sha": "448c24468e5c0060b41038706fb00f5bc3a5acd9", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -1 +1 @@\n-nightly-2018-08-30\n+nightly-2018-09-01"}, {"sha": "0e768fcccf9e5c561fea2e6af0ba18a011cc9bf2", "filename": "src/fn_call.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                 };\n \n                 self.write_scalar(\n-                    Scalar::from_i32(result),\n+                    Scalar::from_int(result, Size::from_bits(32)),\n                     dest,\n                 )?;\n             }\n@@ -346,7 +346,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     match self.machine.env_vars.get(name) {\n                         Some(&var) => Scalar::Ptr(var),\n-                        None => Scalar::null(self.memory.pointer_size()),\n+                        None => Scalar::ptr_null(*self.tcx),\n                     }\n                 };\n                 self.write_scalar(result, dest)?;\n@@ -446,7 +446,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n \n             // Some things needed for sys::thread initialization to go through\n             \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n-                self.write_scalar(Scalar::null(dest.layout.size), dest)?;\n+                self.write_scalar(Scalar::from_int(0, dest.layout.size), dest)?;\n             }\n \n             \"sysconf\" => {\n@@ -729,6 +729,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for EvalContext<'a, '\n     }\n \n     fn write_null(&mut self, dest: PlaceTy<'tcx>) -> EvalResult<'tcx> {\n-        self.write_scalar(Scalar::null(dest.layout.size), dest)\n+        self.write_scalar(Scalar::from_int(0, dest.layout.size), dest)\n     }\n }"}, {"sha": "27b2109d18a16a5d0af36959e147a7f1ae27e335", "filename": "src/helpers.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -1,57 +1,12 @@\n-use rustc::ty::layout::Size;\n-\n use super::{Scalar, ScalarMaybeUndef, EvalResult};\n \n-pub trait ScalarExt {\n-    fn null(size: Size) -> Self;\n-    fn from_i32(i: i32) -> Self;\n-    fn from_uint(i: impl Into<u128>, ptr_size: Size) -> Self;\n-    fn from_int(i: impl Into<i128>, ptr_size: Size) -> Self;\n-    fn from_f32(f: f32) -> Self;\n-    fn from_f64(f: f64) -> Self;\n-    fn is_null(self) -> bool;\n-}\n-\n pub trait FalibleScalarExt {\n     /// HACK: this function just extracts all bits if `defined != 0`\n     /// Mainly used for args of C-functions and we should totally correctly fetch the size\n     /// of their arguments\n     fn to_bytes(self) -> EvalResult<'static, u128>;\n }\n \n-impl ScalarExt for Scalar {\n-    fn null(size: Size) -> Self {\n-        Scalar::Bits { bits: 0, size: size.bytes() as u8 }\n-    }\n-\n-    fn from_i32(i: i32) -> Self {\n-        Scalar::Bits { bits: i as u32 as u128, size: 4 }\n-    }\n-\n-    fn from_uint(i: impl Into<u128>, size: Size) -> Self {\n-        Scalar::Bits { bits: i.into(), size: size.bytes() as u8 }\n-    }\n-\n-    fn from_int(i: impl Into<i128>, size: Size) -> Self {\n-        Scalar::Bits { bits: i.into() as u128, size: size.bytes() as u8 }\n-    }\n-\n-    fn from_f32(f: f32) -> Self {\n-        Scalar::Bits { bits: f.to_bits() as u128, size: 4 }\n-    }\n-\n-    fn from_f64(f: f64) -> Self {\n-        Scalar::Bits { bits: f.to_bits() as u128, size: 8 }\n-    }\n-\n-    fn is_null(self) -> bool {\n-        match self {\n-            Scalar::Bits { bits, .. } => bits == 0,\n-            Scalar::Ptr(_) => false\n-        }\n-    }\n-}\n-\n impl FalibleScalarExt for Scalar {\n     fn to_bytes(self) -> EvalResult<'static, u128> {\n         match self {"}, {"sha": "1b877256c31fac99ca777a6231d6a1935b27265b", "filename": "src/intrinsic.rs", "status": "modified", "additions": 30, "deletions": 47, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -2,12 +2,12 @@ use rustc::mir;\n use rustc::ty::layout::{self, LayoutOf, Size};\n use rustc::ty;\n \n-use rustc::mir::interpret::{EvalResult, Scalar, ScalarMaybeUndef};\n+use rustc::mir::interpret::{EvalResult, Scalar, ScalarMaybeUndef, PointerArithmetic};\n use rustc_mir::interpret::{\n     PlaceTy, EvalContext, OpTy, Value\n };\n \n-use super::{ScalarExt, FalibleScalarExt, OperatorEvalContextExt};\n+use super::{FalibleScalarExt, OperatorEvalContextExt};\n \n pub trait EvalContextExt<'tcx> {\n     fn call_intrinsic(\n@@ -116,11 +116,11 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n-                let expect_old = self.read_value(args[1])?; // read as value for the sake of `binary_op()`\n+                let expect_old = self.read_value(args[1])?; // read as value for the sake of `binary_op_val()`\n                 let new = self.read_scalar(args[2])?;\n-                let old = self.read_value(ptr.into())?; // read as value for the sake of `binary_op()`\n-                // binary_op will bail if either of them is not a scalar\n-                let (eq, _) = self.binary_op(mir::BinOp::Eq, old, expect_old)?;\n+                let old = self.read_value(ptr.into())?; // read as value for the sake of `binary_op_val()`\n+                // binary_op_val will bail if either of them is not a scalar\n+                let (eq, _) = self.binary_op_val(mir::BinOp::Eq, old, expect_old)?;\n                 let res = Value::ScalarPair(old.to_scalar_or_undef(), eq.into());\n                 self.write_value(res, dest)?; // old value is returned\n                 // update ptr depending on comparison\n@@ -167,8 +167,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     _ => bug!(),\n                 };\n                 // FIXME: what do atomics do on overflow?\n-                let (val, _) = self.binary_op(op, old, rhs)?;\n-                self.write_scalar(val, ptr.into())?;\n+                self.binop_ignore_overflow(op, old, rhs, ptr.into())?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -204,8 +203,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             \"sinf32\" | \"fabsf32\" | \"cosf32\" | \"sqrtf32\" | \"expf32\" | \"exp2f32\" | \"logf32\" |\n             \"log10f32\" | \"log2f32\" | \"floorf32\" | \"ceilf32\" | \"truncf32\" => {\n-                let f = self.read_scalar(args[0])?.to_bytes()?;\n-                let f = f32::from_bits(f as u32);\n+                let f = self.read_scalar(args[0])?.to_f32()?;\n                 let f = match intrinsic_name {\n                     \"sinf32\" => f.sin(),\n                     \"fabsf32\" => f.abs(),\n@@ -226,8 +224,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             \"sinf64\" | \"fabsf64\" | \"cosf64\" | \"sqrtf64\" | \"expf64\" | \"exp2f64\" | \"logf64\" |\n             \"log10f64\" | \"log2f64\" | \"floorf64\" | \"ceilf64\" | \"truncf64\" => {\n-                let f = self.read_scalar(args[0])?.to_bytes()?;\n-                let f = f64::from_bits(f as u64);\n+                let f = self.read_scalar(args[0])?.to_f64()?;\n                 let f = match intrinsic_name {\n                     \"sinf64\" => f.sin(),\n                     \"fabsf64\" => f.abs(),\n@@ -257,8 +254,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     \"frem_fast\" => mir::BinOp::Rem,\n                     _ => bug!(),\n                 };\n-                let result = self.binary_op(op, a, b)?;\n-                self.write_scalar(result.0, dest)?;\n+                self.binop_ignore_overflow(op, a, b, dest)?;\n             }\n \n             \"exact_div\" => {\n@@ -267,11 +263,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let a = self.read_value(args[0])?;\n                 let b = self.read_value(args[1])?;\n                 // check x % y != 0\n-                if !self.binary_op(mir::BinOp::Rem, a, b)?.0.is_null() {\n+                if !self.binary_op_val(mir::BinOp::Rem, a, b)?.0.is_null() {\n                     return err!(ValidationFailure(format!(\"exact_div: {:?} cannot be divided by {:?}\", a, b)));\n                 }\n-                let result = self.binary_op(mir::BinOp::Div, a, b)?;\n-                self.write_scalar(result.0, dest)?;\n+                self.binop_ignore_overflow(mir::BinOp::Div, a, b, dest)?;\n             },\n \n             \"likely\" | \"unlikely\" | \"forget\" => {}\n@@ -282,12 +277,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 if !dest.layout.is_zst() { // notzhing to do for ZST\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(ref s) => {\n-                            let x = Scalar::null(s.value.size(&self));\n+                            let x = Scalar::from_int(0, s.value.size(&self));\n                             self.write_value(Value::Scalar(x.into()), dest)?;\n                         }\n                         layout::Abi::ScalarPair(ref s1, ref s2) => {\n-                            let x = Scalar::null(s1.value.size(&self));\n-                            let y = Scalar::null(s2.value.size(&self));\n+                            let x = Scalar::from_int(0, s1.value.size(&self));\n+                            let y = Scalar::from_int(0, s2.value.size(&self));\n                             self.write_value(Value::ScalarPair(x.into(), y.into()), dest)?;\n                         }\n                         _ => {\n@@ -304,7 +299,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let ty = substs.type_at(0);\n                 let layout = self.layout_of(ty)?;\n                 let align = layout.align.pref();\n-                let ptr_size = self.memory.pointer_size();\n+                let ptr_size = self.pointer_size();\n                 let align_val = Scalar::from_uint(align as u128, ptr_size);\n                 self.write_scalar(align_val, dest)?;\n             }\n@@ -365,56 +360,45 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             }\n \n             \"powf32\" => {\n-                let f = self.read_scalar(args[0])?.to_bits(Size::from_bits(32))?;\n-                let f = f32::from_bits(f as u32);\n-                let f2 = self.read_scalar(args[1])?.to_bits(Size::from_bits(32))?;\n-                let f2 = f32::from_bits(f2 as u32);\n+                let f = self.read_scalar(args[0])?.to_f32()?;\n+                let f2 = self.read_scalar(args[1])?.to_f32()?;\n                 self.write_scalar(\n                     Scalar::from_f32(f.powf(f2)),\n                     dest,\n                 )?;\n             }\n \n             \"powf64\" => {\n-                let f = self.read_scalar(args[0])?.to_bits(Size::from_bits(64))?;\n-                let f = f64::from_bits(f as u64);\n-                let f2 = self.read_scalar(args[1])?.to_bits(Size::from_bits(64))?;\n-                let f2 = f64::from_bits(f2 as u64);\n+                let f = self.read_scalar(args[0])?.to_f64()?;\n+                let f2 = self.read_scalar(args[1])?.to_f64()?;\n                 self.write_scalar(\n                     Scalar::from_f64(f.powf(f2)),\n                     dest,\n                 )?;\n             }\n \n             \"fmaf32\" => {\n-                let a = self.read_scalar(args[0])?.to_bits(Size::from_bits(32))?;\n-                let a = f32::from_bits(a as u32);\n-                let b = self.read_scalar(args[1])?.to_bits(Size::from_bits(32))?;\n-                let b = f32::from_bits(b as u32);\n-                let c = self.read_scalar(args[2])?.to_bits(Size::from_bits(32))?;\n-                let c = f32::from_bits(c as u32);\n+                let a = self.read_scalar(args[0])?.to_f32()?;\n+                let b = self.read_scalar(args[1])?.to_f32()?;\n+                let c = self.read_scalar(args[2])?.to_f32()?;\n                 self.write_scalar(\n                     Scalar::from_f32(a * b + c),\n                     dest,\n                 )?;\n             }\n \n             \"fmaf64\" => {\n-                let a = self.read_scalar(args[0])?.to_bits(Size::from_bits(64))?;\n-                let a = f64::from_bits(a as u64);\n-                let b = self.read_scalar(args[1])?.to_bits(Size::from_bits(64))?;\n-                let b = f64::from_bits(b as u64);\n-                let c = self.read_scalar(args[2])?.to_bits(Size::from_bits(64))?;\n-                let c = f64::from_bits(c as u64);\n+                let a = self.read_scalar(args[0])?.to_f64()?;\n+                let b = self.read_scalar(args[1])?.to_f64()?;\n+                let c = self.read_scalar(args[2])?.to_f64()?;\n                 self.write_scalar(\n                     Scalar::from_f64(a * b + c),\n                     dest,\n                 )?;\n             }\n \n             \"powif32\" => {\n-                let f = self.read_scalar(args[0])?.to_bits(Size::from_bits(32))?;\n-                let f = f32::from_bits(f as u32);\n+                let f = self.read_scalar(args[0])?.to_f32()?;\n                 let i = self.read_scalar(args[1])?.to_i32()?;\n                 self.write_scalar(\n                     Scalar::from_f32(f.powi(i)),\n@@ -423,8 +407,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             }\n \n             \"powif64\" => {\n-                let f = self.read_scalar(args[0])?.to_bits(Size::from_bits(64))?;\n-                let f = f64::from_bits(f as u64);\n+                let f = self.read_scalar(args[0])?.to_f64()?;\n                 let i = self.read_scalar(args[1])?.to_i32()?;\n                 self.write_scalar(\n                     Scalar::from_f64(f.powi(i)),\n@@ -435,7 +418,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"size_of_val\" => {\n                 let mplace = self.ref_to_mplace(self.read_value(args[0])?)?;\n                 let (size, _) = self.size_and_align_of_mplace(mplace)?;\n-                let ptr_size = self.memory.pointer_size();\n+                let ptr_size = self.pointer_size();\n                 self.write_scalar(\n                     Scalar::from_uint(size.bytes() as u128, ptr_size),\n                     dest,\n@@ -446,7 +429,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"align_of_val\" => {\n                 let mplace = self.ref_to_mplace(self.read_value(args[0])?)?;\n                 let (_, align) = self.size_and_align_of_mplace(mplace)?;\n-                let ptr_size = self.memory.pointer_size();\n+                let ptr_size = self.pointer_size();\n                 self.write_scalar(\n                     Scalar::from_uint(align.abi(), ptr_size),\n                     dest,"}, {"sha": "b8d3c18c01cba4a8b69856e427c29c9f5bed9d63", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -46,7 +46,7 @@ use tls::EvalContextExt as TlsEvalContextExt;\n use memory::MemoryKind as MiriMemoryKind;\n use locks::LockInfo;\n use range_map::RangeMap;\n-use helpers::{ScalarExt, FalibleScalarExt};\n+use helpers::FalibleScalarExt;\n \n pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -304,14 +304,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         ecx.call_intrinsic(instance, args, dest)\n     }\n \n-    fn try_ptr_op<'a>(\n+    fn ptr_op<'a>(\n         ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: Scalar,\n         left_layout: TyLayout<'tcx>,\n         right: Scalar,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n         ecx.ptr_op(bin_op, left, left_layout, right, right_layout)\n     }\n "}, {"sha": "4f697dbd5b7483118fe1c442a74934aaef7f99af", "filename": "src/operator.rs", "status": "modified", "additions": 87, "deletions": 82, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -1,5 +1,4 @@\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{TyLayout, Primitive};\n+use rustc::ty::{Ty, layout::TyLayout};\n use rustc::mir;\n \n use super::*;\n@@ -12,7 +11,7 @@ pub trait EvalContextExt<'tcx> {\n         left_layout: TyLayout<'tcx>,\n         right: Scalar,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n+    ) -> EvalResult<'tcx, (Scalar, bool)>;\n \n     fn ptr_int_arithmetic(\n         &self,\n@@ -22,6 +21,13 @@ pub trait EvalContextExt<'tcx> {\n         signed: bool,\n     ) -> EvalResult<'tcx, (Scalar, bool)>;\n \n+    fn ptr_eq(\n+        &self,\n+        left: Scalar,\n+        right: Scalar,\n+        size: Size,\n+    ) -> EvalResult<'tcx, bool>;\n+\n     fn pointer_offset_inbounds(\n         &self,\n         ptr: Scalar,\n@@ -38,131 +44,130 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         left_layout: TyLayout<'tcx>,\n         right: Scalar,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        use rustc::mir::BinOp::*;\n+\n         trace!(\"ptr_op: {:?} {:?} {:?}\", left, bin_op, right);\n+        debug_assert!(left.is_ptr() || right.is_ptr() || bin_op == Offset);\n \n-        use rustc::mir::BinOp::*;\n-        use rustc::ty::layout::Integer::*;\n-        let usize = Primitive::Int(match self.memory.pointer_size().bytes() {\n-            1 => I8,\n-            2 => I16,\n-            4 => I32,\n-            8 => I64,\n-            16 => I128,\n-            _ => unreachable!(),\n-        }, /*signed*/ false);\n-        let isize = Primitive::Int(match self.memory.pointer_size().bytes() {\n-            1 => I8,\n-            2 => I16,\n-            4 => I32,\n-            8 => I64,\n-            16 => I128,\n-            _ => unreachable!(),\n-        }, /*signed*/ true);\n-        let left_kind = match left_layout.abi {\n-            ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => Err(EvalErrorKind::TypeNotPrimitive(left_layout.ty))?,\n-        };\n-        let right_kind = match right_layout.abi {\n-            ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => Err(EvalErrorKind::TypeNotPrimitive(right_layout.ty))?,\n-        };\n         match bin_op {\n             Offset => {\n-                assert!(left_kind == Primitive::Pointer && right_kind == usize);\n                 let pointee_ty = left_layout.ty\n                     .builtin_deref(true)\n                     .expect(\"Offset called on non-ptr type\")\n                     .ty;\n                 let ptr = self.pointer_offset_inbounds(\n                     left,\n                     pointee_ty,\n-                    right.to_bits(self.memory.pointer_size())? as i64,\n+                    right.to_isize(self)?,\n                 )?;\n-                Ok(Some((ptr, false)))\n+                Ok((ptr, false))\n             }\n             // These work on anything\n-            Eq if left_kind == right_kind => {\n-                let result = match (left, right) {\n-                    (Scalar::Bits { .. }, Scalar::Bits { .. }) => {\n-                        left.to_bits(left_layout.size)? == right.to_bits(right_layout.size)?\n-                    },\n-                    // FIXME: Test if both allocations are still live *or* if they are in the same allocation? (same for Ne below)\n-                    (Scalar::Ptr(left), Scalar::Ptr(right)) => left == right,\n-                    // FIXME: We should probably error out when comparing anything but NULL with a pointer (same for Ne below)\n-                    _ => false,\n-                };\n-                Ok(Some((Scalar::from_bool(result), false)))\n-            }\n-            Ne if left_kind == right_kind => {\n-                let result = match (left, right) {\n-                    (Scalar::Bits { .. }, Scalar::Bits { .. }) => {\n-                        left.to_bits(left_layout.size)? != right.to_bits(right_layout.size)?\n-                    },\n-                    (Scalar::Ptr(left), Scalar::Ptr(right)) => left != right,\n-                    _ => true,\n-                };\n-                Ok(Some((Scalar::from_bool(result), false)))\n-            }\n-            // These need both pointers to be in the same allocation\n-            Lt | Le | Gt | Ge | Sub\n-                if left_kind == right_kind &&\n-                       (left_kind == Primitive::Pointer || left_kind == usize || left_kind == isize) &&\n-                       left.is_ptr() && right.is_ptr() => {\n-                let left = left.to_ptr()?;\n-                let right = right.to_ptr()?;\n+            Eq =>\n+                Ok((Scalar::from_bool(self.ptr_eq(left, right, left_layout.size)?), false)),\n+            Ne =>\n+                Ok((Scalar::from_bool(!self.ptr_eq(left, right, left_layout.size)?), false)),\n+            // These need both to be pointer, and fail if they are not in the same location\n+            Lt | Le | Gt | Ge | Sub if left.is_ptr() && right.is_ptr() => {\n+                let left = left.to_ptr().expect(\"we checked is_ptr\");\n+                let right = right.to_ptr().expect(\"we checked is_ptr\");\n                 if left.alloc_id == right.alloc_id {\n                     let res = match bin_op {\n                         Lt => left.offset < right.offset,\n                         Le => left.offset <= right.offset,\n                         Gt => left.offset > right.offset,\n                         Ge => left.offset >= right.offset,\n                         Sub => {\n+                            // subtract the offsets\n                             let left_offset = Scalar::from_uint(left.offset.bytes(), self.memory.pointer_size());\n                             let right_offset = Scalar::from_uint(right.offset.bytes(), self.memory.pointer_size());\n                             let layout = self.layout_of(self.tcx.types.usize)?;\n                             return self.binary_op(\n                                 Sub,\n-                                ValTy { value: Value::Scalar(left_offset.into()), layout },\n-                                ValTy { value: Value::Scalar(right_offset.into()), layout },\n-                            ).map(Some)\n+                                left_offset, layout,\n+                                right_offset, layout,\n+                            )\n                         }\n                         _ => bug!(\"We already established it has to be one of these operators.\"),\n                     };\n-                    Ok(Some((Scalar::from_bool(res), false)))\n+                    Ok((Scalar::from_bool(res), false))\n                 } else {\n                     // Both are pointers, but from different allocations.\n                     err!(InvalidPointerMath)\n                 }\n             }\n-            // These work if the left operand is a pointer, the right an integer\n-            Add | BitAnd | Sub | Rem\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n-                       left.is_ptr() && right.is_bits() => {\n+            // These work if the left operand is a pointer, and the right an integer\n+            Add | BitAnd | Sub | Rem if left.is_ptr() && right.is_bits() => {\n                 // Cast to i128 is fine as we checked the kind to be ptr-sized\n                 self.ptr_int_arithmetic(\n                     bin_op,\n-                    left.to_ptr()?,\n-                    right.to_bits(self.memory.pointer_size())?,\n-                    left_kind == isize,\n-                ).map(Some)\n+                    left.to_ptr().expect(\"we checked is_ptr\"),\n+                    right.to_bits(self.memory.pointer_size()).expect(\"we checked is_bits\"),\n+                    right_layout.abi.is_signed(),\n+                )\n             }\n             // Commutative operators also work if the integer is on the left\n-            Add | BitAnd\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n-                       left.is_bits() && right.is_ptr() => {\n+            Add | BitAnd if left.is_bits() && right.is_ptr() => {\n                 // This is a commutative operation, just swap the operands\n                 self.ptr_int_arithmetic(\n                     bin_op,\n-                    right.to_ptr()?,\n-                    left.to_bits(self.memory.pointer_size())?,\n-                    left_kind == isize,\n-                ).map(Some)\n+                    right.to_ptr().expect(\"we checked is_ptr\"),\n+                    left.to_bits(self.memory.pointer_size()).expect(\"we checked is_bits\"),\n+                    left_layout.abi.is_signed(),\n+                )\n             }\n-            _ => Ok(None),\n+            // Nothing else works\n+            _ => err!(InvalidPointerMath),\n         }\n     }\n \n+    fn ptr_eq(\n+        &self,\n+        left: Scalar,\n+        right: Scalar,\n+        size: Size,\n+    ) -> EvalResult<'tcx, bool> {\n+        Ok(match (left, right) {\n+            (Scalar::Bits { .. }, Scalar::Bits { .. }) =>\n+                left.to_bits(size)? == right.to_bits(size)?,\n+            (Scalar::Ptr(left), Scalar::Ptr(right)) => {\n+                // Comparison illegal if one of them is out-of-bounds, *unless* they\n+                // are in the same allocation.\n+                if left.alloc_id == right.alloc_id {\n+                    left.offset == right.offset\n+                } else {\n+                    // This accepts one-past-the end.  So technically there is still\n+                    // some non-determinism that we do not fully rule out when two\n+                    // allocations sit right next to each other.  The C/C++ standards are\n+                    // somewhat fuzzy about this case, so I think for now this check is\n+                    // \"good enough\".\n+                    self.memory.check_bounds(left, false)?;\n+                    self.memory.check_bounds(right, false)?;\n+                    // Two live in-bounds pointers, we can compare across allocations\n+                    left == right\n+                }\n+            }\n+            // Comparing ptr and integer\n+            (Scalar::Ptr(ptr), Scalar::Bits { bits, size }) |\n+            (Scalar::Bits { bits, size }, Scalar::Ptr(ptr)) => {\n+                assert_eq!(size as u64, self.pointer_size().bytes());\n+\n+                if bits == 0 {\n+                    // Nothing equals 0, not even dangling pointers. Ideally we would\n+                    // require them to be in-bounds of their (possilby dead) allocation,\n+                    // but with the allocation gonew e cannot check that.\n+                    false\n+                } else {\n+                    // Live pointers cannot equal an integer, but again do not\n+                    // allow comparing dead pointers.\n+                    self.memory.check_bounds(ptr, false)?;\n+                    false\n+                }\n+            }\n+        })\n+    }\n+\n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "bd0318a62ed45823271bae22964a62bc675b2656", "filename": "src/tls.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -1,6 +1,6 @@\n use rustc::{ty, mir};\n \n-use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Scalar, ScalarExt, Memory, Evaluator,\n+use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Scalar, Memory, Evaluator,\n             Place, StackPopCleanup, EvalContext};\n \n pub trait MemoryExt<'tcx> {\n@@ -22,11 +22,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n     fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.data.next_thread_local;\n         self.data.next_thread_local += 1;\n-        let ptr_size = self.pointer_size();\n         self.data.thread_local.insert(\n             new_key,\n             TlsEntry {\n-                data: Scalar::null(ptr_size).into(),\n+                data: Scalar::ptr_null(*self.tcx).into(),\n                 dtor,\n             },\n         );\n@@ -89,7 +88,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n     ) -> Option<(ty::Instance<'tcx>, Scalar, TlsKey)> {\n         use std::collections::Bound::*;\n \n-        let ptr_size = self.pointer_size();\n         let thread_local = &mut self.data.thread_local;\n         let start = match key {\n             Some(key) => Excluded(key),\n@@ -101,7 +99,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n             if !data.is_null() {\n                 if let Some(dtor) = dtor {\n                     let ret = Some((dtor, *data, key));\n-                    *data = Scalar::null(ptr_size);\n+                    *data = Scalar::ptr_null(*self.tcx);\n                     return ret;\n                 }\n             }"}, {"sha": "0add977bf97b417af68ce2957ec7d893dd74d104", "filename": "tests/compile-fail/cast_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -5,6 +5,5 @@ fn main() {\n         std::mem::transmute::<fn(), fn(i32)>(f)\n     };\n \n-    g(42) //~ ERROR constant evaluation error\n-    //~^ NOTE tried to call a function with sig fn() through a function pointer of type fn(i32)\n+    g(42) //~ ERROR tried to call a function with incorrect number of arguments\n }"}, {"sha": "5af527016fb6fecd3bf4253fa6cfd453f744ccb1", "filename": "tests/compile-fail/cast_fn_ptr2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -5,6 +5,5 @@ fn main() {\n         std::mem::transmute::<fn((i32,i32)), fn(i32)>(f)\n     };\n \n-    g(42) //~ ERROR constant evaluation error\n-    //~^ NOTE tried to call a function with sig fn((i32, i32)) through a function pointer of type fn(i32)\n+    g(42) //~ ERROR tried to call a function with argument of type (i32, i32) passing data of type i32\n }"}, {"sha": "29507e7c7cf54c6e7b92065c02df68cc6c0e4838", "filename": "tests/compile-fail/cast_fn_ptr3.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Fcompile-fail%2Fcast_fn_ptr3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Fcompile-fail%2Fcast_fn_ptr3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr3.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    fn f(_ : (i32,i32)) {}\n+\n+    let g = unsafe {\n+        std::mem::transmute::<fn((i32,i32)), fn()>(f)\n+    };\n+\n+    g() //~ ERROR tried to call a function with incorrect number of arguments\n+}\n+"}, {"sha": "f9a2cf9f6965e5bed02e30eccc7204f8472fe6d8", "filename": "tests/compile-fail/cast_fn_ptr4.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Fcompile-fail%2Fcast_fn_ptr4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Fcompile-fail%2Fcast_fn_ptr4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr4.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    fn f(_ : *const [i32]) {}\n+\n+    let g = unsafe {\n+        std::mem::transmute::<fn(*const [i32]), fn(*const i32)>(f)\n+    };\n+\n+    g(&42 as *const i32) //~ ERROR tried to call a function with argument of type *const [i32] passing data of type *const i32\n+}"}, {"sha": "b25f09d485fb39e2a1800e37c4d4593468258295", "filename": "tests/compile-fail/pointer_byte_read_1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -3,6 +3,5 @@ fn main() {\n     let y = &x;\n     let z = &y as *const &i32 as *const usize;\n     let ptr_bytes = unsafe { *z }; // the actual deref is fine, because we read the entire pointer at once\n-    let _ = ptr_bytes / 432; //~ ERROR constant evaluation error\n-    //~^ NOTE tried to access part of a pointer value as raw bytes\n+    let _ = ptr_bytes / 432; //~ ERROR invalid arithmetic on pointers that would leak base addresses\n }"}, {"sha": "2706b0970d7d586212d8c1e6d1e97212ec61332f", "filename": "tests/compile-fail/ptr_bitops.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Fcompile-fail%2Fptr_bitops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Fcompile-fail%2Fptr_bitops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_bitops.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -2,7 +2,6 @@ fn main() {\n     let bytes = [0i8, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let one = bytes.as_ptr().wrapping_offset(1);\n     let three = bytes.as_ptr().wrapping_offset(3);\n-    let res = (one as usize) | (three as usize); //~ ERROR constant evaluation error\n-    //~^ NOTE a raw memory access tried to access part of a pointer value as raw bytes\n+    let res = (one as usize) | (three as usize); //~ ERROR invalid arithmetic on pointers that would leak base addresses\n     println!(\"{}\", res);\n }"}, {"sha": "5524f0ae7abea09409c637f924c81bc1e1c1e4b5", "filename": "tests/run-pass/char.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Frun-pass%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Frun-pass%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fchar.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -3,7 +3,5 @@ fn main() {\n     assert_eq!(c, 'x');\n     assert!('a' < 'z');\n     assert!('1' < '9');\n-    assert_eq!(std::char::from_u32('x' as u32).unwrap(), 'x');\n-    // FIXME:\n-    // assert_eq!(std::char::from_u32('x' as u32), Some('x'));\n+    assert_eq!(std::char::from_u32('x' as u32), Some('x'));\n }"}, {"sha": "d48c4df45944a12a6ddae736d1ccce87b4f4f9e8", "filename": "tests/run-pass/non_capture_closure_to_fn_ptr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/155399382e45d404f208482b61e10f5ac266a4ec/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs?ref=155399382e45d404f208482b61e10f5ac266a4ec", "patch": "@@ -4,11 +4,17 @@ static FOO: fn() = || { assert_ne!(42, 43) };\n #[allow(const_err)]\n static BAR: fn(i32, i32) = |a, b| { assert_ne!(a, b) };\n \n+// use to first make the closure FnOnce() before making it fn()\n+fn magic<F: FnOnce()>(f: F) -> F { f }\n+\n fn main() {\n     FOO();\n     BAR(44, 45);\n     let bar: unsafe fn(i32, i32) = BAR;\n     unsafe { bar(46, 47) };\n     let boo: &Fn(i32, i32) = &BAR;\n     boo(48, 49);\n+\n+    let f = magic(||{}) as fn();\n+    f();\n }"}]}