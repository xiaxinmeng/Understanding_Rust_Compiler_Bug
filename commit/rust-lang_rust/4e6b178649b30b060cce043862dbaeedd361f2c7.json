{"sha": "4e6b178649b30b060cce043862dbaeedd361f2c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNmIxNzg2NDliMzBiMDYwY2NlMDQzODYyZGJhZWVkZDM2MWYyYzc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-06T12:37:19Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-11T17:49:07Z"}, "message": "trans: use DefKey directly in debuginfo for paths.", "tree": {"sha": "a15b84afea0643490e1d8f01b5a845f36517465f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a15b84afea0643490e1d8f01b5a845f36517465f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e6b178649b30b060cce043862dbaeedd361f2c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e6b178649b30b060cce043862dbaeedd361f2c7", "html_url": "https://github.com/rust-lang/rust/commit/4e6b178649b30b060cce043862dbaeedd361f2c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e6b178649b30b060cce043862dbaeedd361f2c7/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e945b2852e772960248105bd9a0518c4a0b10b04", "url": "https://api.github.com/repos/rust-lang/rust/commits/e945b2852e772960248105bd9a0518c4a0b10b04", "html_url": "https://github.com/rust-lang/rust/commit/e945b2852e772960248105bd9a0518c4a0b10b04"}], "stats": {"total": 306, "additions": 113, "deletions": 193}, "files": [{"sha": "956e1a5ce96b792c64cf5c6d22c44b81a3d72eb7", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b178649b30b060cce043862dbaeedd361f2c7/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b178649b30b060cce043862dbaeedd361f2c7/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=4e6b178649b30b060cce043862dbaeedd361f2c7", "patch": "@@ -1400,15 +1400,11 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     pub fn new(ccx: &'blk CrateContext<'blk, 'tcx>,\n                llfndecl: ValueRef,\n                fn_ty: FnType,\n-               definition: Option<(Instance<'tcx>,\n-                                   &ty::FnSig<'tcx>,\n-                                   Abi,\n-                                   &ty::Generics<'tcx>,\n-                                   Option<ast::Name>)>,\n+               definition: Option<(Instance<'tcx>, &ty::FnSig<'tcx>, Abi)>,\n                block_arena: &'blk TypedArena<common::BlockS<'blk, 'tcx>>)\n                -> FunctionContext<'blk, 'tcx> {\n         let (param_substs, def_id) = match definition {\n-            Some((instance, _, _, _, _)) => {\n+            Some((instance, _, _)) => {\n                 common::validate_substs(instance.substs);\n                 (instance.substs, Some(instance.def))\n             }\n@@ -1450,14 +1446,9 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             None\n         };\n \n-        let span = inlined_id.and_then(|id| ccx.tcx().map.opt_span(id));\n-\n         let debug_context = if let (false, Some(definition)) = (no_debug, definition) {\n-            let (instance, sig, abi, generics, name) = definition;\n-            debuginfo::create_function_debug_context(ccx, instance, sig,\n-                                                     abi, generics, name,\n-                                                     span.unwrap_or(DUMMY_SP),\n-                                                     llfndecl)\n+            let (instance, sig, abi) = definition;\n+            debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfndecl)\n         } else {\n             debuginfo::empty_function_debug_context(ccx)\n         };\n@@ -1476,7 +1467,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             lldropflag_hints: RefCell::new(DropFlagHintsMap::new()),\n             fn_ty: fn_ty,\n             param_substs: param_substs,\n-            span: span,\n+            span: inlined_id.and_then(|id| ccx.tcx().map.opt_span(id)),\n             block_arena: block_arena,\n             lpad_arena: TypedArena::new(),\n             ccx: ccx,\n@@ -1831,8 +1822,6 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                inlined_id: ast::NodeId,\n                                sig: &ty::FnSig<'tcx>,\n                                abi: Abi,\n-                               generics: &ty::Generics<'tcx>,\n-                               name: Option<ast::Name>,\n                                closure_env: closure::ClosureEnv) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n@@ -1849,8 +1838,7 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfndecl, fn_ty,\n-                               Some((instance, sig, abi, generics, name)), &arena);\n+    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, Some((instance, sig, abi)), &arena);\n \n     if fcx.mir.is_some() {\n         return mir::trans_mir(&fcx);\n@@ -1931,8 +1919,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     } else {\n         ccx.tcx().map.local_def_id(id)\n     };\n-    let scheme = ccx.tcx().lookup_item_type(def_id);\n-    let fn_ty = scheme.ty;\n+    let fn_ty = ccx.tcx().lookup_item_type(def_id).ty;\n     let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fn_ty);\n     let sig = ccx.tcx().erase_late_bound_regions(fn_ty.fn_sig());\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n@@ -1945,8 +1932,6 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   id,\n                   &sig,\n                   abi,\n-                  &scheme.generics,\n-                  Some(ccx.tcx().item_name(def_id)),\n                   closure::ClosureEnv::NotClosure);\n }\n "}, {"sha": "c2031638044fb02dad9575aab0913d6b4b731583", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b178649b30b060cce043862dbaeedd361f2c7/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b178649b30b060cce043862dbaeedd361f2c7/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=4e6b178649b30b060cce043862dbaeedd361f2c7", "patch": "@@ -235,10 +235,6 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n         variadic: false\n     };\n \n-    // This is not quite right. It should actually inherit\n-    // the generics of the enclosing function.\n-    let generics = ty::Generics::empty();\n-\n     trans_closure(ccx,\n                   decl,\n                   body,\n@@ -247,8 +243,6 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                   id,\n                   &sig,\n                   Abi::RustCall,\n-                  &generics,\n-                  None,\n                   ClosureEnv::Closure(closure_def_id, id));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate"}, {"sha": "de403732269febe8ec18cdcd28c8d5fb3bae970c", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b178649b30b060cce043862dbaeedd361f2c7/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b178649b30b060cce043862dbaeedd361f2c7/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=4e6b178649b30b060cce043862dbaeedd361f2c7", "patch": "@@ -16,7 +16,7 @@ use self::EnumDiscriminantInfo::*;\n use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n                    get_namespace_and_span_for_item, create_DIArray,\n                    fn_should_be_ignored, is_node_local_to_unit};\n-use super::namespace::namespace_for_item;\n+use super::namespace::mangled_name_of_item;\n use super::type_names::{compute_debuginfo_type_name, push_debuginfo_type_name};\n use super::{declare_local, VariableKind, VariableAccess};\n \n@@ -68,8 +68,8 @@ pub const UNKNOWN_LINE_NUMBER: c_uint = 0;\n pub const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n \n // ptr::null() doesn't work :(\n-const NO_FILE_METADATA: DIFile = (0 as DIFile);\n-const NO_SCOPE_METADATA: DIScope = (0 as DIScope);\n+pub const NO_FILE_METADATA: DIFile = (0 as DIFile);\n+pub const NO_SCOPE_METADATA: DIScope = (0 as DIScope);\n \n const FLAGS_NONE: c_uint = 0;\n \n@@ -1846,28 +1846,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         return;\n     }\n \n-    let var_item = cx.tcx().map.get(node_id);\n-\n-    let (name, span) = match var_item {\n-        hir_map::NodeItem(item) => {\n-            match item.node {\n-                hir::ItemStatic(..) => (item.name, item.span),\n-                hir::ItemConst(..) => (item.name, item.span),\n-                _ => {\n-                    span_bug!(item.span,\n-                              \"debuginfo::\\\n-                               create_global_var_metadata() -\n-                               Captured var-id refers to \\\n-                               unexpected ast_item variant: {:?}\",\n-                              var_item)\n-                }\n-            }\n-        },\n-        _ => bug!(\"debuginfo::create_global_var_metadata() \\\n-                   - Captured var-id refers to unexpected \\\n-                   hir_map variant: {:?}\",\n-                  var_item)\n-    };\n+    let node_def_id = cx.tcx().map.local_def_id(node_id);\n+    let (var_scope, span) = get_namespace_and_span_for_item(cx, node_def_id);\n \n     let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n         let loc = span_start(cx, span);\n@@ -1879,12 +1859,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n     let variable_type = cx.tcx().node_id_to_type(node_id);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let node_def_id = cx.tcx().map.local_def_id(node_id);\n-    let namespace_node = namespace_for_item(cx, node_def_id);\n-    let var_name = name.to_string();\n-    let linkage_name =\n-        namespace_node.mangled_name_of_contained_item(&var_name[..]);\n-    let var_scope = namespace_node.scope;\n+    let var_name = cx.tcx().item_name(node_def_id).to_string();\n+    let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");\n \n     let var_name = CString::new(var_name).unwrap();\n     let linkage_name = CString::new(linkage_name).unwrap();"}, {"sha": "2ecd6c5ebf7f2ca9d98c4175014c6c1c1ece2a7f", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b178649b30b060cce043862dbaeedd361f2c7/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b178649b30b060cce043862dbaeedd361f2c7/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=4e6b178649b30b060cce043862dbaeedd361f2c7", "patch": "@@ -14,8 +14,9 @@ mod doc;\n use self::VariableAccess::*;\n use self::VariableKind::*;\n \n-use self::utils::{DIB, span_start, create_DIArray, is_node_local_to_unit};\n-use self::namespace::{namespace_for_item, NamespaceTreeNode};\n+use self::utils::{DIB, span_start, create_DIArray, is_node_local_to_unit,\n+                  get_namespace_and_span_for_item};\n+use self::namespace::mangled_name_of_item;\n use self::type_names::compute_debuginfo_type_name;\n use self::metadata::{type_metadata, diverging_type_metadata};\n use self::metadata::{file_metadata, scope_metadata, TypeMap, compile_unit_metadata};\n@@ -26,6 +27,7 @@ use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray,\n                       FlagPrototyped};\n use rustc::hir::def_id::DefId;\n+use rustc::hir::map::DefPathData;\n use rustc::ty::subst::Substs;\n use rustc::hir;\n \n@@ -34,18 +36,16 @@ use common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n use monomorphize::Instance;\n use rustc::ty::{self, Ty};\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n-use util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n use std::ffi::CString;\n use std::ptr;\n-use std::rc::Rc;\n \n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap};\n use syntax::attr::IntType;\n-use syntax::parse::token;\n \n pub mod gdb;\n mod utils;\n@@ -80,7 +80,7 @@ pub struct CrateDebugContext<'tcx> {\n     created_enum_disr_types: RefCell<FnvHashMap<(DefId, IntType), DIType>>,\n \n     type_map: RefCell<TypeMap<'tcx>>,\n-    namespace_map: RefCell<FnvHashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n+    namespace_map: RefCell<DefIdMap<DIScope>>,\n \n     // This collection is used to assert that composite types (structs, enums,\n     // ...) have their members only set once:\n@@ -100,7 +100,7 @@ impl<'tcx> CrateDebugContext<'tcx> {\n             created_files: RefCell::new(FnvHashMap()),\n             created_enum_disr_types: RefCell::new(FnvHashMap()),\n             type_map: RefCell::new(TypeMap::new()),\n-            namespace_map: RefCell::new(FnvHashMap()),\n+            namespace_map: RefCell::new(DefIdMap()),\n             composite_types_completed: RefCell::new(FnvHashSet()),\n         };\n     }\n@@ -232,9 +232,6 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                instance: Instance<'tcx>,\n                                                sig: &ty::FnSig<'tcx>,\n                                                abi: Abi,\n-                                               generics: &ty::Generics<'tcx>,\n-                                               name: Option<ast::Name>,\n-                                               span: Span,\n                                                llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n         return FunctionDebugContext::DebugInfoDisabled;\n@@ -245,6 +242,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n \n     // This can be the case for functions inlined from another crate\n+    let (containing_scope, span) = get_namespace_and_span_for_item(cx, instance.def);\n     if span == codemap::DUMMY_SP {\n         return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n@@ -257,38 +255,34 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n+    // Find the enclosing function, in case this is a closure.\n+    let mut fn_def_id = instance.def;\n+    let mut def_key = cx.tcx().def_key(fn_def_id);\n+    let mut name = def_key.disambiguated_data.data.to_string();\n+    let name_len = name.len();\n+    while def_key.disambiguated_data.data == DefPathData::ClosureExpr {\n+        fn_def_id.index = def_key.parent.expect(\"closure without a parent?\");\n+        def_key = cx.tcx().def_key(fn_def_id);\n+    }\n+\n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let mut function_name = name.map(|name| name.to_string()).unwrap_or_else(|| {\n-        // We do this only for closures atm.\n-        format!(\"fn{}\", token::gensym(\"fn\"))\n-    });\n+    let generics = cx.tcx().lookup_item_type(fn_def_id).generics;\n     let template_parameters = get_template_parameters(cx,\n-                                                      generics,\n+                                                      &generics,\n                                                       instance.substs,\n                                                       file_metadata,\n-                                                      &mut function_name);\n-\n-    // There is no hir_map::Path for hir::ExprClosure-type functions. For now,\n-    // just don't put them into a namespace. In the future this could be improved\n-    // somehow (storing a path in the hir_map, or construct a path using the\n-    // enclosing function).\n-    let (linkage_name, containing_scope) = if name.is_some() {\n-        let namespace_node = namespace_for_item(cx, instance.def);\n-        let linkage_name = namespace_node.mangled_name_of_contained_item(\n-            &function_name[..]);\n-        let containing_scope = namespace_node.scope;\n-        (linkage_name, containing_scope)\n-    } else {\n-        (function_name.clone(), file_metadata)\n-    };\n+                                                      &mut name);\n+\n+    // Build the linkage_name out of the item path and \"template\" parameters.\n+    let linkage_name = mangled_name_of_item(cx, instance.def, &name[name_len..]);\n \n     let scope_line = span_start(cx, span).line;\n \n     let local_id = cx.tcx().map.as_local_node_id(instance.def);\n     let is_local_to_unit = local_id.map_or(false, |id| is_node_local_to_unit(cx, id));\n \n-    let function_name = CString::new(function_name).unwrap();\n+    let function_name = CString::new(name).unwrap();\n     let linkage_name = CString::new(linkage_name).unwrap();\n     let fn_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateFunction("}, {"sha": "fc31eaa4e74a7961507f2ea92f42623887401819", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 62, "deletions": 98, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b178649b30b060cce043862dbaeedd361f2c7/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b178649b30b060cce043862dbaeedd361f2c7/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=4e6b178649b30b060cce043862dbaeedd361f2c7", "patch": "@@ -10,118 +10,82 @@\n \n // Namespace Handling.\n \n-use super::utils::{DIB, debug_context};\n+use super::metadata::{file_metadata, NO_FILE_METADATA, UNKNOWN_LINE_NUMBER};\n+use super::utils::{DIB, debug_context, span_start};\n \n use llvm;\n use llvm::debuginfo::DIScope;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map as hir_map;\n+use rustc::hir::map::DefPathData;\n use common::CrateContext;\n \n+use libc::c_uint;\n use std::ffi::CString;\n-use std::iter::once;\n use std::ptr;\n-use std::rc::{Rc, Weak};\n-use syntax::ast;\n-use syntax::parse::token;\n-\n-pub struct NamespaceTreeNode {\n-    pub name: ast::Name,\n-    pub scope: DIScope,\n-    pub parent: Option<Weak<NamespaceTreeNode>>,\n-}\n-\n-impl NamespaceTreeNode {\n-    pub fn mangled_name_of_contained_item(&self, item_name: &str) -> String {\n-        fn fill_nested(node: &NamespaceTreeNode, output: &mut String) {\n-            match node.parent {\n-                Some(ref parent) => fill_nested(&parent.upgrade().unwrap(), output),\n-                None => {}\n-            }\n-            let string = node.name.as_str();\n-            output.push_str(&string.len().to_string());\n-            output.push_str(&string);\n+use syntax::codemap::DUMMY_SP;\n+\n+pub fn mangled_name_of_item(ccx: &CrateContext, def_id: DefId, extra: &str) -> String {\n+    fn fill_nested(ccx: &CrateContext, def_id: DefId, extra: &str, output: &mut String) {\n+        let def_key = ccx.tcx().def_key(def_id);\n+        if let Some(parent) = def_key.parent {\n+            fill_nested(ccx, DefId {\n+                krate: def_id.krate,\n+                index: parent\n+            }, \"\", output);\n         }\n \n-        let mut name = String::from(\"_ZN\");\n-        fill_nested(self, &mut name);\n-        name.push_str(&item_name.len().to_string());\n-        name.push_str(item_name);\n-        name.push('E');\n-        name\n-    }\n-}\n-\n-pub fn namespace_for_item(cx: &CrateContext, def_id: DefId) -> Rc<NamespaceTreeNode> {\n-    // prepend crate name.\n-    // This shouldn't need a roundtrip through InternedString.\n-    let krate = token::intern(&cx.tcx().crate_name(def_id.krate));\n-    let krate = hir_map::DefPathData::TypeNs(krate);\n-    let path = cx.tcx().def_path(def_id).data;\n-    let mut path = once(krate).chain(path.into_iter().map(|e| e.data)).peekable();\n-\n-    let mut current_key = Vec::new();\n-    let mut parent_node: Option<Rc<NamespaceTreeNode>> = None;\n-\n-    // Create/Lookup namespace for each element of the path.\n-    loop {\n-        // Emulate a for loop so we can use peek below.\n-        let path_element = match path.next() {\n-            Some(e) => e,\n-            None => break\n+        let name = match def_key.disambiguated_data.data {\n+            DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate),\n+            data => data.as_interned_str()\n         };\n-        // Ignore the name of the item (the last path element).\n-        if path.peek().is_none() {\n-            break;\n-        }\n \n-        // This shouldn't need a roundtrip through InternedString.\n-        let namespace_name = path_element.as_interned_str();\n-        let name = token::intern(&namespace_name);\n-        current_key.push(name);\n-\n-        let existing_node = debug_context(cx).namespace_map.borrow()\n-                                             .get(&current_key).cloned();\n-        let current_node = match existing_node {\n-            Some(existing_node) => existing_node,\n-            None => {\n-                // create and insert\n-                let parent_scope = match parent_node {\n-                    Some(ref node) => node.scope,\n-                    None => ptr::null_mut()\n-                };\n-                let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n-                let scope = unsafe {\n-                    llvm::LLVMDIBuilderCreateNameSpace(\n-                        DIB(cx),\n-                        parent_scope,\n-                        namespace_name.as_ptr(),\n-                        // cannot reconstruct file ...\n-                        ptr::null_mut(),\n-                        // ... or line information, but that's not so important.\n-                        0)\n-                };\n-\n-                let node = Rc::new(NamespaceTreeNode {\n-                    name: name,\n-                    scope: scope,\n-                    parent: parent_node.map(|parent| Rc::downgrade(&parent)),\n-                });\n-\n-                debug_context(cx).namespace_map.borrow_mut()\n-                                 .insert(current_key.clone(), node.clone());\n+        output.push_str(&(name.len() + extra.len()).to_string());\n+        output.push_str(&name);\n+        output.push_str(extra);\n+    }\n \n-                node\n-            }\n-        };\n+    let mut name = String::from(\"_ZN\");\n+    fill_nested(ccx, def_id, extra, &mut name);\n+    name.push('E');\n+    name\n+}\n \n-        parent_node = Some(current_node);\n+pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n+    if let Some(&scope) = debug_context(ccx).namespace_map.borrow().get(&def_id) {\n+        return scope;\n     }\n \n-    match parent_node {\n-        Some(node) => node,\n-        None => {\n-            bug!(\"debuginfo::namespace_for_item: path too short for {:?}\", def_id);\n-        }\n-    }\n+    let def_key = ccx.tcx().def_key(def_id);\n+    let parent_scope = def_key.parent.map_or(ptr::null_mut(), |parent| {\n+        item_namespace(ccx, DefId {\n+            krate: def_id.krate,\n+            index: parent\n+        })\n+    });\n+\n+    let namespace_name = match def_key.disambiguated_data.data {\n+        DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate),\n+        data => data.as_interned_str()\n+    };\n+\n+    let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n+    let span = ccx.tcx().map.def_id_span(def_id, DUMMY_SP);\n+    let (file, line) = if span != DUMMY_SP {\n+        let loc = span_start(ccx, span);\n+        (file_metadata(ccx, &loc.file.name), loc.line as c_uint)\n+    } else {\n+        (NO_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n+    };\n+\n+    let scope = unsafe {\n+        llvm::LLVMDIBuilderCreateNameSpace(\n+            DIB(ccx),\n+            parent_scope,\n+            namespace_name.as_ptr(),\n+            file,\n+            line as c_uint)\n+    };\n+\n+    debug_context(ccx).namespace_map.borrow_mut().insert(def_id, scope);\n+    scope\n }"}, {"sha": "3fd979371843434db7542198803e8dc028639143", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b178649b30b060cce043862dbaeedd361f2c7/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b178649b30b060cce043862dbaeedd361f2c7/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=4e6b178649b30b060cce043862dbaeedd361f2c7", "patch": "@@ -11,7 +11,7 @@\n // Utility Functions.\n \n use super::{FunctionDebugContext, CrateDebugContext};\n-use super::namespace::namespace_for_item;\n+use super::namespace::item_namespace;\n \n use rustc::hir::def_id::DefId;\n \n@@ -79,10 +79,17 @@ pub fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n \n pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n                                    -> (DIScope, Span) {\n-    let containing_scope = namespace_for_item(cx, def_id).scope;\n-    let definition_span = cx.tcx().map.def_id_span(def_id, codemap::DUMMY_SP /* (1) */ );\n-\n-    // (1) For external items there is no span information\n+    let containing_scope = item_namespace(cx, DefId {\n+        krate: def_id.krate,\n+        index: cx.tcx().def_key(def_id).parent\n+                 .expect(\"get_namespace_and_span_for_item: missing parent?\")\n+    });\n+\n+    // Try to get some span information, if we have an inlined item.\n+    let definition_span = match cx.external().borrow().get(&def_id) {\n+        Some(&Some(node_id)) => cx.tcx().map.span(node_id),\n+        _ => cx.tcx().map.def_id_span(def_id, codemap::DUMMY_SP)\n+    };\n \n     (containing_scope, definition_span)\n }"}]}