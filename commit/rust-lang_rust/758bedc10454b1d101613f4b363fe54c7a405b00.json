{"sha": "758bedc10454b1d101613f4b363fe54c7a405b00", "node_id": "C_kwDOAAsO6NoAKDc1OGJlZGMxMDQ1NGIxZDEwMTYxM2Y0YjM2M2ZlNTRjN2E0MDViMDA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-06T23:11:19Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-06T23:30:22Z"}, "message": "Make elaborator generic", "tree": {"sha": "8a1f8b0b5ebd9ffcc11cadb68d56d0c1b45adb2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a1f8b0b5ebd9ffcc11cadb68d56d0c1b45adb2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/758bedc10454b1d101613f4b363fe54c7a405b00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/758bedc10454b1d101613f4b363fe54c7a405b00", "html_url": "https://github.com/rust-lang/rust/commit/758bedc10454b1d101613f4b363fe54c7a405b00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/758bedc10454b1d101613f4b363fe54c7a405b00/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de74dab880447f5227030b261dbd0f2bc4f32dba", "url": "https://api.github.com/repos/rust-lang/rust/commits/de74dab880447f5227030b261dbd0f2bc4f32dba", "html_url": "https://github.com/rust-lang/rust/commit/de74dab880447f5227030b261dbd0f2bc4f32dba"}], "stats": {"total": 320, "additions": 164, "deletions": 156}, "files": [{"sha": "f6c2004c4a672073000482401c0745c3a613ad64", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -2034,7 +2034,7 @@ pub(super) fn check_type_bounds<'tcx>(\n         ObligationCause::new(impl_ty_span, impl_ty_def_id, code)\n     };\n \n-    let obligations = tcx\n+    let obligations: Vec<_> = tcx\n         .bound_explicit_item_bounds(trait_ty.def_id)\n         .subst_iter_copied(tcx, rebased_substs)\n         .map(|(concrete_ty_bound, span)| {\n@@ -2044,7 +2044,7 @@ pub(super) fn check_type_bounds<'tcx>(\n         .collect();\n     debug!(\"check_type_bounds: item_bounds={:?}\", obligations);\n \n-    for mut obligation in util::elaborate_obligations(tcx, obligations) {\n+    for mut obligation in util::elaborate(tcx, obligations) {\n         let normalized_predicate =\n             ocx.normalize(&normalize_cause, normalize_param_env, obligation.predicate);\n         debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);"}, {"sha": "c03621fcfb224d0447c3c37c1c71c2b402f5ba8e", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -1908,7 +1908,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n \n         let predicates_with_span = tcx.predicates_of(self.body_def_id).predicates.iter().copied();\n         // Check elaborated bounds.\n-        let implied_obligations = traits::elaborate_predicates_with_span(tcx, predicates_with_span);\n+        let implied_obligations = traits::elaborate(tcx, predicates_with_span);\n \n         for (pred, obligation_span) in implied_obligations {\n             // We lower empty bounds like `Vec<dyn Copy>:` as"}, {"sha": "2e56d24638cdb101920d748bc2a849fe66492b5c", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -130,7 +130,7 @@ pub(super) fn item_bounds(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n ) -> ty::EarlyBinder<&'_ ty::List<ty::Predicate<'_>>> {\n-    let bounds = tcx.mk_predicates_from_iter(util::elaborate_predicates(\n+    let bounds = tcx.mk_predicates_from_iter(util::elaborate(\n         tcx,\n         tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n     ));"}, {"sha": "35785e81ff497516004281970f1c4b127d6611c0", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -318,15 +318,14 @@ fn check_predicates<'tcx>(\n     span: Span,\n ) {\n     let instantiated = tcx.predicates_of(impl1_def_id).instantiate(tcx, impl1_substs);\n-    let impl1_predicates: Vec<_> =\n-        traits::elaborate_predicates_with_span(tcx, instantiated.into_iter()).collect();\n+    let impl1_predicates: Vec<_> = traits::elaborate(tcx, instantiated.into_iter()).collect();\n \n     let mut impl2_predicates = if impl2_node.is_from_trait() {\n         // Always applicable traits have to be always applicable without any\n         // assumptions.\n         Vec::new()\n     } else {\n-        traits::elaborate_predicates(\n+        traits::elaborate(\n             tcx,\n             tcx.predicates_of(impl2_node.def_id())\n                 .instantiate(tcx, impl2_substs)\n@@ -371,11 +370,10 @@ fn check_predicates<'tcx>(\n                 .unwrap();\n \n         assert!(!obligations.needs_infer());\n-        impl2_predicates.extend(\n-            traits::elaborate_obligations(tcx, obligations).map(|obligation| obligation.predicate),\n-        )\n+        impl2_predicates\n+            .extend(traits::elaborate(tcx, obligations).map(|obligation| obligation.predicate))\n     }\n-    impl2_predicates.extend(traits::elaborate_predicates(tcx, always_applicable_traits));\n+    impl2_predicates.extend(traits::elaborate(tcx, always_applicable_traits));\n \n     for (predicate, span) in impl1_predicates {\n         if !impl2_predicates.iter().any(|pred2| trait_predicates_eq(tcx, predicate, *pred2, span)) {"}, {"sha": "15eec42d78641c7810f53da5c6b97fe2af3120e1", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut expected_sig = None;\n         let mut expected_kind = None;\n \n-        for (pred, span) in traits::elaborate_predicates_with_span(\n+        for (pred, span) in traits::elaborate(\n             self.tcx,\n             // Reverse the obligations here, since `elaborate_*` uses a stack,\n             // and we want to keep inference generally in the same order of"}, {"sha": "9155a3d8daa19ac796521454b34d47853d854173", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -574,7 +574,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     ) -> Option<Span> {\n         let sized_def_id = self.tcx.lang_items().sized_trait()?;\n \n-        traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n+        traits::elaborate(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here.\n             .filter_map(|pred| match pred.kind().skip_binder() {\n                 ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))"}, {"sha": "0092bd2c6e641201faee1d0a8e66eb2b91de4212", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -1555,8 +1555,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         if !self.predicate_may_hold(&o) {\n                             result = ProbeResult::NoMatch;\n                             let parent_o = o.clone();\n-                            let implied_obligations =\n-                                traits::elaborate_obligations(self.tcx, vec![o]);\n+                            let implied_obligations = traits::elaborate(self.tcx, vec![o]);\n                             for o in implied_obligations {\n                                 let parent = if o == parent_o {\n                                     None"}, {"sha": "c5095a76f42c2aa879c55406b15ea652dce874a5", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 117, "deletions": 92, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -1,7 +1,7 @@\n use smallvec::smallvec;\n \n use crate::infer::outlives::components::{push_outlives_components, Component};\n-use crate::traits::{self, Obligation, ObligationCause, PredicateObligation};\n+use crate::traits::{self, Obligation, PredicateObligation};\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_middle::ty::{self, ToPredicate, TyCtxt};\n use rustc_span::symbol::Ident;\n@@ -66,99 +66,143 @@ impl<'tcx> Extend<ty::Predicate<'tcx>> for PredicateSet<'tcx> {\n /// if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd`\n /// holds as well. Similarly, if we have `trait Foo: 'static`, and we know that\n /// `T: Foo`, then we know that `T: 'static`.\n-pub struct Elaborator<'tcx> {\n-    stack: Vec<PredicateObligation<'tcx>>,\n+pub struct Elaborator<'tcx, O> {\n+    stack: Vec<O>,\n     visited: PredicateSet<'tcx>,\n }\n \n-pub fn elaborate_trait_ref<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n-    elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate(tcx)))\n+/// Describes how to elaborate an obligation into a sub-obligation.\n+///\n+/// For [`Obligation`], a sub-obligation is combined with the current obligation's\n+/// param-env and cause code. For [`ty::Predicate`], none of this is needed, since\n+/// there is no param-env or cause code to copy over.\n+pub trait Elaboratable<'tcx> {\n+    fn predicate(&self) -> ty::Predicate<'tcx>;\n+\n+    // Makes a new `Self` but with a different predicate.\n+    fn child(&self, predicate: ty::Predicate<'tcx>) -> Self;\n+\n+    // Makes a new `Self` but with a different predicate and a different cause\n+    // code (if `Self` has one).\n+    fn child_with_derived_cause(\n+        &self,\n+        predicate: ty::Predicate<'tcx>,\n+        span: Span,\n+        parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        index: usize,\n+    ) -> Self;\n }\n \n-pub fn elaborate_trait_refs<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n-    let predicates = trait_refs.map(move |trait_ref| trait_ref.without_const().to_predicate(tcx));\n-    elaborate_predicates(tcx, predicates)\n+impl<'tcx> Elaboratable<'tcx> for PredicateObligation<'tcx> {\n+    fn predicate(&self) -> ty::Predicate<'tcx> {\n+        self.predicate\n+    }\n+\n+    fn child(&self, predicate: ty::Predicate<'tcx>) -> Self {\n+        Obligation {\n+            cause: self.cause.clone(),\n+            param_env: self.param_env,\n+            recursion_depth: 0,\n+            predicate,\n+        }\n+    }\n+\n+    fn child_with_derived_cause(\n+        &self,\n+        predicate: ty::Predicate<'tcx>,\n+        span: Span,\n+        parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        index: usize,\n+    ) -> Self {\n+        let cause = self.cause.clone().derived_cause(parent_trait_pred, |derived| {\n+            traits::ImplDerivedObligation(Box::new(traits::ImplDerivedObligationCause {\n+                derived,\n+                impl_or_alias_def_id: parent_trait_pred.def_id(),\n+                impl_def_predicate_index: Some(index),\n+                span,\n+            }))\n+        });\n+        Obligation { cause, param_env: self.param_env, recursion_depth: 0, predicate }\n+    }\n }\n \n-pub fn elaborate_predicates<'tcx>(\n+impl<'tcx> Elaboratable<'tcx> for ty::Predicate<'tcx> {\n+    fn predicate(&self) -> ty::Predicate<'tcx> {\n+        *self\n+    }\n+\n+    fn child(&self, predicate: ty::Predicate<'tcx>) -> Self {\n+        predicate\n+    }\n+\n+    fn child_with_derived_cause(\n+        &self,\n+        predicate: ty::Predicate<'tcx>,\n+        _span: Span,\n+        _parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        _index: usize,\n+    ) -> Self {\n+        predicate\n+    }\n+}\n+\n+impl<'tcx> Elaboratable<'tcx> for (ty::Predicate<'tcx>, Span) {\n+    fn predicate(&self) -> ty::Predicate<'tcx> {\n+        self.0\n+    }\n+\n+    fn child(&self, predicate: ty::Predicate<'tcx>) -> Self {\n+        (predicate, self.1)\n+    }\n+\n+    fn child_with_derived_cause(\n+        &self,\n+        predicate: ty::Predicate<'tcx>,\n+        _span: Span,\n+        _parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        _index: usize,\n+    ) -> Self {\n+        (predicate, self.1)\n+    }\n+}\n+\n+pub fn elaborate_trait_ref<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n-) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n-    elaborate_obligations(\n-        tcx,\n-        predicates\n-            .map(|predicate| {\n-                Obligation::new(\n-                    tcx,\n-                    // We'll dump the cause/param-env later\n-                    ObligationCause::dummy(),\n-                    ty::ParamEnv::empty(),\n-                    predicate,\n-                )\n-            })\n-            .collect(),\n-    )\n-    .map(|obl| obl.predicate)\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Elaborator<'tcx, ty::Predicate<'tcx>> {\n+    elaborate(tcx, std::iter::once(trait_ref.without_const().to_predicate(tcx)))\n }\n \n-pub fn elaborate_predicates_with_span<'tcx>(\n+pub fn elaborate_trait_refs<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    predicates: impl Iterator<Item = (ty::Predicate<'tcx>, Span)>,\n-) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> {\n-    elaborate_obligations(\n-        tcx,\n-        predicates\n-            .map(|(predicate, span)| {\n-                Obligation::new(\n-                    tcx,\n-                    // We'll dump the cause/param-env later\n-                    ObligationCause::dummy_with_span(span),\n-                    ty::ParamEnv::empty(),\n-                    predicate,\n-                )\n-            })\n-            .collect(),\n-    )\n-    .map(|obl| (obl.predicate, obl.cause.span))\n+    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Elaborator<'tcx, ty::Predicate<'tcx>> {\n+    elaborate(tcx, trait_refs.map(|trait_ref| trait_ref.to_predicate(tcx)))\n }\n \n-pub fn elaborate_obligations<'tcx>(\n+pub fn elaborate<'tcx, O: Elaboratable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n-    obligations: Vec<PredicateObligation<'tcx>>,\n-) -> Elaborator<'tcx> {\n+    obligations: impl IntoIterator<Item = O>,\n+) -> Elaborator<'tcx, O> {\n     let mut elaborator = Elaborator { stack: Vec::new(), visited: PredicateSet::new(tcx) };\n     elaborator.extend_deduped(obligations);\n     elaborator\n }\n \n-fn predicate_obligation<'tcx>(\n-    predicate: ty::Predicate<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-) -> PredicateObligation<'tcx> {\n-    Obligation { cause, param_env, recursion_depth: 0, predicate }\n-}\n-\n-impl<'tcx> Elaborator<'tcx> {\n-    fn extend_deduped(&mut self, obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>) {\n+impl<'tcx, O: Elaboratable<'tcx>> Elaborator<'tcx, O> {\n+    fn extend_deduped(&mut self, obligations: impl IntoIterator<Item = O>) {\n         // Only keep those bounds that we haven't already seen.\n         // This is necessary to prevent infinite recursion in some\n         // cases. One common case is when people define\n         // `trait Sized: Sized { }` rather than `trait Sized { }`.\n         // let visited = &mut self.visited;\n-        self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate)));\n+        self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate())));\n     }\n \n-    fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n+    fn elaborate(&mut self, elaboratable: &O) {\n         let tcx = self.visited.tcx;\n \n-        let bound_predicate = obligation.predicate.kind();\n+        let bound_predicate = elaboratable.predicate().kind();\n         match bound_predicate.skip_binder() {\n             ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n                 // Get predicates declared on the trait.\n@@ -170,24 +214,11 @@ impl<'tcx> Elaborator<'tcx> {\n                         if data.constness == ty::BoundConstness::NotConst {\n                             pred = pred.without_const(tcx);\n                         }\n-\n-                        let cause = obligation.cause.clone().derived_cause(\n-                            bound_predicate.rebind(data),\n-                            |derived| {\n-                                traits::ImplDerivedObligation(Box::new(\n-                                    traits::ImplDerivedObligationCause {\n-                                        derived,\n-                                        impl_or_alias_def_id: data.def_id(),\n-                                        impl_def_predicate_index: Some(index),\n-                                        span,\n-                                    },\n-                                ))\n-                            },\n-                        );\n-                        predicate_obligation(\n+                        elaboratable.child_with_derived_cause(\n                             pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n-                            obligation.param_env,\n-                            cause,\n+                            span,\n+                            bound_predicate.rebind(data),\n+                            index,\n                         )\n                     });\n                 debug!(?data, ?obligations, \"super_predicates\");\n@@ -290,13 +321,7 @@ impl<'tcx> Elaborator<'tcx> {\n                         .map(|predicate_kind| {\n                             bound_predicate.rebind(predicate_kind).to_predicate(tcx)\n                         })\n-                        .map(|predicate| {\n-                            predicate_obligation(\n-                                predicate,\n-                                obligation.param_env,\n-                                obligation.cause.clone(),\n-                            )\n-                        }),\n+                        .map(|predicate| elaboratable.child(predicate)),\n                 );\n             }\n             ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n@@ -313,8 +338,8 @@ impl<'tcx> Elaborator<'tcx> {\n     }\n }\n \n-impl<'tcx> Iterator for Elaborator<'tcx> {\n-    type Item = PredicateObligation<'tcx>;\n+impl<'tcx, O: Elaboratable<'tcx>> Iterator for Elaborator<'tcx, O> {\n+    type Item = O;\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.stack.len(), None)"}, {"sha": "35c461f5acee81f78e8fb1f2026aa7620e315874", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -12,7 +12,7 @@ use rustc_errors::{pluralize, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_infer::traits::util::elaborate_predicates_with_span;\n+use rustc_infer::traits::util::elaborate;\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::Symbol;\n@@ -254,24 +254,21 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 }\n                 ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n                 ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n-                    elaborate_predicates_with_span(\n-                        cx.tcx,\n-                        cx.tcx.explicit_item_bounds(def).iter().cloned(),\n-                    )\n-                    .find_map(|(pred, _span)| {\n-                        // We only look at the `DefId`, so it is safe to skip the binder here.\n-                        if let ty::PredicateKind::Clause(ty::Clause::Trait(\n-                            ref poly_trait_predicate,\n-                        )) = pred.kind().skip_binder()\n-                        {\n-                            let def_id = poly_trait_predicate.trait_ref.def_id;\n-\n-                            is_def_must_use(cx, def_id, span)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n+                    elaborate(cx.tcx, cx.tcx.explicit_item_bounds(def).iter().cloned())\n+                        .find_map(|(pred, _span)| {\n+                            // We only look at the `DefId`, so it is safe to skip the binder here.\n+                            if let ty::PredicateKind::Clause(ty::Clause::Trait(\n+                                ref poly_trait_predicate,\n+                            )) = pred.kind().skip_binder()\n+                            {\n+                                let def_id = poly_trait_predicate.trait_ref.def_id;\n+\n+                                is_def_must_use(cx, def_id, span)\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n                 }\n                 ty::Dynamic(binders, _, _) => binders.iter().find_map(|predicate| {\n                     if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder()"}, {"sha": "839d5422ad1df0ae007d800e03ec19645b9536aa", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -115,10 +115,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             .predicates\n             .iter()\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n-        if traits::impossible_predicates(\n-            tcx,\n-            traits::elaborate_predicates(tcx, predicates).collect(),\n-        ) {\n+        if traits::impossible_predicates(tcx, traits::elaborate(tcx, predicates).collect()) {\n             trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;\n         }"}, {"sha": "85e229b694ceccce1a19a813f1f195ea4179c127", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -91,10 +91,7 @@ impl<'tcx> MirLint<'tcx> for ConstProp {\n             .predicates\n             .iter()\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n-        if traits::impossible_predicates(\n-            tcx,\n-            traits::elaborate_predicates(tcx, predicates).collect(),\n-        ) {\n+        if traits::impossible_predicates(tcx, traits::elaborate(tcx, predicates).collect()) {\n             trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;\n         }"}, {"sha": "6476da7ba489c99a72d90cff83cc4756504e1e87", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -9,7 +9,7 @@ use itertools::Itertools;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::util::elaborate_predicates;\n+use rustc_infer::traits::util::elaborate;\n use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, MaybeCause, QueryResult};\n use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::TypeFoldable;\n@@ -498,7 +498,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let tcx = self.tcx();\n         let own_bounds: FxIndexSet<_> =\n             bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)).collect();\n-        for assumption in elaborate_predicates(tcx, own_bounds.iter().copied()) {\n+        for assumption in elaborate(tcx, own_bounds.iter().copied()) {\n             // FIXME: Predicates are fully elaborated in the object type's existential bounds\n             // list. We want to only consider these pre-elaborated projections, and not other\n             // projection predicates that we reach by elaborating the principal trait ref,"}, {"sha": "a53d414be9e7a811613fbd461ba7c8c76fdf56b8", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -234,7 +234,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     /// constructed once for a given type. As part of the construction process, the `ParamEnv` will\n     /// have any supertrait bounds normalized -- e.g., if we have a type `struct Foo<T: Copy>`, the\n     /// `ParamEnv` will contain `T: Copy` and `T: Clone`, since `Copy: Clone`. When we construct our\n-    /// own `ParamEnv`, we need to do this ourselves, through `traits::elaborate_predicates`, or\n+    /// own `ParamEnv`, we need to do this ourselves, through `traits::elaborate`, or\n     /// else `SelectionContext` will choke on the missing predicates. However, this should never\n     /// show up in the final synthesized generics: we don't want our generated docs page to contain\n     /// something like `T: Copy + Clone`, as that's redundant. Therefore, we keep track of a\n@@ -346,10 +346,8 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 _ => panic!(\"Unexpected error for '{:?}': {:?}\", ty, result),\n             };\n \n-            let normalized_preds = elaborate_predicates(\n-                tcx,\n-                computed_preds.clone().chain(user_computed_preds.iter().cloned()),\n-            );\n+            let normalized_preds =\n+                elaborate(tcx, computed_preds.clone().chain(user_computed_preds.iter().cloned()));\n             new_env = ty::ParamEnv::new(\n                 tcx.mk_predicates_from_iter(normalized_preds),\n                 param_env.reveal(),"}, {"sha": "53d4f95e9e30fec17058656ceb43688302771574", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -368,7 +368,7 @@ fn negative_impl_exists<'tcx>(\n     }\n \n     // Try to prove a negative obligation exists for super predicates\n-    for pred in util::elaborate_predicates(infcx.tcx, iter::once(o.predicate)) {\n+    for pred in util::elaborate(infcx.tcx, iter::once(o.predicate)) {\n         if resolve_negative_obligation(infcx.fork(), &o.with(infcx.tcx, pred), body_def_id) {\n             return true;\n         }"}, {"sha": "0475f24d87c7f77d91bc70dbdf6d711dacd6dce8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/ambiguity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -1,6 +1,6 @@\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{InferCtxt, LateBoundRegionConversionTime};\n-use rustc_infer::traits::util::elaborate_predicates_with_span;\n+use rustc_infer::traits::util::elaborate;\n use rustc_infer::traits::{Obligation, ObligationCause, TraitObligation};\n use rustc_middle::ty;\n use rustc_span::{Span, DUMMY_SP};\n@@ -82,7 +82,7 @@ pub fn recompute_applicable_impls<'tcx>(\n \n     let predicates =\n         tcx.predicates_of(obligation.cause.body_id.to_def_id()).instantiate_identity(tcx);\n-    for (pred, span) in elaborate_predicates_with_span(tcx, predicates.into_iter()) {\n+    for (pred, span) in elaborate(tcx, predicates.into_iter()) {\n         let kind = pred.kind();\n         if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = kind.skip_binder()\n             && param_env_candidate_may_apply(kind.rebind(trait_pred))"}, {"sha": "6ebf056f0e837d1f2c1f65f7cd0c45ae007d3700", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -1624,7 +1624,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n         };\n \n-        for pred in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n+        for pred in super::elaborate(self.tcx, std::iter::once(cond)) {\n             let bound_predicate = pred.kind();\n             if let ty::PredicateKind::Clause(ty::Clause::Trait(implication)) =\n                 bound_predicate.skip_binder()"}, {"sha": "1094a77fe1477c239ea5954b8396adaa8ec69d33", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -58,10 +58,7 @@ pub use self::specialize::{specialization_graph, translate_substs, OverlapError}\n pub use self::structural_match::{\n     search_for_adt_const_param_violation, search_for_structural_match_violation,\n };\n-pub use self::util::{\n-    elaborate_obligations, elaborate_predicates, elaborate_predicates_with_span,\n-    elaborate_trait_ref, elaborate_trait_refs,\n-};\n+pub use self::util::{elaborate, elaborate_trait_ref, elaborate_trait_refs};\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n pub use self::util::{get_vtable_index_of_object_method, impl_item_is_final, upcast_choices};\n pub use self::util::{\n@@ -267,7 +264,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // and errors will get reported then; so outside of type inference we\n     // can be sure that no errors should occur.\n     let mut predicates: Vec<_> =\n-        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds().into_iter()).collect();\n+        util::elaborate(tcx, unnormalized_env.caller_bounds().into_iter()).collect();\n \n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n "}, {"sha": "9953d048f7557eff85dbaebf2ed90b7c14a921b2", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -8,7 +8,7 @@\n //!   - not reference the erased type `Self` except for in this receiver;\n //!   - not have generic type parameters.\n \n-use super::{elaborate_predicates, elaborate_trait_ref};\n+use super::{elaborate, elaborate_trait_ref};\n \n use crate::infer::TyCtxtInferExt;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -379,7 +379,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n-    elaborate_predicates(tcx, predicates.into_iter()).any(|pred| match pred.kind().skip_binder() {\n+    elaborate(tcx, predicates.into_iter()).any(|pred| match pred.kind().skip_binder() {\n         ty::PredicateKind::Clause(ty::Clause::Trait(ref trait_pred)) => {\n             trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n         }"}, {"sha": "3d026506a5a8d9fab7a3e8ff18be3fed2c94aa74", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -364,7 +364,7 @@ impl<'tcx> WfPredicates<'tcx> {\n         };\n \n         if let Elaborate::All = elaborate {\n-            let implied_obligations = traits::util::elaborate_obligations(tcx, obligations);\n+            let implied_obligations = traits::util::elaborate(tcx, obligations);\n             let implied_obligations = implied_obligations.map(extend);\n             self.out.extend(implied_obligations);\n         } else {\n@@ -920,7 +920,7 @@ pub(crate) fn required_region_bounds<'tcx>(\n ) -> Vec<ty::Region<'tcx>> {\n     assert!(!erased_self_ty.has_escaping_bound_vars());\n \n-    traits::elaborate_predicates(tcx, predicates)\n+    traits::elaborate(tcx, predicates)\n         .filter_map(|pred| {\n             debug!(?pred);\n             match pred.kind().skip_binder() {"}, {"sha": "0bb1775aae9cfb23c2c700c1cfb73109c927de67", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -122,7 +122,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n \n         let sized_trait = need!(cx.tcx.lang_items().sized_trait());\n \n-        let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds().iter())\n+        let preds = traits::elaborate(cx.tcx, cx.param_env.caller_bounds().iter())\n             .filter(|p| !p.is_global())\n             .filter_map(|pred| {\n                 // Note that we do not want to deal with qualified predicates here."}, {"sha": "9051cf51658df061b6b94bf213db999f6cb2334e", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/758bedc10454b1d101613f4b363fe54c7a405b00/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758bedc10454b1d101613f4b363fe54c7a405b00/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=758bedc10454b1d101613f4b363fe54c7a405b00", "patch": "@@ -2104,7 +2104,7 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n         .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n     traits::impossible_predicates(\n         cx.tcx,\n-        traits::elaborate_predicates(cx.tcx, predicates)\n+        traits::elaborate(cx.tcx, predicates)\n             .collect::<Vec<_>>(),\n     )\n }"}]}