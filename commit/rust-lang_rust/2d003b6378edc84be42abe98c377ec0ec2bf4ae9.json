{"sha": "2d003b6378edc84be42abe98c377ec0ec2bf4ae9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMDAzYjYzNzhlZGM4NGJlNDJhYmU5OGMzNzdlYzBlYzJiZjRhZTk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-22T14:43:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-22T14:43:15Z"}, "message": "Merge #2645\n\n2645: Simplify r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "513bb8b0a4ecb487dc1cf7be4bbc05c84ce9a975", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/513bb8b0a4ecb487dc1cf7be4bbc05c84ce9a975"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d003b6378edc84be42abe98c377ec0ec2bf4ae9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/4EDCRBK7hj4Ov3rIwAAdHIIAA+Xit3sWUAOirqqJcg2t6Tl\nFFihjwhmz80iJx55JcpIoc+V4GGNkxrtXJ3zv69BSDNEHEv5oVY5Yslal0ETpvdk\nAhH5kjAUL1sQnX6h593N0uOb8f9Z6dGuYjiCTTXSeegnKPN8Q4Whns4mPNiGp5hN\nlyCb2ZVPk/dQI15r0uTmhamPb9Quqr4hiWaogo2/ORhpQFiGaA2/R5JN1ar+KvrV\nogYI1n6ek4QWgv3bSXyUdDBwtA5zk2ndhAEy6nP0PnM5sdcyL4zmlW13pbt4yGpH\nMHuE6jzXi8XAQkjEQBvPAISfjZyXD8KPkvrQ1g3ZHtQwAyN8Ues9s6d5fCO5FsY=\n=PuEb\n-----END PGP SIGNATURE-----\n", "payload": "tree 513bb8b0a4ecb487dc1cf7be4bbc05c84ce9a975\nparent 9f616ed65a3cd3088a006ab9f116c2b9a2235cb6\nparent 6c3ddcfa501060cff3a7f81c179f712ef072c808\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1577025795 +0000\ncommitter GitHub <noreply@github.com> 1577025795 +0000\n\nMerge #2645\n\n2645: Simplify r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d003b6378edc84be42abe98c377ec0ec2bf4ae9", "html_url": "https://github.com/rust-lang/rust/commit/2d003b6378edc84be42abe98c377ec0ec2bf4ae9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f616ed65a3cd3088a006ab9f116c2b9a2235cb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f616ed65a3cd3088a006ab9f116c2b9a2235cb6", "html_url": "https://github.com/rust-lang/rust/commit/9f616ed65a3cd3088a006ab9f116c2b9a2235cb6"}, {"sha": "6c3ddcfa501060cff3a7f81c179f712ef072c808", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c3ddcfa501060cff3a7f81c179f712ef072c808", "html_url": "https://github.com/rust-lang/rust/commit/6c3ddcfa501060cff3a7f81c179f712ef072c808"}], "stats": {"total": 248, "additions": 108, "deletions": 140}, "files": [{"sha": "bcfc0d03eca920dc1d42c37a52e7a602276f587e", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=2d003b6378edc84be42abe98c377ec0ec2bf4ae9", "patch": "@@ -184,7 +184,7 @@ impl Module {\n         db.crate_def_map(self.id.krate)[self.id.local_id]\n             .scope\n             .entries()\n-            .map(|(name, res)| (name.clone(), res.def.into()))\n+            .map(|(name, def)| (name.clone(), def.into()))\n             .collect()\n     }\n "}, {"sha": "a6355232750a46e8acac4e2f83362581ef0a9359", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=2d003b6378edc84be42abe98c377ec0ec2bf4ae9", "patch": "@@ -183,8 +183,8 @@ mod tests {\n         let crate_def_map = db.crate_def_map(krate);\n \n         let module = crate_def_map.modules_for_file(file_id).next().unwrap();\n-        let (_, res) = crate_def_map[module].scope.entries().next().unwrap();\n-        match res.def.take_values().unwrap() {\n+        let (_, def) = crate_def_map[module].scope.entries().next().unwrap();\n+        match def.take_values().unwrap() {\n             ModuleDefId::FunctionId(it) => it,\n             _ => panic!(),\n         }"}, {"sha": "f1adc3b58ceba703280805088f5c1f3bc8198589", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=2d003b6378edc84be42abe98c377ec0ec2bf4ae9", "patch": "@@ -5,11 +5,12 @@ use hir_expand::name::Name;\n use once_cell::sync::Lazy;\n use rustc_hash::FxHashMap;\n \n-use crate::{per_ns::PerNs, BuiltinType, ImplId, MacroDefId, ModuleDefId, TraitId};\n+use crate::{per_ns::PerNs, AdtId, BuiltinType, ImplId, MacroDefId, ModuleDefId, TraitId};\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ItemScope {\n-    items: FxHashMap<Name, Resolution>,\n+    visible: FxHashMap<Name, PerNs>,\n+    defs: Vec<ModuleDefId>,\n     impls: Vec<ImplId>,\n     /// Macros visible in current module in legacy textual scope\n     ///\n@@ -26,12 +27,10 @@ pub struct ItemScope {\n     legacy_macros: FxHashMap<Name, MacroDefId>,\n }\n \n-static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n+static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n     BuiltinType::ALL\n         .iter()\n-        .map(|(name, ty)| {\n-            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), import: false })\n-        })\n+        .map(|(name, ty)| (name.clone(), PerNs::types(ty.clone().into())))\n         .collect()\n });\n \n@@ -47,17 +46,13 @@ pub(crate) enum BuiltinShadowMode {\n /// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n /// Other methods will only resolve values, types and module scoped macros only.\n impl ItemScope {\n-    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n+    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n         //FIXME: shadowing\n-        self.items.iter().chain(BUILTIN_SCOPE.iter())\n+        self.visible.iter().chain(BUILTIN_SCOPE.iter()).map(|(n, def)| (n, *def))\n     }\n \n     pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n-        self.entries()\n-            .filter_map(|(_name, res)| if !res.import { Some(res.def) } else { None })\n-            .flat_map(|per_ns| {\n-                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n-            })\n+        self.defs.iter().copied()\n     }\n \n     pub fn impls(&self) -> impl Iterator<Item = ImplId> + ExactSizeIterator + '_ {\n@@ -66,9 +61,7 @@ impl ItemScope {\n \n     /// Iterate over all module scoped macros\n     pub(crate) fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n-        self.items\n-            .iter()\n-            .filter_map(|(name, res)| res.def.take_macros().map(|macro_| (name, macro_)))\n+        self.visible.iter().filter_map(|(name, def)| def.take_macros().map(|macro_| (name, macro_)))\n     }\n \n     /// Iterate over all legacy textual scoped macros visible at the end of the module\n@@ -77,13 +70,13 @@ impl ItemScope {\n     }\n \n     /// Get a name from current module scope, legacy macros are not included\n-    pub(crate) fn get(&self, name: &Name, shadow: BuiltinShadowMode) -> Option<&Resolution> {\n+    pub(crate) fn get(&self, name: &Name, shadow: BuiltinShadowMode) -> Option<&PerNs> {\n         match shadow {\n-            BuiltinShadowMode::Module => self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name)),\n+            BuiltinShadowMode::Module => self.visible.get(name).or_else(|| BUILTIN_SCOPE.get(name)),\n             BuiltinShadowMode::Other => {\n-                let item = self.items.get(name);\n-                if let Some(res) = item {\n-                    if let Some(ModuleDefId::ModuleId(_)) = res.def.take_types() {\n+                let item = self.visible.get(name);\n+                if let Some(def) = item {\n+                    if let Some(ModuleDefId::ModuleId(_)) = def.take_types() {\n                         return BUILTIN_SCOPE.get(name).or(item);\n                     }\n                 }\n@@ -94,12 +87,16 @@ impl ItemScope {\n     }\n \n     pub(crate) fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n-        self.items.values().filter_map(|r| match r.def.take_types() {\n+        self.visible.values().filter_map(|def| match def.take_types() {\n             Some(ModuleDefId::TraitId(t)) => Some(t),\n             _ => None,\n         })\n     }\n \n+    pub(crate) fn define_def(&mut self, def: ModuleDefId) {\n+        self.defs.push(def)\n+    }\n+\n     pub(crate) fn get_legacy_macro(&self, name: &Name) -> Option<MacroDefId> {\n         self.legacy_macros.get(name).copied()\n     }\n@@ -112,44 +109,49 @@ impl ItemScope {\n         self.legacy_macros.insert(name, mac);\n     }\n \n-    pub(crate) fn push_res(&mut self, name: Name, res: &Resolution, import: bool) -> bool {\n+    pub(crate) fn push_res(&mut self, name: Name, def: &PerNs) -> bool {\n         let mut changed = false;\n-        let existing = self.items.entry(name.clone()).or_default();\n+        let existing = self.visible.entry(name.clone()).or_default();\n \n-        if existing.def.types.is_none() && res.def.types.is_some() {\n-            existing.def.types = res.def.types;\n-            existing.import = import || res.import;\n+        if existing.types.is_none() && def.types.is_some() {\n+            existing.types = def.types;\n             changed = true;\n         }\n-        if existing.def.values.is_none() && res.def.values.is_some() {\n-            existing.def.values = res.def.values;\n-            existing.import = import || res.import;\n+        if existing.values.is_none() && def.values.is_some() {\n+            existing.values = def.values;\n             changed = true;\n         }\n-        if existing.def.macros.is_none() && res.def.macros.is_some() {\n-            existing.def.macros = res.def.macros;\n-            existing.import = import || res.import;\n+        if existing.macros.is_none() && def.macros.is_some() {\n+            existing.macros = def.macros;\n             changed = true;\n         }\n \n-        if existing.def.is_none() && res.def.is_none() && !existing.import && res.import {\n-            existing.import = res.import;\n-        }\n         changed\n     }\n \n-    pub(crate) fn collect_resolutions(&self) -> Vec<(Name, Resolution)> {\n-        self.items.iter().map(|(name, res)| (name.clone(), res.clone())).collect()\n+    pub(crate) fn collect_resolutions(&self) -> Vec<(Name, PerNs)> {\n+        self.visible.iter().map(|(name, res)| (name.clone(), res.clone())).collect()\n     }\n \n     pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroDefId> {\n         self.legacy_macros.clone()\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Default)]\n-pub struct Resolution {\n-    /// None for unresolved\n-    pub def: PerNs,\n-    pub(crate) import: bool,\n+impl From<ModuleDefId> for PerNs {\n+    fn from(def: ModuleDefId) -> PerNs {\n+        match def {\n+            ModuleDefId::ModuleId(_) => PerNs::types(def),\n+            ModuleDefId::FunctionId(_) => PerNs::values(def),\n+            ModuleDefId::AdtId(adt) => match adt {\n+                AdtId::StructId(_) | AdtId::UnionId(_) => PerNs::both(def, def),\n+                AdtId::EnumId(_) => PerNs::types(def),\n+            },\n+            ModuleDefId::EnumVariantId(_) => PerNs::both(def, def),\n+            ModuleDefId::ConstId(_) | ModuleDefId::StaticId(_) => PerNs::values(def),\n+            ModuleDefId::TraitId(_) => PerNs::types(def),\n+            ModuleDefId::TypeAliasId(_) => PerNs::types(def),\n+            ModuleDefId::BuiltinType(_) => PerNs::types(def),\n+        }\n+    }\n }"}, {"sha": "4f1fd480181ea1c239ce3b7053650bca97fb61dc", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 47, "deletions": 77, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=2d003b6378edc84be42abe98c377ec0ec2bf4ae9", "patch": "@@ -18,7 +18,6 @@ use test_utils::tested_by;\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    item_scope::Resolution,\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n         raw, BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, ResolveMode,\n@@ -215,11 +214,7 @@ where\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n         // crate root, even if the parent modules is **not** visible.\n         if export {\n-            self.update(\n-                self.def_map.root,\n-                None,\n-                &[(name, Resolution { def: PerNs::macros(macro_), import: false })],\n-            );\n+            self.update(self.def_map.root, &[(name, PerNs::macros(macro_))]);\n         }\n     }\n \n@@ -373,7 +368,7 @@ where\n                         // Module scoped macros is included\n                         let items = scope.collect_resolutions();\n \n-                        self.update(module_id, Some(import_id), &items);\n+                        self.update(module_id, &items);\n                     } else {\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n@@ -383,7 +378,7 @@ where\n                         // Module scoped macros is included\n                         let items = scope.collect_resolutions();\n \n-                        self.update(module_id, Some(import_id), &items);\n+                        self.update(module_id, &items);\n                         // record the glob import in case we add further items\n                         let glob = self.glob_imports.entry(m.local_id).or_default();\n                         if !glob.iter().any(|it| *it == (module_id, import_id)) {\n@@ -401,14 +396,11 @@ where\n                         .map(|(local_id, variant_data)| {\n                             let name = variant_data.name.clone();\n                             let variant = EnumVariantId { parent: e, local_id };\n-                            let res = Resolution {\n-                                def: PerNs::both(variant.into(), variant.into()),\n-                                import: true,\n-                            };\n+                            let res = PerNs::both(variant.into(), variant.into());\n                             (name, res)\n                         })\n                         .collect::<Vec<_>>();\n-                    self.update(module_id, Some(import_id), &resolutions);\n+                    self.update(module_id, &resolutions);\n                 }\n                 Some(d) => {\n                     log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n@@ -430,28 +422,21 @@ where\n                         }\n                     }\n \n-                    let resolution = Resolution { def, import: true };\n-                    self.update(module_id, Some(import_id), &[(name, resolution)]);\n+                    self.update(module_id, &[(name, def)]);\n                 }\n                 None => tested_by!(bogus_paths),\n             }\n         }\n     }\n \n-    fn update(\n-        &mut self,\n-        module_id: LocalModuleId,\n-        import: Option<raw::Import>,\n-        resolutions: &[(Name, Resolution)],\n-    ) {\n-        self.update_recursive(module_id, import, resolutions, 0)\n+    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, PerNs)]) {\n+        self.update_recursive(module_id, resolutions, 0)\n     }\n \n     fn update_recursive(\n         &mut self,\n         module_id: LocalModuleId,\n-        import: Option<raw::Import>,\n-        resolutions: &[(Name, Resolution)],\n+        resolutions: &[(Name, PerNs)],\n         depth: usize,\n     ) {\n         if depth > 100 {\n@@ -461,7 +446,7 @@ where\n         let scope = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            changed |= scope.push_res(name.clone(), res, import.is_some());\n+            changed |= scope.push_res(name.clone(), res);\n         }\n \n         if !changed {\n@@ -474,9 +459,9 @@ where\n             .flat_map(|v| v.iter())\n             .cloned()\n             .collect::<Vec<_>>();\n-        for (glob_importing_module, glob_import) in glob_imports {\n+        for (glob_importing_module, _glob_import) in glob_imports {\n             // We pass the glob import so that the tracked import in those modules is that glob import\n-            self.update_recursive(glob_importing_module, Some(glob_import), resolutions, depth + 1);\n+            self.update_recursive(glob_importing_module, resolutions, depth + 1);\n         }\n     }\n \n@@ -714,13 +699,10 @@ where\n             modules[res].scope.define_legacy_macro(name, mac)\n         }\n         modules[self.module_id].children.insert(name.clone(), res);\n-        let resolution = Resolution {\n-            def: PerNs::types(\n-                ModuleId { krate: self.def_collector.def_map.krate, local_id: res }.into(),\n-            ),\n-            import: false,\n-        };\n-        self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n+        let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: res };\n+        let def: ModuleDefId = module.into();\n+        self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n+        self.def_collector.update(self.module_id, &[(name, def.into())]);\n         res\n     }\n \n@@ -734,64 +716,52 @@ where\n \n         let name = def.name.clone();\n         let container = ContainerId::ModuleId(module);\n-        let def: PerNs = match def.kind {\n-            raw::DefKind::Function(ast_id) => {\n-                let def = FunctionLoc {\n-                    container: container.into(),\n-                    ast_id: AstId::new(self.file_id, ast_id),\n-                }\n-                .intern(self.def_collector.db);\n-\n-                PerNs::values(def.into())\n+        let def: ModuleDefId = match def.kind {\n+            raw::DefKind::Function(ast_id) => FunctionLoc {\n+                container: container.into(),\n+                ast_id: AstId::new(self.file_id, ast_id),\n             }\n+            .intern(self.def_collector.db)\n+            .into(),\n             raw::DefKind::Struct(ast_id) => {\n-                let def = StructLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db);\n-                PerNs::both(def.into(), def.into())\n+                StructLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db)\n+                    .into()\n             }\n             raw::DefKind::Union(ast_id) => {\n-                let def = UnionLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db);\n-                PerNs::both(def.into(), def.into())\n+                UnionLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db)\n+                    .into()\n             }\n             raw::DefKind::Enum(ast_id) => {\n-                let def = EnumLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db);\n-                PerNs::types(def.into())\n+                EnumLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db)\n+                    .into()\n             }\n             raw::DefKind::Const(ast_id) => {\n-                let def = ConstLoc {\n-                    container: container.into(),\n-                    ast_id: AstId::new(self.file_id, ast_id),\n-                }\n-                .intern(self.def_collector.db);\n-\n-                PerNs::values(def.into())\n+                ConstLoc { container: container.into(), ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db)\n+                    .into()\n             }\n             raw::DefKind::Static(ast_id) => {\n-                let def = StaticLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db);\n-\n-                PerNs::values(def.into())\n+                StaticLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db)\n+                    .into()\n             }\n             raw::DefKind::Trait(ast_id) => {\n-                let def = TraitLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db);\n-\n-                PerNs::types(def.into())\n+                TraitLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n+                    .intern(self.def_collector.db)\n+                    .into()\n             }\n-            raw::DefKind::TypeAlias(ast_id) => {\n-                let def = TypeAliasLoc {\n-                    container: container.into(),\n-                    ast_id: AstId::new(self.file_id, ast_id),\n-                }\n-                .intern(self.def_collector.db);\n-\n-                PerNs::types(def.into())\n+            raw::DefKind::TypeAlias(ast_id) => TypeAliasLoc {\n+                container: container.into(),\n+                ast_id: AstId::new(self.file_id, ast_id),\n             }\n+            .intern(self.def_collector.db)\n+            .into(),\n         };\n-        let resolution = Resolution { def, import: false };\n-        self.def_collector.update(self.module_id, None, &[(name, resolution)])\n+        self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n+        self.def_collector.update(self.module_id, &[(name, def.into())])\n     }\n \n     fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {"}, {"sha": "378d49455527abbc9ce2cef59b9a480e0804f64c", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=2d003b6378edc84be42abe98c377ec0ec2bf4ae9", "patch": "@@ -181,7 +181,7 @@ impl CrateDefMap {\n \n                     // Since it is a qualified path here, it should not contains legacy macros\n                     match self[module.local_id].scope.get(&segment, prefer_module(i)) {\n-                        Some(res) => res.def,\n+                        Some(def) => *def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment);\n                             return ResolvePathResult::empty(ReachedFixedPoint::No);\n@@ -243,8 +243,7 @@ impl CrateDefMap {\n         //  - std prelude\n         let from_legacy_macro =\n             self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n-        let from_scope =\n-            self[module].scope.get(name, shadow).map_or_else(PerNs::none, |res| res.def);\n+        let from_scope = self[module].scope.get(name, shadow).copied().unwrap_or_else(PerNs::none);\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n         let from_prelude = self.resolve_in_prelude(db, name, shadow);\n@@ -258,7 +257,7 @@ impl CrateDefMap {\n         shadow: BuiltinShadowMode,\n     ) -> PerNs {\n         let from_crate_root =\n-            self[self.root].scope.get(name, shadow).map_or_else(PerNs::none, |res| res.def);\n+            self[self.root].scope.get(name, shadow).copied().unwrap_or_else(PerNs::none);\n         let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n \n         from_crate_root.or(from_extern_prelude)\n@@ -279,10 +278,7 @@ impl CrateDefMap {\n                 keep = db.crate_def_map(prelude.krate);\n                 &keep\n             };\n-            def_map[prelude.local_id]\n-                .scope\n-                .get(name, shadow)\n-                .map_or_else(PerNs::none, |res| res.def)\n+            def_map[prelude.local_id].scope.get(name, shadow).copied().unwrap_or_else(PerNs::none)\n         } else {\n             PerNs::none()\n         }"}, {"sha": "ff474b53b01eee6669bcbadf6ffd4ef9b2cf9c63", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=2d003b6378edc84be42abe98c377ec0ec2bf4ae9", "patch": "@@ -35,19 +35,19 @@ fn render_crate_def_map(map: &CrateDefMap) -> String {\n         let mut entries = map.modules[module].scope.collect_resolutions();\n         entries.sort_by_key(|(name, _)| name.clone());\n \n-        for (name, res) in entries {\n+        for (name, def) in entries {\n             *buf += &format!(\"{}:\", name);\n \n-            if res.def.types.is_some() {\n+            if def.types.is_some() {\n                 *buf += \" t\";\n             }\n-            if res.def.values.is_some() {\n+            if def.values.is_some() {\n                 *buf += \" v\";\n             }\n-            if res.def.macros.is_some() {\n+            if def.macros.is_some() {\n                 *buf += \" m\";\n             }\n-            if res.def.is_none() {\n+            if def.is_none() {\n                 *buf += \" _\";\n             }\n "}, {"sha": "e70049617dda5e32eb5a29ca16d935643e2a3e56", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d003b6378edc84be42abe98c377ec0ec2bf4ae9/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=2d003b6378edc84be42abe98c377ec0ec2bf4ae9", "patch": "@@ -413,8 +413,8 @@ impl Scope {\n                 //         def: m.module.into(),\n                 //     }),\n                 // );\n-                m.crate_def_map[m.module_id].scope.entries().for_each(|(name, res)| {\n-                    f(name.clone(), ScopeDef::PerNs(res.def));\n+                m.crate_def_map[m.module_id].scope.entries().for_each(|(name, def)| {\n+                    f(name.clone(), ScopeDef::PerNs(def));\n                 });\n                 m.crate_def_map[m.module_id].scope.legacy_macros().for_each(|(name, macro_)| {\n                     f(name.clone(), ScopeDef::PerNs(PerNs::macros(macro_)));\n@@ -424,8 +424,8 @@ impl Scope {\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);\n-                    prelude_def_map[prelude.local_id].scope.entries().for_each(|(name, res)| {\n-                        f(name.clone(), ScopeDef::PerNs(res.def));\n+                    prelude_def_map[prelude.local_id].scope.entries().for_each(|(name, def)| {\n+                        f(name.clone(), ScopeDef::PerNs(def));\n                     });\n                 }\n             }"}]}