{"sha": "9d39758d14df45956b1a8d8132e3e40c3558dd4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMzk3NThkMTRkZjQ1OTU2YjFhOGQ4MTMyZTNlNDBjMzU1OGRkNGI=", "commit": {"author": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2019-07-25T16:06:26Z"}, "committer": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2019-07-25T16:06:26Z"}, "message": "Remove `cfg(bootstrap)` code for array implementations\n\nIn PR #62435 (\"Use const generics for array impls [part 1]\") the old\nmacro-based implementations were not removed but still used with\n`cfg(bootstrap)` since the bootstrap compiler had some problems with\nconst generics at the time. This does not seem to be the case anymore,\nso there is no reason to keep the old code.", "tree": {"sha": "4c48e5ca396bd8c644e0806b1122a6c1ababbdb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c48e5ca396bd8c644e0806b1122a6c1ababbdb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d39758d14df45956b1a8d8132e3e40c3558dd4b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEENwctvZ5TgcKYXim8PLr0FT+BhicFAl0504IACgkQPLr0FT+B\nhidKTBAAioZF7TWsfeedirHl1vFVUi0MDEQI2CTbP7+wOTh4oVP9UYGNHT1IZ7CC\nm3Np1r5FtNka31V1T8qskeR3ZdoB7YHMRCtO4JDXOEQgPZ2BGm0TElo0N3G7dWmT\nL5wPSmdtmqOJ2SbfJMSiMCr4g604/NzO/e2WqlmPpwzoWcxaD15BD/RsnprqrBP5\nilLRfVtFoGwj4/BQwyOE2rnHzaIdmoI/4FwnU0aR9KBX7g/ePcAI9ZhVHeUDJCJd\nfPOxquH+5aD1I7xyqRdB6ONJpkGbCZll3fEu2osu97v/k8Gd+iAYTcGJdOxI/4jB\nvYfkUotmxvRcUPLF36nv/OBfjKlIij96mZ29qKQEVH1kRcahf3hPKarjI7inzFTP\nG1r9IeRt9FPgQJUF6z75ctQky/q7i+pNXnMTTxRg+MXKOJI6m4/mLvT270h4RtC1\nD52VdcYHwG6MWD/iYaCIYOktUOlAZulsutebd1tezkki9dWACKR18MOr+RM9793i\nxTyRxNkvkBuAv/efui75A1DCeauYCxfYcNLPpeUUAvieiVdBVF23uCyIa5lcRhy9\nwLDr3DTa9+PIXTKyoqYpcGYHlZfZKmKOmzQpI/0NwaiRMIGLHyFqgfkm/tYaN9G2\nwF0X/v1pmejZ5BBGJFs1JG5vgHs0JhqEpafz/taQ9DlCsDA1InM=\n=eCNH\n-----END PGP SIGNATURE-----", "payload": "tree 4c48e5ca396bd8c644e0806b1122a6c1ababbdb3\nparent e649e903440bfd919bfc9db848c28df6d795a116\nauthor Lukas Kalbertodt <lukas.kalbertodt@gmail.com> 1564070786 +0200\ncommitter Lukas Kalbertodt <lukas.kalbertodt@gmail.com> 1564070786 +0200\n\nRemove `cfg(bootstrap)` code for array implementations\n\nIn PR #62435 (\"Use const generics for array impls [part 1]\") the old\nmacro-based implementations were not removed but still used with\n`cfg(bootstrap)` since the bootstrap compiler had some problems with\nconst generics at the time. This does not seem to be the case anymore,\nso there is no reason to keep the old code.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d39758d14df45956b1a8d8132e3e40c3558dd4b", "html_url": "https://github.com/rust-lang/rust/commit/9d39758d14df45956b1a8d8132e3e40c3558dd4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d39758d14df45956b1a8d8132e3e40c3558dd4b/comments", "author": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e649e903440bfd919bfc9db848c28df6d795a116", "url": "https://api.github.com/repos/rust-lang/rust/commits/e649e903440bfd919bfc9db848c28df6d795a116", "html_url": "https://github.com/rust-lang/rust/commit/e649e903440bfd919bfc9db848c28df6d795a116"}], "stats": {"total": 675, "additions": 241, "deletions": 434}, "files": [{"sha": "6ecc0487fae1b16fdadaf00c94d36a3117a9b373", "filename": "src/libcore/array.rs", "status": "modified", "additions": 240, "deletions": 433, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/9d39758d14df45956b1a8d8132e3e40c3558dd4b/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39758d14df45956b1a8d8132e3e40c3558dd4b/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=9d39758d14df45956b1a8d8132e3e40c3558dd4b", "patch": "@@ -81,487 +81,296 @@ impl From<Infallible> for TryFromSliceError {\n     }\n }\n \n-#[cfg(bootstrap)]\n-macro_rules! __impl_slice_eq1 {\n-    ($Lhs: ty, $Rhs: ty) => {\n-        __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n-    };\n-    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n-            #[inline]\n-            fn eq(&self, other: &$Rhs) -> bool { self[..] == other[..] }\n-            #[inline]\n-            fn ne(&self, other: &$Rhs) -> bool { self[..] != other[..] }\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, const N: usize> AsRef<[T]> for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn as_ref(&self) -> &[T] {\n+        &self[..]\n     }\n }\n \n-#[cfg(bootstrap)]\n-macro_rules! __impl_slice_eq2 {\n-    ($Lhs: ty, $Rhs: ty) => {\n-        __impl_slice_eq2! { $Lhs, $Rhs, Sized }\n-    };\n-    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n-        __impl_slice_eq1!($Lhs, $Rhs, $Bound);\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, 'b, A: $Bound, B> PartialEq<$Lhs> for $Rhs where B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &$Lhs) -> bool { self[..] == other[..] }\n-            #[inline]\n-            fn ne(&self, other: &$Lhs) -> bool { self[..] != other[..] }\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, const N: usize> AsMut<[T]> for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn as_mut(&mut self) -> &mut [T] {\n+        &mut self[..]\n     }\n }\n \n-// macro for implementing n-element array functions and operations\n-#[cfg(bootstrap)]\n-macro_rules! array_impls {\n-    ($($N:expr)+) => {\n-        $(\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T> AsRef<[T]> for [T; $N] {\n-                #[inline]\n-                fn as_ref(&self) -> &[T] {\n-                    &self[..]\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T> AsMut<[T]> for [T; $N] {\n-                #[inline]\n-                fn as_mut(&mut self) -> &mut [T] {\n-                    &mut self[..]\n-                }\n-            }\n-\n-            #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-            impl<T> Borrow<[T]> for [T; $N] {\n-                fn borrow(&self) -> &[T] {\n-                    self\n-                }\n-            }\n-\n-            #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-            impl<T> BorrowMut<[T]> for [T; $N] {\n-                fn borrow_mut(&mut self) -> &mut [T] {\n-                    self\n-                }\n-            }\n-\n-            #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-            impl<T> TryFrom<&[T]> for [T; $N] where T: Copy {\n-                type Error = TryFromSliceError;\n-\n-                fn try_from(slice: &[T]) -> Result<[T; $N], TryFromSliceError> {\n-                    <&Self>::try_from(slice).map(|r| *r)\n-                }\n-            }\n-\n-            #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-            impl<'a, T> TryFrom<&'a [T]> for &'a [T; $N] {\n-                type Error = TryFromSliceError;\n-\n-                fn try_from(slice: &[T]) -> Result<&[T; $N], TryFromSliceError> {\n-                    if slice.len() == $N {\n-                        let ptr = slice.as_ptr() as *const [T; $N];\n-                        unsafe { Ok(&*ptr) }\n-                    } else {\n-                        Err(TryFromSliceError(()))\n-                    }\n-                }\n-            }\n-\n-            #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-            impl<'a, T> TryFrom<&'a mut [T]> for &'a mut [T; $N] {\n-                type Error = TryFromSliceError;\n-\n-                fn try_from(slice: &mut [T]) -> Result<&mut [T; $N], TryFromSliceError> {\n-                    if slice.len() == $N {\n-                        let ptr = slice.as_mut_ptr() as *mut [T; $N];\n-                        unsafe { Ok(&mut *ptr) }\n-                    } else {\n-                        Err(TryFromSliceError(()))\n-                    }\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T: Hash> Hash for [T; $N] {\n-                fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-                    Hash::hash(&self[..], state)\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T: fmt::Debug> fmt::Debug for [T; $N] {\n-                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                    fmt::Debug::fmt(&&self[..], f)\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<'a, T> IntoIterator for &'a [T; $N] {\n-                type Item = &'a T;\n-                type IntoIter = Iter<'a, T>;\n-\n-                fn into_iter(self) -> Iter<'a, T> {\n-                    self.iter()\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<'a, T> IntoIterator for &'a mut [T; $N] {\n-                type Item = &'a mut T;\n-                type IntoIter = IterMut<'a, T>;\n-\n-                fn into_iter(self) -> IterMut<'a, T> {\n-                    self.iter_mut()\n-                }\n-            }\n-\n-            // NOTE: some less important impls are omitted to reduce code bloat\n-            __impl_slice_eq1! { [A; $N], [B; $N] }\n-            __impl_slice_eq2! { [A; $N], [B] }\n-            __impl_slice_eq2! { [A; $N], &'b [B] }\n-            __impl_slice_eq2! { [A; $N], &'b mut [B] }\n-            // __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n-            // __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T:Eq> Eq for [T; $N] { }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T:PartialOrd> PartialOrd for [T; $N] {\n-                #[inline]\n-                fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n-                    PartialOrd::partial_cmp(&&self[..], &&other[..])\n-                }\n-                #[inline]\n-                fn lt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::lt(&&self[..], &&other[..])\n-                }\n-                #[inline]\n-                fn le(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::le(&&self[..], &&other[..])\n-                }\n-                #[inline]\n-                fn ge(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::ge(&&self[..], &&other[..])\n-                }\n-                #[inline]\n-                fn gt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::gt(&&self[..], &&other[..])\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T:Ord> Ord for [T; $N] {\n-                #[inline]\n-                fn cmp(&self, other: &[T; $N]) -> Ordering {\n-                    Ord::cmp(&&self[..], &&other[..])\n-                }\n-            }\n-        )+\n+#[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n+impl<T, const N: usize> Borrow<[T]> for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn borrow(&self) -> &[T] {\n+        self\n     }\n }\n \n-#[cfg(not(bootstrap))]\n-mod impls_using_const_generics {\n-    use super::*;\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T, const N: usize> AsRef<[T]> for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn as_ref(&self) -> &[T] {\n-            &self[..]\n-        }\n+#[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n+impl<T, const N: usize> BorrowMut<[T]> for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn borrow_mut(&mut self) -> &mut [T] {\n+        self\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T, const N: usize> AsMut<[T]> for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn as_mut(&mut self) -> &mut [T] {\n-            &mut self[..]\n-        }\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl<T, const N: usize> TryFrom<&[T]> for [T; N]\n+where\n+    T: Copy,\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = TryFromSliceError;\n+\n+    fn try_from(slice: &[T]) -> Result<[T; N], TryFromSliceError> {\n+        <&Self>::try_from(slice).map(|r| *r)\n     }\n+}\n \n-    #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-    impl<T, const N: usize> Borrow<[T]> for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        fn borrow(&self) -> &[T] {\n-            self\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = TryFromSliceError;\n+\n+    fn try_from(slice: &[T]) -> Result<&[T; N], TryFromSliceError> {\n+        if slice.len() == N {\n+            let ptr = slice.as_ptr() as *const [T; N];\n+            unsafe { Ok(&*ptr) }\n+        } else {\n+            Err(TryFromSliceError(()))\n         }\n     }\n+}\n \n-    #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-    impl<T, const N: usize> BorrowMut<[T]> for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        fn borrow_mut(&mut self) -> &mut [T] {\n-            self\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = TryFromSliceError;\n+\n+    fn try_from(slice: &mut [T]) -> Result<&mut [T; N], TryFromSliceError> {\n+        if slice.len() == N {\n+            let ptr = slice.as_mut_ptr() as *mut [T; N];\n+            unsafe { Ok(&mut *ptr) }\n+        } else {\n+            Err(TryFromSliceError(()))\n         }\n     }\n+}\n \n-    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-    impl<T, const N: usize> TryFrom<&[T]> for [T; N]\n-    where\n-        T: Copy,\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Error = TryFromSliceError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Hash, const N: usize> Hash for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        Hash::hash(&self[..], state)\n+    }\n+}\n \n-        fn try_from(slice: &[T]) -> Result<[T; N], TryFromSliceError> {\n-            <&Self>::try_from(slice).map(|r| *r)\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&&self[..], f)\n     }\n+}\n \n-    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-    impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Error = TryFromSliceError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, const N: usize> IntoIterator for &'a [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n \n-        fn try_from(slice: &[T]) -> Result<&[T; N], TryFromSliceError> {\n-            if slice.len() == N {\n-                let ptr = slice.as_ptr() as *const [T; N];\n-                unsafe { Ok(&*ptr) }\n-            } else {\n-                Err(TryFromSliceError(()))\n-            }\n-        }\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n     }\n+}\n \n-    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-    impl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Error = TryFromSliceError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, const N: usize> IntoIterator for &'a mut [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Item = &'a mut T;\n+    type IntoIter = IterMut<'a, T>;\n \n-        fn try_from(slice: &mut [T]) -> Result<&mut [T; N], TryFromSliceError> {\n-            if slice.len() == N {\n-                let ptr = slice.as_mut_ptr() as *mut [T; N];\n-                unsafe { Ok(&mut *ptr) }\n-            } else {\n-                Err(TryFromSliceError(()))\n-            }\n-        }\n+    fn into_iter(self) -> IterMut<'a, T> {\n+        self.iter_mut()\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Hash, const N: usize> Hash for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-            Hash::hash(&self[..], state)\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[B; N]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+    [A; N]: LengthAtMost32,\n+    [B; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[B; N]) -> bool {\n+        self[..] == other[..]\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: fmt::Debug, const N: usize> fmt::Debug for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            fmt::Debug::fmt(&&self[..], f)\n-        }\n+    #[inline]\n+    fn ne(&self, other: &[B; N]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, T, const N: usize> IntoIterator for &'a [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Item = &'a T;\n-        type IntoIter = Iter<'a, T>;\n-\n-        fn into_iter(self) -> Iter<'a, T> {\n-            self.iter()\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[B]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[B]) -> bool {\n+        self[..] == other[..]\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, T, const N: usize> IntoIterator for &'a mut [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Item = &'a mut T;\n-        type IntoIter = IterMut<'a, T>;\n-\n-        fn into_iter(self) -> IterMut<'a, T> {\n-            self.iter_mut()\n-        }\n+    #[inline]\n+    fn ne(&self, other: &[B]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[B; N]> for [A; N]\n-    where\n-        A: PartialEq<B>,\n-        [A; N]: LengthAtMost32,\n-        [B; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[B; N]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[B; N]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for [B]\n+where\n+    B: PartialEq<A>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[A; N]) -> bool {\n+        self[..] == other[..]\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[B]> for [A; N]\n-    where\n-        A: PartialEq<B>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[B]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[B]) -> bool {\n-            self[..] != other[..]\n-        }\n+    #[inline]\n+    fn ne(&self, other: &[A; N]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for [B]\n-    where\n-        B: PartialEq<A>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[A; N]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[A; N]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<&'b [B]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &&'b [B]) -> bool {\n+        self[..] == other[..]\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<&'b [B]> for [A; N]\n-    where\n-        A: PartialEq<B>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &&'b [B]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &&'b [B]) -> bool {\n-            self[..] != other[..]\n-        }\n+    #[inline]\n+    fn ne(&self, other: &&'b [B]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b [B]\n-    where\n-        B: PartialEq<A>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[A; N]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[A; N]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b [B]\n+where\n+    B: PartialEq<A>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[A; N]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &[A; N]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<&'b mut [B]> for [A; N]\n-    where\n-        A: PartialEq<B>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &&'b mut [B]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &&'b mut [B]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<&'b mut [B]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &&'b mut [B]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &&'b mut [B]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b mut [B]\n-    where\n-        B: PartialEq<A>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[A; N]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[A; N]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b mut [B]\n+where\n+    B: PartialEq<A>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[A; N]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &[A; N]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    // NOTE: some less important impls are omitted to reduce code bloat\n-    // __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n-    // __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n+// NOTE: some less important impls are omitted to reduce code bloat\n+// __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n+// __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Eq, const N: usize> Eq for [T; N] where [T; N]: LengthAtMost32 {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Eq, const N: usize> Eq for [T; N] where [T; N]: LengthAtMost32 {}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: PartialOrd, const N: usize> PartialOrd for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn partial_cmp(&self, other: &[T; N]) -> Option<Ordering> {\n-            PartialOrd::partial_cmp(&&self[..], &&other[..])\n-        }\n-        #[inline]\n-        fn lt(&self, other: &[T; N]) -> bool {\n-            PartialOrd::lt(&&self[..], &&other[..])\n-        }\n-        #[inline]\n-        fn le(&self, other: &[T; N]) -> bool {\n-            PartialOrd::le(&&self[..], &&other[..])\n-        }\n-        #[inline]\n-        fn ge(&self, other: &[T; N]) -> bool {\n-            PartialOrd::ge(&&self[..], &&other[..])\n-        }\n-        #[inline]\n-        fn gt(&self, other: &[T; N]) -> bool {\n-            PartialOrd::gt(&&self[..], &&other[..])\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: PartialOrd, const N: usize> PartialOrd for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn partial_cmp(&self, other: &[T; N]) -> Option<Ordering> {\n+        PartialOrd::partial_cmp(&&self[..], &&other[..])\n+    }\n+    #[inline]\n+    fn lt(&self, other: &[T; N]) -> bool {\n+        PartialOrd::lt(&&self[..], &&other[..])\n+    }\n+    #[inline]\n+    fn le(&self, other: &[T; N]) -> bool {\n+        PartialOrd::le(&&self[..], &&other[..])\n     }\n+    #[inline]\n+    fn ge(&self, other: &[T; N]) -> bool {\n+        PartialOrd::ge(&&self[..], &&other[..])\n+    }\n+    #[inline]\n+    fn gt(&self, other: &[T; N]) -> bool {\n+        PartialOrd::gt(&&self[..], &&other[..])\n+    }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Ord, const N: usize> Ord for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn cmp(&self, other: &[T; N]) -> Ordering {\n-            Ord::cmp(&&self[..], &&other[..])\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Ord, const N: usize> Ord for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn cmp(&self, other: &[T; N]) -> Ordering {\n+        Ord::cmp(&&self[..], &&other[..])\n     }\n }\n \n@@ -571,10 +380,8 @@ mod impls_using_const_generics {\n )]\n #[unstable(feature = \"const_generic_impls_guard\", issue = \"0\",\n     reason = \"will never be stable, just a temporary step until const generics are stable\")]\n-#[cfg(not(bootstrap))]\n pub trait LengthAtMost32 {}\n \n-#[cfg(not(bootstrap))]\n macro_rules! array_impls {\n     ($($N:literal)+) => {\n         $("}, {"sha": "9243dda84a6efa3f9d077581b46a6b944323afa6", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d39758d14df45956b1a8d8132e3e40c3558dd4b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d39758d14df45956b1a8d8132e3e40c3558dd4b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=9d39758d14df45956b1a8d8132e3e40c3558dd4b", "patch": "@@ -74,7 +74,7 @@\n #![feature(concat_idents)]\n #![feature(const_fn)]\n #![feature(const_fn_union)]\n-#![cfg_attr(not(bootstrap), feature(const_generics))]\n+#![feature(const_generics)]\n #![feature(custom_inner_attributes)]\n #![feature(decl_macro)]\n #![feature(doc_cfg)]"}]}