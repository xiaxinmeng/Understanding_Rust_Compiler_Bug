{"sha": "cfed923600e2f7ad34241501200d595abccdeb54", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZWQ5MjM2MDBlMmY3YWQzNDI0MTUwMTIwMGQ1OTVhYmNjZGViNTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-19T23:55:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-20T00:03:01Z"}, "message": "demode the each() method on vec and other iterables.", "tree": {"sha": "d382eb144026703d9abee0e6a99b87b34e9bd138", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d382eb144026703d9abee0e6a99b87b34e9bd138"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfed923600e2f7ad34241501200d595abccdeb54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfed923600e2f7ad34241501200d595abccdeb54", "html_url": "https://github.com/rust-lang/rust/commit/cfed923600e2f7ad34241501200d595abccdeb54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfed923600e2f7ad34241501200d595abccdeb54/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c39f1968c77a3d42b0fdb30a36cff4d94a17da2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c39f1968c77a3d42b0fdb30a36cff4d94a17da2", "html_url": "https://github.com/rust-lang/rust/commit/1c39f1968c77a3d42b0fdb30a36cff4d94a17da2"}], "stats": {"total": 939, "additions": 483, "deletions": 456}, "files": [{"sha": "11ba5257f8d41579871b2aa59a64e4ab13a3360e", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -325,9 +325,9 @@ fn load_crate(filename: &Path) -> Option<crate> {\n                 let mut attr_from = ~\"\";\n \n               for m.each |item| {\n-                    match attr::get_meta_item_value_str(item) {\n+                    match attr::get_meta_item_value_str(*item) {\n                         Some(value) => {\n-                            let name = attr::get_meta_item_name(item);\n+                            let name = attr::get_meta_item_name(*item);\n \n                             match name {\n                                 ~\"vers\" => attr_vers = value,\n@@ -530,7 +530,7 @@ fn load_one_source_package(src: source, p: map::HashMap<~str, json::Json>) {\n     match p.find(~\"tags\") {\n         Some(json::List(js)) => {\n           for (*js).each |j| {\n-                match j {\n+                match *j {\n                     json::String(j) => vec::grow(tags, 1u, *j),\n                     _ => ()\n                 }\n@@ -602,7 +602,7 @@ fn load_source_packages(c: &cargo, src: source) {\n     match json::from_str(result::get(pkgstr)) {\n         Ok(json::List(js)) => {\n           for (*js).each |j| {\n-                match j {\n+                match *j {\n                     json::Dict(p) => {\n                         load_one_source_package(src, p);\n                     }\n@@ -715,7 +715,7 @@ fn configure(opts: options) -> cargo {\n fn for_each_package(c: &cargo, b: fn(source, package)) {\n     for c.sources.each_value |v| {\n         for v.packages.each |p| {\n-            b(v, p);\n+            b(v, *p);\n         }\n     }\n }\n@@ -773,15 +773,15 @@ fn install_one_crate(c: &cargo, path: &Path, cf: &Path) {\n              !str::starts_with(option::get(ct.filename()),\n                                ~\"lib\")) {\n             debug!(\"  bin: %s\", ct.to_str());\n-            install_to_dir(ct, &c.bindir);\n+            install_to_dir(*ct, &c.bindir);\n             if c.opts.mode == system_mode {\n                 // FIXME (#2662): Put this file in PATH / symlink it so it can\n                 // be used as a generic executable\n                 // `cargo install -G rustray` and `rustray file.obj`\n             }\n         } else {\n             debug!(\"  lib: %s\", ct.to_str());\n-            install_to_dir(ct, &c.libdir);\n+            install_to_dir(*ct, &c.libdir);\n         }\n     }\n }\n@@ -814,7 +814,7 @@ fn install_source(c: &cargo, path: &Path) {\n     }\n \n     for cratefiles.each |cf| {\n-        match load_crate(&cf) {\n+        match load_crate(cf) {\n             None => loop,\n             Some(crate) => {\n               for crate.deps.each |query| {\n@@ -823,15 +823,15 @@ fn install_source(c: &cargo, path: &Path) {\n                     // condition\")\n \n                     let wd = get_temp_workdir(c);\n-                    install_query(c, &wd, query);\n+                    install_query(c, &wd, *query);\n                 }\n \n                 os::change_dir(path);\n \n                 if c.opts.test {\n-                    test_one_crate(c, path, &cf);\n+                    test_one_crate(c, path, cf);\n                 }\n-                install_one_crate(c, path, &cf);\n+                install_one_crate(c, path, cf);\n             }\n         }\n     }\n@@ -915,7 +915,7 @@ fn install_uuid(c: &cargo, wd: &Path, uuid: ~str) {\n     }\n     error(~\"found multiple packages:\");\n     for ps.each |elt| {\n-        let (sname,p) = copy elt;\n+        let (sname,p) = copy *elt;\n         info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n     }\n }\n@@ -939,7 +939,7 @@ fn install_named(c: &cargo, wd: &Path, name: ~str) {\n     }\n     error(~\"found multiple packages:\");\n     for ps.each |elt| {\n-        let (sname,p) = copy elt;\n+        let (sname,p) = copy *elt;\n         info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n     }\n }\n@@ -949,7 +949,7 @@ fn install_uuid_specific(c: &cargo, wd: &Path, src: ~str, uuid: ~str) {\n         Some(s) => {\n             for s.packages.each |p| {\n                 if p.uuid == uuid {\n-                    install_package(c, src, wd, p);\n+                    install_package(c, src, wd, *p);\n                     return;\n                 }\n             }\n@@ -964,7 +964,7 @@ fn install_named_specific(c: &cargo, wd: &Path, src: ~str, name: ~str) {\n         Some(s) => {\n             for s.packages.each |p| {\n                 if p.name == name {\n-                    install_package(c, src, wd, p);\n+                    install_package(c, src, wd, *p);\n                     return;\n                 }\n             }\n@@ -1002,22 +1002,22 @@ fn cmd_uninstall(c: &cargo) {\n \n     if is_uuid(target) {\n         for os::list_dir(lib).each |file| {\n-            match str::find_str(file, ~\"-\" + target + ~\"-\") {\n-              Some(_) => if !try_uninstall(&lib.push(file)) { return },\n+            match str::find_str(*file, ~\"-\" + target + ~\"-\") {\n+              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n               None => ()\n             }\n         }\n         error(~\"can't find package with uuid: \" + target);\n     } else {\n         for os::list_dir(lib).each |file| {\n-            match str::find_str(file, ~\"lib\" + target + ~\"-\") {\n-              Some(_) => if !try_uninstall(&lib.push(file)) { return },\n+            match str::find_str(*file, ~\"lib\" + target + ~\"-\") {\n+              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n               None => ()\n             }\n         }\n         for os::list_dir(bin).each |file| {\n-            match str::find_str(file, target) {\n-              Some(_) => if !try_uninstall(&lib.push(file)) { return },\n+            match str::find_str(*file, target) {\n+              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n               None => ()\n             }\n         }"}, {"sha": "17cb8dc6487892c2511ef5e91243686c63269750", "filename": "src/cargo/pgp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Fcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Fcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fpgp.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -95,7 +95,7 @@ fn verify(root: &Path, data: &Path, sig: &Path, keyfp: ~str) -> bool {\n                   ~\"--verify\", sig.to_str(),\n                  data.to_str()]);\n     let res = ~\"Primary key fingerprint: \" + keyfp;\n-    for str::split_char(p.err, '\\n').each |line| {\n+    for str::split_char_each(p.err, '\\n') |line| {\n         if line == res { return true; }\n     }\n     return false;"}, {"sha": "869f3e9339556e8c8ad9cd745c1326f2b24c76fd", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -138,7 +138,7 @@ fn make_tests(config: config) -> ~[test::TestDesc] {\n            config.src_base.to_str());\n     let mut tests = ~[];\n     for os::list_dir_path(&config.src_base).each |file| {\n-        let file = copy file;\n+        let file = copy *file;\n         debug!(\"inspecting file %s\", file.to_str());\n         if is_test(config, file) {\n             vec::push(tests, make_test(config, file))\n@@ -160,11 +160,11 @@ fn is_test(config: config, testfile: &Path) -> bool {\n     let mut valid = false;\n \n     for valid_extensions.each |ext| {\n-        if str::ends_with(name, ext) { valid = true; }\n+        if str::ends_with(name, *ext) { valid = true; }\n     }\n \n     for invalid_prefixes.each |pre| {\n-        if str::starts_with(name, pre) { valid = false; }\n+        if str::starts_with(name, *pre) { valid = false; }\n     }\n \n     return valid;"}, {"sha": "a6437598acf64ed1a4c11c1ef269e812b7f72fff", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -219,7 +219,7 @@ fn check_error_patterns(props: test_props,\n     let mut next_err_pat = props.error_patterns[next_err_idx];\n     let mut done = false;\n     for str::split_char(procres.stderr, '\\n').each |line| {\n-        if str::contains(line, next_err_pat) {\n+        if str::contains(*line, next_err_pat) {\n             debug!(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == vec::len(props.error_patterns) {\n@@ -240,7 +240,7 @@ fn check_error_patterns(props: test_props,\n                            missing_patterns[0]), procres);\n     } else {\n         for missing_patterns.each |pattern| {\n-            error(fmt!(\"error pattern '%s' not found!\", pattern));\n+            error(fmt!(\"error pattern '%s' not found!\", *pattern));\n         }\n         fatal_procres(~\"multiple error patterns not found\", procres);\n     }\n@@ -273,10 +273,10 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n         for vec::eachi(expected_errors) |i, ee| {\n             if !found_flags[i] {\n                 debug!(\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n-                       prefixes[i], ee.kind, ee.msg, line);\n-                if (str::starts_with(line, prefixes[i]) &&\n-                    str::contains(line, ee.kind) &&\n-                    str::contains(line, ee.msg)) {\n+                       prefixes[i], ee.kind, ee.msg, *line);\n+                if (str::starts_with(*line, prefixes[i]) &&\n+                    str::contains(*line, ee.kind) &&\n+                    str::contains(*line, ee.msg)) {\n                     found_flags[i] = true;\n                     was_expected = true;\n                     break;\n@@ -285,13 +285,13 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n         }\n \n         // ignore this msg which gets printed at the end\n-        if str::contains(line, ~\"aborting due to\") {\n+        if str::contains(*line, ~\"aborting due to\") {\n             was_expected = true;\n         }\n \n-        if !was_expected && is_compiler_error_or_warning(line) {\n+        if !was_expected && is_compiler_error_or_warning(*line) {\n             fatal_procres(fmt!(\"unexpected compiler error or warning: '%s'\",\n-                               line),\n+                               *line),\n                           procres);\n         }\n     }"}, {"sha": "700acb5434d367588176bb2fcc5b3564db02d25b", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -33,7 +33,7 @@ fn find_rust_files(files: &mut ~[Path], path: &Path) {\n         && !contains(path.to_str(), ~\"compile-fail\")\n         && !contains(path.to_str(), ~\"build\") {\n         for os::list_dir_path(path).each |p| {\n-            find_rust_files(files, p);\n+            find_rust_files(files, *p);\n         }\n     }\n }\n@@ -463,15 +463,15 @@ fn content_is_dangerous_to_run(code: ~str) -> bool {\n          ~\"unsafe\",\n          ~\"log\"];    // python --> rust pipe deadlock?\n \n-    for dangerous_patterns.each |p| { if contains(code, p) { return true; } }\n+    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n     return false;\n }\n \n fn content_is_dangerous_to_compile(code: ~str) -> bool {\n     let dangerous_patterns =\n         ~[~\"xfail-test\"];\n \n-    for dangerous_patterns.each |p| { if contains(code, p) { return true; } }\n+    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n     return false;\n }\n \n@@ -487,7 +487,7 @@ fn content_might_not_converge(code: ~str) -> bool {\n          ~\"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n         ];\n \n-    for confusing_patterns.each |p| { if contains(code, p) { return true; } }\n+    for confusing_patterns.each |p| { if contains(code, *p) { return true; } }\n     return false;\n }\n \n@@ -502,7 +502,7 @@ fn file_might_not_converge(filename: &Path) -> bool {\n \n \n     for confusing_files.each |f| {\n-        if contains(filename.to_str(), f) {\n+        if contains(filename.to_str(), *f) {\n             return true;\n         }\n     }\n@@ -540,8 +540,8 @@ fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n fn check_convergence(files: &[Path]) {\n     error!(\"pp convergence tests: %u files\", vec::len(files));\n     for files.each |file| {\n-        if !file_might_not_converge(&file) {\n-            let s = @result::get(io::read_whole_file_str(&file));\n+        if !file_might_not_converge(file) {\n+            let s = @result::get(io::read_whole_file_str(file));\n             if !content_might_not_converge(*s) {\n                 error!(\"pp converge: %s\", file.to_str());\n                 // Change from 7u to 2u once\n@@ -555,13 +555,13 @@ fn check_convergence(files: &[Path]) {\n fn check_variants(files: &[Path], cx: context) {\n     for files.each |file| {\n         if cx.mode == tm_converge &&\n-            file_might_not_converge(&file) {\n+            file_might_not_converge(file) {\n             error!(\"Skipping convergence test based on\\\n                     file_might_not_converge\");\n             loop;\n         }\n \n-        let s = @result::get(io::read_whole_file_str(&file));\n+        let s = @result::get(io::read_whole_file_str(file));\n         if contains(*s, ~\"#\") {\n             loop; // Macros are confusing\n         }\n@@ -572,11 +572,13 @@ fn check_variants(files: &[Path], cx: context) {\n             loop;\n         }\n \n-        log(error, ~\"check_variants: \" + file.to_str());\n+        let file_str = file.to_str();\n+\n+        log(error, ~\"check_variants: \" + file_str);\n         let sess = parse::new_parse_sess(option::None);\n         let crate =\n             parse::parse_crate_from_source_str(\n-                file.to_str(),\n+                file_str,\n                 s, ~[], sess);\n         io::with_str_reader(*s, |rdr| {\n             error!(\"%s\",\n@@ -586,12 +588,12 @@ fn check_variants(files: &[Path], cx: context) {\n                        syntax::parse::token::mk_fake_ident_interner(),\n                        sess.span_diagnostic,\n                        crate,\n-                       file.to_str(),\n+                       file_str,\n                        rdr, a,\n                        pprust::no_ann(),\n-                       false) ))\n+                       false)))\n         });\n-        check_variants_of_ast(*crate, sess.cm, &file, cx);\n+        check_variants_of_ast(*crate, sess.cm, file, cx);\n     }\n }\n "}, {"sha": "7f4a42db64119f8196a6f9d7ab4c561c9fb3d98d", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -678,7 +678,7 @@ mod tests {\n         let mut x = 0;\n         for l.each |i| {\n             x += 1;\n-            if (i == 3) { break; }\n+            if (*i == 3) { break; }\n         }\n         assert x == 3;\n     }"}, {"sha": "8f196b9e0784e5571a67e4475a61e5405231617e", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -272,7 +272,7 @@ impl<A: Copy> DVec<A> {\n             }\n            };\n \n-        for ts.each |t| { vec::push(v, t) };\n+        for ts.each |t| { vec::push(v, *t) };\n            v\n         }\n     }"}, {"sha": "2bc79d20bd3919b2623db15a97e5bc1b18512112", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -7,7 +7,7 @@ use inst::{IMPL_T, EACH, SIZE_HINT};\n export extensions;\n \n impl<A> IMPL_T<A>: iter::BaseIter<A> {\n-    pure fn each(blk: fn(A) -> bool) { EACH(self, blk) }\n+    pure fn each(blk: fn(v: &A) -> bool) { EACH(self, blk) }\n     pure fn size_hint() -> Option<uint> { SIZE_HINT(self) }\n }\n "}, {"sha": "fde6cf22a5e3f12fe02912f24a2c587ad13eaff4", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -8,12 +8,12 @@ type IMPL_T<A> = dlist::DList<A>;\n  * e.g. breadth-first search with in-place enqueues), but removing the current\n  * node is forbidden.\n  */\n-pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n+pure fn EACH<A>(self: IMPL_T<A>, f: fn(v: &A) -> bool) {\n     let mut link = self.peek_n();\n     while option::is_some(link) {\n         let nobe = option::get(link);\n         assert nobe.linked;\n-        if !f(nobe.data) { break; }\n+        if !f(&nobe.data) { break; }\n         // Check (weakly) that the user didn't do a remove.\n         if self.size == 0 {\n             fail ~\"The dlist became empty during iteration??\""}, {"sha": "0f51df7b5455aa422368b45eace06992d4b33dd6", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -6,7 +6,7 @@ type IMPL_T<A> = dvec::DVec<A>;\n  *\n  * Attempts to access this dvec during iteration will fail.\n  */\n-pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n+pure fn EACH<A>(self: IMPL_T<A>, f: fn(v: &A) -> bool) {\n     unsafe {\n         do self.swap |v| {\n             v.each(f);"}, {"sha": "e1ffec0a7d771abff3839991b29e560286da98fb", "filename": "src/libcore/iter-trait/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fiter-trait%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fiter-trait%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Foption.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -1,10 +1,10 @@\n #[allow(non_camel_case_types)]\n type IMPL_T<A> = Option<A>;\n \n-pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n+pure fn EACH<A>(self: IMPL_T<A>, f: fn(v: &A) -> bool) {\n     match self {\n       None => (),\n-      Some(a) => { f(a); }\n+      Some(ref a) => { f(a); }\n     }\n }\n "}, {"sha": "aab6bc38d9378de98a858ad931288022248165ef", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -10,7 +10,7 @@ use cmp::{Eq, Ord};\n type InitOp<T> = fn(uint) -> T;\n \n trait BaseIter<A> {\n-    pure fn each(blk: fn(A) -> bool);\n+    pure fn each(blk: fn(v: &A) -> bool);\n     pure fn size_hint() -> Option<uint>;\n }\n \n@@ -69,21 +69,21 @@ trait Buildable<A> {\n pure fn eachi<A,IA:BaseIter<A>>(self: IA, blk: fn(uint, A) -> bool) {\n     let mut i = 0u;\n     for self.each |a| {\n-        if !blk(i, a) { break; }\n+        if !blk(i, *a) { break; }\n         i += 1u;\n     }\n }\n \n pure fn all<A,IA:BaseIter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n     for self.each |a| {\n-        if !blk(a) { return false; }\n+        if !blk(*a) { return false; }\n     }\n     return true;\n }\n \n pure fn any<A,IA:BaseIter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n     for self.each |a| {\n-        if blk(a) { return true; }\n+        if blk(*a) { return true; }\n     }\n     return false;\n }\n@@ -92,7 +92,7 @@ pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(self: IA,\n                                          prd: fn(A) -> bool) -> ~[A] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n-            if prd(a) { push(a); }\n+            if prd(*a) { push(*a); }\n         }\n     }\n }\n@@ -101,7 +101,7 @@ pure fn map_to_vec<A:Copy,B,IA:BaseIter<A>>(self: IA, op: fn(A) -> B)\n     -> ~[B] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n-            push(op(a));\n+            push(op(*a));\n         }\n     }\n }\n@@ -111,8 +111,8 @@ pure fn flat_map_to_vec<A:Copy,B:Copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n \n     do vec::build |push| {\n         for self.each |a| {\n-            for op(a).each |b| {\n-                push(b);\n+            for op(*a).each |b| {\n+                push(*b);\n             }\n         }\n     }\n@@ -121,7 +121,7 @@ pure fn flat_map_to_vec<A:Copy,B:Copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n pure fn foldl<A,B,IA:BaseIter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n     let mut b <- b0;\n     for self.each |a| {\n-        b = blk(b, a);\n+        b = blk(b, *a);\n     }\n     move b\n }\n@@ -132,7 +132,7 @@ pure fn to_vec<A:Copy,IA:BaseIter<A>>(self: IA) -> ~[A] {\n \n pure fn contains<A:Eq,IA:BaseIter<A>>(self: IA, x: A) -> bool {\n     for self.each |a| {\n-        if a == x { return true; }\n+        if *a == x { return true; }\n     }\n     return false;\n }\n@@ -152,7 +152,7 @@ pure fn position<A,IA:BaseIter<A>>(self: IA, f: fn(A) -> bool)\n {\n     let mut i = 0;\n     for self.each |a| {\n-        if f(a) { return Some(i); }\n+        if f(*a) { return Some(i); }\n         i += 1;\n     }\n     return None;\n@@ -205,7 +205,7 @@ pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: IA) -> A {\n pure fn find<A: Copy,IA:BaseIter<A>>(self: IA,\n                                      p: fn(A) -> bool) -> Option<A> {\n     for self.each |i| {\n-        if p(i) { return Some(i) }\n+        if p(*i) { return Some(*i) }\n     }\n     return None;\n }\n@@ -254,7 +254,7 @@ pure fn build_sized_opt<A,B: Buildable<A>>(\n fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: IT, f: fn(T) -> U) -> BU {\n     do build_sized_opt(v.size_hint()) |push| {\n         for v.each() |elem| {\n-            push(f(elem));\n+            push(f(*elem));\n         }\n     }\n }\n@@ -292,8 +292,8 @@ pure fn append<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n     let size_opt = lhs.size_hint().chain(\n         |sz1| rhs.size_hint().map(|sz2| sz1+sz2));\n     do build_sized_opt(size_opt) |push| {\n-        for lhs.each |x| { push(x); }\n-        for rhs.each |x| { push(x); }\n+        for lhs.each |x| { push(*x); }\n+        for rhs.each |x| { push(*x); }\n     }\n }\n \n@@ -303,6 +303,6 @@ pure fn append<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n pure fn copy_seq<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n     v: IT) -> BT {\n     do build_sized_opt(v.size_hint()) |push| {\n-        for v.each |x| { push(x); }\n+        for v.each |x| { push(*x); }\n     }\n }"}, {"sha": "21a6a06572a03ee45353ced8215c5c41c354580d", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -529,7 +529,7 @@ fn walk_dir(p: &Path, f: fn((&Path)) -> bool) {\n     fn walk_dir_(p: &Path, f: fn((&Path)) -> bool) -> bool {\n         let mut keepgoing = true;\n         do list_dir(p).each |q| {\n-            let path = &p.push(q);\n+            let path = &p.push(*q);\n             if !f(path) {\n                 keepgoing = false;\n                 false"}, {"sha": "88d2526f31024e7cc4f9be147e7ad76a1c696fda", "filename": "src/libcore/path.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -203,7 +203,9 @@ impl PosixPath : GenericPath {\n     pure fn push_many(cs: &[~str]) -> PosixPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n-            let mut ss = str::split_nonempty(e, |c| windows::is_sep(c as u8));\n+            let mut ss = str::split_nonempty(\n+                *e,\n+                |c| windows::is_sep(c as u8));\n             unsafe { vec::push_all_move(v, move ss); }\n         }\n         PosixPath { components: move v, ..self }\n@@ -395,7 +397,9 @@ impl WindowsPath : GenericPath {\n     pure fn push_many(cs: &[~str]) -> WindowsPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n-            let mut ss = str::split_nonempty(e, |c| windows::is_sep(c as u8));\n+            let mut ss = str::split_nonempty(\n+                *e,\n+                |c| windows::is_sep(c as u8));\n             unsafe { vec::push_all_move(v, move ss); }\n         }\n         return WindowsPath { components: move v, ..self }\n@@ -430,13 +434,13 @@ pure fn normalize(components: &[~str]) -> ~[~str] {\n     unsafe {\n         for components.each |c| {\n             unsafe {\n-                if c == ~\".\" && components.len() > 1 { loop; }\n-                if c == ~\"\" { loop; }\n-                if c == ~\"..\" && cs.len() != 0 {\n+                if *c == ~\".\" && components.len() > 1 { loop; }\n+                if *c == ~\"\" { loop; }\n+                if *c == ~\"..\" && cs.len() != 0 {\n                     vec::pop(cs);\n                     loop;\n                 }\n-                vec::push(cs, copy c);\n+                vec::push(cs, copy *c);\n             }\n         }\n     }"}, {"sha": "2fac80aa2e7c991bf824bf907c57a8457e5048ae", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -1874,9 +1874,9 @@ mod bytes {\n // required in the slice.\n \n impl<A> &[A]: iter::BaseIter<A> {\n-    pure fn each(blk: fn(A) -> bool) {\n+    pure fn each(blk: fn(v: &A) -> bool) {\n         for each(self) |e| {\n-            if (!blk(*e)) {\n+            if (!blk(e)) {\n                 return;\n             }\n         }"}, {"sha": "b66d69d442f75293ff1141362e4074fd327e5902", "filename": "src/libstd/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -61,7 +61,7 @@ fn to_writer(wr: io::Writer, j: Json) {\n                 wr.write_str(~\", \");\n             }\n             first = false;\n-            to_writer(wr, item);\n+            to_writer(wr, *item);\n         };\n         wr.write_char(']');\n       }\n@@ -122,7 +122,7 @@ fn to_writer_pretty(wr: io::Writer, j: Json, indent: uint) {\n                 wr.write_str(spaces(inner_indent));\n             }\n             first = false;\n-            to_writer_pretty(wr, item, inner_indent);\n+            to_writer_pretty(wr, *item, inner_indent);\n         };\n \n         // ]\n@@ -156,7 +156,7 @@ fn to_writer_pretty(wr: io::Writer, j: Json, indent: uint) {\n         //   k: v }\n         let mut first = true;\n         for sorted_pairs.each |kv| {\n-            let (key, value) = kv;\n+            let (key, value) = *kv;\n             if !first {\n                 wr.write_str(~\",\\n\");\n                 wr.write_str(spaces(inner_indent));"}, {"sha": "493e0cc762c8ab66c085a968a9cb6085ad8632af", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -199,7 +199,7 @@ fn encode_form_urlencoded(m: HashMap<~str, @DVec<@~str>>) -> ~str {\n                 first = false;\n             }\n \n-            out += #fmt(\"%s=%s\", key, encode_plus(*value));\n+            out += #fmt(\"%s=%s\", key, encode_plus(**value));\n         }\n     }\n \n@@ -328,7 +328,7 @@ fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n     if str::len(rawquery) != 0 {\n         for str::split_char(rawquery, '&').each |p| {\n-            let (k, v) = split_char_first(p, '=');\n+            let (k, v) = split_char_first(*p, '=');\n             vec::push(query, (decode_component(k), decode_component(v)));\n         };\n     }\n@@ -338,7 +338,7 @@ fn query_from_str(rawquery: &str) -> Query {\n fn query_to_str(+query: Query) -> ~str {\n     let mut strvec = ~[];\n     for query.each |kv| {\n-        let (k, v) = copy kv;\n+        let (k, v) = copy *kv;\n         strvec += ~[#fmt(\"%s=%s\", encode_component(k), encode_component(v))];\n     };\n     return str::connect(strvec, ~\"&\");"}, {"sha": "ffa5aeef31ee6026c1a6ee9aab05c72c3a6524d7", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -70,7 +70,7 @@ impl<V: Copy> SmallIntMap<V>: map::Map<uint, V> {\n     pure fn size() -> uint {\n         let mut sz = 0u;\n         for self.v.each |item| {\n-            match item {\n+            match *item {\n               Some(_) => sz += 1u,\n               _ => ()\n             }"}, {"sha": "eca9a1fc8a8e46f98c095967fb3d0eca09f570a8", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -179,7 +179,7 @@ mod test {\n         for iter::repeat(repeat) {\n \n             for spec.each |spec| {\n-                let (times, maxms) = spec;\n+                let (times, maxms) = *spec;\n                 do task::spawn {\n                     use rand::*;\n                     let rng = Rng();"}, {"sha": "d813c7e4b0873633c41add21c4b50ca564bdff27", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -151,7 +151,7 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     for decl.inputs.each |a| {\n         cx.map.insert(a.id,\n                       node_arg(/* FIXME (#2543) */\n-                          copy a, cx.local_id));\n+                          copy *a, cx.local_id));\n         cx.local_id += 1u;\n     }\n     match fk {\n@@ -220,14 +220,14 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n       item_impl(_, _, _, ms) => {\n         let impl_did = ast_util::local_def(i.id);\n         for ms.each |m| {\n-            map_method(impl_did, extend(cx, i.ident), m,\n+            map_method(impl_did, extend(cx, i.ident), *m,\n                        cx);\n         }\n       }\n       item_enum(enum_definition, _) => {\n         for enum_definition.variants.each |v| {\n             cx.map.insert(v.node.id, node_variant(\n-                /* FIXME (#2543) */ copy v, i,\n+                /* FIXME (#2543) */ copy *v, i,\n                 extend(cx, i.ident)));\n         }\n       }\n@@ -238,7 +238,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         };\n         for nm.items.each |nitem| {\n             cx.map.insert(nitem.id,\n-                          node_foreign_item(nitem, abi,\n+                          node_foreign_item(*nitem, abi,\n                                            /* FIXME (#2543) */\n                                             if nm.sort == ast::named {\n                                                 extend(cx, i.ident)\n@@ -264,9 +264,9 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n             cx.map.insert(p.impl_id, node_item(i, item_path));\n         }\n         for methods.each |tm| {\n-            let id = ast_util::trait_method_to_ty_method(tm).id;\n+            let id = ast_util::trait_method_to_ty_method(*tm).id;\n             let d_id = ast_util::local_def(i.id);\n-            cx.map.insert(id, node_trait_method(@tm, d_id, item_path));\n+            cx.map.insert(id, node_trait_method(@*tm, d_id, item_path));\n         }\n       }\n       _ => ()\n@@ -310,7 +310,7 @@ fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n             (id, path_to_ident(pth))\n           }\n         };\n-        cx.map.insert(id, node_export(vp, extend(cx, name)));\n+        cx.map.insert(id, node_export(*vp, extend(cx, name)));\n       },\n       _ => ()\n     }"}, {"sha": "41be872f06075f75adbd4dc4b1562d4bdc7f2a0a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -312,7 +312,7 @@ fn split_trait_methods(trait_methods: ~[trait_method])\n     -> (~[ty_method], ~[@method]) {\n     let mut reqd = ~[], provd = ~[];\n     for trait_methods.each |trt_method| {\n-        match trt_method {\n+        match *trt_method {\n           required(tm) => vec::push(reqd, tm),\n           provided(m) => vec::push(provd, m)\n         }\n@@ -575,15 +575,23 @@ pure fn is_item_impl(item: @ast::item) -> bool {\n fn walk_pat(pat: @pat, it: fn(@pat)) {\n     it(pat);\n     match pat.node {\n-      pat_ident(_, _, Some(p)) => walk_pat(p, it),\n-      pat_rec(fields, _) | pat_struct(_, fields, _) =>\n-        for fields.each |f| { walk_pat(f.pat, it) },\n-      pat_enum(_, Some(s)) | pat_tup(s) => for s.each |p| {\n-        walk_pat(p, it)\n-      },\n-      pat_box(s) | pat_uniq(s) | pat_region(s) => walk_pat(s, it),\n-      pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _)\n-        | pat_enum(_, _) => ()\n+        pat_ident(_, _, Some(p)) => walk_pat(p, it),\n+        pat_rec(fields, _) | pat_struct(_, fields, _) => {\n+            for fields.each |f| {\n+                walk_pat(f.pat, it)\n+            }\n+        }\n+        pat_enum(_, Some(s)) | pat_tup(s) => {\n+            for s.each |p| {\n+                walk_pat(*p, it)\n+            }\n+        }\n+        pat_box(s) | pat_uniq(s) | pat_region(s) => {\n+            walk_pat(s, it)\n+        }\n+        pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _) |\n+        pat_enum(_, _) => {\n+        }\n     }\n }\n "}, {"sha": "fdcd1087935e95bb61fabc6106fd8f1ad9382ed1", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -91,7 +91,7 @@ fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n // Get the meta_items from inside a vector of attributes\n fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n     let mut mitems = ~[];\n-    for attrs.each |a| { vec::push(mitems, attr_meta(a)); }\n+    for attrs.each |a| { vec::push(mitems, attr_meta(*a)); }\n     return mitems;\n }\n \n@@ -189,7 +189,7 @@ fn find_meta_items_by_name(metas: ~[@ast::meta_item], name: ~str) ->\n  */\n fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item) -> bool {\n     for haystack.each |item| {\n-        if eq(item, needle) { return true; }\n+        if eq(*item, needle) { return true; }\n     }\n     return false;\n }\n@@ -370,7 +370,7 @@ fn require_unique_names(diagnostic: span_handler,\n                         metas: ~[@ast::meta_item]) {\n     let map = map::HashMap();\n     for metas.each |meta| {\n-        let name = get_meta_item_name(meta);\n+        let name = get_meta_item_name(*meta);\n \n         // FIXME: How do I silence the warnings? --pcw (#2619)\n         if map.contains_key(name) {"}, {"sha": "ab34ed8368c249f8106ef802675214ee8fa296c6", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -242,7 +242,7 @@ fn get_snippet(cm: codemap::codemap, fidx: uint, lo: uint, hi: uint) -> ~str\n }\n \n fn get_filemap(cm: codemap, filename: ~str) -> filemap {\n-    for cm.files.each |fm| { if fm.name == filename { return fm; } }\n+    for cm.files.each |fm| { if fm.name == filename { return *fm; } }\n     //XXjdm the following triggers a mismatched type bug\n     //      (or expected function, found _|_)\n     fail; // (\"asking for \" + filename + \" which we don't know about\");"}, {"sha": "217b8c9cf4b17cecbad4ae0e966feec4ac60d25a", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -219,8 +219,8 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     }\n     // Print the offending lines\n     for display_lines.each |line| {\n-        io::stderr().write_str(fmt!(\"%s:%u \", fm.name, line + 1u));\n-        let s = codemap::get_line(fm, line as int) + ~\"\\n\";\n+        io::stderr().write_str(fmt!(\"%s:%u \", fm.name, *line + 1u));\n+        let s = codemap::get_line(fm, *line as int) + ~\"\\n\";\n         io::stderr().write_str(s);\n     }\n     if elided {"}, {"sha": "94b22d68ceabcaa78e157e8705c5c6adb409fdf6", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -6,7 +6,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     let mut res_str = ~\"\";\n     for args.each |e| {\n         res_str += *cx.parse_sess().interner.get(\n-            expr_to_ident(cx, e, ~\"expected an ident\"));\n+            expr_to_ident(cx, *e, ~\"expected an ident\"));\n     }\n     let res = cx.parse_sess().interner.intern(@res_str);\n "}, {"sha": "3ea0493239f0b642539e83ae21c7a34d5850aa8d", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -53,7 +53,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         fn make_flags(cx: ext_ctxt, sp: span, flags: ~[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, @~\"flag_none\");\n             for flags.each |f| {\n-                let fstr = match f {\n+                let fstr = match *f {\n                   FlagLeftJustify => ~\"flag_left_justify\",\n                   FlagLeftZeroPad => ~\"flag_left_zero_pad\",\n                   FlagSpaceForSign => ~\"flag_space_for_sign\",\n@@ -139,7 +139,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n           _ => cx.span_unimpl(sp, unsupported)\n         }\n         for cnv.flags.each |f| {\n-            match f {\n+            match *f {\n               FlagLeftJustify => (),\n               FlagSignAlways => {\n                 if !is_signed_type(cnv) {\n@@ -196,7 +196,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n           _ => debug!(\"param: none\")\n         }\n         for c.flags.each |f| {\n-            match f {\n+            match *f {\n               FlagLeftJustify => debug!(\"flag: left justify\"),\n               FlagLeftZeroPad => debug!(\"flag: left zero pad\"),\n               FlagSpaceForSign => debug!(\"flag: left space pad\"),\n@@ -243,7 +243,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     let mut piece_exprs = ~[];\n     let nargs = args.len();\n     for pieces.each |pc| {\n-        match pc {\n+        match *pc {\n           PieceString(s) => {\n             vec::push(piece_exprs, mk_uniq_str(cx, fmt_sp, s))\n           }"}, {"sha": "e2b08d089a7b79155841d98cfc5225713baed891", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -202,7 +202,7 @@ impl state: to_type_decls {\n         let mut items_msg = ~[];\n \n         for self.messages.each |m| {\n-            let message(name, span, tys, this, next) = m;\n+            let message(name, span, tys, this, next) = *m;\n \n             let tys = match next {\n               Some({state: next, tys: next_tys}) => {\n@@ -366,7 +366,7 @@ impl protocol: gen_init {\n         for (copy self.states).each |s| {\n             for s.ty_params.each |tp| {\n                 match params.find(|tpp| tp.ident == tpp.ident) {\n-                  None => vec::push(params, tp),\n+                  None => vec::push(params, *tp),\n                   _ => ()\n                 }\n             }\n@@ -382,7 +382,7 @@ impl protocol: gen_init {\n         let fields = do (copy self.states).map_to_vec |s| {\n             for s.ty_params.each |tp| {\n                 match params.find(|tpp| tp.ident == tpp.ident) {\n-                  None => vec::push(params, tp),\n+                  None => vec::push(params, *tp),\n                   _ => ()\n                 }\n             }"}, {"sha": "fec8339cf1a63b1f3e12d28f6e05043974443f45", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -102,7 +102,7 @@ impl state {\n     /// from this state.\n     fn reachable(f: fn(state) -> bool) {\n         for self.messages.each |m| {\n-            match m {\n+            match *m {\n               message(_, _, _, _, Some({state: id, _})) => {\n                 let state = self.proto.get_state(id);\n                 if !f(state) { break }"}, {"sha": "c9385b0c35cfdca6037480458302c8ddb7f3a4fe", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -92,7 +92,7 @@ fn option_flatten_map<T: Copy, U: Copy>(f: fn@(T) -> Option<U>, v: ~[T]) ->\n    Option<~[U]> {\n     let mut res = ~[];\n     for v.each |elem| {\n-        match f(elem) {\n+        match f(*elem) {\n           None => return None,\n           Some(fv) => vec::push(res, fv)\n         }\n@@ -156,7 +156,7 @@ fn use_selectors_to_bind(b: binders, e: @expr) -> Option<bindings> {\n     let res = HashMap();\n     //need to do this first, to check vec lengths.\n     for b.literal_ast_matchers.each |sel| {\n-        match sel(match_expr(e)) { None => return None, _ => () }\n+        match (*sel)(match_expr(e)) { None => return None, _ => () }\n     }\n     let mut never_mind: bool = false;\n     for b.real_binders.each |key, val| {"}, {"sha": "74c36dcf1b7f548798aadff6c8ad5fc526e96dda", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -174,7 +174,7 @@ fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n         match m {\n           {node: match_tok(_), span: _} => (),\n           {node: match_seq(more_ms, _, _, _, _), span: _} => {\n-            for more_ms.each() |next_m| { n_rec(p_s, next_m, res, ret_val) };\n+            for more_ms.each() |next_m| { n_rec(p_s, *next_m, res, ret_val) };\n           }\n           {node: match_nonterminal(bind_name, _, idx), span: sp} => {\n             if ret_val.contains_key(bind_name) {\n@@ -186,7 +186,7 @@ fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n         }\n     }\n     let ret_val = HashMap::<uint,@named_match>();\n-    for ms.each() |m| { n_rec(p_s, m, res, ret_val) }\n+    for ms.each() |m| { n_rec(p_s, *m, res, ret_val) }\n     return ret_val;\n }\n "}, {"sha": "c5e64654d7be6a71d0fd07257f97e02f40d37402", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -13,7 +13,7 @@ fn eval_crate_directives(cx: ctx,\n                          &view_items: ~[@ast::view_item],\n                          &items: ~[@ast::item]) {\n     for cdirs.each |sub_cdir| {\n-        eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n+        eval_crate_directive(cx, *sub_cdir, prefix, view_items, items);\n     }\n }\n "}, {"sha": "a1c1208d21c5fc37dc0657e68e65d50f50c68b50", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -2244,7 +2244,7 @@ impl parser {\n                                             IMPORTS_AND_ITEMS_ALLOWED);\n \n         for items.each |item| {\n-            let decl = @spanned(item.span.lo, item.span.hi, decl_item(item));\n+            let decl = @spanned(item.span.lo, item.span.hi, decl_item(*item));\n             push(stmts, @spanned(item.span.lo, item.span.hi,\n                                  stmt_decl(decl, self.get_id())));\n         }\n@@ -2699,7 +2699,7 @@ impl parser {\n                   }\n                   members(mms) => {\n                     for mms.each |mm| {\n-                        match mm {\n+                        match *mm {\n                             @field_member(struct_field) =>\n                                 vec::push(fields, struct_field),\n                             @method_member(the_method_member) =>\n@@ -3090,7 +3090,7 @@ impl parser {\n                 }\n                 members(mms) => {\n                     for mms.each |mm| {\n-                        match mm {\n+                        match *mm {\n                             @field_member(struct_field) =>\n                                 vec::push(fields, struct_field),\n                             @method_member(the_method_member) =>\n@@ -3163,7 +3163,7 @@ impl parser {\n                         seq_sep_trailing_disallowed(token::COMMA),\n                         |p| p.parse_ty(false));\n                     for arg_tys.each |ty| {\n-                        vec::push(args, {ty: ty, id: self.get_id()});\n+                        vec::push(args, {ty: *ty, id: self.get_id()});\n                     }\n                     kind = tuple_variant_kind(args);\n                 } else if self.eat(token::EQ) {"}, {"sha": "570915e657fb167d744c8e7427f138c59553ca29", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -389,7 +389,7 @@ fn temporary_keyword_table() -> HashMap<~str, ()> {\n         ~\"self\", ~\"static\",\n     ];\n     for keys.each |word| {\n-        words.insert(word, ());\n+        words.insert(*word, ());\n     }\n     words\n }\n@@ -415,7 +415,7 @@ fn strict_keyword_table() -> HashMap<~str, ()> {\n         ~\"while\"\n     ];\n     for keys.each |word| {\n-        words.insert(word, ());\n+        words.insert(*word, ());\n     }\n     words\n }\n@@ -426,7 +426,7 @@ fn reserved_keyword_table() -> HashMap<~str, ()> {\n         ~\"be\"\n     ];\n     for keys.each |word| {\n-        words.insert(word, ());\n+        words.insert(*word, ());\n     }\n     words\n }"}, {"sha": "f41cdae7e035593deb781328a753ca93a402e7d9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -281,7 +281,7 @@ fn commasep<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN)) {\n     let mut first = true;\n     for elts.each |elt| {\n         if first { first = false; } else { word_space(s, ~\",\"); }\n-        op(s, elt);\n+        op(s, *elt);\n     }\n     end(s);\n }\n@@ -293,12 +293,12 @@ fn commasep_cmnt<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN),\n     let len = vec::len::<IN>(elts);\n     let mut i = 0u;\n     for elts.each |elt| {\n-        maybe_print_comment(s, get_span(elt).hi);\n-        op(s, elt);\n+        maybe_print_comment(s, get_span(*elt).hi);\n+        op(s, *elt);\n         i += 1u;\n         if i < len {\n             word(s.s, ~\",\");\n-            maybe_print_trailing_comment(s, get_span(elt),\n+            maybe_print_trailing_comment(s, get_span(*elt),\n                                          Some(get_span(elts[i]).hi));\n             space_if_not_bol(s);\n         }\n@@ -314,18 +314,18 @@ fn commasep_exprs(s: ps, b: breaks, exprs: ~[@ast::expr]) {\n fn print_mod(s: ps, _mod: ast::_mod, attrs: ~[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for _mod.view_items.each |vitem| {\n-        print_view_item(s, vitem);\n+        print_view_item(s, *vitem);\n     }\n-    for _mod.items.each |item| { print_item(s, item); }\n+    for _mod.items.each |item| { print_item(s, *item); }\n }\n \n fn print_foreign_mod(s: ps, nmod: ast::foreign_mod,\n                      attrs: ~[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for nmod.view_items.each |vitem| {\n-        print_view_item(s, vitem);\n+        print_view_item(s, *vitem);\n     }\n-    for nmod.items.each |item| { print_foreign_item(s, item); }\n+    for nmod.items.each |item| { print_foreign_item(s, *item); }\n }\n \n fn print_region(s: ps, region: @ast::region, sep: ~str) {\n@@ -525,7 +525,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n \n         bopen(s);\n         for methods.each |meth| {\n-           print_method(s, meth);\n+           print_method(s, *meth);\n         }\n         bclose(s, item.span);\n       }\n@@ -540,7 +540,9 @@ fn print_item(s: ps, &&item: @ast::item) {\n         }\n         word(s.s, ~\" \");\n         bopen(s);\n-        for methods.each |meth| { print_trait_method(s, meth); }\n+        for methods.each |meth| {\n+            print_trait_method(s, *meth);\n+        }\n         bclose(s, item.span);\n       }\n       ast::item_mac({node: ast::mac_invoc_tt(pth, tts), _}) => {\n@@ -549,7 +551,9 @@ fn print_item(s: ps, &&item: @ast::item) {\n         print_ident(s, item.ident);\n         cbox(s, indent_unit);\n         popen(s);\n-        for tts.each |tt| { print_tt(s, tt);  }\n+        for tts.each |tt| {\n+            print_tt(s, *tt);\n+        }\n         pclose(s);\n         end(s);\n       }\n@@ -602,7 +606,7 @@ fn print_variants(s: ps, variants: ~[ast::variant], span: ast::span) {\n         maybe_print_comment(s, v.span.lo);\n         print_outer_attributes(s, v.node.attrs);\n         ibox(s, indent_unit);\n-        print_variant(s, v);\n+        print_variant(s, *v);\n         word(s.s, ~\",\");\n         end(s);\n         maybe_print_trailing_comment(s, v.span, None::<uint>);\n@@ -661,7 +665,7 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n         }\n     }\n     for struct_def.methods.each |method| {\n-        print_method(s, method);\n+        print_method(s, *method);\n     }\n     bclose(s, span);\n }\n@@ -675,7 +679,7 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n /// expression arguments as expressions). It can be done! I think.\n fn print_tt(s: ps, tt: ast::token_tree) {\n     match tt {\n-      ast::tt_delim(tts) => for tts.each() |tt_elt| { print_tt(s, tt_elt); },\n+      ast::tt_delim(tts) => for tts.each() |tt_elt| { print_tt(s, *tt_elt); },\n       ast::tt_tok(_, tk) => {\n         match tk {\n           parse::token::IDENT(*) => { // don't let idents run together\n@@ -688,7 +692,7 @@ fn print_tt(s: ps, tt: ast::token_tree) {\n       }\n       ast::tt_seq(_, tts, sep, zerok) => {\n         word(s.s, ~\"$(\");\n-        for tts.each() |tt_elt| { print_tt(s, tt_elt); }\n+        for tts.each() |tt_elt| { print_tt(s, *tt_elt); }\n         word(s.s, ~\")\");\n         match sep {\n           Some(tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n@@ -767,7 +771,7 @@ fn print_outer_attributes(s: ps, attrs: ~[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n         match attr.node.style {\n-          ast::attr_outer => { print_attribute(s, attr); count += 1; }\n+          ast::attr_outer => { print_attribute(s, *attr); count += 1; }\n           _ => {/* fallthrough */ }\n         }\n     }\n@@ -779,7 +783,7 @@ fn print_inner_attributes(s: ps, attrs: ~[ast::attribute]) {\n     for attrs.each |attr| {\n         match attr.node.style {\n           ast::attr_inner => {\n-            print_attribute(s, attr);\n+            print_attribute(s, *attr);\n             if !attr.node.is_sugared_doc {\n                 word(s.s, ~\";\");\n             }\n@@ -870,9 +874,9 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n \n     print_inner_attributes(s, attrs);\n \n-    for blk.node.view_items.each |vi| { print_view_item(s, vi); }\n+    for blk.node.view_items.each |vi| { print_view_item(s, *vi); }\n     for blk.node.stmts.each |st| {\n-        print_stmt(s, *st);\n+        print_stmt(s, **st);\n     }\n     match blk.node.expr {\n       Some(expr) => {\n@@ -956,7 +960,7 @@ fn print_mac(s: ps, m: ast::mac) {\n         print_path(s, pth, false);\n         word(s.s, ~\"!\");\n         popen(s);\n-        for tts.each() |tt| { print_tt(s, tt); }\n+        for tts.each() |tt| { print_tt(s, *tt); }\n         pclose(s);\n       }\n       ast::mac_ellipsis => word(s.s, ~\"...\"),\n@@ -1167,7 +1171,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n                 if first {\n                     first = false;\n                 } else { space(s.s); word_space(s, ~\"|\"); }\n-                print_pat(s, p);\n+                print_pat(s, *p);\n             }\n             space(s.s);\n             match arm.guard {\n@@ -1445,7 +1449,7 @@ fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n     let mut first = true;\n     for path.idents.each |id| {\n         if first { first = false; } else { word(s.s, ~\"::\"); }\n-        print_ident(s, id);\n+        print_ident(s, *id);\n     }\n     if path.rp.is_some() || !path.types.is_empty() {\n         if colons_before_params { word(s.s, ~\"::\"); }\n@@ -1599,12 +1603,12 @@ fn print_fn_args(s: ps, decl: ast::fn_decl,\n     box(s, 0u, inconsistent);\n     let mut first = true;\n     for opt_self_ty.each |self_ty| {\n-        first = !print_self_ty(s, self_ty);\n+        first = !print_self_ty(s, *self_ty);\n     }\n \n     for decl.inputs.each |arg| {\n         if first { first = false; } else { word_space(s, ~\",\"); }\n-        print_arg(s, arg);\n+        print_arg(s, *arg);\n     }\n \n     for cap_items.each |cap_item| {\n@@ -1836,11 +1840,11 @@ fn print_ty_fn(s: ps, opt_proto: Option<ast::proto>, purity: ast::purity,\n     box(s, 0u, inconsistent);\n     let mut first = true;\n     for opt_self_ty.each |self_ty| {\n-        first = !print_self_ty(s, self_ty);\n+        first = !print_self_ty(s, *self_ty);\n     }\n     for decl.inputs.each |arg| {\n         if first { first = false; } else { word_space(s, ~\",\"); }\n-        print_arg(s, arg);\n+        print_arg(s, *arg);\n     }\n     end(s);\n     pclose(s);\n@@ -1988,7 +1992,7 @@ fn print_comment(s: ps, cmnt: comments::cmnt) {\n         for cmnt.lines.each |line| {\n             // Don't print empty lines because they will end up as trailing\n             // whitespace\n-            if str::is_not_empty(line) { word(s.s, line); }\n+            if str::is_not_empty(*line) { word(s.s, *line); }\n             hardbreak(s.s);\n         }\n       }\n@@ -2000,7 +2004,7 @@ fn print_comment(s: ps, cmnt: comments::cmnt) {\n         } else {\n             ibox(s, 0u);\n             for cmnt.lines.each |line| {\n-                if str::is_not_empty(line) { word(s.s, line); }\n+                if str::is_not_empty(*line) { word(s.s, *line); }\n                 hardbreak(s.s);\n             }\n             end(s);"}, {"sha": "15b9e34566fbe3a9217aa87658aaaac55528080b", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -21,7 +21,7 @@ fn mk<T:Eq IterBytes Hash Const Copy>() -> interner<T> {\n \n fn mk_prefill<T:Eq IterBytes Hash Const Copy>(init: ~[T]) -> interner<T> {\n     let rv = mk();\n-    for init.each() |v| { rv.intern(v); }\n+    for init.each() |v| { rv.intern(*v); }\n     return rv;\n }\n "}, {"sha": "4392ed55219efad311dfed1a9c267931b43ee7d9", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -98,16 +98,16 @@ fn visit_crate_directive<E>(cd: @crate_directive, e: E, v: vt<E>) {\n     match cd.node {\n       cdir_src_mod(_, _) => (),\n       cdir_dir_mod(_, cdirs, _) => for cdirs.each |cdir| {\n-        visit_crate_directive(cdir, e, v);\n+        visit_crate_directive(*cdir, e, v);\n       },\n       cdir_view_item(vi) => v.visit_view_item(vi, e, v),\n       cdir_syntax(_) => ()\n     }\n }\n \n fn visit_mod<E>(m: _mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n-    for m.view_items.each |vi| { v.visit_view_item(vi, e, v); }\n-    for m.items.each |i| { v.visit_item(i, e, v); }\n+    for m.view_items.each |vi| { v.visit_view_item(*vi, e, v); }\n+    for m.items.each |i| { v.visit_item(*i, e, v); }\n }\n \n fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n@@ -132,8 +132,8 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       }\n       item_mod(m) => v.visit_mod(m, i.span, i.id, e, v),\n       item_foreign_mod(nm) => {\n-        for nm.view_items.each |vi| { v.visit_view_item(vi, e, v); }\n-        for nm.items.each |ni| { v.visit_foreign_item(ni, e, v); }\n+        for nm.view_items.each |vi| { v.visit_view_item(*vi, e, v); }\n+        for nm.items.each |ni| { v.visit_foreign_item(*ni, e, v); }\n       }\n       item_ty(t, tps) => {\n         v.visit_ty(t, e, v);\n@@ -150,7 +150,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         }\n         v.visit_ty(ty, e, v);\n         for methods.each |m| {\n-            visit_method_helper(m, e, v)\n+            visit_method_helper(*m, e, v)\n         }\n       }\n       item_class(struct_def, tps) => {\n@@ -161,7 +161,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         v.visit_ty_params(tps, e, v);\n         for traits.each |p| { visit_path(p.path, e, v); }\n         for methods.each |m| {\n-            v.visit_trait_method(m, e, v);\n+            v.visit_trait_method(*m, e, v);\n         }\n       }\n       item_mac(m) => visit_mac(m, e, v)\n@@ -198,7 +198,7 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n         v.visit_ty(f.node.mt.ty, e, v);\n       },\n       ty_tup(ts) => for ts.each |tt| {\n-        v.visit_ty(tt, e, v);\n+        v.visit_ty(*tt, e, v);\n       },\n       ty_fn(_, _, bounds, decl) => {\n         for decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n@@ -215,15 +215,15 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n }\n \n fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n-    for p.types.each |tp| { v.visit_ty(tp, e, v); }\n+    for p.types.each |tp| { v.visit_ty(*tp, e, v); }\n }\n \n fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     match p.node {\n       pat_enum(path, children) => {\n         visit_path(path, e, v);\n         do option::iter(children) |children| {\n-            for children.each |child| { v.visit_pat(child, e, v); }}\n+            for children.each |child| { v.visit_pat(*child, e, v); }}\n       }\n       pat_rec(fields, _) => for fields.each |f| {\n         v.visit_pat(f.pat, e, v)\n@@ -235,7 +235,7 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n         }\n       }\n       pat_tup(elts) => for elts.each |elt| {\n-        v.visit_pat(elt, e, v)\n+        v.visit_pat(*elt, e, v)\n       },\n       pat_box(inner) | pat_uniq(inner) | pat_region(inner) =>\n           v.visit_pat(inner, e, v),\n@@ -333,12 +333,14 @@ fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n fn visit_struct_def<E>(sd: @struct_def, nm: ast::ident, tps: ~[ty_param],\n                        id: node_id, e: E, v: vt<E>) {\n     for sd.fields.each |f| {\n-        v.visit_struct_field(f, e, v);\n+        v.visit_struct_field(*f, e, v);\n     }\n     for sd.methods.each |m| {\n-        v.visit_struct_method(m, e, v);\n+        v.visit_struct_method(*m, e, v);\n+    }\n+    for sd.traits.each |p| {\n+        visit_path(p.path, e, v);\n     }\n-    for sd.traits.each |p| { visit_path(p.path, e, v); }\n     do option::iter(sd.ctor) |ctor| {\n       visit_class_ctor_helper(ctor, nm, tps, ast_util::local_def(id), e, v);\n     };\n@@ -356,8 +358,12 @@ fn visit_struct_method<E>(m: @method, e: E, v: vt<E>) {\n }\n \n fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n-    for b.node.view_items.each |vi| { v.visit_view_item(vi, e, v); }\n-    for b.node.stmts.each |s| { v.visit_stmt(s, e, v); }\n+    for b.node.view_items.each |vi| {\n+        v.visit_view_item(*vi, e, v);\n+    }\n+    for b.node.stmts.each |s| {\n+        v.visit_stmt(*s, e, v);\n+    }\n     visit_expr_opt(b.node.expr, e, v);\n }\n \n@@ -372,7 +378,7 @@ fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n     match d.node {\n       decl_local(locs) => for locs.each |loc| {\n-        v.visit_local(loc, e, v)\n+        v.visit_local(*loc, e, v)\n       },\n       decl_item(it) => v.visit_item(it, e, v)\n     }\n@@ -383,7 +389,7 @@ fn visit_expr_opt<E>(eo: Option<@expr>, e: E, v: vt<E>) {\n }\n \n fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n-    for exprs.each |ex| { v.visit_expr(ex, e, v); }\n+    for exprs.each |ex| { v.visit_expr(*ex, e, v); }\n }\n \n fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n@@ -414,7 +420,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         for flds.each |f| { v.visit_expr(f.node.expr, e, v); }\n         visit_expr_opt(base, e, v);\n       }\n-      expr_tup(elts) => for elts.each |el| { v.visit_expr(el, e, v); },\n+      expr_tup(elts) => for elts.each |el| { v.visit_expr(*el, e, v); },\n       expr_call(callee, args, _) => {\n         visit_exprs(args, e, v);\n         v.visit_expr(callee, e, v);\n@@ -436,7 +442,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       expr_loop(b, _) => v.visit_block(b, e, v),\n       expr_match(x, arms) => {\n         v.visit_expr(x, e, v);\n-        for arms.each |a| { v.visit_arm(a, e, v); }\n+        for arms.each |a| { v.visit_arm(*a, e, v); }\n       }\n       expr_fn(proto, decl, body, cap_clause) => {\n         v.visit_fn(fk_anon(proto, cap_clause), decl, body,\n@@ -458,7 +464,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       }\n       expr_field(x, _, tys) => {\n         v.visit_expr(x, e, v);\n-        for tys.each |tp| { v.visit_ty(tp, e, v); }\n+        for tys.each |tp| { v.visit_ty(*tp, e, v); }\n       }\n       expr_index(a, b) => { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_path(p) => visit_path(p, e, v),\n@@ -476,7 +482,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n }\n \n fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n-    for a.pats.each |p| { v.visit_pat(p, e, v); }\n+    for a.pats.each |p| { v.visit_pat(*p, e, v); }\n     visit_expr_opt(a.guard, e, v);\n     v.visit_block(a.body, e, v);\n }"}, {"sha": "374e56b94fd5a40de38fced4efa29cdd6a973e2f", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -400,17 +400,17 @@ fn build_link_meta(sess: session, c: ast::crate, output: &Path,\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each |meta| {\n-            if attr::get_meta_item_name(meta) == ~\"name\" {\n-                match attr::get_meta_item_value_str(meta) {\n+            if attr::get_meta_item_name(*meta) == ~\"name\" {\n+                match attr::get_meta_item_value_str(*meta) {\n                   Some(v) => { name = Some(v); }\n-                  None => vec::push(cmh_items, meta)\n+                  None => vec::push(cmh_items, *meta)\n                 }\n-            } else if attr::get_meta_item_name(meta) == ~\"vers\" {\n-                match attr::get_meta_item_value_str(meta) {\n+            } else if attr::get_meta_item_name(*meta) == ~\"vers\" {\n+                match attr::get_meta_item_value_str(*meta) {\n                   Some(v) => { vers = Some(v); }\n-                  None => vec::push(cmh_items, meta)\n+                  None => vec::push(cmh_items, *meta)\n                 }\n-            } else { vec::push(cmh_items, meta); }\n+            } else { vec::push(cmh_items, *meta); }\n         }\n         return {name: name, vers: vers, cmh_items: cmh_items};\n     }\n@@ -431,8 +431,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: &Path,\n         let cmh_items = attr::sort_meta_items(metas.cmh_items);\n \n         symbol_hasher.reset();\n-        for cmh_items.each |m_| {\n-            let m = m_;\n+        for cmh_items.each |m| {\n             match m.node {\n               ast::meta_name_value(key, value) => {\n                 symbol_hasher.write_str(len_and_str(key));\n@@ -449,7 +448,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: &Path,\n         }\n \n         for dep_hashes.each |dh| {\n-            symbol_hasher.write_str(len_and_str(dh));\n+            symbol_hasher.write_str(len_and_str(*dh));\n         }\n \n         return truncated_hash_result(symbol_hasher);\n@@ -576,7 +575,7 @@ fn mangle(sess: session, ss: path) -> ~str {\n     let mut n = ~\"_ZN\"; // Begin name-sequence.\n \n     for ss.each |s| {\n-        match s { path_name(s) | path_mod(s) => {\n+        match *s { path_name(s) | path_mod(s) => {\n           let sani = sanitize(sess.str_of(s));\n           n += fmt!(\"%u%s\", str::len(sani), sani);\n         } }\n@@ -696,7 +695,7 @@ fn link_binary(sess: session,\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.each |arg| { vec::push(cc_args, arg); }\n+    for ula.each |arg| { vec::push(cc_args, *arg); }\n \n     // # Extern library linking\n \n@@ -711,7 +710,7 @@ fn link_binary(sess: session,\n \n     // The names of the extern libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n-    for used_libs.each |l| { vec::push(cc_args, ~\"-l\" + l); }\n+    for used_libs.each |l| { vec::push(cc_args, ~\"-l\" + *l); }\n \n     if sess.building_library {\n         vec::push(cc_args, lib_cmd);"}, {"sha": "5af2987cb69982840b29eb3807ec191314ebc03a", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -172,7 +172,7 @@ fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n     for rpaths.each |rpath| {\n         let s = rpath.to_str();\n         if !set.contains_key(s) {\n-            vec::push(minimized, rpath);\n+            vec::push(minimized, *rpath);\n             set.insert(s, ());\n         }\n     }"}, {"sha": "f289a0bdf273827b16a0758a93456be5258df13a", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -28,7 +28,7 @@ fn declare_upcalls(targ_cfg: @session::config,\n             tys: ~[TypeRef], rv: TypeRef) ->\n        ValueRef {\n         let mut arg_tys: ~[TypeRef] = ~[];\n-        for tys.each |t| { vec::push(arg_tys, t); }\n+        for tys.each |t| { vec::push(arg_tys, *t); }\n         let fn_ty = T_fn(arg_tys, rv);\n         return base::decl_cdecl_fn(llmod, prefix + name, fn_ty);\n     }"}, {"sha": "7ccad3b717d854899d754eff4fbf88df0d2d4677", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -93,7 +93,9 @@ fn parse_cfgspecs(cfgspecs: ~[~str]) -> ast::crate_cfg {\n     // varieties of meta_item here. At the moment we just support the\n     // meta_word variant.\n     let mut words = ~[];\n-    for cfgspecs.each |s| { vec::push(words, attr::mk_word_item(s)); }\n+    for cfgspecs.each |s| {\n+        vec::push(words, attr::mk_word_item(*s));\n+    }\n     return words;\n }\n \n@@ -453,19 +455,19 @@ fn build_session_options(binary: ~str,\n     let mut lint_opts = ~[];\n     let lint_dict = lint::get_lint_dict();\n     for lint_levels.each |level| {\n-        let level_name = lint::level_to_str(level);\n+        let level_name = lint::level_to_str(*level);\n         let level_short = level_name.substr(0,1).to_upper();\n         let flags = vec::append(getopts::opt_strs(matches, level_short),\n                                 getopts::opt_strs(matches, level_name));\n         for flags.each |lint_name| {\n-            let lint_name = str::replace(lint_name, ~\"-\", ~\"_\");\n+            let lint_name = str::replace(*lint_name, ~\"-\", ~\"_\");\n             match lint_dict.find(lint_name) {\n               None => {\n                 early_error(demitter, fmt!(\"unknown %s flag: %s\",\n                                            level_name, lint_name));\n               }\n               Some(lint) => {\n-                vec::push(lint_opts, (lint.lint, level));\n+                vec::push(lint_opts, (lint.lint, *level));\n               }\n             }\n         }\n@@ -477,11 +479,11 @@ fn build_session_options(binary: ~str,\n     for debug_flags.each |debug_flag| {\n         let mut this_bit = 0u;\n         for debug_map.each |pair| {\n-            let (name, _, bit) = pair;\n-            if name == debug_flag { this_bit = bit; break; }\n+            let (name, _, bit) = *pair;\n+            if name == *debug_flag { this_bit = bit; break; }\n         }\n         if this_bit == 0u {\n-            early_error(demitter, fmt!(\"unknown debug flag: %s\", debug_flag))\n+            early_error(demitter, fmt!(\"unknown debug flag: %s\", *debug_flag))\n         }\n         debugging_opts |= this_bit;\n     }"}, {"sha": "d34d92b153412c5807e6626561ddaa20388ad06b", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -111,7 +111,7 @@ fn describe_warnings() {\n fn describe_debug_flags() {\n     io::println(fmt!(\"\\nAvailable debug options:\\n\"));\n     for session::debugging_opts_map().each |pair| {\n-        let (name, desc, _) = pair;\n+        let (name, desc, _) = *pair;\n         io::println(fmt!(\"    -Z%-20s -- %s\", name, desc));\n     }\n }\n@@ -267,7 +267,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n                      to get further details and report the results \\\n                      to github.com/mozilla/rust/issues\"\n                 ]/_.each |note| {\n-                    diagnostic::emit(None, note, diagnostic::note)\n+                    diagnostic::emit(None, *note, diagnostic::note)\n                 }\n             }\n             // Fail so the process returns a failure code"}, {"sha": "7599d94e0f69d84dab869a3916ebf2439830f288", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -142,7 +142,7 @@ fn metas_in_cfg(cfg: ast::crate_cfg, metas: ~[@ast::meta_item]) -> bool {\n     if !has_cfg_metas { return true; }\n \n     for cfg_metas.each |cfg_mi| {\n-        if attr::contains(cfg, cfg_mi) { return true; }\n+        if attr::contains(cfg, *cfg_mi) { return true; }\n     }\n \n     return false;"}, {"sha": "27c070cd20162e718314136369bcb7aaf5df959e", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -285,7 +285,7 @@ fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n     for cx.testfns.each |test| {\n-        vec::push(descs, mk_test_desc_rec(cx, test));\n+        vec::push(descs, mk_test_desc_rec(cx, *test));\n     }\n \n     let inner_expr = @{id: cx.sess.next_node_id(),"}, {"sha": "b6ee29b8a1b7b0f4476c5323b23b3fed8aed5986", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -1080,7 +1080,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n         let mut first: bool = true;\n         for tys.each |t| {\n             if first { first = false; } else { s += ~\", \"; }\n-            s += type_to_str_inner(names, outer, t);\n+            s += type_to_str_inner(names, outer, *t);\n         }\n         return s;\n     }\n@@ -1130,7 +1130,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n         let mut i: uint = 0u;\n         for outer0.each |tout| {\n             i += 1u;\n-            if tout as int == ty as int {\n+            if *tout as int == ty as int {\n                 let n: uint = vec::len::<TypeRef>(outer0) - i;\n                 return ~\"*\\\\\" + int::str(n as int);\n             }"}, {"sha": "03e15487ab986e9bff8919274f48657ad5b7ae2c", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -150,7 +150,7 @@ fn visit_item(e: env, i: @ast::item) {\n         }\n \n         for link_args.each |a| {\n-            match attr::get_meta_item_value_str(attr::attr_meta(a)) {\n+            match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n               Some(linkarg) => {\n                 cstore::add_used_link_args(cstore, linkarg);\n               }"}, {"sha": "61cf9646762a0a364947318a1398d01733a1dacb", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -595,7 +595,7 @@ fn get_enum_variants(intr: ident_interner, cdata: cmd, id: ast::node_id,\n           _         => { /* empty */ }\n         }\n         vec::push(infos, @{args: arg_tys, ctor_ty: ctor_ty, name: name,\n-                           id: did, disr_val: disr_val});\n+                           id: *did, disr_val: disr_val});\n         disr_val += 1;\n     }\n     return infos;\n@@ -881,7 +881,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n fn list_meta_items(intr: ident_interner,\n                    meta_items: ebml::Doc, out: io::Writer) {\n     for get_meta_items(meta_items).each |mi| {\n-        out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(mi, intr)));\n+        out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(*mi, intr)));\n     }\n }\n \n@@ -890,7 +890,7 @@ fn list_crate_attributes(intr: ident_interner, md: ebml::Doc, hash: ~str,\n     out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n \n     for get_attributes(md).each |attr| {\n-        out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(attr, intr)));\n+        out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(*attr, intr)));\n     }\n \n     out.write_str(~\"\\n\\n\");"}, {"sha": "1b9fc64dd86e525afe0de91e4ff8a298983460ec", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -100,7 +100,7 @@ fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n     let opt_rp = ecx.tcx.region_paramd_items.find(it.id);\n     for opt_rp.each |rp| {\n         do ebml_w.wr_tag(tag_region_param) {\n-            ty::serialize_region_variance(ebml_w, rp);\n+            ty::serialize_region_variance(ebml_w, *rp);\n         }\n     }\n }\n@@ -153,7 +153,7 @@ fn encode_ty_type_param_bounds(ebml_w: ebml::Writer, ecx: @encode_ctxt,\n                         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for params.each |param| {\n         ebml_w.start_tag(tag_items_data_item_ty_param_bounds);\n-        tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, param);\n+        tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, *param);\n         ebml_w.end_tag();\n     }\n }\n@@ -421,7 +421,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                 debug!(\"encode_info_for_class: doing %s %d\",\n                        ecx.tcx.sess.str_of(m.ident), m.id);\n                 encode_info_for_method(ecx, ebml_w, impl_path,\n-                                       should_inline(m.attrs), id, m,\n+                                       should_inline(m.attrs), id, *m,\n                                        vec::append(class_tps, m.tps));\n             }\n             _ => { /* don't encode private methods */ }\n@@ -633,7 +633,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n         for struct_def.traits.each |t| {\n-           encode_trait_ref(ebml_w, ecx, t);\n+           encode_trait_ref(ebml_w, ecx, *t);\n         }\n         /* Encode the dtor */\n         /* Encode id for dtor */\n@@ -696,7 +696,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n             });\n             encode_info_for_ctor(ecx, ebml_w, ctor.node.id, item.ident,\n                                  path, if tps.len() > 0u {\n-                                     Some(ii_ctor(ctor, item.ident, tps,\n+                                     Some(ii_ctor(*ctor, item.ident, tps,\n                                                   local_def(item.id))) }\n                                  else { None }, tps);\n         }\n@@ -727,7 +727,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n         for methods.each |m| {\n             vec::push(*index, {val: m.id, pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx, ebml_w, impl_path,\n-                                   should_inline(m.attrs), item.id, m,\n+                                   should_inline(m.attrs), item.id, *m,\n                                    vec::append(tps, m.tps));\n         }\n       }\n@@ -764,7 +764,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         for traits.each |associated_trait| {\n-           encode_trait_ref(ebml_w, ecx, associated_trait)\n+           encode_trait_ref(ebml_w, ecx, *associated_trait)\n         }\n         ebml_w.end_tag();\n \n@@ -874,12 +874,12 @@ fn create_index<T: Copy Hash IterBytes>(index: ~[entry<T>]) ->\n     for uint::range(0u, 256u) |_i| { vec::push(buckets, @mut ~[]); };\n     for index.each |elt| {\n         let h = elt.val.hash() as uint;\n-        vec::push(*buckets[h % 256], elt);\n+        vec::push(*buckets[h % 256], *elt);\n     }\n \n     let mut buckets_frozen = ~[];\n     for buckets.each |bucket| {\n-        vec::push(buckets_frozen, @*bucket);\n+        vec::push(buckets_frozen, @**bucket);\n     }\n     return buckets_frozen;\n }\n@@ -893,7 +893,7 @@ fn encode_index<T>(ebml_w: ebml::Writer, buckets: ~[@~[entry<T>]],\n     for buckets.each |bucket| {\n         vec::push(bucket_locs, ebml_w.writer.tell());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n-        for vec::each(*bucket) |elt| {\n+        for vec::each(**bucket) |elt| {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert elt.pos < 0xffff_ffff;\n             writer.write_be_u32(elt.pos as u32);\n@@ -905,8 +905,8 @@ fn encode_index<T>(ebml_w: ebml::Writer, buckets: ~[@~[entry<T>]],\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_index_table);\n     for bucket_locs.each |pos| {\n-        assert pos < 0xffff_ffff;\n-        writer.write_be_u32(pos as u32);\n+        assert *pos < 0xffff_ffff;\n+        writer.write_be_u32(*pos as u32);\n     }\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n@@ -949,7 +949,7 @@ fn encode_meta_item(ebml_w: ebml::Writer, mi: meta_item) {\n         ebml_w.writer.write(str::to_bytes(name));\n         ebml_w.end_tag();\n         for items.each |inner_item| {\n-            encode_meta_item(ebml_w, *inner_item);\n+            encode_meta_item(ebml_w, **inner_item);\n         }\n         ebml_w.end_tag();\n       }\n@@ -1000,15 +1000,15 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n     for crate.node.attrs.each |attr| {\n         vec::push(\n             attrs,\n-            if attr::get_attr_name(attr) != ~\"link\" {\n-                attr\n+            if attr::get_attr_name(*attr) != ~\"link\" {\n+                *attr\n             } else {\n                 match attr.node.value.node {\n                   meta_list(_, l) => {\n                     found_link_attr = true;;\n                     synthesize_link_attr(ecx, l)\n                   }\n-                  _ => attr\n+                  _ => *attr\n                 }\n             });\n     }\n@@ -1059,7 +1059,7 @@ fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n     // but is enough to get transitive crate dependencies working.\n     ebml_w.start_tag(tag_crate_deps);\n     for get_ordered_deps(ecx, cstore).each |dep| {\n-        encode_crate_dep(ecx, ebml_w, dep);\n+        encode_crate_dep(ecx, ebml_w, *dep);\n     }\n     ebml_w.end_tag();\n }\n@@ -1149,7 +1149,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n \n         do wr.buf.borrow |v| {\n             do v.each |e| {\n-                if e == 0 {\n+                if *e == 0 {\n                     ecx.stats.zero_bytes += 1;\n                 }\n                 true"}, {"sha": "25abcb1b7ebe0aa0745ad64c4b14a499c1c93085", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -71,9 +71,9 @@ fn search<T: Copy>(filesearch: filesearch, pick: pick<T>) -> Option<T> {\n     let mut rslt = None;\n     for filesearch.lib_search_paths().each |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());\n-        for os::list_dir_path(&lib_search_path).each |path| {\n+        for os::list_dir_path(lib_search_path).each |path| {\n             debug!(\"testing %s\", path.to_str());\n-            let maybe_picked = pick(path);\n+            let maybe_picked = pick(*path);\n             if option::is_some(maybe_picked) {\n                 debug!(\"picked %s\", path.to_str());\n                 rslt = maybe_picked;"}, {"sha": "c45b189d697ea4fa6f95a01fca40a3bf93c8432e", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -139,7 +139,7 @@ fn note_linkage_attrs(intr: ident_interner, diag: span_handler,\n                       attrs: ~[ast::attribute]) {\n     for attr::find_linkage_metas(attrs).each |mi| {\n         diag.handler().note(fmt!(\"meta: %s\",\n-              pprust::meta_item_to_str(mi,intr)));\n+              pprust::meta_item_to_str(*mi,intr)));\n     }\n }\n \n@@ -161,7 +161,7 @@ fn metadata_matches(extern_metas: ~[@ast::meta_item],\n            vec::len(local_metas), vec::len(extern_metas));\n \n     for local_metas.each |needed| {\n-        if !attr::contains(extern_metas, needed) {\n+        if !attr::contains(extern_metas, *needed) {\n             return false;\n         }\n     }"}, {"sha": "88d83ca23f4c2bd47442a889b7de737aec235ca6", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -120,7 +120,7 @@ fn enc_substs(w: io::Writer, cx: @ctxt, substs: ty::substs) {\n     do enc_opt(w, substs.self_r) |r| { enc_region(w, cx, r) }\n     do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n     w.write_char('[');\n-    for substs.tps.each |t| { enc_ty(w, cx, t); }\n+    for substs.tps.each |t| { enc_ty(w, cx, *t); }\n     w.write_char(']');\n }\n \n@@ -243,7 +243,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n       }\n       ty::ty_tup(ts) => {\n         w.write_str(&\"T[\");\n-        for ts.each |t| { enc_ty(w, cx, t); }\n+        for ts.each |t| { enc_ty(w, cx, *t); }\n         w.write_char(']');\n       }\n       ty::ty_box(mt) => { w.write_char('@'); enc_mt(w, cx, mt); }\n@@ -355,7 +355,7 @@ fn enc_ty_fn(w: io::Writer, cx: @ctxt, ft: ty::FnTy) {\n     enc_bounds(w, cx, ft.meta.bounds);\n     w.write_char('[');\n     for ft.sig.inputs.each |arg| {\n-        enc_arg(w, cx, arg);\n+        enc_arg(w, cx, *arg);\n     }\n     w.write_char(']');\n     match ft.meta.ret_style {"}, {"sha": "d0c722cab10865011a18ba0d0c83cc0d632f76b1", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -137,15 +137,15 @@ impl check_loan_ctxt {\n     }\n \n     fn walk_loans(scope_id: ast::node_id,\n-                  f: fn(loan) -> bool) {\n+                  f: fn(v: &loan) -> bool) {\n         let mut scope_id = scope_id;\n         let region_map = self.tcx().region_map;\n         let req_loan_map = self.req_maps.req_loan_map;\n \n         loop {\n             for req_loan_map.find(scope_id).each |loanss| {\n-                for (*loanss).each |loans| {\n-                    for (*loans).each |loan| {\n+                for loanss.each |loans| {\n+                    for loans.each |loan| {\n                         if !f(loan) { return; }\n                     }\n                 }\n@@ -160,7 +160,7 @@ impl check_loan_ctxt {\n \n     fn walk_loans_of(scope_id: ast::node_id,\n                      lp: @loan_path,\n-                     f: fn(loan) -> bool) {\n+                     f: fn(v: &loan) -> bool) {\n         for self.walk_loans(scope_id) |loan| {\n             if loan.lp == lp {\n                 if !f(loan) { return; }\n@@ -268,8 +268,8 @@ impl check_loan_ctxt {\n \n         let par_scope_id = self.tcx().region_map.get(scope_id);\n         for self.walk_loans(par_scope_id) |old_loan| {\n-            for (*new_loanss).each |new_loans| {\n-                for (*new_loans).each |new_loan| {\n+            for new_loanss.each |new_loans| {\n+                for new_loans.each |new_loan| {\n                     if old_loan.lp != new_loan.lp { loop; }\n                     match (old_loan.mutbl, new_loan.mutbl) {\n                       (m_const, _) | (_, m_const) |\n@@ -368,7 +368,7 @@ impl check_loan_ctxt {\n         // check_for_conflicting_loans()\n         for cmt.lp.each |lp| {\n             self.check_for_loan_conflicting_with_assignment(\n-                at, ex, cmt, lp);\n+                at, ex, cmt, *lp);\n         }\n \n         self.bccx.add_to_mutbl_map(cmt);\n@@ -517,7 +517,7 @@ impl check_loan_ctxt {\n                 pc, callee, callee_id, callee_span);\n             for args.each |arg| {\n                 self.check_pure_callee_or_arg(\n-                    pc, Some(arg), arg.id, arg.span);\n+                    pc, Some(*arg), arg.id, arg.span);\n             }\n           }\n         }"}, {"sha": "b3f846d47fdbd99c549b7f19576f326a697cf54e", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -95,7 +95,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     for tcx.adjustments.find(ex.id).each |adjustments| {\n-        self.guarantee_adjustments(ex, adjustments);\n+        self.guarantee_adjustments(ex, *adjustments);\n     }\n \n     // Special checks for various kinds of expressions:\n@@ -138,7 +138,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n         let cmt = self.bccx.cat_expr(ex_v);\n         for arms.each |arm| {\n             for arm.pats.each |pat| {\n-                self.gather_pat(cmt, pat, arm.body.node.id, ex.id);\n+                self.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n             }\n         }\n         visit::visit_expr(ex, self, vt);"}, {"sha": "1e8856051715e4635147991d1639e4ab57473063", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -78,12 +78,12 @@ fn compute_capture_vars(tcx: ty::ctxt,\n             if vec::any(*freevars, |fv| fv.def == cap_def ) {\n                 cap_map.insert(cap_def_id, {def:cap_def,\n                                             span: cap_item.span,\n-                                            cap_item: Some(cap_item),\n+                                            cap_item: Some(*cap_item),\n                                             mode:cap_move});\n             } else {\n                 cap_map.insert(cap_def_id, {def:cap_def,\n                                             span: cap_item.span,\n-                                            cap_item: Some(cap_item),\n+                                            cap_item: Some(*cap_item),\n                                             mode:cap_drop});\n             }\n         } else {\n@@ -92,7 +92,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n             if vec::any(*freevars, |fv| fv.def == cap_def ) {\n                 cap_map.insert(cap_def_id, {def:cap_def,\n                                             span: cap_item.span,\n-                                            cap_item: Some(cap_item),\n+                                            cap_item: Some(*cap_item),\n                                             mode:cap_copy});\n             }\n         }"}, {"sha": "9e1c8886353ee20ff7900b8197125f817c34bbab", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -60,7 +60,7 @@ fn check_arms(tcx: ty::ctxt, arms: ~[arm]) {\n     let mut seen = ~[];\n     for arms.each |arm| {\n         for arm.pats.each |pat| {\n-            let v = ~[pat];\n+            let v = ~[*pat];\n             match is_useful(tcx, seen, v) {\n               not_useful => {\n                 tcx.sess.span_err(pat.span, ~\"unreachable pattern\");\n@@ -449,24 +449,16 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n       pat_lit(@{node: expr_lit(@{node: lit_nil, _}), _}) => { false } // \"()\"\n       pat_lit(_) | pat_range(_, _) => { true }\n       pat_rec(fields, _) => {\n-        for fields.each |it| {\n-            if is_refutable(tcx, it.pat) { return true; }\n-        }\n-        false\n+        fields.any(|f| is_refutable(tcx, f.pat))\n       }\n       pat_struct(_, fields, _) => {\n-        for fields.each |it| {\n-            if is_refutable(tcx, it.pat) { return true; }\n-        }\n-        false\n+        fields.any(|f| is_refutable(tcx, f.pat))\n       }\n       pat_tup(elts) => {\n-        for elts.each |elt| { if is_refutable(tcx, elt) { return true; } }\n-        false\n+        elts.any(|elt| is_refutable(tcx, elt))\n       }\n       pat_enum(_, Some(args)) => {\n-        for args.each |p| { if is_refutable(tcx, p) { return true; } };\n-        false\n+        args.any(|a| is_refutable(tcx, a))\n       }\n       pat_enum(_,_) => { false }\n     }"}, {"sha": "b5bd685d83564421501a21a490c32024d8d3487b", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -316,12 +316,12 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n       }\n       expr_tup(exprs) | expr_vec(exprs, _) => {\n-        for exprs.each |expr| { maybe_copy(cx, expr, None); }\n+        for exprs.each |expr| { maybe_copy(cx, *expr, None); }\n       }\n       expr_call(f, args, _) => {\n         let mut i = 0u;\n         for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each |arg_t| {\n-            match ty::arg_mode(cx.tcx, arg_t) {\n+            match ty::arg_mode(cx.tcx, *arg_t) {\n               by_copy => maybe_copy(cx, args[i], None),\n               by_ref | by_val | by_mutbl_ref | by_move => ()\n             }"}, {"sha": "e33ff5dcf50e6e2c2958bc2a09b21c58fbc6fefc", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -208,7 +208,7 @@ impl LanguageItemCollector {\n \n                 do get_item_attrs(crate_store, def_id) |meta_items| {\n                     for meta_items.each |meta_item| {\n-                        self.match_and_collect_meta_item(def_id, *meta_item);\n+                        self.match_and_collect_meta_item(def_id, **meta_item);\n                     }\n                 }\n             }\n@@ -217,7 +217,7 @@ impl LanguageItemCollector {\n \n     fn check_completeness() {\n         for self.item_refs.each |key, item_ref| {\n-            match copy *item_ref {\n+            match *item_ref {\n                 None => {\n                     self.session.err(fmt!(\"no item found for `%s`\", key));\n                 }"}, {"sha": "7ffc0fcf090c58bcae329cf666003971d6e245aa", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -278,7 +278,7 @@ impl ctxt {\n         let mut triples = ~[];\n \n         for [allow, warn, deny, forbid].each |level| {\n-            let level_name = level_to_str(level);\n+            let level_name = level_to_str(*level);\n             let metas =\n                 attr::attr_metas(attr::find_attrs_by_name(attrs,\n                                                           level_name));\n@@ -288,7 +288,7 @@ impl ctxt {\n                     for metas.each |meta| {\n                         match meta.node {\n                           ast::meta_word(lintname) => {\n-                            vec::push(triples, (meta, level, lintname));\n+                            vec::push(triples, (*meta, *level, lintname));\n                           }\n                           _ => {\n                             self.sess.span_err(\n@@ -307,7 +307,7 @@ impl ctxt {\n         }\n \n         for triples.each |pair| {\n-            let (meta, level, lintname) = pair;\n+            let (meta, level, lintname) = *pair;\n             match self.dict.find(lintname) {\n               None => {\n                 self.span_lint(\n@@ -367,7 +367,7 @@ fn build_settings_crate(sess: session::session, crate: @ast::crate) {\n \n     // Install command-line options, overriding defaults.\n     for sess.opts.lint_opts.each |pair| {\n-        let (lint,level) = pair;\n+        let (lint,level) = *pair;\n         cx.set_level(lint, level);\n     }\n \n@@ -534,7 +534,7 @@ fn check_item_heap(cx: ty::ctxt, it: @ast::item) {\n             for [managed_heap_memory,\n                  owned_heap_memory,\n                  heap_memory].each |lint| {\n-                check_type_for_lint(cx, lint, node, item, span, ty);\n+                check_type_for_lint(cx, *lint, node, item, span, ty);\n             }\n     }\n "}, {"sha": "18480ee483fe228570b573c808e88d62520a9f30", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -495,7 +495,7 @@ fn visit_local(local: @local, &&self: @IrMaps, vt: vt<@IrMaps>) {\n fn visit_arm(arm: arm, &&self: @IrMaps, vt: vt<@IrMaps>) {\n     let def_map = self.tcx.def_map;\n     for arm.pats.each |pat| {\n-        do pat_util::pat_bindings(def_map, pat) |bm, p_id, sp, path| {\n+        do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n             debug!(\"adding local variable %d from match with bm %?\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n@@ -1524,7 +1524,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n       expr_path(_) => {\n         for self.variable_from_def_map(expr.id, expr.span).each |var| {\n             let ln = self.live_node(expr.id, expr.span);\n-            self.consider_last_use(expr, ln, var);\n+            self.consider_last_use(expr, ln, *var);\n         }\n \n         visit::visit_expr(expr, self, vt);\n@@ -1911,11 +1911,11 @@ impl @Liveness {\n                     // FIXME(#3266)--make liveness warnings lintable\n                     self.tcx.sess.span_warn(\n                         sp, fmt!(\"variable `%s` is assigned to, \\\n-                                  but never used\", name));\n+                                  but never used\", *name));\n                 } else {\n                     // FIXME(#3266)--make liveness warnings lintable\n                     self.tcx.sess.span_warn(\n-                        sp, fmt!(\"unused variable: `%s`\", name));\n+                        sp, fmt!(\"unused variable: `%s`\", *name));\n                 }\n             }\n             return true;\n@@ -1929,7 +1929,7 @@ impl @Liveness {\n                 // FIXME(#3266)--make liveness warnings lintable\n                 self.tcx.sess.span_warn(\n                     sp,\n-                    fmt!(\"value assigned to `%s` is never read\", name));\n+                    fmt!(\"value assigned to `%s` is never read\", *name));\n             }\n         }\n     }"}, {"sha": "c4b0e0ffd00ed361a50294886443e2a329f30380", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -838,8 +838,8 @@ impl &mem_categorization_ctxt {\n             };\n \n             for subpats.each |subpat| {\n-                let subcmt = self.cat_variant(subpat, enum_did, cmt);\n-                self.cat_pattern(subcmt, subpat, op);\n+                let subcmt = self.cat_variant(*subpat, enum_did, cmt);\n+                self.cat_pattern(subcmt, *subpat, op);\n             }\n           }\n \n@@ -870,8 +870,8 @@ impl &mem_categorization_ctxt {\n           ast::pat_tup(subpats) => {\n             // (p1, ..., pN)\n             for subpats.each |subpat| {\n-                let subcmt = self.cat_tuple_elt(subpat, cmt);\n-                self.cat_pattern(subcmt, subpat, op);\n+                let subcmt = self.cat_tuple_elt(*subpat, cmt);\n+                self.cat_pattern(subcmt, *subpat, op);\n             }\n           }\n "}, {"sha": "b0916af376c3565c73025a2d820e5d90957d6902", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -195,8 +195,8 @@ fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n /// Records the current parent (if any) as the parent of `child_id`.\n fn record_parent(cx: ctxt, child_id: ast::node_id) {\n     for cx.parent.each |parent_id| {\n-        debug!(\"parent of node %d is node %d\", child_id, parent_id);\n-        cx.region_map.insert(child_id, parent_id);\n+        debug!(\"parent of node %d is node %d\", child_id, *parent_id);\n+        cx.region_map.insert(child_id, *parent_id);\n     }\n }\n \n@@ -700,7 +700,7 @@ fn determine_rp_in_ty(ty: @ast::ty,\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n             for path.types.each |tp| {\n-                visitor.visit_ty(tp, cx, visitor);\n+                visitor.visit_ty(*tp, cx, visitor);\n             }\n         }\n       }"}, {"sha": "24806197baf89bfd984bea7c578a415746135604", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -484,7 +484,7 @@ pure fn is_none<T>(x: Option<T>) -> bool {\n \n fn unused_import_lint_level(session: session) -> level {\n     for session.opts.lint_opts.each |lint_option_pair| {\n-        let (lint_type, lint_level) = lint_option_pair;\n+        let (lint_type, lint_level) = *lint_option_pair;\n         if lint_type == unused_imports {\n             return lint_level;\n         }\n@@ -1040,7 +1040,7 @@ impl Resolver {\n                      sp);\n \n                 for enum_definition.variants.each |variant| {\n-                    self.build_reduced_graph_for_variant(variant,\n+                    self.build_reduced_graph_for_variant(*variant,\n                                                          local_def(item.id),\n                                                          new_parent,\n                                                          visitor);\n@@ -1097,7 +1097,7 @@ impl Resolver {\n                 // Add the names of all the methods to the trait info.\n                 let method_names = @atom_hashmap();\n                 for methods.each |method| {\n-                    let ty_m = trait_method_to_ty_method(method);\n+                    let ty_m = trait_method_to_ty_method(*method);\n \n                     let atom = ty_m.ident;\n                     // Add it to the trait info if not static,\n@@ -1166,7 +1166,7 @@ impl Resolver {\n                                      def_ty(local_def(variant.node.id)),\n                                      variant.span);\n                 for enum_definition.variants.each |variant| {\n-                    self.build_reduced_graph_for_variant(variant, item_id,\n+                    self.build_reduced_graph_for_variant(*variant, item_id,\n                                                          parent, visitor);\n                 }\n             }\n@@ -1203,7 +1203,7 @@ impl Resolver {\n                         view_path_glob(module_ident_path, _) |\n                         view_path_list(module_ident_path, _, _) => {\n                             for module_ident_path.idents.each |ident| {\n-                                (*module_path).push(ident);\n+                                (*module_path).push(*ident);\n                             }\n                         }\n                     }\n@@ -1466,7 +1466,7 @@ impl Resolver {\n               Some(method_names) => {\n                 let interned_method_names = @atom_hashmap();\n                 for method_names.each |method_data| {\n-                    let (method_name, self_ty) = method_data;\n+                    let (method_name, self_ty) = *method_data;\n                     debug!(\"(building reduced graph for \\\n                             external crate) ... adding \\\n                             trait method '%s'\",\n@@ -1530,7 +1530,7 @@ impl Resolver {\n \n             let mut current_module = root;\n             for pieces.each |ident_str| {\n-                let ident = self.session.ident_of(ident_str);\n+                let ident = self.session.ident_of(*ident_str);\n                 // Create or reuse a graph node for the child.\n                 let (child_name_bindings, new_parent) =\n                     self.add_child(ident,\n@@ -1542,7 +1542,7 @@ impl Resolver {\n                 match child_name_bindings.module_def {\n                     NoModuleDef => {\n                         debug!(\"(building reduced graph for external crate) \\\n-                                autovivifying %s\", ident_str);\n+                                autovivifying %s\", *ident_str);\n                         let parent_link = self.get_parent_link(new_parent,\n                                                                ident);\n                         (*child_name_bindings).define_module(parent_link,\n@@ -1667,7 +1667,7 @@ impl Resolver {\n         self.resolve_imports_for_module(module_);\n \n         for module_.children.each |_name, child_node| {\n-            match (*child_node).get_module_if_available() {\n+            match child_node.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n                 }\n@@ -1724,7 +1724,7 @@ impl Resolver {\n             } else {\n                 result += ~\"::\";\n             }\n-            result += self.session.str_of(atom);\n+            result += self.session.str_of(*atom);\n         }\n         // XXX: Shouldn't copy here. We need string builder functionality.\n         return result;\n@@ -2757,7 +2757,7 @@ impl Resolver {\n \n         // Descend into children and anonymous children.\n         for module_.children.each |_name, child_node| {\n-            match (*child_node).get_module_if_available() {\n+            match child_node.get_module_if_available() {\n                 None => {\n                     // Continue.\n                 }\n@@ -2809,7 +2809,7 @@ impl Resolver {\n         self.record_exports_for_module(module_);\n \n         for module_.children.each |_atom, child_name_bindings| {\n-            match (*child_name_bindings).get_module_if_available() {\n+            match child_name_bindings.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n                 }\n@@ -2830,9 +2830,9 @@ impl Resolver {\n             let mut exports = ~[];\n             for self.namespaces.each |namespace| {\n                 match self.resolve_definition_of_name_in_module(module_,\n-                                                              name,\n-                                                              namespace,\n-                                                              Xray) {\n+                                                                name,\n+                                                                *namespace,\n+                                                                Xray) {\n                     NoNameDefinition => {\n                         // Nothing to do.\n                     }\n@@ -3158,7 +3158,7 @@ impl Resolver {\n                         //\n                         // XXX: Do we need a node ID here?\n \n-                        match method {\n+                        match *method {\n                           required(ty_m) => {\n                             do self.with_type_parameter_rib\n                                 (HasTypeParameters(&ty_m.tps,\n@@ -3222,12 +3222,12 @@ impl Resolver {\n                                                        OpaqueFunctionRibKind))\n                                         || {\n \n-                                    visit_foreign_item(foreign_item, (),\n+                                    visit_foreign_item(*foreign_item, (),\n                                                        visitor);\n                                 }\n                             }\n                             foreign_item_const(_) => {\n-                                visit_foreign_item(foreign_item, (),\n+                                visit_foreign_item(*foreign_item, (),\n                                                    visitor);\n                             }\n                         }\n@@ -3338,9 +3338,9 @@ impl Resolver {\n                 // Resolve each captured item.\n                 for (*capture_clause).each |capture_item| {\n                     match self.resolve_identifier(capture_item.name,\n-                                                ValueNS,\n-                                                true,\n-                                                capture_item.span) {\n+                                                  ValueNS,\n+                                                  true,\n+                                                  capture_item.span) {\n                         None => {\n                             self.session.span_err(capture_item.span,\n                                                   ~\"unresolved name in \\\n@@ -3422,8 +3422,8 @@ impl Resolver {\n                                visitor: ResolveVisitor) {\n \n         for type_parameters.each |type_parameter| {\n-            for (*type_parameter.bounds).each |bound| {\n-                match bound {\n+            for type_parameter.bounds.each |bound| {\n+                match *bound {\n                     bound_copy | bound_send | bound_const | bound_owned => {\n                         // Nothing to do.\n                     }\n@@ -3482,7 +3482,7 @@ impl Resolver {\n             // Resolve methods.\n             for methods.each |method| {\n                 self.resolve_method(MethodRibKind(id, Provided(method.id)),\n-                                    method,\n+                                    *method,\n                                     outer_type_parameter_count,\n                                     visitor);\n             }\n@@ -3605,7 +3605,7 @@ impl Resolver {\n                 // We also need a new scope for the method-specific\n                 // type parameters.\n                 self.resolve_method(MethodRibKind(id, Provided(method.id)),\n-                                    method,\n+                                    *method,\n                                     outer_type_parameter_count,\n                                     visitor);\n /*\n@@ -3718,7 +3718,7 @@ impl Resolver {\n \n         let bindings_list = atom_hashmap();\n         for arm.pats.each |pattern| {\n-            self.resolve_pattern(pattern, RefutableMode, Immutable,\n+            self.resolve_pattern(*pattern, RefutableMode, Immutable,\n                                  Some(bindings_list), visitor);\n         }\n \n@@ -3939,7 +3939,7 @@ impl Resolver {\n \n                     // Check the types in the path pattern.\n                     for path.types.each |ty| {\n-                        self.resolve_type(ty, visitor);\n+                        self.resolve_type(*ty, visitor);\n                     }\n                 }\n \n@@ -3964,7 +3964,7 @@ impl Resolver {\n \n                     // Check the types in the path pattern.\n                     for path.types.each |ty| {\n-                        self.resolve_type(ty, visitor);\n+                        self.resolve_type(*ty, visitor);\n                     }\n                 }\n \n@@ -4057,7 +4057,7 @@ impl Resolver {\n \n         // First, resolve the types.\n         for path.types.each |ty| {\n-            self.resolve_type(ty, visitor);\n+            self.resolve_type(*ty, visitor);\n         }\n \n         if path.global {\n@@ -4583,7 +4583,7 @@ impl Resolver {\n                 Some(trait_def_ids) => {\n                     for trait_def_ids.each |trait_def_id| {\n                         self.add_trait_info_if_containing_method\n-                            (found_traits, trait_def_id, name);\n+                            (found_traits, *trait_def_id, name);\n                     }\n                 }\n                 None => {"}, {"sha": "67f20f124094b12fdc65bd8bf7dbd85f235f9c3b", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -797,7 +797,7 @@ fn compile_guard(bcx: block,\n \n     // Revoke the temp cleanups now that the guard successfully executed.\n     for temp_cleanups.each |llval| {\n-        revoke_clean(bcx, llval);\n+        revoke_clean(bcx, *llval);\n     }\n \n     return do with_cond(bcx, Not(bcx, val)) |bcx| {\n@@ -1158,11 +1158,11 @@ fn trans_alt_inner(scope_cx: block,\n         // is just to reduce code space.  See extensive comment at the start\n         // of the file for more details.\n         if arm_data.arm.guard.is_none() {\n-            bcx = store_non_ref_bindings(bcx, arm_data, None);\n+            bcx = store_non_ref_bindings(bcx, *arm_data, None);\n         }\n \n         // insert bindings into the lllocals map and add cleanups\n-        bcx = insert_lllocals(bcx, arm_data, true);\n+        bcx = insert_lllocals(bcx, *arm_data, true);\n \n         bcx = controlflow::trans_block(bcx, arm_data.arm.body, dest);\n         bcx = trans_block_cleanups(bcx, block_cleanups(arm_data.bodycx));\n@@ -1208,7 +1208,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n             }\n \n             for inner.each |inner_pat| {\n-                bcx = bind_irrefutable_pat(bcx, inner_pat, val, true);\n+                bcx = bind_irrefutable_pat(bcx, *inner_pat, val, true);\n             }\n       }\n         ast::pat_enum(_, sub_pats) => {"}, {"sha": "70e02a5aaf9e01bbc5f053c1b5e9bf8bfcd338dd", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -409,9 +409,9 @@ fn revoke_clean(cx: block, val: ValueRef) {\n             });\n         for cleanup_pos.each |i| {\n             info.cleanups =\n-                vec::append(vec::slice(info.cleanups, 0u, i),\n+                vec::append(vec::slice(info.cleanups, 0u, *i),\n                             vec::view(info.cleanups,\n-                                      i + 1u,\n+                                      *i + 1u,\n                                       info.cleanups.len()));\n             scope_clean_changed(info);\n         }"}, {"sha": "40530a54bd8f2eb34fca99a19e97ff82375ec3ca", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -152,7 +152,7 @@ fn cached_metadata<T: Copy>(cache: metadata_cache, mdtag: int,\n     if cache.contains_key(mdtag) {\n         let items = cache.get(mdtag);\n         for items.each |item| {\n-            let md: T = md_from_metadata::<T>(item);\n+            let md: T = md_from_metadata::<T>(*item);\n             if eq(md) {\n                 return option::Some(md);\n             }"}, {"sha": "ea2aa7c98e1566212d8e6cd2908dbd3997b541e7", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -687,7 +687,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     // at the end of the scope with id `scope_id`:\n     let root_key = {id:expr.id, derefs:0u};\n     for bcx.ccx().maps.root_map.find(root_key).each |scope_id| {\n-        unrooted_datum.root(bcx, scope_id);\n+        unrooted_datum.root(bcx, *scope_id);\n     }\n \n     return DatumBlock {bcx: bcx, datum: unrooted_datum};\n@@ -996,7 +996,7 @@ fn trans_rec_or_struct(bcx: block,\n         // functional record update)\n         for base.each |base_expr| {\n             let base_datum = unpack_datum!(\n-                bcx, trans_to_datum(bcx, base_expr));\n+                bcx, trans_to_datum(bcx, *base_expr));\n \n             // Copy over inherited fields\n             for field_tys.eachi |i, field_ty| {\n@@ -1017,7 +1017,9 @@ fn trans_rec_or_struct(bcx: block,\n \n         // Now revoke the cleanups as we pass responsibility for the data\n         // structure on to the caller\n-        for temp_cleanups.each |cleanup| { revoke_clean(bcx, cleanup); }\n+        for temp_cleanups.each |cleanup| {\n+            revoke_clean(bcx, *cleanup);\n+        }\n         bcx\n     }\n }"}, {"sha": "1c973620ba29915ba11f1f91e202446186fd9ca8", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -104,7 +104,7 @@ fn trans_self_arg(bcx: block, base: @ast::expr,\n     // FIXME(#3446)---this is wrong, actually.  The temp_cleanups\n     // should be revoked only after all arguments have been passed.\n     for temp_cleanups.each |c| {\n-        revoke_clean(bcx, c)\n+        revoke_clean(bcx, *c)\n     }\n \n     return result;"}, {"sha": "f78a7452f4a281aaa7e62b07cec77b8c9954f4e1", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -28,8 +28,8 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n         }\n     });\n \n-    for real_substs.each() |s| { assert !ty::type_has_params(s); }\n-    for substs.each() |s| { assert !ty::type_has_params(s); }\n+    for real_substs.each() |s| { assert !ty::type_has_params(*s); }\n+    for substs.each() |s| { assert !ty::type_has_params(*s); }\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     let hash_id = make_mono_id(ccx, fn_id, substs, vtables, Some(param_uses));\n     if vec::any(hash_id.params,"}, {"sha": "d7d7af3ed8cde4b244cad8c46c5f33b4653cf028", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -166,7 +166,9 @@ fn traverse_ty(ty: @ty, cx: ctx, v: visit::vt<ctx>) {\n           Some(d) => traverse_def_id(cx, def_id_of_def(d)),\n           None    => { /* do nothing -- but should we fail here? */ }\n         }\n-        for p.types.each |t| { v.visit_ty(t, cx, v); };\n+        for p.types.each |t| {\n+            v.visit_ty(*t, cx, v);\n+        }\n       }\n       _ => visit::visit_ty(ty, cx, v)\n     }"}, {"sha": "bed945815d465378af02ec3dfef328149ddcd300", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -46,7 +46,7 @@ impl nominal_id_ : to_bytes::IterBytes {\n     pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.did, &self.parent_id, lsb0, f);\n         for self.tps.each |t| {\n-            ty::type_id(t).iter_bytes(lsb0, f);\n+            ty::type_id(*t).iter_bytes(lsb0, f);\n         }\n     }\n }\n@@ -415,7 +415,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n     let mut inf_sz = 0u16;\n     for enum_variants.each |variants| {\n-        let num_variants = vec::len(*variants) as u16;\n+        let num_variants = vec::len(**variants) as u16;\n         add_u16(header, header_sz + inf_sz);\n         inf_sz += 2u16 * (num_variants + 2u16) + 3u16;\n     }\n@@ -427,31 +427,29 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let mut lv_table = ~[];\n     let mut i = 0u;\n     for enum_variants.each |variants| {\n-        add_u16(inf, vec::len(*variants) as u16);\n+        add_u16(inf, vec::len(**variants) as u16);\n \n         // Construct the largest-variants table.\n         add_u16(inf,\n                 header_sz + inf_sz + data_sz + (vec::len(lv_table) as u16));\n \n-        let lv = largest_variants(ccx, variants);\n+        let lv = largest_variants(ccx, *variants);\n         add_u16(lv_table, vec::len(lv) as u16);\n         for vec::each(lv) |v| { add_u16(lv_table, *v as u16); }\n \n         // Determine whether the enum has dynamic size.\n-        assert !vec::any(*variants, |v| {\n-            vec::any(v.args, |t| ty::type_has_params(t))\n-        });\n+        assert !variants.any(|v| v.args.any(|t| ty::type_has_params(t)));\n \n         // If we can, write in the static size and alignment of the enum.\n         // Otherwise, write a placeholder.\n-        let size_align = compute_static_enum_size(ccx, lv, variants);\n+        let size_align = compute_static_enum_size(ccx, lv, *variants);\n \n         // Write in the static size and alignment of the enum.\n         add_u16(inf, size_align.size);\n         inf += ~[size_align.align];\n \n         // Now write in the offset of each variant.\n-        for vec::each(*variants) |_v| {\n+        for variants.each |_v| {\n             add_u16(inf, header_sz + inf_sz + offsets[i]);\n             i += 1u;\n         }\n@@ -584,7 +582,7 @@ fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let len = ccx.shape_cx.resources.len();\n     for uint::range(0u, len) |i| {\n         let ri = ccx.shape_cx.resources.get(i);\n-        for ri.tps.each() |s| { assert !ty::type_has_params(s); }\n+        for ri.tps.each() |s| { assert !ty::type_has_params(*s); }\n         do option::iter(ri.parent_id) |id| {\n             dtors += ~[trans::base::get_res_dtor(ccx, ri.did, id, ri.tps)];\n         }\n@@ -613,7 +611,7 @@ fn force_declare_tydescs(ccx: @crate_ctxt) {\n     let len = ccx.shape_cx.resources.len();\n     for uint::range(0u, len) |i| {\n         let ri = ccx.shape_cx.resources.get(i);\n-        for ri.tps.each() |s| { assert !ty::type_has_params(s); }\n+        for ri.tps.each() |s| { assert !ty::type_has_params(*s); }\n         do option::iter(ri.parent_id) |id| {\n             trans::base::get_res_dtor(ccx, ri.did, id, ri.tps);\n         }"}, {"sha": "31eeedae10404558ef57c319a5d1bcd58edd3766", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -319,7 +319,7 @@ fn write_content(bcx: block,\n             match dest {\n                 Ignore => {\n                     for elements.each |element| {\n-                        bcx = expr::trans_into(bcx, element, Ignore);\n+                        bcx = expr::trans_into(bcx, *element, Ignore);\n                     }\n                 }\n "}, {"sha": "000a93f76670594c859f66d985680452188178bc", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -41,7 +41,7 @@ fn node_ids_in_fn(tcx: ty::ctxt, body: blk, rs: @mut ~[node_id]) {\n fn init_vecs(ccx: crate_ctxt, node_ids: ~[node_id], len: uint) {\n     for node_ids.each |i| {\n         log(debug, int::str(i) + ~\" |-> \" + uint::str(len));\n-        add_node(ccx, i, empty_ann(len));\n+        add_node(ccx, *i, empty_ann(len));\n     }\n }\n "}, {"sha": "8f9f8fb03ade5dc482716fdd1305f18536e98593", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -900,7 +900,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n     }\n     fn sflags(substs: &substs) -> uint {\n         let mut f = 0u;\n-        for substs.tps.each |tt| { f |= get(tt).flags; }\n+        for substs.tps.each |tt| { f |= get(*tt).flags; }\n         substs.self_r.iter(|r| f |= rflags(r));\n         return f;\n     }\n@@ -931,7 +931,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n         flags |= get(m.ty).flags;\n       }\n       ty_rec(flds) => for flds.each |f| { flags |= get(f.mt.ty).flags; },\n-      ty_tup(ts) => for ts.each |tt| { flags |= get(tt).flags; },\n+      ty_tup(ts) => for ts.each |tt| { flags |= get(*tt).flags; },\n       ty_fn(ref f) => {\n         match f.meta.proto {\n             ty::proto_vstore(vstore_slice(r)) => flags |= rflags(r),\n@@ -1135,12 +1135,12 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n       }\n       ty_enum(_, substs) | ty_class(_, substs) |\n       ty_trait(_, substs, _) => {\n-        for substs.tps.each |subty| { maybe_walk_ty(subty, f); }\n+        for substs.tps.each |subty| { maybe_walk_ty(*subty, f); }\n       }\n       ty_rec(fields) => {\n         for fields.each |fl| { maybe_walk_ty(fl.mt.ty, f); }\n       }\n-      ty_tup(ts) => { for ts.each |tt| { maybe_walk_ty(tt, f); } }\n+      ty_tup(ts) => { for ts.each |tt| { maybe_walk_ty(*tt, f); } }\n       ty_fn(ref ft) => {\n         for ft.sig.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n         maybe_walk_ty(ft.sig.output, f);\n@@ -1621,15 +1621,15 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n          }\n       }\n       ty_tup(elts) => {\n-          for elts.each |m| { if type_needs_drop(cx, m) { accum = true; } }\n+          for elts.each |m| { if type_needs_drop(cx, *m) { accum = true; } }\n         accum\n       }\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n           for vec::each(*variants) |variant| {\n               for variant.args.each |aty| {\n                 // Perform any type parameter substitutions.\n-                let arg_ty = subst(cx, substs, aty);\n+                let arg_ty = subst(cx, substs, *aty);\n                 if type_needs_drop(cx, arg_ty) { accum = true; }\n             }\n             if accum { break; }\n@@ -1692,7 +1692,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n           ty_enum(did, ref substs) => {\n             for vec::each(*enum_variants(cx, did)) |v| {\n                 for v.args.each |aty| {\n-                    let t = subst(cx, substs, aty);\n+                    let t = subst(cx, substs, *aty);\n                     needs_unwind_cleanup |=\n                         type_needs_unwind_cleanup_(cx, t, tycache,\n                                                    encountered_box);\n@@ -2040,7 +2040,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) => {\n         let mut lowest = kind_top();\n-        for tys.each |ty| { lowest = lower_kind(lowest, type_kind(cx, ty)); }\n+        for tys.each |ty| { lowest = lower_kind(lowest, type_kind(cx, *ty)); }\n         lowest\n       }\n \n@@ -2054,7 +2054,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n             for vec::each(*variants) |variant| {\n                 for variant.args.each |aty| {\n                     // Perform any type parameter substitutions.\n-                    let arg_ty = subst(cx, substs, aty);\n+                    let arg_ty = subst(cx, substs, *aty);\n                     lowest = lower_kind(lowest, type_kind(cx, arg_ty));\n                     if lowest == kind_noncopyable() { break; }\n                 }\n@@ -2273,7 +2273,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(x: &sty) -> bool) ->\n       ty_enum(did, ref substs) => {\n         for vec::each(*enum_variants(cx, did)) |variant| {\n             for variant.args.each |aty| {\n-                let sty = subst(cx, substs, aty);\n+                let sty = subst(cx, substs, *aty);\n                 if type_structurally_contains(cx, sty, test) { return true; }\n             }\n         }\n@@ -2297,7 +2297,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(x: &sty) -> bool) ->\n \n       ty_tup(ts) => {\n         for ts.each |tt| {\n-            if type_structurally_contains(cx, tt, test) { return true; }\n+            if type_structurally_contains(cx, *tt, test) { return true; }\n         }\n         return false;\n       }\n@@ -2374,7 +2374,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         }\n       }\n       ty_tup(elts) => {\n-        for elts.each |elt| { if !type_is_pod(cx, elt) { result = false; } }\n+        for elts.each |elt| { if !type_is_pod(cx, *elt) { result = false; } }\n       }\n       ty_estr(vstore_fixed(_)) => result = true,\n       ty_evec(mt, vstore_fixed(_)) | ty_unboxed_vec(mt) => {\n@@ -3667,9 +3667,9 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n     if is_local(did) {\n        let ms = lookup_class_method_ids(cx, did);\n         for ms.each |m| {\n-         if m.name == name {\n-             return ast_util::local_def(m.id);\n-         }\n+            if m.name == name {\n+                return ast_util::local_def(m.id);\n+            }\n        }\n        cx.sess.span_fatal(sp, fmt!(\"Class doesn't have a method \\\n            named %s\", cx.sess.str_of(name)));"}, {"sha": "b7cdbbb8571b2cf8fa65214f00eddab87f860636", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -428,7 +428,7 @@ fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n     let field_names = HashMap();\n \n     for fields.each |p| {\n-        let (id, sp) = p;\n+        let (id, sp) = *p;\n         match field_names.find(id) {\n           Some(orig_sp) => {\n             tcx.sess.span_err(sp, fmt!(\"Duplicate field \\\n@@ -477,7 +477,7 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n \n     // typecheck the methods\n     for struct_def.methods.each |m| {\n-        check_method(ccx, m, self_ty, local_def(id));\n+        check_method(ccx, *m, self_ty, local_def(id));\n     }\n     // Check that there's at least one field\n     if struct_def.fields.len() < 1u {\n@@ -507,12 +507,12 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n         for ms.each |m| {\n-            check_method(ccx, m, self_ty, local_def(it.id));\n+            check_method(ccx, *m, self_ty, local_def(it.id));\n         }\n       }\n       ast::item_trait(_, _, trait_methods) => {\n         for trait_methods.each |trait_method| {\n-            match trait_method {\n+            match *trait_method {\n               required(*) => {\n                 // Nothing to do, since required methods don't have\n                 // bodies to check.\n@@ -542,7 +542,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         if syntax::attr::foreign_abi(it.attrs) ==\n             either::Right(ast::foreign_abi_rust_intrinsic) {\n             for m.items.each |item| {\n-                check_intrinsic_type(ccx, item);\n+                check_intrinsic_type(ccx, *item);\n             }\n         } else {\n             for m.items.each |item| {\n@@ -868,7 +868,7 @@ fn check_expr(fcx: @fn_ctxt, expr: @ast::expr,\n               expected: Option<ty::t>) -> bool {\n     return do check_expr_with_unifier(fcx, expr, expected) {\n         for expected.each |t| {\n-            demand::suptype(fcx, expr.span, t, fcx.expr_ty(expr));\n+            demand::suptype(fcx, expr.span, *t, fcx.expr_ty(expr));\n         }\n     };\n }\n@@ -1024,6 +1024,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // of arguments when we typecheck the functions. This isn't really the\n         // right way to do this.\n         for [false, true]/_.each |check_blocks| {\n+            let check_blocks = *check_blocks;\n             debug!(\"check_blocks=%b\", check_blocks);\n \n             // More awful hacks: before we check the blocks, try to do\n@@ -1442,7 +1443,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           ast::expr_vec(args, mutbl) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vec::len(args), vst);\n             let t: ty::t = fcx.infcx().next_ty_var();\n-            for args.each |e| { bot |= check_expr_with(fcx, e, t); }\n+            for args.each |e| { bot |= check_expr_with(fcx, *e, t); }\n             ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n           }\n           ast::expr_repeat(element, count_expr, mutbl) => {\n@@ -1813,7 +1814,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_vec(args, mutbl) => {\n         let t: ty::t = fcx.infcx().next_ty_var();\n-        for args.each |e| { bot |= check_expr_with(fcx, e, t); }\n+        for args.each |e| { bot |= check_expr_with(fcx, *e, t); }\n         let typ = ty::mk_evec(tcx, {ty: t, mutbl: mutbl},\n                               ty::vstore_fixed(args.len()));\n         fcx.write_ty(id, typ);\n@@ -2138,7 +2139,7 @@ fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n         node_id = id;\n         match decl.node {\n           ast::decl_local(ls) => for ls.each |l| {\n-            bot |= check_decl_local(fcx, l);\n+            bot |= check_decl_local(fcx, *l);\n           },\n           ast::decl_item(_) => {/* ignore for now */ }\n         }\n@@ -2186,7 +2187,7 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n                 fcx.ccx.tcx.sess.span_warn(s.span, ~\"unreachable statement\");\n                 warned = true;\n             }\n-            bot |= check_stmt(fcx, s);\n+            bot |= check_stmt(fcx, *s);\n         }\n         match blk.node.expr {\n           None => fcx.write_nil(blk.node.id),"}, {"sha": "77d1ce4f77460d98dfa92061af0705baad582864", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -23,7 +23,7 @@ fn check_alt(fcx: @fn_ctxt,\n             block_region: ty::re_scope(arm.body.node.id)\n         };\n \n-        for arm.pats.each |p| { check_pat(pcx, p, pattern_ty);}\n+        for arm.pats.each |p| { check_pat(pcx, *p, pattern_ty);}\n         check_legality_of_move_bindings(fcx,\n                                         is_lvalue,\n                                         arm.guard.is_some(),\n@@ -58,7 +58,7 @@ fn check_legality_of_move_bindings(fcx: @fn_ctxt,\n     let mut by_ref = None;\n     let mut any_by_move = false;\n     for pats.each |pat| {\n-        do pat_util::pat_bindings(def_map, pat) |bm, _id, span, _path| {\n+        do pat_util::pat_bindings(def_map, *pat) |bm, _id, span, _path| {\n             match bm {\n                 ast::bind_by_ref(_) | ast::bind_by_implicit_ref => {\n                     by_ref = Some(span);\n@@ -73,7 +73,7 @@ fn check_legality_of_move_bindings(fcx: @fn_ctxt,\n \n     if !any_by_move { return; } // pointless micro-optimization\n     for pats.each |pat| {\n-        do walk_pat(pat) |p| {\n+        do walk_pat(*pat) |p| {\n             if !pat_is_variant(def_map, p) {\n                 match p.node {\n                     ast::pat_ident(ast::bind_by_move, _, sub) => {\n@@ -411,7 +411,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         }\n         let mut i = 0u;\n         for elts.each |elt| {\n-            check_pat(pcx, elt, ex_elts[i]);\n+            check_pat(pcx, *elt, ex_elts[i]);\n             i += 1u;\n         }\n "}, {"sha": "815101a14481528361233cb3976d0adce488fb5f", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -272,11 +272,11 @@ impl LookupContext {\n             for applicable_traits.each |trait_did| {\n                 let coherence_info = self.fcx.ccx.coherence_info;\n                 let opt_impl_infos =\n-                    coherence_info.extension_methods.find(trait_did);\n+                    coherence_info.extension_methods.find(*trait_did);\n                 for opt_impl_infos.each |impl_infos| {\n                     for impl_infos.each |impl_info| {\n                         self.push_candidates_from_impl(\n-                            &self.extension_candidates, impl_info);\n+                            &self.extension_candidates, *impl_info);\n                     }\n                 }\n             }\n@@ -414,7 +414,7 @@ impl LookupContext {\n         for opt_impl_infos.each |impl_infos| {\n             for impl_infos.each |impl_info| {\n                 self.push_candidates_from_impl(\n-                    &self.inherent_candidates, impl_info);\n+                    &self.inherent_candidates, *impl_info);\n             }\n         }\n     }\n@@ -633,7 +633,7 @@ impl LookupContext {\n         let region = self.infcx().next_region_var(self.expr.span,\n                                                   self.expr.id);\n         for mutbls.each |mutbl| {\n-            let autoref_ty = mk_autoref_ty(mutbl, region);\n+            let autoref_ty = mk_autoref_ty(*mutbl, region);\n             match self.search_for_method(autoref_ty) {\n                 None => {}\n                 Some(move mme) => {\n@@ -642,7 +642,7 @@ impl LookupContext {\n                         @{autoderefs: autoderefs,\n                           autoref: Some({kind: kind,\n                                          region: region,\n-                                         mutbl: mutbl})});\n+                                         mutbl: *mutbl})});\n                     return Some(mme);\n                 }\n             }"}, {"sha": "d8ea330ee11fb0c29fdd48bd41e1c537834c538c", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -199,7 +199,7 @@ fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n             }\n \n             for args.each |arg| {\n-                constrain_auto_ref(rcx, arg);\n+                constrain_auto_ref(rcx, *arg);\n             }\n         }\n "}, {"sha": "64065a5bd35eaaeebe95fd98e125e553b464d20f", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -33,7 +33,7 @@ fn replace_bound_regions_in_fn_ty(\n     }\n \n \n-    for self_ty.each |t| { vec::push(all_tys, t) }\n+    for self_ty.each |t| { vec::push(all_tys, *t) }\n \n     debug!(\"replace_bound_regions_in_fn_ty(self_info.self_ty=%?, fn_ty=%s, \\\n                 all_tys=%?)\","}, {"sha": "d48f5b9c070f9db2b1fcd2e1be6b25fa678382db", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -51,7 +51,7 @@ fn lookup_vtables(fcx: @fn_ctxt,\n             match *bound {\n               ty::bound_trait(i_ty) => {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n-                vec::push(result, lookup_vtable(fcx, expr, ty, i_ty,\n+                vec::push(result, lookup_vtable(fcx, expr, *ty, i_ty,\n                                                 allow_unsafe, is_early));\n               }\n               _ => ()"}, {"sha": "a70e5f600d35cdc82c4ef2f828a69de5707d4acb", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -36,7 +36,7 @@ fn resolve_method_map_entry(fcx: @fn_ctxt, sp: span, id: ast::node_id)\n             for resolve_type_vars_in_type(fcx, sp, mme.self_arg.ty).each |t| {\n                 fcx.ccx.method_map.insert(\n                     id,\n-                    {self_arg: {mode: mme.self_arg.mode, ty: t},\n+                    {self_arg: {mode: mme.self_arg.mode, ty: *t},\n                      ..*mme});\n             }\n         }\n@@ -93,7 +93,7 @@ fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n           Some(substs) => {\n             let mut new_tps = ~[];\n             for substs.tps.each |subst| {\n-                match resolve_type_vars_in_type(fcx, sp, subst) {\n+                match resolve_type_vars_in_type(fcx, sp, *subst) {\n                   Some(t) => vec::push(new_tps, t),\n                   None => { wbcx.success = false; return None; }\n                 }"}, {"sha": "17d5f81993dfadf3eadf68881e961d69f2ae85c2", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -178,7 +178,7 @@ impl CoherenceChecker {\n                                 trait `%s` with id %d\",\n                                 sess.str_of(item.ident), item.id);\n \n-                        match trait_method {\n+                        match *trait_method {\n                             required(_) => { /* fall through */}\n                             provided(m) => {\n                                 // For every provided method in the\n@@ -293,7 +293,7 @@ impl CoherenceChecker {\n \n         for associated_traits.each |associated_trait| {\n             let trait_did =\n-                self.trait_ref_to_trait_def_id(associated_trait);\n+                self.trait_ref_to_trait_def_id(*associated_trait);\n             debug!(\"(checking implementation) adding impl for trait \\\n                     '%s', item '%s'\",\n                     ast_map::node_id_to_str(\n@@ -547,7 +547,7 @@ impl CoherenceChecker {\n                     debug!(\n                         \"(creating impl) adding provided method `%s` to impl\",\n                         sess.str_of(provided_method.ident));\n-                    push(methods, provided_method);\n+                    push(methods, *provided_method);\n                 }\n             }\n \n@@ -560,7 +560,7 @@ impl CoherenceChecker {\n \n                 for ast_methods.each |ast_method| {\n                     push(methods,\n-                         method_to_MethodInfo(ast_method));\n+                         method_to_MethodInfo(*ast_method));\n                 }\n \n                 // For each trait that the impl implements, see what\n@@ -569,7 +569,8 @@ impl CoherenceChecker {\n                 // impl, use the provided definition in the trait.\n                 for trait_refs.each |trait_ref| {\n \n-                    let trait_did = self.trait_ref_to_trait_def_id(trait_ref);\n+                    let trait_did =\n+                        self.trait_ref_to_trait_def_id(*trait_ref);\n \n                     match self.crate_context.provided_methods_map\n                         .find(trait_did.node) {\n@@ -694,9 +695,9 @@ impl CoherenceChecker {\n \n             // Record all the trait methods.\n             for associated_traits.each |trait_type| {\n-                match get(trait_type).sty {\n+                match get(*trait_type).sty {\n                     ty_trait(trait_id, _, _) => {\n-                        self.add_trait_method(trait_id, implementation);\n+                        self.add_trait_method(trait_id, *implementation);\n                     }\n                     _ => {\n                         self.crate_context.tcx.sess.bug(~\"trait type \\\n@@ -718,7 +719,7 @@ impl CoherenceChecker {\n                 }\n                 Some(base_type_def_id) => {\n                     self.add_inherent_method(base_type_def_id,\n-                                             implementation);\n+                                             *implementation);\n \n                     self.base_type_def_ids.insert(implementation.did,\n                                                   base_type_def_id);"}, {"sha": "d984ca1a18ae4311ef51192b93a10c9c02bad10b", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -453,7 +453,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n \n         let cms = convert_methods(ccx, ms, rp, i_bounds);\n         for trait_ref.each |t| {\n-            check_methods_against_trait(ccx, tps, rp, selfty, t, cms);\n+            check_methods_against_trait(ccx, tps, rp, selfty, *t, cms);\n         }\n       }\n       ast::item_trait(tps, _, trait_methods) => {\n@@ -469,7 +469,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         // FIXME (#2616): something like this, when we start having\n         // trait inheritance?\n         // for trait_ref.each |t| {\n-        // check_methods_against_trait(ccx, tps, rp, selfty, t, cms);\n+        // check_methods_against_trait(ccx, tps, rp, selfty, *t, cms);\n         // }\n       }\n       ast::item_class(struct_def, tps) => {\n@@ -539,13 +539,13 @@ fn convert_struct(ccx: @crate_ctxt,\n \n     // Write the type of each of the members\n     for struct_def.fields.each |f| {\n-       convert_field(ccx, rp, tpt.bounds, f);\n+       convert_field(ccx, rp, tpt.bounds, *f);\n     }\n     let {bounds, substs} = mk_substs(ccx, tps, rp);\n     let selfty = ty::mk_class(tcx, local_def(id), substs);\n     let cms = convert_methods(ccx, struct_def.methods, rp, bounds);\n     for struct_def.traits.each |trait_ref| {\n-        check_methods_against_trait(ccx, tps, rp, selfty, trait_ref, cms);\n+        check_methods_against_trait(ccx, tps, rp, selfty, *trait_ref, cms);\n         // trait_ref.impl_id represents (class, trait) pair\n         write_ty_to_tcx(tcx, trait_ref.impl_id, tpt.ty);\n         tcx.tcache.insert(local_def(trait_ref.impl_id), tpt);"}, {"sha": "17af1fd565b118870a95a27de6b4e9faa154763e", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -286,7 +286,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         }\n         s += ~\"(\";\n         let mut strs = ~[];\n-        for inputs.each |a| { vec::push(strs, fn_input_to_str(cx, a)); }\n+        for inputs.each |a| { vec::push(strs, fn_input_to_str(cx, *a)); }\n         s += str::connect(strs, ~\", \");\n         s += ~\")\";\n         if ty::get(output).sty != ty_nil {\n@@ -311,7 +311,8 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     // if there is an id, print that instead of the structural type:\n     for ty::type_def_id(typ).each |def_id| {\n         // note that this typedef cannot have type parameters\n-        return ast_map::path_to_str(ty::item_path(cx, def_id),cx.sess.intr());\n+        return ast_map::path_to_str(ty::item_path(cx, *def_id),\n+                                    cx.sess.intr());\n     }\n \n     // pretty print the structural type representation:\n@@ -341,12 +342,12 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_type => ~\"type\",\n       ty_rec(elems) => {\n         let mut strs: ~[~str] = ~[];\n-        for elems.each |fld| { vec::push(strs, field_to_str(cx, fld)); }\n+        for elems.each |fld| { vec::push(strs, field_to_str(cx, *fld)); }\n         ~\"{\" + str::connect(strs, ~\",\") + ~\"}\"\n       }\n       ty_tup(elems) => {\n         let mut strs = ~[];\n-        for elems.each |elem| { vec::push(strs, ty_to_str(cx, elem)); }\n+        for elems.each |elem| { vec::push(strs, ty_to_str(cx, *elem)); }\n         ~\"(\" + str::connect(strs, ~\",\") + ~\")\"\n       }\n       ty_fn(ref f) => {"}, {"sha": "39971bc91e7515d569b50e5818467e654be774c7", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -347,8 +347,8 @@ fn write_mod_contents(\n         write_index(ctxt, option::get(doc.index));\n     }\n \n-    for doc.items.each |ItemTag| {\n-        write_item(ctxt, ItemTag);\n+    for doc.items.each |itemTag| {\n+        write_item(ctxt, *itemTag);\n     }\n }\n \n@@ -451,8 +451,8 @@ fn write_nmod(ctxt: Ctxt, doc: doc::NmodDoc) {\n     }\n \n     for doc.fns.each |FnDoc| {\n-        write_item_header(ctxt, doc::FnTag(FnDoc));\n-        write_fn(ctxt, FnDoc);\n+        write_item_header(ctxt, doc::FnTag(*FnDoc));\n+        write_fn(ctxt, *FnDoc);\n     }\n }\n "}, {"sha": "2a0118895362373f3e95d3bb43ba9222eea06582", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -95,7 +95,7 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     let mut sections = ~[];\n \n     for lines.each |line| {\n-        match parse_header(line) {\n+        match parse_header(*line) {\n           Some(header) => {\n             if option::is_some(current_section) {\n                 sections += ~[option::get(current_section)];\n@@ -109,17 +109,17 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n             match copy current_section {\n               Some(section) => {\n                 current_section = Some({\n-                    body: section.body + ~\"\\n\" + line,\n+                    body: section.body + ~\"\\n\" + *line,\n                     .. section\n                 });\n               }\n               None => {\n                 new_desc = match new_desc {\n                   Some(desc) => {\n-                    Some(desc + ~\"\\n\" + line)\n+                    Some(desc + ~\"\\n\" + *line)\n                   }\n                   None => {\n-                    Some(line)\n+                    Some(*line)\n                   }\n                 };\n               }"}, {"sha": "5e49a5488e9ed22fad24d5ed3965985700b099dd", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -123,9 +123,9 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n         let t = Q.pop_front();\n \n         do graph[t].each() |k| {\n-            if marks[k] == -1i64 {\n-                marks[k] = t;\n-                Q.add_back(k);\n+            if marks[*k] == -1i64 {\n+                marks[*k] = t;\n+                Q.add_back(*k);\n             }\n             true\n         };\n@@ -183,8 +183,8 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n                 let mut color = white;\n \n                 do neighbors.each() |k| {\n-                    if is_gray(colors[k]) {\n-                        color = gray(k);\n+                    if is_gray(colors[*k]) {\n+                        color = gray(*k);\n                         false\n                     }\n                     else { true }\n@@ -264,8 +264,8 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n                     let mut color = white;\n \n                     do neighbors.each() |k| {\n-                        if is_gray(colors[k]) {\n-                            color = gray(k);\n+                        if is_gray(colors[*k]) {\n+                            color = gray(*k);\n                             false\n                         }\n                         else { true }"}, {"sha": "ca76835dadd4495938aca6a46f70c4d964d19cd3", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -99,7 +99,7 @@ fn main(args: ~[~str]) {\n     thread_ring(0u, msg_per_task, option::unwrap(num_chan), num_port);\n \n     // synchronize\n-    for futures.each |f| { future::get(&f) };\n+    for futures.each |f| { future::get(f) };\n \n     let stop = time::precise_time_s();\n "}, {"sha": "9fa30af4bde99a1ac03d9bc2e9a2200ad1ccc0e3", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -96,7 +96,7 @@ fn main(args: ~[~str]) {\n     thread_ring(0u, msg_per_task, option::unwrap(num_chan), num_port);\n \n     // synchronize\n-    for futures.each |f| { future::get(&f) };\n+    for futures.each |f| { future::get(f) };\n \n     let stop = time::precise_time_s();\n "}, {"sha": "77e5d7c8b67e1c4d4708a8e11883d5e6667d454a", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -100,7 +100,7 @@ fn main(args: ~[~str]) {\n     thread_ring(0u, msg_per_task, option::unwrap(num_chan), num_port);\n \n     // synchronize\n-    for futures.each |f| { future::get(&f) };\n+    for futures.each |f| { future::get(f) };\n \n     let stop = time::precise_time_s();\n "}, {"sha": "bcdd77d015a71b2f55713033009e6268666a028c", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -46,14 +46,15 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n    });\n \n    let pairs_sorted = sortKV(pairs);\n-   \n+\n    let mut buffer = ~\"\";\n \n-   pairs_sorted.each(fn&(kv: (~[u8], float)) -> bool unsafe {\n-      let (k,v) = kv;\n-      buffer += (fmt!(\"%s %0.3f\\n\", str::to_upper(str::raw::from_bytes(k)), v));\n-      return true;\n-   });\n+   for pairs_sorted.each |kv| {\n+       let (k,v) = *kv;\n+       unsafe {\n+           buffer += (fmt!(\"%s %0.3f\\n\", str::to_upper(str::raw::from_bytes(k)), v));\n+       }\n+   }\n \n    return buffer;\n }"}, {"sha": "bc9d068094eb1c22a99fc5640be73a33defedf0c", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -43,14 +43,15 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n    });\n \n    let pairs_sorted = sortKV(pairs);\n-   \n+\n    let mut buffer = ~\"\";\n \n-   pairs_sorted.each(fn&(kv: (~[u8], float)) -> bool unsafe {\n-      let (k,v) = kv;\n-      buffer += (fmt!(\"%s %0.3f\\n\", str::to_upper(str::raw::from_bytes(k)), v));\n-      return true;\n-   });\n+   for pairs_sorted.each |kv| {\n+      let (k,v) = *kv;\n+      unsafe {\n+          buffer += (fmt!(\"%s %0.3f\\n\", str::to_upper(str::raw::from_bytes(k)), v));\n+      }\n+   }\n \n    return buffer;\n }"}, {"sha": "9740e5adc1d84818eb1fdbeab31aacc057b9719b", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -78,7 +78,7 @@ fn stress(num_tasks: int) {\n             stress_task(i);\n         }\n     }\n-    for results.each |r| { future::get(&r); }\n+    for results.each |r| { future::get(r); }\n }\n \n fn main(args: ~[~str]) {"}, {"sha": "b7d6e4769a0f01f295d4d725d92d51b7ea153f74", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -153,7 +153,8 @@ mod map_reduce {\n         for inputs.each |i| {\n             let (ctrl, ctrl_server) = ctrl_proto::init();\n             let ctrl = box(ctrl);\n-            vec::push(tasks, spawn_joinable(|| map_task(map, ctrl, i) ));\n+            let i = copy *i;\n+            vec::push(tasks, spawn_joinable(|move i| map_task(map, ctrl, i)));\n             vec::push(ctrls, ctrl_server);\n         }\n         return tasks;\n@@ -283,7 +284,7 @@ mod map_reduce {\n \n         for reducers.each_value |v| { send(v, done) }\n \n-        for tasks.each |t| { join(t); }\n+        for tasks.each |t| { join(*t); }\n     }\n }\n "}, {"sha": "eb8da1519e822d77567707b7564b77c808670e17", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -5,7 +5,7 @@ trait vec_monad<A> {\n impl<A> ~[A]: vec_monad<A> {\n     fn bind<B>(f: fn(A) -> ~[B]) {\n         let mut r = fail;\n-        for self.each |elt| { r += f(elt); }\n+        for self.each |elt| { r += f(*elt); }\n         //~^ WARNING unreachable expression\n         //~^^ ERROR the type of this value must be known\n    }"}, {"sha": "0d067eb0e15e8b36db5e8416822ff54efef2d2a4", "filename": "src/test/run-pass/argv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fargv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fargv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargv.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -1,5 +1,5 @@\n fn main(args: ~[~str]) {\n     let vs: ~[~str] = ~[~\"hi\", ~\"there\", ~\"this\", ~\"is\", ~\"a\", ~\"vec\"];\n     let vvs: ~[~[~str]] = ~[args, vs];\n-    for vvs.each |vs| { for vs.each |s| { log(debug, s); } }\n+    for vvs.each |vs| { for vs.each |s| { log(debug, *s); } }\n }"}, {"sha": "74a81d5b803ea4af409f67dcd5e88f99c0366a01", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -1,7 +1,7 @@\n // xfail-fast\n #[legacy_modes];\n \n-fn iter_vec<T>(v: ~[T], f: fn(T)) { for v.each |x| { f(x); } }\n+fn iter_vec<T>(v: ~[T], f: fn(T)) { for v.each |x| { f(*x); } }\n \n fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7];"}, {"sha": "6389ef0f644a03a32b706a66c0f7005079777ad6", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -1,7 +1,7 @@\n // xfail-fast\n #[legacy_modes];\n \n-fn iter_vec<T>(v: ~[T], f: fn(T)) { for v.each |x| { f(x); } }\n+fn iter_vec<T>(v: ~[T], f: fn(T)) { for v.each |x| { f(*x); } }\n \n fn main() {\n     let v = ~[1, 2, 3, 4, 5];"}, {"sha": "a8013c1514c6bd3e442f2c634ec8020918c2c3a1", "filename": "src/test/run-pass/borrowck-borrow-from-at-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -1,6 +1,6 @@\n fn sum_slice(x: &[int]) -> int {\n     let mut sum = 0;\n-    for x.each |i| { sum += i; }\n+    for x.each |i| { sum += *i; }\n     return sum;\n }\n "}, {"sha": "162c62803c3c833d2e30105a8ab1006b12abccd9", "filename": "src/test/run-pass/explicit-self-closures.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -6,13 +6,13 @@ struct Box {\n \n impl Box {\n     fn set_many(&mut self, xs: &[uint]) {\n-        for xs.each |x| { self.x = x; }\n+        for xs.each |x| { self.x = *x; }\n     }\n     fn set_many2(@mut self, xs: &[uint]) {\n-        for xs.each |x| { self.x = x; }\n+        for xs.each |x| { self.x = *x; }\n     }\n     fn set_many3(~mut self, xs: &[uint]) {\n-        for xs.each |x| { self.x = x; }\n+        for xs.each |x| { self.x = *x; }\n     }\n }\n "}, {"sha": "9e0727471e286200a9fbc7cb461239101789a68b", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -30,7 +30,8 @@ mod map_reduce {\n \n     fn start_mappers(ctrl: Chan<ctrl_proto>, inputs: ~[~str]) {\n         for inputs.each |i| {\n-            task::spawn(|| map_task(ctrl, i) );\n+            let i = *i;\n+            task::spawn(|move i| map_task(ctrl, i) );\n         }\n     }\n "}, {"sha": "ccb2c25b58d69eb57a689c31b68e082168dfbd80", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -3,7 +3,7 @@\n fn main() {\n     let x = ~[1, 2, 3];\n     let mut y = 0;\n-    for x.each |i| { log(debug, i); y += i; }\n+    for x.each |i| { log(debug, *i); y += *i; }\n     log(debug, y);\n     assert (y == 6);\n     let s = ~\"hello there\";"}, {"sha": "6ffbfa21ba4d22e82488cab02dc50c2a48e1f14f", "filename": "src/test/run-pass/loop-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Floop-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Floop-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-scope.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let x = ~[10, 20, 30];\n     let mut sum = 0;\n-    for x.each |x| { sum += x; }\n+    for x.each |x| { sum += *x; }\n     assert (sum == 60);\n }"}, {"sha": "0c2251a24199bae0018f3f786ce9f8e4804a903a", "filename": "src/test/run-pass/main-ivec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fmain-ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fmain-ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmain-ivec.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -1 +1 @@\n-fn main(args: ~[~str]) { for args.each |s| { log(debug, s); } }\n+fn main(args: ~[~str]) { for args.each |s| { log(debug, *s); } }"}, {"sha": "ddfc29fc8d8d340c7322aaf6abc7b725862c604e", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -8,7 +8,7 @@ trait vec_monad<A> {\n impl<A> ~[A]: vec_monad<A> {\n     fn bind<B: Copy>(f: fn(A) -> ~[B]) -> ~[B] {\n         let mut r = ~[];\n-        for self.each |elt| { r += f(elt); }\n+        for self.each |elt| { r += f(*elt); }\n         r\n     }\n }"}, {"sha": "deca22de6435a64fb7c7136bf5d05fadf2b998f1", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -52,8 +52,9 @@ fn main() {\n     ];\n     let rng = rand::Rng();\n     for fns.each |f| {\n+        let f = *f;\n         let sz = rng.next() % 256u32 + 256u32;\n         let frame_backoff = rng.next() % 10u32 + 1u32;\n-        task::try(|| runtest(f, frame_backoff) );\n+        task::try(|move f| runtest(f, frame_backoff) );\n     }\n }"}, {"sha": "affd0ef61625e759e137c0235847e9c12efeed8b", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -624,7 +624,7 @@ fn main() {\n     visit_tydesc(td, v);\n \n     for (copy u.vals).each |s| {\n-        io::println(fmt!(\"val: %s\", s));\n+        io::println(fmt!(\"val: %s\", *s));\n     }\n     error!(\"%?\", copy u.vals);\n     assert u.vals == ~[~\"1\", ~\"2\", ~\"3\", ~\"true\", ~\"false\", ~\"5\", ~\"4\", ~\"3\"];"}, {"sha": "750d13b87e28ea604a729ccc9f91498ccff730af", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -36,10 +36,10 @@ trait vec_utils<T> {\n \n impl<T> ~[T]: vec_utils<T> {\n     fn length_() -> uint { vec::len(self) }\n-    fn iter_(f: fn(T)) { for self.each |x| { f(x); } }\n+    fn iter_(f: fn(T)) { for self.each |x| { f(*x); } }\n     fn map_<U: Copy>(f: fn(T) -> U) -> ~[U] {\n         let mut r = ~[];\n-        for self.each |elt| { r += ~[f(elt)]; }\n+        for self.each |elt| { r += ~[f(*elt)]; }\n         r\n     }\n }"}, {"sha": "2619cc05586277ba5fecafaeed63218d798403bb", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -55,7 +55,7 @@ fn map<T, IT: BaseIter<T>, U, BU: buildable<U>>\n     (v: IT, f: fn(T) -> U) -> BU {\n     do build |push| {\n         for v.each() |elem| {\n-            push(f(elem));\n+            push(f(*elem));\n         }\n     }\n }"}, {"sha": "dd2dd5e54d469853abfdf5d2c66ebab702725cbb", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -32,7 +32,7 @@ fn test00() {\n     // Create and spawn tasks...\n     let mut results = ~[];\n     while i < number_of_tasks {\n-        let ch = po.chan();        \n+        let ch = po.chan();\n         do task::task().future_result(|+r| {\n             vec::push(results, r);\n         }).spawn |copy i| {\n@@ -53,7 +53,7 @@ fn test00() {\n     }\n \n     // Join spawned tasks...\n-    for results.each |r| { future::get(&r); }\n+    for results.each |r| { future::get(r); }\n \n     debug!(\"Completed: Final number is: \");\n     log(error, sum);"}, {"sha": "a3a6b6efd7f896b074d282dd6e7d9b26cd20113f", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -51,7 +51,7 @@ fn test00() {\n         while i < number_of_messages { sum += recv(po); i = i + 1; }\n     }\n \n-    for results.each |r| { future::get(&r); }\n+    for results.each |r| { future::get(r); }\n \n     debug!(\"Completed: Final number is: \");\n     assert (sum ==\n@@ -134,7 +134,7 @@ fn test06() {\n     }\n \n \n-    for results.each |r| { future::get(&r); }\n+    for results.each |r| { future::get(r); }\n }\n \n "}, {"sha": "83391d80e2617bdf602d17308a7f87a49dbef361", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfed923600e2f7ad34241501200d595abccdeb54/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=cfed923600e2f7ad34241501200d595abccdeb54", "patch": "@@ -20,7 +20,7 @@ trait map<T> {\n impl<T> ~[T]: map<T> {\n     fn map<U: Copy>(f: fn(T) -> U) -> ~[U] {\n         let mut r = ~[];\n-        for self.each |x| { r += ~[f(x)]; }\n+        for self.each |x| { r += ~[f(*x)]; }\n         r\n     }\n }"}]}