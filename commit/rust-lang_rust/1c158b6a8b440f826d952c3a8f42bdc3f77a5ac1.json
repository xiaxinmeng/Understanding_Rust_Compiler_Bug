{"sha": "1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMTU4YjZhOGI0NDBmODI2ZDk1MmMzYThmNDJiZGMzZjc3YTVhYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-07T04:45:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-07T04:45:12Z"}, "message": "Auto merge of #83833 - jyn514:no-resolver, r=GuillaumeGomez\n\nrustdoc: Store intra-doc links in Cache instead of on items directly\n\nItems are first built after rustdoc creates the TyCtxt. To allow\nresolving the links before the TyCtxt is built, the links can't be\nstored on `clean::Item` directly.\n\nHelps with https://github.com/rust-lang/rust/issues/83761. Opening this early because I think it might decrease memory usage.", "tree": {"sha": "a761b215e64d40ff400b48926c976cfe4999316a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a761b215e64d40ff400b48926c976cfe4999316a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1", "html_url": "https://github.com/rust-lang/rust/commit/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c53d2d40f9a1db8bad4da30a6b10d6fe9be6a1b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c53d2d40f9a1db8bad4da30a6b10d6fe9be6a1b2", "html_url": "https://github.com/rust-lang/rust/commit/c53d2d40f9a1db8bad4da30a6b10d6fe9be6a1b2"}, {"sha": "9e11902eff3b5bde80c4ac8e8d970f5f89ad818f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e11902eff3b5bde80c4ac8e8d970f5f89ad818f", "html_url": "https://github.com/rust-lang/rust/commit/9e11902eff3b5bde80c4ac8e8d970f5f89ad818f"}], "stats": {"total": 164, "additions": 82, "deletions": 82}, "files": [{"sha": "a5629fe1d1186b378d08d986710c7e9fd4153c66", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 64, "deletions": 73, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1", "patch": "@@ -195,7 +195,69 @@ impl Item {\n     }\n \n     crate fn links(&self, cache: &Cache) -> Vec<RenderedLink> {\n-        self.attrs.links(self.def_id.krate, cache)\n+        use crate::html::format::href;\n+        use crate::html::render::CURRENT_DEPTH;\n+\n+        cache\n+            .intra_doc_links\n+            .get(&self.def_id)\n+            .map_or(&[][..], |v| v.as_slice())\n+            .iter()\n+            .filter_map(|ItemLink { link: s, link_text, did, fragment }| {\n+                match *did {\n+                    Some(did) => {\n+                        if let Some((mut href, ..)) = href(did, cache) {\n+                            if let Some(ref fragment) = *fragment {\n+                                href.push('#');\n+                                href.push_str(fragment);\n+                            }\n+                            Some(RenderedLink {\n+                                original_text: s.clone(),\n+                                new_text: link_text.clone(),\n+                                href,\n+                            })\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    None => {\n+                        if let Some(ref fragment) = *fragment {\n+                            let url = match cache.extern_locations.get(&self.def_id.krate) {\n+                                Some(&(_, _, ExternalLocation::Local)) => {\n+                                    let depth = CURRENT_DEPTH.with(|l| l.get());\n+                                    \"../\".repeat(depth)\n+                                }\n+                                Some(&(_, _, ExternalLocation::Remote(ref s))) => s.to_string(),\n+                                Some(&(_, _, ExternalLocation::Unknown)) | None => String::from(\n+                                    // NOTE: intentionally doesn't pass crate name to avoid having\n+                                    // different primitive links between crates\n+                                    if UnstableFeatures::from_environment(None).is_nightly_build() {\n+                                        \"https://doc.rust-lang.org/nightly\"\n+                                    } else {\n+                                        \"https://doc.rust-lang.org\"\n+                                    },\n+                                ),\n+                            };\n+                            // This is a primitive so the url is done \"by hand\".\n+                            let tail = fragment.find('#').unwrap_or_else(|| fragment.len());\n+                            Some(RenderedLink {\n+                                original_text: s.clone(),\n+                                new_text: link_text.clone(),\n+                                href: format!(\n+                                    \"{}{}std/primitive.{}.html{}\",\n+                                    url,\n+                                    if !url.ends_with('/') { \"/\" } else { \"\" },\n+                                    &fragment[..tail],\n+                                    &fragment[tail..]\n+                                ),\n+                            })\n+                        } else {\n+                            panic!(\"This isn't a primitive?!\");\n+                        }\n+                    }\n+                }\n+            })\n+            .collect()\n     }\n \n     crate fn is_crate(&self) -> bool {\n@@ -572,15 +634,13 @@ crate struct Attributes {\n     crate other_attrs: Vec<ast::Attribute>,\n     crate cfg: Option<Arc<Cfg>>,\n     crate span: Option<rustc_span::Span>,\n-    /// map from Rust paths to resolved defs and potential URL fragments\n-    crate links: Vec<ItemLink>,\n     crate inner_docs: bool,\n }\n \n #[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\n /// A link that has not yet been rendered.\n ///\n-/// This link will be turned into a rendered link by [`Attributes::links`]\n+/// This link will be turned into a rendered link by [`Item::links`].\n crate struct ItemLink {\n     /// The original link written in the markdown\n     pub(crate) link: String,\n@@ -806,7 +866,6 @@ impl Attributes {\n             other_attrs,\n             cfg: if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) },\n             span: sp,\n-            links: vec![],\n             inner_docs,\n         }\n     }\n@@ -850,72 +909,6 @@ impl Attributes {\n         if self.doc_strings.is_empty() { None } else { Some(self.doc_strings.iter().collect()) }\n     }\n \n-    /// Gets links as a vector\n-    ///\n-    /// Cache must be populated before call\n-    crate fn links(&self, krate: CrateNum, cache: &Cache) -> Vec<RenderedLink> {\n-        use crate::html::format::href;\n-        use crate::html::render::CURRENT_DEPTH;\n-\n-        self.links\n-            .iter()\n-            .filter_map(|ItemLink { link: s, link_text, did, fragment }| {\n-                match *did {\n-                    Some(did) => {\n-                        if let Some((mut href, ..)) = href(did, cache) {\n-                            if let Some(ref fragment) = *fragment {\n-                                href.push('#');\n-                                href.push_str(fragment);\n-                            }\n-                            Some(RenderedLink {\n-                                original_text: s.clone(),\n-                                new_text: link_text.clone(),\n-                                href,\n-                            })\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                    None => {\n-                        if let Some(ref fragment) = *fragment {\n-                            let url = match cache.extern_locations.get(&krate) {\n-                                Some(&(_, _, ExternalLocation::Local)) => {\n-                                    let depth = CURRENT_DEPTH.with(|l| l.get());\n-                                    \"../\".repeat(depth)\n-                                }\n-                                Some(&(_, _, ExternalLocation::Remote(ref s))) => s.to_string(),\n-                                Some(&(_, _, ExternalLocation::Unknown)) | None => String::from(\n-                                    // NOTE: intentionally doesn't pass crate name to avoid having\n-                                    // different primitive links between crates\n-                                    if UnstableFeatures::from_environment(None).is_nightly_build() {\n-                                        \"https://doc.rust-lang.org/nightly\"\n-                                    } else {\n-                                        \"https://doc.rust-lang.org\"\n-                                    },\n-                                ),\n-                            };\n-                            // This is a primitive so the url is done \"by hand\".\n-                            let tail = fragment.find('#').unwrap_or_else(|| fragment.len());\n-                            Some(RenderedLink {\n-                                original_text: s.clone(),\n-                                new_text: link_text.clone(),\n-                                href: format!(\n-                                    \"{}{}std/primitive.{}.html{}\",\n-                                    url,\n-                                    if !url.ends_with('/') { \"/\" } else { \"\" },\n-                                    &fragment[..tail],\n-                                    &fragment[tail..]\n-                                ),\n-                            })\n-                        } else {\n-                            panic!(\"This isn't a primitive?!\");\n-                        }\n-                    }\n-                }\n-            })\n-            .collect()\n-    }\n-\n     crate fn get_doc_aliases(&self) -> Box<[String]> {\n         let mut aliases = FxHashSet::default();\n \n@@ -942,7 +935,6 @@ impl PartialEq for Attributes {\n         self.doc_strings == rhs.doc_strings\n             && self.cfg == rhs.cfg\n             && self.span == rhs.span\n-            && self.links == rhs.links\n             && self\n                 .other_attrs\n                 .iter()\n@@ -958,7 +950,6 @@ impl Hash for Attributes {\n         self.doc_strings.hash(hasher);\n         self.cfg.hash(hasher);\n         self.span.hash(hasher);\n-        self.links.hash(hasher);\n         for attr in &self.other_attrs {\n             attr.id.hash(hasher);\n         }"}, {"sha": "b2b895cc6726e150ca2fde05d928ba41beb5a6e4", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1", "patch": "@@ -120,6 +120,11 @@ crate struct Cache {\n     // when gathering trait documentation on a type, hold impls here while\n     // folding and add them to the cache later on if we find the trait.\n     orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n+\n+    /// All intra-doc links resolved so far.\n+    ///\n+    /// Links are indexed by the DefId of the item they document.\n+    crate intra_doc_links: BTreeMap<DefId, Vec<clean::ItemLink>>,\n }\n \n /// This struct is used to wrap the `cache` and `tcx` in order to run `DocFolder`."}, {"sha": "10d5b9807b0104b3933347bc544a1cbaf2773f90", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1", "patch": "@@ -24,6 +24,16 @@ use std::collections::HashSet;\n impl JsonRenderer<'_> {\n     pub(super) fn convert_item(&self, item: clean::Item) -> Option<Item> {\n         let deprecation = item.deprecation(self.tcx);\n+        let links = self\n+            .cache\n+            .intra_doc_links\n+            .get(&item.def_id)\n+            .into_iter()\n+            .flatten()\n+            .filter_map(|clean::ItemLink { link, did, .. }| {\n+                did.map(|did| (link.clone(), from_def_id(did)))\n+            })\n+            .collect();\n         let clean::Item { span, name, attrs, kind, visibility, def_id } = item;\n         let inner = match *kind {\n             clean::StrippedItem(_) => return None,\n@@ -36,20 +46,14 @@ impl JsonRenderer<'_> {\n             span: self.convert_span(span),\n             visibility: self.convert_visibility(visibility),\n             docs: attrs.collapsed_doc_value(),\n-            links: attrs\n-                .links\n-                .into_iter()\n-                .filter_map(|clean::ItemLink { link, did, .. }| {\n-                    did.map(|did| (link, from_def_id(did)))\n-                })\n-                .collect(),\n             attrs: attrs\n                 .other_attrs\n                 .iter()\n                 .map(rustc_ast_pretty::pprust::attribute_to_string)\n                 .collect(),\n             deprecation: deprecation.map(from_deprecation),\n             inner,\n+            links,\n         })\n     }\n "}, {"sha": "31e3c11c1b087b0a0af251896a6f5cccb6b7206a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1", "patch": "@@ -788,7 +788,7 @@ fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_\n }\n \n impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n-    fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n+    fn fold_item(&mut self, item: Item) -> Option<Item> {\n         use rustc_middle::ty::DefIdTree;\n \n         let parent_node = if item.is_fake() {\n@@ -873,7 +873,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             for md_link in markdown_links(&doc) {\n                 let link = self.resolve_link(&item, &doc, &self_name, parent_node, krate, md_link);\n                 if let Some(link) = link {\n-                    item.attrs.links.push(link);\n+                    self.cx.cache.intra_doc_links.entry(item.def_id).or_default().push(link);\n                 }\n             }\n         }"}]}