{"sha": "d63e1cebff771621b90bdce25ac013eecb415e1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2M2UxY2ViZmY3NzE2MjFiOTBiZGNlMjVhYzAxM2VlY2I0MTVlMWU=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2019-01-25T17:39:35Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T08:46:37Z"}, "message": "use `Roots` in watcher", "tree": {"sha": "b4b83981fb7734d036be1dc4e9385a9c6e71e6ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4b83981fb7734d036be1dc4e9385a9c6e71e6ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d63e1cebff771621b90bdce25ac013eecb415e1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d63e1cebff771621b90bdce25ac013eecb415e1e", "html_url": "https://github.com/rust-lang/rust/commit/d63e1cebff771621b90bdce25ac013eecb415e1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d63e1cebff771621b90bdce25ac013eecb415e1e/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86fadbd4e59f12535edcc280ec227d7ee8a0848d", "url": "https://api.github.com/repos/rust-lang/rust/commits/86fadbd4e59f12535edcc280ec227d7ee8a0848d", "html_url": "https://github.com/rust-lang/rust/commit/86fadbd4e59f12535edcc280ec227d7ee8a0848d"}], "stats": {"total": 604, "additions": 274, "deletions": 330}, "files": [{"sha": "7ca1e983586b5ecfacca281fe1e8ade8b328c25b", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 51, "deletions": 149, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/d63e1cebff771621b90bdce25ac013eecb415e1e/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63e1cebff771621b90bdce25ac013eecb415e1e/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=d63e1cebff771621b90bdce25ac013eecb415e1e", "patch": "@@ -1,95 +1,72 @@\n-use std::{\n-    fmt, fs,\n-    path::{Path, PathBuf},\n-    sync::Arc,\n-    thread,\n-};\n+use std::{fs, sync::Arc, thread};\n \n use crossbeam_channel::{Receiver, Sender};\n-use parking_lot::Mutex;\n use relative_path::RelativePathBuf;\n use thread_worker::WorkerHandle;\n use walkdir::WalkDir;\n \n mod watcher;\n use watcher::Watcher;\n-pub use watcher::WatcherChange;\n \n-use crate::{RootFilter, VfsRoot};\n+use crate::{RootFilter, Roots, VfsRoot};\n \n pub(crate) enum Task {\n     AddRoot {\n         root: VfsRoot,\n-        path: PathBuf,\n-        root_filter: Arc<RootFilter>,\n-        nested_roots: Vec<PathBuf>,\n-    },\n-    /// this variant should only be created by the watcher\n-    HandleChange(WatcherChange),\n-    LoadChange(WatcherChange),\n-    Watch {\n-        dir: PathBuf,\n-        root_filter: Arc<RootFilter>,\n+        filter: Arc<RootFilter>,\n     },\n }\n \n #[derive(Debug)]\n-pub struct AddRootResult {\n-    pub(crate) root: VfsRoot,\n-    pub(crate) files: Vec<(RelativePathBuf, String)>,\n-}\n-\n-#[derive(Debug)]\n-pub enum WatcherChangeData {\n-    Create { path: PathBuf, text: String },\n-    Write { path: PathBuf, text: String },\n-    Remove { path: PathBuf },\n-}\n-\n pub enum TaskResult {\n-    AddRoot(AddRootResult),\n-    HandleChange(WatcherChange),\n-    LoadChange(WatcherChangeData),\n-}\n-\n-impl fmt::Debug for TaskResult {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self {\n-            TaskResult::AddRoot(..) => f.write_str(\"TaskResult::AddRoot(..)\"),\n-            TaskResult::HandleChange(c) => write!(f, \"TaskResult::HandleChange({:?})\", c),\n-            TaskResult::LoadChange(c) => write!(f, \"TaskResult::LoadChange({:?})\", c),\n-        }\n-    }\n+    BulkLoadRoot {\n+        root: VfsRoot,\n+        files: Vec<(RelativePathBuf, String)>,\n+    },\n+    AddSingleFile {\n+        root: VfsRoot,\n+        path: RelativePathBuf,\n+        text: String,\n+    },\n+    ChangeSingleFile {\n+        root: VfsRoot,\n+        path: RelativePathBuf,\n+        text: String,\n+    },\n+    RemoveSingleFile {\n+        root: VfsRoot,\n+        path: RelativePathBuf,\n+    },\n }\n \n pub(crate) struct Worker {\n     worker: thread_worker::Worker<Task, TaskResult>,\n     worker_handle: WorkerHandle,\n-    watcher: Arc<Mutex<Option<Watcher>>>,\n }\n \n impl Worker {\n-    pub(crate) fn start() -> Worker {\n-        let watcher = Arc::new(Mutex::new(None));\n-        let watcher_clone = watcher.clone();\n+    pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n         let (worker, worker_handle) =\n             thread_worker::spawn(\"vfs\", 128, move |input_receiver, output_sender| {\n-                input_receiver\n+                let mut watcher = match Watcher::start(roots, output_sender.clone()) {\n+                    Ok(w) => Some(w),\n+                    Err(e) => {\n+                        log::error!(\"could not start watcher: {}\", e);\n+                        None\n+                    }\n+                };\n+                let res = input_receiver\n                     .into_iter()\n-                    .filter_map(|t| handle_task(t, &watcher_clone))\n-                    .try_for_each(|it| output_sender.send(it))\n-                    .unwrap()\n+                    .filter_map(|t| handle_task(t, &mut watcher))\n+                    .try_for_each(|it| output_sender.send(it));\n+                if let Some(watcher) = watcher {\n+                    let _ = watcher.shutdown();\n+                }\n+                res.unwrap()\n             });\n-        match Watcher::start(worker.inp.clone()) {\n-            Ok(w) => {\n-                watcher.lock().replace(w);\n-            }\n-            Err(e) => log::error!(\"could not start watcher: {}\", e),\n-        };\n         Worker {\n             worker,\n             worker_handle,\n-            watcher,\n         }\n     }\n \n@@ -102,72 +79,31 @@ impl Worker {\n     }\n \n     pub(crate) fn shutdown(self) -> thread::Result<()> {\n-        if let Some(watcher) = self.watcher.lock().take() {\n-            let _ = watcher.shutdown();\n-        }\n         let _ = self.worker.shutdown();\n         self.worker_handle.shutdown()\n     }\n }\n \n-fn watch(\n-    watcher: &Arc<Mutex<Option<Watcher>>>,\n-    dir: &Path,\n-    filter_entry: &RootFilter,\n-    emit_for_existing: bool,\n-) {\n-    if let Some(watcher) = watcher.lock().as_mut() {\n-        watcher.watch_recursive(dir, filter_entry, emit_for_existing)\n-    }\n-}\n-\n-fn handle_task(task: Task, watcher: &Arc<Mutex<Option<Watcher>>>) -> Option<TaskResult> {\n+fn handle_task(task: Task, watcher: &mut Option<Watcher>) -> Option<TaskResult> {\n     match task {\n-        Task::AddRoot {\n-            root,\n-            path,\n-            root_filter,\n-            nested_roots,\n-        } => {\n-            watch(watcher, &path, root_filter.as_ref(), false);\n-            log::debug!(\"loading {} ...\", path.as_path().display());\n-            let files = load_root(\n-                path.as_path(),\n-                root_filter.as_ref(),\n-                nested_roots.as_slice(),\n-            );\n-            log::debug!(\"... loaded {}\", path.as_path().display());\n-            Some(TaskResult::AddRoot(AddRootResult { root, files }))\n-        }\n-        Task::HandleChange(change) => {\n-            // forward as is because Vfs has to decide if we should load it\n-            Some(TaskResult::HandleChange(change))\n-        }\n-        Task::LoadChange(change) => {\n-            log::debug!(\"loading {:?} ...\", change);\n-            load_change(change).map(TaskResult::LoadChange)\n-        }\n-        Task::Watch { dir, root_filter } => {\n-            watch(watcher, &dir, root_filter.as_ref(), true);\n-            None\n+        Task::AddRoot { root, filter } => {\n+            if let Some(watcher) = watcher {\n+                watcher.watch_root(&filter)\n+            }\n+            log::debug!(\"loading {} ...\", filter.root.as_path().display());\n+            let files = load_root(filter.as_ref());\n+            log::debug!(\"... loaded {}\", filter.root.as_path().display());\n+            Some(TaskResult::BulkLoadRoot { root, files })\n         }\n     }\n }\n \n-fn load_root(\n-    root: &Path,\n-    root_filter: &RootFilter,\n-    nested_roots: &[PathBuf],\n-) -> Vec<(RelativePathBuf, String)> {\n+fn load_root(filter: &RootFilter) -> Vec<(RelativePathBuf, String)> {\n     let mut res = Vec::new();\n-    for entry in WalkDir::new(root).into_iter().filter_entry(|entry| {\n-        if entry.file_type().is_dir() && nested_roots.iter().any(|it| it == entry.path()) {\n-            // do not load files of a nested root\n-            false\n-        } else {\n-            root_filter.can_contain(entry.path()).is_some()\n-        }\n-    }) {\n+    for entry in WalkDir::new(&filter.root)\n+        .into_iter()\n+        .filter_entry(filter.entry_filter())\n+    {\n         let entry = match entry {\n             Ok(entry) => entry,\n             Err(e) => {\n@@ -186,42 +122,8 @@ fn load_root(\n                 continue;\n             }\n         };\n-        let path = RelativePathBuf::from_path(path.strip_prefix(root).unwrap()).unwrap();\n+        let path = RelativePathBuf::from_path(path.strip_prefix(&filter.root).unwrap()).unwrap();\n         res.push((path.to_owned(), text))\n     }\n     res\n }\n-\n-fn load_change(change: WatcherChange) -> Option<WatcherChangeData> {\n-    let data = match change {\n-        WatcherChange::Create(path) => {\n-            if path.is_dir() {\n-                return None;\n-            }\n-            let text = match fs::read_to_string(&path) {\n-                Ok(text) => text,\n-                Err(e) => {\n-                    log::warn!(\"watcher error \\\"{}\\\": {}\", path.display(), e);\n-                    return None;\n-                }\n-            };\n-            WatcherChangeData::Create { path, text }\n-        }\n-        WatcherChange::Write(path) => {\n-            let text = match fs::read_to_string(&path) {\n-                Ok(text) => text,\n-                Err(e) => {\n-                    log::warn!(\"watcher error \\\"{}\\\": {}\", path.display(), e);\n-                    return None;\n-                }\n-            };\n-            WatcherChangeData::Write { path, text }\n-        }\n-        WatcherChange::Remove(path) => WatcherChangeData::Remove { path },\n-        WatcherChange::Rescan => {\n-            // this should be handled by Vfs::handle_task\n-            return None;\n-        }\n-    };\n-    Some(data)\n-}"}, {"sha": "1d7ce213670e6805119f257161b8385b4b868c88", "filename": "crates/ra_vfs/src/io/watcher.rs", "status": "modified", "additions": 141, "deletions": 74, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/d63e1cebff771621b90bdce25ac013eecb415e1e/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63e1cebff771621b90bdce25ac013eecb415e1e/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs?ref=d63e1cebff771621b90bdce25ac013eecb415e1e", "patch": "@@ -1,118 +1,72 @@\n-use crate::{io, RootFilter};\n+use crate::{io, RootFilter, Roots, VfsRoot};\n use crossbeam_channel::Sender;\n use drop_bomb::DropBomb;\n use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as NotifyWatcher};\n+use parking_lot::Mutex;\n use std::{\n+    fs,\n     path::{Path, PathBuf},\n-    sync::mpsc,\n+    sync::{mpsc, Arc},\n     thread,\n     time::Duration,\n };\n use walkdir::WalkDir;\n \n #[derive(Debug)]\n-pub enum WatcherChange {\n-    Create(PathBuf),\n-    Write(PathBuf),\n-    Remove(PathBuf),\n-    Rescan,\n-}\n-\n-fn handle_change_event(\n-    ev: DebouncedEvent,\n-    sender: &Sender<io::Task>,\n-) -> Result<(), Box<std::error::Error>> {\n-    match ev {\n-        DebouncedEvent::NoticeWrite(_)\n-        | DebouncedEvent::NoticeRemove(_)\n-        | DebouncedEvent::Chmod(_) => {\n-            // ignore\n-        }\n-        DebouncedEvent::Rescan => {\n-            sender.send(io::Task::HandleChange(WatcherChange::Rescan))?;\n-        }\n-        DebouncedEvent::Create(path) => {\n-            sender.send(io::Task::HandleChange(WatcherChange::Create(path)))?;\n-        }\n-        DebouncedEvent::Write(path) => {\n-            sender.send(io::Task::HandleChange(WatcherChange::Write(path)))?;\n-        }\n-        DebouncedEvent::Remove(path) => {\n-            sender.send(io::Task::HandleChange(WatcherChange::Remove(path)))?;\n-        }\n-        DebouncedEvent::Rename(src, dst) => {\n-            sender.send(io::Task::HandleChange(WatcherChange::Remove(src)))?;\n-            sender.send(io::Task::HandleChange(WatcherChange::Create(dst)))?;\n-        }\n-        DebouncedEvent::Error(err, path) => {\n-            // TODO should we reload the file contents?\n-            log::warn!(\"watcher error \\\"{}\\\", {:?}\", err, path);\n-        }\n-    }\n-    Ok(())\n+enum ChangeKind {\n+    Create,\n+    Write,\n+    Remove,\n }\n \n const WATCHER_DELAY: Duration = Duration::from_millis(250);\n \n pub(crate) struct Watcher {\n-    watcher: RecommendedWatcher,\n     thread: thread::JoinHandle<()>,\n     bomb: DropBomb,\n-    sender: Sender<io::Task>,\n+    watcher: Arc<Mutex<Option<RecommendedWatcher>>>,\n }\n \n impl Watcher {\n     pub(crate) fn start(\n-        output_sender: Sender<io::Task>,\n+        roots: Arc<Roots>,\n+        output_sender: Sender<io::TaskResult>,\n     ) -> Result<Watcher, Box<std::error::Error>> {\n         let (input_sender, input_receiver) = mpsc::channel();\n-        let watcher = notify::watcher(input_sender, WATCHER_DELAY)?;\n+        let watcher = Arc::new(Mutex::new(Some(notify::watcher(\n+            input_sender,\n+            WATCHER_DELAY,\n+        )?)));\n         let sender = output_sender.clone();\n+        let watcher_clone = watcher.clone();\n         let thread = thread::spawn(move || {\n+            let worker = WatcherWorker {\n+                roots,\n+                watcher: watcher_clone,\n+                sender,\n+            };\n             input_receiver\n                 .into_iter()\n                 // forward relevant events only\n-                .try_for_each(|change| handle_change_event(change, &output_sender))\n+                .try_for_each(|change| worker.handle_debounced_event(change))\n                 .unwrap()\n         });\n         Ok(Watcher {\n-            watcher,\n             thread,\n-            sender,\n+            watcher,\n             bomb: DropBomb::new(format!(\"Watcher was not shutdown\")),\n         })\n     }\n \n-    pub fn watch_recursive(&mut self, dir: &Path, filter: &RootFilter, emit_for_contents: bool) {\n-        for res in WalkDir::new(dir)\n+    pub fn watch_root(&mut self, filter: &RootFilter) {\n+        for res in WalkDir::new(&filter.root)\n             .into_iter()\n-            .filter_entry(|entry| filter.can_contain(entry.path()).is_some())\n+            .filter_entry(filter.entry_filter())\n         {\n             match res {\n                 Ok(entry) => {\n                     if entry.path().is_dir() {\n-                        match self\n-                            .watcher\n-                            .watch(entry.path(), RecursiveMode::NonRecursive)\n-                        {\n-                            Ok(()) => log::debug!(\"watching \\\"{}\\\"\", entry.path().display()),\n-                            Err(e) => {\n-                                log::warn!(\"could not watch \\\"{}\\\": {}\", entry.path().display(), e)\n-                            }\n-                        }\n-                    } else {\n-                        if emit_for_contents && entry.depth() > 0 {\n-                            // emit only for files otherwise we will cause watch_recursive to be called again with a dir that we are already watching\n-                            // emit as create because we haven't seen it yet\n-                            if let Err(e) =\n-                                self.sender\n-                                    .send(io::Task::HandleChange(WatcherChange::Create(\n-                                        entry.path().to_path_buf(),\n-                                    )))\n-                            {\n-                                log::warn!(\"watcher error: {}\", e)\n-                            }\n-                        }\n+                        watch_one(self.watcher.as_ref(), entry.path());\n                     }\n                 }\n                 Err(e) => log::warn!(\"watcher error: {}\", e),\n@@ -122,7 +76,7 @@ impl Watcher {\n \n     pub fn shutdown(mut self) -> thread::Result<()> {\n         self.bomb.defuse();\n-        drop(self.watcher);\n+        drop(self.watcher.lock().take());\n         let res = self.thread.join();\n         match &res {\n             Ok(()) => log::info!(\"... Watcher terminated with ok\"),\n@@ -131,3 +85,116 @@ impl Watcher {\n         res\n     }\n }\n+\n+struct WatcherWorker {\n+    watcher: Arc<Mutex<Option<RecommendedWatcher>>>,\n+    roots: Arc<Roots>,\n+    sender: Sender<io::TaskResult>,\n+}\n+\n+impl WatcherWorker {\n+    fn handle_debounced_event(&self, ev: DebouncedEvent) -> Result<(), Box<std::error::Error>> {\n+        match ev {\n+            DebouncedEvent::NoticeWrite(_)\n+            | DebouncedEvent::NoticeRemove(_)\n+            | DebouncedEvent::Chmod(_) => {\n+                // ignore\n+            }\n+            DebouncedEvent::Rescan => {\n+                // TODO rescan all roots\n+            }\n+            DebouncedEvent::Create(path) => {\n+                self.handle_change(path, ChangeKind::Create);\n+            }\n+            DebouncedEvent::Write(path) => {\n+                self.handle_change(path, ChangeKind::Write);\n+            }\n+            DebouncedEvent::Remove(path) => {\n+                self.handle_change(path, ChangeKind::Remove);\n+            }\n+            DebouncedEvent::Rename(src, dst) => {\n+                self.handle_change(src, ChangeKind::Remove);\n+                self.handle_change(dst, ChangeKind::Create);\n+            }\n+            DebouncedEvent::Error(err, path) => {\n+                // TODO should we reload the file contents?\n+                log::warn!(\"watcher error \\\"{}\\\", {:?}\", err, path);\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn handle_change(&self, path: PathBuf, kind: ChangeKind) {\n+        if let Err(e) = self.try_handle_change(path, kind) {\n+            log::warn!(\"watcher error: {}\", e)\n+        }\n+    }\n+\n+    fn try_handle_change(\n+        &self,\n+        path: PathBuf,\n+        kind: ChangeKind,\n+    ) -> Result<(), Box<std::error::Error>> {\n+        let (root, rel_path) = match self.roots.find(&path) {\n+            Some(x) => x,\n+            None => return Ok(()),\n+        };\n+        match kind {\n+            ChangeKind::Create => {\n+                if path.is_dir() {\n+                    self.watch_recursive(&path, root);\n+                } else {\n+                    let text = fs::read_to_string(&path)?;\n+                    self.sender.send(io::TaskResult::AddSingleFile {\n+                        root,\n+                        path: rel_path,\n+                        text,\n+                    })?\n+                }\n+            }\n+            ChangeKind::Write => {\n+                let text = fs::read_to_string(&path)?;\n+                self.sender.send(io::TaskResult::ChangeSingleFile {\n+                    root,\n+                    path: rel_path,\n+                    text,\n+                })?\n+            }\n+            ChangeKind::Remove => self.sender.send(io::TaskResult::RemoveSingleFile {\n+                root,\n+                path: rel_path,\n+            })?,\n+        }\n+        Ok(())\n+    }\n+\n+    fn watch_recursive(&self, dir: &Path, root: VfsRoot) {\n+        let filter = &self.roots[root];\n+        for res in WalkDir::new(dir)\n+            .into_iter()\n+            .filter_entry(|entry| filter.can_contain(entry.path()).is_some())\n+        {\n+            match res {\n+                Ok(entry) => {\n+                    if entry.path().is_dir() {\n+                        watch_one(self.watcher.as_ref(), entry.path());\n+                    } else {\n+                        // emit only for files otherwise we will cause watch_recursive to be called again with a dir that we are already watching\n+                        // emit as create because we haven't seen it yet\n+                        self.handle_change(entry.path().to_path_buf(), ChangeKind::Create);\n+                    }\n+                }\n+                Err(e) => log::warn!(\"watcher error: {}\", e),\n+            }\n+        }\n+    }\n+}\n+\n+fn watch_one(watcher: &Mutex<Option<RecommendedWatcher>>, dir: &Path) {\n+    if let Some(watcher) = watcher.lock().as_mut() {\n+        match watcher.watch(dir, RecursiveMode::NonRecursive) {\n+            Ok(()) => log::debug!(\"watching \\\"{}\\\"\", dir.display()),\n+            Err(e) => log::warn!(\"could not watch \\\"{}\\\": {}\", dir.display(), e),\n+        }\n+    }\n+}"}, {"sha": "661892f8a25f1ba78aeed1b345828f0a15d24bd2", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 70, "deletions": 98, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/d63e1cebff771621b90bdce25ac013eecb415e1e/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63e1cebff771621b90bdce25ac013eecb415e1e/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=d63e1cebff771621b90bdce25ac013eecb415e1e", "patch": "@@ -28,22 +28,25 @@ use crossbeam_channel::Receiver;\n use ra_arena::{impl_arena_id, Arena, RawId};\n use relative_path::{Component, RelativePath, RelativePathBuf};\n use rustc_hash::{FxHashMap, FxHashSet};\n+use walkdir::DirEntry;\n \n pub use crate::io::TaskResult as VfsTask;\n-use io::{Task, TaskResult, WatcherChange, WatcherChangeData, Worker};\n+use io::{TaskResult, Worker};\n \n /// `RootFilter` is a predicate that checks if a file can belong to a root. If\n /// several filters match a file (nested dirs), the most nested one wins.\n pub(crate) struct RootFilter {\n     root: PathBuf,\n     filter: fn(&Path, &RelativePath) -> bool,\n+    excluded_dirs: Vec<PathBuf>,\n }\n \n impl RootFilter {\n-    fn new(root: PathBuf) -> RootFilter {\n+    fn new(root: PathBuf, excluded_dirs: Vec<PathBuf>) -> RootFilter {\n         RootFilter {\n             root,\n             filter: default_filter,\n+            excluded_dirs,\n         }\n     }\n     /// Check if this root can contain `path`. NB: even if this returns\n@@ -56,6 +59,17 @@ impl RootFilter {\n         }\n         Some(rel_path)\n     }\n+\n+    pub(crate) fn entry_filter<'a>(&'a self) -> impl FnMut(&DirEntry) -> bool + 'a {\n+        move |entry: &DirEntry| {\n+            if entry.path().is_dir() && self.excluded_dirs.iter().any(|it| it == entry.path()) {\n+                // do not walk nested roots\n+                false\n+            } else {\n+                self.can_contain(entry.path()).is_some()\n+            }\n+        }\n+    }\n }\n \n pub(crate) fn default_filter(path: &Path, rel_path: &RelativePath) -> bool {\n@@ -94,10 +108,22 @@ pub(crate) struct Roots {\n }\n \n impl Roots {\n-    pub(crate) fn new() -> Roots {\n-        Roots {\n-            roots: Arena::default(),\n+    pub(crate) fn new(mut paths: Vec<PathBuf>) -> Roots {\n+        let mut roots = Arena::default();\n+        // A hack to make nesting work.\n+        paths.sort_by_key(|it| Reverse(it.as_os_str().len()));\n+        for (i, path) in paths.iter().enumerate() {\n+            let nested_roots = paths[..i]\n+                .iter()\n+                .filter(|it| it.starts_with(path))\n+                .map(|it| it.clone())\n+                .collect::<Vec<_>>();\n+\n+            let root_filter = Arc::new(RootFilter::new(path.clone(), nested_roots));\n+\n+            roots.alloc(root_filter.clone());\n         }\n+        Roots { roots }\n     }\n     pub(crate) fn find(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf)> {\n         self.roots\n@@ -135,36 +161,22 @@ impl fmt::Debug for Vfs {\n \n impl Vfs {\n     pub fn new(roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n-        let mut root_paths = roots;\n-        let worker = io::Worker::start();\n-\n-        let mut roots = Roots::new();\n+        let roots = Arc::new(Roots::new(roots));\n+        let worker = io::Worker::start(roots.clone());\n         let mut root2files = FxHashMap::default();\n \n-        // A hack to make nesting work.\n-        root_paths.sort_by_key(|it| Reverse(it.as_os_str().len()));\n-        for (i, path) in root_paths.iter().enumerate() {\n-            let root_filter = Arc::new(RootFilter::new(path.clone()));\n-\n-            let root = roots.alloc(root_filter.clone());\n+        for (root, filter) in roots.iter() {\n             root2files.insert(root, Default::default());\n-\n-            let nested_roots = root_paths[..i]\n-                .iter()\n-                .filter(|it| it.starts_with(path))\n-                .map(|it| it.clone())\n-                .collect::<Vec<_>>();\n-\n-            let task = io::Task::AddRoot {\n-                root,\n-                path: path.clone(),\n-                root_filter,\n-                nested_roots,\n-            };\n-            worker.sender().send(task).unwrap();\n+            worker\n+                .sender()\n+                .send(io::Task::AddRoot {\n+                    root,\n+                    filter: filter.clone(),\n+                })\n+                .unwrap();\n         }\n         let res = Vfs {\n-            roots: Arc::new(roots),\n+            roots,\n             files: Arena::default(),\n             root2files,\n             worker,\n@@ -225,90 +237,46 @@ impl Vfs {\n \n     pub fn handle_task(&mut self, task: io::TaskResult) {\n         match task {\n-            TaskResult::AddRoot(task) => {\n-                let mut files = Vec::new();\n+            TaskResult::BulkLoadRoot { root, files } => {\n+                let mut cur_files = Vec::new();\n                 // While we were scanning the root in the backgound, a file might have\n                 // been open in the editor, so we need to account for that.\n-                let exising = self.root2files[&task.root]\n+                let exising = self.root2files[&root]\n                     .iter()\n                     .map(|&file| (self.files[file].path.clone(), file))\n                     .collect::<FxHashMap<_, _>>();\n-                for (path, text) in task.files {\n+                for (path, text) in files {\n                     if let Some(&file) = exising.get(&path) {\n                         let text = Arc::clone(&self.files[file].text);\n-                        files.push((file, path, text));\n+                        cur_files.push((file, path, text));\n                         continue;\n                     }\n                     let text = Arc::new(text);\n-                    let file = self.add_file(task.root, path.clone(), Arc::clone(&text), false);\n-                    files.push((file, path, text));\n+                    let file = self.add_file(root, path.clone(), Arc::clone(&text), false);\n+                    cur_files.push((file, path, text));\n                 }\n \n                 let change = VfsChange::AddRoot {\n-                    root: task.root,\n-                    files,\n+                    root,\n+                    files: cur_files,\n                 };\n                 self.pending_changes.push(change);\n             }\n-            TaskResult::HandleChange(change) => match &change {\n-                WatcherChange::Create(path) if path.is_dir() => {\n-                    if let Some((root, _path, _file)) = self.find_root(&path) {\n-                        let root_filter = self.roots[root].clone();\n-                        self.worker\n-                            .sender()\n-                            .send(Task::Watch {\n-                                dir: path.to_path_buf(),\n-                                root_filter,\n-                            })\n-                            .unwrap()\n-                    }\n-                }\n-                WatcherChange::Create(path)\n-                | WatcherChange::Remove(path)\n-                | WatcherChange::Write(path) => {\n-                    if self.should_handle_change(&path) {\n-                        self.worker.sender().send(Task::LoadChange(change)).unwrap()\n-                    }\n-                }\n-                WatcherChange::Rescan => {\n-                    // TODO we should reload all files\n-                }\n-            },\n-            TaskResult::LoadChange(change) => match change {\n-                WatcherChangeData::Create { path, text }\n-                | WatcherChangeData::Write { path, text } => {\n-                    if let Some((root, path, file)) = self.find_root(&path) {\n-                        if let Some(file) = file {\n-                            self.do_change_file(file, text, false);\n-                        } else {\n-                            self.do_add_file(root, path, text, false);\n-                        }\n-                    }\n-                }\n-                WatcherChangeData::Remove { path } => {\n-                    if let Some((root, path, file)) = self.find_root(&path) {\n-                        if let Some(file) = file {\n-                            self.do_remove_file(root, path, file, false);\n-                        }\n-                    }\n+            TaskResult::AddSingleFile { root, path, text } => {\n+                self.do_add_file(root, path, text, false);\n+            }\n+            TaskResult::ChangeSingleFile { root, path, text } => {\n+                if let Some(file) = self.find_file(root, &path) {\n+                    self.do_change_file(file, text, false);\n+                } else {\n+                    self.do_add_file(root, path, text, false);\n                 }\n-            },\n-        }\n-    }\n-\n-    fn should_handle_change(&self, path: &Path) -> bool {\n-        if let Some((_root, _rel_path, file)) = self.find_root(&path) {\n-            if let Some(file) = file {\n-                if self.files[file].is_overlayed {\n-                    // file is overlayed\n-                    log::debug!(\"skipping overlayed \\\"{}\\\"\", path.display());\n-                    return false;\n+            }\n+            TaskResult::RemoveSingleFile { root, path } => {\n+                if let Some(file) = self.find_file(root, &path) {\n+                    self.do_remove_file(root, path, file, false);\n                 }\n             }\n-            true\n-        } else {\n-            // file doesn't belong to any root\n-            false\n         }\n     }\n \n@@ -434,11 +402,15 @@ impl Vfs {\n \n     fn find_root(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf, Option<VfsFile>)> {\n         let (root, path) = self.roots.find(&path)?;\n-        let file = self.root2files[&root]\n+        let file = self.find_file(root, &path);\n+        Some((root, path, file))\n+    }\n+\n+    fn find_file(&self, root: VfsRoot, path: &RelativePath) -> Option<VfsFile> {\n+        self.root2files[&root]\n             .iter()\n             .map(|&it| it)\n-            .find(|&file| self.files[file].path == path);\n-        Some((root, path, file))\n+            .find(|&file| self.files[file].path == path)\n     }\n }\n "}, {"sha": "8562c56b963e660cdff5db0dafafaf2534368619", "filename": "crates/ra_vfs/tests/vfs.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d63e1cebff771621b90bdce25ac013eecb415e1e/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63e1cebff771621b90bdce25ac013eecb415e1e/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Ftests%2Fvfs.rs?ref=d63e1cebff771621b90bdce25ac013eecb415e1e", "patch": "@@ -75,27 +75,31 @@ fn test_vfs_works() -> std::io::Result<()> {\n     }\n \n     fs::write(&dir.path().join(\"a/b/baz.rs\"), \"quux\").unwrap();\n-    // 2 tasks per change, HandleChange and then LoadChange\n-    process_tasks(&mut vfs, 2);\n+    process_tasks(&mut vfs, 1);\n     assert_match!(\n         vfs.commit_changes().as_slice(),\n         [VfsChange::ChangeFile { text, .. }],\n         assert_eq!(text.as_str(), \"quux\")\n     );\n \n-    vfs.change_file_overlay(&dir.path().join(\"a/b/baz.rs\"), \"m\".to_string());\n+    vfs.add_file_overlay(&dir.path().join(\"a/b/baz.rs\"), \"m\".to_string());\n     assert_match!(\n         vfs.commit_changes().as_slice(),\n         [VfsChange::ChangeFile { text, .. }],\n         assert_eq!(text.as_str(), \"m\")\n     );\n \n+    // changing file on disk while overlayed doesn't generate a VfsChange\n+    fs::write(&dir.path().join(\"a/b/baz.rs\"), \"corge\").unwrap();\n+    process_tasks(&mut vfs, 1);\n+    assert_match!(vfs.commit_changes().as_slice(), []);\n+\n     // removing overlay restores data on disk\n     vfs.remove_file_overlay(&dir.path().join(\"a/b/baz.rs\"));\n     assert_match!(\n         vfs.commit_changes().as_slice(),\n         [VfsChange::ChangeFile { text, .. }],\n-        assert_eq!(text.as_str(), \"quux\")\n+        assert_eq!(text.as_str(), \"corge\")\n     );\n \n     vfs.add_file_overlay(&dir.path().join(\"a/b/spam.rs\"), \"spam\".to_string());\n@@ -117,7 +121,7 @@ fn test_vfs_works() -> std::io::Result<()> {\n \n     fs::create_dir_all(dir.path().join(\"a/sub1/sub2\")).unwrap();\n     fs::write(dir.path().join(\"a/sub1/sub2/new.rs\"), \"new hello\").unwrap();\n-    process_tasks(&mut vfs, 3);\n+    process_tasks(&mut vfs, 1);\n     assert_match!(\n         vfs.commit_changes().as_slice(),\n         [VfsChange::AddFile { text, path, .. }],\n@@ -132,7 +136,7 @@ fn test_vfs_works() -> std::io::Result<()> {\n         &dir.path().join(\"a/sub1/sub2/new1.rs\"),\n     )\n     .unwrap();\n-    process_tasks(&mut vfs, 4);\n+    process_tasks(&mut vfs, 2);\n     assert_match!(\n         vfs.commit_changes().as_slice(),\n         [VfsChange::RemoveFile {\n@@ -150,17 +154,16 @@ fn test_vfs_works() -> std::io::Result<()> {\n     );\n \n     fs::remove_file(&dir.path().join(\"a/sub1/sub2/new1.rs\")).unwrap();\n-    process_tasks(&mut vfs, 2);\n+    process_tasks(&mut vfs, 1);\n     assert_match!(\n         vfs.commit_changes().as_slice(),\n         [VfsChange::RemoveFile { path, .. }],\n         assert_eq!(path, \"sub1/sub2/new1.rs\")\n     );\n \n-    fs::create_dir_all(dir.path().join(\"a/target\")).unwrap();\n     // should be ignored\n+    fs::create_dir_all(dir.path().join(\"a/target\")).unwrap();\n     fs::write(&dir.path().join(\"a/target/new.rs\"), \"ignore me\").unwrap();\n-    process_tasks(&mut vfs, 1); // 1 task because no LoadChange will happen, just HandleChange for dir creation\n \n     assert_match!(\n         vfs.task_receiver().try_recv(),"}]}