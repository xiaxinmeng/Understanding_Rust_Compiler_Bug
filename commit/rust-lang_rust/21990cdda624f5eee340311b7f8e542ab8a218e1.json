{"sha": "21990cdda624f5eee340311b7f8e542ab8a218e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxOTkwY2RkYTYyNGY1ZWVlMzQwMzExYjdmOGU1NDJhYjhhMjE4ZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T09:07:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T09:07:40Z"}, "message": "auto merge of #10622 : Kimundi/rust/str_de_iter, r=alexcrichton\n\nThis PR removes almost all `_iter` suffixes in various APIs of the codebase that return Iterators, as discussed in #9440.\r\n\r\nAs a summarize for the intend behind this PR:\r\n\r\n- Iterators are the recommended way to provide a potentially lazy list of values, no need to name them painfully verbose. If anything, functions that return a specific container type should have more verbose names.\r\n- We have a static type system, so no need to encode the return value of a constructor function into its name.\r\n\r\nFollowing is a possibly incomplete list of all renamings I performed in the codebase. For a few of them I'm a bit unsure whether the new name still properly expresses their functionality, so feedback would be welcome:\r\n\r\n~~~\r\n&str : word_iter()             -> words()\r\n       line_iter()             -> lines()\r\n       any_line_iter()         -> lines_any()\r\n       iter()                  -> chars()\r\n       char_offset_iter()      -> char_indices()\r\n       byte_iter()             -> bytes()\r\n       split_iter()            -> split()\r\n       splitn_iter()           -> splitn()\r\n       split_str_iter()        -> split_str()\r\n       split_terminator_iter() -> split_terminator()\r\n       matches_index_iter()    -> match_indices()\r\n       nfd_iter()              -> nfd_chars()\r\n       nfkd_iter()             -> nfkd_chars()\r\n      \r\n&[T] : split_iter()        -> split()\r\n       splitn_iter()       -> splitn()\r\n       window_iter()       -> windows()\r\n       chunk_iter()        -> chunks()\r\n       permutations_iter() -> permutations()\r\n      \r\nextra:bitv::Bitv :  rev_liter()    -> rev_iter()\r\n                    common_iter()  -> commons()\r\n                    outlier_iter() -> outliers()\r\n\r\nextra::treemap::{...} : lower_bound_iter() -> lower_bound()\r\n                        upper_bound_iter() -> upper_bound()\r\n                       \r\nstd::trie::{...} : bound_iter()       -> bound()\r\n                   lower_bound_iter() -> lower_bound()\r\n                   upper_bound_iter() -> upper_bound()\r\n\r\nrustpkg::package_id::{...} : prefixes_iter() -> prefixes()\r\n\r\nstd::hashmap::{...} : difference_iter()           -> difference()\r\n                      symmetric_difference_iter() -> symmetric_difference()\r\n                      intersection_iter()         -> intersection()\r\n                      union_iter()                -> union()\r\n                     \r\nstd::path::{posix, windows} : component_iter()     -> components()\r\n                              str_component_iter() -> str_components()\r\n\r\n... not showing all identical renamings for reverse versions\r\n~~~\r\n\r\n---\r\n\r\nI'm also planning a few more changes, like removing all unnecessary `_rev` constructors (#9391), or reducing the `split` variants on `&str` to a more versatile and concise system.", "tree": {"sha": "567d9df8a078d09fc610ea3e0b301f5cb6fb63d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/567d9df8a078d09fc610ea3e0b301f5cb6fb63d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21990cdda624f5eee340311b7f8e542ab8a218e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21990cdda624f5eee340311b7f8e542ab8a218e1", "html_url": "https://github.com/rust-lang/rust/commit/21990cdda624f5eee340311b7f8e542ab8a218e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21990cdda624f5eee340311b7f8e542ab8a218e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b42c4388927db75f9a38edbeafbfe13775b1773d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b42c4388927db75f9a38edbeafbfe13775b1773d", "html_url": "https://github.com/rust-lang/rust/commit/b42c4388927db75f9a38edbeafbfe13775b1773d"}, {"sha": "24b316a3b9567cb2cc2fb6644bd891dbf8855c18", "url": "https://api.github.com/repos/rust-lang/rust/commits/24b316a3b9567cb2cc2fb6644bd891dbf8855c18", "html_url": "https://github.com/rust-lang/rust/commit/24b316a3b9567cb2cc2fb6644bd891dbf8855c18"}], "stats": {"total": 942, "additions": 473, "deletions": 469}, "files": [{"sha": "15b4a430ec1c7bf60480ab5714fa6807391d9d6c", "filename": "doc/tutorial-conditions.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/doc%2Ftutorial-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/doc%2Ftutorial-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-conditions.md?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -82,7 +82,7 @@ fn read_int_pairs() -> ~[(int,int)] {\n         let line = fi.read_line();\n \n         // 2. Split the line into fields (\"words\").\n-        let fields = line.word_iter().to_owned_vec();\n+        let fields = line.words().to_owned_vec();\n \n         // 3. Match the vector of fields against a vector pattern.\n         match fields {\n@@ -295,7 +295,7 @@ fn read_int_pairs() -> ~[(int,int)] {\n     let fi = FileInput::from_args();\n     while ! fi.eof() {\n         let line = fi.read_line();\n-        let fields = line.word_iter().to_owned_vec();\n+        let fields = line.words().to_owned_vec();\n         match fields {\n             [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n                                   from_str::<int>(b).unwrap())),\n@@ -396,7 +396,7 @@ fn read_int_pairs() -> ~[(int,int)] {\n     let fi = FileInput::from_args();\n     while ! fi.eof() {\n         let line = fi.read_line();\n-        let fields = line.word_iter().to_owned_vec();\n+        let fields = line.words().to_owned_vec();\n         match fields {\n             [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n                                   from_str::<int>(b).unwrap())),\n@@ -473,7 +473,7 @@ fn read_int_pairs() -> ~[(int,int)] {\n     let fi = FileInput::from_args();\n     while ! fi.eof() {\n         let line = fi.read_line();\n-        let fields = line.word_iter().to_owned_vec();\n+        let fields = line.words().to_owned_vec();\n         match fields {\n             [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n                                   from_str::<int>(b).unwrap())),\n@@ -551,7 +551,7 @@ fn read_int_pairs() -> ~[(int,int)] {\n     let fi = FileInput::from_args();\n     while ! fi.eof() {\n         let line = fi.read_line();\n-        let fields = line.word_iter().to_owned_vec();\n+        let fields = line.words().to_owned_vec();\n         match fields {\n             [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n                                   from_str::<int>(b).unwrap())),\n@@ -647,7 +647,7 @@ fn read_int_pairs() -> ~[(int,int)] {\n     let fi = FileInput::from_args();\n     while ! fi.eof() {\n         let line = fi.read_line();\n-        let fields = line.word_iter().to_owned_vec();\n+        let fields = line.words().to_owned_vec();\n         match fields {\n             [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n                                   from_str::<int>(b).unwrap())),\n@@ -787,7 +787,7 @@ fn read_int_pairs() -> ~[(int,int)] {\n     let fi = FileInput::from_args();\n     while ! fi.eof() {\n         let line = fi.read_line();\n-        let fields = line.word_iter().to_owned_vec();\n+        let fields = line.words().to_owned_vec();\n         match fields {\n \n             // Delegate parsing ints to helper function that will"}, {"sha": "2c01907d7fae1dcc0273becf62d980690b8ae96e", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -145,7 +145,7 @@ fn parse_check_line(line: &str) -> Option<~str> {\n fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n-        let mut strs: ~[~str] = nv.splitn_iter('=', 1).map(|s| s.to_owned()).collect();\n+        let mut strs: ~[~str] = nv.splitn('=', 1).map(|s| s.to_owned()).collect();\n \n         match strs.len() {\n           1u => (strs.pop(), ~\"\"),"}, {"sha": "035f0b83406df816eb4c0c1a1abb87587ead22c6", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -383,11 +383,11 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     if num_check_lines > 0 {\n         // Allow check lines to leave parts unspecified (e.g., uninitialized\n         // bits in the wrong case of an enum) with the notation \"[...]\".\n-        let check_fragments: ~[~[&str]] = check_lines.map(|s| s.split_str_iter(\"[...]\").collect());\n+        let check_fragments: ~[~[&str]] = check_lines.map(|s| s.split_str(\"[...]\").collect());\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n-        for line in ProcRes.stdout.line_iter() {\n+        for line in ProcRes.stdout.lines() {\n             let mut rest = line.trim();\n             let mut first = true;\n             let mut failed = false;\n@@ -439,7 +439,7 @@ fn check_error_patterns(props: &TestProps,\n     let mut next_err_idx = 0u;\n     let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n-    for line in ProcRes.stderr.line_iter() {\n+    for line in ProcRes.stderr.lines() {\n         if line.contains(*next_err_pat) {\n             debug!(\"found error pattern {}\", *next_err_pat);\n             next_err_idx += 1u;\n@@ -483,7 +483,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     }).collect::<~[~str]>();\n \n     fn to_lower( s : &str ) -> ~str {\n-        let i = s.iter();\n+        let i = s.chars();\n         let c : ~[char] = i.map( |c| {\n             if c.is_ascii() {\n                 c.to_ascii().to_lower().to_char()\n@@ -512,7 +512,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for line in ProcRes.stderr.line_iter() {\n+    for line in ProcRes.stderr.lines() {\n         let mut was_expected = false;\n         for (i, ee) in expected_errors.iter().enumerate() {\n             if !found_flags[i] {\n@@ -777,7 +777,7 @@ fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n fn split_maybe_args(argstr: &Option<~str>) -> ~[~str] {\n     match *argstr {\n         Some(ref s) => {\n-            s.split_iter(' ')\n+            s.split(' ')\n                 .filter_map(|s| if s.is_whitespace() {None} else {Some(s.to_owned())})\n                 .collect()\n         }\n@@ -896,7 +896,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     let cmdline = make_cmdline(\"\", args.prog, args.args);\n \n     // get bare program string\n-    let mut tvec: ~[~str] = args.prog.split_iter('/').map(|ts| ts.to_owned()).collect();\n+    let mut tvec: ~[~str] = args.prog.split('/').map(|ts| ts.to_owned()).collect();\n     let prog_short = tvec.pop();\n \n     // copy to target\n@@ -939,7 +939,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n                      Some(~\"\"));\n \n     let mut exitcode : int = 0;\n-    for c in exitcode_out.iter() {\n+    for c in exitcode_out.chars() {\n         if !c.is_digit() { break; }\n         exitcode = exitcode * 10 + match c {\n             '0' .. '9' => c as int - ('0' as int),\n@@ -1089,7 +1089,7 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n fn count_extracted_lines(p: &Path) -> uint {\n     let x = File::open(&p.with_extension(\"ll\")).read_to_end();\n     let x = str::from_utf8_owned(x);\n-    x.line_iter().len()\n+    x.lines().len()\n }\n \n "}, {"sha": "cfcd508e4d45ff5978153429c57f3d4d1ea3a626", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -193,7 +193,7 @@ impl<'self> FromBase64 for &'self str {\n         let mut buf: u32 = 0;\n         let mut modulus = 0;\n \n-        let mut it = self.byte_iter().enumerate();\n+        let mut it = self.bytes().enumerate();\n         for (idx, byte) in it {\n             let val = byte as u32;\n "}, {"sha": "393d76f246c7a06531bcc70e7664d70e3666dafe", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -413,7 +413,7 @@ impl Bitv {\n     }\n \n     #[inline]\n-    pub fn rev_liter<'a>(&'a self) -> Invert<BitvIterator<'a>> {\n+    pub fn rev_iter<'a>(&'a self) -> Invert<BitvIterator<'a>> {\n         self.iter().invert()\n     }\n \n@@ -723,38 +723,38 @@ impl BitvSet {\n     }\n \n     pub fn difference(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n-        for (i, w1, w2) in self.common_iter(other) {\n+        for (i, w1, w2) in self.commons(other) {\n             if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n                 return false\n             }\n         };\n         /* everything we have that they don't also shows up */\n-        self.outlier_iter(other).advance(|(mine, i, w)|\n+        self.outliers(other).advance(|(mine, i, w)|\n             !mine || iterate_bits(i, w, |b| f(&b))\n         )\n     }\n \n     pub fn symmetric_difference(&self, other: &BitvSet, f: |&uint| -> bool)\n                                 -> bool {\n-        for (i, w1, w2) in self.common_iter(other) {\n+        for (i, w1, w2) in self.commons(other) {\n             if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n                 return false\n             }\n         };\n-        self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n+        self.outliers(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n     }\n \n     pub fn intersection(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n-        self.common_iter(other).advance(|(i, w1, w2)| iterate_bits(i, w1 & w2, |b| f(&b)))\n+        self.commons(other).advance(|(i, w1, w2)| iterate_bits(i, w1 & w2, |b| f(&b)))\n     }\n \n     pub fn union(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n-        for (i, w1, w2) in self.common_iter(other) {\n+        for (i, w1, w2) in self.commons(other) {\n             if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n                 return false\n             }\n         };\n-        self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n+        self.outliers(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n     }\n }\n \n@@ -763,12 +763,12 @@ impl cmp::Eq for BitvSet {\n         if self.size != other.size {\n             return false;\n         }\n-        for (_, w1, w2) in self.common_iter(other) {\n+        for (_, w1, w2) in self.commons(other) {\n             if w1 != w2 {\n                 return false;\n             }\n         }\n-        for (_, _, w) in self.outlier_iter(other) {\n+        for (_, _, w) in self.outliers(other) {\n             if w != 0 {\n                 return false;\n             }\n@@ -803,15 +803,15 @@ impl Set<uint> for BitvSet {\n     }\n \n     fn is_subset(&self, other: &BitvSet) -> bool {\n-        for (_, w1, w2) in self.common_iter(other) {\n+        for (_, w1, w2) in self.commons(other) {\n             if w1 & w2 != w1 {\n                 return false;\n             }\n         }\n         /* If anything is not ours, then everything is not ours so we're\n            definitely a subset in that case. Otherwise if there's any stray\n            ones that 'other' doesn't have, we're not a subset. */\n-        for (mine, _, w) in self.outlier_iter(other) {\n+        for (mine, _, w) in self.outliers(other) {\n             if !mine {\n                 return true;\n             } else if w != 0 {\n@@ -865,7 +865,7 @@ impl BitvSet {\n     /// both have in common. The three yielded arguments are (bit location,\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n-    fn common_iter<'a>(&'a self, other: &'a BitvSet)\n+    fn commons<'a>(&'a self, other: &'a BitvSet)\n         -> Map<'static, ((uint, &'a uint), &'a ~[uint]), (uint, uint, uint),\n                Zip<Enumerate<vec::VecIterator<'a, uint>>, Repeat<&'a ~[uint]>>> {\n         let min = num::min(self.bitv.storage.len(), other.bitv.storage.len());\n@@ -881,7 +881,7 @@ impl BitvSet {\n     /// The yielded arguments are a `bool`, the bit offset, and a word. The `bool`\n     /// is true if the word comes from `self`, and `false` if it comes from\n     /// `other`.\n-    fn outlier_iter<'a>(&'a self, other: &'a BitvSet)\n+    fn outliers<'a>(&'a self, other: &'a BitvSet)\n         -> Map<'static, ((uint, &'a uint), uint), (bool, uint, uint),\n                Zip<Enumerate<vec::VecIterator<'a, uint>>, Repeat<uint>>> {\n         let slen = self.bitv.storage.len();"}, {"sha": "47dfaee3f57134486ecdafb25c99d1b438a8c7aa", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -413,7 +413,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n             let mut i_arg = None;\n             if cur[1] == '-' as u8 {\n                 let tail = cur.slice(2, curlen);\n-                let tail_eq: ~[&str] = tail.split_iter('=').collect();\n+                let tail_eq: ~[&str] = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n                     names = ~[Long(tail.to_owned())];\n                 } else {\n@@ -735,7 +735,7 @@ pub mod groups {\n \n             // Normalize desc to contain words separated by one space character\n             let mut desc_normalized_whitespace = ~\"\";\n-            for word in desc.word_iter() {\n+            for word in desc.words() {\n                 desc_normalized_whitespace.push_str(word);\n                 desc_normalized_whitespace.push_char(' ');\n             }\n@@ -826,7 +826,7 @@ pub mod groups {\n             cont\n         };\n \n-        ss.char_offset_iter().advance(|x| machine(x));\n+        ss.char_indices().advance(|x| machine(x));\n \n         // Let the automaton 'run out' by supplying trailing whitespace\n         while cont && match state { B | C => true, A => false } {"}, {"sha": "fde63071bc89235b3bee132b11d4fe4d41c941c5", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -102,7 +102,7 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n \n     let root_len = pat_root.map_default(0u, |p| p.as_vec().len());\n     let dir_patterns = pattern.slice_from(root_len.min(&pattern.len()))\n-                       .split_terminator_iter(is_sep).map(|s| Pattern::new(s)).to_owned_vec();\n+                       .split_terminator(is_sep).map(|s| Pattern::new(s)).to_owned_vec();\n \n     let todo = list_dir_sorted(&root).move_iter().map(|x|(x,0u)).to_owned_vec();\n \n@@ -209,7 +209,7 @@ impl Pattern {\n      */\n     pub fn new(pattern: &str) -> Pattern {\n \n-        let chars = pattern.iter().to_owned_vec();\n+        let chars = pattern.chars().to_owned_vec();\n         let mut tokens = ~[];\n         let mut i = 0;\n \n@@ -272,7 +272,7 @@ impl Pattern {\n      */\n     pub fn escape(s: &str) -> ~str {\n         let mut escaped = ~\"\";\n-        for c in s.iter() {\n+        for c in s.chars() {\n             match c {\n                 // note that ! does not need escaping because it is only special inside brackets\n                 '?' | '*' | '[' | ']' => {\n@@ -586,10 +586,10 @@ mod test {\n         let pats = [\"[a-z123]\", \"[1a-z23]\", \"[123a-z]\"];\n         for &p in pats.iter() {\n             let pat = Pattern::new(p);\n-            for c in \"abcdefghijklmnopqrstuvwxyz\".iter() {\n+            for c in \"abcdefghijklmnopqrstuvwxyz\".chars() {\n                 assert!(pat.matches(c.to_str()));\n             }\n-            for c in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".iter() {\n+            for c in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".chars() {\n                 let options = MatchOptions {case_sensitive: false, .. MatchOptions::new()};\n                 assert!(pat.matches_with(c.to_str(), options));\n             }"}, {"sha": "714fc4d8253f9b8daf8f60b32653587a83124ff9", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -91,7 +91,7 @@ impl<'self> FromHex for &'self str {\n         let mut modulus = 0;\n         let mut buf = 0u8;\n \n-        for (idx, byte) in self.byte_iter().enumerate() {\n+        for (idx, byte) in self.bytes().enumerate() {\n             buf <<= 4;\n \n             match byte as char {"}, {"sha": "6befdc899d2bc921ef1b452c28d095a569b7d4d4", "filename": "src/libextra/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -59,7 +59,7 @@ pub struct Error {\n \n fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n-    for c in s.iter() {\n+    for c in s.chars() {\n         match c {\n           '\"' => escaped.push_str(\"\\\\\\\"\"),\n           '\\\\' => escaped.push_str(\"\\\\\\\\\"),\n@@ -559,7 +559,7 @@ impl<T : Iterator<char>> Parser<T> {\n     }\n \n     fn parse_ident(&mut self, ident: &str, value: Json) -> Result<Json, Error> {\n-        if ident.iter().all(|c| c == self.next_char()) {\n+        if ident.chars().all(|c| c == self.next_char()) {\n             self.bump();\n             Ok(value)\n         } else {\n@@ -844,13 +844,13 @@ impl<T : Iterator<char>> Parser<T> {\n /// Decodes a json value from an `&mut io::Reader`\n pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, Error> {\n     let s = str::from_utf8(rdr.read_to_end());\n-    let mut parser = Parser(~s.iter());\n+    let mut parser = Parser(~s.chars());\n     parser.parse()\n }\n \n /// Decodes a json value from a string\n pub fn from_str(s: &str) -> Result<Json, Error> {\n-    let mut parser = Parser(~s.iter());\n+    let mut parser = Parser(~s.chars());\n     parser.parse()\n }\n \n@@ -930,7 +930,7 @@ impl serialize::Decoder for Decoder {\n     fn read_char(&mut self) -> char {\n         let s = self.read_str();\n         {\n-            let mut it = s.iter();\n+            let mut it = s.chars();\n             match (it.next(), it.next()) {\n                 // exactly one character\n                 (Some(c), None) => return c,"}, {"sha": "19cb483992017a9c300a5dc066d4be1db0d55e29", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -292,7 +292,7 @@ impl<T: FromStr + Clone + Integer + Ord>\n     FromStr for Ratio<T> {\n     /// Parses `numer/denom`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n-        let split: ~[&str] = s.splitn_iter('/', 1).collect();\n+        let split: ~[&str] = s.splitn('/', 1).collect();\n         if split.len() < 2 {\n             return None\n         }\n@@ -309,7 +309,7 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n     FromStrRadix for Ratio<T> {\n     /// Parses `numer/denom` where the numbers are in base `radix`.\n     fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n-        let split: ~[&str] = s.splitn_iter('/', 1).collect();\n+        let split: ~[&str] = s.splitn('/', 1).collect();\n         if split.len() < 2 {\n             None\n         } else {"}, {"sha": "616125c9960eaf02a5c17993ab8343b2aa07450e", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -176,7 +176,7 @@ fn take_num<T: Iterator<char>>(rdr: &mut T) -> (uint, Option<char>) {\n \n fn take_ident<T: Iterator<char>>(rdr: &mut T) -> (Identifier, Option<char>) {\n     let (s,ch) = take_nonempty_prefix(rdr, char::is_alphanumeric);\n-    if s.iter().all(char::is_digit) {\n+    if s.chars().all(char::is_digit) {\n         match from_str::<uint>(s) {\n             None => { bad_parse::cond.raise(()); (Numeric(0), ch) },\n             Some(i) => (Numeric(i), ch)\n@@ -239,7 +239,7 @@ pub fn parse(s: &str) -> Option<Version> {\n     let s = s.trim();\n     let mut bad = false;\n     do bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).inside {\n-        let v = parse_iter(&mut s.iter());\n+        let v = parse_iter(&mut s.chars());\n         if bad || v.to_str() != s.to_owned() {\n             None\n         } else {"}, {"sha": "af1532db93551cdd6238fc6282c4798f6028a3b2", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -216,7 +216,7 @@ pub fn parse(file: &mut io::Reader,\n     }\n \n     let names_str = str::from_utf8(file.read_bytes(names_bytes as uint - 1)); // don't read NUL\n-    let term_names: ~[~str] = names_str.split_iter('|').map(|s| s.to_owned()).collect();\n+    let term_names: ~[~str] = names_str.split('|').map(|s| s.to_owned()).collect();\n \n     file.read_byte(); // consume NUL\n "}, {"sha": "09f8cc0efef4003eac116014d9d8a8bb62e27540", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -36,7 +36,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n                 dirs_to_search.push(homedir.unwrap().join(\".terminfo\"))\n             }\n             match getenv(\"TERMINFO_DIRS\") {\n-                Some(dirs) => for i in dirs.split_iter(':') {\n+                Some(dirs) => for i in dirs.split(':') {\n                     if i == \"\" {\n                         dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));\n                     } else {"}, {"sha": "87bd314c8fb0a8997e554bd220743db406a62c68", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -313,7 +313,7 @@ pub fn opt_shard(maybestr: Option<~str>) -> Option<(uint,uint)> {\n     match maybestr {\n         None => None,\n         Some(s) => {\n-            match s.split_iter('.').to_owned_vec() {\n+            match s.split('.').to_owned_vec() {\n                 [a, b] => match (from_str::<uint>(a), from_str::<uint>(b)) {\n                     (Some(a), Some(b)) => Some((a,b)),\n                     _ => None"}, {"sha": "fb80ce026257d6e35f8ec13302ce8943befefc7f", "filename": "src/libextra/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -248,7 +248,7 @@ impl Tm {\n pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n-        for ch in needle.byte_iter() {\n+        for ch in needle.bytes() {\n             if s[i] != ch {\n                 return false;\n             }"}, {"sha": "9912e3d6ef701aa6ef7e9855fb7d64fdef247596", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -170,7 +170,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n \n     /// Return a lazy iterator to the first key-value pair whose key is not less than `k`\n     /// If all keys in map are less than `k` an empty iterator is returned.\n-    pub fn lower_bound_iter<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n+    pub fn lower_bound<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n         let mut iter: TreeMapIterator<'a, K, V> = self.iter_for_traversal();\n         loop {\n             match iter.node {\n@@ -194,7 +194,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n \n     /// Return a lazy iterator to the first key-value pair whose key is greater than `k`\n     /// If all keys in map are not greater than `k` an empty iterator is returned.\n-    pub fn upper_bound_iter<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n+    pub fn upper_bound<'a>(&'a self, k: &K) -> TreeMapIterator<'a, K, V> {\n         let mut iter: TreeMapIterator<'a, K, V> = self.iter_for_traversal();\n         loop {\n             match iter.node {\n@@ -526,15 +526,15 @@ impl<T: TotalOrd> TreeSet<T> {\n     /// Get a lazy iterator pointing to the first value not less than `v` (greater or equal).\n     /// If all elements in the set are less than `v` empty iterator is returned.\n     #[inline]\n-    pub fn lower_bound_iter<'a>(&'a self, v: &T) -> TreeSetIterator<'a, T> {\n-        TreeSetIterator{iter: self.map.lower_bound_iter(v)}\n+    pub fn lower_bound<'a>(&'a self, v: &T) -> TreeSetIterator<'a, T> {\n+        TreeSetIterator{iter: self.map.lower_bound(v)}\n     }\n \n     /// Get a lazy iterator pointing to the first value greater than `v`.\n     /// If all elements in the set are not greater than `v` empty iterator is returned.\n     #[inline]\n-    pub fn upper_bound_iter<'a>(&'a self, v: &T) -> TreeSetIterator<'a, T> {\n-        TreeSetIterator{iter: self.map.upper_bound_iter(v)}\n+    pub fn upper_bound<'a>(&'a self, v: &T) -> TreeSetIterator<'a, T> {\n+        TreeSetIterator{iter: self.map.upper_bound(v)}\n     }\n \n     /// Visit the values (in-order) representing the difference\n@@ -1095,19 +1095,19 @@ mod test_treemap {\n         }\n \n         for i in range(1, 198) {\n-            let mut lb_it = m.lower_bound_iter(&i);\n+            let mut lb_it = m.lower_bound(&i);\n             let (&k, &v) = lb_it.next().unwrap();\n             let lb = i + i % 2;\n             assert_eq!(lb, k);\n             assert_eq!(lb * 2, v);\n \n-            let mut ub_it = m.upper_bound_iter(&i);\n+            let mut ub_it = m.upper_bound(&i);\n             let (&k, &v) = ub_it.next().unwrap();\n             let ub = i + 2 - i % 2;\n             assert_eq!(ub, k);\n             assert_eq!(ub * 2, v);\n         }\n-        let mut end_it = m.lower_bound_iter(&199);\n+        let mut end_it = m.lower_bound(&199);\n         assert_eq!(end_it.next(), None);\n     }\n "}, {"sha": "71a8774e35c6400d11628c4256482ccf76bc2543", "filename": "src/libextra/url.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -356,7 +356,7 @@ fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n     if !rawquery.is_empty() {\n-        for p in rawquery.split_iter('&') {\n+        for p in rawquery.split('&') {\n             let (k, v) = split_char_first(p, '=');\n             query.push((decode_component(k), decode_component(v)));\n         };\n@@ -391,7 +391,7 @@ pub fn query_to_str(query: &Query) -> ~str {\n \n // returns the scheme and the rest of the url, or a parsing error\n pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n-    for (i,c) in rawurl.iter().enumerate() {\n+    for (i,c) in rawurl.chars().enumerate() {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => continue,\n           '0' .. '9' | '+' | '-' | '.' => {\n@@ -453,7 +453,7 @@ fn get_authority(rawurl: &str) ->\n     let mut begin = 2;\n     let mut end = len;\n \n-    for (i,c) in rawurl.iter().enumerate() {\n+    for (i,c) in rawurl.chars().enumerate() {\n         if i < 2 { continue; } // ignore the leading //\n \n         // deal with input class first\n@@ -587,7 +587,7 @@ fn get_path(rawurl: &str, authority: bool) ->\n     Result<(~str, ~str), ~str> {\n     let len = rawurl.len();\n     let mut end = len;\n-    for (i,c) in rawurl.iter().enumerate() {\n+    for (i,c) in rawurl.chars().enumerate() {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '&' |'\\'' | '(' | ')' | '.'\n           | '@' | ':' | '%' | '/' | '+' | '!' | '*' | ',' | ';' | '='"}, {"sha": "be26d1b935134b5821bab14e9725a446ba18c08b", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -366,15 +366,15 @@ impl Uuid {\n         }\n \n         // Make sure all chars are either hex digits or hyphen\n-        for (i, c) in us.iter().enumerate() {\n+        for (i, c) in us.chars().enumerate() {\n             match c {\n                 '0'..'9' | 'A'..'F' | 'a'..'f' | '-' => {},\n                 _ => return Err(ErrorInvalidCharacter(c, i)),\n             }\n         }\n \n         // Split string up by hyphens into groups\n-        let hex_groups: ~[&str] = us.split_str_iter(\"-\").collect();\n+        let hex_groups: ~[&str] = us.split_str(\"-\").collect();\n \n         // Get the length of each group\n         let group_lens: ~[uint] = hex_groups.iter().map(|&v| v.len()).collect();\n@@ -407,7 +407,7 @@ impl Uuid {\n \n         // At this point, we know we have a valid hex string, without hyphens\n         assert!(vs.len() == 32);\n-        assert!(vs.iter().all(|c| c.is_digit_radix(16)));\n+        assert!(vs.chars().all(|c| c.is_digit_radix(16)));\n \n         // Allocate output UUID buffer\n         let mut ub = [0u8, ..16];\n@@ -650,7 +650,7 @@ mod test {\n         let s = uuid1.to_simple_str();\n \n         assert!(s.len() == 32);\n-        assert!(s.iter().all(|c| c.is_digit_radix(16)));\n+        assert!(s.chars().all(|c| c.is_digit_radix(16)));\n     }\n \n     #[test]\n@@ -659,7 +659,7 @@ mod test {\n         let s = uuid1.to_str();\n \n         assert!(s.len() == 32);\n-        assert!(s.iter().all(|c| c.is_digit_radix(16)));\n+        assert!(s.chars().all(|c| c.is_digit_radix(16)));\n     }\n \n     #[test]\n@@ -668,7 +668,7 @@ mod test {\n         let s = uuid1.to_hyphenated_str();\n \n         assert!(s.len() == 36);\n-        assert!(s.iter().all(|c| c.is_digit_radix(16) || c == '-'));\n+        assert!(s.chars().all(|c| c.is_digit_radix(16) || c == '-'));\n     }\n \n     #[test]\n@@ -679,7 +679,7 @@ mod test {\n \n         assert!(ss.starts_with(\"urn:uuid:\"));\n         assert!(s.len() == 36);\n-        assert!(s.iter().all(|c| c.is_digit_radix(16) || c == '-'));\n+        assert!(s.chars().all(|c| c.is_digit_radix(16) || c == '-'));\n     }\n \n     #[test]\n@@ -689,7 +689,7 @@ mod test {\n         let hs = uuid1.to_hyphenated_str();\n         let ss = uuid1.to_str();\n \n-        let hsn = str::from_chars(hs.iter().filter(|&c| c != '-').collect::<~[char]>());\n+        let hsn = str::from_chars(hs.chars().filter(|&c| c != '-').collect::<~[char]>());\n \n         assert!(hsn == ss);\n     }"}, {"sha": "35e8c6fde3c8d1dec98a5af4b79778ac1f1c2ce5", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -711,7 +711,7 @@ pub fn get_symbol_hash(ccx: &mut CrateContext, t: ty::t) -> @str {\n // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n pub fn sanitize(s: &str) -> ~str {\n     let mut result = ~\"\";\n-    for c in s.iter() {\n+    for c in s.chars() {\n         match c {\n             // Escape these with $ sequences\n             '@' => result.push_str(\"$SP$\"),"}, {"sha": "eb332aeeb5c74d70cc9934328ee534217a1692c8", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -172,7 +172,6 @@ mod test {\n \n     use back::rpath::{get_absolute_rpath, get_install_prefix_rpath};\n     use back::rpath::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n-    use driver::session;\n     use syntax::abi;\n \n     #[test]"}, {"sha": "bdc3e2658a5e1c9aa1d72e61e847daba024b50f9", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -757,7 +757,7 @@ pub fn build_session_options(binary: @str,\n     }).move_iter().collect();\n     let linker = matches.opt_str(\"linker\");\n     let linker_args = matches.opt_strs(\"link-args\").flat_map( |a| {\n-        a.split_iter(' ').map(|arg| arg.to_owned()).collect()\n+        a.split(' ').map(|arg| arg.to_owned()).collect()\n     });\n \n     let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"), demitter);\n@@ -767,15 +767,15 @@ pub fn build_session_options(binary: @str,\n     let custom_passes = match matches.opt_str(\"passes\") {\n         None => ~[],\n         Some(s) => {\n-            s.split_iter(|c: char| c == ' ' || c == ',').map(|s| {\n+            s.split(|c: char| c == ' ' || c == ',').map(|s| {\n                 s.trim().to_owned()\n             }).collect()\n         }\n     };\n     let llvm_args = match matches.opt_str(\"llvm-args\") {\n         None => ~[],\n         Some(s) => {\n-            s.split_iter(|c: char| c == ' ' || c == ',').map(|s| {\n+            s.split(|c: char| c == ' ' || c == ',').map(|s| {\n                 s.trim().to_owned()\n             }).collect()\n         }"}, {"sha": "0f6fcf819b00abcb50bc57e38480211462a46b9b", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -113,7 +113,7 @@ pub fn get_used_libraries<'a>(cstore: &'a CStore) -> &'a [@str] {\n }\n \n pub fn add_used_link_args(cstore: &mut CStore, args: &str) {\n-    for s in args.split_iter(' ') {\n+    for s in args.split(' ') {\n         cstore.used_link_args.push(s.to_managed());\n     }\n }"}, {"sha": "eccbe049e2b9085973a6678ebfcdbeb8f313aba5", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -198,7 +198,7 @@ pub fn rust_path() -> ~[Path] {\n     let mut env_rust_path: ~[Path] = match get_rust_path() {\n         Some(env_path) => {\n             let env_path_components: ~[&str] =\n-                env_path.split_str_iter(PATH_ENTRY_SEPARATOR).collect();\n+                env_path.split_str(PATH_ENTRY_SEPARATOR).collect();\n             env_path_components.map(|&s| Path::new(s))\n         }\n         None => ~[]"}, {"sha": "2b2c2aa74c709a6b0f4c1526edb1430cd4195ae1", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -936,7 +936,7 @@ fn check_item_non_uppercase_statics(cx: &Context, it: &ast::item) {\n             // check for lowercase letters rather than non-uppercase\n             // ones (some scripts don't have a concept of\n             // upper/lowercase)\n-            if s.iter().any(|c| c.is_lowercase()) {\n+            if s.chars().any(|c| c.is_lowercase()) {\n                 cx.span_lint(non_uppercase_statics, it.span,\n                              \"static constant should have an uppercase identifier\");\n             }\n@@ -952,7 +952,7 @@ fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n             // last identifier alone is right choice for this lint.\n             let ident = path.segments.last().identifier;\n             let s = cx.tcx.sess.str_of(ident);\n-            if s.iter().any(|c| c.is_lowercase()) {\n+            if s.chars().any(|c| c.is_lowercase()) {\n                 cx.span_lint(non_uppercase_pattern_statics, path.span,\n                              \"static constant in pattern should be all caps\");\n             }"}, {"sha": "e57eed480eb53e41f8a5ba818e36f39e400ee203", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -157,7 +157,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n     // This requires that atomic intrinsics follow a specific naming pattern:\n     // \"atomic_<operation>[_<ordering>], and no ordering means SeqCst\n     if name.starts_with(\"atomic_\") {\n-        let split : ~[&str] = name.split_iter('_').collect();\n+        let split : ~[&str] = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n         let order = if split.len() == 2 {\n             lib::llvm::SequentiallyConsistent"}, {"sha": "857b1455a364e9437c46def50fad5ebc1f66a249", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -3926,7 +3926,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     let nm = ccx.tcx.sess.str_of(it.ident);\n     let name = nm.as_slice();\n     let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n-        let split : ~[&str] = name.split_iter('_').collect();\n+        let split : ~[&str] = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n         //We only care about the operation here"}, {"sha": "d618275ff05e5419a7f691cc6b62fba819b6dd93", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -25,7 +25,7 @@ impl<'self> fmt::Default for Escape<'self> {\n         // characters to escape: http://stackoverflow.com/questions/7381974\n         let pile_o_bits = s.as_slice();\n         let mut last = 0;\n-        for (i, ch) in s.byte_iter().enumerate() {\n+        for (i, ch) in s.bytes().enumerate() {\n             match ch as char {\n                 '<' | '>' | '&' | '\\'' | '\"' => {\n                     fmt.buf.write(pile_o_bits.slice(last, i).as_bytes());"}, {"sha": "96219479e104bdd31c4faee42a00f430b3217332", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -338,7 +338,7 @@ fn mkdir(path: &Path) {\n fn clean_srcpath(src: &[u8], f: &fn(&str)) {\n     let p = Path::new(src);\n     if p.as_vec() != bytes!(\".\") {\n-        for c in p.str_component_iter().map(|x|x.unwrap()) {\n+        for c in p.str_components().map(|x|x.unwrap()) {\n             if \"..\" == c {\n                 f(\"up\");\n             } else {\n@@ -1621,7 +1621,7 @@ fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n \n impl<'self> fmt::Default for Source<'self> {\n     fn fmt(s: &Source<'self>, fmt: &mut fmt::Formatter) {\n-        let lines = s.line_iter().len();\n+        let lines = s.lines().len();\n         let mut cols = 0;\n         let mut tmp = lines;\n         while tmp > 0 {"}, {"sha": "977931eb42ac97d374eb8a4f5cc783f53899f7a3", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -215,12 +215,12 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n                         default_passes = false;\n                     }\n                     clean::NameValue(~\"passes\", ref value) => {\n-                        for pass in value.word_iter() {\n+                        for pass in value.words() {\n                             passes.push(pass.to_owned());\n                         }\n                     }\n                     clean::NameValue(~\"plugins\", ref value) => {\n-                        for p in value.word_iter() {\n+                        for p in value.words() {\n                             plugins.push(p.to_owned());\n                         }\n                     }"}, {"sha": "99e825c35e366067eda5b9bc77bf698306044e23", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -228,7 +228,7 @@ pub fn collapse_docs(crate: clean::Crate) -> plugins::PluginResult {\n }\n \n pub fn unindent(s: &str) -> ~str {\n-    let lines = s.any_line_iter().collect::<~[&str]>();\n+    let lines = s.lines_any().collect::<~[&str]>();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n     let min_indent = do lines.iter().fold(uint::max_value) |min_indent, line| {\n@@ -257,7 +257,7 @@ pub fn unindent(s: &str) -> ~str {\n         } else {\n             saw_first_line = true;\n             let mut spaces = 0;\n-            do line.iter().all |char| {\n+            do line.chars().all |char| {\n                 // Only comparing against space because I wouldn't\n                 // know what to do with mixed whitespace chars\n                 if char == ' ' {"}, {"sha": "855f6bbc3e50f855a0e4e2e32fa92c945ca6bf87", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -59,7 +59,7 @@ pub fn has_library(p: &Path) -> Option<~str> {\n     for path in files.iter() {\n         if path.extension_str() == Some(os::consts::DLL_EXTENSION) {\n             let stuff : &str = path.filestem_str().expect(\"has_library: weird path\");\n-            let mut stuff2 = stuff.split_str_iter(&\"-\");\n+            let mut stuff2 = stuff.split_str(\"-\");\n             let stuff3: ~[&str] = stuff2.collect();\n             // argh\n             let chars_to_drop = os::consts::DLL_PREFIX.len();"}, {"sha": "46b7b466f236b557b356cc525cf873a3f0ca7ef8", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -184,7 +184,7 @@ impl<'self> PkgScript<'self> {\n                                              [sysroot.as_str().unwrap().to_owned(), ~\"configs\"]);\n             debug!(\"run_custom: second pkg command did {:?}\", output.status);\n             // Run the configs() function to get the configs\n-            let cfgs = str::from_utf8_slice(output.output).word_iter()\n+            let cfgs = str::from_utf8_slice(output.output).words()\n                 .map(|w| w.to_owned()).collect();\n             (cfgs, output.status)\n         }"}, {"sha": "bb3f6f27e04f25371eb67dbca369ece7af444c81", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -102,8 +102,8 @@ impl PkgId {\n         self.short_name.as_bytes() != self.path.as_vec()\n     }\n \n-    pub fn prefixes_iter(&self) -> Prefixes {\n-        prefixes_iter(&self.path)\n+    pub fn prefixes(&self) -> Prefixes {\n+        prefixes(&self.path)\n     }\n \n     // This is the workcache function name for the *installed*\n@@ -114,9 +114,9 @@ impl PkgId {\n     }\n }\n \n-pub fn prefixes_iter(p: &Path) -> Prefixes {\n+pub fn prefixes(p: &Path) -> Prefixes {\n     Prefixes {\n-        components: p.str_component_iter().map(|x|x.unwrap().to_owned()).to_owned_vec(),\n+        components: p.str_components().map(|x|x.unwrap().to_owned()).to_owned_vec(),\n         remaining: ~[]\n     }\n }"}, {"sha": "7e1430792ffbddc0c978799ec9c066ce44f37cdc", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -132,7 +132,7 @@ impl PkgSrc {\n             None => {\n                 // See if any of the prefixes of this package ID form a valid package ID\n                 // That is, is this a package ID that points into the middle of a workspace?\n-                for (prefix, suffix) in id.prefixes_iter() {\n+                for (prefix, suffix) in id.prefixes() {\n                     let package_id = PkgId::new(prefix.as_str().unwrap());\n                     let path = build_dir.join(&package_id.path);\n                     debug!(\"in loop: checking if {} is a directory\", path.display());\n@@ -183,7 +183,7 @@ impl PkgSrc {\n                                 || d.is_ancestor_of(&versionize(&id.path, &id.version)) {\n                                 // Strip off the package ID\n                                 source_workspace = d.clone();\n-                                for _ in id.path.component_iter() {\n+                                for _ in id.path.components() {\n                                     source_workspace.pop();\n                                 }\n                                 // Strip off the src/ part\n@@ -279,7 +279,7 @@ impl PkgSrc {\n                 Some(local.clone())\n             }\n             DirToUse(clone_target) => {\n-                if pkgid.path.component_iter().nth(1).is_none() {\n+                if pkgid.path.components().nth(1).is_none() {\n                     // If a non-URL, don't bother trying to fetch\n                     return None;\n                 }\n@@ -329,7 +329,7 @@ impl PkgSrc {\n     }\n \n     pub fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n-        let mut it = p.component_iter().peekable();\n+        let mut it = p.components().peekable();\n         if prefix > 0 {\n             it.nth(prefix-1); // skip elements\n         }\n@@ -351,7 +351,7 @@ impl PkgSrc {\n     pub fn find_crates_with_filter(&mut self, filter: &fn(&str) -> bool) {\n         use conditions::missing_pkg_files::cond;\n \n-        let prefix = self.start_dir.component_iter().len();\n+        let prefix = self.start_dir.components().len();\n         debug!(\"Matching against {}\", self.id.short_name);\n         for pth in fs::walk_dir(&self.start_dir) {\n             let maybe_known_crate_set = match pth.filename_str() {"}, {"sha": "a6897e141aac77f9cfc4ec8550da8c5b19900126", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -457,7 +457,7 @@ fn command_line_test_output(args: &[~str]) -> ~[~str] {\n     let mut result = ~[];\n     let p_output = command_line_test(args, &os::getcwd());\n     let test_output = str::from_utf8(p_output.output);\n-    for s in test_output.split_iter('\\n') {\n+    for s in test_output.split('\\n') {\n         result.push(s.to_owned());\n     }\n     result\n@@ -471,7 +471,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n         Success(r) => r\n     };\n     let test_output = str::from_utf8(p_output.output);\n-    for s in test_output.split_iter('\\n') {\n+    for s in test_output.split('\\n') {\n         result.push(s.to_owned());\n     }\n     result"}, {"sha": "4f3d431543b7df5967ed5c0e5c7525056ff57ee6", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -177,7 +177,7 @@ pub fn compile_input(context: &BuildContext,\n                      cfgs: &[~str],\n                      opt: session::OptLevel,\n                      what: OutputType) -> Option<Path> {\n-    assert!(in_file.component_iter().nth(1).is_some());\n+    assert!(in_file.components().nth(1).is_some());\n     let input = driver::file_input(in_file.clone());\n     debug!(\"compile_input: {} / {:?}\", in_file.display(), what);\n     // tjc: by default, use the package ID name as the link name"}, {"sha": "ad3c0cb6645f9a7fab15e68808e554d0f04822dd", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -115,7 +115,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n \n     let mut output = None;\n     let output_text = str::from_utf8(outp.output);\n-    for l in output_text.line_iter() {\n+    for l in output_text.lines() {\n         if !l.is_whitespace() {\n             output = Some(l);\n         }\n@@ -157,7 +157,7 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n                                             ~\"tag\", ~\"-l\"]);\n             let output_text = str::from_utf8(outp.output);\n             debug!(\"Full output: ( {} ) [{:?}]\", output_text, outp.status);\n-            for l in output_text.line_iter() {\n+            for l in output_text.lines() {\n                 debug!(\"A line of output: {}\", l);\n                 if !l.is_whitespace() {\n                     output = Some(l);\n@@ -187,7 +187,7 @@ pub fn try_parsing_version(s: &str) -> Option<Version> {\n     let s = s.trim();\n     debug!(\"Attempting to parse: {}\", s);\n     let mut parse_state = Start;\n-    for c in s.iter() {\n+    for c in s.chars() {\n         if char::is_digit(c) {\n             parse_state = SawDigit;\n         }\n@@ -207,15 +207,15 @@ pub fn try_parsing_version(s: &str) -> Option<Version> {\n /// Just an approximation\n fn is_url_like(p: &Path) -> bool {\n     // check if there are more than 2 /-separated components\n-    p.as_vec().split_iter(|b| *b == '/' as u8).nth(2).is_some()\n+    p.as_vec().split(|b| *b == '/' as u8).nth(2).is_some()\n }\n \n /// If s is of the form foo#bar, where bar is a valid version\n /// number, return the prefix before the # and the version.\n /// Otherwise, return None.\n pub fn split_version<'a>(s: &'a str) -> Option<(&'a str, Version)> {\n     // Check for extra '#' characters separately\n-    if s.split_iter('#').len() > 2 {\n+    if s.split('#').len() > 2 {\n         return None;\n     }\n     split_version_general(s, '#')"}, {"sha": "5d4f6ee112136d996dbb3db647af572ba50c4c0e", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -180,7 +180,7 @@ impl<'self> AsciiCast<&'self [Ascii]> for &'self str {\n \n     #[inline]\n     fn is_ascii(&self) -> bool {\n-        self.byte_iter().all(|b| b.is_ascii())\n+        self.bytes().all(|b| b.is_ascii())\n     }\n }\n \n@@ -394,7 +394,7 @@ unsafe fn str_map_bytes(string: ~str, map: &'static [u8]) -> ~str {\n \n #[inline]\n unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> ~str {\n-    let bytes = string.byte_iter().map(|b| map[b]).to_owned_vec();\n+    let bytes = string.bytes().map(|b| map[b]).to_owned_vec();\n \n     str::raw::from_utf8_owned(bytes)\n }\n@@ -498,8 +498,8 @@ mod tests {\n         assert_eq!('`'.to_ascii().to_upper().to_char(), '`');\n         assert_eq!('{'.to_ascii().to_upper().to_char(), '{');\n \n-        assert!(\"banana\".iter().all(|c| c.is_ascii()));\n-        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".iter().all(|c| c.is_ascii()));\n+        assert!(\"banana\".chars().all(|c| c.is_ascii()));\n+        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n     }\n \n     #[test]"}, {"sha": "885fe75fb9fa64ad70f785182fdfaaeb2bcfc93b", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -196,7 +196,7 @@ impl<'self> Parser<'self> {\n     pub fn new<'a>(s: &'a str) -> Parser<'a> {\n         Parser {\n             input: s,\n-            cur: s.char_offset_iter(),\n+            cur: s.char_indices(),\n             depth: 0,\n         }\n     }"}, {"sha": "0bc1aa89353538c8b9dde165003390a1df944fcd", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -736,7 +736,7 @@ impl<T:Hash + Eq> HashSet<T> {\n     }\n \n     /// Visit the values representing the difference\n-    pub fn difference_iter<'a>(&'a self, other: &'a HashSet<T>) -> SetAlgebraIter<'a, T> {\n+    pub fn difference<'a>(&'a self, other: &'a HashSet<T>) -> SetAlgebraIter<'a, T> {\n         Repeat::new(other)\n             .zip(self.iter())\n             .filter_map(|(other, elt)| {\n@@ -745,13 +745,13 @@ impl<T:Hash + Eq> HashSet<T> {\n     }\n \n     /// Visit the values representing the symmetric difference\n-    pub fn symmetric_difference_iter<'a>(&'a self, other: &'a HashSet<T>)\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T>)\n         -> Chain<SetAlgebraIter<'a, T>, SetAlgebraIter<'a, T>> {\n-        self.difference_iter(other).chain(other.difference_iter(self))\n+        self.difference(other).chain(other.difference(self))\n     }\n \n     /// Visit the values representing the intersection\n-    pub fn intersection_iter<'a>(&'a self, other: &'a HashSet<T>)\n+    pub fn intersection<'a>(&'a self, other: &'a HashSet<T>)\n         -> SetAlgebraIter<'a, T> {\n         Repeat::new(other)\n             .zip(self.iter())\n@@ -761,9 +761,9 @@ impl<T:Hash + Eq> HashSet<T> {\n     }\n \n     /// Visit the values representing the union\n-    pub fn union_iter<'a>(&'a self, other: &'a HashSet<T>)\n+    pub fn union<'a>(&'a self, other: &'a HashSet<T>)\n         -> Chain<HashSetIterator<'a, T>, SetAlgebraIter<'a, T>> {\n-        self.iter().chain(other.difference_iter(self))\n+        self.iter().chain(other.difference(self))\n     }\n \n }\n@@ -1114,7 +1114,7 @@ mod test_set {\n \n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n-        for x in a.intersection_iter(&b) {\n+        for x in a.intersection(&b) {\n             assert!(expected.contains(x));\n             i += 1\n         }\n@@ -1137,7 +1137,7 @@ mod test_set {\n \n         let mut i = 0;\n         let expected = [1, 5, 11];\n-        for x in a.difference_iter(&b) {\n+        for x in a.difference(&b) {\n             assert!(expected.contains(x));\n             i += 1\n         }\n@@ -1163,7 +1163,7 @@ mod test_set {\n \n         let mut i = 0;\n         let expected = [-2, 1, 5, 11, 14, 22];\n-        for x in a.symmetric_difference_iter(&b) {\n+        for x in a.symmetric_difference(&b) {\n             assert!(expected.contains(x));\n             i += 1\n         }\n@@ -1193,7 +1193,7 @@ mod test_set {\n \n         let mut i = 0;\n         let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n-        for x in a.union_iter(&b) {\n+        for x in a.union(&b) {\n             assert!(expected.contains(x));\n             i += 1\n         }"}, {"sha": "8f66215105a3b8643cc924b143165e8d30b03b1b", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -46,7 +46,7 @@ Some examples of obvious things you might want to do\n \n * Pull the lines of a file into a vector of strings\n \n-    let lines = File::open(\"message.txt\").line_iter().to_vec();\n+    let lines = File::open(\"message.txt\").lines().to_vec();\n \n * Make an simple HTTP request\n "}, {"sha": "6f726d1a45e551bccb705d78ba8c2149939b3d34", "filename": "src/libstd/io/native/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -315,7 +315,7 @@ pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n     return cmd;\n \n     fn append_arg(cmd: &mut ~str, arg: &str) {\n-        let quote = arg.iter().any(|c| c == ' ' || c == '\\t');\n+        let quote = arg.chars().any(|c| c == ' ' || c == '\\t');\n         if quote {\n             cmd.push_char('\"');\n         }"}, {"sha": "f45764996522497d1164f25721042f6fd592ad0e", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -200,7 +200,7 @@ pub fn env() -> ~[(~str,~str)] {\n         fn env_convert(input: ~[~str]) -> ~[(~str, ~str)] {\n             let mut pairs = ~[];\n             for p in input.iter() {\n-                let vs: ~[&str] = p.splitn_iter('=', 1).collect();\n+                let vs: ~[&str] = p.splitn('=', 1).collect();\n                 debug!(\"splitting: len: {}\", vs.len());\n                 assert_eq!(vs.len(), 2);\n                 pairs.push((vs[0].to_owned(), vs[1].to_owned()));"}, {"sha": "f58db55d4c5e0b1d7fc6db5295a8a97bda7c2873", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -20,7 +20,7 @@ appropriate platform-specific path variant.\n Both `PosixPath` and `WindowsPath` implement a trait `GenericPath`, which\n contains the set of methods that behave the same for both paths. They each also\n implement some methods that could not be expressed in `GenericPath`, yet behave\n-identically for both path flavors, such as `.component_iter()`.\n+identically for both path flavors, such as `.components()`.\n \n The three main design goals of this module are 1) to avoid unnecessary\n allocation, 2) to behave the same regardless of which flavor of path is being"}, {"sha": "dcd0829533174b2f6c8e3208e84d02d08174bf2b", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -233,8 +233,8 @@ impl GenericPath for Path {\n         if self.is_absolute() != other.is_absolute() {\n             false\n         } else {\n-            let mut ita = self.component_iter();\n-            let mut itb = other.component_iter();\n+            let mut ita = self.components();\n+            let mut itb = other.components();\n             if bytes!(\".\") == self.repr {\n                 return itb.next() != Some(bytes!(\"..\"));\n             }\n@@ -261,8 +261,8 @@ impl GenericPath for Path {\n                 None\n             }\n         } else {\n-            let mut ita = self.component_iter();\n-            let mut itb = base.component_iter();\n+            let mut ita = self.components();\n+            let mut itb = base.components();\n             let mut comps = ~[];\n             loop {\n                 match (ita.next(), itb.next()) {\n@@ -293,8 +293,8 @@ impl GenericPath for Path {\n \n     fn ends_with_path(&self, child: &Path) -> bool {\n         if !child.is_relative() { return false; }\n-        let mut selfit = self.rev_component_iter();\n-        let mut childit = child.rev_component_iter();\n+        let mut selfit = self.rev_components();\n+        let mut childit = child.rev_components();\n         loop {\n             match (selfit.next(), childit.next()) {\n                 (Some(a), Some(b)) => if a != b { return false; },\n@@ -367,11 +367,11 @@ impl Path {\n     /// Does not distinguish between absolute and relative paths, e.g.\n     /// /a/b/c and a/b/c yield the same set of components.\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n-    pub fn component_iter<'a>(&'a self) -> ComponentIter<'a> {\n+    pub fn components<'a>(&'a self) -> ComponentIter<'a> {\n         let v = if self.repr[0] == sep_byte {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n-        let mut ret = v.split_iter(is_sep_byte);\n+        let mut ret = v.split(is_sep_byte);\n         if v.is_empty() {\n             // consume the empty \"\" component\n             ret.next();\n@@ -380,12 +380,12 @@ impl Path {\n     }\n \n     /// Returns an iterator that yields each component of the path in reverse.\n-    /// See component_iter() for details.\n-    pub fn rev_component_iter<'a>(&'a self) -> RevComponentIter<'a> {\n+    /// See components() for details.\n+    pub fn rev_components<'a>(&'a self) -> RevComponentIter<'a> {\n         let v = if self.repr[0] == sep_byte {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n-        let mut ret = v.rsplit_iter(is_sep_byte);\n+        let mut ret = v.rsplit(is_sep_byte);\n         if v.is_empty() {\n             // consume the empty \"\" component\n             ret.next();\n@@ -394,15 +394,15 @@ impl Path {\n     }\n \n     /// Returns an iterator that yields each component of the path as Option<&str>.\n-    /// See component_iter() for details.\n-    pub fn str_component_iter<'a>(&'a self) -> StrComponentIter<'a> {\n-        self.component_iter().map(str::from_utf8_slice_opt)\n+    /// See components() for details.\n+    pub fn str_components<'a>(&'a self) -> StrComponentIter<'a> {\n+        self.components().map(str::from_utf8_slice_opt)\n     }\n \n     /// Returns an iterator that yields each component of the path in reverse as Option<&str>.\n-    /// See component_iter() for details.\n-    pub fn rev_str_component_iter<'a>(&'a self) -> RevStrComponentIter<'a> {\n-        self.rev_component_iter().map(str::from_utf8_slice_opt)\n+    /// See components() for details.\n+    pub fn rev_str_components<'a>(&'a self) -> RevStrComponentIter<'a> {\n+        self.rev_components().map(str::from_utf8_slice_opt)\n     }\n }\n \n@@ -414,7 +414,7 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<~[&'a [u8]]> {\n     let mut comps: ~[&'a [u8]] = ~[];\n     let mut n_up = 0u;\n     let mut changed = false;\n-    for comp in v.split_iter(is_sep_byte) {\n+    for comp in v.split(is_sep_byte) {\n         if comp.is_empty() { changed = true }\n         else if comp == bytes!(\".\") { changed = true }\n         else if comp == bytes!(\"..\") {\n@@ -1245,33 +1245,33 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_component_iter() {\n+    fn test_components_iter() {\n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    let comps = path.component_iter().to_owned_vec();\n+                    let comps = path.components().to_owned_vec();\n                     let exp: &[&str] = $exp;\n                     let exps = exp.iter().map(|x| x.as_bytes()).to_owned_vec();\n-                    assert!(comps == exps, \"component_iter: Expected {:?}, found {:?}\",\n+                    assert!(comps == exps, \"components: Expected {:?}, found {:?}\",\n                             comps, exps);\n-                    let comps = path.rev_component_iter().to_owned_vec();\n+                    let comps = path.rev_components().to_owned_vec();\n                     let exps = exps.move_rev_iter().to_owned_vec();\n-                    assert!(comps == exps, \"rev_component_iter: Expected {:?}, found {:?}\",\n+                    assert!(comps == exps, \"rev_components: Expected {:?}, found {:?}\",\n                             comps, exps);\n                 }\n             );\n             (v: [$($arg:expr),+], [$([$($exp:expr),*]),*]) => (\n                 {\n                     let path = Path::new(b!($($arg),+));\n-                    let comps = path.component_iter().to_owned_vec();\n+                    let comps = path.components().to_owned_vec();\n                     let exp: &[&[u8]] = [$(b!($($exp),*)),*];\n-                    assert!(comps.as_slice() == exp, \"component_iter: Expected {:?}, found {:?}\",\n+                    assert!(comps.as_slice() == exp, \"components: Expected {:?}, found {:?}\",\n                             comps.as_slice(), exp);\n-                    let comps = path.rev_component_iter().to_owned_vec();\n+                    let comps = path.rev_components().to_owned_vec();\n                     let exp = exp.rev_iter().map(|&x|x).to_owned_vec();\n                     assert!(comps.as_slice() == exp,\n-                            \"rev_component_iter: Expected {:?}, found {:?}\",\n+                            \"rev_components: Expected {:?}, found {:?}\",\n                             comps.as_slice(), exp);\n                 }\n             )\n@@ -1294,20 +1294,20 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_str_component_iter() {\n+    fn test_str_components() {\n         macro_rules! t(\n             (v: [$($arg:expr),+], $exp:expr) => (\n                 {\n                     let path = Path::new(b!($($arg),+));\n-                    let comps = path.str_component_iter().to_owned_vec();\n+                    let comps = path.str_components().to_owned_vec();\n                     let exp: &[Option<&str>] = $exp;\n                     assert!(comps.as_slice() == exp,\n-                            \"str_component_iter: Expected {:?}, found {:?}\",\n+                            \"str_components: Expected {:?}, found {:?}\",\n                             comps.as_slice(), exp);\n-                    let comps = path.rev_str_component_iter().to_owned_vec();\n+                    let comps = path.rev_str_components().to_owned_vec();\n                     let exp = exp.rev_iter().map(|&x|x).to_owned_vec();\n                     assert!(comps.as_slice() == exp,\n-                            \"rev_str_component_iter: Expected {:?}, found {:?}\",\n+                            \"rev_str_components: Expected {:?}, found {:?}\",\n                             comps.as_slice(), exp);\n                 }\n             )\n@@ -1316,7 +1316,7 @@ mod tests {\n         t!(v: [\"a/b/c\"], [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n         t!(v: [\"/\", 0xff, \"/a/\", 0x80], [None, Some(\"a\"), None]);\n         t!(v: [\"../../foo\", 0xcd, \"bar\"], [Some(\"..\"), Some(\"..\"), None]);\n-        // str_component_iter is a wrapper around component_iter, so no need to do\n+        // str_components is a wrapper around components, so no need to do\n         // the full set of tests\n     }\n }"}, {"sha": "4e736458fd8f27eeadf59822bd441ff6c6d3cd31", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -472,8 +472,8 @@ impl GenericPath for Path {\n                   is_vol_relative(self) != is_vol_relative(other) {\n             false\n         } else {\n-            let mut ita = self.str_component_iter().map(|x|x.unwrap());\n-            let mut itb = other.str_component_iter().map(|x|x.unwrap());\n+            let mut ita = self.str_components().map(|x|x.unwrap());\n+            let mut itb = other.str_components().map(|x|x.unwrap());\n             if \".\" == self.repr {\n                 return itb.next() != Some(\"..\");\n             }\n@@ -520,8 +520,8 @@ impl GenericPath for Path {\n                 None\n             }\n         } else {\n-            let mut ita = self.str_component_iter().map(|x|x.unwrap());\n-            let mut itb = base.str_component_iter().map(|x|x.unwrap());\n+            let mut ita = self.str_components().map(|x|x.unwrap());\n+            let mut itb = base.str_components().map(|x|x.unwrap());\n             let mut comps = ~[];\n \n             let a_verb = is_verbatim(self);\n@@ -569,8 +569,8 @@ impl GenericPath for Path {\n \n     fn ends_with_path(&self, child: &Path) -> bool {\n         if !child.is_relative() { return false; }\n-        let mut selfit = self.str_component_iter().invert();\n-        let mut childit = child.str_component_iter().invert();\n+        let mut selfit = self.str_components().invert();\n+        let mut childit = child.str_components().invert();\n         loop {\n             match (selfit.next(), childit.next()) {\n                 (Some(a), Some(b)) => if a != b { return false; },\n@@ -608,7 +608,7 @@ impl Path {\n     /// \\a\\b\\c and a\\b\\c.\n     /// Does not distinguish between absolute and cwd-relative paths, e.g.\n     /// C:\\foo and C:foo.\n-    pub fn str_component_iter<'a>(&'a self) -> StrComponentIter<'a> {\n+    pub fn str_components<'a>(&'a self) -> StrComponentIter<'a> {\n         let s = match self.prefix {\n             Some(_) => {\n                 let plen = self.prefix_len();\n@@ -619,34 +619,34 @@ impl Path {\n             None if self.repr[0] == sep as u8 => self.repr.slice_from(1),\n             None => self.repr.as_slice()\n         };\n-        let ret = s.split_terminator_iter(sep).map(Some);\n+        let ret = s.split_terminator(sep).map(Some);\n         ret\n     }\n \n     /// Returns an iterator that yields each component of the path in reverse as an Option<&str>\n-    /// See str_component_iter() for details.\n-    pub fn rev_str_component_iter<'a>(&'a self) -> RevStrComponentIter<'a> {\n-        self.str_component_iter().invert()\n+    /// See str_components() for details.\n+    pub fn rev_str_components<'a>(&'a self) -> RevStrComponentIter<'a> {\n+        self.str_components().invert()\n     }\n \n     /// Returns an iterator that yields each component of the path in turn as a &[u8].\n-    /// See str_component_iter() for details.\n-    pub fn component_iter<'a>(&'a self) -> ComponentIter<'a> {\n+    /// See str_components() for details.\n+    pub fn components<'a>(&'a self) -> ComponentIter<'a> {\n         fn convert<'a>(x: Option<&'a str>) -> &'a [u8] {\n             #[inline];\n             x.unwrap().as_bytes()\n         }\n-        self.str_component_iter().map(convert)\n+        self.str_components().map(convert)\n     }\n \n     /// Returns an iterator that yields each component of the path in reverse as a &[u8].\n-    /// See str_component_iter() for details.\n-    pub fn rev_component_iter<'a>(&'a self) -> RevComponentIter<'a> {\n+    /// See str_components() for details.\n+    pub fn rev_components<'a>(&'a self) -> RevComponentIter<'a> {\n         fn convert<'a>(x: Option<&'a str>) -> &'a [u8] {\n             #[inline];\n             x.unwrap().as_bytes()\n         }\n-        self.rev_str_component_iter().map(convert)\n+        self.rev_str_components().map(convert)\n     }\n \n     fn equiv_prefix(&self, other: &Path) -> bool {\n@@ -999,7 +999,7 @@ fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<\n     let mut comps: ~[&'a str] = ~[];\n     let mut n_up = 0u;\n     let mut changed = false;\n-    for comp in s_.split_iter(f) {\n+    for comp in s_.split(f) {\n         if comp.is_empty() { changed = true }\n         else if comp == \".\" { changed = true }\n         else if comp == \"..\" {\n@@ -2260,35 +2260,35 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_str_component_iter() {\n+    fn test_str_components() {\n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    let comps = path.str_component_iter().map(|x|x.unwrap()).to_owned_vec();\n+                    let comps = path.str_components().map(|x|x.unwrap()).to_owned_vec();\n                     let exp: &[&str] = $exp;\n                     assert!(comps.as_slice() == exp,\n-                            \"str_component_iter: Expected {:?}, found {:?}\",\n+                            \"str_components: Expected {:?}, found {:?}\",\n                             comps.as_slice(), exp);\n-                    let comps = path.rev_str_component_iter().map(|x|x.unwrap()).to_owned_vec();\n+                    let comps = path.rev_str_components().map(|x|x.unwrap()).to_owned_vec();\n                     let exp = exp.rev_iter().map(|&x|x).to_owned_vec();\n                     assert!(comps.as_slice() == exp,\n-                            \"rev_str_component_iter: Expected {:?}, found {:?}\",\n+                            \"rev_str_components: Expected {:?}, found {:?}\",\n                             comps.as_slice(), exp);\n                 }\n             );\n             (v: [$($arg:expr),+], $exp:expr) => (\n                 {\n                     let path = Path::new(b!($($arg),+));\n-                    let comps = path.str_component_iter().map(|x|x.unwrap()).to_owned_vec();\n+                    let comps = path.str_components().map(|x|x.unwrap()).to_owned_vec();\n                     let exp: &[&str] = $exp;\n                     assert!(comps.as_slice() == exp,\n-                            \"str_component_iter: Expected {:?}, found {:?}\",\n+                            \"str_components: Expected {:?}, found {:?}\",\n                             comps.as_slice(), exp);\n-                    let comps = path.rev_str_component_iter().map(|x|x.unwrap()).to_owned_vec();\n+                    let comps = path.rev_str_components().map(|x|x.unwrap()).to_owned_vec();\n                     let exp = exp.rev_iter().map(|&x|x).to_owned_vec();\n                     assert!(comps.as_slice() == exp,\n-                            \"rev_str_component_iter: Expected {:?}, found {:?}\",\n+                            \"rev_str_components: Expected {:?}, found {:?}\",\n                             comps.as_slice(), exp);\n                 }\n             )\n@@ -2335,26 +2335,26 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_component_iter() {\n+    fn test_components_iter() {\n         macro_rules! t(\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    let comps = path.component_iter().to_owned_vec();\n+                    let comps = path.components().to_owned_vec();\n                     let exp: &[&[u8]] = $exp;\n-                    assert!(comps.as_slice() == exp, \"component_iter: Expected {:?}, found {:?}\",\n+                    assert!(comps.as_slice() == exp, \"components: Expected {:?}, found {:?}\",\n                             comps.as_slice(), exp);\n-                    let comps = path.rev_component_iter().to_owned_vec();\n+                    let comps = path.rev_components().to_owned_vec();\n                     let exp = exp.rev_iter().map(|&x|x).to_owned_vec();\n                     assert!(comps.as_slice() == exp,\n-                            \"rev_component_iter: Expected {:?}, found {:?}\",\n+                            \"rev_components: Expected {:?}, found {:?}\",\n                             comps.as_slice(), exp);\n                 }\n             )\n         )\n \n         t!(s: \"a\\\\b\\\\c\", [b!(\"a\"), b!(\"b\"), b!(\"c\")]);\n         t!(s: \".\", [b!(\".\")]);\n-        // since this is really a wrapper around str_component_iter, those tests suffice\n+        // since this is really a wrapper around str_components, those tests suffice\n     }\n }"}, {"sha": "d30d08870665a6db77be65703b810e916f39cebf", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -170,7 +170,7 @@ impl<'self> ReprVisitor<'self> {\n \n     pub fn write_escaped_slice(&mut self, slice: &str) {\n         self.writer.write(['\"' as u8]);\n-        for ch in slice.iter() {\n+        for ch in slice.chars() {\n             self.write_escaped_char(ch, true);\n         }\n         self.writer.write(['\"' as u8]);"}, {"sha": "2c78a32a4b6cbb2fd4dfe2400de7175da050895f", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -17,7 +17,7 @@ use rt::env;\n use rt::local::Local;\n use rt::task;\n use rt::task::Task;\n-use str::{OwnedStr, StrSlice};\n+use str::OwnedStr;\n use str;\n use uint;\n use unstable::raw;"}, {"sha": "2ca47dbff59dcf7c1771d5beeb6e3b5711bd7adc", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -63,8 +63,8 @@ fn parse_log_level(level: &str) -> Option<u32> {\n /// Also supports string log levels of error, warn, info, and debug\n fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n     let mut dirs = ~[];\n-    for s in spec.split_iter(',') {\n-        let parts: ~[&str] = s.split_iter('=').collect();\n+    for s in spec.split(',') {\n+        let parts: ~[&str] = s.split('=').collect();\n         let mut log_level;\n         let mut name = Some(parts[0].to_owned());\n         match parts.len() {"}, {"sha": "93721986f3c259d88d89aea9f442165a38a4ffb8", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -77,7 +77,7 @@ pub fn dumb_println(args: &fmt::Arguments) {\n \n pub fn abort(msg: &str) -> ! {\n     let msg = if !msg.is_empty() { msg } else { \"aborted\" };\n-    let hash = msg.iter().fold(0, |accum, val| accum + (val as uint) );\n+    let hash = msg.chars().fold(0, |accum, val| accum + (val as uint) );\n     let quote = match hash % 10 {\n         0 => \"\n It was from the artists and poets that the pertinent answers came, and I"}, {"sha": "3582782fc5ecdf1fea2f24e39f6e5a98f089e0da", "filename": "src/libstd/str.rs", "status": "modified", "additions": 169, "deletions": 169, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -508,14 +508,14 @@ impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitIterator<'self, Sep>\n \n         let mut next_split = None;\n         if self.only_ascii {\n-            for (idx, byte) in self.string.byte_iter().enumerate() {\n+            for (idx, byte) in self.string.bytes().enumerate() {\n                 if self.sep.matches(byte as char) && byte < 128u8 {\n                     next_split = Some((idx, idx + 1));\n                     break;\n                 }\n             }\n         } else {\n-            for (idx, ch) in self.string.char_offset_iter() {\n+            for (idx, ch) in self.string.char_indices() {\n                 if self.sep.matches(ch) {\n                     next_split = Some((idx, self.string.char_range_at(idx).next));\n                     break;\n@@ -550,14 +550,14 @@ for CharSplitIterator<'self, Sep> {\n         let mut next_split = None;\n \n         if self.only_ascii {\n-            for (idx, byte) in self.string.byte_iter().enumerate().invert() {\n+            for (idx, byte) in self.string.bytes().enumerate().invert() {\n                 if self.sep.matches(byte as char) && byte < 128u8 {\n                     next_split = Some((idx, idx + 1));\n                     break;\n                 }\n             }\n         } else {\n-            for (idx, ch) in self.string.char_offset_rev_iter() {\n+            for (idx, ch) in self.string.char_indices_rev() {\n                 if self.sep.matches(ch) {\n                     next_split = Some((idx, self.string.char_range_at(idx).next));\n                     break;\n@@ -763,7 +763,7 @@ impl<'self> Iterator<char> for NormalizationIterator<'self> {\n pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\";\n     let mut last_end = 0;\n-    for (start, end) in s.matches_index_iter(from) {\n+    for (start, end) in s.match_indices(from) {\n         result.push_str(unsafe{raw::slice_bytes(s, last_end, start)});\n         result.push_str(to);\n         last_end = end;\n@@ -1211,7 +1211,7 @@ pub mod traits {\n     impl<'self> TotalOrd for &'self str {\n         #[inline]\n         fn cmp(&self, other: & &'self str) -> Ordering {\n-            for (s_b, o_b) in self.byte_iter().zip(other.byte_iter()) {\n+            for (s_b, o_b) in self.bytes().zip(other.bytes()) {\n                 match s_b.cmp(&o_b) {\n                     Greater => return Greater,\n                     Less => return Less,\n@@ -1397,107 +1397,107 @@ pub trait StrSlice<'self> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".iter().collect();\n+    /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n     /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n-    fn iter(&self) -> CharIterator<'self>;\n+    fn chars(&self) -> CharIterator<'self>;\n \n     /// An iterator over the characters of `self`, in reverse order.\n-    fn rev_iter(&self) -> CharRevIterator<'self>;\n+    fn chars_rev(&self) -> CharRevIterator<'self>;\n \n     /// An iterator over the bytes of `self`\n-    fn byte_iter(&self) -> ByteIterator<'self>;\n+    fn bytes(&self) -> ByteIterator<'self>;\n \n     /// An iterator over the bytes of `self`, in reverse order\n-    fn byte_rev_iter(&self) -> ByteRevIterator<'self>;\n+    fn bytes_rev(&self) -> ByteRevIterator<'self>;\n \n     /// An iterator over the characters of `self` and their byte offsets.\n-    fn char_offset_iter(&self) -> CharOffsetIterator<'self>;\n+    fn char_indices(&self) -> CharOffsetIterator<'self>;\n \n     /// An iterator over the characters of `self` and their byte offsets,\n     /// in reverse order.\n-    fn char_offset_rev_iter(&self) -> CharOffsetRevIterator<'self>;\n+    fn char_indices_rev(&self) -> CharOffsetRevIterator<'self>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lamb\".split_iter(' ').collect();\n+    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').collect();\n     /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".split_iter(|c: char| c.is_digit()).collect();\n+    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).collect();\n     /// assert_eq!(v, ~[\"abc\", \"def\", \"ghi\"]);\n     /// ```\n-    fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, restricted to splitting at most `count`\n     /// times.\n-    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n+    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n     ///\n-    /// Equivalent to `split_iter`, except that the trailing substring\n+    /// Equivalent to `split`, except that the trailing substring\n     /// is skipped if empty (terminator semantics).\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"A.B.\".split_terminator_iter('.').collect();\n+    /// let v: ~[&str] = \"A.B.\".split_terminator('.').collect();\n     /// assert_eq!(v, ~[\"A\", \"B\"]);\n     /// ```\n-    fn split_terminator_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n+    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, in reverse order\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lamb\".rsplit_iter(' ').collect();\n+    /// let v: ~[&str] = \"Mary had a little lamb\".rsplit(' ').collect();\n     /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     /// ```\n-    fn rsplit_iter<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep>;\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, starting from the end of the string.\n     /// Restricted to splitting at most `count` times.\n-    fn rsplitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n+    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n \n     /// An iterator over the start and end indices of each match of\n     /// `sep` within `self`.\n-    fn matches_index_iter(&self, sep: &'self str) -> MatchesIndexIterator<'self>;\n+    fn match_indices(&self, sep: &'self str) -> MatchesIndexIterator<'self>;\n \n     /// An iterator over the substrings of `self` separated by `sep`.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str_iter(\"abc\").collect()\n+    /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str(\"abc\").collect()\n     /// assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n     /// ```\n-    fn split_str_iter(&self, &'self str) -> StrSplitIterator<'self>;\n+    fn split_str(&self, &'self str) -> StrSplitIterator<'self>;\n \n     /// An iterator over the lines of a string (subsequences separated\n     /// by `\\n`).\n-    fn line_iter(&self) -> CharSplitIterator<'self, char>;\n+    fn lines(&self) -> CharSplitIterator<'self, char>;\n \n     /// An iterator over the lines of a string, separated by either\n     /// `\\n` or (`\\r\\n`).\n-    fn any_line_iter(&self) -> AnyLineIterator<'self>;\n+    fn lines_any(&self) -> AnyLineIterator<'self>;\n \n     /// An iterator over the words of a string (subsequences separated\n     /// by any sequence of whitespace).\n-    fn word_iter(&self) -> WordIterator<'self>;\n+    fn words(&self) -> WordIterator<'self>;\n \n     /// An Iterator over the string in Unicode Normalization Form D (canonical decomposition)\n-    fn nfd_iter(&self) -> NormalizationIterator<'self>;\n+    fn nfd_chars(&self) -> NormalizationIterator<'self>;\n \n     /// An Iterator over the string in Unicode Normalization Form KD (compatibility decomposition)\n-    fn nfkd_iter(&self) -> NormalizationIterator<'self>;\n+    fn nfkd_chars(&self) -> NormalizationIterator<'self>;\n \n     /// Returns true if the string contains only whitespace\n     ///\n@@ -1751,7 +1751,7 @@ pub trait StrSlice<'self> {\n     /// ```rust\n     /// let string = \"a\\nb\\nc\";\n     /// let mut lines = ~[];\n-    /// for line in string.line_iter() { lines.push(line) }\n+    /// for line in string.lines() { lines.push(line) }\n     ///\n     /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n@@ -1777,37 +1777,37 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn iter(&self) -> CharIterator<'self> {\n+    fn chars(&self) -> CharIterator<'self> {\n         CharIterator{string: *self}\n     }\n \n     #[inline]\n-    fn rev_iter(&self) -> CharRevIterator<'self> {\n-        self.iter().invert()\n+    fn chars_rev(&self) -> CharRevIterator<'self> {\n+        self.chars().invert()\n     }\n \n     #[inline]\n-    fn byte_iter(&self) -> ByteIterator<'self> {\n+    fn bytes(&self) -> ByteIterator<'self> {\n         self.as_bytes().iter().map(|&b| b)\n     }\n \n     #[inline]\n-    fn byte_rev_iter(&self) -> ByteRevIterator<'self> {\n-        self.byte_iter().invert()\n+    fn bytes_rev(&self) -> ByteRevIterator<'self> {\n+        self.bytes().invert()\n     }\n \n     #[inline]\n-    fn char_offset_iter(&self) -> CharOffsetIterator<'self> {\n-        CharOffsetIterator{string: *self, iter: self.iter()}\n+    fn char_indices(&self) -> CharOffsetIterator<'self> {\n+        CharOffsetIterator{string: *self, iter: self.chars()}\n     }\n \n     #[inline]\n-    fn char_offset_rev_iter(&self) -> CharOffsetRevIterator<'self> {\n-        self.char_offset_iter().invert()\n+    fn char_indices_rev(&self) -> CharOffsetRevIterator<'self> {\n+        self.char_indices().invert()\n     }\n \n     #[inline]\n-    fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep> {\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep> {\n         CharSplitIterator {\n             string: *self,\n             only_ascii: sep.only_ascii(),\n@@ -1818,41 +1818,41 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint)\n+    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n         -> CharSplitNIterator<'self, Sep> {\n         CharSplitNIterator {\n-            iter: self.split_iter(sep),\n+            iter: self.split(sep),\n             count: count,\n             invert: false,\n         }\n     }\n \n     #[inline]\n-    fn split_terminator_iter<Sep: CharEq>(&self, sep: Sep)\n+    fn split_terminator<Sep: CharEq>(&self, sep: Sep)\n         -> CharSplitIterator<'self, Sep> {\n         CharSplitIterator {\n             allow_trailing_empty: false,\n-            ..self.split_iter(sep)\n+            ..self.split(sep)\n         }\n     }\n \n     #[inline]\n-    fn rsplit_iter<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep> {\n-        self.split_iter(sep).invert()\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep> {\n+        self.split(sep).invert()\n     }\n \n     #[inline]\n-    fn rsplitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint)\n+    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n         -> CharSplitNIterator<'self, Sep> {\n         CharSplitNIterator {\n-            iter: self.split_iter(sep),\n+            iter: self.split(sep),\n             count: count,\n             invert: true,\n         }\n     }\n \n     #[inline]\n-    fn matches_index_iter(&self, sep: &'self str) -> MatchesIndexIterator<'self> {\n+    fn match_indices(&self, sep: &'self str) -> MatchesIndexIterator<'self> {\n         assert!(!sep.is_empty())\n         MatchesIndexIterator {\n             haystack: *self,\n@@ -1862,60 +1862,60 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn split_str_iter(&self, sep: &'self str) -> StrSplitIterator<'self> {\n+    fn split_str(&self, sep: &'self str) -> StrSplitIterator<'self> {\n         StrSplitIterator {\n-            it: self.matches_index_iter(sep),\n+            it: self.match_indices(sep),\n             last_end: 0,\n             finished: false\n         }\n     }\n \n     #[inline]\n-    fn line_iter(&self) -> CharSplitIterator<'self, char> {\n-        self.split_terminator_iter('\\n')\n+    fn lines(&self) -> CharSplitIterator<'self, char> {\n+        self.split_terminator('\\n')\n     }\n \n-    fn any_line_iter(&self) -> AnyLineIterator<'self> {\n-        do self.line_iter().map |line| {\n+    fn lines_any(&self) -> AnyLineIterator<'self> {\n+        do self.lines().map |line| {\n             let l = line.len();\n             if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n             else { line }\n         }\n     }\n \n     #[inline]\n-    fn word_iter(&self) -> WordIterator<'self> {\n-        self.split_iter(char::is_whitespace).filter(|s| !s.is_empty())\n+    fn words(&self) -> WordIterator<'self> {\n+        self.split(char::is_whitespace).filter(|s| !s.is_empty())\n     }\n \n     #[inline]\n-    fn nfd_iter(&self) -> NormalizationIterator<'self> {\n+    fn nfd_chars(&self) -> NormalizationIterator<'self> {\n         NormalizationIterator {\n-            iter: self.iter(),\n+            iter: self.chars(),\n             buffer: ~[],\n             sorted: false,\n             kind: NFD\n         }\n     }\n \n     #[inline]\n-    fn nfkd_iter(&self) -> NormalizationIterator<'self> {\n+    fn nfkd_chars(&self) -> NormalizationIterator<'self> {\n         NormalizationIterator {\n-            iter: self.iter(),\n+            iter: self.chars(),\n             buffer: ~[],\n             sorted: false,\n             kind: NFKD\n         }\n     }\n \n     #[inline]\n-    fn is_whitespace(&self) -> bool { self.iter().all(char::is_whitespace) }\n+    fn is_whitespace(&self) -> bool { self.chars().all(char::is_whitespace) }\n \n     #[inline]\n-    fn is_alphanumeric(&self) -> bool { self.iter().all(char::is_alphanumeric) }\n+    fn is_alphanumeric(&self) -> bool { self.chars().all(char::is_alphanumeric) }\n \n     #[inline]\n-    fn char_len(&self) -> uint { self.iter().len() }\n+    fn char_len(&self) -> uint { self.chars().len() }\n \n     #[inline]\n     fn slice(&self, begin: uint, end: uint) -> &'self str {\n@@ -1942,7 +1942,7 @@ impl<'self> StrSlice<'self> for &'self str {\n \n         // This could be even more efficient by not decoding,\n         // only finding the char boundaries\n-        for (idx, _) in self.char_offset_iter() {\n+        for (idx, _) in self.char_indices() {\n             if count == begin { begin_byte = Some(idx); }\n             if count == end { end_byte = Some(idx); break; }\n             count += 1;\n@@ -1972,7 +1972,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn escape_default(&self) -> ~str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n-        for c in self.iter() {\n+        for c in self.chars() {\n             do c.escape_default |c| {\n                 out.push_char(c);\n             }\n@@ -1983,7 +1983,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn escape_unicode(&self) -> ~str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n-        for c in self.iter() {\n+        for c in self.chars() {\n             do c.escape_unicode |c| {\n                 out.push_char(c);\n             }\n@@ -2033,7 +2033,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn replace(&self, from: &str, to: &str) -> ~str {\n         let mut result = ~\"\";\n         let mut last_end = 0;\n-        for (start, end) in self.matches_index_iter(from) {\n+        for (start, end) in self.match_indices(from) {\n             result.push_str(unsafe{raw::slice_bytes(*self, last_end, start)});\n             result.push_str(to);\n             last_end = end;\n@@ -2067,7 +2067,7 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     fn to_utf16(&self) -> ~[u16] {\n         let mut u = ~[];\n-        for ch in self.iter() {\n+        for ch in self.chars() {\n             // Arithmetic with u32 literals is easier on the eyes than chars.\n             let mut ch = ch as u32;\n \n@@ -2172,9 +2172,9 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n         if search.only_ascii() {\n-            self.byte_iter().position(|b| search.matches(b as char))\n+            self.bytes().position(|b| search.matches(b as char))\n         } else {\n-            for (index, c) in self.char_offset_iter() {\n+            for (index, c) in self.char_indices() {\n                 if search.matches(c) { return Some(index); }\n             }\n             None\n@@ -2183,9 +2183,9 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n         if search.only_ascii() {\n-            self.byte_iter().rposition(|b| search.matches(b as char))\n+            self.bytes().rposition(|b| search.matches(b as char))\n         } else {\n-            for (index, c) in self.char_offset_rev_iter() {\n+            for (index, c) in self.char_indices_rev() {\n                 if search.matches(c) { return Some(index); }\n             }\n             None\n@@ -2196,7 +2196,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         if needle.is_empty() {\n             Some(0)\n         } else {\n-            self.matches_index_iter(needle)\n+            self.match_indices(needle)\n                 .next()\n                 .map(|(start, _end)| start)\n         }\n@@ -2226,12 +2226,12 @@ impl<'self> StrSlice<'self> for &'self str {\n \n         let mut dcol = vec::from_fn(tlen + 1, |x| x);\n \n-        for (i, sc) in self.iter().enumerate() {\n+        for (i, sc) in self.chars().enumerate() {\n \n             let mut current = i;\n             dcol[0] = current + 1;\n \n-            for (j, tc) in t.iter().enumerate() {\n+            for (j, tc) in t.chars().enumerate() {\n \n                 let next = dcol[j + 1];\n \n@@ -2674,10 +2674,10 @@ mod tests {\n     #[test]\n     fn test_collect() {\n         let empty = ~\"\";\n-        let s: ~str = empty.iter().collect();\n+        let s: ~str = empty.chars().collect();\n         assert_eq!(empty, s);\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-        let s: ~str = data.iter().collect();\n+        let s: ~str = data.chars().collect();\n         assert_eq!(data, s);\n     }\n \n@@ -2686,7 +2686,7 @@ mod tests {\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n         let mut cpy = data.clone();\n         let other = \"abc\";\n-        let mut it = other.iter();\n+        let mut it = other.chars();\n         cpy.extend(&mut it);\n         assert_eq!(cpy, data + other);\n     }\n@@ -3227,7 +3227,7 @@ mod tests {\n \n         let string = \"a\\nb\\nc\";\n         let mut lines = ~[];\n-        for line in string.line_iter() { lines.push(line) }\n+        for line in string.lines() { lines.push(line) }\n         assert_eq!(string.subslice_offset(lines[0]), 0);\n         assert_eq!(string.subslice_offset(lines[1]), 2);\n         assert_eq!(string.subslice_offset(lines[2]), 4);\n@@ -3443,7 +3443,7 @@ mod tests {\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n \n         let mut pos = 0;\n-        let mut it = s.iter();\n+        let mut it = s.chars();\n \n         for c in it {\n             assert_eq!(c, v[pos]);\n@@ -3459,7 +3459,7 @@ mod tests {\n         let v = ~['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n-        let mut it = s.rev_iter();\n+        let mut it = s.chars_rev();\n \n         for c in it {\n             assert_eq!(c, v[pos]);\n@@ -3471,13 +3471,13 @@ mod tests {\n     #[test]\n     fn test_iterator_clone() {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let mut it = s.iter();\n+        let mut it = s.chars();\n         it.next();\n         assert!(it.zip(it.clone()).all(|(x,y)| x == y));\n     }\n \n     #[test]\n-    fn test_byte_iterator() {\n+    fn test_bytesator() {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = [\n             224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n@@ -3486,14 +3486,14 @@ mod tests {\n         ];\n         let mut pos = 0;\n \n-        for b in s.byte_iter() {\n+        for b in s.bytes() {\n             assert_eq!(b, v[pos]);\n             pos += 1;\n         }\n     }\n \n     #[test]\n-    fn test_byte_rev_iterator() {\n+    fn test_bytes_revator() {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = [\n             224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n@@ -3502,21 +3502,21 @@ mod tests {\n         ];\n         let mut pos = v.len();\n \n-        for b in s.byte_rev_iter() {\n+        for b in s.bytes_rev() {\n             pos -= 1;\n             assert_eq!(b, v[pos]);\n         }\n     }\n \n     #[test]\n-    fn test_char_offset_iterator() {\n+    fn test_char_indicesator() {\n         use iter::*;\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let p = [0, 3, 6, 9, 12, 15, 18, 19, 20, 23, 24, 25, 26, 27];\n         let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n \n         let mut pos = 0;\n-        let mut it = s.char_offset_iter();\n+        let mut it = s.char_indices();\n \n         for c in it {\n             assert_eq!(c, (p[pos], v[pos]));\n@@ -3527,14 +3527,14 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_char_offset_rev_iterator() {\n+    fn test_char_indices_revator() {\n         use iter::*;\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let p = [27, 26, 25, 24, 23, 20, 19, 18, 15, 12, 9, 6, 3, 0];\n         let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n-        let mut it = s.char_offset_rev_iter();\n+        let mut it = s.char_indices_rev();\n \n         for c in it {\n             assert_eq!(c, (p[pos], v[pos]));\n@@ -3548,32 +3548,32 @@ mod tests {\n     fn test_split_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let split: ~[&str] = data.split_iter(' ').collect();\n+        let split: ~[&str] = data.split(' ').collect();\n         assert_eq!( split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.rsplit_iter(' ').collect();\n+        let mut rsplit: ~[&str] = data.rsplit(' ').collect();\n         rsplit.reverse();\n         assert_eq!(rsplit, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let split: ~[&str] = data.split_iter(|c: char| c == ' ').collect();\n+        let split: ~[&str] = data.split(|c: char| c == ' ').collect();\n         assert_eq!( split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.rsplit_iter(|c: char| c == ' ').collect();\n+        let mut rsplit: ~[&str] = data.rsplit(|c: char| c == ' ').collect();\n         rsplit.reverse();\n         assert_eq!(rsplit, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n-        let split: ~[&str] = data.split_iter('\u00e4').collect();\n+        let split: ~[&str] = data.split('\u00e4').collect();\n         assert_eq!( split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.rsplit_iter('\u00e4').collect();\n+        let mut rsplit: ~[&str] = data.rsplit('\u00e4').collect();\n         rsplit.reverse();\n         assert_eq!(rsplit, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let split: ~[&str] = data.split_iter(|c: char| c == '\u00e4').collect();\n+        let split: ~[&str] = data.split(|c: char| c == '\u00e4').collect();\n         assert_eq!( split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.rsplit_iter(|c: char| c == '\u00e4').collect();\n+        let mut rsplit: ~[&str] = data.rsplit(|c: char| c == '\u00e4').collect();\n         rsplit.reverse();\n         assert_eq!(rsplit, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n@@ -3582,38 +3582,38 @@ mod tests {\n     fn test_splitn_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let split: ~[&str] = data.splitn_iter(' ', 3).collect();\n+        let split: ~[&str] = data.splitn(' ', 3).collect();\n         assert_eq!(split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-        let split: ~[&str] = data.splitn_iter(|c: char| c == ' ', 3).collect();\n+        let split: ~[&str] = data.splitn(|c: char| c == ' ', 3).collect();\n         assert_eq!(split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         // Unicode\n-        let split: ~[&str] = data.splitn_iter('\u00e4', 3).collect();\n+        let split: ~[&str] = data.splitn('\u00e4', 3).collect();\n         assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-        let split: ~[&str] = data.splitn_iter(|c: char| c == '\u00e4', 3).collect();\n+        let split: ~[&str] = data.splitn(|c: char| c == '\u00e4', 3).collect();\n         assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n     }\n \n     #[test]\n     fn test_rsplitn_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let mut split: ~[&str] = data.rsplitn_iter(' ', 3).collect();\n+        let mut split: ~[&str] = data.rsplitn(' ', 3).collect();\n         split.reverse();\n         assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut split: ~[&str] = data.rsplitn_iter(|c: char| c == ' ', 3).collect();\n+        let mut split: ~[&str] = data.rsplitn(|c: char| c == ' ', 3).collect();\n         split.reverse();\n         assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n-        let mut split: ~[&str] = data.rsplitn_iter('\u00e4', 3).collect();\n+        let mut split: ~[&str] = data.rsplitn('\u00e4', 3).collect();\n         split.reverse();\n         assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut split: ~[&str] = data.rsplitn_iter(|c: char| c == '\u00e4', 3).collect();\n+        let mut split: ~[&str] = data.rsplitn(|c: char| c == '\u00e4', 3).collect();\n         split.reverse();\n         assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n@@ -3622,76 +3622,76 @@ mod tests {\n     fn test_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let split: ~[&str] = data.split_iter('\\n').collect();\n+        let split: ~[&str] = data.split('\\n').collect();\n         assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n-        let split: ~[&str] = data.split_terminator_iter('\\n').collect();\n+        let split: ~[&str] = data.split_terminator('\\n').collect();\n         assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n     fn test_rev_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let mut split: ~[&str] = data.split_iter('\\n').invert().collect();\n+        let mut split: ~[&str] = data.split('\\n').invert().collect();\n         split.reverse();\n         assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n-        let mut split: ~[&str] = data.split_terminator_iter('\\n').invert().collect();\n+        let mut split: ~[&str] = data.split_terminator('\\n').invert().collect();\n         split.reverse();\n         assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n-    fn test_word_iter() {\n+    fn test_words() {\n         let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-        let words: ~[&str] = data.word_iter().collect();\n+        let words: ~[&str] = data.words().collect();\n         assert_eq!(words, ~[\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n     }\n \n     #[test]\n-    fn test_nfd_iter() {\n-        assert_eq!(\"abc\".nfd_iter().collect::<~str>(), ~\"abc\");\n-        assert_eq!(\"\\u1e0b\\u01c4\".nfd_iter().collect::<~str>(), ~\"d\\u0307\\u01c4\");\n-        assert_eq!(\"\\u2026\".nfd_iter().collect::<~str>(), ~\"\\u2026\");\n-        assert_eq!(\"\\u2126\".nfd_iter().collect::<~str>(), ~\"\\u03a9\");\n-        assert_eq!(\"\\u1e0b\\u0323\".nfd_iter().collect::<~str>(), ~\"d\\u0323\\u0307\");\n-        assert_eq!(\"\\u1e0d\\u0307\".nfd_iter().collect::<~str>(), ~\"d\\u0323\\u0307\");\n-        assert_eq!(\"a\\u0301\".nfd_iter().collect::<~str>(), ~\"a\\u0301\");\n-        assert_eq!(\"\\u0301a\".nfd_iter().collect::<~str>(), ~\"\\u0301a\");\n-        assert_eq!(\"\\ud4db\".nfd_iter().collect::<~str>(), ~\"\\u1111\\u1171\\u11b6\");\n-        assert_eq!(\"\\uac1c\".nfd_iter().collect::<~str>(), ~\"\\u1100\\u1162\");\n+    fn test_nfd_chars() {\n+        assert_eq!(\"abc\".nfd_chars().collect::<~str>(), ~\"abc\");\n+        assert_eq!(\"\\u1e0b\\u01c4\".nfd_chars().collect::<~str>(), ~\"d\\u0307\\u01c4\");\n+        assert_eq!(\"\\u2026\".nfd_chars().collect::<~str>(), ~\"\\u2026\");\n+        assert_eq!(\"\\u2126\".nfd_chars().collect::<~str>(), ~\"\\u03a9\");\n+        assert_eq!(\"\\u1e0b\\u0323\".nfd_chars().collect::<~str>(), ~\"d\\u0323\\u0307\");\n+        assert_eq!(\"\\u1e0d\\u0307\".nfd_chars().collect::<~str>(), ~\"d\\u0323\\u0307\");\n+        assert_eq!(\"a\\u0301\".nfd_chars().collect::<~str>(), ~\"a\\u0301\");\n+        assert_eq!(\"\\u0301a\".nfd_chars().collect::<~str>(), ~\"\\u0301a\");\n+        assert_eq!(\"\\ud4db\".nfd_chars().collect::<~str>(), ~\"\\u1111\\u1171\\u11b6\");\n+        assert_eq!(\"\\uac1c\".nfd_chars().collect::<~str>(), ~\"\\u1100\\u1162\");\n     }\n \n     #[test]\n-    fn test_nfkd_iter() {\n-        assert_eq!(\"abc\".nfkd_iter().collect::<~str>(), ~\"abc\");\n-        assert_eq!(\"\\u1e0b\\u01c4\".nfkd_iter().collect::<~str>(), ~\"d\\u0307DZ\\u030c\");\n-        assert_eq!(\"\\u2026\".nfkd_iter().collect::<~str>(), ~\"...\");\n-        assert_eq!(\"\\u2126\".nfkd_iter().collect::<~str>(), ~\"\\u03a9\");\n-        assert_eq!(\"\\u1e0b\\u0323\".nfkd_iter().collect::<~str>(), ~\"d\\u0323\\u0307\");\n-        assert_eq!(\"\\u1e0d\\u0307\".nfkd_iter().collect::<~str>(), ~\"d\\u0323\\u0307\");\n-        assert_eq!(\"a\\u0301\".nfkd_iter().collect::<~str>(), ~\"a\\u0301\");\n-        assert_eq!(\"\\u0301a\".nfkd_iter().collect::<~str>(), ~\"\\u0301a\");\n-        assert_eq!(\"\\ud4db\".nfkd_iter().collect::<~str>(), ~\"\\u1111\\u1171\\u11b6\");\n-        assert_eq!(\"\\uac1c\".nfkd_iter().collect::<~str>(), ~\"\\u1100\\u1162\");\n+    fn test_nfkd_chars() {\n+        assert_eq!(\"abc\".nfkd_chars().collect::<~str>(), ~\"abc\");\n+        assert_eq!(\"\\u1e0b\\u01c4\".nfkd_chars().collect::<~str>(), ~\"d\\u0307DZ\\u030c\");\n+        assert_eq!(\"\\u2026\".nfkd_chars().collect::<~str>(), ~\"...\");\n+        assert_eq!(\"\\u2126\".nfkd_chars().collect::<~str>(), ~\"\\u03a9\");\n+        assert_eq!(\"\\u1e0b\\u0323\".nfkd_chars().collect::<~str>(), ~\"d\\u0323\\u0307\");\n+        assert_eq!(\"\\u1e0d\\u0307\".nfkd_chars().collect::<~str>(), ~\"d\\u0323\\u0307\");\n+        assert_eq!(\"a\\u0301\".nfkd_chars().collect::<~str>(), ~\"a\\u0301\");\n+        assert_eq!(\"\\u0301a\".nfkd_chars().collect::<~str>(), ~\"\\u0301a\");\n+        assert_eq!(\"\\ud4db\".nfkd_chars().collect::<~str>(), ~\"\\u1111\\u1171\\u11b6\");\n+        assert_eq!(\"\\uac1c\".nfkd_chars().collect::<~str>(), ~\"\\u1100\\u1162\");\n     }\n \n     #[test]\n-    fn test_line_iter() {\n+    fn test_lines() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-        let lines: ~[&str] = data.line_iter().collect();\n+        let lines: ~[&str] = data.lines().collect();\n         assert_eq!(lines, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n \n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\"; // no trailing \\n\n-        let lines: ~[&str] = data.line_iter().collect();\n+        let lines: ~[&str] = data.lines().collect();\n         assert_eq!(lines, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n-    fn test_split_str_iterator() {\n+    fn test_split_strator() {\n         fn t<'a>(s: &str, sep: &'a str, u: ~[&str]) {\n-            let v: ~[&str] = s.split_str_iter(sep).collect();\n+            let v: ~[&str] = s.split_str(sep).collect();\n             assert_eq!(v, u);\n         }\n         t(\"--1233345--\", \"12345\", ~[\"--1233345--\"]);\n@@ -3865,7 +3865,7 @@ mod bench {\n         let len = s.char_len();\n \n         do bh.iter {\n-            assert_eq!(s.iter().len(), len);\n+            assert_eq!(s.chars().len(), len);\n         }\n     }\n \n@@ -3880,7 +3880,7 @@ mod bench {\n         let len = s.char_len();\n \n         do bh.iter {\n-            assert_eq!(s.iter().len(), len);\n+            assert_eq!(s.chars().len(), len);\n         }\n     }\n \n@@ -3890,41 +3890,41 @@ mod bench {\n         let len = s.char_len();\n \n         do bh.iter {\n-            assert_eq!(s.rev_iter().len(), len);\n+            assert_eq!(s.chars_rev().len(), len);\n         }\n     }\n \n     #[bench]\n-    fn char_offset_iterator(bh: &mut BenchHarness) {\n+    fn char_indicesator(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n         do bh.iter {\n-            assert_eq!(s.char_offset_iter().len(), len);\n+            assert_eq!(s.char_indices().len(), len);\n         }\n     }\n \n     #[bench]\n-    fn char_offset_iterator_rev(bh: &mut BenchHarness) {\n+    fn char_indicesator_rev(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n         do bh.iter {\n-            assert_eq!(s.char_offset_rev_iter().len(), len);\n+            assert_eq!(s.char_indices_rev().len(), len);\n         }\n     }\n \n     #[bench]\n-    fn split_iter_unicode_ascii(bh: &mut BenchHarness) {\n+    fn split_unicode_ascii(bh: &mut BenchHarness) {\n         let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n \n         do bh.iter {\n-            assert_eq!(s.split_iter('V').len(), 3);\n+            assert_eq!(s.split('V').len(), 3);\n         }\n     }\n \n     #[bench]\n-    fn split_iter_unicode_not_ascii(bh: &mut BenchHarness) {\n+    fn split_unicode_not_ascii(bh: &mut BenchHarness) {\n         struct NotAscii(char);\n         impl CharEq for NotAscii {\n             fn matches(&self, c: char) -> bool {\n@@ -3935,65 +3935,65 @@ mod bench {\n         let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n \n         do bh.iter {\n-            assert_eq!(s.split_iter(NotAscii('V')).len(), 3);\n+            assert_eq!(s.split(NotAscii('V')).len(), 3);\n         }\n     }\n \n \n     #[bench]\n-    fn split_iter_ascii(bh: &mut BenchHarness) {\n+    fn split_ascii(bh: &mut BenchHarness) {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split_iter(' ').len();\n+        let len = s.split(' ').len();\n \n         do bh.iter {\n-            assert_eq!(s.split_iter(' ').len(), len);\n+            assert_eq!(s.split(' ').len(), len);\n         }\n     }\n \n     #[bench]\n-    fn split_iter_not_ascii(bh: &mut BenchHarness) {\n+    fn split_not_ascii(bh: &mut BenchHarness) {\n         struct NotAscii(char);\n         impl CharEq for NotAscii {\n             #[inline]\n             fn matches(&self, c: char) -> bool { **self == c }\n             fn only_ascii(&self) -> bool { false }\n         }\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split_iter(' ').len();\n+        let len = s.split(' ').len();\n \n         do bh.iter {\n-            assert_eq!(s.split_iter(NotAscii(' ')).len(), len);\n+            assert_eq!(s.split(NotAscii(' ')).len(), len);\n         }\n     }\n \n     #[bench]\n-    fn split_iter_extern_fn(bh: &mut BenchHarness) {\n+    fn split_extern_fn(bh: &mut BenchHarness) {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split_iter(' ').len();\n+        let len = s.split(' ').len();\n         fn pred(c: char) -> bool { c == ' ' }\n \n         do bh.iter {\n-            assert_eq!(s.split_iter(pred).len(), len);\n+            assert_eq!(s.split(pred).len(), len);\n         }\n     }\n \n     #[bench]\n-    fn split_iter_closure(bh: &mut BenchHarness) {\n+    fn split_closure(bh: &mut BenchHarness) {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split_iter(' ').len();\n+        let len = s.split(' ').len();\n \n         do bh.iter {\n-            assert_eq!(s.split_iter(|c: char| c == ' ').len(), len);\n+            assert_eq!(s.split(|c: char| c == ' ').len(), len);\n         }\n     }\n \n     #[bench]\n-    fn split_iter_slice(bh: &mut BenchHarness) {\n+    fn split_slice(bh: &mut BenchHarness) {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split_iter(' ').len();\n+        let len = s.split(' ').len();\n \n         do bh.iter {\n-            assert_eq!(s.split_iter(&[' ']).len(), len);\n+            assert_eq!(s.split(&[' ']).len(), len);\n         }\n     }\n "}, {"sha": "9f5ee75208958c2b6500f80499aaeac45ccea7a6", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -158,7 +158,7 @@ impl<T> TrieMap<T> {\n \n     // If `upper` is true then returns upper_bound else returns lower_bound.\n     #[inline]\n-    fn bound_iter<'a>(&'a self, key: uint, upper: bool) -> TrieMapIterator<'a, T> {\n+    fn bound<'a>(&'a self, key: uint, upper: bool) -> TrieMapIterator<'a, T> {\n         let mut node: &'a TrieNode<T> = &self.root;\n         let mut idx = 0;\n         let mut it = TrieMapIterator {\n@@ -193,14 +193,14 @@ impl<T> TrieMap<T> {\n \n     /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n     /// If all keys in the map are less than `key` an empty iterator is returned.\n-    pub fn lower_bound_iter<'a>(&'a self, key: uint) -> TrieMapIterator<'a, T> {\n-        self.bound_iter(key, false)\n+    pub fn lower_bound<'a>(&'a self, key: uint) -> TrieMapIterator<'a, T> {\n+        self.bound(key, false)\n     }\n \n     /// Get an iterator pointing to the first key-value pair whose key is greater than `key`.\n     /// If all keys in the map are not greater than `key` an empty iterator is returned.\n-    pub fn upper_bound_iter<'a>(&'a self, key: uint) -> TrieMapIterator<'a, T> {\n-        self.bound_iter(key, true)\n+    pub fn upper_bound<'a>(&'a self, key: uint) -> TrieMapIterator<'a, T> {\n+        self.bound(key, true)\n     }\n }\n \n@@ -282,14 +282,14 @@ impl TrieSet {\n \n     /// Get an iterator pointing to the first value that is not less than `val`.\n     /// If all values in the set are less than `val` an empty iterator is returned.\n-    pub fn lower_bound_iter<'a>(&'a self, val: uint) -> TrieSetIterator<'a> {\n-        TrieSetIterator{iter: self.map.lower_bound_iter(val)}\n+    pub fn lower_bound<'a>(&'a self, val: uint) -> TrieSetIterator<'a> {\n+        TrieSetIterator{iter: self.map.lower_bound(val)}\n     }\n \n     /// Get an iterator pointing to the first value that key is greater than `val`.\n     /// If all values in the set are not greater than `val` an empty iterator is returned.\n-    pub fn upper_bound_iter<'a>(&'a self, val: uint) -> TrieSetIterator<'a> {\n-        TrieSetIterator{iter: self.map.upper_bound_iter(val)}\n+    pub fn upper_bound<'a>(&'a self, val: uint) -> TrieSetIterator<'a> {\n+        TrieSetIterator{iter: self.map.upper_bound(val)}\n     }\n }\n \n@@ -713,10 +713,10 @@ mod test_map {\n     }\n \n     #[test]\n-    fn test_bound_iter() {\n+    fn test_bound() {\n         let empty_map : TrieMap<uint> = TrieMap::new();\n-        assert_eq!(empty_map.lower_bound_iter(0).next(), None);\n-        assert_eq!(empty_map.upper_bound_iter(0).next(), None);\n+        assert_eq!(empty_map.lower_bound(0).next(), None);\n+        assert_eq!(empty_map.upper_bound(0).next(), None);\n \n         let last = 999u;\n         let step = 3u;\n@@ -729,8 +729,8 @@ mod test_map {\n         }\n \n         for i in range(0u, last - step) {\n-            let mut lb = map.lower_bound_iter(i);\n-            let mut ub = map.upper_bound_iter(i);\n+            let mut lb = map.lower_bound(i);\n+            let mut ub = map.upper_bound(i);\n             let next_key = i - i % step + step;\n             let next_pair = (next_key, &value);\n             if (i % step == 0) {\n@@ -741,15 +741,15 @@ mod test_map {\n             assert_eq!(ub.next(), Some(next_pair));\n         }\n \n-        let mut lb = map.lower_bound_iter(last - step);\n+        let mut lb = map.lower_bound(last - step);\n         assert_eq!(lb.next(), Some((last - step, &value)));\n-        let mut ub = map.upper_bound_iter(last - step);\n+        let mut ub = map.upper_bound(last - step);\n         assert_eq!(ub.next(), None);\n \n         for i in range(last - step + 1, last) {\n-            let mut lb = map.lower_bound_iter(i);\n+            let mut lb = map.lower_bound(i);\n             assert_eq!(lb.next(), None);\n-            let mut ub = map.upper_bound_iter(i);\n+            let mut ub = map.upper_bound(i);\n             assert_eq!(ub.next(), None);\n         }\n     }"}, {"sha": "5fbf03c3cbb94e0f532c81787ba1ecb5fa1d6da0", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -859,20 +859,20 @@ pub trait ImmutableVector<'self, T> {\n     fn rev_iter(self) -> RevIterator<'self, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`.\n-    fn split_iter(self, pred: &'self fn(&T) -> bool) -> SplitIterator<'self, T>;\n+    fn split(self, pred: &'self fn(&T) -> bool) -> SplitIterator<'self, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`, limited to splitting\n     /// at most `n` times.\n-    fn splitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> SplitIterator<'self, T>;\n+    fn splitn(self, n: uint, pred: &'self fn(&T) -> bool) -> SplitIterator<'self, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`. This starts at the\n     /// end of the vector and works backwards.\n-    fn rsplit_iter(self, pred: &'self fn(&T) -> bool) -> RSplitIterator<'self, T>;\n+    fn rsplit(self, pred: &'self fn(&T) -> bool) -> RSplitIterator<'self, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred` limited to splitting\n     /// at most `n` times. This starts at the end of the vector and\n     /// works backwards.\n-    fn rsplitn_iter(self,  n: uint, pred: &'self fn(&T) -> bool) -> RSplitIterator<'self, T>;\n+    fn rsplitn(self,  n: uint, pred: &'self fn(&T) -> bool) -> RSplitIterator<'self, T>;\n \n     /**\n      * Returns an iterator over all contiguous windows of length\n@@ -890,13 +890,13 @@ pub trait ImmutableVector<'self, T> {\n      *\n      * ```rust\n      * let v = &[1,2,3,4];\n-     * for win in v.window_iter() {\n+     * for win in v.windows(2) {\n      *     println!(\"{:?}\", win);\n      * }\n      * ```\n      *\n      */\n-    fn window_iter(self, size: uint) -> WindowIter<'self, T>;\n+    fn windows(self, size: uint) -> WindowIter<'self, T>;\n     /**\n      *\n      * Returns an iterator over `size` elements of the vector at a\n@@ -915,13 +915,13 @@ pub trait ImmutableVector<'self, T> {\n      *\n      * ```rust\n      * let v = &[1,2,3,4,5];\n-     * for win in v.chunk_iter() {\n+     * for win in v.chunks(2) {\n      *     println!(\"{:?}\", win);\n      * }\n      * ```\n      *\n      */\n-    fn chunk_iter(self, size: uint) -> ChunkIter<'self, T>;\n+    fn chunks(self, size: uint) -> ChunkIter<'self, T>;\n \n     /// Returns the element of a vector at the given index, or `None` if the\n     /// index is out of bounds\n@@ -1024,24 +1024,27 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n \n     #[inline]\n-    fn split_iter(self, pred: &'self fn(&T) -> bool) -> SplitIterator<'self, T> {\n-        self.splitn_iter(uint::max_value, pred)\n+    fn split(self, pred: &'self fn(&T) -> bool) -> SplitIterator<'self, T> {\n+        self.splitn(uint::max_value, pred)\n     }\n+\n     #[inline]\n-    fn splitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> SplitIterator<'self, T> {\n+    fn splitn(self, n: uint, pred: &'self fn(&T) -> bool) -> SplitIterator<'self, T> {\n         SplitIterator {\n             v: self,\n             n: n,\n             pred: pred,\n             finished: false\n         }\n     }\n+\n     #[inline]\n-    fn rsplit_iter(self, pred: &'self fn(&T) -> bool) -> RSplitIterator<'self, T> {\n-        self.rsplitn_iter(uint::max_value, pred)\n+    fn rsplit(self, pred: &'self fn(&T) -> bool) -> RSplitIterator<'self, T> {\n+        self.rsplitn(uint::max_value, pred)\n     }\n+\n     #[inline]\n-    fn rsplitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> RSplitIterator<'self, T> {\n+    fn rsplitn(self, n: uint, pred: &'self fn(&T) -> bool) -> RSplitIterator<'self, T> {\n         RSplitIterator {\n             v: self,\n             n: n,\n@@ -1050,12 +1053,14 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         }\n     }\n \n-    fn window_iter(self, size: uint) -> WindowIter<'self, T> {\n+    #[inline]\n+    fn windows(self, size: uint) -> WindowIter<'self, T> {\n         assert!(size != 0);\n         WindowIter { v: self, size: size }\n     }\n \n-    fn chunk_iter(self, size: uint) -> ChunkIter<'self, T> {\n+    #[inline]\n+    fn chunks(self, size: uint) -> ChunkIter<'self, T> {\n         assert!(size != 0);\n         ChunkIter { v: self, size: size }\n     }\n@@ -1218,7 +1223,7 @@ pub trait ImmutableCopyableVector<T> {\n \n     /// Create an iterator that yields every possible permutation of the\n     /// vector in succession.\n-    fn permutations_iter(self) -> Permutations<T>;\n+    fn permutations(self) -> Permutations<T>;\n }\n \n impl<'self,T:Clone> ImmutableCopyableVector<T> for &'self [T] {\n@@ -1243,7 +1248,7 @@ impl<'self,T:Clone> ImmutableCopyableVector<T> for &'self [T] {\n         (*self.unsafe_ref(index)).clone()\n     }\n \n-    fn permutations_iter(self) -> Permutations<T> {\n+    fn permutations(self) -> Permutations<T> {\n         Permutations{\n             swaps: ElementSwaps::new(self.len()),\n             v: self.to_owned(),\n@@ -3035,17 +3040,17 @@ mod tests {\n         use hashmap;\n         {\n             let v: [int, ..0] = [];\n-            let mut it = v.permutations_iter();\n+            let mut it = v.permutations();\n             assert_eq!(it.next(), None);\n         }\n         {\n             let v = [~\"Hello\"];\n-            let mut it = v.permutations_iter();\n+            let mut it = v.permutations();\n             assert_eq!(it.next(), None);\n         }\n         {\n             let v = [1, 2, 3];\n-            let mut it = v.permutations_iter();\n+            let mut it = v.permutations();\n             assert_eq!(it.next(), Some(~[1,2,3]));\n             assert_eq!(it.next(), Some(~[1,3,2]));\n             assert_eq!(it.next(), Some(~[3,1,2]));\n@@ -3058,7 +3063,7 @@ mod tests {\n             // check that we have N! unique permutations\n             let mut set = hashmap::HashSet::new();\n             let v = ['A', 'B', 'C', 'D', 'E', 'F'];\n-            for perm in v.permutations_iter() {\n+            for perm in v.permutations() {\n                 set.insert(perm);\n             }\n             assert_eq!(set.len(), 2 * 3 * 4 * 5 * 6);\n@@ -3357,7 +3362,7 @@ mod tests {\n     fn test_permute_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        for _ in v.permutations_iter() {\n+        for _ in v.permutations() {\n             if i == 2 {\n                 fail!()\n             }\n@@ -3530,97 +3535,97 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_split_iterator() {\n+    fn test_splitator() {\n         let xs = &[1i,2,3,4,5];\n \n-        assert_eq!(xs.split_iter(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n                    ~[&[1], &[3], &[5]]);\n-        assert_eq!(xs.split_iter(|x| *x == 1).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|x| *x == 1).collect::<~[&[int]]>(),\n                    ~[&[], &[2,3,4,5]]);\n-        assert_eq!(xs.split_iter(|x| *x == 5).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|x| *x == 5).collect::<~[&[int]]>(),\n                    ~[&[1,2,3,4], &[]]);\n-        assert_eq!(xs.split_iter(|x| *x == 10).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|x| *x == 10).collect::<~[&[int]]>(),\n                    ~[&[1,2,3,4,5]]);\n-        assert_eq!(xs.split_iter(|_| true).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|_| true).collect::<~[&[int]]>(),\n                    ~[&[], &[], &[], &[], &[], &[]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.split_iter(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+        assert_eq!(xs.split(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n     }\n \n     #[test]\n-    fn test_splitn_iterator() {\n+    fn test_splitnator() {\n         let xs = &[1i,2,3,4,5];\n \n-        assert_eq!(xs.splitn_iter(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n                    ~[&[1,2,3,4,5]]);\n-        assert_eq!(xs.splitn_iter(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n                    ~[&[1], &[3,4,5]]);\n-        assert_eq!(xs.splitn_iter(3, |_| true).collect::<~[&[int]]>(),\n+        assert_eq!(xs.splitn(3, |_| true).collect::<~[&[int]]>(),\n                    ~[&[], &[], &[], &[4,5]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.splitn_iter(1, |x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n     }\n \n     #[test]\n-    fn test_rsplit_iterator() {\n+    fn test_rsplitator() {\n         let xs = &[1i,2,3,4,5];\n \n-        assert_eq!(xs.rsplit_iter(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n+        assert_eq!(xs.rsplit(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n                    ~[&[5], &[3], &[1]]);\n-        assert_eq!(xs.rsplit_iter(|x| *x == 1).collect::<~[&[int]]>(),\n+        assert_eq!(xs.rsplit(|x| *x == 1).collect::<~[&[int]]>(),\n                    ~[&[2,3,4,5], &[]]);\n-        assert_eq!(xs.rsplit_iter(|x| *x == 5).collect::<~[&[int]]>(),\n+        assert_eq!(xs.rsplit(|x| *x == 5).collect::<~[&[int]]>(),\n                    ~[&[], &[1,2,3,4]]);\n-        assert_eq!(xs.rsplit_iter(|x| *x == 10).collect::<~[&[int]]>(),\n+        assert_eq!(xs.rsplit(|x| *x == 10).collect::<~[&[int]]>(),\n                    ~[&[1,2,3,4,5]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.rsplit_iter(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+        assert_eq!(xs.rsplit(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n     }\n \n     #[test]\n-    fn test_rsplitn_iterator() {\n+    fn test_rsplitnator() {\n         let xs = &[1,2,3,4,5];\n \n-        assert_eq!(xs.rsplitn_iter(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n                    ~[&[1,2,3,4,5]]);\n-        assert_eq!(xs.rsplitn_iter(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n+        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n                    ~[&[5], &[1,2,3]]);\n-        assert_eq!(xs.rsplitn_iter(3, |_| true).collect::<~[&[int]]>(),\n+        assert_eq!(xs.rsplitn(3, |_| true).collect::<~[&[int]]>(),\n                    ~[&[], &[], &[], &[1,2]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.rsplitn_iter(1, |x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n     }\n \n     #[test]\n-    fn test_window_iterator() {\n+    fn test_windowsator() {\n         let v = &[1i,2,3,4];\n \n-        assert_eq!(v.window_iter(2).collect::<~[&[int]]>(), ~[&[1,2], &[2,3], &[3,4]]);\n-        assert_eq!(v.window_iter(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[2,3,4]]);\n-        assert!(v.window_iter(6).next().is_none());\n+        assert_eq!(v.windows(2).collect::<~[&[int]]>(), ~[&[1,2], &[2,3], &[3,4]]);\n+        assert_eq!(v.windows(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[2,3,4]]);\n+        assert!(v.windows(6).next().is_none());\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_window_iterator_0() {\n+    fn test_windowsator_0() {\n         let v = &[1i,2,3,4];\n-        let _it = v.window_iter(0);\n+        let _it = v.windows(0);\n     }\n \n     #[test]\n-    fn test_chunk_iterator() {\n+    fn test_chunksator() {\n         let v = &[1i,2,3,4,5];\n \n-        assert_eq!(v.chunk_iter(2).collect::<~[&[int]]>(), ~[&[1i,2], &[3,4], &[5]]);\n-        assert_eq!(v.chunk_iter(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[4,5]]);\n-        assert_eq!(v.chunk_iter(6).collect::<~[&[int]]>(), ~[&[1i,2,3,4,5]]);\n+        assert_eq!(v.chunks(2).collect::<~[&[int]]>(), ~[&[1i,2], &[3,4], &[5]]);\n+        assert_eq!(v.chunks(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[4,5]]);\n+        assert_eq!(v.chunks(6).collect::<~[&[int]]>(), ~[&[1i,2,3,4,5]]);\n \n-        assert_eq!(v.chunk_iter(2).invert().collect::<~[&[int]]>(), ~[&[5i], &[3,4], &[1,2]]);\n-        let it = v.chunk_iter(2);\n+        assert_eq!(v.chunks(2).invert().collect::<~[&[int]]>(), ~[&[5i], &[3,4], &[1,2]]);\n+        let it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n         assert_eq!(it.idx(0).unwrap(), &[1,2]);\n         assert_eq!(it.idx(1).unwrap(), &[3,4]);\n@@ -3630,9 +3635,9 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n-    fn test_chunk_iterator_0() {\n+    fn test_chunksator_0() {\n         let v = &[1i,2,3,4];\n-        let _it = v.chunk_iter(0);\n+        let _it = v.chunks(0);\n     }\n \n     #[test]"}, {"sha": "933f4b33fe3df3a75ff7fd81a053df4ec5703876", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -29,7 +29,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> bas\n             ast::ExprLit(lit) => match lit.node {\n                 // string literal, push each byte to vector expression\n                 ast::lit_str(s, _) => {\n-                    for byte in s.byte_iter() {\n+                    for byte in s.bytes() {\n                         bytes.push(cx.expr_u8(expr.span, byte));\n                     }\n                 }"}, {"sha": "8defd8a7b6cb6a117f9342696c387780fc5802f1", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -60,14 +60,14 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         let mut i = 0u;\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n-        if lines.len() > 0 && lines[0].iter().all(|c| c == '*') {\n+        if lines.len() > 0 && lines[0].chars().all(|c| c == '*') {\n             i += 1;\n         }\n         while i < j && lines[i].trim().is_empty() {\n             i += 1;\n         }\n         // like the first, a last line of all stars should be omitted\n-        if j > i && lines[j - 1].iter().skip(1).all(|c| c == '*') {\n+        if j > i && lines[j - 1].chars().skip(1).all(|c| c == '*') {\n             j -= 1;\n         }\n         while j > i && lines[j - 1].trim().is_empty() {\n@@ -82,7 +82,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         let mut can_trim = true;\n         let mut first = true;\n         for line in lines.iter() {\n-            for (j, c) in line.iter().enumerate() {\n+            for (j, c) in line.chars().enumerate() {\n                 if j > i || !\"* \\t\".contains_char(c) {\n                     can_trim = false;\n                     break;\n@@ -124,7 +124,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n \n     if comment.starts_with(\"/*\") {\n         let lines = comment.slice(3u, comment.len() - 2u)\n-            .any_line_iter()\n+            .lines_any()\n             .map(|s| s.to_owned())\n             .collect::<~[~str]>();\n "}, {"sha": "6aa3962a0e7de5b30de8f5b6d8606855dda11ddb", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -318,7 +318,7 @@ fn consume_whitespace_and_comments(rdr: @mut StringReader)\n \n pub fn is_line_non_doc_comment(s: &str) -> bool {\n     let s = s.trim_right();\n-    s.len() > 3 && s.iter().all(|ch| ch == '/')\n+    s.len() > 3 && s.chars().all(|ch| ch == '/')\n }\n \n // PRECONDITION: rdr.curr is not whitespace\n@@ -379,7 +379,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n \n pub fn is_block_non_doc_comment(s: &str) -> bool {\n     assert!(s.len() >= 1u);\n-    s.slice(1u, s.len() - 1u).iter().all(|ch| ch == '*')\n+    s.slice(1u, s.len() - 1u).chars().all(|ch| ch == '*')\n }\n \n // might return a sugared-doc-attr"}, {"sha": "7de8e3087c8777e2738c36f9ee0903e83a4a93cb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -4586,7 +4586,7 @@ impl Parser {\n                 self.bump();\n                 let the_string = ident_to_str(&s);\n                 let mut abis = AbiSet::empty();\n-                for word in the_string.word_iter() {\n+                for word in the_string.words() {\n                     match abi::lookup(word) {\n                         Some(abi) => {\n                             if abis.contains(abi) {"}, {"sha": "e3fe631068c1f2c6b7dba621487b19670c6568e0", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -128,7 +128,7 @@ fn make_masks() -> ~[~[~[u64]]] {\n         let mut cur_piece = ~[];\n         for dy in range(0, 10) {\n             for dx in range(0, 5) {\n-                let masks = \n+                let masks =\n                     trans.iter()\n                     .filter_map(|t| mask(dy, dx, id, *t))\n                     .collect();\n@@ -192,7 +192,7 @@ fn to_utf8(raw_sol: &List<u64>) -> ~str {\n \n // Prints a solution in ~str form.\n fn print_sol(sol: &str) {\n-    for (i, c) in sol.iter().enumerate() {\n+    for (i, c) in sol.chars().enumerate() {\n         if (i) % 5 == 0 {println(\"\");}\n         if (i + 5) % 10 == 0 {print(\" \");}\n         print!(\"{} \", c);\n@@ -220,7 +220,7 @@ fn handle_sol(raw_sol: &List<u64>, data: &mut Data) -> bool {\n     // reverse order, i.e. the board rotated by half a turn.\n     data.nb += 2;\n     let sol1 = to_utf8(raw_sol);\n-    let sol2: ~str = sol1.iter().invert().collect();\n+    let sol2: ~str = sol1.chars().invert().collect();\n \n     if data.nb == 2 {\n         data.min = sol1.clone();"}, {"sha": "f3465a9bc7e45312f185f75bb79bea4816b0a622", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -76,7 +76,7 @@ impl Sudoku {\n             let line = match reader.read_line() {\n                 Some(ln) => ln, None => break\n             };\n-            let comps: ~[&str] = line.trim().split_iter(',').collect();\n+            let comps: ~[&str] = line.trim().split(',').collect();\n \n             if comps.len() == 3u {\n                 let row     = from_str::<uint>(comps[0]).unwrap() as u8;"}, {"sha": "67bbd0967206bad20951c2177185ffe9801b3f3b", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n     assert_eq!(y, 6);\n     let s = ~\"hello there\";\n     let mut i: int = 0;\n-    for c in s.byte_iter() {\n+    for c in s.bytes() {\n         if i == 0 { assert!((c == 'h' as u8)); }\n         if i == 1 { assert!((c == 'e' as u8)); }\n         if i == 2 { assert!((c == 'l' as u8)); }"}, {"sha": "22786c0abc89b9bd6487882d021967e18abb377f", "filename": "src/test/run-pass/nul-characters.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Ftest%2Frun-pass%2Fnul-characters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Ftest%2Frun-pass%2Fnul-characters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnul-characters.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -16,23 +16,23 @@ pub fn main()\n     let all_nuls4 = \"\\x00\\u0000\\0\\U00000000\";\n \n     // sizes for two should suffice\n-    assert_eq!(all_nuls1.len(), 4); \n+    assert_eq!(all_nuls1.len(), 4);\n     assert_eq!(all_nuls2.len(), 4);\n \n     // string equality should pass between the strings\n     assert_eq!(all_nuls1, all_nuls2);\n     assert_eq!(all_nuls2, all_nuls3);\n     assert_eq!(all_nuls3, all_nuls4);\n-    \n+\n     // all extracted characters in all_nuls are equivalent to each other\n-    for c1 in all_nuls1.iter()\n+    for c1 in all_nuls1.chars()\n     {\n-        for c2 in all_nuls1.iter()\n+        for c2 in all_nuls1.chars()\n         {\n             assert_eq!(c1,c2);\n         }\n     }\n-    \n+\n     // testing equality between explicit character literals\n     assert_eq!('\\0', '\\x00');\n     assert_eq!('\\u0000', '\\x00');"}, {"sha": "1520a8b7e611c577257e60a35ff55c4e7bdc4ae0", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -41,7 +41,7 @@ pub fn main() {\n \n     fn check_str_eq(a: ~str, b: ~str) {\n         let mut i: int = 0;\n-        for ab in a.byte_iter() {\n+        for ab in a.bytes() {\n             info!(\"{}\", i);\n             info!(\"{}\", ab);\n             let bb: u8 = b[i];"}, {"sha": "4c86b5eb2bec8ca6541ae2ea92cff14ce74d7638", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21990cdda624f5eee340311b7f8e542ab8a218e1/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=21990cdda624f5eee340311b7f8e542ab8a218e1", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n     // Chars of 1, 2, 3, and 4 bytes\n     let chs: ~[char] = ~['e', '\u00e9', '\u20ac', '\\U00010000'];\n     let s: ~str = str::from_chars(chs);\n-    let schs: ~[char] = s.iter().collect();\n+    let schs: ~[char] = s.chars().collect();\n \n     assert!(s.len() == 10u);\n     assert!(s.char_len() == 4u);"}]}