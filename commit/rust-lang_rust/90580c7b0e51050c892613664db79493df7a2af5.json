{"sha": "90580c7b0e51050c892613664db79493df7a2af5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNTgwYzdiMGU1MTA1MGM4OTI2MTM2NjRkYjc5NDkzZGY3YTJhZjU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-05T16:02:00Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-05T17:05:55Z"}, "message": "make unchecked slice indexing helper methods use raw pointers", "tree": {"sha": "63ea4e4a2bdde9dcbd3f2d141fb54f5e4a14de26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63ea4e4a2bdde9dcbd3f2d141fb54f5e4a14de26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90580c7b0e51050c892613664db79493df7a2af5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90580c7b0e51050c892613664db79493df7a2af5", "html_url": "https://github.com/rust-lang/rust/commit/90580c7b0e51050c892613664db79493df7a2af5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90580c7b0e51050c892613664db79493df7a2af5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b1d5e6d792fb47c9a95c4ea210ce88174f18b13", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b1d5e6d792fb47c9a95c4ea210ce88174f18b13", "html_url": "https://github.com/rust-lang/rust/commit/3b1d5e6d792fb47c9a95c4ea210ce88174f18b13"}], "stats": {"total": 263, "additions": 134, "deletions": 129}, "files": [{"sha": "88deeac00ff14ae95e6ff6b8add97eb6487de64d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/90580c7b0e51050c892613664db79493df7a2af5/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90580c7b0e51050c892613664db79493df7a2af5/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=90580c7b0e51050c892613664db79493df7a2af5", "patch": "@@ -310,8 +310,10 @@ impl<T> [T] {\n     where\n         I: SliceIndex<Self>,\n     {\n-        // SAFETY: the caller must uphold the safety requirements for `get_unchecked`.\n-        unsafe { index.get_unchecked(self) }\n+        // SAFETY: the caller must uphold most of the safety requirements for `get_unchecked`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &*index.get_unchecked(self) }\n     }\n \n     /// Returns a mutable reference to an element or subslice, without doing\n@@ -342,8 +344,10 @@ impl<T> [T] {\n     where\n         I: SliceIndex<Self>,\n     {\n-        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`.\n-        unsafe { index.get_unchecked_mut(self) }\n+        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &mut *index.get_unchecked_mut(self) }\n     }\n \n     /// Returns a raw pointer to the slice's buffer.\n@@ -2910,6 +2914,9 @@ mod private_slice_index {\n }\n \n /// A helper trait used for indexing operations.\n+///\n+/// Implementations of this trait have to promise that if the argument\n+/// to `get_(mut_)unchecked` is a safe reference, then so is the result.\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n #[rustc_on_unimplemented(\n     on(T = \"str\", label = \"string indices are ranges of `usize`\",),\n@@ -2921,7 +2928,7 @@ see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#ind\n     message = \"the type `{T}` cannot be indexed by `{Self}`\",\n     label = \"slice indices are of type `usize` or ranges of `usize`\"\n )]\n-pub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n+pub unsafe trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n     /// The output type returned by methods.\n     #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n     type Output: ?Sized;\n@@ -2938,21 +2945,21 @@ pub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n \n     /// Returns a shared reference to the output at this location, without\n     /// performing any bounds checking.\n-    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n-    /// even if the resulting reference is not used.\n+    /// Calling this method with an out-of-bounds index or a dangling `slice` pointer\n+    /// is *[undefined behavior]* even if the resulting reference is not used.\n     ///\n     /// [undefined behavior]: ../../reference/behavior-considered-undefined.html\n     #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n-    unsafe fn get_unchecked(self, slice: &T) -> &Self::Output;\n+    unsafe fn get_unchecked(self, slice: *const T) -> *const Self::Output;\n \n     /// Returns a mutable reference to the output at this location, without\n     /// performing any bounds checking.\n-    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n-    /// even if the resulting reference is not used.\n+    /// Calling this method with an out-of-bounds index or a dangling `slice` pointer\n+    /// is *[undefined behavior]* even if the resulting reference is not used.\n     ///\n     /// [undefined behavior]: ../../reference/behavior-considered-undefined.html\n     #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n-    unsafe fn get_unchecked_mut(self, slice: &mut T) -> &mut Self::Output;\n+    unsafe fn get_unchecked_mut(self, slice: *mut T) -> *mut Self::Output;\n \n     /// Returns a shared reference to the output at this location, panicking\n     /// if out of bounds.\n@@ -2968,33 +2975,32 @@ pub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for usize {\n+unsafe impl<T> SliceIndex<[T]> for usize {\n     type Output = T;\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&T> {\n-        if self < slice.len() { unsafe { Some(self.get_unchecked(slice)) } } else { None }\n+        if self < slice.len() { unsafe { Some(&*self.get_unchecked(slice)) } } else { None }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n-        if self < slice.len() { unsafe { Some(self.get_unchecked_mut(slice)) } } else { None }\n+        if self < slice.len() { unsafe { Some(&mut *self.get_unchecked_mut(slice)) } } else { None }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &T {\n-        // SAFETY: `slice` cannot be longer than `isize::MAX` and\n-        // the caller guarantees that `self` is in bounds of `slice`\n-        // so `self` cannot overflow an `isize`, so the call to `add` is safe.\n-        // The obtained pointer comes from a reference which is guaranteed\n-        // to be valid.\n-        unsafe { &*slice.as_ptr().add(self) }\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {\n+        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n+        // cannot be longer than `isize::MAX`. They also guarantee that\n+        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n+        // so the call to `add` is safe.\n+        unsafe { slice.as_ptr().add(self) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut T {\n         // SAFETY: see comments for `get_unchecked` above.\n-        unsafe { &mut *slice.as_mut_ptr().add(self) }\n+        unsafe { slice.as_mut_ptr().add(self) }\n     }\n \n     #[inline]\n@@ -3011,15 +3017,15 @@ impl<T> SliceIndex<[T]> for usize {\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for ops::Range<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n     type Output = [T];\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n         if self.start > self.end || self.end > slice.len() {\n             None\n         } else {\n-            unsafe { Some(self.get_unchecked(slice)) }\n+            unsafe { Some(&*self.get_unchecked(slice)) }\n         }\n     }\n \n@@ -3028,24 +3034,25 @@ impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         if self.start > self.end || self.end > slice.len() {\n             None\n         } else {\n-            unsafe { Some(self.get_unchecked_mut(slice)) }\n+            unsafe { Some(&mut *self.get_unchecked_mut(slice)) }\n         }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        // SAFETY: `slice` cannot be longer than `isize::MAX` and\n-        // the caller guarantees that `self` is in bounds of `slice`\n-        // so `self` cannot overflow an `isize`, so the call to `add` is safe.\n-        // Also, since the caller guarantees that `self` is in bounds of `slice`,\n-        // `from_raw_parts` will give a subslice of `slice` which is always safe.\n-        unsafe { from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n+        // cannot be longer than `isize::MAX`. They also guarantee that\n+        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n+        // so the call to `add` is safe.\n+        unsafe { ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: see comments for `get_unchecked` above.\n-        unsafe { from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start) }\n+        unsafe {\n+            ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n+        }\n     }\n \n     #[inline]\n@@ -3055,7 +3062,7 @@ impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         } else if self.end > slice.len() {\n             slice_index_len_fail(self.end, slice.len());\n         }\n-        unsafe { self.get_unchecked(slice) }\n+        unsafe { &*self.get_unchecked(slice) }\n     }\n \n     #[inline]\n@@ -3065,12 +3072,12 @@ impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         } else if self.end > slice.len() {\n             slice_index_len_fail(self.end, slice.len());\n         }\n-        unsafe { self.get_unchecked_mut(slice) }\n+        unsafe { &mut *self.get_unchecked_mut(slice) }\n     }\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -3084,13 +3091,13 @@ impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n         unsafe { (0..self.end).get_unchecked(slice) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n         unsafe { (0..self.end).get_unchecked_mut(slice) }\n     }\n@@ -3107,7 +3114,7 @@ impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -3121,13 +3128,13 @@ impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n         unsafe { (self.start..slice.len()).get_unchecked(slice) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n         unsafe { (self.start..slice.len()).get_unchecked_mut(slice) }\n     }\n@@ -3144,7 +3151,7 @@ impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeFull {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeFull {\n     type Output = [T];\n \n     #[inline]\n@@ -3158,12 +3165,12 @@ impl<T> SliceIndex<[T]> for ops::RangeFull {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         slice\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         slice\n     }\n \n@@ -3179,7 +3186,7 @@ impl<T> SliceIndex<[T]> for ops::RangeFull {\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -3197,13 +3204,13 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n         unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n         unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n     }\n@@ -3226,7 +3233,7 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -3240,13 +3247,13 @@ impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n         unsafe { (0..=self.end).get_unchecked(slice) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n         unsafe { (0..=self.end).get_unchecked_mut(slice) }\n     }"}, {"sha": "5c4134b0749b9953c900f0741cc69382af66e874", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 75, "deletions": 77, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/90580c7b0e51050c892613664db79493df7a2af5/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90580c7b0e51050c892613664db79493df7a2af5/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=90580c7b0e51050c892613664db79493df7a2af5", "patch": "@@ -1731,7 +1731,8 @@ Section: Trait implementations\n mod traits {\n     use crate::cmp::Ordering;\n     use crate::ops;\n-    use crate::slice::{self, SliceIndex};\n+    use crate::ptr;\n+    use crate::slice::SliceIndex;\n \n     /// Implements ordering of strings.\n     ///\n@@ -1822,7 +1823,7 @@ mod traits {\n     ///\n     /// Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    impl SliceIndex<str> for ops::RangeFull {\n+    unsafe impl SliceIndex<str> for ops::RangeFull {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -1833,11 +1834,11 @@ mod traits {\n             Some(slice)\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n             slice\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n             slice\n         }\n         #[inline]\n@@ -1886,16 +1887,18 @@ mod traits {\n     /// // &s[3 .. 100];\n     /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    impl SliceIndex<str> for ops::Range<usize> {\n+    unsafe impl SliceIndex<str> for ops::Range<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if self.start <= self.end\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n-                // SAFETY: just checked that `start` and `end` are on a char boundary.\n-                Some(unsafe { self.get_unchecked(slice) })\n+                // SAFETY: just checked that `start` and `end` are on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                // We also checked char boundaries, so this is valid UTF-8.\n+                Some(unsafe { &*self.get_unchecked(slice) })\n             } else {\n                 None\n             }\n@@ -1907,34 +1910,28 @@ mod traits {\n                 && slice.is_char_boundary(self.end)\n             {\n                 // SAFETY: just checked that `start` and `end` are on a char boundary.\n-                Some(unsafe { self.get_unchecked_mut(slice) })\n+                // We know the pointer is unique because we got it from `slice`.\n+                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+            let slice = slice as *const [u8];\n             // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n             // which satisfies all the conditions for `add`.\n             let ptr = unsafe { slice.as_ptr().add(self.start) };\n             let len = self.end - self.start;\n-            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n-            // we can safely construct a subslice with `from_raw_parts` and use it\n-            // since we return a shared thus immutable reference.\n-            // The call to `from_utf8_unchecked` is safe since the data comes from\n-            // a `str` which is guaranteed to be valid utf8, since the caller\n-            // must guarantee that `self.start` and `self.end` are char boundaries.\n-            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, len)) }\n+            ptr::slice_from_raw_parts(ptr, len) as *const str\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+            let slice = slice as *mut [u8];\n             // SAFETY: see comments for `get_unchecked`.\n             let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n             let len = self.end - self.start;\n-            // SAFETY: mostly identical to the comments for `get_unchecked`, except that we\n-            // can return a mutable reference since the caller passed a mutable reference\n-            // and is thus guaranteed to have exclusive write access to `slice`.\n-            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len)) }\n+            ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -1949,8 +1946,9 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n-                // SAFETY: just checked that `start` and `end` are on a char boundary.\n-                unsafe { self.get_unchecked_mut(slice) }\n+                // SAFETY: just checked that `start` and `end` are on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                unsafe { &mut *self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, self.end)\n             }\n@@ -1973,44 +1971,39 @@ mod traits {\n     /// Panics if `end` does not point to the starting byte offset of a\n     /// character (as defined by `is_char_boundary`), or if `end > len`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    impl SliceIndex<str> for ops::RangeTo<usize> {\n+    unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary.\n-                Some(unsafe { self.get_unchecked(slice) })\n+                // SAFETY: just checked that `end` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                Some(unsafe { &*self.get_unchecked(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary.\n-                Some(unsafe { self.get_unchecked_mut(slice) })\n+                // SAFETY: just checked that `end` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+            let slice = slice as *const [u8];\n             let ptr = slice.as_ptr();\n-            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n-            // we can safely construct a subslice with `from_raw_parts` and use it\n-            // since we return a shared thus immutable reference.\n-            // The call to `from_utf8_unchecked` is safe since the data comes from\n-            // a `str` which is guaranteed to be valid utf8, since the caller\n-            // must guarantee that `self.end` is a char boundary.\n-            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end)) }\n+            ptr::slice_from_raw_parts(ptr, self.end) as *const str\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+            let slice = slice as *mut [u8];\n             let ptr = slice.as_mut_ptr();\n-            // SAFETY: mostly identical to `get_unchecked`, except that we can safely\n-            // return a mutable reference since the caller passed a mutable reference\n-            // and is thus guaranteed to have exclusive write access to `slice`.\n-            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, self.end)) }\n+            ptr::slice_from_raw_parts_mut(ptr, self.end) as *mut str\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2020,8 +2013,9 @@ mod traits {\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n             if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary.\n-                unsafe { self.get_unchecked_mut(slice) }\n+                // SAFETY: just checked that `end` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                unsafe { &mut *self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, 0, self.end)\n             }\n@@ -2045,49 +2039,44 @@ mod traits {\n     /// Panics if `begin` does not point to the starting byte offset of\n     /// a character (as defined by `is_char_boundary`), or if `begin >= len`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    impl SliceIndex<str> for ops::RangeFrom<usize> {\n+    unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary.\n-                Some(unsafe { self.get_unchecked(slice) })\n+                // SAFETY: just checked that `start` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                Some(unsafe { &*self.get_unchecked(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary.\n-                Some(unsafe { self.get_unchecked_mut(slice) })\n+                // SAFETY: just checked that `start` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+            let slice = slice as *const [u8];\n             // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n             // which satisfies all the conditions for `add`.\n             let ptr = unsafe { slice.as_ptr().add(self.start) };\n             let len = slice.len() - self.start;\n-            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n-            // we can safely construct a subslice with `from_raw_parts` and use it\n-            // since we return a shared thus immutable reference.\n-            // The call to `from_utf8_unchecked` is safe since the data comes from\n-            // a `str` which is guaranteed to be valid utf8, since the caller\n-            // must guarantee that `self.start` is a char boundary.\n-            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, len)) }\n+            ptr::slice_from_raw_parts(ptr, len) as *const str\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+            let slice = slice as *mut [u8];\n             // SAFETY: identical to `get_unchecked`.\n             let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n             let len = slice.len() - self.start;\n-            // SAFETY: mostly identical to `get_unchecked`, except that we can safely\n-            // return a mutable reference since the caller passed a mutable reference\n-            // and is thus guaranteed to have exclusive write access to `slice`.\n-            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len)) }\n+            ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2097,8 +2086,9 @@ mod traits {\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n             if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary.\n-                unsafe { self.get_unchecked_mut(slice) }\n+                // SAFETY: just checked that `start` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                unsafe { &mut *self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, slice.len())\n             }\n@@ -2122,7 +2112,7 @@ mod traits {\n     /// to the ending byte offset of a character (`end + 1` is either a starting\n     /// byte offset or equal to `len`), if `begin > end`, or if `end >= len`.\n     #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl SliceIndex<str> for ops::RangeInclusive<usize> {\n+    unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -2141,12 +2131,12 @@ mod traits {\n             }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n             // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n             unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n             // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n             unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n         }\n@@ -2181,7 +2171,7 @@ mod traits {\n     /// (`end + 1` is either a starting byte offset as defined by\n     /// `is_char_boundary`, or equal to `len`), or if `end >= len`.\n     #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n+    unsafe impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -2192,12 +2182,12 @@ mod traits {\n             if self.end == usize::MAX { None } else { (..self.end + 1).get_mut(slice) }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n             // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n             unsafe { (..self.end + 1).get_unchecked(slice) }\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n             // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n             unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n         }\n@@ -2560,8 +2550,10 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n-        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { i.get_unchecked(self) }\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &*i.get_unchecked(self) }\n     }\n \n     /// Returns a mutable, unchecked subslice of `str`.\n@@ -2593,8 +2585,10 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n-        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { i.get_unchecked_mut(self) }\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &mut *i.get_unchecked_mut(self) }\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2644,8 +2638,10 @@ impl str {\n     #[rustc_deprecated(since = \"1.29.0\", reason = \"use `get_unchecked(begin..end)` instead\")]\n     #[inline]\n     pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { (begin..end).get_unchecked(self) }\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &*(begin..end).get_unchecked(self) }\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2676,8 +2672,10 @@ impl str {\n     #[rustc_deprecated(since = \"1.29.0\", reason = \"use `get_unchecked_mut(begin..end)` instead\")]\n     #[inline]\n     pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (begin..end).get_unchecked_mut(self) }\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &mut *(begin..end).get_unchecked_mut(self) }\n     }\n \n     /// Divide one string slice into two at an index."}]}