{"sha": "640886ceb662ae212cf3edc7f400142af3aa7bbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MDg4NmNlYjY2MmFlMjEyY2YzZWRjN2Y0MDAxNDJhZjNhYTdiYmY=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-25T22:36:55Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-27T01:03:33Z"}, "message": "Polymorphic MapReduce!", "tree": {"sha": "d2a08c26cafc7b5d359b953430f66afded4ddd81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2a08c26cafc7b5d359b953430f66afded4ddd81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/640886ceb662ae212cf3edc7f400142af3aa7bbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/640886ceb662ae212cf3edc7f400142af3aa7bbf", "html_url": "https://github.com/rust-lang/rust/commit/640886ceb662ae212cf3edc7f400142af3aa7bbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/640886ceb662ae212cf3edc7f400142af3aa7bbf/comments", "author": null, "committer": null, "parents": [{"sha": "5c0cc474be9fc38537fa2fcbc20e9dc0f2f47169", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c0cc474be9fc38537fa2fcbc20e9dc0f2f47169", "html_url": "https://github.com/rust-lang/rust/commit/5c0cc474be9fc38537fa2fcbc20e9dc0f2f47169"}], "stats": {"total": 329, "additions": 329, "deletions": 0}, "files": [{"sha": "d5ad05fa6b01bb93fe966d89c35b997fada8ef4f", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/640886ceb662ae212cf3edc7f400142af3aa7bbf/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/640886ceb662ae212cf3edc7f400142af3aa7bbf/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=640886ceb662ae212cf3edc7f400142af3aa7bbf", "patch": "@@ -26,6 +26,7 @@ fn mode_str(m: &ty::mode) -> str {\n       mo_val. { \"\" }\n       mo_alias(false) { \"&\" }\n       mo_alias(true) { \"&mutable \" }\n+      mo_move. { \"-\" }\n     }\n }\n "}, {"sha": "ce4d2b2e44d6546466e23cb5063bfb369e07c772", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/640886ceb662ae212cf3edc7f400142af3aa7bbf/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/640886ceb662ae212cf3edc7f400142af3aa7bbf/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=640886ceb662ae212cf3edc7f400142af3aa7bbf", "patch": "@@ -0,0 +1,328 @@\n+/**\n+   A parallel word-frequency counting program.\n+\n+   This is meant primarily to demonstrate Rust's MapReduce framework.\n+\n+   It takes a list of files on the command line and outputs a list of\n+   words along with how many times each word is used.\n+\n+*/\n+\n+use std;\n+\n+import option = std::option::t;\n+import std::option::some;\n+import std::option::none;\n+import std::str;\n+import std::treemap;\n+import std::vec;\n+import std::io;\n+\n+import std::time;\n+import std::u64;\n+\n+import std::task;\n+import std::task::joinable_task;\n+import std::comm;\n+import std::comm::chan;\n+import std::comm::port;\n+import std::comm::recv;\n+import std::comm::send;\n+\n+fn map(filename: &[u8], emit: &map_reduce::putter<[u8], int>) {\n+    let f = io::file_reader(str::unsafe_from_bytes(filename));\n+\n+    while true {\n+        alt read_word(f) {\n+          some(w) { emit(str::bytes(w), 1); }\n+          none. { break; }\n+        }\n+    }\n+}\n+\n+fn reduce(word: &[u8], get: &map_reduce::getter<int>) {\n+    let count = 0;\n+\n+    while true { alt get() { some(_) { count += 1; } none. { break } } }\n+}\n+\n+mod map_reduce {\n+    export putter;\n+    export getter;\n+    export mapper;\n+    export reducer;\n+    export map_reduce;\n+\n+    type putter<~K, ~V> = fn(&K, &V);\n+\n+    // FIXME: the first K1 parameter should probably be a -, but that\n+    // doesn't parse at the moment.\n+    type mapper<~K1, ~K2, ~V> = fn(&K1, &putter<K2, V>);\n+\n+    type getter<~V> = fn() -> option<V>;\n+\n+    type reducer<~K, ~V> = fn(&K, &getter<V>);\n+\n+    tag ctrl_proto<~K, ~V> {\n+        find_reducer(K, chan<chan<reduce_proto<V>>>);\n+        mapper_done;\n+    }\n+\n+    tag reduce_proto<~V> { emit_val(V); done; ref; release; }\n+\n+    fn start_mappers<~K1, ~K2, ~V>(map : mapper<K1, K2, V>,\n+                             ctrl: chan<ctrl_proto<K2, V>>, inputs: &[K1])\n+        -> [joinable_task] {\n+        let tasks = [];\n+        for i in inputs {\n+            let m = map, c = ctrl, ii = i;\n+            tasks += [task::spawn_joinable(bind map_task(m, c, ii))];\n+        }\n+        ret tasks;\n+    }\n+\n+    fn map_task<~K1, ~K2, ~V>(map : -mapper<K1,K2,V>,\n+                              ctrl: -chan<ctrl_proto<K2,V>>, input: -K1) {\n+        // log_err \"map_task \" + input;\n+        let intermediates = treemap::init();\n+\n+        fn emit<~K2, ~V>(im: &treemap::treemap<K2, chan<reduce_proto<V>>>,\n+                         ctrl: &chan<ctrl_proto<K2,V>>, key: &K2, val: &V) {\n+            let c;\n+            alt treemap::find(im, key) {\n+              some(_c) {\n+                c = _c\n+              }\n+              none. {\n+                let p = port();\n+                send(ctrl, find_reducer(key, chan(p)));\n+                c = recv(p);\n+                treemap::insert(im, key, c);\n+                send(c, ref);\n+              }\n+            }\n+            send(c, emit_val(val));\n+        }\n+\n+        map(input, bind emit(intermediates, ctrl, _, _));\n+\n+        fn finish<~K, ~V>(k : &K, v : &chan<reduce_proto<V>>) {\n+            send(v, release);\n+        }\n+        treemap::traverse(intermediates, finish);\n+        send(ctrl, mapper_done);\n+    }\n+\n+    fn reduce_task<~K, ~V>(reduce : -reducer<K,V>,\n+                           key: -K, out: -chan<chan<reduce_proto<V>>>) {\n+        let p = port();\n+\n+        send(out, chan(p));\n+\n+        let ref_count = 0;\n+        let is_done = false;\n+\n+        fn get<~V>(p: &port<reduce_proto<V>>, ref_count: &mutable int,\n+               is_done: &mutable bool) -> option<V> {\n+            while !is_done || ref_count > 0 {\n+                alt recv(p) {\n+                  emit_val(v) {\n+                    // log_err #fmt(\"received %d\", v);\n+                    ret some(v);\n+                  }\n+                  done. {\n+                    // log_err \"all done\";\n+                    is_done = true;\n+                  }\n+                  ref. { ref_count += 1; }\n+                  release. { ref_count -= 1; }\n+                }\n+            }\n+            ret none;\n+        }\n+\n+        reduce(key, bind get(p, ref_count, is_done));\n+    }\n+\n+    fn map_reduce<~K1, ~K2, ~V>(map : mapper<K1,K2,V>,\n+                               reduce : reducer<K2, V>,\n+                               inputs: &[K1]) {\n+        let ctrl = port();\n+\n+        // This task becomes the master control task. It task::_spawns\n+        // to do the rest.\n+\n+        let reducers = treemap::init();\n+\n+        let tasks = start_mappers(map, chan(ctrl), inputs);\n+\n+        let num_mappers = vec::len(inputs) as int;\n+\n+        while num_mappers > 0 {\n+            alt recv(ctrl) {\n+              mapper_done. {\n+                // log_err \"received mapper terminated.\";\n+                num_mappers -= 1;\n+              }\n+              find_reducer(k, cc) {\n+                let c;\n+                // log_err \"finding reducer for \" + k;\n+                alt treemap::find(reducers, k) {\n+                  some(_c) {\n+                    // log_err \"reusing existing reducer for \" + k;\n+                    c = _c;\n+                  }\n+                  none. {\n+                    // log_err \"creating new reducer for \" + k;\n+                    let p = port();\n+                    let r = reduce, kk = k;\n+                    tasks +=\n+                        [task::spawn_joinable(bind reduce_task(r,\n+                                                               kk, chan(p)))];\n+                    c = recv(p);\n+                    treemap::insert(reducers, k, c);\n+                  }\n+                }\n+                send(cc, c);\n+              }\n+            }\n+        }\n+\n+        fn finish<~K, ~V>(k : &K, v : &chan<reduce_proto<V>>) {\n+            send(v, done);\n+        }\n+        treemap::traverse(reducers, finish);\n+\n+        for t in tasks { task::join(t); }\n+    }\n+}\n+\n+fn main(argv: [str]) {\n+    if vec::len(argv) < 2u {\n+        let out = io::stdout();\n+\n+        out.write_line(#fmt[\"Usage: %s <filename> ...\", argv[0]]);\n+\n+        // TODO: run something just to make sure the code hasn't\n+        // broken yet. This is the unit test mode of this program.\n+\n+        ret;\n+    }\n+\n+    let iargs = [];\n+    for a in vec::slice(argv, 1u, vec::len(argv)) {\n+        iargs += [str::bytes(a)];\n+    }\n+\n+    // We can get by with 8k stacks, and we'll probably exhaust our\n+    // address space otherwise.\n+    task::set_min_stack(8192u);\n+\n+    let start = time::precise_time_ns();\n+\n+    map_reduce::map_reduce(map, reduce, iargs);\n+    let stop = time::precise_time_ns();\n+\n+    let elapsed = stop - start;\n+    elapsed /= 1000000u64;\n+\n+    log_err \"MapReduce completed in \" + u64::str(elapsed) + \"ms\";\n+}\n+\n+fn read_word(r: io::reader) -> option<str> {\n+    let w = \"\";\n+\n+    while !r.eof() {\n+        let c = r.read_char();\n+\n+\n+        if is_word_char(c) {\n+            w += str::from_char(c);\n+        } else { if w != \"\" { ret some(w); } }\n+    }\n+    ret none;\n+}\n+\n+fn is_digit(c: char) -> bool {\n+    alt c {\n+      '0' { true }\n+      '1' { true }\n+      '2' { true }\n+      '3' { true }\n+      '4' { true }\n+      '5' { true }\n+      '6' { true }\n+      '7' { true }\n+      '8' { true }\n+      '9' { true }\n+      _ { false }\n+    }\n+}\n+\n+fn is_alpha_lower(c: char) -> bool {\n+    alt c {\n+      'a' { true }\n+      'b' { true }\n+      'c' { true }\n+      'd' { true }\n+      'e' { true }\n+      'f' { true }\n+      'g' { true }\n+      'h' { true }\n+      'i' { true }\n+      'j' { true }\n+      'k' { true }\n+      'l' { true }\n+      'm' { true }\n+      'n' { true }\n+      'o' { true }\n+      'p' { true }\n+      'q' { true }\n+      'r' { true }\n+      's' { true }\n+      't' { true }\n+      'u' { true }\n+      'v' { true }\n+      'w' { true }\n+      'x' { true }\n+      'y' { true }\n+      'z' { true }\n+      _ { false }\n+    }\n+}\n+\n+fn is_alpha_upper(c: char) -> bool {\n+    alt c {\n+      'A' { true }\n+      'B' { true }\n+      'C' { true }\n+      'D' { true }\n+      'E' { true }\n+      'F' { true }\n+      'G' { true }\n+      'H' { true }\n+      'I' { true }\n+      'J' { true }\n+      'K' { true }\n+      'L' { true }\n+      'M' { true }\n+      'N' { true }\n+      'O' { true }\n+      'P' { true }\n+      'Q' { true }\n+      'R' { true }\n+      'S' { true }\n+      'T' { true }\n+      'U' { true }\n+      'V' { true }\n+      'W' { true }\n+      'X' { true }\n+      'Y' { true }\n+      'Z' { true }\n+      _ { false }\n+    }\n+}\n+\n+fn is_alpha(c: char) -> bool { is_alpha_upper(c) || is_alpha_lower(c) }\n+\n+fn is_word_char(c: char) -> bool { is_alpha(c) || is_digit(c) || c == '_' }"}]}