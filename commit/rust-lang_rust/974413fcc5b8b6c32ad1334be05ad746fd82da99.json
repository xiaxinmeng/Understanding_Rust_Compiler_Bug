{"sha": "974413fcc5b8b6c32ad1334be05ad746fd82da99", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NDQxM2ZjYzViOGI2YzMyYWQxMzM0YmUwNWFkNzQ2ZmQ4MmRhOTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-09T01:55:13Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-28T04:53:38Z"}, "message": "Recover on '..X' / '..=X' / '...X' range patterns.", "tree": {"sha": "e6b3bdf8e30110b694cd66f3fe604f389d8a1567", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6b3bdf8e30110b694cd66f3fe604f389d8a1567"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/974413fcc5b8b6c32ad1334be05ad746fd82da99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/974413fcc5b8b6c32ad1334be05ad746fd82da99", "html_url": "https://github.com/rust-lang/rust/commit/974413fcc5b8b6c32ad1334be05ad746fd82da99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/974413fcc5b8b6c32ad1334be05ad746fd82da99/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62b29a1e1774e8bf6c4246f2b47d556a9178ed67", "url": "https://api.github.com/repos/rust-lang/rust/commits/62b29a1e1774e8bf6c4246f2b47d556a9178ed67", "html_url": "https://github.com/rust-lang/rust/commit/62b29a1e1774e8bf6c4246f2b47d556a9178ed67"}], "stats": {"total": 52, "additions": 46, "deletions": 6}, "files": [{"sha": "e1bbd7631e5ea32b65973ec7d8622962aae43809", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/974413fcc5b8b6c32ad1334be05ad746fd82da99/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974413fcc5b8b6c32ad1334be05ad746fd82da99/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=974413fcc5b8b6c32ad1334be05ad746fd82da99", "patch": "@@ -3730,6 +3730,13 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Is the current token suitable as the start of a range patterns end?\n+    fn is_pat_range_end_start(&self) -> bool {\n+        self.token.is_path_start() // e.g. `MY_CONST`;\n+            || self.token == token::Dot // e.g. `.5` for recovery;\n+            || self.token.can_begin_literal_or_bool() // e.g. `42`.\n+    }\n+\n     // helper function to decide whether to parse as ident binding or to try to do\n     // something more complex like range patterns\n     fn parse_as_ident(&mut self) -> bool {\n@@ -3802,6 +3809,26 @@ impl<'a> Parser<'a> {\n         self.parse_pat_with_range_pat(true, expected)\n     }\n \n+    /// Parse a range-to pattern, e.g. `..X` and `..=X` for recovery.\n+    fn parse_pat_range_to(&mut self, re: RangeEnd, form: &str) -> PResult<'a, PatKind> {\n+        let lo = self.prev_span;\n+        let end = self.parse_pat_range_end()?;\n+        let range_span = lo.to(end.span);\n+        let begin = self.mk_expr(range_span, ExprKind::Err, ThinVec::new());\n+\n+        self.diagnostic()\n+            .struct_span_err(range_span, &format!(\"`{}X` range patterns are not supported\", form))\n+            .span_suggestion(\n+                range_span,\n+                \"try using the minimum value for the type\",\n+                format!(\"MIN{}{}\", form, pprust::expr_to_string(&end)),\n+                Applicability::HasPlaceholders,\n+            )\n+            .emit();\n+\n+        Ok(PatKind::Range(begin, end, respan(lo, re)))\n+    }\n+\n     /// Parses a pattern, with a setting whether modern range patterns (e.g., `a..=b`, `a..b` are\n     /// allowed).\n     fn parse_pat_with_range_pat(\n@@ -3843,9 +3870,24 @@ impl<'a> Parser<'a> {\n                 pat = PatKind::Slice(slice);\n             }\n             token::DotDot => {\n-                // Parse `..`.\n                 self.bump();\n-                pat = PatKind::Rest;\n+                pat = if self.is_pat_range_end_start() {\n+                    // Parse `..42` for recovery.\n+                    self.parse_pat_range_to(RangeEnd::Excluded, \"..\")?\n+                } else {\n+                    // A rest pattern `..`.\n+                    PatKind::Rest\n+                };\n+            }\n+            token::DotDotEq => {\n+                // Parse `..=42` for recovery.\n+                self.bump();\n+                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?;\n+            }\n+            token::DotDotDot => {\n+                // Parse `...42` for recovery.\n+                self.bump();\n+                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?;\n             }\n             // At this point, token != &, &&, (, [\n             _ => if self.eat_keyword(kw::Underscore) {\n@@ -3915,8 +3957,7 @@ impl<'a> Parser<'a> {\n                         let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n                         let end = self.parse_pat_range_end()?;\n-                        let op = Spanned { span: op_span, node: end_kind };\n-                        pat = PatKind::Range(begin, end, op);\n+                        pat = PatKind::Range(begin, end, respan(op_span, end_kind));\n                     }\n                     token::OpenDelim(token::Brace) => {\n                         if qself.is_some() {\n@@ -3966,8 +4007,7 @@ impl<'a> Parser<'a> {\n                                         on a range-operator token\")\n                             };\n                             let end = self.parse_pat_range_end()?;\n-                            let op = Spanned { span: op_span, node: end_kind };\n-                            pat = PatKind::Range(begin, end, op);\n+                            pat = PatKind::Range(begin, end, respan(op_span, end_kind))\n                         } else {\n                             pat = PatKind::Lit(begin);\n                         }"}]}