{"sha": "09defbcb5b733773c516a31f0206d344e6555f72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZGVmYmNiNWI3MzM3NzNjNTE2YTMxZjAyMDZkMzQ0ZTY1NTVmNzI=", "commit": {"author": {"name": "Thomas Jespersen", "email": "laumann.thomas@gmail.com", "date": "2017-03-20T19:02:51Z"}, "committer": {"name": "Thomas Jespersen", "email": "laumann.thomas@gmail.com", "date": "2017-09-21T10:05:56Z"}, "message": "Add suggestions for misspelled method names\n\nUse the syntax::util::lev_distance module to provide suggestions when a\nnamed method cannot be found.\n\nPart of #30197", "tree": {"sha": "deadb2d4a06615237e0767512a37cce1e95bce3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deadb2d4a06615237e0767512a37cce1e95bce3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09defbcb5b733773c516a31f0206d344e6555f72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09defbcb5b733773c516a31f0206d344e6555f72", "html_url": "https://github.com/rust-lang/rust/commit/09defbcb5b733773c516a31f0206d344e6555f72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09defbcb5b733773c516a31f0206d344e6555f72/comments", "author": null, "committer": null, "parents": [{"sha": "ef227f5ffe438783db0add58208d79dd84158c06", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef227f5ffe438783db0add58208d79dd84158c06", "html_url": "https://github.com/rust-lang/rust/commit/ef227f5ffe438783db0add58208d79dd84158c06"}], "stats": {"total": 155, "additions": 145, "deletions": 10}, "files": [{"sha": "f344b6362203e070d92f09b6dfe11df8f2eb6c25", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09defbcb5b733773c516a31f0206d344e6555f72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09defbcb5b733773c516a31f0206d344e6555f72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=09defbcb5b733773c516a31f0206d344e6555f72", "patch": "@@ -68,19 +68,22 @@ pub enum MethodError<'tcx> {\n // could lead to matches if satisfied, and a list of not-in-scope traits which may work.\n pub struct NoMatchData<'tcx> {\n     pub static_candidates: Vec<CandidateSource>,\n+    pub lev_candidates: Vec<ty::AssociatedItem>,\n     pub unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n     pub out_of_scope_traits: Vec<DefId>,\n     pub mode: probe::Mode,\n }\n \n impl<'tcx> NoMatchData<'tcx> {\n     pub fn new(static_candidates: Vec<CandidateSource>,\n+               lev_candidates: Vec<ty::AssociatedItem>,\n                unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n                out_of_scope_traits: Vec<DefId>,\n                mode: probe::Mode)\n                -> Self {\n         NoMatchData {\n             static_candidates,\n+            lev_candidates,\n             unsatisfied_predicates,\n             out_of_scope_traits,\n             mode,"}, {"sha": "2041ff58861ef2b89962f910ed4563d3df22efec", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 61, "deletions": 10, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/09defbcb5b733773c516a31f0206d344e6555f72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09defbcb5b733773c516a31f0206d344e6555f72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=09defbcb5b733773c516a31f0206d344e6555f72", "patch": "@@ -23,11 +23,13 @@ use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use rustc::infer::{self, InferOk};\n use syntax::ast;\n+use syntax::util::lev_distance::lev_distance;\n use syntax_pos::Span;\n use rustc::hir;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n+use std::cmp::max;\n \n use self::CandidateKind::*;\n pub use self::PickKind::*;\n@@ -51,6 +53,10 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// used for error reporting\n     static_candidates: Vec<CandidateSource>,\n \n+    /// When probing for names, include names that are close to the\n+    /// requested name (by Levensthein distance)\n+    allow_similar_names: bool,\n+\n     /// Some(candidate) if there is a private candidate\n     private_candidate: Option<Def>,\n \n@@ -240,6 +246,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 Some(steps) => steps,\n                 None => {\n                     return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n+                                                                     Vec::new(),\n                                                                      Vec::new(),\n                                                                      Vec::new(),\n                                                                      mode)))\n@@ -261,7 +268,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // that we create during the probe process are removed later\n         self.probe(|_| {\n             let mut probe_cx =\n-                ProbeContext::new(self, span, mode, method_name, return_type, steps);\n+                ProbeContext::new(self, span, mode, method_name, return_type, Rc::new(steps));\n \n             probe_cx.assemble_inherent_candidates();\n             match scope {\n@@ -333,7 +340,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n            mode: Mode,\n            method_name: Option<ast::Name>,\n            return_type: Option<Ty<'tcx>>,\n-           steps: Vec<CandidateStep<'tcx>>)\n+           steps: Rc<Vec<CandidateStep<'tcx>>>)\n            -> ProbeContext<'a, 'gcx, 'tcx> {\n         ProbeContext {\n             fcx,\n@@ -344,8 +351,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: FxHashSet(),\n-            steps: Rc::new(steps),\n+            steps: steps,\n             static_candidates: Vec::new(),\n+            allow_similar_names: false,\n             private_candidate: None,\n             unsatisfied_predicates: Vec::new(),\n         }\n@@ -798,8 +806,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         if let Some(def) = private_candidate {\n             return Err(MethodError::PrivateMatch(def, out_of_scope_traits));\n         }\n+        let lev_candidates = self.probe_for_lev_candidates()?;\n \n         Err(MethodError::NoMatch(NoMatchData::new(static_candidates,\n+                                                  lev_candidates,\n                                                   unsatisfied_predicates,\n                                                   out_of_scope_traits,\n                                                   self.mode)))\n@@ -913,11 +923,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         debug!(\"applicable_candidates: {:?}\", applicable_candidates);\n \n         if applicable_candidates.len() > 1 {\n-            match self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n-                Some(pick) => {\n-                    return Some(Ok(pick));\n-                }\n-                None => {}\n+            if let Some(pick) = self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n+                return Some(Ok(pick));\n             }\n         }\n \n@@ -1126,6 +1133,39 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         })\n     }\n \n+    /// Similarly to `probe_for_return_type`, this method attempts to find candidate methods where\n+    /// the method name may have been misspelt.\n+    fn probe_for_lev_candidates(&mut self) -> Result<Vec<ty::AssociatedItem>, MethodError<'tcx>> {\n+        debug!(\"Probing for method names similar to {:?}\",\n+               self.method_name);\n+\n+        let steps = self.steps.clone();\n+        self.probe(|_| {\n+            let mut pcx = ProbeContext::new(self.fcx, self.span, self.mode, self.method_name,\n+                                            self.return_type, steps);\n+            pcx.allow_similar_names = true;\n+            pcx.assemble_inherent_candidates();\n+            pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)?;\n+\n+            let method_names = pcx.candidate_method_names();\n+            pcx.allow_similar_names = false;\n+            Ok(method_names\n+                .iter()\n+                .filter_map(|&method_name| {\n+                    pcx.reset();\n+                    pcx.method_name = Some(method_name);\n+                    pcx.assemble_inherent_candidates();\n+                    pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)\n+                        .ok().map_or(None, |_| {\n+                            pcx.pick_core()\n+                                .and_then(|pick| pick.ok())\n+                                .and_then(|pick| Some(pick.item))\n+                        })\n+                })\n+               .collect())\n+        })\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n     fn has_applicable_self(&self, item: &ty::AssociatedItem) -> bool {\n@@ -1253,10 +1293,21 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.tcx.erase_late_bound_regions(value)\n     }\n \n-    /// Find the method with the appropriate name (or return type, as the case may be).\n+    /// Find the method with the appropriate name (or return type, as the case may be). If\n+    /// `allow_similar_names` is set, find methods with close-matching names.\n     fn impl_or_trait_item(&self, def_id: DefId) -> Vec<ty::AssociatedItem> {\n         if let Some(name) = self.method_name {\n-            self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n+            if self.allow_similar_names {\n+                let max_dist = max(name.as_str().len(), 3) / 3;\n+                self.tcx.associated_items(def_id)\n+                    .filter(|x| {\n+                        let dist = lev_distance(&*name.as_str(), &x.name.as_str());\n+                        dist > 0 && dist <= max_dist\n+                    })\n+                    .collect()\n+            } else {\n+                self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n+            }\n         } else {\n             self.tcx.associated_items(def_id).collect()\n         }"}, {"sha": "d65ea5f7fb5caca1c4714e7e3cebd8a439d27866", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09defbcb5b733773c516a31f0206d344e6555f72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09defbcb5b733773c516a31f0206d344e6555f72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=09defbcb5b733773c516a31f0206d344e6555f72", "patch": "@@ -162,6 +162,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         match error {\n             MethodError::NoMatch(NoMatchData { static_candidates: static_sources,\n+                                               lev_candidates,\n                                                unsatisfied_predicates,\n                                                out_of_scope_traits,\n                                                mode,\n@@ -282,6 +283,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                               item_name,\n                                               rcvr_expr,\n                                               out_of_scope_traits);\n+\n+                if !lev_candidates.is_empty() {\n+                    for meth in lev_candidates.iter().take(5) {\n+                        err.help(&format!(\"did you mean `{}`?\", meth.name));\n+                    }\n+                }\n                 err.emit();\n             }\n "}, {"sha": "e3f0df6fb5f1a6996b8fbe75b58de77215e66292", "filename": "src/test/ui/block-result/issue-3563.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09defbcb5b733773c516a31f0206d344e6555f72/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09defbcb5b733773c516a31f0206d344e6555f72/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr?ref=09defbcb5b733773c516a31f0206d344e6555f72", "patch": "@@ -3,6 +3,8 @@ error[E0599]: no method named `b` found for type `&Self` in the current scope\n    |\n 13 |         || self.b()\n    |                 ^\n+   |\n+   = help: did you mean `a`?\n \n error[E0308]: mismatched types\n   --> $DIR/issue-3563.rs:13:9"}, {"sha": "36b9976ae56f6fee47ed6e8cc8e8638522a48ebc", "filename": "src/test/ui/suggestions/suggest-methods.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/09defbcb5b733773c516a31f0206d344e6555f72/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09defbcb5b733773c516a31f0206d344e6555f72/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.rs?ref=09defbcb5b733773c516a31f0206d344e6555f72", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(self) {}\n+    fn baz(&self, x: f64) {}\n+}\n+\n+trait FooT {\n+    fn bag(&self);\n+}\n+\n+impl FooT for Foo {\n+    fn bag(&self) {}\n+}\n+\n+fn main() {\n+    let f = Foo;\n+    f.bat(1.0);\n+\n+    let s = \"foo\".to_string();\n+    let _ = s.is_emtpy();\n+\n+    // Generates a warning, both for count_ones and count_zeros\n+    let _ = 63u32.count_eos();\n+    let _ = 63u32.count_o(); // Does not generate a warning\n+\n+}\n+"}, {"sha": "d1a5ebcdef4690367e85cb8c8fc06776057da4bb", "filename": "src/test/ui/suggestions/suggest-methods.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/09defbcb5b733773c516a31f0206d344e6555f72/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09defbcb5b733773c516a31f0206d344e6555f72/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.stderr?ref=09defbcb5b733773c516a31f0206d344e6555f72", "patch": "@@ -0,0 +1,34 @@\n+error[E0599]: no method named `bat` found for type `Foo` in the current scope\n+  --> $DIR/suggest-methods.rs:28:7\n+   |\n+28 |     f.bat(1.0);\n+   |       ^^^\n+   |\n+   = help: did you mean `bar`?\n+   = help: did you mean `baz`?\n+\n+error[E0599]: no method named `is_emtpy` found for type `std::string::String` in the current scope\n+  --> $DIR/suggest-methods.rs:31:15\n+   |\n+31 |     let _ = s.is_emtpy();\n+   |               ^^^^^^^^\n+   |\n+   = help: did you mean `is_empty`?\n+\n+error[E0599]: no method named `count_eos` found for type `u32` in the current scope\n+  --> $DIR/suggest-methods.rs:34:19\n+   |\n+34 |     let _ = 63u32.count_eos();\n+   |                   ^^^^^^^^^\n+   |\n+   = help: did you mean `count_ones`?\n+   = help: did you mean `count_zeros`?\n+\n+error[E0599]: no method named `count_o` found for type `u32` in the current scope\n+  --> $DIR/suggest-methods.rs:35:19\n+   |\n+35 |     let _ = 63u32.count_o(); // Does not generate a warning\n+   |                   ^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}]}