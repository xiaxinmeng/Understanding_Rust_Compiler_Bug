{"sha": "f91351aaf69b0d4fefaff0df1c288466c0183de5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MTM1MWFhZjY5YjBkNGZlZmFmZjBkZjFjMjg4NDY2YzAxODNkZTU=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-16T04:54:52Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-16T05:19:50Z"}, "message": "The wonky for...in... whitespace was bothering me.  Sorry!", "tree": {"sha": "ca66d19b0991260c5b0f386969bcfe091ca8ada3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca66d19b0991260c5b0f386969bcfe091ca8ada3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f91351aaf69b0d4fefaff0df1c288466c0183de5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f91351aaf69b0d4fefaff0df1c288466c0183de5", "html_url": "https://github.com/rust-lang/rust/commit/f91351aaf69b0d4fefaff0df1c288466c0183de5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f91351aaf69b0d4fefaff0df1c288466c0183de5/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb239cc028d388ce9784ffc023639924c5a2e59b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb239cc028d388ce9784ffc023639924c5a2e59b", "html_url": "https://github.com/rust-lang/rust/commit/cb239cc028d388ce9784ffc023639924c5a2e59b"}], "stats": {"total": 1130, "additions": 565, "deletions": 565}, "files": [{"sha": "f93107d6a17016fb4205914d272d27c9340abb74", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -296,7 +296,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n         let cmh_items: [@ast::meta_item] = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess, linkage_metas);\n-        for meta: @ast::meta_item  in linkage_metas {\n+        for meta: @ast::meta_item in linkage_metas {\n             if attr::get_meta_item_name(meta) == \"name\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { name = some(v); }\n@@ -326,7 +326,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n         let cmh_items = attr::sort_meta_items(metas.cmh_items);\n \n         sha.reset();\n-        for m_: @ast::meta_item  in cmh_items {\n+        for m_: @ast::meta_item in cmh_items {\n             let m = m_;\n             alt m.node {\n               ast::meta_name_value(key, value) {\n@@ -429,7 +429,7 @@ fn mangle(ss: &[str]) -> str {\n \n     let n = \"_ZN\"; // Begin name-sequence.\n \n-    for s: str  in ss { n += #fmt(\"%u%s\", str::byte_len(s), s); }\n+    for s: str in ss { n += #fmt(\"%u%s\", str::byte_len(s), s); }\n     n += \"E\"; // End name-sequence.\n \n     ret n;"}, {"sha": "6984efaa113b0d7feefe5c08f8715477adac92f9", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -68,7 +68,7 @@ fn declare_upcalls(tn: type_names, tydesc_type: TypeRef,\n     fn decl(tn: type_names, llmod: ModuleRef, name: str, tys: [TypeRef],\n           rv: TypeRef) -> ValueRef {\n         let arg_tys: [TypeRef] = ~[];\n-        for t: TypeRef  in tys { arg_tys += ~[t]; }\n+        for t: TypeRef in tys { arg_tys += ~[t]; }\n         let fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }"}, {"sha": "e6324aa73d658963c081eb38fb3c52aad97a31ab", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -82,7 +82,7 @@ fn parse_cfgspecs(cfgspecs: &[str]) -> ast::crate_cfg {\n     // FIXME: It would be nice to use the parser to parse all varieties of\n     // meta_item here. At the moment we just support the meta_word variant.\n     let words = ~[];\n-    for s: str  in cfgspecs { words += ~[attr::mk_word_item(s)]; }\n+    for s: str in cfgspecs { words += ~[attr::mk_word_item(s)]; }\n     ret words;\n }\n \n@@ -334,7 +334,7 @@ fn build_session_options(binary: str, match: getopts::match, binary_dir: str)\n \n     let library_search_paths = ~[binary_dir + \"/lib\"];\n     let lsp_vec = getopts::opt_strs(match, \"L\");\n-    for lsp: str  in lsp_vec { library_search_paths += ~[lsp]; }\n+    for lsp: str in lsp_vec { library_search_paths += ~[lsp]; }\n \n     let parse_only = opt_present(match, \"parse-only\");\n     let no_trans = opt_present(match, \"no-trans\");\n@@ -591,7 +591,7 @@ fn main(args: vec[str]) {\n     }\n \n     let cstore = sess.get_cstore();\n-    for cratepath: str  in cstore::get_used_crate_files(cstore) {\n+    for cratepath: str in cstore::get_used_crate_files(cstore) {\n         if str::ends_with(cratepath, \".rlib\") {\n             gcc_args += ~[cratepath];\n             cont;\n@@ -603,10 +603,10 @@ fn main(args: vec[str]) {\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for arg: str  in ula { gcc_args += ~[arg]; }\n+    for arg: str in ula { gcc_args += ~[arg]; }\n \n     let used_libs = cstore::get_used_libraries(cstore);\n-    for l: str  in used_libs { gcc_args += ~[\"-l\" + l]; }\n+    for l: str in used_libs { gcc_args += ~[\"-l\" + l]; }\n \n     if sopts.library {\n         gcc_args += ~[lib_cmd];"}, {"sha": "6a12972affdf6aab44b6f45d6a7229690f8633d7", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -31,7 +31,7 @@ export mk_attr;\n // linkage\n fn find_linkage_metas(attrs: &[ast::attribute]) -> [@ast::meta_item] {\n     let metas: [@ast::meta_item] = ~[];\n-    for attr: ast::attribute  in find_attrs_by_name(attrs, \"link\") {\n+    for attr: ast::attribute in find_attrs_by_name(attrs, \"link\") {\n         alt attr.node.value.node {\n           ast::meta_list(_, items) { metas += items; }\n           _ { log \"ignoring link attribute that has incorrect type\"; }\n@@ -96,7 +96,7 @@ fn attr_meta(attr: &ast::attribute) -> @ast::meta_item { @attr.node.value }\n // Get the meta_items from inside a vector of attributes\n fn attr_metas(attrs: &[ast::attribute]) -> [@ast::meta_item] {\n     let mitems = ~[];\n-    for a: ast::attribute  in attrs { mitems += ~[attr_meta(a)]; }\n+    for a: ast::attribute in attrs { mitems += ~[attr_meta(a)]; }\n     ret mitems;\n }\n \n@@ -124,7 +124,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n fn contains(haystack: &[@ast::meta_item], needle: @ast::meta_item) -> bool {\n     log #fmt(\"looking for %s\",\n              syntax::print::pprust::meta_item_to_str(*needle));\n-    for item: @ast::meta_item  in haystack {\n+    for item: @ast::meta_item in haystack {\n         log #fmt(\"looking in %s\",\n                  syntax::print::pprust::meta_item_to_str(*item));\n         if eq(item, needle) { log \"found it!\"; ret true; }\n@@ -153,12 +153,12 @@ fn sort_meta_items(items: &[@ast::meta_item]) -> [@ast::meta_item] {\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n     let v: [mutable @ast::meta_item] = ~[mutable];\n-    for mi: @ast::meta_item  in items { v += ~[mutable mi]; }\n+    for mi: @ast::meta_item in items { v += ~[mutable mi]; }\n \n     std::sort::quick_sort(lteq, v);\n \n     let v2: [@ast::meta_item] = ~[];\n-    for mi: @ast::meta_item  in v { v2 += ~[mi]; }\n+    for mi: @ast::meta_item in v { v2 += ~[mi]; }\n     ret v2;\n }\n \n@@ -179,7 +179,7 @@ fn remove_meta_items_by_name(items: &[@ast::meta_item], name: str) ->\n fn require_unique_names(sess: &session::session,\n                         metas: &[@ast::meta_item]) {\n     let map = map::mk_hashmap[str, ()](str::hash, str::eq);\n-    for meta: @ast::meta_item  in metas {\n+    for meta: @ast::meta_item in metas {\n         let name = get_meta_item_name(meta);\n         if map.contains_key(name) {\n             sess.span_fatal(meta.span,"}, {"sha": "b65b221cae4ee1e07ee2bc7961edd19af657070c", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -118,7 +118,7 @@ fn in_cfg(cfg: &ast::crate_cfg, attrs: &[ast::attribute]) -> bool {\n             ivec::foldl(extract_metas, ~[], cfg_metas)\n         };\n \n-    for cfg_mi: @ast::meta_item  in item_cfg_metas {\n+    for cfg_mi: @ast::meta_item in item_cfg_metas {\n         if attr::contains(cfg, cfg_mi) { ret true; }\n     }\n "}, {"sha": "5d6cc62c37dc387ffe435cf5dc911ca53f1e3da8", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -229,7 +229,7 @@ fn mk_test_desc_ivec_ty(cx: &test_ctxt) -> @ast::ty {\n fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n     log #fmt(\"building test vector from %u tests\", ivec::len(cx.testfns));\n     let descs = ~[];\n-    for test: test  in cx.testfns {\n+    for test: test in cx.testfns {\n         let test_ = test; // Satisfy alias analysis\n         descs += ~[mk_test_desc_rec(cx, test_)];\n     }"}, {"sha": "cefff79f0b5d26084d821abb2a9c7d8aa4184b49", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -1469,7 +1469,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n     fn tys_str(names: type_names, outer: &[TypeRef], tys: &[TypeRef]) -> str {\n         let s: str = \"\";\n         let first: bool = true;\n-        for t: TypeRef  in tys {\n+        for t: TypeRef in tys {\n             if first { first = false; } else { s += \", \"; }\n             s += type_to_str_inner(names, outer, t);\n         }\n@@ -1531,7 +1531,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n \n       11 {\n         let i: uint = 0u;\n-        for tout: TypeRef  in outer0 {\n+        for tout: TypeRef in outer0 {\n             i += 1u;\n             if tout as int == ty as int {\n                 let n: uint = ivec::len[TypeRef](outer0) - i;"}, {"sha": "9d6a2c745f8e71ef6e4e4aeda942c0128e8edde6", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -69,7 +69,7 @@ fn hash_node_id(node_id: &int) -> uint { ret 177573u ^ (node_id as uint); }\n \n fn hash_path(s: &str) -> uint {\n     let h = 5381u;\n-    for ch: u8  in str::bytes(s) { h = (h << 5u) + h ^ (ch as uint); }\n+    for ch: u8 in str::bytes(s) { h = (h << 5u) + h ^ (ch as uint); }\n     ret h;\n }\n "}, {"sha": "38cf9e619f397490b8f33e9e2fc706978e00455a", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -96,7 +96,7 @@ fn metadata_matches(crate_data: &@[u8], metas: &[@ast::meta_item]) -> bool {\n     log #fmt(\"matching %u metadata requirements against %u items\",\n              ivec::len(metas), ivec::len(linkage_metas));\n \n-    for needed: @ast::meta_item  in metas {\n+    for needed: @ast::meta_item in metas {\n         if !attr::contains(linkage_metas, needed) {\n             log #fmt(\"missing %s\", pprust::meta_item_to_str(*needed));\n             ret false;\n@@ -156,9 +156,9 @@ fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: str,\n     // stomach from here, and writing a C++ wrapper is more work than just\n     // manually filtering fs::list_dir here.\n \n-    for library_search_path: str  in library_search_paths {\n+    for library_search_path: str in library_search_paths {\n         log #fmt(\"searching %s\", library_search_path);\n-        for path: str  in fs::list_dir(library_search_path) {\n+        for path: str in fs::list_dir(library_search_path) {\n             log #fmt(\"searching %s\", path);\n             let f: str = fs::basename(path);\n             if !(str::starts_with(f, prefix) && str::ends_with(f, nn.suffix))\n@@ -250,7 +250,7 @@ fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let cnum_map = new_int_hash[ast::crate_num]();\n-    for dep: decoder::crate_dep  in decoder::get_crate_deps(cdata) {\n+    for dep: decoder::crate_dep in decoder::get_crate_deps(cdata) {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.ident;\n         log #fmt(\"resolving dep %s\", cname);"}, {"sha": "2fadfaab7a713aba49c563dedeb30533cd939bf6", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -46,7 +46,7 @@ fn lookup_hash(d: &ebml::doc, eq_fn: fn(&[u8]) -> bool , hash: uint) ->\n \n     let result: [ebml::doc] = ~[];\n     let belt = tag_index_buckets_bucket_elt;\n-    for each elt: ebml::doc  in ebml::tagged_docs(bucket, belt) {\n+    for each elt: ebml::doc in ebml::tagged_docs(bucket, belt) {\n         let pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n         if eq_fn(ivec::slice[u8](*elt.data, elt.start + 4u, elt.end)) {\n             result += ~[ebml::doc_at(d.data, pos)];\n@@ -138,7 +138,7 @@ fn tag_variant_ids(item: &ebml::doc, this_cnum: ast::crate_num) ->\n    [ast::def_id] {\n     let ids: [ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n-    for each p: ebml::doc  in ebml::tagged_docs(item, v) {\n+    for each p: ebml::doc in ebml::tagged_docs(item, v) {\n         let ext = parse_def_id(ebml::doc_data(p));\n         ids += ~[{crate: this_cnum, node: ext.node}];\n     }\n@@ -156,7 +156,7 @@ fn resolve_path(path: &[ast::ident], data: @[u8]) -> [ast::def_id] {\n     let paths = ebml::get_doc(md, tag_paths);\n     let eqer = bind eq_item(_, s);\n     let result: [ast::def_id] = ~[];\n-    for doc: ebml::doc  in lookup_hash(paths, eqer, hash_path(s)) {\n+    for doc: ebml::doc in lookup_hash(paths, eqer, hash_path(s)) {\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n         result += ~[parse_def_id(ebml::doc_data(did_doc))];\n     }\n@@ -233,13 +233,13 @@ fn get_tag_variants(data: &@[u8], def: ast::def_id, tcx: &ty::ctxt,\n     let item = find_item(def.node, items);\n     let infos: [ty::variant_info] = ~[];\n     let variant_ids = tag_variant_ids(item, external_crate_id);\n-    for did: ast::def_id  in variant_ids {\n+    for did: ast::def_id in variant_ids {\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type(item, external_crate_id, tcx, extres);\n         let arg_tys: [ty::t] = ~[];\n         alt ty::struct(tcx, ctor_ty) {\n           ty::ty_fn(_, args, _, _, _) {\n-            for a: ty::arg  in args { arg_tys += ~[a.ty]; }\n+            for a: ty::arg in args { arg_tys += ~[a.ty]; }\n           }\n           _ {\n             // Nullary tag variant.\n@@ -344,15 +344,15 @@ fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n }\n \n fn list_meta_items(meta_items: &ebml::doc, out: io::writer) {\n-    for mi: @ast::meta_item  in get_meta_items(meta_items) {\n+    for mi: @ast::meta_item in get_meta_items(meta_items) {\n         out.write_str(#fmt(\"%s\\n\", pprust::meta_item_to_str(*mi)));\n     }\n }\n \n fn list_crate_attributes(md: &ebml::doc, out: io::writer) {\n     out.write_str(\"=Crate Attributes=\\n\");\n \n-    for attr: ast::attribute  in get_attributes(md) {\n+    for attr: ast::attribute in get_attributes(md) {\n         out.write_str(#fmt(\"%s\\n\", pprust::attribute_to_str(attr)));\n     }\n \n@@ -382,7 +382,7 @@ fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n fn list_crate_deps(data: @[u8], out: io::writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n-    for dep: crate_dep  in get_crate_deps(data) {\n+    for dep: crate_dep in get_crate_deps(data) {\n         out.write_str(#fmt(\"%d %s\\n\", dep.cnum, dep.ident));\n     }\n \n@@ -398,7 +398,7 @@ fn list_crate_items(bytes: &@[u8], md: &ebml::doc, out: io::writer) {\n     for each bucket: ebml::doc  in\n              ebml::tagged_docs(bs, tag_index_buckets_bucket) {\n         let et = tag_index_buckets_bucket_elt;\n-        for each elt: ebml::doc  in ebml::tagged_docs(bucket, et) {\n+        for each elt: ebml::doc in ebml::tagged_docs(bucket, et) {\n             let data = read_path(elt);\n             let def = ebml::doc_at(bytes, data.pos);\n             let did_doc = ebml::get_doc(def, tag_def_id);"}, {"sha": "2976745327f494017efce4d9b7847ff8c522b6c7", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -40,7 +40,7 @@ type entry[T] = {val: T, pos: uint};\n \n fn encode_tag_variant_paths(ebml_w: &ebml::writer, variants: &[variant],\n                             path: &[str], index: &mutable [entry[str]]) {\n-    for variant: variant  in variants {\n+    for variant: variant in variants {\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, variant.node.name);\n@@ -60,7 +60,7 @@ fn add_to_index(ebml_w: &ebml::writer, path: &[str],\n fn encode_native_module_item_paths(ebml_w: &ebml::writer,\n                                    nmod: &native_mod, path: &[str],\n                                    index: &mutable [entry[str]]) {\n-    for nitem: @native_item  in nmod.items {\n+    for nitem: @native_item in nmod.items {\n         add_to_index(ebml_w, path, index, nitem.ident);\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, nitem.ident);\n@@ -71,7 +71,7 @@ fn encode_native_module_item_paths(ebml_w: &ebml::writer,\n \n fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n                             path: &[str], index: &mutable [entry[str]]) {\n-    for it: @item  in module.items {\n+    for it: @item in module.items {\n         if !is_exported(it.ident, module) { cont; }\n         alt it.node {\n           item_const(_, _) {\n@@ -228,7 +228,7 @@ fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n                            id: node_id, variants: &[variant],\n                            index: &mutable [entry[int]],\n                            ty_params: &[ty_param]) {\n-    for variant: variant  in variants {\n+    for variant: variant in variants {\n         index += ~[{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n@@ -298,7 +298,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebml::writer,\n         encode_family(ebml_w, 't' as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n-        for v: variant  in variants {\n+        for v: variant in variants {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n         ebml::end_tag(ebml_w);\n@@ -395,14 +395,14 @@ fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebml::writer) ->\n fn create_index[T](index: &[entry[T]], hash_fn: fn(&T) -> uint ) ->\n    [@[entry[T]]] {\n     let buckets: [@mutable [entry[T]]] = ~[];\n-    for each i: uint  in uint::range(0u, 256u) { buckets += ~[@mutable ~[]]; }\n-    for elt: entry[T]  in index {\n+    for each i: uint in uint::range(0u, 256u) { buckets += ~[@mutable ~[]]; }\n+    for elt: entry[T] in index {\n         let h = hash_fn(elt.val);\n         *buckets.(h % 256u) += ~[elt];\n     }\n \n     let buckets_frozen = ~[];\n-    for bucket: @mutable [entry[T]]  in buckets {\n+    for bucket: @mutable [entry[T]] in buckets {\n         buckets_frozen += ~[@*bucket];\n     }\n     ret buckets_frozen;\n@@ -414,10 +414,10 @@ fn encode_index[T](ebml_w: &ebml::writer, buckets: &[@[entry[T]]],\n     ebml::start_tag(ebml_w, tag_index);\n     let bucket_locs: [uint] = ~[];\n     ebml::start_tag(ebml_w, tag_index_buckets);\n-    for bucket: @[entry[T]]  in buckets {\n+    for bucket: @[entry[T]] in buckets {\n         bucket_locs += ~[ebml_w.writer.tell()];\n         ebml::start_tag(ebml_w, tag_index_buckets_bucket);\n-        for elt: entry[T]  in *bucket {\n+        for elt: entry[T] in *bucket {\n             ebml::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n             writer.write_be_uint(elt.pos, 4u);\n             write_fn(writer, elt.val);\n@@ -427,7 +427,7 @@ fn encode_index[T](ebml_w: &ebml::writer, buckets: &[@[entry[T]]],\n     }\n     ebml::end_tag(ebml_w);\n     ebml::start_tag(ebml_w, tag_index_table);\n-    for pos: uint  in bucket_locs { writer.write_be_uint(pos, 4u); }\n+    for pos: uint in bucket_locs { writer.write_be_uint(pos, 4u); }\n     ebml::end_tag(ebml_w);\n     ebml::end_tag(ebml_w);\n }\n@@ -467,7 +467,7 @@ fn encode_meta_item(ebml_w: &ebml::writer, mi: &meta_item) {\n         ebml::start_tag(ebml_w, tag_meta_item_name);\n         ebml_w.writer.write(str::bytes(name));\n         ebml::end_tag(ebml_w);\n-        for inner_item: @meta_item  in items {\n+        for inner_item: @meta_item in items {\n             encode_meta_item(ebml_w, *inner_item);\n         }\n         ebml::end_tag(ebml_w);\n@@ -477,7 +477,7 @@ fn encode_meta_item(ebml_w: &ebml::writer, mi: &meta_item) {\n \n fn encode_attributes(ebml_w: &ebml::writer, attrs: &[attribute]) {\n     ebml::start_tag(ebml_w, tag_attributes);\n-    for attr: attribute  in attrs {\n+    for attr: attribute in attrs {\n         ebml::start_tag(ebml_w, tag_attribute);\n         encode_meta_item(ebml_w, attr.node.value);\n         ebml::end_tag(ebml_w);\n@@ -516,7 +516,7 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n \n     let attrs: [attribute] = ~[];\n     let found_link_attr = false;\n-    for attr: attribute  in crate.node.attrs {\n+    for attr: attribute in crate.node.attrs {\n         attrs +=\n             if attr::get_attr_name(attr) != \"link\" {\n                 ~[attr]\n@@ -544,7 +544,7 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n \n         // Pull the cnums and names out of cstore\n         let pairs: [mutable numname] = ~[mutable];\n-        for each hashkv: hashkv  in cstore::iter_crate_data(cstore) {\n+        for each hashkv: hashkv in cstore::iter_crate_data(cstore) {\n             pairs += ~[mutable {crate: hashkv.key, ident: hashkv.val.name}];\n         }\n \n@@ -556,7 +556,7 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n \n         // Sanity-check the crate numbers\n         let expected_cnum = 1;\n-        for n: numname  in pairs {\n+        for n: numname in pairs {\n             assert (n.crate == expected_cnum);\n             expected_cnum += 1;\n         }\n@@ -573,7 +573,7 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n     // FIXME: This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     ebml::start_tag(ebml_w, tag_crate_deps);\n-    for cname: str  in get_ordered_names(cstore) {\n+    for cname: str in get_ordered_names(cstore) {\n         ebml::start_tag(ebml_w, tag_crate_dep);\n         ebml_w.writer.write(str::bytes(cname));\n         ebml::end_tag(ebml_w);"}, {"sha": "d72d7b2c869e93cbd147315d5d050d50629cb172", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -420,8 +420,8 @@ fn parse_def_id(buf: &[u8]) -> ast::def_id {\n \n     let crate_part_vec = ~[];\n     let def_part_vec = ~[];\n-    for b: u8  in crate_part { crate_part_vec += ~[b]; }\n-    for b: u8  in def_part { def_part_vec += ~[b]; }\n+    for b: u8 in crate_part { crate_part_vec += ~[b]; }\n+    for b: u8 in def_part { def_part_vec += ~[b]; }\n \n     let crate_num = uint::parse_buf(crate_part_vec, 10u) as int;\n     let def_num = uint::parse_buf(def_part_vec, 10u) as int;"}, {"sha": "c9750dfbb8632f5ec0a6407916063ce7966c3858", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -117,7 +117,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n         w.write_str(\"t[\");\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n-        for t: ty::t  in tys { enc_ty(w, cx, t); }\n+        for t: ty::t in tys { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_tup(ts) {\n@@ -134,7 +134,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       ty::ty_chan(t) { w.write_char('C'); enc_ty(w, cx, t); }\n       ty::ty_rec(fields) {\n         w.write_str(\"R[\");\n-        for field: ty::field  in fields {\n+        for field: ty::field in fields {\n             w.write_str(field.ident);\n             w.write_char('=');\n             enc_mt(w, cx, field.mt);\n@@ -158,7 +158,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       }\n       ty::ty_obj(methods) {\n         w.write_str(\"O[\");\n-        for m: ty::method  in methods {\n+        for m: ty::method in methods {\n             enc_proto(w, m.proto);\n             w.write_str(m.ident);\n             enc_ty_fn(w, cx, m.inputs, m.output, m.cf, m.constrs);\n@@ -170,7 +170,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n         enc_ty(w, cx, ty);\n-        for t: ty::t  in tps { enc_ty(w, cx, t); }\n+        for t: ty::t in tps { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n       ty::ty_var(id) { w.write_char('X'); w.write_str(int::str(id)); }\n@@ -192,7 +192,7 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       ty::ty_constr(ty, cs) {\n         w.write_str(\"A[\");\n         enc_ty(w, cx, ty);\n-        for tc: @ty::type_constr  in cs { enc_ty_constr(w, cx, tc); }\n+        for tc: @ty::type_constr in cs { enc_ty_constr(w, cx, tc); }\n         w.write_char(']');\n       }\n     }\n@@ -208,7 +208,7 @@ fn enc_proto(w: &io::writer, proto: proto) {\n fn enc_ty_fn(w: &io::writer, cx: &@ctxt, args: &[ty::arg], out: &ty::t,\n              cf: &controlflow, constrs: &[@ty::constr]) {\n     w.write_char('[');\n-    for arg: ty::arg  in args {\n+    for arg: ty::arg in args {\n         alt arg.mode {\n           ty::mo_alias(mut) {\n             w.write_char('&');\n@@ -223,7 +223,7 @@ fn enc_ty_fn(w: &io::writer, cx: &@ctxt, args: &[ty::arg], out: &ty::t,\n     }\n     w.write_char(']');\n     let colon = true;\n-    for c: @ty::constr  in constrs {\n+    for c: @ty::constr in constrs {\n         if colon {\n             w.write_char(':');\n             colon = false;\n@@ -241,7 +241,7 @@ fn enc_constr(w: &io::writer, cx: &@ctxt, c: &@ty::constr) {\n     w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n     let semi = false;\n-    for a: @constr_arg  in c.node.args {\n+    for a: @constr_arg in c.node.args {\n         if semi { w.write_char(';'); } else { semi = true; }\n         alt a.node {\n           carg_base. { w.write_char('*'); }\n@@ -258,7 +258,7 @@ fn enc_ty_constr(w: &io::writer, cx: &@ctxt, c: &@ty::type_constr) {\n     w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n     let semi = false;\n-    for a: @ty::ty_constr_arg  in c.node.args {\n+    for a: @ty::ty_constr_arg in c.node.args {\n         if semi { w.write_char(';'); } else { semi = true; }\n         alt a.node {\n           carg_base. { w.write_char('*'); }"}, {"sha": "e7d15d71a3b132e28dcf2f8dd05cc795cde26c65", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -54,7 +54,7 @@ fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n fn visit_fn(cx: &@ctx, f: &ast::_fn, tp: &[ast::ty_param], sp: &span,\n             name: &fn_ident, id: ast::node_id, sc: &scope, v: &vt[scope]) {\n     visit::visit_fn_decl(f.decl, sc, v);\n-    for arg_: ast::arg  in f.decl.inputs {\n+    for arg_: ast::arg in f.decl.inputs {\n         cx.local_map.insert(arg_.id, arg(arg_.mode));\n     }\n     let scope = alt (f.proto) {\n@@ -85,7 +85,7 @@ fn visit_fn(cx: &@ctx, f: &ast::_fn, tp: &[ast::ty_param], sp: &span,\n fn visit_item(cx: &@ctx, i: &@ast::item, sc: &scope, v: &vt[scope]) {\n     alt i.node {\n       ast::item_obj(o, _, _) {\n-        for f: ast::obj_field  in o.fields {\n+        for f: ast::obj_field in o.fields {\n             cx.local_map.insert(f.id, objfield(f.mut));\n         }\n       }\n@@ -173,7 +173,7 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n     let unsafe_ts: [ty::t] = ~[];\n     let unsafe_t_offsets: [uint] = ~[];\n     let i = 0u;\n-    for arg_t: ty::arg  in arg_ts {\n+    for arg_t: ty::arg in arg_ts {\n         if arg_t.mode != ty::mo_val {\n             let arg = args.(i);\n             let root = expr_root(cx, arg, false);\n@@ -232,11 +232,11 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n         }\n     }\n     let j = 0u;\n-    for unsafe: ty::t  in unsafe_ts {\n+    for unsafe: ty::t in unsafe_ts {\n         let offset = unsafe_t_offsets.(j);\n         j += 1u;\n         let i = 0u;\n-        for arg_t: ty::arg  in arg_ts {\n+        for arg_t: ty::arg in arg_ts {\n             let mut_alias = arg_t.mode == ty::mo_alias(true);\n             if i != offset &&\n                    ty_can_unsafely_include(cx, unsafe, arg_t.ty, mut_alias) {\n@@ -250,10 +250,10 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n     }\n     // Ensure we're not passing a root by mutable alias.\n \n-    for root: {arg: uint, node: node_id}  in mut_roots {\n+    for root: {arg: uint, node: node_id} in mut_roots {\n         let mut_alias_to_root = false;\n         let mut_alias_to_root_count = 0u;\n-        for r: node_id  in roots {\n+        for r: node_id in roots {\n             if root.node == r {\n                 mut_alias_to_root_count += 1u;\n                 if mut_alias_to_root_count > 1u {\n@@ -277,7 +277,7 @@ fn check_tail_call(cx: &ctx, call: &@ast::expr) {\n     let args;\n     let f = alt call.node { ast::expr_call(f, args_) { args = args_; f } };\n     let i = 0u;\n-    for arg_t: ty::arg  in fty_args(cx, ty::expr_ty(cx.tcx, f)) {\n+    for arg_t: ty::arg in fty_args(cx, ty::expr_ty(cx.tcx, f)) {\n         if arg_t.mode != ty::mo_val {\n             let mut_a = arg_t.mode == ty::mo_alias(true);\n             let ok = true;\n@@ -316,7 +316,7 @@ fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n         alt path_def_id(cx, root.ex) { some(did) { ~[did.node] } _ { ~[] } };\n     let forbidden_tp: [ty::t] =\n         alt inner_mut(root.ds) { some(t) { ~[t] } _ { ~[] } };\n-    for a: ast::arm  in arms {\n+    for a: ast::arm in arms {\n         let dnums = arm_defnums(a);\n         let new_sc = sc;\n         if ivec::len(dnums) > 0u {\n@@ -390,7 +390,7 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n     if !def_is_local(def, true) { ret; }\n     let my_defnum = ast::def_id_of_def(def).node;\n     let var_t = ty::expr_ty(cx.tcx, ex);\n-    for r: restrict  in *sc {\n+    for r: restrict in *sc {\n         // excludes variables introduced since the alias was made\n         // FIXME This does not work anymore, now that we have macros.\n         if my_defnum < r.block_defnum {\n@@ -475,7 +475,7 @@ fn is_immutable_alias(cx: &ctx, sc: &scope, dnum: node_id) -> bool {\n       some(arg(ast::alias(false))) { ret true; }\n       _ { }\n     }\n-    for r: restrict  in *sc {\n+    for r: restrict in *sc {\n         if ivec::member(dnum, r.bindings) { ret true; }\n     }\n     ret false;\n@@ -487,7 +487,7 @@ fn is_immutable_objfield(cx: &ctx, dnum: node_id) -> bool {\n \n fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n     let prob = r.ok;\n-    for dep: uint  in r.depends_on {\n+    for dep: uint in r.depends_on {\n         if prob != valid { break; }\n         prob = sc.(dep).ok;\n     }\n@@ -509,8 +509,8 @@ fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n fn deps(sc: &scope, roots: &[node_id]) -> [uint] {\n     let i = 0u;\n     let result = ~[];\n-    for r: restrict  in *sc {\n-        for dn: node_id  in roots {\n+    for r: restrict in *sc {\n+        for dn: node_id in roots {\n             if ivec::member(dn, r.bindings) { result += ~[i]; }\n         }\n         i += 1u;\n@@ -568,7 +568,7 @@ fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n             let mut = false;\n             alt ty::struct(cx.tcx, auto_unbox.t) {\n               ty::ty_rec(fields) {\n-                for fld: ty::field  in fields {\n+                for fld: ty::field in fields {\n                     if str::eq(ident, fld.ident) {\n                         mut = fld.mt.mut != ast::imm;\n                         break;\n@@ -626,12 +626,12 @@ fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n }\n \n fn mut_field(ds: &@[deref]) -> bool {\n-    for d: deref  in *ds { if d.mut { ret true; } }\n+    for d: deref in *ds { if d.mut { ret true; } }\n     ret false;\n }\n \n fn inner_mut(ds: &@[deref]) -> option::t[ty::t] {\n-    for d: deref  in *ds { if d.mut { ret some(d.outer_t); } }\n+    for d: deref in *ds { if d.mut { ret some(d.outer_t); } }\n     ret none;\n }\n \n@@ -661,7 +661,7 @@ fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n         if needle == haystack { ret true; }\n         alt ty::struct(tcx, haystack) {\n           ty::ty_tag(_, ts) {\n-            for t: ty::t  in ts {\n+            for t: ty::t in ts {\n                 if helper(tcx, needle, t, mut) { ret true; }\n             }\n             ret false;\n@@ -671,7 +671,7 @@ fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n           }\n           ty::ty_uniq(t) { ret helper(tcx, needle, t, false); }\n           ty::ty_rec(fields) {\n-            for f: ty::field  in fields {\n+            for f: ty::field in fields {\n                 if helper(tcx, needle, f.mt.ty, get_mut(mut, f.mt)) {\n                     ret true;\n                 }"}, {"sha": "e1d9e398cc8854ae3d2ef784e8ca32a2cf2d4725", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -93,7 +93,7 @@ fn new_smallintmap_adapter[@K,\n \n         iter items() -> @{key: K, val: V} {\n             let idx = 0u;\n-            for item: option::t[V]  in map.v {\n+            for item: option::t[V] in map.v {\n                 alt item {\n                   option::some(elt) {\n                     let value = elt;\n@@ -106,7 +106,7 @@ fn new_smallintmap_adapter[@K,\n             }\n         }\n         iter keys() -> K {\n-            for each p: @{key: K, val: V}  in self.items() { put p.key; }\n+            for each p: @{key: K, val: V} in self.items() { put p.key; }\n         }\n     }\n "}, {"sha": "f891b82c4534243f3510a8d0c0f9ea55dfd0eae1", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -17,12 +17,12 @@ fn check_expr(tcx: &ty::ctxt, ex: &@expr, s: &(), v: &visit::vt[()]) {\n \n fn check_arms(tcx: &ty::ctxt, arms: &[arm]) {\n     let i = 0;\n-    for arm: arm  in arms {\n-        for arm_pat: @pat  in arm.pats {\n+    for arm: arm in arms {\n+        for arm_pat: @pat in arm.pats {\n             let reachable = true;\n             let j = 0;\n             while j < i {\n-                for prev_pat: @pat  in arms.(j).pats {\n+                for prev_pat: @pat in arms.(j).pats {\n                     if pattern_supersedes(tcx, prev_pat, arm_pat) {\n                         reachable = false;\n                     }\n@@ -41,7 +41,7 @@ fn pattern_supersedes(tcx: &ty::ctxt, a: &@pat, b: &@pat) -> bool {\n     fn patterns_supersede(tcx: &ty::ctxt, as: &[@pat], bs: &[@pat]) ->\n        bool {\n         let i = 0;\n-        for a: @pat  in as {\n+        for a: @pat in as {\n             if !pattern_supersedes(tcx, a, bs.(i)) { ret false; }\n             i += 1;\n         }\n@@ -50,9 +50,9 @@ fn pattern_supersedes(tcx: &ty::ctxt, a: &@pat, b: &@pat) -> bool {\n     fn field_patterns_supersede(tcx: &ty::ctxt, fas: &[field_pat],\n                                 fbs: &[field_pat]) -> bool {\n         let wild = @{id: 0, node: pat_wild, span: dummy_sp()};\n-        for fa: field_pat  in fas {\n+        for fa: field_pat in fas {\n             let pb = wild;\n-            for fb: field_pat  in fbs {\n+            for fb: field_pat in fbs {\n                 if fa.ident == fb.ident { pb = fb.pat; }\n             }\n             if !pattern_supersedes(tcx, fa.pat, pb) { ret false; }"}, {"sha": "b0c42d5d2ac15bda6a331762066ec45eadfa1145", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -42,12 +42,12 @@ fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n                     walker: &fn(&visit::vt[()]) ,\n                     initial_decls: [ast::node_id]) -> freevar_info {\n     let decls = new_int_hash();\n-    for decl: ast::node_id  in initial_decls { set_add(decls, decl); }\n+    for decl: ast::node_id in initial_decls { set_add(decls, decl); }\n     let refs = @mutable ~[];\n \n     let walk_fn = lambda(f: &ast::_fn, tps: &[ast::ty_param], sp: &span,\n                          i: &ast::fn_ident, nid: ast::node_id) {\n-        for a: ast::arg  in f.decl.inputs { set_add(decls, a.id); }\n+        for a: ast::arg in f.decl.inputs { set_add(decls, a.id); }\n     };\n     let walk_expr = lambda(expr: &@ast::expr) {\n         alt expr.node {\n@@ -87,7 +87,7 @@ fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n     // node ids of the definitions.\n     let canonical_refs = ~[];\n     let defs = new_int_hash();\n-    for ref_id_: ast::node_id  in *refs {\n+    for ref_id_: ast::node_id in *refs {\n         let ref_id = ref_id_;\n         let def_id = ast::def_id_of_def(def_map.get(ref_id)).node;\n         if !decls.contains_key(def_id) && !defs.contains_key(def_id) {"}, {"sha": "9e51e4428388b282d13d4f195c8980d1daadda50", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -239,7 +239,7 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n }\n \n fn resolve_imports(e: &env) {\n-    for each it: @{key: ast::node_id, val: import_state}  in e.imports.items()\n+    for each it: @{key: ast::node_id, val: import_state} in e.imports.items()\n              {\n         alt it.val {\n           todo(item, sc) { resolve_import(e, item, sc); }\n@@ -345,7 +345,7 @@ fn visit_fn_with_scope(e: &@env, f: &ast::_fn, tp: &[ast::ty_param],\n     // here's where we need to set up the mapping\n     // for f's constrs in the table.\n \n-    for c: @ast::constr  in f.decl.constraints {\n+    for c: @ast::constr in f.decl.constraints {\n         resolve_constr(e, id, c, sc, v);\n     }\n     visit::visit_fn(f, tp, sp, name, id,\n@@ -531,7 +531,7 @@ fn unresolved_err(e: &env, sc: &scopes, sp: &span, name: &ident, kind: &str) {\n         fail;\n     }\n     let err_scope = find_fn_or_mod_scope(sc);\n-    for rs: {ident: str, sc: scope}  in e.reported {\n+    for rs: {ident: str, sc: scope} in e.reported {\n         if str::eq(rs.ident, name) && err_scope == rs.sc { ret; }\n     }\n     e.reported += ~[{ident: name, sc: err_scope}];\n@@ -704,7 +704,7 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n fn lookup_in_ty_params(name: &ident, ty_params: &[ast::ty_param]) ->\n    option::t[def] {\n     let i = 0u;\n-    for tp: ast::ty_param  in ty_params {\n+    for tp: ast::ty_param in ty_params {\n         if str::eq(tp.ident, name) { ret some(ast::def_ty_arg(i,tp.kind)); }\n         i += 1u;\n     }\n@@ -727,7 +727,7 @@ fn lookup_in_fn(name: &ident, decl: &ast::fn_decl,\n    option::t[def] {\n     alt ns {\n       ns_value. {\n-        for a: ast::arg  in decl.inputs {\n+        for a: ast::arg in decl.inputs {\n             if str::eq(a.ident, name) {\n                 ret some(ast::def_arg(local_def(a.id)));\n             }\n@@ -743,7 +743,7 @@ fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &[ast::ty_param],\n                  ns: namespace) -> option::t[def] {\n     alt ns {\n       ns_value. {\n-        for f: ast::obj_field  in ob.fields {\n+        for f: ast::obj_field in ob.fields {\n             if str::eq(f.ident, name) {\n                 ret some(ast::def_obj_field(local_def(f.id)));\n             }\n@@ -779,7 +779,7 @@ fn lookup_in_block(name: &ident, b: &ast::blk_, ns: namespace) ->\n                             ret some(ast::def_ty(local_def(it.id)));\n                         }\n                     } else if (ns == ns_value) {\n-                        for v: ast::variant  in variants {\n+                        for v: ast::variant in variants {\n                             if str::eq(v.node.name, name) {\n                                 let i = v.node.id;\n                                 ret some(ast::def_variant(local_def(it.id),\n@@ -971,7 +971,7 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n         } else if (ivec::len(matches) == 1u) {\n             ret some(matches.(0).def);\n         } else {\n-            for match: glob_imp_def  in matches {\n+            for match: glob_imp_def in matches {\n                 let sp = match.item.span;\n                 e.sess.span_note(sp, #fmt(\"'%s' is imported here\", id));\n             }\n@@ -1053,7 +1053,7 @@ fn add_to_index(index: &hashmap[ident, list[mod_index_entry]], id: &ident,\n \n fn index_mod(md: &ast::_mod) -> mod_index {\n     let index = new_str_hash[list[mod_index_entry]]();\n-    for it: @ast::view_item  in md.view_items {\n+    for it: @ast::view_item in md.view_items {\n         alt it.node {\n           ast::view_item_import(ident, _, _) | ast::view_item_use(ident, _, _)\n           {\n@@ -1065,7 +1065,7 @@ fn index_mod(md: &ast::_mod) -> mod_index {\n           }\n         }\n     }\n-    for it: @ast::item  in md.items {\n+    for it: @ast::item in md.items {\n         alt it.node {\n           ast::item_const(_, _) | ast::item_fn(_, _) | ast::item_mod(_) |\n           ast::item_native_mod(_) | ast::item_ty(_, _) |\n@@ -1075,7 +1075,7 @@ fn index_mod(md: &ast::_mod) -> mod_index {\n           ast::item_tag(variants, _) {\n             add_to_index(index, it.ident, mie_item(it));\n             let variant_idx: uint = 0u;\n-            for v: ast::variant  in variants {\n+            for v: ast::variant in variants {\n                 add_to_index(index, v.node.name,\n                              mie_tag_variant(it, variant_idx));\n                 variant_idx += 1u;\n@@ -1088,7 +1088,7 @@ fn index_mod(md: &ast::_mod) -> mod_index {\n \n fn index_nmod(md: &ast::native_mod) -> mod_index {\n     let index = new_str_hash[list[mod_index_entry]]();\n-    for it: @ast::view_item  in md.view_items {\n+    for it: @ast::view_item in md.view_items {\n         alt it.node {\n           ast::view_item_use(ident, _, _) | ast::view_item_import(ident, _, _)\n           {\n@@ -1097,7 +1097,7 @@ fn index_nmod(md: &ast::native_mod) -> mod_index {\n           ast::view_item_import_glob(_, _) | ast::view_item_export(_, _) { }\n         }\n     }\n-    for it: @ast::native_item  in md.items {\n+    for it: @ast::native_item in md.items {\n         add_to_index(index, it.ident, mie_native_item(it));\n     }\n     ret index;\n@@ -1125,7 +1125,7 @@ fn ns_for_def(d: def) -> namespace {\n \n fn lookup_external(e: &env, cnum: int, ids: &[ident], ns: namespace) ->\n    option::t[def] {\n-    for d: def  in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids) {\n+    for d: def in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids) {\n         e.ext_map.insert(ast::def_id_of_def(d), ids);\n         if ns == ns_for_def(d) { ret some(d); }\n     }\n@@ -1211,7 +1211,7 @@ fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt[()]) {\n       ast::item_obj(ob, ty_params, _) {\n         fn field_name(field: &ast::obj_field) -> ident { ret field.ident; }\n         ensure_unique(*e, i.span, ob.fields, field_name, \"object field\");\n-        for m: @ast::method  in ob.methods {\n+        for m: @ast::method in ob.methods {\n             check_fn(*e, m.span, m.node.meth);\n         }\n         ensure_unique(*e, i.span, typaram_names(ty_params),\n@@ -1249,7 +1249,7 @@ fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt[()]) {\n             e.sess.span_err(a.pats.(i).span,\n                             \"inconsistent number of bindings\");\n         } else {\n-            for name: ident  in ch.seen {\n+            for name: ident in ch.seen {\n                 if is_none(ivec::find(bind str::eq(name, _), seen0)) {\n                     // Fight the alias checker\n                     let name_ = name;\n@@ -1267,7 +1267,7 @@ fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt[()]) {\n     let values = checker(*e, \"value\");\n     let types = checker(*e, \"type\");\n     let mods = checker(*e, \"module\");\n-    for st: @ast::stmt  in b.node.stmts {\n+    for st: @ast::stmt in b.node.stmts {\n         alt st.node {\n           ast::stmt_decl(d, _) {\n             alt d.node {\n@@ -1280,7 +1280,7 @@ fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt[()]) {\n                 alt it.node {\n                   ast::item_tag(variants, _) {\n                     add_name(types, it.span, it.ident);\n-                    for v: ast::variant  in variants {\n+                    for v: ast::variant in variants {\n                         add_name(values, v.span, v.node.name);\n                     }\n                   }\n@@ -1340,7 +1340,7 @@ fn checker(e: &env, kind: str) -> checker {\n }\n \n fn add_name(ch: &checker, sp: &span, name: &ident) {\n-    for s: ident  in ch.seen {\n+    for s: ident in ch.seen {\n         if str::eq(s, name) {\n             ch.sess.span_fatal(sp, \"duplicate \" + ch.kind + \" name: \" + name);\n         }\n@@ -1353,7 +1353,7 @@ fn ident_id(i: &ident) -> ident { ret i; }\n fn ensure_unique[T](e: &env, sp: &span, elts: &[T], id: fn(&T) -> ident ,\n                     kind: &str) {\n     let ch = checker(e, kind);\n-    for elt: T  in elts { add_name(ch, sp, id(elt)); }\n+    for elt: T in elts { add_name(ch, sp, id(elt)); }\n }\n \n // Local Variables:"}, {"sha": "f077516bdf6acfe0dbbf83b1e2d3ae575eab7354", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -95,7 +95,7 @@ fn type_of(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n fn type_of_explicit_args(cx: &@crate_ctxt, sp: &span, inputs: &[ty::arg]) ->\n    [TypeRef] {\n     let atys: [TypeRef] = ~[];\n-    for arg: ty::arg  in inputs {\n+    for arg: ty::arg in inputs {\n         let t: TypeRef = type_of_inner(cx, sp, arg.ty);\n         t = alt arg.mode {\n           ty::mo_alias(_) { T_ptr(t) }\n@@ -231,7 +231,7 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n       ty::ty_task. { llty = T_taskptr(*cx); }\n       ty::ty_rec(fields) {\n         let tys: [TypeRef] = ~[];\n-        for f: ty::field  in fields {\n+        for f: ty::field in fields {\n             tys += ~[type_of_inner(cx, sp, f.mt.ty)];\n         }\n         llty = T_struct(tys);\n@@ -305,7 +305,7 @@ fn type_of_or_i8(bcx: &@block_ctxt, typ: ty::t) -> TypeRef {\n // gas doesn't!\n fn sanitize(s: &str) -> str {\n     let result = \"\";\n-    for c: u8  in s {\n+    for c: u8 in s {\n         if c == '@' as u8 {\n             result += \"boxed_\";\n         } else {\n@@ -401,7 +401,7 @@ fn trans_native_call(b: &builder, glues: @glue_fns, lltaskptr: ValueRef,\n     let n: int = std::ivec::len[ValueRef](args) as int;\n     let llnative: ValueRef = get_simple_extern_fn(externs, llmod, name, n);\n     let call_args: [ValueRef] = ~[];\n-    for a: ValueRef  in args { call_args += ~[b.ZExtOrBitCast(a, T_int())]; }\n+    for a: ValueRef in args { call_args += ~[b.ZExtOrBitCast(a, T_int())]; }\n     ret b.Call(llnative, call_args);\n }\n \n@@ -528,7 +528,7 @@ fn static_size_of_tag(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> uint {\n \n         let max_size = 0u;\n         let variants = ty::tag_variants(cx.tcx, tid);\n-        for variant: ty::variant_info  in variants {\n+        for variant: ty::variant_info in variants {\n             let tup_ty =\n                 simplify_type(cx, ty::mk_tup(cx.tcx, variant.args));\n             // Perform any type parameter substitutions.\n@@ -562,7 +562,7 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n         let off = C_int(0);\n         let max_align = C_int(1);\n         let bcx = cx;\n-        for e: ty::t  in elts {\n+        for e: ty::t in elts {\n             let elt_align = align_of(bcx, e);\n             bcx = elt_align.bcx;\n             let elt_size = size_of(bcx, e);\n@@ -581,7 +581,7 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n       }\n       ty::ty_rec(flds) {\n         let tys: [ty::t] = ~[];\n-        for f: ty::field  in flds { tys += ~[f.mt.ty]; }\n+        for f: ty::field in flds { tys += ~[f.mt.ty]; }\n         ret align_elements(cx, tys);\n       }\n       ty::ty_tup(elts) {\n@@ -596,12 +596,12 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n         let max_size: ValueRef = alloca(bcx, T_int());\n         bcx.build.Store(C_int(0), max_size);\n         let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n-        for variant: ty::variant_info  in variants {\n+        for variant: ty::variant_info in variants {\n             // Perform type substitution on the raw argument types.\n \n             let raw_tys: [ty::t] = variant.args;\n             let tys: [ty::t] = ~[];\n-            for raw_ty: ty::t  in raw_tys {\n+            for raw_ty: ty::t in raw_tys {\n                 let t = ty::substitute_type_params(bcx_tcx(cx), tps, raw_ty);\n                 tys += ~[t];\n             }\n@@ -640,7 +640,7 @@ fn dynamic_align_of(cx: &@block_ctxt, t: &ty::t) -> result {\n       ty::ty_rec(flds) {\n         let a = C_int(1);\n         let bcx = cx;\n-        for f: ty::field  in flds {\n+        for f: ty::field in flds {\n             let align = align_of(bcx, f.mt.ty);\n             bcx = align.bcx;\n             a = umax(bcx, a, align.val);\n@@ -674,7 +674,7 @@ fn dynamic_align_of(cx: &@block_ctxt, t: &ty::t) -> result {\n // in C_int()\n fn GEPi(cx: &@block_ctxt, base: ValueRef, ixs: &[int]) -> ValueRef {\n     let v: [ValueRef] = ~[];\n-    for i: int  in ixs { v += ~[C_int(i)]; }\n+    for i: int in ixs { v += ~[C_int(i)]; }\n     ret cx.build.InBoundsGEP(base, v);\n }\n \n@@ -765,7 +765,7 @@ fn GEP_tup_like(cx: &@block_ctxt, t: &ty::t, base: ValueRef, ixs: &[int]) ->\n     let s = split_type(bcx_ccx(cx), t, ixs, 0u);\n \n     let args = ~[];\n-    for typ: ty::t  in s.prefix { args += ~[typ]; }\n+    for typ: ty::t in s.prefix { args += ~[typ]; }\n     let prefix_ty = ty::mk_tup(bcx_tcx(cx), args);\n \n     let bcx = cx;\n@@ -789,7 +789,7 @@ fn GEP_tag(cx: @block_ctxt, llblobptr: ValueRef, tag_id: &ast::def_id,\n \n     let i = 0;\n     let true_arg_tys: [ty::t] = ~[];\n-    for aty: ty::t  in arg_tys {\n+    for aty: ty::t in arg_tys {\n         let arg_ty = ty::substitute_type_params(bcx_tcx(cx), ty_substs, aty);\n         true_arg_tys += ~[arg_ty];\n         if i == ix { elem_ty = arg_ty; }\n@@ -909,7 +909,7 @@ fn linearize_ty_params(cx: &@block_ctxt, t: &ty::t) ->\n         alt ty::struct(bcx_tcx(r.cx), t) {\n           ty::ty_param(pid,_) {\n             let seen: bool = false;\n-            for d: uint  in r.defs { if d == pid { seen = true; } }\n+            for d: uint in r.defs { if d == pid { seen = true; } }\n             if !seen {\n                 r.vals += ~[r.cx.fcx.lltydescs.(pid)];\n                 r.defs += ~[pid];\n@@ -983,7 +983,7 @@ fn get_derived_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool,\n         let tdp = bcx.build.GEP(tydescs, ~[C_int(0), C_int(i)]);\n         bcx.build.Store(root, tdp);\n         i += 1;\n-        for td: ValueRef  in tys.descs {\n+        for td: ValueRef in tys.descs {\n             let tdp = bcx.build.GEP(tydescs, ~[C_int(0), C_int(i)]);\n             bcx.build.Store(td, tdp);\n             i += 1;\n@@ -1002,7 +1002,7 @@ fn get_derived_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool,\n             alloca(bcx, T_array(T_ptr(bcx_ccx(bcx).tydesc_type),\n                                 n_params + 1u));\n         let i = 0;\n-        for td: ValueRef  in tys.descs {\n+        for td: ValueRef in tys.descs {\n             let tdp = bcx.build.GEP(llparamtydescs, ~[C_int(0), C_int(i)]);\n             bcx.build.Store(td, tdp);\n             i += 1;\n@@ -1173,7 +1173,7 @@ fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: &ty::t,\n \n     // TODO: Implement some kind of freeze operation in the standard library.\n     let lltydescs_frozen = ~[];\n-    for lltydesc: ValueRef  in lltydescs { lltydescs_frozen += ~[lltydesc]; }\n+    for lltydesc: ValueRef in lltydescs { lltydescs_frozen += ~[lltydesc]; }\n     fcx.lltydescs = lltydescs_frozen;\n \n     let bcx = new_top_block_ctxt(fcx);\n@@ -1201,7 +1201,7 @@ fn make_generic_glue(cx: &@local_ctxt, sp: &span, t: &ty::t, llfn: ValueRef,\n }\n \n fn emit_tydescs(ccx: &@crate_ctxt) {\n-    for each pair: @{key: ty::t, val: @tydesc_info}  in ccx.tydescs.items() {\n+    for each pair: @{key: ty::t, val: @tydesc_info} in ccx.tydescs.items() {\n         let glue_fn_ty = T_ptr(T_glue_fn(*ccx));\n         let cmp_fn_ty = T_ptr(T_cmp_glue_fn(*ccx));\n         let ti = pair.val;\n@@ -1518,7 +1518,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n         cx.build.Load(cx.build.GEP(dtor_pair,\n                                    ~[C_int(0), C_int(abi::fn_field_box)]));\n     let args = ~[cx.fcx.llretptr, cx.fcx.lltaskptr, dtor_env];\n-    for tp: ty::t  in tps {\n+    for tp: ty::t in tps {\n         let ti: option::t[@tydesc_info] = none;\n         let td = get_tydesc(cx, tp, false, ti);\n         args += ~[td.val];\n@@ -1814,7 +1814,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: &ty::t,\n         alt ty::struct(ccx.tcx, fn_ty) {\n           ty::ty_fn(_, args, _, _, _) {\n             let j = 0;\n-            for a: ty::arg  in args {\n+            for a: ty::arg in args {\n                 let rslt = GEP_tag(cx, a_tup, tid, variant.id, tps, j);\n                 let llfldp_a = rslt.val;\n                 cx = rslt.bcx;\n@@ -1883,7 +1883,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: &ty::t,\n         let llswitch = bcx.build.Switch(lldiscrim_a, unr_cx.llbb, n_variants);\n         let next_cx = new_sub_block_ctxt(bcx, \"tag-iter-next\");\n         let i = 0u;\n-        for variant: ty::variant_info  in variants {\n+        for variant: ty::variant_info in variants {\n             let variant_cx =\n                 new_sub_block_ctxt(bcx,\n                                    \"tag-iter-variant-\" +\n@@ -2041,7 +2041,7 @@ fn lazily_emit_all_tydesc_glue(cx: &@block_ctxt,\n \n fn lazily_emit_all_generic_info_tydesc_glues(cx: &@block_ctxt,\n                                              gi: &generic_info) {\n-    for ti: option::t[@tydesc_info]  in gi.static_tis {\n+    for ti: option::t[@tydesc_info] in gi.static_tis {\n         lazily_emit_all_tydesc_glue(cx, ti);\n     }\n }\n@@ -3386,7 +3386,7 @@ fn join_results(parent_cx: &@block_ctxt, t: TypeRef, ins: &[result]) ->\n     let live: [result] = ~[];\n     let vals: [ValueRef] = ~[];\n     let bbs: [BasicBlockRef] = ~[];\n-    for r: result  in ins {\n+    for r: result in ins {\n         if !is_terminated(r.bcx) {\n             live += ~[r];\n             vals += ~[r.val];\n@@ -3407,14 +3407,14 @@ fn join_results(parent_cx: &@block_ctxt, t: TypeRef, ins: &[result]) ->\n     // We have >1 incoming edges. Make a join block and br+phi them into it.\n \n     let join_cx = new_sub_block_ctxt(parent_cx, \"join\");\n-    for r: result  in live { r.bcx.build.Br(join_cx.llbb); }\n+    for r: result in live { r.bcx.build.Br(join_cx.llbb); }\n     let phi = join_cx.build.Phi(t, vals, bbs);\n     ret rslt(join_cx, phi);\n }\n \n fn join_branches(parent_cx: &@block_ctxt, ins: &[result]) -> @block_ctxt {\n     let out = new_sub_block_ctxt(parent_cx, \"join\");\n-    for r: result  in ins {\n+    for r: result in ins {\n         if !is_terminated(r.bcx) { r.bcx.build.Br(out.llbb); }\n     }\n     ret out;\n@@ -3571,7 +3571,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n         GEP_tup_like(bcx, closure_ty, closure,\n                      ~[0, abi::closure_elt_bindings]);\n     bcx = bindings.bcx;\n-    for lv: lval_result  in bound_vals {\n+    for lv: lval_result in bound_vals {\n         let bound = GEP_tup_like(bcx, bindings_ty, bindings.val,\n                                  ~[0, i as int]);\n         bcx = bound.bcx;\n@@ -3591,7 +3591,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n                      ~[0, abi::closure_elt_ty_params]);\n     bcx = ty_params_slot.bcx;\n     i = 0u;\n-    for td: ValueRef  in lltydescs {\n+    for td: ValueRef in lltydescs {\n         let ty_param_slot = GEPi(bcx, ty_params_slot.val, ~[0, i as int]);\n         bcx.build.Store(td, ty_param_slot);\n         i += 1u;\n@@ -3612,7 +3612,7 @@ fn build_closure(cx: &@block_ctxt, upvars: &@[ast::node_id], copying: bool)\n             closure_tys += ~[option::get(cx.fcx.iterbodyty)];\n         }\n         // Package up the upvars\n-        for nid: ast::node_id  in *upvars {\n+        for nid: ast::node_id in *upvars {\n             closure_vals += ~[trans_var(cx, cx.sp, nid)];\n             let ty = ty::node_id_to_monotype(bcx_tcx(cx), nid);\n             if !copying { ty = ty::mk_mut_ptr(bcx_tcx(cx), ty); }\n@@ -3689,7 +3689,7 @@ fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt,\n         i += 1u;\n     }\n     // Load the acutal upvars.\n-    for upvar_id: ast::node_id  in *upvars {\n+    for upvar_id: ast::node_id in *upvars {\n         let upvarptr =\n             GEP_tup_like(bcx, ty, llclosure, path + ~[i as int]);\n         bcx = upvarptr.bcx;\n@@ -3875,7 +3875,7 @@ fn lval_generic_fn(cx: &@block_ctxt, tpt: &ty::ty_param_kinds_and_ty,\n         let bcx = lv.res.bcx;\n         let tydescs: [ValueRef] = ~[];\n         let tis: [option::t[@tydesc_info]] = ~[];\n-        for t: ty::t  in tys {\n+        for t: ty::t in tys {\n             // TODO: Doesn't always escape.\n \n             let ti = none[@tydesc_info];\n@@ -4368,7 +4368,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n     let outgoing_arg_index: uint = 0u;\n     let llout_arg_tys: [TypeRef] =\n         type_of_explicit_args(cx.ccx, sp, outgoing_args);\n-    for arg: option::t[@ast::expr]  in args {\n+    for arg: option::t[@ast::expr] in args {\n         let out_arg = outgoing_args.(outgoing_arg_index);\n         let llout_arg_ty = llout_arg_tys.(outgoing_arg_index);\n         let is_val = out_arg.mode == ty::mo_val;\n@@ -4452,7 +4452,7 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n                 args: &[option::t[@ast::expr]], id: ast::node_id) ->\n    result {\n     let bound: [@ast::expr] = ~[];\n-    for argopt: option::t[@ast::expr]  in args {\n+    for argopt: option::t[@ast::expr] in args {\n         alt argopt { none. { } some(e) { bound += ~[e]; } }\n     }\n \n@@ -4487,7 +4487,7 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     let bound_tys: [ty::t] = ~[outgoing_fty];\n     let bound_vals: [lval_result] = ~[bound_f];\n     // Translate the bound expressions.\n-    for e: @ast::expr  in bound {\n+    for e: @ast::expr in bound {\n         let lv = trans_lval(bcx, e);\n         bcx = lv.res.bcx;\n         bound_vals += ~[lv];\n@@ -4660,7 +4660,7 @@ fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n     // to cast her view of the arguments to the caller's view.\n     let arg_tys = type_of_explicit_args(bcx_ccx(cx), cx.sp, args);\n     let i = 0u;\n-    for e: @ast::expr  in es {\n+    for e: @ast::expr in es {\n         if bcx.build.is_terminated() {\n             // This means an earlier arg was divergent.\n             // So this arg can't be evaluated.\n@@ -4816,7 +4816,7 @@ fn trans_vec(cx: &@block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n                        std::ivec::init_elt[ty::t](unit_ty,\n                                                   std::ivec::len(args)));\n     let i: int = 0;\n-    for e: @ast::expr  in args {\n+    for e: @ast::expr in args {\n         let src = trans_lval(bcx, e);\n         bcx = src.res.bcx;\n         let dst_res = GEP_tup_like(bcx, pseudo_tup_ty, body, ~[0, i]);\n@@ -4924,7 +4924,7 @@ fn trans_ivec(bcx: @block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n     // Store the individual elements.\n \n     let i = 0u;\n-    for e: @ast::expr  in args {\n+    for e: @ast::expr in args {\n         let lv = trans_lval(bcx, e);\n         bcx = lv.res.bcx;\n         let lleltptr;\n@@ -4961,12 +4961,12 @@ fn trans_rec(cx: &@block_ctxt, fields: &[ast::field],\n     }\n     let ty_fields: [ty::field] = ~[];\n     alt ty::struct(bcx_tcx(cx), t) { ty::ty_rec(flds) { ty_fields = flds; } }\n-    for tf: ty::field  in ty_fields {\n+    for tf: ty::field in ty_fields {\n         let e_ty = tf.mt.ty;\n         let dst_res = GEP_tup_like(bcx, t, rec_val, ~[0, i]);\n         bcx = dst_res.bcx;\n         let expr_provided = false;\n-        for f: ast::field  in fields {\n+        for f: ast::field in fields {\n             if str::eq(f.node.ident, tf.ident) {\n                 expr_provided = true;\n                 let lv = trans_lval(bcx, f.node.expr);\n@@ -5525,7 +5525,7 @@ fn trans_stmt(cx: &@block_ctxt, s: &ast::stmt) -> result {\n       ast::stmt_decl(d, _) {\n         alt d.node {\n           ast::decl_local(locals) {\n-            for local: @ast::local  in locals {\n+            for local: @ast::local in locals {\n                 bcx = init_local(bcx, local).bcx;\n             }\n           }\n@@ -5624,7 +5624,7 @@ fn trans_block_cleanups(cx: &@block_ctxt, cleanup_cx: &@block_ctxt) ->\n iter block_locals(b: &ast::blk) -> @ast::local {\n     // FIXME: putting from inside an iter block doesn't work, so we can't\n     // use the index here.\n-    for s: @ast::stmt  in b.node.stmts {\n+    for s: @ast::stmt in b.node.stmts {\n         alt s.node {\n           ast::stmt_decl(d, _) {\n             alt d.node {\n@@ -5725,7 +5725,7 @@ fn trans_block(cx: &@block_ctxt, b: &ast::blk, output: &out_method) ->\n         bcx.fcx.lllocals.insert(local.node.id, r.val);\n     }\n     let r = rslt(bcx, C_nil());\n-    for s: @ast::stmt  in b.node.stmts {\n+    for s: @ast::stmt in b.node.stmts {\n         r = trans_stmt(bcx, *s);\n         bcx = r.bcx;\n \n@@ -5868,7 +5868,7 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n       some(tt) { cx.llself = some[val_self_pair]({v: cx.llenv, t: tt}); }\n       none. {\n         let i = 0u;\n-        for tp: ast::ty_param  in ty_params {\n+        for tp: ast::ty_param in ty_params {\n             let llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n             assert (llarg as int != 0);\n             cx.lltydescs += ~[llarg];\n@@ -5891,7 +5891,7 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n \n     // Populate the llargs field of the function context with the ValueRefs\n     // that we get from llvm::LLVMGetParam for each argument.\n-    for arg: ast::arg  in args {\n+    for arg: ast::arg in args {\n         let llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n         assert (llarg as int != 0);\n         cx.llargs.insert(arg.id, llarg);\n@@ -5903,7 +5903,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, args: &[ast::arg],\n                         arg_tys: &[ty::arg]) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n     let arg_n: uint = 0u;\n-    for aarg: ast::arg  in args {\n+    for aarg: ast::arg in args {\n         if aarg.mode == ast::val {\n             let argval;\n             alt bcx.fcx.llargs.find(aarg.id) {\n@@ -5925,7 +5925,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, args: &[ast::arg],\n fn add_cleanups_for_args(bcx: &@block_ctxt, args: &[ast::arg],\n                          arg_tys: &[ty::arg]) {\n     let arg_n: uint = 0u;\n-    for aarg: ast::arg  in args {\n+    for aarg: ast::arg in args {\n         if aarg.mode == ast::val || aarg.mode == ast::move {\n             let argval;\n             alt bcx.fcx.llargs.find(aarg.id) {\n@@ -5955,7 +5955,7 @@ fn arg_tys_of_fn(ccx: &@crate_ctxt, id: ast::node_id) -> [ty::arg] {\n fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n     let bcx = llstaticallocas_block_ctxt(fcx);\n     let field_tys: [ty::t] = ~[];\n-    for f: ast::obj_field  in bcx.fcx.lcx.obj_fields {\n+    for f: ast::obj_field in bcx.fcx.lcx.obj_fields {\n         field_tys += ~[node_id_type(bcx_ccx(bcx), f.id)];\n     }\n     // Synthesize a tuple type for the fields so that GEP_tup_like() can work\n@@ -5986,15 +5986,15 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n         obj_fields = vi2p(bcx, obj_fields, T_ptr(llfields_ty));\n     } else { obj_fields = vi2p(bcx, obj_fields, T_ptr(T_i8())); }\n     let i: int = 0;\n-    for p: ast::ty_param  in fcx.lcx.obj_typarams {\n+    for p: ast::ty_param in fcx.lcx.obj_typarams {\n         let lltyparam: ValueRef =\n             bcx.build.GEP(obj_typarams, ~[C_int(0), C_int(i)]);\n         lltyparam = bcx.build.Load(lltyparam);\n         fcx.lltydescs += ~[lltyparam];\n         i += 1;\n     }\n     i = 0;\n-    for f: ast::obj_field  in fcx.lcx.obj_fields {\n+    for f: ast::obj_field in fcx.lcx.obj_fields {\n         let rslt = GEP_tup_like(bcx, fields_tup_ty, obj_fields, ~[0, i]);\n         bcx = llstaticallocas_block_ctxt(fcx);\n         let llfield = rslt.val;\n@@ -6166,7 +6166,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n \n     let fn_args: [ast::arg] = ~[];\n     let i = 0u;\n-    for varg: ast::variant_arg  in variant.node.args {\n+    for varg: ast::variant_arg in variant.node.args {\n         fn_args +=\n             ~[{mode: ast::alias(false),\n                ty: varg.ty,\n@@ -6188,7 +6188,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n                               fn_args, ty_params);\n     let ty_param_substs: [ty::t] = ~[];\n     i = 0u;\n-    for tp: ast::ty_param  in ty_params {\n+    for tp: ast::ty_param in ty_params {\n         ty_param_substs += ~[ty::mk_param(cx.ccx.tcx, i, tp.kind)];\n         i += 1u;\n     }\n@@ -6210,7 +6210,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n             bcx.build.GEP(lltagptr, ~[C_int(0), C_int(1)])\n         };\n     i = 0u;\n-    for va: ast::variant_arg  in variant.node.args {\n+    for va: ast::variant_arg in variant.node.args {\n         let rslt =\n             GEP_tag(bcx, llblobptr, ast::local_def(tag_id),\n                     ast::local_def(variant.node.id), ty_param_substs,\n@@ -6313,7 +6313,7 @@ fn trans_item(cx: @local_ctxt, item: &ast::item) {\n         let sub_cx = extend_path(cx, item.ident);\n         let degen = std::ivec::len(variants) == 1u;\n         let i = 0;\n-        for variant: ast::variant  in variants {\n+        for variant: ast::variant in variants {\n             trans_tag_variant(sub_cx, item.id, variant, i, degen, tps);\n             i += 1;\n         }\n@@ -6330,7 +6330,7 @@ fn trans_item(cx: @local_ctxt, item: &ast::item) {\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n fn trans_mod(cx: @local_ctxt, m: &ast::_mod) {\n-    for item: @ast::item  in m.items { trans_item(cx, *item); }\n+    for item: @ast::item in m.items { trans_item(cx, *item); }\n }\n \n fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n@@ -6525,7 +6525,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     if uses_retptr { call_args += ~[bcx.fcx.llretptr]; }\n \n     let arg_n = 3u;\n-    for each i: uint  in uint::range(0u, num_ty_param) {\n+    for each i: uint in uint::range(0u, num_ty_param) {\n         let llarg = llvm::LLVMGetParam(fcx.llfn, arg_n);\n         fcx.lltydescs += ~[llarg];\n         assert (llarg as int != 0);\n@@ -6558,7 +6558,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n                                first_arg_n: uint, uses_retptr: bool, cc: uint)\n        -> {val: ValueRef, rptr: ValueRef} {\n         let call_arg_tys: [TypeRef] = ~[];\n-        for arg: ValueRef  in call_args { call_arg_tys += ~[val_ty(arg)]; }\n+        for arg: ValueRef in call_args { call_arg_tys += ~[val_ty(arg)]; }\n \n         let llnativefnty;\n         if uses_retptr {\n@@ -6586,7 +6586,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n \n     let drop_args: [{val: ValueRef, ty: ty::t}] = ~[];\n     let i = arg_n;\n-    for arg: ty::arg  in args {\n+    for arg: ty::arg in args {\n         let llarg = llvm::LLVMGetParam(fcx.llfn, i);\n         assert (llarg as int != 0);\n         if cast_to_i32 {\n@@ -6638,7 +6638,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n \n     if !rty_is_nil && !uses_retptr { bcx.build.Store(r, rptr); }\n \n-    for d: {val: ValueRef, ty: ty::t}  in drop_args {\n+    for d: {val: ValueRef, ty: ty::t} in drop_args {\n         bcx = drop_ty(bcx, d.val, d.ty).bcx;\n     }\n     bcx.build.RetVoid();\n@@ -6690,7 +6690,7 @@ fn collect_item_2(ccx: &@crate_ctxt, i: &@ast::item, pt: &[str],\n       }\n       ast::item_obj(ob, tps, ctor_id) {\n         decl_fn_and_pair(ccx, i.span, new_pt, \"obj_ctor\", tps, ctor_id);\n-        for m: @ast::method  in ob.methods {\n+        for m: @ast::method in ob.methods {\n             ccx.obj_methods.insert(m.node.id, ());\n         }\n       }\n@@ -6724,7 +6724,7 @@ fn collect_tag_ctor(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n     visit::visit_item(i, new_pt, v);\n     alt i.node {\n       ast::item_tag(variants, tps) {\n-        for variant: ast::variant  in variants {\n+        for variant: ast::variant in variants {\n             if std::ivec::len(variant.node.args) != 0u {\n                 decl_fn_and_pair(ccx, i.span, new_pt + ~[variant.node.name],\n                                  \"tag\", tps, variant.node.id);\n@@ -6891,7 +6891,7 @@ fn create_module_map(ccx: &@crate_ctxt) -> ValueRef {\n     llvm::LLVMSetLinkage(map,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n     let elts: [ValueRef] = ~[];\n-    for each item: @{key: str, val: ValueRef}  in ccx.module_data.items() {\n+    for each item: @{key: str, val: ValueRef} in ccx.module_data.items() {\n         let elt = C_struct(~[p2i(C_cstr(ccx, item.key)), p2i(item.val)]);\n         elts += ~[elt];\n     }\n@@ -7040,7 +7040,7 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n         log_err #fmt(\"n_real_glues: %u\", ccx.stats.n_real_glues);\n \n \n-        for timing: {ident: str, time: int}  in *ccx.stats.fn_times {\n+        for timing: {ident: str, time: int} in *ccx.stats.fn_times {\n             log_err #fmt(\"time: %s took %d ms\", timing.ident, timing.time);\n         }\n     }"}, {"sha": "5f770b21ca895ca00474040575e6ca5a80d6fa28", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -47,7 +47,7 @@ fn variant_opt(ccx: &@crate_ctxt, pat_id: ast::node_id) -> opt {\n     let vdef = ast::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n     let variants = ty::tag_variants(ccx.tcx, vdef.tg);\n     let i = 0u;\n-    for v: ty::variant_info  in variants {\n+    for v: ty::variant_info in variants {\n         if vdef.var == v.id { ret var(i, vdef); }\n         i += 1u;\n     }\n@@ -81,7 +81,7 @@ type enter_pat = fn(&@ast::pat) -> option::t[[@ast::pat]] ;\n \n fn enter_match(m: &match, col: uint, val: ValueRef, e: &enter_pat) -> match {\n     let result = ~[];\n-    for br: match_branch  in m {\n+    for br: match_branch in m {\n         alt e(br.pats.(col)) {\n           some(sub) {\n             let pats =\n@@ -132,9 +132,9 @@ fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n             let pats = ~[];\n-            for fname: ast::ident  in fields {\n+            for fname: ast::ident in fields {\n                 let pat = dummy;\n-                for fpat: ast::field_pat  in fpats {\n+                for fpat: ast::field_pat in fpats {\n                     if str::eq(fpat.ident, fname) { pat = fpat.pat; break; }\n                 }\n                 pats += ~[pat];\n@@ -172,12 +172,12 @@ fn enter_box(m: &match, col: uint, val: ValueRef) -> match {\n \n fn get_options(ccx: &@crate_ctxt, m: &match, col: uint) -> [opt] {\n     fn add_to_set(set: &mutable [opt], val: &opt) {\n-        for l: opt  in set { if opt_eq(l, val) { ret; } }\n+        for l: opt in set { if opt_eq(l, val) { ret; } }\n         set += ~[val];\n     }\n \n     let found = ~[];\n-    for br: match_branch  in m {\n+    for br: match_branch in m {\n         alt br.pats.(col).node {\n           ast::pat_lit(l) { add_to_set(found, lit(l)); }\n           ast::pat_tag(_, _) {\n@@ -219,10 +219,10 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n \n fn collect_record_fields(m: &match, col: uint) -> [ast::ident] {\n     let fields = ~[];\n-    for br: match_branch  in m {\n+    for br: match_branch in m {\n         alt br.pats.(col).node {\n           ast::pat_rec(fs, _) {\n-            for f: ast::field_pat  in fs {\n+            for f: ast::field_pat in fs {\n                 if !ivec::any(bind str::eq(f.ident, _), fields) {\n                     fields += ~[f.ident];\n                 }\n@@ -235,7 +235,7 @@ fn collect_record_fields(m: &match, col: uint) -> [ast::ident] {\n }\n \n fn any_box_pat(m: &match, col: uint) -> bool {\n-    for br: match_branch  in m {\n+    for br: match_branch in m {\n         alt br.pats.(col).node { ast::pat_box(_) { ret true; } _ { } }\n     }\n     ret false;\n@@ -296,7 +296,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n         ivec::slice(vals, col + 1u, ivec::len(vals));\n     let ccx = bcx.fcx.lcx.ccx;\n     let pat_id = 0;\n-    for br: match_branch  in m {\n+    for br: match_branch in m {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 { pat_id = br.pats.(col).id; }\n@@ -385,7 +385,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n         } else { C_int(0) }; // Placeholder for when not using a switch\n \n      // Compile subtrees for each option\n-    for opt: opt  in opts {\n+    for opt: opt in opts {\n         let opt_cx = new_sub_block_ctxt(bcx, \"match_case\");\n         alt kind {\n           single. { bcx.build.Br(opt_cx.llbb); }\n@@ -432,18 +432,18 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n                      ids: &ast::pat_id_map) -> bool {\n     fn assoc(key: str, list: &bind_map) -> option::t[ValueRef] {\n-        for elt: {ident: ast::ident, val: ValueRef}  in list {\n+        for elt: {ident: ast::ident, val: ValueRef} in list {\n             if str::eq(elt.ident, key) { ret some(elt.val); }\n         }\n         ret none;\n     }\n \n     let our_block = bcx.llbb as uint;\n     let success = true;\n-    for each item: @{key: ast::ident, val: ast::node_id}  in ids.items() {\n+    for each item: @{key: ast::ident, val: ast::node_id} in ids.items() {\n         let llbbs = ~[];\n         let vals = ~[];\n-        for ex: exit_node  in map {\n+        for ex: exit_node in map {\n             if ex.to as uint == our_block {\n                 alt assoc(item.key, ex.bound) {\n                   some(val) { llbbs += ~[ex.from]; vals += ~[val]; }\n@@ -475,10 +475,10 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n         }\n     }\n \n-    for a: ast::arm  in arms {\n+    for a: ast::arm in arms {\n         let body = new_scope_block_ctxt(cx, \"case_body\");\n         bodies += ~[body];\n-        for p: @ast::pat  in a.pats {\n+        for p: @ast::pat in a.pats {\n             match += ~[@{pats: ~[p], body: body.llbb, mutable bound: ~[]}];\n         }\n     }\n@@ -502,7 +502,7 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n \n     let i = 0u;\n     let arm_results = ~[];\n-    for a: ast::arm  in arms {\n+    for a: ast::arm in arms {\n         let body_cx = bodies.(i);\n         if make_phi_bindings(body_cx, exit_map, ast::pat_id_map(a.pats.(0))) {\n             let block_res = trans::trans_block(body_cx, a.body, output);"}, {"sha": "c0a4e15ed8b472221b1ae279bff3e42adb92026f", "filename": "src/comp/middle/trans_comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -109,7 +109,7 @@ fn trans_spawn(cx: &@block_ctxt, dom: &ast::spawn_dom, name: &option::t[str],\n \n     let arg_tys: [ty::t] = ~[];\n     let arg_vals: [ValueRef] = ~[];\n-    for e: @ast::expr  in args {\n+    for e: @ast::expr in args {\n         let e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n         let arg = trans_expr(bcx, e);\n \n@@ -127,7 +127,7 @@ fn trans_spawn(cx: &@block_ctxt, dom: &ast::spawn_dom, name: &option::t[str],\n \n     let llargs = alloc_ty(bcx, args_ty);\n     let i = 0u;\n-    for v: ValueRef  in arg_vals {\n+    for v: ValueRef in arg_vals {\n         let target = bcx.build.GEP(llargs.val, ~[C_int(0), C_int(i as int)]);\n \n         bcx.build.Store(v, target);"}, {"sha": "0361535f3709e43511048010000e132a240d41a5", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -298,7 +298,7 @@ fn revoke_clean(cx: &@block_ctxt, val: ValueRef) {\n     let sc_cx = find_scope_cx(cx);\n     let found = -1;\n     let i = 0;\n-    for c: cleanup  in sc_cx.cleanups {\n+    for c: cleanup in sc_cx.cleanups {\n         alt c {\n           clean_temp(v, _) {\n             if v as uint == val as uint { found = i; break; }"}, {"sha": "d5020d1fe41c91bc1c489830a12f247f05f20581", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -416,11 +416,11 @@ fn trans_recv(bcx: &@block_ctxt, dest: &dest, expr: &@ast::expr) ->\n \n fn trans_block(cx: &@block_ctxt, dest: &dest, blk: &ast::blk) -> @block_ctxt {\n     let bcx = cx;\n-    for each local: @ast::local  in trans::block_locals(blk) {\n+    for each local: @ast::local in trans::block_locals(blk) {\n         bcx = trans::alloc_local(bcx, local).bcx;\n     }\n \n-    for stmt: @ast::stmt  in blk.node.stmts {\n+    for stmt: @ast::stmt in blk.node.stmts {\n         bcx = trans_stmt(bcx, stmt);\n \n \n@@ -456,7 +456,7 @@ fn trans_lit_str_common(ccx: &@crate_ctxt, s: &str, expand: bool) ->\n     let len = str::byte_len(s);\n \n     let array = ~[];\n-    for ch: u8  in s { array += ~[tc::C_u8(ch as uint)]; }\n+    for ch: u8 in s { array += ~[tc::C_u8(ch as uint)]; }\n     array += ~[tc::C_u8(0u)];\n \n     if expand {\n@@ -567,7 +567,7 @@ fn trans_stmt(cx: &@block_ctxt, stmt: &@ast::stmt) -> @block_ctxt {\n       ast::stmt_decl(d, _) {\n         alt d.node {\n           ast::decl_local(locals) {\n-            for local: @ast::local  in locals {\n+            for local: @ast::local in locals {\n                 bcx = trans_init_local(bcx, local);\n             }\n           }"}, {"sha": "1e9726e9001a5e40d21bddb11f65be4f6d1efb08", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -44,7 +44,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     // The fields of our object will become the arguments to the function\n     // we're creating.\n     let fn_args: [ast::arg] = ~[];\n-    for f: ast::obj_field  in ob.fields {\n+    for f: ast::obj_field in ob.fields {\n         fn_args +=\n             ~[{mode: ast::alias(false), ty: f.ty, ident: f.ident, id: f.id}];\n     }\n@@ -104,11 +104,11 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n         let obj_fields: [ty::t] = ~[];\n-        for a: ty::arg  in arg_tys { obj_fields += ~[a.ty]; }\n+        for a: ty::arg in arg_tys { obj_fields += ~[a.ty]; }\n \n         let tps: [ty::t] = ~[];\n         let tydesc_ty = ty::mk_type(ccx.tcx);\n-        for tp: ast::ty_param  in ty_params { tps += ~[tydesc_ty]; }\n+        for tp: ast::ty_param in ty_params { tps += ~[tydesc_ty]; }\n \n         // Synthesize an object body type and hand it off to\n         // trans_malloc_boxed, which allocates a box, including space for a\n@@ -154,7 +154,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         // TODO: can we just get typarams_ty out of body_ty instead?\n         let typarams_ty: ty::t = ty::mk_tup(ccx.tcx, tps);\n         let i: int = 0;\n-        for tp: ast::ty_param  in ty_params {\n+        for tp: ast::ty_param in ty_params {\n             let typaram = bcx.fcx.lltydescs.(i);\n             let capture =\n                 GEP_tup_like(bcx, typarams_ty, body_typarams.val, ~[0, i]);\n@@ -169,7 +169,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n                          ~[0, abi::obj_body_elt_fields]);\n         bcx = body_fields.bcx;\n         i = 0;\n-        for f: ast::obj_field  in ob.fields {\n+        for f: ast::obj_field in ob.fields {\n             alt bcx.fcx.llargs.find(f.id) {\n               some(arg1) {\n                 let arg = load_if_immediate(bcx, arg1, arg_tys.(i).ty);\n@@ -217,7 +217,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n       none. { }\n       some(fields) {\n         additional_fields = fields;\n-        for f: ast::anon_obj_field  in fields {\n+        for f: ast::anon_obj_field in fields {\n             additional_field_tys += ~[node_id_type(ccx, f.id)];\n             additional_field_vals += ~[trans_expr(bcx, f.expr)];\n         }\n@@ -342,7 +342,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n                          ~[0, abi::obj_body_elt_fields]);\n         bcx = body_fields.bcx;\n         let i: int = 0;\n-        for f: ast::anon_obj_field  in additional_fields {\n+        for f: ast::anon_obj_field in additional_fields {\n             // FIXME (part of issue #538): make this work eventually, when we\n             // have additional field exprs in the AST.\n             load_if_immediate(bcx, additional_field_vals.(i).val,\n@@ -483,7 +483,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n         // Gather up methods on the inner object.\n         alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n           ty::ty_obj(inner_obj_methods) {\n-            for m: ty::method  in inner_obj_methods {\n+            for m: ty::method in inner_obj_methods {\n                 meths += ~[fwding_mthd(@m)];\n             }\n           }\n@@ -699,7 +699,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     let a: uint = 3u; // retptr, task ptr, env come first\n     let passed_arg: ValueRef = llvm::LLVMGetParam(llbackwarding_fn, a);\n-    for arg: ty::arg  in m.inputs {\n+    for arg: ty::arg in m.inputs {\n         if arg.mode == ty::mo_val {\n             passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n         }\n@@ -871,7 +871,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     let a: uint = 3u; // retptr, task ptr, env come first\n     let passed_arg: ValueRef = llvm::LLVMGetParam(llforwarding_fn, a);\n-    for arg: ty::arg  in m.inputs {\n+    for arg: ty::arg in m.inputs {\n         if arg.mode == ty::mo_val {\n             passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n         }"}, {"sha": "1d9fa056363739ce843a6cb141a3045eb4d9b2b8", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -59,7 +59,7 @@ fn node_ids_in_fn(f: &_fn, tps: &[ty_param], sp: &span, i: &fn_ident,\n }\n \n fn init_vecs(ccx: &crate_ctxt, node_ids: &[node_id], len: uint) {\n-    for i: node_id  in node_ids {\n+    for i: node_id in node_ids {\n         log int::str(i) + \" |-> \" + uint::str(len);\n         add_node(ccx, i, empty_ann(len));\n     }"}, {"sha": "52600781ed2b01eac59f0c639b3eafecf577c4a6", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -61,7 +61,7 @@ fn def_id_to_str(d: def_id) -> str {\n fn comma_str(args: &[@constr_arg_use]) -> str {\n     let rslt = \"\";\n     let comma = false;\n-    for a: @constr_arg_use  in args {\n+    for a: @constr_arg_use in args {\n         if comma { rslt += \", \"; } else { comma = true; }\n         alt a.node {\n           carg_base. { rslt += \"*\"; }\n@@ -87,7 +87,7 @@ fn constraint_to_str(tcx: &ty::ctxt, c: &sp_constr) -> str {\n fn tritv_to_str(fcx: fn_ctxt, v: &tritv::t) -> str {\n     let s = \"\";\n     let comma = false;\n-    for p: norm_constraint  in constraints(fcx) {\n+    for p: norm_constraint in constraints(fcx) {\n         alt tritv_get(v, p.bit_num) {\n           dont_care. { }\n           t {\n@@ -106,7 +106,7 @@ fn log_tritv(fcx: &fn_ctxt, v: &tritv::t) { log tritv_to_str(fcx, v); }\n fn first_difference_string(fcx: &fn_ctxt, expected: &tritv::t,\n                            actual: &tritv::t) -> str {\n     let s: str = \"\";\n-    for c: norm_constraint  in constraints(fcx) {\n+    for c: norm_constraint in constraints(fcx) {\n         if tritv_get(expected, c.bit_num) == ttrue &&\n                tritv_get(actual, c.bit_num) != ttrue {\n             ret constraint_to_str(fcx.ccx.tcx, c.c);\n@@ -119,7 +119,7 @@ fn log_tritv_err(fcx: fn_ctxt, v: tritv::t) { log_err tritv_to_str(fcx, v); }\n \n fn tos(v: &[uint]) -> str {\n     let rslt = \"\";\n-    for i: uint  in v {\n+    for i: uint in v {\n         if i == 0u {\n             rslt += \"0\";\n         } else if (i == 1u) { rslt += \"1\"; } else { rslt += \"?\"; }\n@@ -561,7 +561,7 @@ fn norm_a_constraint(id: def_id, c: &constraint) -> [norm_constraint] {\n       }\n       cpred(p, descs) {\n         let rslt: [norm_constraint] = ~[];\n-        for pd: pred_args  in *descs {\n+        for pd: pred_args in *descs {\n             rslt +=\n                 ~[{bit_num: pd.node.bit_num,\n                    c: respan(pd.span, npred(p, id, pd.node.args))}];\n@@ -590,7 +590,7 @@ fn match_args(fcx: &fn_ctxt, occs: &@mutable [pred_args],\n               occ: &[@constr_arg_use]) -> uint {\n     log \"match_args: looking at \" +\n             constr_args_to_str(fn (i: &inst) -> str { ret i.ident; }, occ);\n-    for pd: pred_args  in *occs {\n+    for pd: pred_args in *occs {\n         log \"match_args: candidate \" + pred_args_to_str(pd);\n         fn eq(p: &inst, q: &inst) -> bool { ret p.node == q.node; }\n         if ty::args_eq(eq, pd.node.args, occ) { ret pd.node.bit_num; }\n@@ -642,7 +642,7 @@ fn exprs_to_constr_args(tcx: ty::ctxt, args: &[@expr]) ->\n    [@constr_arg_use] {\n     let f = bind expr_to_constr_arg(tcx, _);\n     let rslt: [@constr_arg_use] = ~[];\n-    for e: @expr  in args { rslt += ~[f(e)]; }\n+    for e: @expr in args { rslt += ~[f(e)]; }\n     rslt\n }\n \n@@ -682,7 +682,7 @@ fn pred_args_to_str(p: &pred_args) -> str {\n fn substitute_constr_args(cx: &ty::ctxt, actuals: &[@expr], c: &@ty::constr)\n    -> tsconstr {\n     let rslt: [@constr_arg_use] = ~[];\n-    for a: @constr_arg  in c.node.args {\n+    for a: @constr_arg in c.node.args {\n         rslt += ~[substitute_arg(cx, actuals, a)];\n     }\n     ret npred(c.node.path, c.node.id, rslt);\n@@ -707,7 +707,7 @@ fn substitute_arg(cx: &ty::ctxt, actuals: &[@expr], a: @constr_arg) ->\n fn pred_args_matches(pattern: &[constr_arg_general_[inst]],\n                      desc: &pred_args) -> bool {\n     let i = 0u;\n-    for c: @constr_arg_use  in desc.node.args {\n+    for c: @constr_arg_use in desc.node.args {\n         let n = pattern.(i);\n         alt c.node {\n           carg_ident(p) {\n@@ -731,7 +731,7 @@ fn pred_args_matches(pattern: &[constr_arg_general_[inst]],\n \n fn find_instance_(pattern: &[constr_arg_general_[inst]],\n                   descs: &[pred_args]) -> option::t[uint] {\n-    for d: pred_args  in descs {\n+    for d: pred_args in descs {\n         if pred_args_matches(pattern, d) { ret some(d.node.bit_num); }\n     }\n     ret none;\n@@ -749,7 +749,7 @@ fn find_instances(fcx: &fn_ctxt, subst: &subst, c: &constraint) ->\n     alt c {\n       cinit(_, _, _) {/* this is dealt with separately */ }\n       cpred(p, descs) {\n-        for d: pred_args  in *descs {\n+        for d: pred_args in *descs {\n             if args_mention(d.node.args, find_in_subst_bool, subst) {\n                 let old_bit_num = d.node.bit_num;\n                 let new = replace(subst, d);\n@@ -765,7 +765,7 @@ fn find_instances(fcx: &fn_ctxt, subst: &subst, c: &constraint) ->\n }\n \n fn find_in_subst(id: node_id, s: &subst) -> option::t[inst] {\n-    for p: {from: inst, to: inst}  in s {\n+    for p: {from: inst, to: inst} in s {\n         if id == p.from.node { ret some(p.to); }\n     }\n     ret none;\n@@ -777,7 +777,7 @@ fn find_in_subst_bool(s: &subst, id: node_id) -> bool {\n \n fn insts_to_str(stuff: &[constr_arg_general_[inst]]) -> str {\n     let rslt = \"<\";\n-    for i: constr_arg_general_[inst]  in stuff {\n+    for i: constr_arg_general_[inst] in stuff {\n         rslt +=\n             \" \" +\n                 alt i {\n@@ -792,7 +792,7 @@ fn insts_to_str(stuff: &[constr_arg_general_[inst]]) -> str {\n \n fn replace(subst: subst, d: pred_args) -> [constr_arg_general_[inst]] {\n     let rslt: [constr_arg_general_[inst]] = ~[];\n-    for c: @constr_arg_use  in d.node.args {\n+    for c: @constr_arg_use in d.node.args {\n         alt c.node {\n           carg_ident(p) {\n             alt find_in_subst(p.node, subst) {\n@@ -906,7 +906,7 @@ fn copy_in_poststate_two(fcx: &fn_ctxt, src_post: &poststate,\n         // replace any occurrences of the src def_id with the\n         // dest def_id\n         let insts = find_instances(fcx, subst, p.val);\n-        for p: {from: uint, to: uint}  in insts {\n+        for p: {from: uint, to: uint} in insts {\n             if promises_(p.from, src_post) {\n                 set_in_poststate_(p.to, target_post);\n             }\n@@ -922,7 +922,7 @@ fn forget_in_postcond(fcx: &fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n     alt d {\n       some(d_id) {\n-        for c: norm_constraint  in constraints(fcx) {\n+        for c: norm_constraint in constraints(fcx) {\n             if constraint_mentions(fcx, c, d_id) {\n                 clear_in_postcond(c.bit_num,\n                                   node_id_to_ts_ann(fcx.ccx,\n@@ -941,7 +941,7 @@ fn forget_in_postcond_still_init(fcx: &fn_ctxt, parent_exp: node_id,\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n     alt d {\n       some(d_id) {\n-        for c: norm_constraint  in constraints(fcx) {\n+        for c: norm_constraint in constraints(fcx) {\n             if non_init_constraint_mentions(fcx, c, d_id) {\n                 clear_in_postcond(c.bit_num,\n                                   node_id_to_ts_ann(fcx.ccx,\n@@ -961,7 +961,7 @@ fn forget_in_poststate(fcx: &fn_ctxt, p: &poststate, dead_v: node_id) ->\n     let changed = false;\n     alt d {\n       some(d_id) {\n-        for c: norm_constraint  in constraints(fcx) {\n+        for c: norm_constraint in constraints(fcx) {\n             if constraint_mentions(fcx, c, d_id) {\n                 changed |= clear_in_poststate_(c.bit_num, p);\n             }\n@@ -980,7 +980,7 @@ fn forget_in_poststate_still_init(fcx: &fn_ctxt, p: &poststate,\n     let changed = false;\n     alt d {\n       some(d_id) {\n-        for c: norm_constraint  in constraints(fcx) {\n+        for c: norm_constraint in constraints(fcx) {\n             if non_init_constraint_mentions(fcx, c, d_id) {\n                 changed |= clear_in_poststate_(c.bit_num, p);\n             }\n@@ -992,7 +992,7 @@ fn forget_in_poststate_still_init(fcx: &fn_ctxt, p: &poststate,\n }\n \n fn any_eq(v: &[node_id], d: node_id) -> bool {\n-    for i: node_id  in v { if i == d { ret true; } }\n+    for i: node_id in v { if i == d { ret true; } }\n     false\n }\n \n@@ -1032,7 +1032,7 @@ fn args_mention[T](args: &[@constr_arg_use], q: fn(&[T], node_id) -> bool ,\n     ret ivec::any(bind mentions(s,q,_), args);\n     */\n \n-    for a: @constr_arg_use  in args {\n+    for a: @constr_arg_use in args {\n         alt a.node { carg_ident(p1) { if q(s, p1.node) { ret true; } } _ { } }\n     }\n     ret false;\n@@ -1042,7 +1042,7 @@ fn use_var(fcx: &fn_ctxt, v: &node_id) { *fcx.enclosing.used_vars += ~[v]; }\n \n // FIXME: This should be a function in std::ivec::.\n fn vec_contains(v: &@mutable [node_id], i: &node_id) -> bool {\n-    for d: node_id  in *v { if d == i { ret true; } }\n+    for d: node_id in *v { if d == i { ret true; } }\n     ret false;\n }\n \n@@ -1058,7 +1058,7 @@ fn do_nothing[T](f: &_fn, tp: &[ty_param], sp: &span, i: &fn_ident,\n \n fn args_to_constr_args(sp: &span, args: &[arg]) -> [@constr_arg_use] {\n     let actuals: [@constr_arg_use] = ~[];\n-    for a: arg  in args {\n+    for a: arg in args {\n         actuals += ~[@respan(sp, carg_ident({ident: a.ident, node: a.id}))];\n     }\n     ret actuals;"}, {"sha": "25e5a27abd889631874f37363a32062e998385af", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -80,7 +80,7 @@ fn seq_postconds(fcx: &fn_ctxt, ps: &[postcond]) -> postcond {\n     let sz = ivec::len(ps);\n     if sz >= 1u {\n         let prev = tritv_clone(ps.(0));\n-        for p: postcond  in ivec::slice(ps, 1u, sz) { seq_tritv(prev, p); }\n+        for p: postcond in ivec::slice(ps, 1u, sz) { seq_tritv(prev, p); }\n         ret prev;\n     } else { ret ann::empty_poststate(num_constraints(fcx.enclosing)); }\n }"}, {"sha": "92afaf7cc3efc6215deca8ff43e7818e2a2e217e", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -49,7 +49,7 @@ import states::find_pre_post_state_fn;\n fn check_unused_vars(fcx: &fn_ctxt) {\n \n     // FIXME: could be more efficient\n-    for c: norm_constraint  in constraints(fcx) {\n+    for c: norm_constraint in constraints(fcx) {\n         alt c.c.node {\n           ninit(id, v) {\n             if !vec_contains(fcx.enclosing.used_vars, id) {"}, {"sha": "35d9d6574036005e01a4345983bd5ef416da4f54", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -30,7 +30,7 @@ fn collect_pred(e: &@expr, cx: &ctxt, v: &visit::vt[ctxt]) {\n       // If it's a call, generate appropriate instances of the\n       // call's constraints.\n       expr_call(operator, operands) {\n-        for c: @ty::constr  in constraints_expr(cx.tcx, operator) {\n+        for c: @ty::constr in constraints_expr(cx.tcx, operator) {\n             let ct: sp_constr =\n                 respan(c.span,\n                        aux::substitute_constr_args(cx.tcx, operands, c));\n@@ -98,13 +98,13 @@ fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n     /* now we have to add bit nums for both the constraints\n        and the variables... */\n \n-    for c: sp_constr  in { *cx.cs } {\n+    for c: sp_constr in { *cx.cs } {\n         next = add_constraint(cx.tcx, c, next, res_map);\n     }\n     /* if this function has any constraints, instantiate them to the\n        argument names and add them */\n     let sc;\n-    for c: @constr  in f.decl.constraints {\n+    for c: @constr in f.decl.constraints {\n         sc = ast_constr_to_sp_constr(cx.tcx, f.decl.inputs, c);\n         next = add_constraint(cx.tcx, sc, next, res_map);\n     }"}, {"sha": "853110275a60d474591c1600103b995ba4f2350f", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -65,7 +65,7 @@ fn find_pre_post_obj(ccx: &crate_ctxt, o: _obj) {\n              ccx: ccx};\n         find_pre_post_fn(fcx, m.node.meth);\n     }\n-    for m: @method  in o.methods { do_a_method(ccx, m); }\n+    for m: @method in o.methods { do_a_method(ccx, m); }\n }\n \n fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n@@ -120,7 +120,7 @@ fn find_pre_post_exprs(fcx: &fn_ctxt, args: &[@expr], id: node_id) {\n         log_expr(*args.(0));\n     }\n     fn do_one(fcx: fn_ctxt, e: &@expr) { find_pre_post_expr(fcx, e); }\n-    for e: @expr  in args { do_one(fcx, e); }\n+    for e: @expr in args { do_one(fcx, e); }\n \n     fn get_pp(ccx: crate_ctxt, e: &@expr) -> pre_and_post {\n         ret expr_pp(ccx, e);\n@@ -341,7 +341,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n \n         find_pre_post_exprs(fcx, args, e.id);\n         /* see if the call has any constraints on its type */\n-        for c: @ty::constr  in constraints_expr(fcx.ccx.tcx, operator) {\n+        for c: @ty::constr in constraints_expr(fcx.ccx.tcx, operator) {\n             let i =\n                 bit_num(fcx, substitute_constr_args(fcx.ccx.tcx, args, c));\n             require(i, expr_pp(fcx.ccx, e));\n@@ -391,7 +391,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         let rslt = expr_pp(fcx.ccx, e);\n         clear_pp(rslt);\n         let upvars = freevars::get_freevars(fcx.ccx.tcx, e.id);\n-        for id: node_id  in *upvars { handle_var(fcx, rslt, id, \"upvar\"); }\n+        for id: node_id in *upvars { handle_var(fcx, rslt, id, \"upvar\"); }\n       }\n       expr_block(b) {\n         find_pre_post_block(fcx, b);\n@@ -512,7 +512,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n             ret block_pp(fcx.ccx, an_alt.body);\n         }\n         let alt_pps = ~[];\n-        for a: arm  in alts { alt_pps += ~[do_an_alt(fcx, a)]; }\n+        for a: arm in alts { alt_pps += ~[do_an_alt(fcx, a)]; }\n         fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, pp: &pre_and_post,\n                       next: &pre_and_post) -> pre_and_post {\n             union(pp.precondition, seq_preconds(fcx, ~[antec, next]));\n@@ -607,7 +607,7 @@ fn find_pre_post_stmt(fcx: &fn_ctxt, s: &stmt) {\n       stmt_decl(adecl, id) {\n         alt adecl.node {\n           decl_local(alocals) {\n-            for alocal: @local  in alocals {\n+            for alocal: @local in alocals {\n                 alt alocal.node.init {\n                   some(an_init) {\n                     /* LHS always becomes initialized,\n@@ -694,13 +694,13 @@ fn find_pre_post_block(fcx: &fn_ctxt, b: blk) {\n         log \"is:\";\n         log_pp(stmt_pp(fcx.ccx, *s));\n     }\n-    for s: @stmt  in b.node.stmts { do_one_(fcx, s); }\n+    for s: @stmt in b.node.stmts { do_one_(fcx, s); }\n     fn do_inner_(fcx: fn_ctxt, e: &@expr) { find_pre_post_expr(fcx, e); }\n     let do_inner = bind do_inner_(fcx, _);\n     option::map[@expr, ()](do_inner, b.node.expr);\n \n     let pps: [pre_and_post] = ~[];\n-    for s: @stmt  in b.node.stmts { pps += ~[stmt_pp(fcx.ccx, *s)]; }\n+    for s: @stmt in b.node.stmts { pps += ~[stmt_pp(fcx.ccx, *s)]; }\n     alt b.node.expr {\n       none. {/* no-op */ }\n       some(e) { pps += ~[expr_pp(fcx.ccx, e)]; }\n@@ -709,7 +709,7 @@ fn find_pre_post_block(fcx: &fn_ctxt, b: blk) {\n     let block_precond = seq_preconds(fcx, pps);\n \n     let postconds = ~[];\n-    for pp: pre_and_post  in pps { postconds += ~[get_post(pp)]; }\n+    for pp: pre_and_post in pps { postconds += ~[get_post(pp)]; }\n \n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */"}, {"sha": "6ff42167e6a5fc42867776281d5b34de3d2f5777", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -556,7 +556,7 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n         let a_post;\n         if ivec::len(alts) > 0u {\n             a_post = false_postcond(num_constrs);\n-            for an_alt: arm  in alts {\n+            for an_alt: arm in alts {\n                 changed |=\n                     find_pre_post_state_block(fcx, e_post, an_alt.body);\n                 intersect(a_post, block_poststate(fcx.ccx, an_alt.body));\n@@ -712,7 +712,7 @@ fn find_pre_post_state_block(fcx: &fn_ctxt, pres0: &prestate, b: &blk) ->\n      initializes.  Then <pres> becomes the new poststate. */\n \n     let changed = false;\n-    for s: @stmt  in b.node.stmts {\n+    for s: @stmt in b.node.stmts {\n         changed |= find_pre_post_state_stmt(fcx, pres, s);\n         pres = stmt_poststate(fcx.ccx, *s);\n     }\n@@ -755,7 +755,7 @@ fn find_pre_post_state_fn(fcx: &fn_ctxt, f: &_fn) -> bool {\n     // Instantiate any constraints on the arguments so we can use them\n     let block_pre = block_prestate(fcx.ccx, f.body);\n     let tsc;\n-    for c: @constr  in f.decl.constraints {\n+    for c: @constr in f.decl.constraints {\n         tsc = ast_constr_to_ts_constr(fcx.ccx.tcx, f.decl.inputs, c);\n         set_in_prestate_constr(fcx, tsc, block_pre);\n     }"}, {"sha": "3652b68ef239f11cdf62d4b7a50a751a3eaf0814", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -455,7 +455,7 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t[str]) -> @raw_t {\n     }\n     fn derive_flags_sig(cx: &ctxt, has_params: &mutable bool,\n                         has_vars: &mutable bool, args: &[arg], tt: &t) {\n-        for a: arg  in args { derive_flags_arg(cx, has_params, has_vars, a); }\n+        for a: arg in args { derive_flags_arg(cx, has_params, has_vars, a); }\n         derive_flags_t(cx, has_params, has_vars, tt);\n     }\n     alt st {\n@@ -475,7 +475,7 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t[str]) -> @raw_t {\n       ty_param(_,_) { has_params = true; }\n       ty_var(_) { has_vars = true; }\n       ty_tag(_, tys) {\n-        for tt: t  in tys { derive_flags_t(cx, has_params, has_vars, tt); }\n+        for tt: t in tys { derive_flags_t(cx, has_params, has_vars, tt); }\n       }\n       ty_box(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n       ty_uniq(tt) { derive_flags_t(cx, has_params, has_vars, tt); }\n@@ -485,7 +485,7 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t[str]) -> @raw_t {\n       ty_port(tt) { derive_flags_t(cx, has_params, has_vars, tt); }\n       ty_chan(tt) { derive_flags_t(cx, has_params, has_vars, tt); }\n       ty_rec(flds) {\n-        for f: field  in flds {\n+        for f: field in flds {\n             derive_flags_mt(cx, has_params, has_vars, f.mt);\n         }\n       }\n@@ -501,13 +501,13 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t[str]) -> @raw_t {\n         derive_flags_sig(cx, has_params, has_vars, args, tt);\n       }\n       ty_obj(meths) {\n-        for m: method  in meths {\n+        for m: method in meths {\n             derive_flags_sig(cx, has_params, has_vars, m.inputs, m.output);\n         }\n       }\n       ty_res(_, tt, tps) {\n         derive_flags_t(cx, has_params, has_vars, tt);\n-        for tt: t  in tps { derive_flags_t(cx, has_params, has_vars, tt); }\n+        for tt: t in tps { derive_flags_t(cx, has_params, has_vars, tt); }\n       }\n       ty_constr(tt, _) { derive_flags_t(cx, has_params, has_vars, tt); }\n     }\n@@ -673,31 +673,31 @@ fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n       ty_port(subty) { walk_ty(cx, walker, subty); }\n       ty_chan(subty) { walk_ty(cx, walker, subty); }\n       ty_tag(tid, subtys) {\n-        for subty: t  in subtys { walk_ty(cx, walker, subty); }\n+        for subty: t in subtys { walk_ty(cx, walker, subty); }\n       }\n       ty_rec(fields) {\n-        for fl: field  in fields { walk_ty(cx, walker, fl.mt.ty); }\n+        for fl: field in fields { walk_ty(cx, walker, fl.mt.ty); }\n       }\n       ty_tup(ts) {\n         for tt in ts { walk_ty(cx, walker, tt); }\n       }\n       ty_fn(proto, args, ret_ty, _, _) {\n-        for a: arg  in args { walk_ty(cx, walker, a.ty); }\n+        for a: arg in args { walk_ty(cx, walker, a.ty); }\n         walk_ty(cx, walker, ret_ty);\n       }\n       ty_native_fn(abi, args, ret_ty) {\n-        for a: arg  in args { walk_ty(cx, walker, a.ty); }\n+        for a: arg in args { walk_ty(cx, walker, a.ty); }\n         walk_ty(cx, walker, ret_ty);\n       }\n       ty_obj(methods) {\n-        for m: method  in methods {\n-            for a: arg  in m.inputs { walk_ty(cx, walker, a.ty); }\n+        for m: method in methods {\n+            for a: arg in m.inputs { walk_ty(cx, walker, a.ty); }\n             walk_ty(cx, walker, m.output);\n         }\n       }\n       ty_res(_, sub, tps) {\n         walk_ty(cx, walker, sub);\n-        for tp: t  in tps { walk_ty(cx, walker, tp); }\n+        for tp: t in tps { walk_ty(cx, walker, tp); }\n       }\n       ty_constr(sub, _) {\n         walk_ty(cx, walker, sub);\n@@ -755,12 +755,12 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_chan(subty) { ty = mk_chan(cx, fold_ty(cx, fld, subty)); }\n       ty_tag(tid, subtys) {\n         let new_subtys: [t] = ~[];\n-        for subty: t  in subtys { new_subtys += ~[fold_ty(cx, fld, subty)]; }\n+        for subty: t in subtys { new_subtys += ~[fold_ty(cx, fld, subty)]; }\n         ty = copy_cname(cx, mk_tag(cx, tid, new_subtys), ty);\n       }\n       ty_rec(fields) {\n         let new_fields: [field] = ~[];\n-        for fl: field  in fields {\n+        for fl: field in fields {\n             let new_ty = fold_ty(cx, fld, fl.mt.ty);\n             let new_mt = {ty: new_ty, mut: fl.mt.mut};\n             new_fields += ~[{ident: fl.ident, mt: new_mt}];\n@@ -776,7 +776,7 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n       }\n       ty_fn(proto, args, ret_ty, cf, constrs) {\n         let new_args: [arg] = ~[];\n-        for a: arg  in args {\n+        for a: arg in args {\n             let new_ty = fold_ty(cx, fld, a.ty);\n             new_args += ~[{mode: a.mode, ty: new_ty}];\n         }\n@@ -787,7 +787,7 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n       }\n       ty_native_fn(abi, args, ret_ty) {\n         let new_args: [arg] = ~[];\n-        for a: arg  in args {\n+        for a: arg in args {\n             let new_ty = fold_ty(cx, fld, a.ty);\n             new_args += ~[{mode: a.mode, ty: new_ty}];\n         }\n@@ -798,9 +798,9 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n       }\n       ty_obj(methods) {\n         let new_methods: [method] = ~[];\n-        for m: method  in methods {\n+        for m: method in methods {\n             let new_args: [arg] = ~[];\n-            for a: arg  in m.inputs {\n+            for a: arg in m.inputs {\n                 new_args += ~[{mode: a.mode, ty: fold_ty(cx, fld, a.ty)}];\n             }\n             new_methods +=\n@@ -815,7 +815,7 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n       }\n       ty_res(did, subty, tps) {\n         let new_tps = ~[];\n-        for tp: t  in tps { new_tps += ~[fold_ty(cx, fld, tp)]; }\n+        for tp: t in tps { new_tps += ~[fold_ty(cx, fld, tp)]; }\n         ty =\n             copy_cname(cx, mk_res(cx, did, fold_ty(cx, fld, subty), new_tps),\n                        ty);\n@@ -1014,7 +1014,7 @@ fn type_has_pointers(cx: &ctxt, ty: &t) -> bool {\n       ty_type. {/* no-op */ }\n       ty_native(_) {/* no-op */ }\n       ty_rec(flds) {\n-        for f: field  in flds {\n+        for f: field in flds {\n             if type_has_pointers(cx, f.mt.ty) {\n                 result = true;\n                 break;\n@@ -1028,8 +1028,8 @@ fn type_has_pointers(cx: &ctxt, ty: &t) -> bool {\n       }\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n-        for variant: variant_info  in variants {\n-            for aty: t  in variant.args {\n+        for variant: variant_info in variants {\n+            for aty: t in variant.args {\n                 // Perform any type parameter substitutions.\n                 let arg_ty = substitute_type_params(cx, tps, aty);\n                 if type_has_pointers(cx, arg_ty) {\n@@ -1129,7 +1129,7 @@ fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n \n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n-        for f: field  in flds {\n+        for f: field in flds {\n             result = kind::lower_kind(result, type_kind(cx, f.mt.ty));\n             if result == ast::kind_pinned { break; }\n         }\n@@ -1138,8 +1138,8 @@ fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n       // Tags lower to the lowest of their variants.\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n-        for variant: variant_info  in variants {\n-            for aty: t  in variant.args {\n+        for variant: variant_info in variants {\n+            for aty: t in variant.args {\n                 // Perform any type parameter substitutions.\n                 let arg_ty = substitute_type_params(cx, tps, aty);\n                 result = kind::lower_kind(result, type_kind(cx, arg_ty));\n@@ -1226,7 +1226,7 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n       ty_native_fn(_, _, _) { ret false; }\n       ty_obj(_) { ret false; }\n       ty_res(_, sub, tps) {\n-        for tp: t  in tps { if type_has_dynamic_size(cx, tp) { ret true; } }\n+        for tp: t in tps { if type_has_dynamic_size(cx, tp) { ret true; } }\n         ret type_has_dynamic_size(cx, sub);\n       }\n       ty_var(_) { fail \"ty_var in type_has_dynamic_size()\"; }\n@@ -1331,16 +1331,16 @@ fn type_owns_heap_mem(cx: &ctxt, ty: &t) -> bool {\n       // structural types\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n-        for variant: variant_info  in variants {\n-            for aty: t  in variant.args {\n+        for variant: variant_info in variants {\n+            for aty: t in variant.args {\n                 // Perform any type parameter substitutions.\n                 let arg_ty = substitute_type_params(cx, tps, aty);\n                 if type_owns_heap_mem(cx, arg_ty) { result = true; }\n             }\n         }\n       }\n       ty_rec(flds) {\n-        for f: field  in flds {\n+        for f: field in flds {\n             if type_owns_heap_mem(cx, f.mt.ty) { result = true; }\n         }\n       }\n@@ -1491,7 +1491,7 @@ fn hash_type_structure(st: &sty) -> uint {\n     }\n     fn hash_type_constr_args(id: uint, args: [@ty_constr_arg]) -> uint {\n         let h = id;\n-        for a: @ty_constr_arg  in args {\n+        for a: @ty_constr_arg in args {\n             alt a.node {\n               carg_base. { h += h << 5u; }\n               carg_lit(_) {\n@@ -1510,7 +1510,7 @@ fn hash_type_structure(st: &sty) -> uint {\n \n     fn hash_fn(id: uint, args: &[arg], rty: &t) -> uint {\n         let h = id;\n-        for a: arg  in args { h += h << 5u + hash_ty(a.ty); }\n+        for a: arg in args { h += h << 5u + hash_ty(a.ty); }\n         h += h << 5u + hash_ty(rty);\n         ret h;\n     }\n@@ -1539,7 +1539,7 @@ fn hash_type_structure(st: &sty) -> uint {\n       ty_istr. { ret 17u; }\n       ty_tag(did, tys) {\n         let h = hash_def(18u, did);\n-        for typ: t  in tys { h += h << 5u + hash_ty(typ); }\n+        for typ: t in tys { h += h << 5u + hash_ty(typ); }\n         ret h;\n       }\n       ty_box(mt) { ret hash_subty(19u, mt.ty); }\n@@ -1550,7 +1550,7 @@ fn hash_type_structure(st: &sty) -> uint {\n       ty_task. { ret 24u; }\n       ty_rec(fields) {\n         let h = 26u;\n-        for f: field  in fields { h += h << 5u + hash_ty(f.mt.ty); }\n+        for f: field in fields { h += h << 5u + hash_ty(f.mt.ty); }\n         ret h;\n       }\n       ty_tup(ts) {\n@@ -1566,7 +1566,7 @@ fn hash_type_structure(st: &sty) -> uint {\n       ty_native_fn(_, args, rty) { ret hash_fn(28u, args, rty); }\n       ty_obj(methods) {\n         let h = 29u;\n-        for m: method  in methods { h += h << 5u + str::hash(m.ident); }\n+        for m: method in methods { h += h << 5u + str::hash(m.ident); }\n         ret h;\n       }\n       ty_var(v) { ret hash_uint(30u, v as uint); }\n@@ -1577,12 +1577,12 @@ fn hash_type_structure(st: &sty) -> uint {\n       ty_ptr(mt) { ret hash_subty(35u, mt.ty); }\n       ty_res(did, sub, tps) {\n         let h = hash_subty(hash_def(18u, did), sub);\n-        for tp: t  in tps { h += h << 5u + hash_ty(tp); }\n+        for tp: t in tps { h += h << 5u + hash_ty(tp); }\n         ret h;\n       }\n       ty_constr(t, cs) {\n         let h = 36u;\n-        for c: @type_constr  in cs { h += h << 5u + hash_type_constr(h, c); }\n+        for c: @type_constr in cs { h += h << 5u + hash_type_constr(h, c); }\n         ret h;\n       }\n       ty_uniq(t) {\n@@ -1629,7 +1629,7 @@ fn arg_eq[T](eq: &fn(&T, &T) -> bool , a: @sp_constr_arg[T],\n fn args_eq[T](eq: fn(&T, &T) -> bool , a: &[@sp_constr_arg[T]],\n               b: &[@sp_constr_arg[T]]) -> bool {\n     let i: uint = 0u;\n-    for arg: @sp_constr_arg[T]  in a {\n+    for arg: @sp_constr_arg[T] in a {\n         if !arg_eq(eq, arg, b.(i)) { ret false; }\n         i += 1u;\n     }\n@@ -1645,7 +1645,7 @@ fn constr_eq(c: &@constr, d: &@constr) -> bool {\n fn constrs_eq(cs: &[@constr], ds: &[@constr]) -> bool {\n     if ivec::len(cs) != ivec::len(ds) { ret false; }\n     let i = 0u;\n-    for c: @constr  in cs { if !constr_eq(c, ds.(i)) { ret false; } i += 1u; }\n+    for c: @constr in cs { if !constr_eq(c, ds.(i)) { ret false; } i += 1u; }\n     ret true;\n }\n \n@@ -1805,7 +1805,7 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n                 ret false;\n             }\n             let i = 0u;\n-            for tp_a: t  in tps_a {\n+            for tp_a: t in tps_a {\n                 if !eq_ty(tp_a, tps_b.(i)) { ret false; }\n                 i += 1u;\n             }\n@@ -1927,7 +1927,7 @@ fn count_ty_params(cx: &ctxt, ty: t) -> uint {\n         alt struct(cx, ty) {\n           ty_param(param_idx,_) {\n             let seen = false;\n-            for other_param_idx: uint  in *param_indices {\n+            for other_param_idx: uint in *param_indices {\n                 if param_idx == other_param_idx { seen = true; }\n             }\n             if !seen { *param_indices += ~[param_idx]; }\n@@ -2044,14 +2044,14 @@ fn stmt_node_id(s: &@ast::stmt) -> ast::node_id {\n fn field_idx(sess: &session::session, sp: &span, id: &ast::ident,\n              fields: &[field]) -> uint {\n     let i: uint = 0u;\n-    for f: field  in fields { if str::eq(f.ident, id) { ret i; } i += 1u; }\n+    for f: field in fields { if str::eq(f.ident, id) { ret i; } i += 1u; }\n     sess.span_fatal(sp, \"unknown field '\" + id + \"' of record\");\n }\n \n fn method_idx(sess: &session::session, sp: &span, id: &ast::ident,\n               meths: &[method]) -> uint {\n     let i: uint = 0u;\n-    for m: method  in meths { if str::eq(m.ident, id) { ret i; } i += 1u; }\n+    for m: method in meths { if str::eq(m.ident, id) { ret i; } i += 1u; }\n     sess.span_fatal(sp, \"unknown method '\" + id + \"' of obj\");\n }\n \n@@ -2219,7 +2219,7 @@ mod unify {\n         }\n         let i = 0u;\n         let rslt;\n-        for c: @type_constr  in expected {\n+        for c: @type_constr in expected {\n             rslt = unify_constr(base_t, c, actual.(i));\n             alt rslt { ures_ok(_) { } ures_err(_) { ret rslt; } }\n             i += 1u;\n@@ -2236,7 +2236,7 @@ mod unify {\n         if expected_arg_len != actual_arg_len { ret err_res; }\n         let i = 0u;\n         let actual;\n-        for a: @ty_constr_arg  in expected.node.args {\n+        for a: @ty_constr_arg in expected.node.args {\n             actual = actual_constr.node.args.(i);\n             alt a.node {\n               carg_base. {\n@@ -2651,7 +2651,7 @@ mod unify {\n                   ures_ok(res_inner) {\n                     let i = 0u;\n                     let res_tps = ~[];\n-                    for ex_tp: t  in ex_tps {\n+                    for ex_tp: t in ex_tps {\n                         let result = unify_step(cx, ex_tp, act_tps.(i));\n                         alt result {\n                           ures_ok(rty) { res_tps += ~[rty]; }\n@@ -3012,11 +3012,11 @@ fn tag_variants(cx: &ctxt, id: &ast::def_id) -> [variant_info] {\n         alt item.node {\n           ast::item_tag(variants, _) {\n             let result: [variant_info] = ~[];\n-            for variant: ast::variant  in variants {\n+            for variant: ast::variant in variants {\n                 let ctor_ty = node_id_to_monotype(cx, variant.node.id);\n                 let arg_tys: [t] = ~[];\n                 if std::ivec::len(variant.node.args) > 0u {\n-                    for a: arg  in ty_fn_args(cx, ctor_ty) {\n+                    for a: arg in ty_fn_args(cx, ctor_ty) {\n                         arg_tys += ~[a.ty];\n                     }\n                 }"}, {"sha": "c2efce8d7b1e0d5cbabbd32f18ceb24d88e2eb88", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -294,7 +294,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         //\n \n         let param_bindings: [ty::t] = ~[];\n-        for ast_ty: @ast::ty  in args {\n+        for ast_ty: @ast::ty in args {\n             param_bindings += ~[ast_ty_to_ty(tcx, getter, ast_ty)];\n         }\n         if ivec::len(param_bindings) !=\n@@ -346,21 +346,21 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n       }\n       ast::ty_rec(fields) {\n         let flds: [field] = ~[];\n-        for f: ast::ty_field  in fields {\n+        for f: ast::ty_field in fields {\n             let tm = ast_mt_to_mt(tcx, getter, f.node.mt);\n             flds += ~[{ident: f.node.ident, mt: tm}];\n         }\n         typ = ty::mk_rec(tcx, flds);\n       }\n       ast::ty_fn(proto, inputs, output, cf, constrs) {\n         let i = ~[];\n-        for ta: ast::ty_arg  in inputs {\n+        for ta: ast::ty_arg in inputs {\n             i += ~[ast_arg_to_arg(tcx, getter, ta)];\n         }\n         let out_ty = ast_ty_to_ty(tcx, getter, output);\n \n         let out_constrs = ~[];\n-        for constr: @ast::constr  in constrs {\n+        for constr: @ast::constr in constrs {\n             out_constrs += ~[ty::ast_constr_to_constr(tcx, constr)];\n         }\n         typ = ty::mk_fn(tcx, proto, i, out_ty, cf, out_constrs);\n@@ -384,15 +384,15 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n       }\n       ast::ty_obj(meths) {\n         let tmeths: [ty::method] = ~[];\n-        for m: ast::ty_method  in meths {\n+        for m: ast::ty_method in meths {\n             let ins = ~[];\n-            for ta: ast::ty_arg  in m.node.inputs {\n+            for ta: ast::ty_arg in m.node.inputs {\n                 ins += ~[ast_arg_to_arg(tcx, getter, ta)];\n             }\n             let out = ast_ty_to_ty(tcx, getter, m.node.output);\n \n             let out_constrs = ~[];\n-            for constr: @ast::constr  in m.node.constrs {\n+            for constr: @ast::constr in m.node.constrs {\n                 out_constrs += ~[ty::ast_constr_to_constr(tcx, constr)];\n             }\n             let new_m: ty::method =\n@@ -408,7 +408,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n       }\n       ast::ty_constr(t, cs) {\n         let out_cs = ~[];\n-        for constr: @ast::ty_constr  in cs {\n+        for constr: @ast::ty_constr in cs {\n             out_cs += ~[ty::ast_constr_to_constr(tcx, constr)];\n         }\n         typ = ty::mk_constr(tcx, ast_ty_to_ty(tcx, getter, t), out_cs);\n@@ -554,11 +554,11 @@ mod collect {\n                      def_id: &option::t[ast::def_id]) ->\n        ty::ty_param_kinds_and_ty {\n         let input_tys = ~[];\n-        for a: ast::arg  in decl.inputs { input_tys += ~[ty_of_arg(a)]; }\n+        for a: ast::arg in decl.inputs { input_tys += ~[ty_of_arg(a)]; }\n         let output_ty = convert(decl.output);\n \n         let out_constrs = ~[];\n-        for constr: @ast::constr  in decl.constraints {\n+        for constr: @ast::constr in decl.constraints {\n             out_constrs += ~[ty::ast_constr_to_constr(cx.tcx, constr)];\n         }\n         let t_fn =\n@@ -574,7 +574,7 @@ mod collect {\n                             ty_params: &[ast::ty_param], def_id: &ast::def_id)\n        -> ty::ty_param_kinds_and_ty {\n         let input_tys = ~[];\n-        for a: ast::arg  in decl.inputs { input_tys += ~[ty_of_arg(a)]; }\n+        for a: ast::arg in decl.inputs { input_tys += ~[ty_of_arg(a)]; }\n         let output_ty = convert(decl.output);\n \n         let t_fn = ty::mk_native_fn(cx.tcx, abi, input_tys, output_ty);\n@@ -619,14 +619,14 @@ mod collect {\n         let convert = bind ast_ty_to_ty(cx.tcx, get, _);\n \n         let inputs = ~[];\n-        for a: ast::arg  in m.node.meth.decl.inputs {\n+        for a: ast::arg in m.node.meth.decl.inputs {\n             inputs += ~[ty_of_arg(cx, a)];\n         }\n \n         let output = convert(m.node.meth.decl.output);\n \n         let out_constrs = ~[];\n-        for constr: @ast::constr  in m.node.meth.decl.constraints {\n+        for constr: @ast::constr in m.node.meth.decl.constraints {\n             out_constrs += ~[ty::ast_constr_to_constr(cx.tcx, constr)];\n         }\n         ret {proto: proto_to_ty_proto(m.node.meth.proto),\n@@ -649,7 +649,7 @@ mod collect {\n         let t_obj = ty_of_obj(cx, id, ob, ty_params);\n \n         let t_inputs: [arg] = ~[];\n-        for f: ast::obj_field  in ob.fields {\n+        for f: ast::obj_field in ob.fields {\n             let g = bind getter(cx, _);\n             let t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n             t_inputs += ~[{mode: ty::mo_alias(false), ty: t_field}];\n@@ -747,7 +747,7 @@ mod collect {\n         // Create a set of parameter types shared among all the variants.\n \n         let ty_param_tys: [ty::t] = mk_ty_params(cx, ty_params);\n-        for variant: ast::variant  in variants {\n+        for variant: ast::variant in variants {\n             // Nullary tag constructors get turned into constants; n-ary tag\n             // constructors get turned into functions.\n \n@@ -760,7 +760,7 @@ mod collect {\n \n                 let f = bind getter(cx, _);\n                 let args: [arg] = ~[];\n-                for va: ast::variant_arg  in variant.node.args {\n+                for va: ast::variant_arg in variant.node.args {\n                     let arg_ty = ast_ty_to_ty(cx.tcx, f, va.ty);\n                     args += ~[{mode: ty::mo_alias(false), ty: arg_ty}];\n                 }\n@@ -777,7 +777,7 @@ mod collect {\n     }\n     fn get_obj_method_types(cx: &@ctxt, object: &ast::_obj) -> [ty::method] {\n         let meths = ~[];\n-        for m: @ast::method  in object.methods {\n+        for m: @ast::method in object.methods {\n             meths += ~[ty_of_method(cx, m)];\n         }\n         ret meths;\n@@ -995,7 +995,7 @@ mod demand {\n \n         let ty_param_substs: [mutable ty::t] = ~[mutable];\n         let ty_param_subst_var_ids: [int] = ~[];\n-        for ty_param_subst: ty::t  in ty_param_substs_0 {\n+        for ty_param_subst: ty::t in ty_param_substs_0 {\n             // Generate a type variable and unify it with the type parameter\n             // substitution. We will then pull out these type variables.\n             let t_0 = next_ty_var(fcx);\n@@ -1008,7 +1008,7 @@ mod demand {\n                      ty_param_subst_var_ids: &[int]) ->\n            ty_param_substs_and_ty {\n             let result_ty_param_substs: [ty::t] = ~[];\n-            for var_id: int  in ty_param_subst_var_ids {\n+            for var_id: int in ty_param_subst_var_ids {\n                 let tp_subst = ty::mk_var(fcx.ccx.tcx, var_id);\n                 result_ty_param_substs += ~[tp_subst];\n             }\n@@ -1055,7 +1055,7 @@ fn variant_arg_types(ccx: &@crate_ctxt, sp: &span, vid: &ast::def_id,\n \n \n         // N-ary variant.\n-        for arg: ty::arg  in ins {\n+        for arg: ty::arg in ins {\n             let arg_ty =\n                 ty::substitute_type_params(ccx.tcx, tag_ty_params, arg.ty);\n             result += ~[arg_ty];\n@@ -1111,7 +1111,7 @@ mod writeback {\n           none[[ty::t]]. { new_substs_opt = none[[ty::t]]; }\n           some[[ty::t]](substs) {\n             let new_substs: [ty::t] = ~[];\n-            for subst: ty::t  in substs {\n+            for subst: ty::t in substs {\n                 alt resolve_type_vars_in_type(fcx, sp, subst) {\n                   some(t) { new_substs += ~[t]; }\n                   none. { wbcx.success = false; ret; }\n@@ -1256,15 +1256,15 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n       }\n       none. {/* no fields */ }\n     }\n-    for f: ast::obj_field  in obj_fields {\n+    for f: ast::obj_field in obj_fields {\n         let field_ty = ty::node_id_to_type(ccx.tcx, f.id);\n         assign(f.id, f.ident, some(field_ty));\n     }\n \n     // Add formal parameters.\n     let args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n     let i = 0u;\n-    for arg: ty::arg  in args {\n+    for arg: ty::arg in args {\n         assign(f.decl.inputs.(i).id, f.decl.inputs.(i).ident, some(arg.ty));\n         i += 1u;\n     }\n@@ -1391,7 +1391,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n                 // TODO: ivec::iter2\n \n                 let i = 0u;\n-                for subpat: @ast::pat  in subpats {\n+                for subpat: @ast::pat in subpats {\n                     check_pat(fcx, map, subpat, arg_types.(i));\n                     i += 1u;\n                 }\n@@ -1442,7 +1442,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n         fn matches(name: &str, f: &ty::field) -> bool {\n             ret str::eq(name, f.ident);\n         }\n-        for f: ast::field_pat  in fields {\n+        for f: ast::field_pat in fields {\n             alt ivec::find(bind matches(f.ident, _), ex_fields) {\n               some(field) { check_pat(fcx, map, f.pat, field.mt.ty); }\n               none. {\n@@ -1619,7 +1619,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         let check_args = lambda(check_blocks: bool) -> bool {\n             let i = 0u;\n             let bot = false;\n-            for a_opt: option::t[@ast::expr]  in args {\n+            for a_opt: option::t[@ast::expr] in args {\n                 alt a_opt {\n                   some(a) {\n                     let is_block =\n@@ -1655,7 +1655,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n     fn check_call(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n                   args: &[@ast::expr], call_kind: call_kind) -> bool {\n         let args_opt_0: [option::t[@ast::expr]] = ~[];\n-        for arg: @ast::expr  in args {\n+        for arg: @ast::expr in args {\n             args_opt_0 += ~[some[@ast::expr](arg)];\n         }\n \n@@ -1727,7 +1727,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n                                        in constraint\");\n                   }\n                 }\n-                for operand: @ast::expr  in operands {\n+                for operand: @ast::expr in operands {\n                     if !ast::is_constraint_arg(operand) {\n                         let s =\n                             \"Constraint args must be \\\n@@ -2048,16 +2048,16 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n         let pattern_ty = ty::expr_ty(tcx, expr);\n-        for arm: ast::arm  in arms {\n+        for arm: ast::arm in arms {\n             let id_map = ast::pat_id_map(arm.pats.(0));\n-            for p: @ast::pat  in arm.pats {\n+            for p: @ast::pat in arm.pats {\n                 check_pat(fcx, id_map, p, pattern_ty);\n             }\n         }\n         // Now typecheck the blocks.\n         let result_ty = next_ty_var(fcx);\n         let arm_non_bot = false;\n-        for arm: ast::arm  in arms {\n+        for arm: ast::arm in arms {\n             if !check_block(fcx, arm.body) { arm_non_bot = true; }\n             let bty = block_ty(tcx, arm.body);\n             result_ty = demand::simple(fcx, arm.body.span, result_ty, bty);\n@@ -2173,7 +2173,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n           some(sty) {\n             alt sty {\n               ty::ty_obj(methods) {\n-                for method: ty::method  in methods {\n+                for method: ty::method in methods {\n                     if method.ident == ident {\n                         t = ty::method_ty_to_fn_ty(tcx, method);\n                     }\n@@ -2251,7 +2251,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n       ast::expr_rec(fields, base) {\n         alt base { none. {/* no-op */ } some(b_0) { check_expr(fcx, b_0); } }\n         let fields_t: [spanned[field]] = ~[];\n-        for f: ast::field  in fields {\n+        for f: ast::field in fields {\n             bot |= check_expr(fcx, f.node.expr);\n             let expr_t = expr_ty(tcx, f.node.expr);\n             let expr_mt = {ty: expr_t, mut: f.node.mut};\n@@ -2279,9 +2279,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n               }\n             }\n             write::ty_only_fixup(fcx, id, bexpr_t);\n-            for f: spanned[ty::field]  in fields_t {\n+            for f: spanned[ty::field] in fields_t {\n                 let found = false;\n-                for bf: ty::field  in base_fields {\n+                for bf: ty::field in base_fields {\n                     if str::eq(f.node.ident, bf.ident) {\n                         demand::simple(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n                         found = true;\n@@ -2384,14 +2384,14 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             let convert = bind ast_ty_to_ty_crate(ccx, _);\n \n             let inputs = ~[];\n-            for aa: ast::arg  in m.node.meth.decl.inputs {\n+            for aa: ast::arg in m.node.meth.decl.inputs {\n                 inputs += ~[ty_of_arg(ccx, aa)];\n             }\n \n             let output = convert(m.node.meth.decl.output);\n \n             let out_constrs = ~[];\n-            for constr: @ast::constr  in m.node.meth.decl.constraints {\n+            for constr: @ast::constr in m.node.meth.decl.constraints {\n                 out_constrs += ~[ty::ast_constr_to_constr(ccx.tcx, constr)];\n             }\n \n@@ -2406,7 +2406,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         let method_types: [ty::method] = ~[];\n         {\n             // Outer methods.\n-            for m: @ast::method  in ao.methods {\n+            for m: @ast::method in ao.methods {\n                 method_types += ~[ty_of_method(fcx.ccx, m)];\n             }\n \n@@ -2495,7 +2495,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         }\n \n         // Typecheck the methods.\n-        for method: @ast::method  in ao.methods {\n+        for method: @ast::method in ao.methods {\n             check_method(fcx.ccx, method);\n         }\n \n@@ -2704,7 +2704,7 @@ fn check_item(ccx: @crate_ctxt, it: &@ast::item) {\n         ccx.obj_infos += ~[regular_obj(ob.fields, it.id)];\n \n         // Typecheck the methods.\n-        for method: @ast::method  in ob.methods { check_method(ccx, method); }\n+        for method: @ast::method in ob.methods { check_method(ccx, method); }\n \n         // Now remove the info from the stack.\n         ivec::pop[obj_info](ccx.obj_infos);"}, {"sha": "ce20360e9ec5b0b5b187f7f5a1c3ce0a811ff0f8", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -618,11 +618,11 @@ tag native_item_ {\n \n fn is_exported(i: ident, m: _mod) -> bool {\n     let nonlocal = true;\n-    for it: @ast::item  in m.items {\n+    for it: @ast::item in m.items {\n         if it.ident == i { nonlocal = false; }\n         alt it.node {\n           item_tag(variants, _) {\n-            for v: variant  in variants {\n+            for v: variant in variants {\n                 if v.node.name == i { nonlocal = false; }\n             }\n           }\n@@ -631,7 +631,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n         if !nonlocal { break; }\n     }\n     let count = 0u;\n-    for vi: @ast::view_item  in m.view_items {\n+    for vi: @ast::view_item in m.view_items {\n         alt vi.node {\n           ast::view_item_export(id, _) {\n             if str::eq(i, id) {"}, {"sha": "7e41865afa45edc210ff990b6805aa7ce866f6a6", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -142,7 +142,7 @@ fn maybe_highlight_lines(sp: &option::t[span], cm: &codemap,\n             elided = true;\n         }\n         // Print the offending lines\n-        for line: uint  in display_lines {\n+        for line: uint in display_lines {\n             io::stdout().write_str(#fmt(\"%s:%u \", fm.name, line + 1u));\n             let s = get_line(fm, line as int, file);\n             if !str::ends_with(s, \"\\n\") { s += \"\\n\"; }\n@@ -203,7 +203,7 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n     let lines = ~[];\n-    for each i: uint  in uint::range(lo.line - 1u, hi.line as uint) {\n+    for each i: uint in uint::range(lo.line - 1u, hi.line as uint) {\n         lines += ~[i];\n     }\n     ret @{name: lo.filename, lines: lines};\n@@ -227,7 +227,7 @@ fn get_line(fm: filemap, line: int, file: &str) -> str {\n }\n \n fn get_filemap(cm: codemap, filename: str) -> filemap {\n-    for fm: filemap  in cm.files { if fm.name == filename { ret fm; } }\n+    for fm: filemap in cm.files { if fm.name == filename { ret fm; } }\n     //XXjdm the following triggers a mismatched type bug\n     //      (or expected function, found _|_)\n     fail; // (\"asking for \" + filename + \" which we don't know about\");"}, {"sha": "cc3d4fef52ee5e6f2fa628e8bc3ca988c7bfe6e2", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -86,7 +86,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                      fields: &[{ident: ast::ident, ex: @ast::expr}]) ->\n        @ast::expr {\n         let astfields: [ast::field] = ~[];\n-        for field: {ident: ast::ident, ex: @ast::expr}  in fields {\n+        for field: {ident: ast::ident, ex: @ast::expr} in fields {\n             let ident = field.ident;\n             let val = field.ex;\n             let astfield =\n@@ -115,7 +115,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n         fn make_flags(cx: &ext_ctxt, sp: span, flags: &[flag]) ->\n            @ast::expr {\n             let flagexprs: [@ast::expr] = ~[];\n-            for f: flag  in flags {\n+            for f: flag in flags {\n                 let fstr;\n                 alt f {\n                   flag_left_justify. { fstr = \"flag_left_justify\"; }\n@@ -205,7 +205,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n           option::none. { }\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n-        for f: flag  in cnv.flags {\n+        for f: flag in cnv.flags {\n             alt f {\n               flag_left_justify. { }\n               flag_sign_always. {\n@@ -259,7 +259,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n           some(p) { log \"param: \" + std::int::to_str(p, 10u); }\n           _ { log \"param: none\"; }\n         }\n-        for f: flag  in c.flags {\n+        for f: flag in c.flags {\n             alt f {\n               flag_left_justify. { log \"flag: left justify\"; }\n               flag_left_zero_pad. { log \"flag: left zero pad\"; }\n@@ -308,7 +308,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     let n = 0u;\n     let tmp_expr = make_new_str(cx, sp, \"\");\n     let nargs = ivec::len[@ast::expr](args);\n-    for pc: piece  in pieces {\n+    for pc: piece in pieces {\n         alt pc {\n           piece_string(s) {\n             let s_expr = make_new_str(cx, fmt_sp, s);"}, {"sha": "543cd8b4644e7916c6bb8593c8066febdb0afe01", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -95,7 +95,7 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n     -> {pre: [@expr], rep: option::t[@expr], post: [@expr]} {\n     let idx: uint = 0u;\n     let res = none;\n-    for elt: @expr  in elts {\n+    for elt: @expr in elts {\n         alt elt.node {\n           expr_mac(m) {\n             alt m.node {\n@@ -124,7 +124,7 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n fn option_flatten_map[T, U](f: &fn(&T) -> option::t[U] , v: &[T]) ->\n    option::t[[U]] {\n     let res = ~[];\n-    for elem: T  in v {\n+    for elem: T in v {\n         alt f(elem) { none. { ret none; } some(fv) { res += ~[fv]; } }\n     }\n     ret some(res);\n@@ -185,11 +185,11 @@ selectors. */\n fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t[bindings] {\n     let res = new_str_hash[arb_depth[matchable]]();\n     //need to do this first, to check vec lengths.\n-    for sel: selector  in b.literal_ast_matchers {\n+    for sel: selector in b.literal_ast_matchers {\n         alt sel(match_expr(e)) { none. { ret none; } _ { } }\n     }\n     let never_mind: bool = false;\n-    for each pair: @{key: ident, val: selector}  in b.real_binders.items() {\n+    for each pair: @{key: ident, val: selector} in b.real_binders.items() {\n         alt pair.val(match_expr(e)) {\n           none. { never_mind = true; }\n           some(mtc) { res.insert(pair.key, mtc); }\n@@ -233,7 +233,7 @@ fn transcribe(cx: &ext_ctxt, b: &bindings, body: @expr) -> @expr {\n fn follow(m: &arb_depth[matchable], idx_path: @mutable [uint]) ->\n    arb_depth[matchable] {\n     let res: arb_depth[matchable] = m;\n-    for idx: uint  in *idx_path {\n+    for idx: uint in *idx_path {\n         alt res {\n           leaf(_) { ret res;/* end of the line */ }\n           seq(new_ms, _) { res = new_ms.(idx); }\n@@ -276,7 +276,7 @@ iter free_vars(b: &bindings, e: @expr) -> ident {\n     let f = make_fold(f_pre);\n     f.fold_expr(e); // ignore result\n     dummy_out(f);\n-    for each id: ident  in idents.keys() { put id; }\n+    for each id: ident in idents.keys() { put id; }\n }\n \n \n@@ -293,7 +293,7 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n             let repeat: option::t[{rep_count: uint, name: ident}] = none;\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n-            for each fv: ident  in free_vars(b, repeat_me) {\n+            for each fv: ident in free_vars(b, repeat_me) {\n                 let cur_pos = follow(b.get(fv), idx_path);\n                 alt cur_pos {\n                   leaf(_) { }\n@@ -686,7 +686,7 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n \n     let macro_name: option::t[str] = none;\n     let clauses: [@clause] = ~[];\n-    for arg: @expr  in args {\n+    for arg: @expr in args {\n         alt arg.node {\n           expr_vec(elts, mut, seq_kind) {\n             if ivec::len(elts) != 2u {"}, {"sha": "944915384ee5fff1402d020239d57424256785cc", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -283,7 +283,7 @@ fn noop_fold_pat(p: &pat_, fld: ast_fold) -> pat_ {\n           }\n           pat_rec(fields, etc) {\n             let fs = ~[];\n-            for f: ast::field_pat  in fields {\n+            for f: ast::field_pat in fields {\n                 fs += ~[{ident: f.ident, pat: fld.fold_pat(f.pat)}];\n             }\n             pat_rec(fs, etc)"}, {"sha": "fb52960517d024a5c77f802f6f0b8f9d317ffad1", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -29,7 +29,7 @@ fn eval_crate_directives(cx: ctx, cdirs: &[@ast::crate_directive],\n                          prefix: str,\n                          view_items: &mutable [@ast::view_item],\n                          items: &mutable [@ast::item]) {\n-    for sub_cdir: @ast::crate_directive  in cdirs {\n+    for sub_cdir: @ast::crate_directive in cdirs {\n         eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n     }\n }"}, {"sha": "edeb6df407bc410c1a37f39d62e75e6652d769d8", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -166,7 +166,7 @@ fn consume_block_comment(rdr: &reader) {\n \n fn digits_to_string(s: str) -> int {\n     let accum_int: int = 0;\n-    for c: u8  in s {\n+    for c: u8 in s {\n         accum_int *= 10;\n         accum_int += dec_digit_val(c as char);\n     }"}, {"sha": "93cdf617a636a2276e4927f8b7d9de05f785689f", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -355,7 +355,7 @@ fn parse_ty_field(p: &parser) -> ast::ty_field {\n // otherwise, fail\n fn ident_index(p: &parser, args: &[ast::arg], i: &ast::ident) -> uint {\n     let j = 0u;\n-    for a: ast::arg  in args { if a.ident == i { ret j; } j += 1u; }\n+    for a: ast::arg in args { if a.ident == i { ret j; } j += 1u; }\n     p.fatal(\"Unbound variable \" + i + \" in constraint arg\");\n }\n \n@@ -1219,7 +1219,7 @@ const ternary_prec: int = 0;\n fn parse_more_binops(p: &parser, lhs: @ast::expr, min_prec: int) ->\n    @ast::expr {\n     let peeked = p.peek();\n-    for cur: op_spec  in *p.get_prec_table() {\n+    for cur: op_spec in *p.get_prec_table() {\n         if cur.prec > min_prec && cur.tok == peeked {\n             p.bump();\n             let rhs = parse_more_binops(p, parse_prefix_expr(p), cur.prec);\n@@ -2123,7 +2123,7 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n                 let arg_tys =\n                     parse_seq(token::LPAREN, token::RPAREN,\n                               some(token::COMMA), bind parse_ty(_, false), p);\n-                for ty: @ast::ty  in arg_tys.node {\n+                for ty: @ast::ty in arg_tys.node {\n                     args += ~[{ty: ty, id: p.get_id()}];\n                 }\n                 vhi = arg_tys.span.hi;"}, {"sha": "e0389c47874cc6060332ee7a1560a680dc7da773", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -218,7 +218,7 @@ fn synth_comment(s: &ps, text: str) {\n fn commasep[IN](s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ) {\n     box(s, 0u, b);\n     let first = true;\n-    for elt: IN  in elts {\n+    for elt: IN in elts {\n         if first { first = false; } else { word_space(s, \",\"); }\n         op(s, elt);\n     }\n@@ -231,7 +231,7 @@ fn commasep_cmnt[IN](s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ,\n     box(s, 0u, b);\n     let len = ivec::len[IN](elts);\n     let i = 0u;\n-    for elt: IN  in elts {\n+    for elt: IN in elts {\n         maybe_print_comment(s, get_span(elt).hi);\n         op(s, elt);\n         i += 1u;\n@@ -252,19 +252,19 @@ fn commasep_exprs(s: &ps, b: breaks, exprs: &[@ast::expr]) {\n \n fn print_mod(s: &ps, _mod: &ast::_mod, attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n-    for vitem: @ast::view_item  in _mod.view_items {\n+    for vitem: @ast::view_item in _mod.view_items {\n         print_view_item(s, vitem);\n     }\n-    for item: @ast::item  in _mod.items { print_item(s, item); }\n+    for item: @ast::item in _mod.items { print_item(s, item); }\n }\n \n fn print_native_mod(s: &ps, nmod: &ast::native_mod,\n                     attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n-    for vitem: @ast::view_item  in nmod.view_items {\n+    for vitem: @ast::view_item in nmod.view_items {\n         print_view_item(s, vitem);\n     }\n-    for item: @ast::native_item  in nmod.items { print_native_item(s, item); }\n+    for item: @ast::native_item in nmod.items { print_native_item(s, item); }\n }\n \n fn print_type(s: &ps, ty: &@ast::ty) {\n@@ -330,7 +330,7 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n       ast::ty_obj(methods) {\n         head(s, \"obj\");\n         bopen(s);\n-        for m: ast::ty_method  in methods {\n+        for m: ast::ty_method in methods {\n             hardbreak_if_not_bol(s);\n             cbox(s, indent_unit);\n             maybe_print_comment(s, m.span.lo);\n@@ -471,7 +471,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n             end(s);\n         } else {\n             bopen(s);\n-            for v: ast::variant  in variants {\n+            for v: ast::variant in variants {\n                 space(s.s);\n                 maybe_print_comment(s, v.span.lo);\n                 word(s.s, v.node.name);\n@@ -506,7 +506,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n         pclose(s);\n         space(s.s);\n         bopen(s);\n-        for meth: @ast::method  in _obj.methods {\n+        for meth: @ast::method in _obj.methods {\n             let typarams: [ast::ty_param] = ~[];\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, meth.span.lo);\n@@ -534,7 +534,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n \n fn print_outer_attributes(s: &ps, attrs: &[ast::attribute]) {\n     let count = 0;\n-    for attr: ast::attribute  in attrs {\n+    for attr: ast::attribute in attrs {\n         alt attr.node.style {\n           ast::attr_outer. { print_attribute(s, attr); count += 1; }\n           _ {/* fallthrough */ }\n@@ -545,7 +545,7 @@ fn print_outer_attributes(s: &ps, attrs: &[ast::attribute]) {\n \n fn print_inner_attributes(s: &ps, attrs: &[ast::attribute]) {\n     let count = 0;\n-    for attr: ast::attribute  in attrs {\n+    for attr: ast::attribute in attrs {\n         alt attr.node.style {\n           ast::attr_inner. {\n             print_attribute(s, attr);\n@@ -594,7 +594,7 @@ fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n     }\n \n     let last_stmt = option::none;\n-    for st: @ast::stmt  in blk.node.stmts {\n+    for st: @ast::stmt in blk.node.stmts {\n         maybe_protect_unop(s, last_stmt, stmt_(st));\n         print_stmt(s, *st);\n         last_stmt = option::some(st);\n@@ -856,12 +856,12 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         print_expr(s, expr);\n         space(s.s);\n         bopen(s);\n-        for arm: ast::arm  in arms {\n+        for arm: ast::arm in arms {\n             space(s.s);\n             cbox(s, alt_indent_unit);\n             ibox(s, 0u);\n             let first = true;\n-            for p: @ast::pat  in arm.pats {\n+            for p: @ast::pat in arm.pats {\n                 if first {\n                     first = false;\n                 } else { space(s.s); word_space(s, \"|\"); }\n@@ -1126,7 +1126,7 @@ fn print_path(s: &ps, path: &ast::path) {\n     maybe_print_comment(s, path.span.lo);\n     if path.node.global { word(s.s, \"::\"); }\n     let first = true;\n-    for id: str  in path.node.idents {\n+    for id: str in path.node.idents {\n         if first { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, id);\n     }\n@@ -1293,15 +1293,15 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n             word_space(s, \"=\");\n         }\n         let first = true;\n-        for elt: str  in ids {\n+        for elt: str in ids {\n             if first { first = false; } else { word(s.s, \"::\"); }\n             word(s.s, elt);\n         }\n       }\n       ast::view_item_import_glob(ids, _) {\n         head(s, \"import\");\n         let first = true;\n-        for elt: str  in ids {\n+        for elt: str in ids {\n             if first { first = false; } else { word(s.s, \"::\"); }\n             word(s.s, elt);\n         }\n@@ -1320,7 +1320,7 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n // FIXME: The fact that this builds up the table anew for every call is\n // not good. Eventually, table should be a const.\n fn operator_prec(op: ast::binop) -> int {\n-    for spec: parse::parser::op_spec  in *parse::parser::prec_table() {\n+    for spec: parse::parser::op_spec in *parse::parser::prec_table() {\n         if spec.op == op { ret spec.prec; }\n     }\n     fail;\n@@ -1497,7 +1497,7 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n       }\n       lexer::isolated. {\n         pprust::hardbreak_if_not_bol(s);\n-        for line: str  in cmnt.lines { word(s.s, line); hardbreak(s.s); }\n+        for line: str in cmnt.lines { word(s.s, line); hardbreak(s.s); }\n       }\n       lexer::trailing. {\n         word(s.s, \" \");\n@@ -1506,7 +1506,7 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n             hardbreak(s.s);\n         } else {\n             ibox(s, 0u);\n-            for line: str  in cmnt.lines { word(s.s, line); hardbreak(s.s); }\n+            for line: str in cmnt.lines { word(s.s, line); hardbreak(s.s); }\n             end(s);\n         }\n       }\n@@ -1571,7 +1571,7 @@ fn constr_args_to_str[T](f: &fn(&T) -> str ,\n                          args: &[@ast::sp_constr_arg[T]]) -> str {\n     let comma = false;\n     let s = \"(\";\n-    for a: @ast::sp_constr_arg[T]  in args {\n+    for a: @ast::sp_constr_arg[T] in args {\n         if comma { s += \", \"; } else { comma = true; }\n         s += constr_arg_to_str[T](f, a.node);\n     }\n@@ -1602,7 +1602,7 @@ fn ast_ty_fn_constr_to_str(c: &@ast::constr) -> str {\n fn ast_ty_fn_constrs_str(constrs: &[@ast::constr]) -> str {\n     let s = \"\";\n     let colon = true;\n-    for c: @ast::constr  in constrs {\n+    for c: @ast::constr in constrs {\n         if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += ast_ty_fn_constr_to_str(c);\n     }\n@@ -1624,7 +1624,7 @@ fn ast_fn_constrs_str(decl: &ast::fn_decl,\n                       constrs: &[@ast::constr]) -> str {\n     let s = \"\";\n     let colon = true;\n-    for c: @ast::constr  in constrs {\n+    for c: @ast::constr in constrs {\n         if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += ast_fn_constr_to_str(decl, c);\n     }\n@@ -1649,7 +1649,7 @@ fn ty_constr_to_str(c: &@ast::ty_constr) -> str {\n fn ast_ty_constrs_str(constrs: &[@ast::ty_constr]) -> str {\n     let s = \"\";\n     let colon = true;\n-    for c: @ast::ty_constr  in constrs {\n+    for c: @ast::ty_constr in constrs {\n         if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += ty_constr_to_str(c);\n     }"}, {"sha": "c4f6395c72f03e264eb47b13dacf560a0488f98b", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -60,7 +60,7 @@ fn visit_crate_directive[E](cd: &@crate_directive, e: &E, v: &vt[E]) {\n     alt cd.node {\n       cdir_src_mod(_, _, _) { }\n       cdir_dir_mod(_, _, cdirs, _) {\n-        for cdir: @crate_directive  in cdirs {\n+        for cdir: @crate_directive in cdirs {\n             visit_crate_directive(cdir, e, v);\n         }\n       }\n@@ -71,8 +71,8 @@ fn visit_crate_directive[E](cd: &@crate_directive, e: &E, v: &vt[E]) {\n }\n \n fn visit_mod[E](m: &_mod, sp: &span, e: &E, v: &vt[E]) {\n-    for vi: @view_item  in m.view_items { v.visit_view_item(vi, e, v); }\n-    for i: @item  in m.items { v.visit_item(i, e, v); }\n+    for vi: @view_item in m.view_items { v.visit_view_item(vi, e, v); }\n+    for i: @item in m.items { v.visit_item(i, e, v); }\n }\n \n fn visit_view_item[E](vi: &@view_item, e: &E, v: &vt[E]) { }\n@@ -89,21 +89,21 @@ fn visit_item[E](i: &@item, e: &E, v: &vt[E]) {\n       item_fn(f, tp) { v.visit_fn(f, tp, i.span, some(i.ident), i.id, e, v); }\n       item_mod(m) { v.visit_mod(m, i.span, e, v); }\n       item_native_mod(nm) {\n-        for vi: @view_item  in nm.view_items { v.visit_view_item(vi, e, v); }\n-        for ni: @native_item  in nm.items { v.visit_native_item(ni, e, v); }\n+        for vi: @view_item in nm.view_items { v.visit_view_item(vi, e, v); }\n+        for ni: @native_item in nm.items { v.visit_native_item(ni, e, v); }\n       }\n       item_ty(t, _) { v.visit_ty(t, e, v); }\n       item_res(f, dtor_id, tps, _) {\n         v.visit_fn(f, tps, i.span, some(i.ident), dtor_id, e, v);\n       }\n       item_tag(variants, _) {\n-        for vr: variant  in variants {\n-            for va: variant_arg  in vr.node.args { v.visit_ty(va.ty, e, v); }\n+        for vr: variant in variants {\n+            for va: variant_arg in vr.node.args { v.visit_ty(va.ty, e, v); }\n         }\n       }\n       item_obj(ob, _, _) {\n-        for f: obj_field  in ob.fields { v.visit_ty(f.ty, e, v); }\n-        for m: @method  in ob.methods {\n+        for f: obj_field in ob.fields { v.visit_ty(f.ty, e, v); }\n+        for m: @method in ob.methods {\n             v.visit_fn(m.node.meth, ~[], m.span, some(m.node.ident),\n                        m.node.id, e, v);\n         }\n@@ -131,29 +131,29 @@ fn visit_ty[E](t: &@ty, e: &E, v: &vt[E]) {\n       ty_chan(t) { v.visit_ty(t, e, v); }\n       ty_task. {/* no-op */ }\n       ty_rec(flds) {\n-        for f: ty_field  in flds { v.visit_ty(f.node.mt.ty, e, v); }\n+        for f: ty_field in flds { v.visit_ty(f.node.mt.ty, e, v); }\n       }\n       ty_tup(ts) {\n         for tt in ts { v.visit_ty(tt, e, v); }\n       }\n       ty_fn(_, args, out, _, constrs) {\n-        for a: ty_arg  in args { v.visit_ty(a.node.ty, e, v); }\n-        for c: @constr  in constrs {\n+        for a: ty_arg in args { v.visit_ty(a.node.ty, e, v); }\n+        for c: @constr in constrs {\n             v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n         }\n         v.visit_ty(out, e, v);\n       }\n       ty_obj(tmeths) {\n-        for m: ty_method  in tmeths {\n-            for a: ty_arg  in m.node.inputs { v.visit_ty(a.node.ty, e, v); }\n+        for m: ty_method in tmeths {\n+            for a: ty_arg in m.node.inputs { v.visit_ty(a.node.ty, e, v); }\n             v.visit_ty(m.node.output, e, v);\n         }\n       }\n-      ty_path(p, _) { for tp: @ty  in p.node.types { v.visit_ty(tp, e, v); } }\n+      ty_path(p, _) { for tp: @ty in p.node.types { v.visit_ty(tp, e, v); } }\n       ty_type. {/* no-op */ }\n       ty_constr(t, cs) {\n         v.visit_ty(t, e, v);\n-        for tc: @spanned[constr_general_[path, node_id]]  in cs {\n+        for tc: @spanned[constr_general_[path, node_id]] in cs {\n             v.visit_constr(tc.node.path, tc.span, tc.node.id, e, v);\n         }\n       }\n@@ -169,11 +169,11 @@ fn visit_constr[E](operator: &path, sp: &span, id: node_id, e: &E,\n fn visit_pat[E](p: &@pat, e: &E, v: &vt[E]) {\n     alt p.node {\n       pat_tag(path, children) {\n-        for tp: @ty  in path.node.types { v.visit_ty(tp, e, v); }\n-        for child: @pat  in children { v.visit_pat(child, e, v); }\n+        for tp: @ty in path.node.types { v.visit_ty(tp, e, v); }\n+        for child: @pat in children { v.visit_pat(child, e, v); }\n       }\n       pat_rec(fields, _) {\n-        for f: field_pat  in fields { v.visit_pat(f.pat, e, v); }\n+        for f: field_pat in fields { v.visit_pat(f.pat, e, v); }\n       }\n       pat_tup(elts) {\n         for elt in elts { v.visit_pat(elt, e, v); }\n@@ -191,8 +191,8 @@ fn visit_native_item[E](ni: &@native_item, e: &E, v: &vt[E]) {\n }\n \n fn visit_fn_decl[E](fd: &fn_decl, e: &E, v: &vt[E]) {\n-    for a: arg  in fd.inputs { v.visit_ty(a.ty, e, v); }\n-    for c: @constr  in fd.constraints {\n+    for a: arg in fd.inputs { v.visit_ty(a.ty, e, v); }\n+    for c: @constr in fd.constraints {\n         v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n     }\n     v.visit_ty(fd.output, e, v);\n@@ -205,7 +205,7 @@ fn visit_fn[E](f: &_fn, tp: &[ty_param], sp: &span, i: &fn_ident, id: node_id,\n }\n \n fn visit_block[E](b: &ast::blk, e: &E, v: &vt[E]) {\n-    for s: @stmt  in b.node.stmts { v.visit_stmt(s, e, v); }\n+    for s: @stmt in b.node.stmts { v.visit_stmt(s, e, v); }\n     visit_expr_opt(b.node.expr, e, v);\n }\n \n@@ -220,7 +220,7 @@ fn visit_stmt[E](s: &@stmt, e: &E, v: &vt[E]) {\n fn visit_decl[E](d: &@decl, e: &E, v: &vt[E]) {\n     alt d.node {\n       decl_local(locs) {\n-        for loc: @ast::local  in locs { v.visit_local(loc, e, v); }\n+        for loc: @ast::local in locs { v.visit_local(loc, e, v); }\n       }\n       decl_item(it) { v.visit_item(it, e, v); }\n     }\n@@ -231,7 +231,7 @@ fn visit_expr_opt[E](eo: option::t[@expr], e: &E, v: &vt[E]) {\n }\n \n fn visit_exprs[E](exprs: &[@expr], e: &E, v: &vt[E]) {\n-    for ex: @expr  in exprs { v.visit_expr(ex, e, v); }\n+    for ex: @expr in exprs { v.visit_expr(ex, e, v); }\n }\n \n fn visit_mac[E](m: mac, e: &E, v: &vt[E]) {\n@@ -247,7 +247,7 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n     alt ex.node {\n       expr_vec(es, _, _) { visit_exprs(es, e, v); }\n       expr_rec(flds, base) {\n-        for f: field  in flds { v.visit_expr(f.node.expr, e, v); }\n+        for f: field in flds { v.visit_expr(f.node.expr, e, v); }\n         visit_expr_opt(base, e, v);\n       }\n       expr_tup(elts) {\n@@ -260,7 +260,7 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n       expr_self_method(_) { }\n       expr_bind(callee, args) {\n         v.visit_expr(callee, e, v);\n-        for eo: option::t[@expr]  in args { visit_expr_opt(eo, e, v); }\n+        for eo: option::t[@expr] in args { visit_expr_opt(eo, e, v); }\n       }\n       expr_spawn(_, _, callee, args) {\n         v.visit_expr(callee, e, v);\n@@ -294,7 +294,7 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n       expr_do_while(b, x) { v.visit_block(b, e, v); v.visit_expr(x, e, v); }\n       expr_alt(x, arms) {\n         v.visit_expr(x, e, v);\n-        for a: arm  in arms { v.visit_arm(a, e, v); }\n+        for a: arm in arms { v.visit_arm(a, e, v); }\n       }\n       expr_fn(f) { v.visit_fn(f, ~[], ex.span, none, ex.id, e, v); }\n       expr_block(b) { v.visit_block(b, e, v); }\n@@ -310,7 +310,7 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n       expr_recv(a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_field(x, _) { v.visit_expr(x, e, v); }\n       expr_index(a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n-      expr_path(p) { for tp: @ty  in p.node.types { v.visit_ty(tp, e, v); } }\n+      expr_path(p) { for tp: @ty in p.node.types { v.visit_ty(tp, e, v); } }\n       expr_fail(eo) { visit_expr_opt(eo, e, v); }\n       expr_break. { }\n       expr_cont. { }\n@@ -326,7 +326,7 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n         alt anon_obj.fields {\n           none. { }\n           some(fields) {\n-            for f: anon_obj_field  in fields {\n+            for f: anon_obj_field in fields {\n                 v.visit_ty(f.ty, e, v);\n                 v.visit_expr(f.expr, e, v);\n             }\n@@ -336,7 +336,7 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n           none. { }\n           some(ex) { v.visit_expr(ex, e, v); }\n         }\n-        for m: @method  in anon_obj.methods {\n+        for m: @method in anon_obj.methods {\n             v.visit_fn(m.node.meth, ~[], m.span, some(m.node.ident),\n                        m.node.id, e, v);\n         }\n@@ -347,7 +347,7 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n }\n \n fn visit_arm[E](a: &arm, e: &E, v: &vt[E]) {\n-    for p: @pat  in a.pats { v.visit_pat(p, e, v); }\n+    for p: @pat in a.pats { v.visit_pat(p, e, v); }\n     v.visit_block(a.body, e, v);\n }\n "}, {"sha": "fe6fc00ae6f954d61085b1ac89c71369e7caf6ef", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -51,7 +51,7 @@ fn field_expr(f: &ast::field) -> @ast::expr { ret f.node.expr; }\n \n fn field_exprs(fields: &[ast::field]) -> [@ast::expr] {\n     let es = ~[];\n-    for f: ast::field  in fields { es += ~[f.node.expr]; }\n+    for f: ast::field in fields { es += ~[f.node.expr]; }\n     ret es;\n }\n "}, {"sha": "faa9195b35bdc60eaf290dd27a1f402ec6d093d4", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -48,7 +48,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n         alt ident { some(i) { s += \" \"; s += i; } _ { } }\n         s += \"(\";\n         let strs = ~[];\n-        for a: arg  in inputs { strs += ~[fn_input_to_str(cx, a)]; }\n+        for a: arg in inputs { strs += ~[fn_input_to_str(cx, a)]; }\n         s += str::connect(strs, \", \");\n         s += \")\";\n         if struct(cx, output) != ty_nil {\n@@ -100,7 +100,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n       ty_task. { s += \"task\"; }\n       ty_rec(elems) {\n         let strs: [str] = ~[];\n-        for fld: field  in elems { strs += ~[field_to_str(cx, fld)]; }\n+        for fld: field in elems { strs += ~[field_to_str(cx, fld)]; }\n         s += \"{\" + str::connect(strs, \",\") + \"}\";\n       }\n       ty_tup(elems) {\n@@ -114,7 +114,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n         s += \"<tag#\" + int::str(id.crate) + \":\" + int::str(id.node) + \">\";\n         if ivec::len[t](tps) > 0u {\n             let strs: [str] = ~[];\n-            for typ: t  in tps { strs += ~[ty_to_str(cx, typ)]; }\n+            for typ: t in tps { strs += ~[ty_to_str(cx, typ)]; }\n             s += \"[\" + str::connect(strs, \",\") + \"]\";\n         }\n       }\n@@ -128,7 +128,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n       }\n       ty_obj(meths) {\n         let strs = ~[];\n-        for m: method  in meths { strs += ~[method_to_str(cx, m)]; }\n+        for m: method in meths { strs += ~[method_to_str(cx, m)]; }\n         s += \"obj {\\n\\t\" + str::connect(strs, \"\\n\\t\") + \"\\n}\";\n       }\n       ty_res(id, _, _) {\n@@ -158,7 +158,7 @@ fn constr_to_str(c: &@constr) -> str {\n fn constrs_str(constrs: &[@constr]) -> str {\n     let s = \"\";\n     let colon = true;\n-    for c: @constr  in constrs {\n+    for c: @constr in constrs {\n         if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += constr_to_str(c);\n     }"}, {"sha": "e4140898b9df7d9d315e7b139ee6c8ff70938c45", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -65,17 +65,17 @@ fn vec_edits[T](v: &[T], xs: &[T]) -> [[T]] {\n \n     }\n \n-    for each i: uint  in ix(0u, 1u, Lv) { edits += ~[vec_omit(v, i)]; }\n-    for each i: uint  in ix(0u, 1u, Lv) { edits += ~[vec_dup(v, i)]; }\n-    for each i: uint  in ix(0u, 2u, Lv) { edits += ~[vec_swadj(v, i)]; }\n-    for each i: uint  in ix(1u, 2u, Lv) { edits += ~[vec_prefix(v, i)]; }\n-    for each i: uint  in ix(2u, 1u, Lv) { edits += ~[vec_suffix(v, i)]; }\n-\n-    for each j: uint  in ix(0u, 1u, len(xs)) {\n-        for each i: uint  in ix(0u, 1u, Lv) {\n+    for each i: uint in ix(0u, 1u, Lv) { edits += ~[vec_omit(v, i)]; }\n+    for each i: uint in ix(0u, 1u, Lv) { edits += ~[vec_dup(v, i)]; }\n+    for each i: uint in ix(0u, 2u, Lv) { edits += ~[vec_swadj(v, i)]; }\n+    for each i: uint in ix(1u, 2u, Lv) { edits += ~[vec_prefix(v, i)]; }\n+    for each i: uint in ix(2u, 1u, Lv) { edits += ~[vec_suffix(v, i)]; }\n+\n+    for each j: uint in ix(0u, 1u, len(xs)) {\n+        for each i: uint in ix(0u, 1u, Lv) {\n             edits += ~[vec_poke(v, i, xs.(j))];\n         }\n-        for each i: uint  in ix(0u, 0u, Lv) {\n+        for each i: uint in ix(0u, 0u, Lv) {\n             edits += ~[vec_insert(v, i, xs.(j))];\n         }\n     }\n@@ -99,7 +99,7 @@ fn vec_to_str(v: &[int]) -> str {\n fn show_edits(a: &[int], xs: &[int]) {\n     log_err \"=== Edits of \" + vec_to_str(a) + \" ===\";\n     let b = vec_edits(a, xs);\n-    for each i: uint  in ix(0u, 1u, len(b)) { log_err vec_to_str(b.(i)); }\n+    for each i: uint in ix(0u, 1u, len(b)) { log_err vec_to_str(b.(i)); }\n }\n \n fn demo_edits() {"}, {"sha": "64932c17cc4cebb12658874eb44b018c39081262", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -41,7 +41,7 @@ fn process(op: &block(uint, uint) -> uint , v0: &t, v1: &t) -> bool {\n     assert (ivec::len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);\n     let changed = false;\n-    for each i: uint  in uint::range(0u, len) {\n+    for each i: uint in uint::range(0u, len) {\n         let w0 = v0.storage.(i);\n         let w1 = v1.storage.(i);\n         let w = op(w0, w1);\n@@ -71,7 +71,7 @@ fn assign(v0: &t, v1: t) -> bool {\n fn clone(v: t) -> t {\n     let storage = ivec::init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n     let len = ivec::len(v.storage);\n-    for each i: uint  in uint::range(0u, len) { storage.(i) = v.storage.(i); }\n+    for each i: uint in uint::range(0u, len) { storage.(i) = v.storage.(i); }\n     ret @{storage: storage, nbits: v.nbits};\n }\n \n@@ -98,17 +98,17 @@ fn equal(v0: &t, v1: &t) -> bool {\n }\n \n fn clear(v: &t) {\n-    for each i: uint  in uint::range(0u, ivec::len(v.storage)) {\n+    for each i: uint in uint::range(0u, ivec::len(v.storage)) {\n         v.storage.(i) = 0u;\n     }\n }\n \n fn set_all(v: &t) {\n-    for each i: uint  in uint::range(0u, v.nbits) { set(v, i, true); }\n+    for each i: uint in uint::range(0u, v.nbits) { set(v, i, true); }\n }\n \n fn invert(v: &t) {\n-    for each i: uint  in uint::range(0u, ivec::len(v.storage)) {\n+    for each i: uint in uint::range(0u, ivec::len(v.storage)) {\n         v.storage.(i) = !v.storage.(i);\n     }\n }\n@@ -135,14 +135,14 @@ fn set(v: &t, i: uint, x: bool) {\n \n /* true if all bits are 1 */\n fn is_true(v: &t) -> bool {\n-    for i: uint  in to_ivec(v) { if i != 1u { ret false; } }\n+    for i: uint in to_ivec(v) { if i != 1u { ret false; } }\n     ret true;\n }\n \n \n /* true if all bits are non-1 */\n fn is_false(v: &t) -> bool {\n-    for i: uint  in to_ivec(v) { if i == 1u { ret false; } }\n+    for i: uint in to_ivec(v) { if i == 1u { ret false; } }\n     ret true;\n }\n \n@@ -155,7 +155,7 @@ fn to_ivec(v: &t) -> [uint] {\n \n fn to_str(v: &t) -> str {\n     let rs = \"\";\n-    for i: uint  in to_ivec(v) {\n+    for i: uint in to_ivec(v) {\n         if i == 1u { rs += \"1\"; } else { rs += \"0\"; }\n     }\n     ret rs;"}, {"sha": "018eee24dc639e268c631885bd1cdc0498379030", "filename": "src/lib/either.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -12,15 +12,15 @@ fn either[T, U, V](f_left: &block(&T) -> V, f_right: &block(&U) -> V,\n \n fn lefts[T, U](eithers: &[t[T, U]]) -> [T] {\n     let result: [T] = ~[];\n-    for elt: t[T, U]  in eithers {\n+    for elt: t[T, U] in eithers {\n         alt elt { left(l) { result += ~[l] } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n fn rights[T, U](eithers: &[t[T, U]]) -> [U] {\n     let result: [U] = ~[];\n-    for elt: t[T, U]  in eithers {\n+    for elt: t[T, U] in eithers {\n         alt elt { right(r) { result += ~[r] } _ {/* fallthrough */ } }\n     }\n     ret result;\n@@ -29,7 +29,7 @@ fn rights[T, U](eithers: &[t[T, U]]) -> [U] {\n fn partition[T, U](eithers: &[t[T, U]]) -> {lefts: [T], rights: [U]} {\n     let lefts: [T] = ~[];\n     let rights: [U] = ~[];\n-    for elt: t[T, U]  in eithers {\n+    for elt: t[T, U] in eithers {\n         alt elt { left(l) { lefts += ~[l] } right(r) { rights += ~[r] } }\n     }\n     ret {lefts: lefts, rights: rights};"}, {"sha": "13cfda6e190006a8243465e843779e070f4f57fd", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -440,7 +440,7 @@ mod rt {\n         ret padstr + s;\n     }\n     fn have_flag(flags: &[flag], f: flag) -> bool {\n-        for candidate: flag  in flags { if candidate == f { ret true; } }\n+        for candidate: flag in flags { if candidate == f { ret true; } }\n         ret false;\n     }\n }"}, {"sha": "e3eb47802b628914096674c05c379fcc81b93d4a", "filename": "src/lib/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -48,7 +48,7 @@ fn list_dir(p: path) -> [str] {\n     let pl = str::byte_len(p);\n     if pl == 0u || p.(pl - 1u) as char != os_fs::path_sep { p += path_sep(); }\n     let full_paths: [str] = ~[];\n-    for filename: str  in os_fs::list_dir(p) {\n+    for filename: str in os_fs::list_dir(p) {\n         if !str::eq(filename, \".\") {\n             if !str::eq(filename, \"..\") { full_paths += ~[p + filename]; }\n         }"}, {"sha": "68e1b40edc37edb1596b019e1c67ab4b22db485b", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -146,7 +146,7 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n                 }\n             }\n             let name_pos = 0u;\n-            for nm: name  in names {\n+            for nm: name in names {\n                 name_pos += 1u;\n                 let optid;\n                 alt find_opt(opts, nm) {\n@@ -218,7 +218,7 @@ fn opt_str(m: &match, nm: str) -> str {\n \n fn opt_strs(m: &match, nm: str) -> [str] {\n     let acc: [str] = ~[];\n-    for v: optval  in opt_vals(m, nm) {\n+    for v: optval in opt_vals(m, nm) {\n         alt v { val(s) { acc += ~[s]; } _ { } }\n     }\n     ret acc;"}, {"sha": "8349b67712eb921e1e83c0ced6991147c23bc7b3", "filename": "src/lib/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -291,7 +291,7 @@ obj fd_buf_writer(fd: int, res: option::t[@fd_res]) {\n fn file_buf_writer(path: str, flags: &[fileflag]) -> buf_writer {\n     let fflags: int =\n         os::libc_constants::O_WRONLY() | os::libc_constants::O_BINARY();\n-    for f: fileflag  in flags {\n+    for f: fileflag in flags {\n         alt f {\n           append. { fflags |= os::libc_constants::O_APPEND(); }\n           create. { fflags |= os::libc_constants::O_CREAT(); }\n@@ -402,7 +402,7 @@ obj byte_buf_writer(buf: mutable_byte_buf) {\n         // Fast path.\n \n         if buf.pos == ivec::len(buf.buf) {\n-            for b: u8  in v { buf.buf += ~[mutable b]; }\n+            for b: u8 in v { buf.buf += ~[mutable b]; }\n             buf.pos += ivec::len[u8](v);\n             ret;\n         }"}, {"sha": "d8285b74ad128676a7355c6fb7372e4a41a13118", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -74,13 +74,13 @@ fn init_elt_mut[@T](t: &T, n_elts: uint) -> [mutable T] {\n \n fn to_mut[@T](v: &[T]) -> [mutable T] {\n     let vres = ~[mutable];\n-    for t: T  in v { vres += ~[mutable t]; }\n+    for t: T in v { vres += ~[mutable t]; }\n     ret vres;\n }\n \n fn from_mut[@T](v: &[mutable T]) -> [T] {\n     let vres = ~[];\n-    for t: T  in v { vres += ~[t]; }\n+    for t: T in v { vres += ~[t]; }\n     ret vres;\n }\n \n@@ -193,7 +193,7 @@ fn grow_set[@T](v: &mutable [mutable T], index: uint, initval: &T, val: &T) {\n fn map[@T, @U](f: &block(&T) -> U , v: &[mutable? T]) -> [U] {\n     let result = ~[];\n     reserve(result, len(v));\n-    for elem: T  in v {\n+    for elem: T in v {\n         let elem2 = elem; // satisfies alias checker\n         result += ~[f(elem2)];\n     }\n@@ -213,7 +213,7 @@ fn map2[@T, @U, @V](f: &block(&T, &U) -> V, v0: &[T], v1: &[U])\n fn filter_map[@T, @U](f: &block(&T) -> option::t[U],\n                       v: &[mutable? T]) -> [U] {\n     let result = ~[];\n-    for elem: T  in v {\n+    for elem: T in v {\n         let elem2 = elem; // satisfies alias checker\n         alt f(elem2) {\n           none. {/* no-op */ }\n@@ -232,28 +232,28 @@ fn foldl[@T, @U](p: &block(&U, &T) -> U , z: &U, v: &[mutable? T]) -> U {\n }\n \n fn any[T](f: &block(&T) -> bool , v: &[T]) -> bool {\n-    for elem: T  in v { if f(elem) { ret true; } }\n+    for elem: T in v { if f(elem) { ret true; } }\n     ret false;\n }\n \n fn all[T](f: &block(&T) -> bool , v: &[T]) -> bool {\n-    for elem: T  in v { if !f(elem) { ret false; } }\n+    for elem: T in v { if !f(elem) { ret false; } }\n     ret true;\n }\n \n fn member[T](x: &T, v: &[T]) -> bool {\n-    for elt: T  in v { if x == elt { ret true; } }\n+    for elt: T in v { if x == elt { ret true; } }\n     ret false;\n }\n \n fn count[T](x: &T, v: &[mutable? T]) -> uint {\n     let cnt = 0u;\n-    for elt: T  in v { if x == elt { cnt += 1u; } }\n+    for elt: T in v { if x == elt { cnt += 1u; } }\n     ret cnt;\n }\n \n fn find[@T](f: &block(&T) -> bool , v: &[T]) -> option::t[T] {\n-    for elt: T  in v { if f(elt) { ret some(elt); } }\n+    for elt: T in v { if f(elt) { ret some(elt); } }\n     ret none;\n }\n "}, {"sha": "1ef84ee79e707ed37a7190a190da7df36eb8fc7e", "filename": "src/lib/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -9,7 +9,7 @@ fn from_vec[@T](v: &[T]) -> list[T] {\n     // a reverse vector iterator. Unfortunately generic iterators seem not to\n     // work yet.\n \n-    for item: T  in ivec::reversed(v) { l = cons[T](item, @l); }\n+    for item: T in ivec::reversed(v) { l = cons[T](item, @l); }\n     ret l;\n }\n "}, {"sha": "6431d4a4d4203bff3162420bf424e5a9965b9095", "filename": "src/lib/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -100,7 +100,7 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n     fn rehash[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K],\n                       oldbkts: &[mutable bucket[K, V]], noldbkts: uint,\n                       newbkts: &[mutable bucket[K, V]], nnewbkts: uint) {\n-        for b: bucket[K, V]  in oldbkts {\n+        for b: bucket[K, V] in oldbkts {\n             alt b {\n               some(k_, v_) {\n                 let k = k_;\n@@ -177,12 +177,12 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n             bkts = newbkts;\n         }\n         iter items() -> @{key: K, val: V} {\n-            for b: bucket[K, V]  in bkts {\n+            for b: bucket[K, V] in bkts {\n                 alt b { some(k, v) { put @{key: k, val: v}; } _ { } }\n             }\n         }\n         iter keys() -> K {\n-            for b: bucket[K, V]  in bkts {\n+            for b: bucket[K, V] in bkts {\n                 alt b { some(k, _) { put k; } _ { } }\n             }\n         }"}, {"sha": "c2ee4d72cd0df230cc89423e95695b5533f368d7", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -14,7 +14,7 @@ native \"rust\" mod rustrt {\n \n fn arg_vec(prog: str, args: &[str]) -> [sbuf] {\n     let argptrs = ~[str::buf(prog)];\n-    for arg: str  in args { argptrs += ~[str::buf(arg)]; }\n+    for arg: str in args { argptrs += ~[str::buf(arg)]; }\n     argptrs += ~[0 as sbuf];\n     ret argptrs;\n }"}, {"sha": "9b54ecdaea086b912f514313a1bbec5879b5cbd6", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -64,7 +64,7 @@ fn mk_sha1() -> sha1 {\n         // FIXME: Should be typestate precondition\n \n         assert (!st.computed);\n-        for element: u8  in msg {\n+        for element: u8 in msg {\n             st.msg_block.(st.msg_block_idx) = element;\n             st.msg_block_idx += 1u;\n             st.len_low += 8u32;\n@@ -165,7 +165,7 @@ fn mk_sha1() -> sha1 {\n     fn mk_result(st: &sha1state) -> [u8] {\n         if !st.computed { pad_msg(st); st.computed = true; }\n         let rs: [u8] = ~[];\n-        for hpart: u32  in st.h {\n+        for hpart: u32 in st.h {\n             let a = hpart >> 24u32 & 0xFFu32 as u8;\n             let b = hpart >> 16u32 & 0xFFu32 as u8;\n             let c = hpart >> 8u32 & 0xFFu32 as u8;\n@@ -243,7 +243,7 @@ fn mk_sha1() -> sha1 {\n         fn result_str() -> str {\n             let r = mk_result(st);\n             let s = \"\";\n-            for b: u8  in r { s += uint::to_str(b as uint, 16u); }\n+            for b: u8 in r { s += uint::to_str(b as uint, 16u); }\n             ret s;\n         }\n     }"}, {"sha": "d229b7d25fae1b45bea824c31b953ec4fca5d599", "filename": "src/lib/str.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -100,7 +100,7 @@ fn hash(s: &str) -> uint {\n     // FIXME: replace with murmur.\n \n     let u: uint = 5381u;\n-    for c: u8  in s { u *= 33u; u += c as uint; }\n+    for c: u8 in s { u *= 33u; u += c as uint; }\n     ret u;\n }\n \n@@ -156,7 +156,7 @@ fn is_ascii(s: str) -> bool {\n fn alloc(n_bytes: uint) -> str { ret rustrt::str_alloc(n_bytes); }\n \n /// Returns true if the string has length 0\n-pred is_empty(s: str) -> bool { for c: u8  in s { ret false; } ret true; }\n+pred is_empty(s: str) -> bool { for c: u8 in s { ret false; } ret true; }\n \n /// Returns true if the string has length greater than 0\n pred is_not_empty(s: str) -> bool { !is_empty(s) }\n@@ -240,7 +240,7 @@ fn from_char(ch: char) -> str {\n \n fn from_chars(chs: &[char]) -> str {\n     let buf = \"\";\n-    for ch: char  in chs { push_utf8_bytes(buf, ch); }\n+    for ch: char in chs { push_utf8_bytes(buf, ch); }\n     ret buf;\n }\n \n@@ -337,7 +337,7 @@ fn refcount(s: str) -> uint {\n // Standard bits from the world of string libraries.\n fn index(s: str, c: u8) -> int {\n     let i: int = 0;\n-    for k: u8  in s { if k == c { ret i; } i += 1; }\n+    for k: u8 in s { if k == c { ret i; } i += 1; }\n     ret -1;\n }\n \n@@ -353,7 +353,7 @@ fn find(haystack: str, needle: str) -> int {\n     if needle_len == 0 { ret 0; }\n     fn match_at(haystack: &str, needle: &str, i: int) -> bool {\n         let j: int = i;\n-        for c: u8  in needle { if haystack.(j) != c { ret false; } j += 1; }\n+        for c: u8 in needle { if haystack.(j) != c { ret false; } j += 1; }\n         ret true;\n     }\n     let i: int = 0;\n@@ -436,7 +436,7 @@ fn split(s: str, sep: u8) -> [str] {\n     let v: [str] = ~[];\n     let accum: str = \"\";\n     let ends_with_sep: bool = false;\n-    for c: u8  in s {\n+    for c: u8 in s {\n         if c == sep {\n             v += ~[accum];\n             accum = \"\";\n@@ -449,14 +449,14 @@ fn split(s: str, sep: u8) -> [str] {\n \n fn concat(v: &[str]) -> str {\n     let s: str = \"\";\n-    for ss: str  in v { s += ss; }\n+    for ss: str in v { s += ss; }\n     ret s;\n }\n \n fn connect(v: &[str], sep: str) -> str {\n     let s: str = \"\";\n     let first: bool = true;\n-    for ss: str  in v {\n+    for ss: str in v {\n         if first { first = false; } else { s += sep; }\n         s += ss;\n     }\n@@ -470,7 +470,7 @@ fn to_upper(s: str) -> str {\n     let ascii_a = 'a' as u8;\n     let ascii_z = 'z' as u8;\n     let diff = 32u8;\n-    for byte: u8  in s {\n+    for byte: u8 in s {\n         let next;\n         if ascii_a <= byte && byte <= ascii_z {\n             next = byte - diff;"}, {"sha": "8891a9ddadd4657f7eca4a44f211c2baa3ee24da", "filename": "src/lib/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fterm.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -51,7 +51,7 @@ fn color_supported() -> bool {\n     let supported_terms = ~[\"xterm-color\", \"xterm\", \"screen-bce\"];\n     ret alt generic_os::getenv(\"TERM\") {\n           option::some(env) {\n-            for term: str  in supported_terms {\n+            for term: str in supported_terms {\n                 if str::eq(term, env) { ret true; }\n             }\n             false"}, {"sha": "d6b151dd18f34846dbe3286421773ca54bfc6c57", "filename": "src/lib/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -50,7 +50,7 @@ type test_desc = {name: test_name, fn: test_fn, ignore: bool};\n // arguments and a vector of test_descs (generated at compile time).\n fn test_main(args: &vec[str], tests: &[test_desc]) {\n     let ivec_args =\n-        { let iargs = ~[]; for arg: str  in args { iargs += ~[arg] } iargs };\n+        { let iargs = ~[]; for arg: str in args { iargs += ~[arg] } iargs };\n     check (ivec::is_not_empty(ivec_args));\n     let opts =\n         alt parse_opts(ivec_args) {"}, {"sha": "cf1989ce29490f4750737be747e949daffa8553b", "filename": "src/test/bench/99bob-iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fbench%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fbench%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-iter.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -43,11 +43,11 @@ fn sub(t: str, n: int) -> str {\n iter ninetynine() -> int { let n: int = 100; while n > 1 { n -= 1; put n; } }\n \n fn main() {\n-    for each n: int  in ninetynine() {\n+    for each n: int in ninetynine() {\n         log sub(b1(), n);\n         log sub(b2(), n - 1);\n         log \"\";\n     }\n     log b7();\n     log b8();\n-}\n\\ No newline at end of file\n+}"}, {"sha": "38f51fa65be3286ae9e19db0c75e886313004dd9", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -26,7 +26,7 @@ type aminoacids = {ch: char, prob: u32};\n fn make_cumulative(aa: &[aminoacids]) -> [aminoacids] {\n     let cp: u32 = 0u32;\n     let ans: [aminoacids] = ~[];\n-    for a: aminoacids  in aa { cp += a.prob; ans += ~[{ch: a.ch, prob: cp}]; }\n+    for a: aminoacids in aa { cp += a.prob; ans += ~[{ch: a.ch, prob: cp}]; }\n     ret ans;\n }\n \n@@ -47,7 +47,7 @@ fn make_random_fasta(id: str, desc: str, genelist: &[aminoacids], n: int) {\n     log \">\" + id + \" \" + desc;\n     let rng = myrandom(std::rand::mk_rng().next());\n     let op: str = \"\";\n-    for each i: uint  in uint::range(0u, n as uint) {\n+    for each i: uint in uint::range(0u, n as uint) {\n         str::push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n         if str::byte_len(op) >= LINE_LENGTH() { log op; op = \"\"; }\n     }\n@@ -58,7 +58,7 @@ fn make_repeat_fasta(id: str, desc: str, s: str, n: int) {\n     log \">\" + id + \" \" + desc;\n     let op: str = \"\";\n     let sl: uint = str::byte_len(s);\n-    for each i: uint  in uint::range(0u, n as uint) {\n+    for each i: uint in uint::range(0u, n as uint) {\n         str::push_byte(op, s.(i % sl));\n         if str::byte_len(op) >= LINE_LENGTH() { log op; op = \"\"; }\n     }\n@@ -91,4 +91,4 @@ fn main(args: vec[str]) {\n     make_repeat_fasta(\"ONE\", \"Homo sapiens alu\", alu, n * 2);\n     make_random_fasta(\"TWO\", \"IUB ambiguity codes\", iub, n * 3);\n     make_random_fasta(\"THREE\", \"Homo sapiens frequency\", homosapiens, n * 5);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "f248dff1cda97bc052300bda6f16562cdfda4243", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     let bodies: [Body::props] = NBodySystem::MakeNBodySystem();\n \n \n-    for n: int  in inputs {\n+    for n: int in inputs {\n         log NBodySystem::energy(bodies);\n \n         let i: int = 0;\n@@ -201,4 +201,4 @@ mod Body {\n         props.vz = -pz / SOLAR_MASS;\n     }\n \n-}\n\\ No newline at end of file\n+}"}, {"sha": "4c41c1f05b7cd661648a43138245f733fd72abe5", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -73,7 +73,7 @@ fn stress_task(id: int) {\n \n fn stress(num_tasks: int) {\n     let tasks = [];\n-    for each i: int  in range(0, num_tasks) {\n+    for each i: int in range(0, num_tasks) {\n         tasks += [task::_spawn(bind stress_task(i))];\n     }\n     for t in tasks { task::join_id(t); }\n@@ -99,8 +99,8 @@ fn main(argv: vec[str]) {\n             let out = io::stdout();\n \n \n-            for each n: int  in range(1, max + 1) {\n-                for each i: int  in range(0, num_trials) {\n+            for each n: int in range(1, max + 1) {\n+                for each i: int in range(0, num_trials) {\n                     let start = time::precise_time_ns();\n                     let fibn = fib(n);\n                     let stop = time::precise_time_ns();\n@@ -113,4 +113,4 @@ fn main(argv: vec[str]) {\n             }\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c67697f29d43e014510fbfcf9f8bcb99f06cae9c", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -76,7 +76,7 @@ mod map_reduce {\n \n     fn start_mappers(ctrl: _chan[ctrl_proto], inputs: &[str]) -> [task_id] {\n         let tasks = ~[];\n-        for i: str  in inputs {\n+        for i: str in inputs {\n             tasks += ~[task::_spawn(bind map_task(ctrl, i))];\n         }\n         ret tasks;"}, {"sha": "b3c5c21d0ef058f111d167226505958abc9ba091", "filename": "src/test/compile-fail/for-loop-decl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -10,10 +10,10 @@ fn bitv_to_str(enclosing: fn_info, v: bitv::t) -> str {\n     let s = \"\";\n \n     // error is that the value type in the hash map is var_info, not a box\n-    for each p: @{key: uint, val: @uint}  in enclosing.vars.items() {\n+    for each p: @{key: uint, val: @uint} in enclosing.vars.items() {\n         if bitv::get(v, *p.val) { s += \"foo\"; }\n     }\n     ret s;\n }\n \n-fn main() { log \"OK\"; }\n\\ No newline at end of file\n+fn main() { log \"OK\"; }"}, {"sha": "3576a1e4ded86ccdc79b17f9550292e60d61d6ef", "filename": "src/test/compile-fail/shadow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fcompile-fail%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fcompile-fail%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshadow.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -6,10 +6,10 @@ fn foo(c: [int]) {\n \n \n     alt none[int] {\n-      some[int](_) { for i: int  in c { log a; let a = 17; b += ~[a]; } }\n+      some[int](_) { for i: int in c { log a; let a = 17; b += ~[a]; } }\n     }\n }\n \n tag t[T] { none; some(T); }\n \n-fn main() { foo(~[]); }\n\\ No newline at end of file\n+fn main() { foo(~[]); }"}, {"sha": "43e8b9cb7c243a633554cff331b2fe9d13d6cf3e", "filename": "src/test/compile-fail/unsafe-for.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -2,5 +2,5 @@\n \n fn main() {\n     let v: [mutable int] = ~[mutable 1, 2, 3];\n-    for x: int  in v { v.(0) = 10; log x; }\n-}\n\\ No newline at end of file\n+    for x: int in v { v.(0) = 10; log x; }\n+}"}, {"sha": "870999e7b04b24a5ba7a660a4b6ad2c049d697f5", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -129,7 +129,7 @@ fn make_tests(cx: &cx) -> tests_and_conv_fn {\n     log #fmt(\"making tests from %s\", cx.config.src_base);\n     let configport = mk_port[[u8]]();\n     let tests = ~[];\n-    for file: str  in fs::list_dir(cx.config.src_base) {\n+    for file: str in fs::list_dir(cx.config.src_base) {\n         log #fmt(\"inspecting file %s\", file);\n         if is_test(cx.config, file) {\n             tests += ~[make_test(cx, file, configport)];"}, {"sha": "4d8855680089f9029a41f1fb7bfa7a05da6a9a9c", "filename": "src/test/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fheader.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -28,7 +28,7 @@ fn load_props(testfile: &str) -> test_props {\n     let compile_flags = option::none;\n     let pp_exact = option::none;\n     let no_valgrind = false;\n-    for each ln: str  in iter_header(testfile) {\n+    for each ln: str in iter_header(testfile) {\n         alt parse_error_pattern(ln) {\n           option::some(ep) { error_patterns += ~[ep]; }\n           option::none. { }\n@@ -56,7 +56,7 @@ fn load_props(testfile: &str) -> test_props {\n \n fn is_test_ignored(config: &config, testfile: &str) -> bool {\n     let found = false;\n-    for each ln: str  in iter_header(testfile) {\n+    for each ln: str in iter_header(testfile) {\n         // FIXME: Can't return or break from iterator\n         found = found\n             || parse_name_directive(ln, \"xfail-\" + config.stage_id);"}, {"sha": "4aaeaa07b1ab99c14e933426584145fde660298b", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -192,7 +192,7 @@ fn check_error_patterns(props: &test_props, testfile: &str,\n \n     let next_err_idx = 0u;\n     let next_err_pat = props.error_patterns.(next_err_idx);\n-    for line: str  in str::split(procres.stdout, '\\n' as u8) {\n+    for line: str in str::split(procres.stdout, '\\n' as u8) {\n         if str::find(line, next_err_pat) > 0 {\n             log #fmt(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n@@ -211,7 +211,7 @@ fn check_error_patterns(props: &test_props, testfile: &str,\n         fatal_procres(#fmt(\"error pattern '%s' not found!\",\n                            missing_patterns.(0)), procres);\n     } else {\n-        for pattern: str  in missing_patterns {\n+        for pattern: str in missing_patterns {\n             error(#fmt(\"error pattern '%s' not found!\", pattern));\n         }\n         fatal_procres(\"multiple error patterns not found\", procres);"}, {"sha": "4128845ab0931fae280cbc02e404a0d3f8897b62", "filename": "src/test/run-fail/for-each-loop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -1,4 +1,4 @@\n // error-pattern:moop\n use std;\n import std::uint;\n-fn main() { for each i: uint  in uint::range(0u, 10u) { fail \"moop\"; } }\n\\ No newline at end of file\n+fn main() { for each i: uint in uint::range(0u, 10u) { fail \"moop\"; } }"}, {"sha": "a99e138fcebc8032974727e592254c340abf935c", "filename": "src/test/run-pass/alt-phi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Falt-phi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Falt-phi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-phi.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -7,8 +7,8 @@ iter foo() -> int { put 10; }\n fn main() {\n     let x = true;\n     alt a {\n-      a. { x = true; for each i: int  in foo() { } }\n+      a. { x = true; for each i: int in foo() { } }\n       b. { x = false; }\n       c. { x = false; }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c8b1222a20060f61caaea584df473e06fe7cc0de", "filename": "src/test/run-pass/argv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fargv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fargv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargv.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -4,5 +4,5 @@ import std::ivec;\n fn main(args: vec[str]) {\n     let vs: [str] = ~[\"hi\", \"there\", \"this\", \"is\", \"a\", \"vec\"];\n     let vvs: [[str]] = ~[ivec::from_vec(args), vs];\n-    for vs: [str]  in vvs { for s: str  in vs { log s; } }\n-}\n\\ No newline at end of file\n+    for vs: [str] in vvs { for s: str in vs { log s; } }\n+}"}, {"sha": "b4ea2f5dedc73780fb70e17d4d61a4f67564adf8", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let sum = 0;\n-    for x  in ~[1, 2, 3, 4, 5] { sum += x; }\n+    for x in ~[1, 2, 3, 4, 5] { sum += x; }\n     assert (sum == 15);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "6f450f7c125143c67068e4773bd875c545881286", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -1,4 +1,4 @@\n-fn iter_vec[T](v: &[T], f: &block(&T) ) { for x: T  in v { f(x); } }\n+fn iter_vec[T](v: &[T], f: &block(&T) ) { for x: T in v { f(x); } }\n \n fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7];"}, {"sha": "fd22ac3d570c5b64163bd3f8472fba4e7d9a5287", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -1,4 +1,4 @@\n-fn iter_vec[T](v: &[T], f: &block(&T) ) { for x: T  in v { f(x); } }\n+fn iter_vec[T](v: &[T], f: &block(&T) ) { for x: T in v { f(x); } }\n \n fn main() {\n     let v = ~[1, 2, 3, 4, 5];"}, {"sha": "d53445ef5866c2886dfd777208901a5ee545a759", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -6,16 +6,16 @@ fn main() {\n     assert (i == 10);\n     do  { i += 1; if i == 20 { break; } } while i < 30\n     assert (i == 20);\n-    for x: int  in ~[1, 2, 3, 4, 5, 6] {\n+    for x: int in ~[1, 2, 3, 4, 5, 6] {\n         if x == 3 { break; }\n         assert (x <= 3);\n     }\n     i = 0;\n     while i < 10 { i += 1; if i % 2 == 0 { cont; } assert (i % 2 != 0); }\n     i = 0;\n     do  { i += 1; if i % 2 == 0 { cont; } assert (i % 2 != 0); } while i < 10\n-    for x: int  in ~[1, 2, 3, 4, 5, 6] {\n+    for x: int in ~[1, 2, 3, 4, 5, 6] {\n         if x % 2 == 0 { cont; }\n         assert (x % 2 != 0);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "2e52a5ae1f7a1f6032c14824c78a5a0b1ce257db", "filename": "src/test/run-pass/for-loop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -1 +1 @@\n-fn main() { let x: [int] = ~[]; for i: int  in x { fail \"moop\"; } }\n\\ No newline at end of file\n+fn main() { let x: [int] = ~[]; for i: int in x { fail \"moop\"; } }"}, {"sha": "cfb33289cf86efe1aaf327e5a794a74207b3ad52", "filename": "src/test/run-pass/foreach-box-drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fforeach-box-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fforeach-box-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-box-drop.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -4,6 +4,6 @@ obj ob[K](k: K) {\n     iter foo() -> @{a: K} { put @{a: k}; }\n }\n \n-fn x(o: &ob[str]) { for each i: @{a: str}  in o.foo() { } }\n+fn x(o: &ob[str]) { for each i: @{a: str} in o.foo() { } }\n \n-fn main() { let o = ob[str](\"hi\" + \"there\"); x(o); }\n\\ No newline at end of file\n+fn main() { let o = ob[str](\"hi\" + \"there\"); x(o); }"}, {"sha": "ba42d7a6ac486f86bab76770dc61383c02d215c8", "filename": "src/test/run-pass/foreach-nested-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -12,10 +12,10 @@ iter range(start: int, stop: int) -> int {\n fn main() {\n     let a: [mutable int] = ~[mutable -1, -1, -1, -1, -1, -1, -1, -1];\n     let p: int = 0;\n-    for each i: int  in two() {\n-        for each j: int  in range(0, 2) {\n+    for each i: int in two() {\n+        for each j: int in range(0, 2) {\n             let tmp: int = 10 * i + j;\n-            for each k: int  in range(0, 2) { a.(p) = 10 * tmp + k; p += 1; }\n+            for each k: int in range(0, 2) { a.(p) = 10 * tmp + k; p += 1; }\n         }\n     }\n     assert (a.(0) == 0);\n@@ -26,4 +26,4 @@ fn main() {\n     assert (a.(5) == 101);\n     assert (a.(6) == 110);\n     assert (a.(7) == 111);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "4e90818621df520af24d757e75b1b38356b824bd", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -7,11 +7,11 @@ iter two() -> int { put 0; put 1; }\n fn main() {\n     let a: [mutable int] = ~[mutable -1, -1, -1, -1];\n     let p: int = 0;\n-    for each i: int  in two() {\n-        for each j: int  in two() { a.(p) = 10 * i + j; p += 1; }\n+    for each i: int in two() {\n+        for each j: int in two() { a.(p) = 10 * i + j; p += 1; }\n     }\n     assert (a.(0) == 0);\n     assert (a.(1) == 1);\n     assert (a.(2) == 10);\n     assert (a.(3) == 11);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "229e1e87c109a0d0a96fa616d461ec95148a4ac0", "filename": "src/test/run-pass/foreach-put-structured.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -9,12 +9,12 @@ iter pairs() -> {_0: int, _1: int} {\n fn main() {\n     let i: int = 10;\n     let j: int = 0;\n-    for each p: {_0: int, _1: int}  in pairs() {\n+    for each p: {_0: int, _1: int} in pairs() {\n         log p._0;\n         log p._1;\n         assert (p._0 + 10 == i);\n         i += 1;\n         j = p._1;\n     }\n     assert (j == 45);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "11e61d4b2d86771d298aa4b7c73db1cdf1a4a725", "filename": "src/test/run-pass/foreach-simple-outer-slot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n fn main() {\n     let sum: int = 0;\n-    for each i: int  in first_ten() { log \"main\"; log i; sum = sum + i; }\n+    for each i: int in first_ten() { log \"main\"; log i; sum = sum + i; }\n     log \"sum\";\n     log sum;\n     assert (sum == 45);\n@@ -13,4 +13,4 @@ fn main() {\n iter first_ten() -> int {\n     let i: int = 0;\n     while i < 10 { log \"first_ten\"; put i; i = i + 1; }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "7e43703a9b25d120a7d7ed89461db736f0d1f547", "filename": "src/test/run-pass/foreach-simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fforeach-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fforeach-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -2,9 +2,9 @@\n \n \n // -*- rust -*-\n-fn main() { for each i: int  in first_ten() { log \"main\"; } }\n+fn main() { for each i: int in first_ten() { log \"main\"; } }\n \n iter first_ten() -> int {\n     let i: int = 90;\n     while i < 100 { log \"first_ten\"; log i; put i; i = i + 1; }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "e4f8609e59b8f1115b1026e222cd5356ef916777", "filename": "src/test/run-pass/generic-iter-frame.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fgeneric-iter-frame.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fgeneric-iter-frame.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-iter-frame.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -4,6 +4,6 @@\n // Contrived example? No. It showed up in rustc's resolve pass.\n iter i() { put (); }\n \n-fn foo[T](t: &T) { let x: int = 10; for each j: ()  in i() { log x; } }\n+fn foo[T](t: &T) { let x: int = 10; for each j: () in i() { log x; } }\n \n-fn main() { foo(0xdeadbeef_u); }\n\\ No newline at end of file\n+fn main() { foo(0xdeadbeef_u); }"}, {"sha": "d4ac50339fdfb6211fbba34c409496c7aaef5f91", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -33,7 +33,7 @@ mod map_reduce {\n     tag ctrl_proto { find_reducer([u8], _chan[int]); mapper_done; }\n \n     fn start_mappers(ctrl: _chan[ctrl_proto], inputs: &[str]) {\n-        for i: str  in inputs { task::_spawn(bind map_task(ctrl, i)); }\n+        for i: str in inputs { task::_spawn(bind map_task(ctrl, i)); }\n     }\n \n     fn map_task(ctrl: _chan[ctrl_proto], input: str) {\n@@ -93,4 +93,4 @@ mod map_reduce {\n \n fn main() {\n     map_reduce::map_reduce(~[\"../src/test/run-pass/hashmap-memory.rs\"]);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "d5cab50916e115a2c4cfc8e27fbe5b0c7dde341d", "filename": "src/test/run-pass/iter-range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fiter-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fiter-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-range.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -8,6 +8,6 @@ iter range(a: int, b: int) -> int {\n \n fn main() {\n     let sum: int = 0;\n-    for each x: int  in range(0, 100) { sum += x; }\n+    for each x: int in range(0, 100) { sum += x; }\n     log sum;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "77edc2c0ec79dfa378205a9edc3dfedf071e62fe", "filename": "src/test/run-pass/iter-ret.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fiter-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fiter-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-ret.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -2,6 +2,6 @@\n \n iter x() -> int { }\n \n-fn f() -> bool { for each i: int  in x() { ret true; } ret false; }\n+fn f() -> bool { for each i: int in x() { ret true; } ret false; }\n \n-fn main(args: vec[str]) { f(); }\n\\ No newline at end of file\n+fn main(args: vec[str]) { f(); }"}, {"sha": "a36848106f66c5c657e2b865d2929bfcfc24b911", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -3,12 +3,12 @@\n fn main() {\n     let x = ~[1, 2, 3];\n     let y = 0;\n-    for i: int  in x { log i; y += i; }\n+    for i: int in x { log i; y += i; }\n     log y;\n     assert (y == 6);\n     let s = \"hello there\";\n     let i: int = 0;\n-    for c: u8  in s {\n+    for c: u8 in s {\n         if i == 0 { assert (c == 'h' as u8); }\n         if i == 1 { assert (c == 'e' as u8); }\n         if i == 2 { assert (c == 'l' as u8); }\n@@ -21,4 +21,4 @@ fn main() {\n         log c;\n     }\n     assert (i == 11);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "fc5618d823df41cb1c4fbe3ab531d62aac478940", "filename": "src/test/run-pass/loop-scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Floop-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Floop-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-scope.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let x = ~[10, 20, 30];\n     let sum = 0;\n-    for x  in x { sum += x; }\n+    for x in x { sum += x; }\n     assert (sum == 60);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "5c941e7c4777f433381e65fb3df28448f304358c", "filename": "src/test/run-pass/maybe-mutable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n fn len(v: [mutable? int]) -> uint {\n     let i = 0u;\n-    for x: int  in v { i += 1u; }\n+    for x: int in v { i += 1u; }\n     ret i;\n }\n \n@@ -13,4 +13,4 @@ fn main() {\n     log len(v0);\n     let v1 = ~[mutable 1, 2, 3, 4, 5];\n     log len(v1);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "9ce0eb3bf5c12b958b6dee8d2ad28306448cd0e2", "filename": "src/test/run-pass/move-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fmove-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fmove-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-3.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -10,8 +10,8 @@ fn test(x: bool, foo: @{x: int, y: int, z: int}) -> int {\n \n fn main() {\n     let x = @{x: 1, y: 2, z: 3};\n-    for each i: uint  in uint::range(0u, 10000u) {\n+    for each i: uint in uint::range(0u, 10000u) {\n         assert (test(true, x) == 2);\n     }\n     assert (test(false, x) == 5);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3ee92b32d0b356ed17fa0e2f0bd7665b17bacace", "filename": "src/test/run-pass/pattern-bound-var-in-for-each.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpattern-bound-var-in-for-each.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -10,7 +10,7 @@ fn foo(src: uint) {\n \n     alt some(src) {\n       some(src_id) {\n-        for each i: uint  in uint::range(0u, 10u) {\n+        for each i: uint in uint::range(0u, 10u) {\n             let yyy = src_id;\n             assert (yyy == 0u);\n         }\n@@ -19,4 +19,4 @@ fn foo(src: uint) {\n     }\n }\n \n-fn main() { foo(0u); }\n\\ No newline at end of file\n+fn main() { foo(0u); }"}, {"sha": "2490b4a45ecc2d281e45b8c52ee42826f56142e6", "filename": "src/test/run-pass/rt-circular-buffer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -31,7 +31,7 @@ fn test_grow() {\n     let myport: port[record] = port();\n     let mychan = chan(myport);\n     let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n-    for each i: uint  in uint::range(0u, 100u) { mychan <| val; }\n+    for each i: uint in uint::range(0u, 100u) { mychan <| val; }\n }\n \n \n@@ -48,16 +48,16 @@ fn test_shrink2() {\n     let myport: port[record] = port();\n     let mychan = chan(myport);\n     let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n-    for each i: uint  in uint::range(0u, 100u) { mychan <| val; }\n-    for each i: uint  in uint::range(0u, 100u) { let x; myport |> x; }\n+    for each i: uint in uint::range(0u, 100u) { mychan <| val; }\n+    for each i: uint in uint::range(0u, 100u) { let x; myport |> x; }\n }\n \n \n // Test rotating the buffer when the unit size is not a power of two\n fn test_rotate() {\n     let myport: port[record] = port();\n     let mychan = chan(myport);\n-    for each i: uint  in uint::range(0u, 100u) {\n+    for each i: uint in uint::range(0u, 100u) {\n         let val = {val1: i as u32, val2: i as u32, val3: i as u32};\n         mychan <| val;\n         let x;\n@@ -74,13 +74,13 @@ fn test_rotate() {\n fn test_rotate_grow() {\n     let myport: port[record] = port();\n     let mychan = chan(myport);\n-    for each j: uint  in uint::range(0u, 10u) {\n-        for each i: uint  in uint::range(0u, 10u) {\n+    for each j: uint in uint::range(0u, 10u) {\n+        for each i: uint in uint::range(0u, 10u) {\n             let val: record =\n                 {val1: i as u32, val2: i as u32, val3: i as u32};\n             mychan <| val;\n         }\n-        for each i: uint  in uint::range(0u, 10u) {\n+        for each i: uint in uint::range(0u, 10u) {\n             let x;\n             myport |> x;\n             assert (x.val1 == i as u32);"}, {"sha": "580be0ed9a816645f9bdb1bea440dc2bf811cfa9", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -49,7 +49,7 @@ fn test00() {\n         }\n     }\n \n-    for t: task_id  in tasks { task::join_id(t); }\n+    for t: task_id in tasks { task::join_id(t); }\n \n     log \"Completed: Final number is: \";\n     assert (sum ==\n@@ -137,7 +137,7 @@ fn test06() {\n         i = i + 1; tasks += [task::_spawn(bind test06_start(i))]; }\n \n \n-    for t: task_id  in tasks { task::join_id(t); }\n+    for t: task_id in tasks { task::join_id(t); }\n }\n \n "}, {"sha": "a75a1010895bcd977e417f2a8795c61fc61c10b1", "filename": "src/test/run-pass/type-params-in-for-each.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -6,7 +6,7 @@ iter range(lo: uint, hi: uint) -> uint {\n }\n \n fn create_index[T](index: &[{a: T, b: uint}], hash_fn: fn(&T) -> uint ) {\n-    for each i: uint  in range(0u, 256u) { let bucket: [T] = ~[]; }\n+    for each i: uint in range(0u, 256u) { let bucket: [T] = ~[]; }\n }\n \n-fn main() { }\n\\ No newline at end of file\n+fn main() { }"}, {"sha": "e7dc278061224811a3de764dffcb61d7769b1b9c", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -31,7 +31,7 @@ fn main() {\n \n     fn check_str_eq(a: str, b: str) {\n         let i: int = 0;\n-        for ab: u8  in a {\n+        for ab: u8 in a {\n             log i;\n             log ab;\n             let bb: u8 = b.(i);\n@@ -45,4 +45,4 @@ fn main() {\n     check_str_eq(japan, japan_e);\n     check_str_eq(uzbekistan, uzbekistan_e);\n     check_str_eq(austria, austria_e);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "1a249de4919e89a8844dae21812766d2701c2ef7", "filename": "src/test/stdtest/qsort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fstdtest%2Fqsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fstdtest%2Fqsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -50,7 +50,7 @@ fn test_simple() {\n     sort::quick_sort(lteq, names);\n \n     let pairs = ivec::zip(expected, ivec::from_mut(names));\n-    for p: {_0: int, _1: int}  in pairs {\n+    for p: {_0: int, _1: int} in pairs {\n         log #fmt(\"%d %d\", p._0, p._1);\n         assert (p._0 == p._1);\n     }"}, {"sha": "5cbdb25d195c6876cac8e068ed256f4b62975681", "filename": "src/test/stdtest/sha1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fstdtest%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fstdtest%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsha1.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -74,7 +74,7 @@ fn test() {\n     // Test that it works when accepting the message all at once\n \n     let sh = sha1::mk_sha1();\n-    for t: test  in tests {\n+    for t: test in tests {\n         sh.input_str(t.input);\n         let out = sh.result();\n         check_vec_eq(t.output, out);\n@@ -83,7 +83,7 @@ fn test() {\n \n \n     // Test that it works when accepting the message in pieces\n-    for t: test  in tests {\n+    for t: test in tests {\n         let len = str::byte_len(t.input);\n         let left = len;\n         while left > 0u {"}, {"sha": "8124e565f6a4ae51651eae9c269e2b8fe85a1008", "filename": "src/test/stdtest/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fstdtest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fstdtest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstr.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -29,7 +29,7 @@ fn test_split() {\n         log i;\n         let v = str::split(s, c as u8);\n         log \"split to: \";\n-        for z: str  in v { log z; }\n+        for z: str in v { log z; }\n         log \"comparing: \" + v.(i) + \" vs. \" + k;\n         assert (str::eq(v.(i), k));\n     }"}, {"sha": "7d587e2352190d96843a58e654ffb0eea2b49ac1", "filename": "src/test/stdtest/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fstdtest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f91351aaf69b0d4fefaff0df1c288466c0183de5/src%2Ftest%2Fstdtest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftest.rs?ref=f91351aaf69b0d4fefaff0df1c288466c0183de5", "patch": "@@ -71,7 +71,7 @@ fn sort_tests() {\n         {\n             let testfn = fn () { };\n             let tests = ~[];\n-            for name: str  in names {\n+            for name: str in names {\n                 let test = {name: name, fn: testfn, ignore: false};\n                 tests += ~[test];\n             }\n@@ -89,7 +89,7 @@ fn sort_tests() {\n     let pairs = ivec::zip(expected, filtered);\n \n \n-    for p: {_0: str, _1: test::test_desc}  in pairs {\n+    for p: {_0: str, _1: test::test_desc} in pairs {\n         assert (p._0 == p._1.name);\n     }\n }"}]}