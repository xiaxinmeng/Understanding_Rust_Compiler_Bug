{"sha": "b2edd42b24307d4ad931117642380872ebd38372", "node_id": "C_kwDOAAsO6NoAKGIyZWRkNDJiMjQzMDdkNGFkOTMxMTE3NjQyMzgwODcyZWJkMzgzNzI", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2023-04-13T22:50:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-13T22:50:00Z"}, "message": "Merge pull request #10603 from robertbastian/octal\n\nFix false positives and false negatives in `octal_escapes`", "tree": {"sha": "56d459d6e61f4cd0a3f4815af023c001549c9d6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56d459d6e61f4cd0a3f4815af023c001549c9d6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2edd42b24307d4ad931117642380872ebd38372", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkOIcYCRBK7hj4Ov3rIwAAypoIADDd9o76OMmGY/b4/ASjRv6A\nYr0Xe0BM5dB/3hnAoOxqq8d1YRZVwvciZOfTA4nI+c0Onpge6xVejWNB+4/T7gm4\nOYoBLrT4YRh8BEHKHwfpUd3Q0E+1N10egMlSOXD+2O9glktudEfnrjFuGpaeoGy4\noCJ8dFwJZveNrSd7vYj6r8Wttvfpm/m+UKOlWlb27gEEiTz6wIeV9S1OCF2kQ0Qt\ncwqjwQmkSNSLYt/DcIrYXlJvITPBK1IFSvT3H5vt1igGg0q4J9I+0RBL58MJdDru\nX526/ok/GK3VZt3QEalkUTNXZTIdETz7ta0Q3bXULdtkuUNuUnCnRREG02HASPs=\n=IHGx\n-----END PGP SIGNATURE-----\n", "payload": "tree 56d459d6e61f4cd0a3f4815af023c001549c9d6c\nparent d9c2957221f785256ac977e89c394400e560336e\nparent 67e836d4cfe4905dd1c4caa1d14f2aa7f76cc42a\nauthor Manish Goregaokar <manishsmail@gmail.com> 1681426200 -0700\ncommitter GitHub <noreply@github.com> 1681426200 -0700\n\nMerge pull request #10603 from robertbastian/octal\n\nFix false positives and false negatives in `octal_escapes`"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2edd42b24307d4ad931117642380872ebd38372", "html_url": "https://github.com/rust-lang/rust/commit/b2edd42b24307d4ad931117642380872ebd38372", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2edd42b24307d4ad931117642380872ebd38372/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9c2957221f785256ac977e89c394400e560336e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9c2957221f785256ac977e89c394400e560336e", "html_url": "https://github.com/rust-lang/rust/commit/d9c2957221f785256ac977e89c394400e560336e"}, {"sha": "67e836d4cfe4905dd1c4caa1d14f2aa7f76cc42a", "url": "https://api.github.com/repos/rust-lang/rust/commits/67e836d4cfe4905dd1c4caa1d14f2aa7f76cc42a", "html_url": "https://github.com/rust-lang/rust/commit/67e836d4cfe4905dd1c4caa1d14f2aa7f76cc42a"}], "stats": {"total": 113, "additions": 67, "deletions": 46}, "files": [{"sha": "6d3865080a68665c08ef0916ca554d7a32452d43", "filename": "clippy_lints/src/octal_escapes.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b2edd42b24307d4ad931117642380872ebd38372/clippy_lints%2Fsrc%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2edd42b24307d4ad931117642380872ebd38372/clippy_lints%2Fsrc%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foctal_escapes.rs?ref=b2edd42b24307d4ad931117642380872ebd38372", "patch": "@@ -76,8 +76,8 @@ fn check_lit(cx: &EarlyContext<'_>, lit: &Lit, span: Span, is_string: bool) {\n         if ch == '\\\\' {\n             if let Some((_, '0')) = iter.next() {\n                 // collect up to two further octal digits\n-                if let Some((mut to, '0'..='7')) = iter.next() {\n-                    if let Some((_, '0'..='7')) = iter.peek() {\n+                if let Some((mut to, _)) = iter.next_if(|(_, ch)| matches!(ch, '0'..='7')) {\n+                    if iter.next_if(|(_, ch)| matches!(ch, '0'..='7')).is_some() {\n                         to += 1;\n                     }\n                     found.push((from, to + 1));\n@@ -90,32 +90,6 @@ fn check_lit(cx: &EarlyContext<'_>, lit: &Lit, span: Span, is_string: bool) {\n         return;\n     }\n \n-    // construct two suggestion strings, one with \\x escapes with octal meaning\n-    // as in C, and one with \\x00 for null bytes.\n-    let mut suggest_1 = if is_string { \"\\\"\" } else { \"b\\\"\" }.to_string();\n-    let mut suggest_2 = suggest_1.clone();\n-    let mut index = 0;\n-    for (from, to) in found {\n-        suggest_1.push_str(&contents[index..from]);\n-        suggest_2.push_str(&contents[index..from]);\n-\n-        // construct a replacement escape\n-        // the maximum value is \\077, or \\x3f, so u8 is sufficient here\n-        if let Ok(n) = u8::from_str_radix(&contents[from + 1..to], 8) {\n-            write!(suggest_1, \"\\\\x{n:02x}\").unwrap();\n-        }\n-\n-        // append the null byte as \\x00 and the following digits literally\n-        suggest_2.push_str(\"\\\\x00\");\n-        suggest_2.push_str(&contents[from + 2..to]);\n-\n-        index = to;\n-    }\n-    suggest_1.push_str(&contents[index..]);\n-    suggest_1.push('\"');\n-    suggest_2.push_str(&contents[index..]);\n-    suggest_2.push('\"');\n-\n     span_lint_and_then(\n         cx,\n         OCTAL_ESCAPES,\n@@ -129,23 +103,53 @@ fn check_lit(cx: &EarlyContext<'_>, lit: &Lit, span: Span, is_string: bool) {\n                 \"octal escapes are not supported, `\\\\0` is always a null {}\",\n                 if is_string { \"character\" } else { \"byte\" }\n             ));\n-            // suggestion 1: equivalent hex escape\n-            diag.span_suggestion(\n-                span,\n-                \"if an octal escape was intended, use the hexadecimal representation instead\",\n-                suggest_1,\n-                Applicability::MaybeIncorrect,\n-            );\n-            // suggestion 2: unambiguous null byte\n-            diag.span_suggestion(\n-                span,\n-                format!(\n-                    \"if the null {} is intended, disambiguate using\",\n-                    if is_string { \"character\" } else { \"byte\" }\n-                ),\n-                suggest_2,\n-                Applicability::MaybeIncorrect,\n-            );\n+\n+            // Generate suggestions if the string is not too long (~ 5 lines)\n+            if contents.len() < 400 {\n+                // construct two suggestion strings, one with \\x escapes with octal meaning\n+                // as in C, and one with \\x00 for null bytes.\n+                let mut suggest_1 = if is_string { \"\\\"\" } else { \"b\\\"\" }.to_string();\n+                let mut suggest_2 = suggest_1.clone();\n+                let mut index = 0;\n+                for (from, to) in found {\n+                    suggest_1.push_str(&contents[index..from]);\n+                    suggest_2.push_str(&contents[index..from]);\n+\n+                    // construct a replacement escape\n+                    // the maximum value is \\077, or \\x3f, so u8 is sufficient here\n+                    if let Ok(n) = u8::from_str_radix(&contents[from + 1..to], 8) {\n+                        write!(suggest_1, \"\\\\x{n:02x}\").unwrap();\n+                    }\n+\n+                    // append the null byte as \\x00 and the following digits literally\n+                    suggest_2.push_str(\"\\\\x00\");\n+                    suggest_2.push_str(&contents[from + 2..to]);\n+\n+                    index = to;\n+                }\n+                suggest_1.push_str(&contents[index..]);\n+                suggest_2.push_str(&contents[index..]);\n+\n+                suggest_1.push('\"');\n+                suggest_2.push('\"');\n+                // suggestion 1: equivalent hex escape\n+                diag.span_suggestion(\n+                    span,\n+                    \"if an octal escape was intended, use the hexadecimal representation instead\",\n+                    suggest_1,\n+                    Applicability::MaybeIncorrect,\n+                );\n+                // suggestion 2: unambiguous null byte\n+                diag.span_suggestion(\n+                    span,\n+                    format!(\n+                        \"if the null {} is intended, disambiguate using\",\n+                        if is_string { \"character\" } else { \"byte\" }\n+                    ),\n+                    suggest_2,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n         },\n     );\n }"}, {"sha": "61ea96604577fdf37a9d0dcbaac89dcadc19eb1b", "filename": "tests/ui/octal_escapes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2edd42b24307d4ad931117642380872ebd38372/tests%2Fui%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2edd42b24307d4ad931117642380872ebd38372/tests%2Fui%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foctal_escapes.rs?ref=b2edd42b24307d4ad931117642380872ebd38372", "patch": "@@ -17,4 +17,5 @@ fn main() {\n     let _good3 = \"\\0\\0\";\n     let _good4 = \"X\\0\\0X\";\n     let _good5 = \"\u9508\\0\u9508\";\n+    let _good6 = \"\\0\\\\01\";\n }"}, {"sha": "aa362e96321bdb7cf984e9754c081ad585a04f16", "filename": "tests/ui/octal_escapes.stderr", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2edd42b24307d4ad931117642380872ebd38372/tests%2Fui%2Foctal_escapes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2edd42b24307d4ad931117642380872ebd38372/tests%2Fui%2Foctal_escapes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foctal_escapes.stderr?ref=b2edd42b24307d4ad931117642380872ebd38372", "patch": "@@ -63,6 +63,22 @@ help: if the null character is intended, disambiguate using\n LL |     let _bad4 = \"/x001234567\";\n    |                 ~~~~~~~~~~~~~\n \n+error: octal-looking escape in string literal\n+  --> $DIR/octal_escapes.rs:9:17\n+   |\n+LL |     let _bad5 = \"/0/03\";\n+   |                 ^^^^^^^\n+   |\n+   = help: octal escapes are not supported, `/0` is always a null character\n+help: if an octal escape was intended, use the hexadecimal representation instead\n+   |\n+LL |     let _bad5 = \"/0/x03\";\n+   |                 ~~~~~~~~\n+help: if the null character is intended, disambiguate using\n+   |\n+LL |     let _bad5 = \"/0/x003\";\n+   |                 ~~~~~~~~~\n+\n error: octal-looking escape in string literal\n   --> $DIR/octal_escapes.rs:10:17\n    |\n@@ -127,5 +143,5 @@ help: if the null character is intended, disambiguate using\n LL |     let _bad9 = \"\u9508/x0011\u9508\";\n    |                 ~~~~~~~~~~~~\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n "}]}