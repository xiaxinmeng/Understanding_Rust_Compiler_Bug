{"sha": "ab6e47851b51a413db5d721f25d714653e7549fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNmU0Nzg1MWI1MWE0MTNkYjVkNzIxZjI1ZDcxNDY1M2U3NTQ5ZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-04T09:00:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-04T09:00:39Z"}, "message": "Auto merge of #65835 - Mark-Simulacrum:lockless-lintbuffer, r=nikomatsakis\n\nRemove LintBuffer from Session\n\nThis moves the `LintBuffer` from `Session` into the `Resolver`, where it is used until lowering is done and then consumed by early lint passes. This also happily removes the failure mode of buffering lints too late where it would have previously lead to ICEs; it is statically no longer possible to do so.\n\nI suspect that with a bit more work a similar move could be done for the lint buffer inside `ParseSess`, but this PR doesn't touch it (in part to keep itself small).\n\nThe last commit is the \"interesting\" commit -- the ones before it don't work (though they compile) as they sort of prepare the various crates for the lint buffer to be passed in rather than accessed through Session.", "tree": {"sha": "31b2ec020f7c4c139561fdb05b6357574f91d5f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31b2ec020f7c4c139561fdb05b6357574f91d5f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab6e47851b51a413db5d721f25d714653e7549fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab6e47851b51a413db5d721f25d714653e7549fd", "html_url": "https://github.com/rust-lang/rust/commit/ab6e47851b51a413db5d721f25d714653e7549fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab6e47851b51a413db5d721f25d714653e7549fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba93685377bc74a2fde1eb8e7a086039b038e94", "url": "https://api.github.com/repos/rust-lang/rust/commits/cba93685377bc74a2fde1eb8e7a086039b038e94", "html_url": "https://github.com/rust-lang/rust/commit/cba93685377bc74a2fde1eb8e7a086039b038e94"}, {"sha": "c68df7c503676a1f63c0fcc2a7f10597fb93c375", "url": "https://api.github.com/repos/rust-lang/rust/commits/c68df7c503676a1f63c0fcc2a7f10597fb93c375", "html_url": "https://github.com/rust-lang/rust/commit/c68df7c503676a1f63c0fcc2a7f10597fb93c375"}], "stats": {"total": 326, "additions": 173, "deletions": 153}, "files": [{"sha": "6b6032516ca73a12b83be7857b5468cf20ec0e6a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -43,6 +43,7 @@ use crate::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use crate::hir::def::{Namespace, Res, DefKind, PartialRes, PerNS};\n use crate::hir::{GenericArg, ConstArg};\n use crate::hir::ptr::P;\n+use crate::lint;\n use crate::lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                     ELIDED_LIFETIMES_IN_PATHS};\n use crate::middle::cstore::CrateStore;\n@@ -184,6 +185,8 @@ pub trait Resolver {\n     ) -> (ast::Path, Res<NodeId>);\n \n     fn has_derives(&self, node_id: NodeId, derives: SpecialDerives) -> bool;\n+\n+    fn lint_buffer(&mut self) -> &mut lint::LintBuffer;\n }\n \n type NtToTokenstream = fn(&Nonterminal, &ParseSess, Span) -> TokenStream;\n@@ -1857,7 +1860,7 @@ impl<'a> LoweringContext<'a> {\n                 GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n                     ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n                     ParenthesizedGenericArgs::Warn => {\n-                        self.sess.buffer_lint(\n+                        self.resolver.lint_buffer().buffer_lint(\n                             PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                             CRATE_NODE_ID,\n                             data.span,\n@@ -1953,7 +1956,7 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     AnonymousLifetimeMode::PassThrough |\n                     AnonymousLifetimeMode::ReportError => {\n-                        self.sess.buffer_lint_with_diagnostic(\n+                        self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n                             ELIDED_LIFETIMES_IN_PATHS,\n                             CRATE_NODE_ID,\n                             path_span,\n@@ -3346,15 +3349,15 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn maybe_lint_bare_trait(&self, span: Span, id: NodeId, is_global: bool) {\n+    fn maybe_lint_bare_trait(&mut self, span: Span, id: NodeId, is_global: bool) {\n         // FIXME(davidtwco): This is a hack to detect macros which produce spans of the\n         // call site which do not have a macro backtrace. See #61963.\n         let is_macro_callsite = self.sess.source_map()\n             .span_to_snippet(span)\n             .map(|snippet| snippet.starts_with(\"#[\"))\n             .unwrap_or(true);\n         if !is_macro_callsite {\n-            self.sess.buffer_lint_with_diagnostic(\n+            self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n                 builtin::BARE_TRAIT_OBJECTS,\n                 id,\n                 span,"}, {"sha": "eef1cee8db37a1678a3317b52e6cf5ba2e74d5df", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -34,7 +34,6 @@ use crate::util::common::time;\n \n use errors::DiagnosticBuilder;\n use std::slice;\n-use std::default::Default as StdDefault;\n use rustc_data_structures::sync::{self, ParallelIterator, join, par_iter};\n use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use syntax::ast;\n@@ -584,12 +583,13 @@ impl<'a> EarlyContext<'a> {\n         lint_store: &'a LintStore,\n         krate: &'a ast::Crate,\n         buffered: LintBuffer,\n+        warn_about_weird_lints: bool,\n     ) -> EarlyContext<'a> {\n         EarlyContext {\n             sess,\n             krate,\n             lint_store,\n-            builder: LintLevelSets::builder(sess, lint_store),\n+            builder: LintLevelSets::builder(sess, warn_about_weird_lints, lint_store),\n             buffered,\n         }\n     }\n@@ -1490,9 +1490,10 @@ fn early_lint_crate<T: EarlyLintPass>(\n     krate: &ast::Crate,\n     pass: T,\n     buffered: LintBuffer,\n+    warn_about_weird_lints: bool,\n ) -> LintBuffer {\n     let mut cx = EarlyContextAndPass {\n-        context: EarlyContext::new(sess, lint_store, krate, buffered),\n+        context: EarlyContext::new(sess, lint_store, krate, buffered, warn_about_weird_lints),\n         pass,\n     };\n \n@@ -1514,22 +1515,19 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n     lint_store: &LintStore,\n     krate: &ast::Crate,\n     pre_expansion: bool,\n+    lint_buffer: Option<LintBuffer>,\n     builtin_lints: T,\n ) {\n-    let (mut passes, mut buffered): (Vec<_>, _) = if pre_expansion {\n-        (\n-            lint_store.pre_expansion_passes.iter().map(|p| (p)()).collect(),\n-            LintBuffer::default(),\n-        )\n+    let mut passes: Vec<_> = if pre_expansion {\n+        lint_store.pre_expansion_passes.iter().map(|p| (p)()).collect()\n     } else {\n-        (\n-            lint_store.early_passes.iter().map(|p| (p)()).collect(),\n-            sess.buffered_lints.borrow_mut().take().unwrap(),\n-        )\n+        lint_store.early_passes.iter().map(|p| (p)()).collect()\n     };\n+    let mut buffered = lint_buffer.unwrap_or_default();\n \n     if !sess.opts.debugging_opts.no_interleave_lints {\n-        buffered = early_lint_crate(sess, lint_store, krate, builtin_lints, buffered);\n+        buffered = early_lint_crate(sess, lint_store, krate, builtin_lints, buffered,\n+            pre_expansion);\n \n         if !passes.is_empty() {\n             buffered = early_lint_crate(\n@@ -1538,6 +1536,7 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n                 krate,\n                 EarlyLintPassObjects { lints: &mut passes[..] },\n                 buffered,\n+                pre_expansion,\n             );\n         }\n     } else {\n@@ -1549,6 +1548,7 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n                     krate,\n                     EarlyLintPassObjects { lints: slice::from_mut(pass) },\n                     buffered,\n+                    pre_expansion,\n                 )\n             });\n         }"}, {"sha": "e470dbdf3239b29ef493bb5c8528e7e317924b64", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -44,8 +44,12 @@ impl LintLevelSets {\n         return me\n     }\n \n-    pub fn builder<'a>(sess: &'a Session, store: &LintStore) -> LintLevelsBuilder<'a> {\n-        LintLevelsBuilder::new(sess, LintLevelSets::new(sess, store))\n+    pub fn builder<'a>(\n+        sess: &'a Session,\n+        warn_about_weird_lints: bool,\n+        store: &LintStore,\n+    ) -> LintLevelsBuilder<'a> {\n+        LintLevelsBuilder::new(sess, warn_about_weird_lints, LintLevelSets::new(sess, store))\n     }\n \n     fn process_command_line(&mut self, sess: &Session, store: &LintStore) {\n@@ -160,14 +164,18 @@ pub struct BuilderPush {\n }\n \n impl<'a> LintLevelsBuilder<'a> {\n-    pub fn new(sess: &'a Session, sets: LintLevelSets) -> LintLevelsBuilder<'a> {\n+    pub fn new(\n+        sess: &'a Session,\n+        warn_about_weird_lints: bool,\n+        sets: LintLevelSets,\n+    ) -> LintLevelsBuilder<'a> {\n         assert_eq!(sets.list.len(), 1);\n         LintLevelsBuilder {\n             sess,\n             sets,\n             cur: 0,\n             id_to_set: Default::default(),\n-            warn_about_weird_lints: sess.buffered_lints.borrow().is_some(),\n+            warn_about_weird_lints,\n         }\n     }\n "}, {"sha": "11d0d0d90fa866b6e6e1206aa945e980fc6c8de4", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -643,13 +643,29 @@ impl LintBuffer {\n         }\n     }\n \n-    pub fn take(&mut self, id: ast::NodeId) -> Vec<BufferedEarlyLint> {\n+    fn take(&mut self, id: ast::NodeId) -> Vec<BufferedEarlyLint> {\n         self.map.remove(&id).unwrap_or_default()\n     }\n \n-    pub fn get_any(&self) -> Option<&[BufferedEarlyLint]> {\n-        let key = self.map.keys().next().map(|k| *k);\n-        key.map(|k| &self.map[&k][..])\n+    pub fn buffer_lint<S: Into<MultiSpan>>(\n+        &mut self,\n+        lint: &'static Lint,\n+        id: ast::NodeId,\n+        sp: S,\n+        msg: &str,\n+    ) {\n+        self.add_lint(lint, id, sp.into(), msg, BuiltinLintDiagnostics::Normal)\n+    }\n+\n+    pub fn buffer_lint_with_diagnostic<S: Into<MultiSpan>>(\n+        &mut self,\n+        lint: &'static Lint,\n+        id: ast::NodeId,\n+        sp: S,\n+        msg: &str,\n+        diagnostic: BuiltinLintDiagnostics,\n+    ) {\n+        self.add_lint(lint, id, sp.into(), msg, diagnostic)\n     }\n }\n \n@@ -779,7 +795,7 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     assert_eq!(cnum, LOCAL_CRATE);\n     let store = &tcx.lint_store;\n     let mut builder = LintLevelMapBuilder {\n-        levels: LintLevelSets::builder(tcx.sess, &store),\n+        levels: LintLevelSets::builder(tcx.sess, false, &store),\n         tcx: tcx,\n         store: store,\n     };"}, {"sha": "93d0627ac6e401415c58d8a8e539c990121ea7dd", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -586,7 +586,7 @@ pub fn rustc_deprecation_message(depr: &RustcDeprecation, path: &str) -> (String\n }\n \n pub fn early_report_deprecation(\n-    sess: &Session,\n+    lint_buffer: &'a mut lint::LintBuffer,\n     message: &str,\n     suggestion: Option<Symbol>,\n     lint: &'static Lint,\n@@ -597,7 +597,7 @@ pub fn early_report_deprecation(\n     }\n \n     let diag = BuiltinLintDiagnostics::DeprecatedMacro(suggestion, span);\n-    sess.buffer_lint_with_diagnostic(lint, CRATE_NODE_ID, span, message, diag);\n+    lint_buffer.buffer_lint_with_diagnostic(lint, CRATE_NODE_ID, span, message, diag);\n }\n \n fn late_report_deprecation("}, {"sha": "2bcddeaf1962db3f3a2b298c96c74b1dfab0e18d", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -1469,7 +1469,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n          (such as entering an empty infinite loop) by inserting llvm.sideeffect\"),\n }\n \n-pub fn default_lib_output() -> CrateType {\n+pub const fn default_lib_output() -> CrateType {\n     CrateType::Rlib\n }\n "}, {"sha": "13b76b79b3d82a5301a0dc94800b9046985204be", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -6,7 +6,6 @@ use crate::hir::def_id::CrateNum;\n use rustc_data_structures::fingerprint::Fingerprint;\n \n use crate::lint;\n-use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::session::config::{OutputType, PrintRequest, Sanitizer, SwitchWithOptPath};\n use crate::session::search_paths::{PathKind, SearchPath};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n@@ -77,13 +76,6 @@ pub struct Session {\n     /// if the value stored here has been affected by path remapping.\n     pub working_dir: (PathBuf, bool),\n \n-    /// This is intended to be used from a single thread.\n-    ///\n-    /// FIXME: there was a previous comment about this not being thread safe,\n-    /// but it's not clear how or why that's the case. The LintBuffer itself is certainly thread\n-    /// safe at least from a \"Rust safety\" standpoint.\n-    pub buffered_lints: Lock<Option<lint::LintBuffer>>,\n-\n     /// Set of `(DiagnosticId, Option<Span>, message)` tuples tracking\n     /// (sub)diagnostics that have been set once, but should not be set again,\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n@@ -366,35 +358,6 @@ impl Session {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n \n-    pub fn buffer_lint<S: Into<MultiSpan>>(\n-        &self,\n-        lint: &'static lint::Lint,\n-        id: ast::NodeId,\n-        sp: S,\n-        msg: &str,\n-    ) {\n-        match *self.buffered_lints.borrow_mut() {\n-            Some(ref mut buffer) => {\n-                buffer.add_lint(lint, id, sp.into(), msg, BuiltinLintDiagnostics::Normal)\n-            }\n-            None => bug!(\"can't buffer lints after HIR lowering\"),\n-        }\n-    }\n-\n-    pub fn buffer_lint_with_diagnostic<S: Into<MultiSpan>>(\n-        &self,\n-        lint: &'static lint::Lint,\n-        id: ast::NodeId,\n-        sp: S,\n-        msg: &str,\n-        diagnostic: BuiltinLintDiagnostics,\n-    ) {\n-        match *self.buffered_lints.borrow_mut() {\n-            Some(ref mut buffer) => buffer.add_lint(lint, id, sp.into(), msg, diagnostic),\n-            None => bug!(\"can't buffer lints after HIR lowering\"),\n-        }\n-    }\n-\n     pub fn reserve_node_ids(&self, count: usize) -> ast::NodeId {\n         let id = self.next_node_id.get();\n \n@@ -1218,7 +1181,6 @@ fn build_session_(\n         sysroot,\n         local_crate_source_file,\n         working_dir,\n-        buffered_lints: Lock::new(Some(Default::default())),\n         one_time_diagnostics: Default::default(),\n         plugin_llvm_passes: OneThread::new(RefCell::new(Vec::new())),\n         plugin_attributes: Lock::new(Vec::new()),"}, {"sha": "52332744d1ad57b6938a98fd3782b24c3cdcf542", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -267,6 +267,7 @@ fn configure_and_expand_inner<'a>(\n             lint_store,\n             &krate,\n             true,\n+            None,\n             rustc_lint::BuiltinCombinedPreExpansionLintPass::new());\n     });\n \n@@ -293,6 +294,8 @@ fn configure_and_expand_inner<'a>(\n         krate\n     });\n \n+    util::check_attr_crate_type(&krate.attrs, &mut resolver.lint_buffer());\n+\n     syntax_ext::plugin_macro_defs::inject(\n         &mut krate, &mut resolver, plugin_info.syntax_exts, sess.edition()\n     );\n@@ -366,7 +369,7 @@ fn configure_and_expand_inner<'a>(\n         for span in missing_fragment_specifiers {\n             let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n             let msg = \"missing fragment specifier\";\n-            sess.buffer_lint(lint, ast::CRATE_NODE_ID, span, msg);\n+            resolver.lint_buffer().buffer_lint(lint, ast::CRATE_NODE_ID, span, msg);\n         }\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n@@ -395,7 +398,7 @@ fn configure_and_expand_inner<'a>(\n     }\n \n     let has_proc_macro_decls = time(sess, \"AST validation\", || {\n-        ast_validation::check_crate(sess, &krate)\n+        ast_validation::check_crate(sess, &krate, &mut resolver.lint_buffer())\n     });\n \n \n@@ -464,7 +467,7 @@ fn configure_and_expand_inner<'a>(\n         info!(\"{} parse sess buffered_lints\", buffered_lints.len());\n         for BufferedEarlyLint{id, span, msg, lint_id} in buffered_lints.drain(..) {\n             let lint = lint::Lint::from_parser_lint_id(lint_id);\n-            sess.buffer_lint(lint, id, span, &msg);\n+            resolver.lint_buffer().buffer_lint(lint, id, span, &msg);\n         }\n     });\n \n@@ -496,6 +499,7 @@ pub fn lower_to_hir(\n             lint_store,\n             &krate,\n             false,\n+            Some(std::mem::take(resolver.lint_buffer())),\n             rustc_lint::BuiltinCombinedEarlyLintPass::new(),\n         )\n     });"}, {"sha": "d0c15073f1640ae2f33f5d768bc32003d557a083", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 59, "deletions": 50, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -526,63 +526,72 @@ pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguat\n     CrateDisambiguator::from(hasher.finish::<Fingerprint>())\n }\n \n+pub(crate) fn check_attr_crate_type(attrs: &[ast::Attribute], lint_buffer: &mut lint::LintBuffer) {\n+    // Unconditionally collect crate types from attributes to make them used\n+    for a in attrs.iter() {\n+        if a.check_name(sym::crate_type) {\n+            if let Some(n) = a.value_str() {\n+                if let Some(_) = categorize_crate_type(n) {\n+                    return;\n+                }\n+\n+                if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().kind {\n+                    let span = spanned.span;\n+                    let lev_candidate = find_best_match_for_name(\n+                        CRATE_TYPES.iter().map(|(k, _)| k),\n+                        &n.as_str(),\n+                        None\n+                    );\n+                    if let Some(candidate) = lev_candidate {\n+                        lint_buffer.buffer_lint_with_diagnostic(\n+                            lint::builtin::UNKNOWN_CRATE_TYPES,\n+                            ast::CRATE_NODE_ID,\n+                            span,\n+                            \"invalid `crate_type` value\",\n+                            lint::builtin::BuiltinLintDiagnostics::\n+                                UnknownCrateTypes(\n+                                    span,\n+                                    \"did you mean\".to_string(),\n+                                    format!(\"\\\"{}\\\"\", candidate)\n+                                )\n+                        );\n+                    } else {\n+                        lint_buffer.buffer_lint(\n+                            lint::builtin::UNKNOWN_CRATE_TYPES,\n+                            ast::CRATE_NODE_ID,\n+                            span,\n+                            \"invalid `crate_type` value\"\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+const CRATE_TYPES: &[(Symbol, config::CrateType)] = &[\n+    (sym::rlib, config::CrateType::Rlib),\n+    (sym::dylib, config::CrateType::Dylib),\n+    (sym::cdylib, config::CrateType::Cdylib),\n+    (sym::lib, config::default_lib_output()),\n+    (sym::staticlib, config::CrateType::Staticlib),\n+    (sym::proc_dash_macro, config::CrateType::ProcMacro),\n+    (sym::bin, config::CrateType::Executable),\n+];\n+\n+fn categorize_crate_type(s: Symbol) -> Option<config::CrateType> {\n+    Some(CRATE_TYPES.iter().find(|(key, _)| *key == s)?.1)\n+}\n+\n pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<config::CrateType> {\n     // Unconditionally collect crate types from attributes to make them used\n     let attr_types: Vec<config::CrateType> = attrs\n         .iter()\n         .filter_map(|a| {\n             if a.check_name(sym::crate_type) {\n                 match a.value_str() {\n-                    Some(sym::rlib) => Some(config::CrateType::Rlib),\n-                    Some(sym::dylib) => Some(config::CrateType::Dylib),\n-                    Some(sym::cdylib) => Some(config::CrateType::Cdylib),\n-                    Some(sym::lib) => Some(config::default_lib_output()),\n-                    Some(sym::staticlib) => Some(config::CrateType::Staticlib),\n-                    Some(sym::proc_dash_macro) => Some(config::CrateType::ProcMacro),\n-                    Some(sym::bin) => Some(config::CrateType::Executable),\n-                    Some(n) => {\n-                        let crate_types = vec![\n-                            sym::rlib,\n-                            sym::dylib,\n-                            sym::cdylib,\n-                            sym::lib,\n-                            sym::staticlib,\n-                            sym::proc_dash_macro,\n-                            sym::bin\n-                        ];\n-\n-                        if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().kind {\n-                            let span = spanned.span;\n-                            let lev_candidate = find_best_match_for_name(\n-                                crate_types.iter(),\n-                                &n.as_str(),\n-                                None\n-                            );\n-                            if let Some(candidate) = lev_candidate {\n-                                session.buffer_lint_with_diagnostic(\n-                                    lint::builtin::UNKNOWN_CRATE_TYPES,\n-                                    ast::CRATE_NODE_ID,\n-                                    span,\n-                                    \"invalid `crate_type` value\",\n-                                    lint::builtin::BuiltinLintDiagnostics::\n-                                        UnknownCrateTypes(\n-                                            span,\n-                                            \"did you mean\".to_string(),\n-                                            format!(\"\\\"{}\\\"\", candidate)\n-                                        )\n-                                );\n-                            } else {\n-                                session.buffer_lint(\n-                                    lint::builtin::UNKNOWN_CRATE_TYPES,\n-                                    ast::CRATE_NODE_ID,\n-                                    span,\n-                                    \"invalid `crate_type` value\"\n-                                );\n-                            }\n-                        }\n-                        None\n-                    }\n-                    None => None\n+                    Some(s) => categorize_crate_type(s),\n+                    _ => None,\n                 }\n             } else {\n                 None"}, {"sha": "e625334040e0ab31f55fe28175f9902cd2137c4f", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -73,6 +73,8 @@ struct AstValidator<'a> {\n     /// these booleans.\n     warning_period_57979_didnt_record_next_impl_trait: bool,\n     warning_period_57979_impl_trait_in_proj: bool,\n+\n+    lint_buffer: &'a mut lint::LintBuffer,\n }\n \n impl<'a> AstValidator<'a> {\n@@ -229,7 +231,7 @@ impl<'a> AstValidator<'a> {\n         err.emit();\n     }\n \n-    fn check_decl_no_pat<ReportFn: Fn(Span, bool)>(&self, decl: &FnDecl, report_err: ReportFn) {\n+    fn check_decl_no_pat<F: FnMut(Span, bool)>(decl: &FnDecl, mut report_err: F) {\n         for arg in &decl.inputs {\n             match arg.pat.kind {\n                 PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), _, None) |\n@@ -460,7 +462,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         match ty.kind {\n             TyKind::BareFn(ref bfty) => {\n                 self.check_fn_decl(&bfty.decl);\n-                self.check_decl_no_pat(&bfty.decl, |span, _| {\n+                Self::check_decl_no_pat(&bfty.decl, |span, _| {\n                     struct_span_err!(self.session, span, E0561,\n                                      \"patterns aren't allowed in function pointer types\").emit();\n                 });\n@@ -483,7 +485,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             TyKind::ImplTrait(_, ref bounds) => {\n                 if self.is_impl_trait_banned {\n                     if self.warning_period_57979_impl_trait_in_proj {\n-                        self.session.buffer_lint(\n+                        self.lint_buffer.buffer_lint(\n                             NESTED_IMPL_TRAIT, ty.id, ty.span,\n                             \"`impl Trait` is not allowed in path parameters\");\n                     } else {\n@@ -494,7 +496,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n                 if let Some(outer_impl_trait) = self.outer_impl_trait {\n                     if outer_impl_trait.should_warn_instead_of_error() {\n-                        self.session.buffer_lint_with_diagnostic(\n+                        self.lint_buffer.buffer_lint_with_diagnostic(\n                             NESTED_IMPL_TRAIT, ty.id, ty.span,\n                             \"nested `impl Trait` is not allowed\",\n                             BuiltinLintDiagnostics::NestedImplTrait {\n@@ -634,9 +636,9 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         self.check_trait_fn_not_async(trait_item.span, sig.header.asyncness.node);\n                         self.check_trait_fn_not_const(sig.header.constness);\n                         if block.is_none() {\n-                            self.check_decl_no_pat(&sig.decl, |span, mut_ident| {\n+                            Self::check_decl_no_pat(&sig.decl, |span, mut_ident| {\n                                 if mut_ident {\n-                                    self.session.buffer_lint(\n+                                    self.lint_buffer.buffer_lint(\n                                         lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY,\n                                         trait_item.id, span,\n                                         \"patterns aren't allowed in methods without bodies\");\n@@ -655,7 +657,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 if attr::contains_name(&item.attrs, sym::warn_directory_ownership) {\n                     let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n                     let msg = \"cannot declare a new module at this location\";\n-                    self.session.buffer_lint(lint, item.id, item.span, msg);\n+                    self.lint_buffer.buffer_lint(lint, item.id, item.span, msg);\n                 }\n             }\n             ItemKind::Union(ref vdata, _) => {\n@@ -686,7 +688,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         match fi.kind {\n             ForeignItemKind::Fn(ref decl, _) => {\n                 self.check_fn_decl(decl);\n-                self.check_decl_no_pat(decl, |span, _| {\n+                Self::check_decl_no_pat(decl, |span, _| {\n                     struct_span_err!(self.session, span, E0130,\n                                      \"patterns aren't allowed in foreign function declarations\")\n                         .span_label(span, \"pattern not allowed in foreign function\").emit();\n@@ -840,7 +842,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n }\n \n-pub fn check_crate(session: &Session, krate: &Crate) -> bool {\n+pub fn check_crate(session: &Session, krate: &Crate, lints: &mut lint::LintBuffer) -> bool {\n     let mut validator = AstValidator {\n         session,\n         has_proc_macro_decls: false,\n@@ -849,6 +851,7 @@ pub fn check_crate(session: &Session, krate: &Crate) -> bool {\n         is_assoc_ty_bound_banned: false,\n         warning_period_57979_didnt_record_next_impl_trait: false,\n         warning_period_57979_impl_trait_in_proj: false,\n+        lint_buffer: lints,\n     };\n     visit::walk_crate(&mut validator, krate);\n "}, {"sha": "44b7a9fa047c27499896aad1b81f3ed726ba1d06", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -232,7 +232,7 @@ impl Resolver<'_> {\n                     directive.span.is_dummy() => {\n                     if let ImportDirectiveSubclass::MacroUse = directive.subclass {\n                         if !directive.span.is_dummy() {\n-                            self.session.buffer_lint(\n+                            self.lint_buffer.buffer_lint(\n                                 lint::builtin::MACRO_USE_EXTERN_CRATE,\n                                 directive.id,\n                                 directive.span,\n@@ -250,7 +250,7 @@ impl Resolver<'_> {\n                 ImportDirectiveSubclass::MacroUse => {\n                     let lint = lint::builtin::UNUSED_IMPORTS;\n                     let msg = \"unused `#[macro_use]` import\";\n-                    self.session.buffer_lint(lint, directive.id, directive.span, msg);\n+                    self.lint_buffer.buffer_lint(lint, directive.id, directive.span, msg);\n                 }\n                 _ => {}\n             }\n@@ -312,7 +312,7 @@ impl Resolver<'_> {\n                 \"remove the unused import\"\n             };\n \n-            visitor.r.session.buffer_lint_with_diagnostic(\n+            visitor.r.lint_buffer.buffer_lint_with_diagnostic(\n                 lint::builtin::UNUSED_IMPORTS,\n                 unused.use_tree_id,\n                 ms,"}, {"sha": "004d86cee8ded00b520759ab5e5e1daa44f30585", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -1548,7 +1548,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                             if is_expected(ctor_res) &&\n                                self.r.is_accessible_from(ctor_vis, self.parent_scope.module) {\n                                 let lint = lint::builtin::LEGACY_CONSTRUCTOR_VISIBILITY;\n-                                self.r.session.buffer_lint(lint, id, span,\n+                                self.r.lint_buffer.buffer_lint(lint, id, span,\n                                     \"private struct constructors are not usable through \\\n                                      re-exports in outer modules\",\n                                 );\n@@ -1774,7 +1774,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             };\n             if result.base_res() == unqualified_result {\n                 let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n-                self.r.session.buffer_lint(lint, id, span, \"unnecessary qualification\")\n+                self.r.lint_buffer.buffer_lint(lint, id, span, \"unnecessary qualification\")\n             }\n         }\n \n@@ -2111,7 +2111,7 @@ impl<'a> Resolver<'a> {\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n         for (id, span) in late_resolution_visitor.diagnostic_metadata.unused_labels.iter() {\n-            self.session.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");\n+            self.lint_buffer.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");\n         }\n     }\n }"}, {"sha": "b45eb356bdbd02f404858f32e97e1b1ae8256ee2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -962,6 +962,8 @@ pub struct Resolver<'a> {\n     /// Stores enum visibilities to properly build a reduced graph\n     /// when visiting the correspondent variants.\n     variant_vis: DefIdMap<ty::Visibility>,\n+\n+    lint_buffer: lint::LintBuffer,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1081,6 +1083,10 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         let expn_id = self.definitions.expansion_that_defined(def_id.index);\n         self.has_derives(expn_id, derives)\n     }\n+\n+    fn lint_buffer(&mut self) -> &mut lint::LintBuffer {\n+        &mut self.lint_buffer\n+    }\n }\n \n impl<'a> Resolver<'a> {\n@@ -1227,10 +1233,15 @@ impl<'a> Resolver<'a> {\n                 features.declared_lib_features.iter().map(|(feat, ..)| *feat)\n                     .chain(features.declared_lang_features.iter().map(|(feat, ..)| *feat))\n                     .collect(),\n-            variant_vis: Default::default()\n+            variant_vis: Default::default(),\n+            lint_buffer: lint::LintBuffer::default(),\n         }\n     }\n \n+    pub fn lint_buffer(&mut self) -> &mut lint::LintBuffer {\n+        &mut self.lint_buffer\n+    }\n+\n     pub fn arenas() -> ResolverArenas<'a> {\n         Default::default()\n     }\n@@ -1653,7 +1664,7 @@ impl<'a> Resolver<'a> {\n             match result {\n                 Ok(binding) => {\n                     if let Some(node_id) = poisoned {\n-                        self.session.buffer_lint_with_diagnostic(\n+                        self.lint_buffer.buffer_lint_with_diagnostic(\n                             lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n                             node_id, ident.span,\n                             &format!(\"cannot find {} `{}` in this scope\", ns.descr(), ident),\n@@ -2118,7 +2129,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn lint_if_path_starts_with_module(\n-        &self,\n+        &mut self,\n         crate_lint: CrateLint,\n         path: &[Segment],\n         path_span: Span,\n@@ -2169,7 +2180,7 @@ impl<'a> Resolver<'a> {\n \n         let diag = lint::builtin::BuiltinLintDiagnostics\n             ::AbsPathWithModule(diag_span);\n-        self.session.buffer_lint_with_diagnostic(\n+        self.lint_buffer.buffer_lint_with_diagnostic(\n             lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n             diag_id, diag_span,\n             \"absolute paths must start with `self`, `super`, \\\n@@ -2419,7 +2430,7 @@ impl<'a> Resolver<'a> {\n         for &(span_use, span_def) in &self.macro_expanded_macro_export_errors {\n             let msg = \"macro-expanded `macro_export` macros from the current crate \\\n                        cannot be referred to by absolute paths\";\n-            self.session.buffer_lint_with_diagnostic(\n+            self.lint_buffer.buffer_lint_with_diagnostic(\n                 lint::builtin::MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n                 CRATE_NODE_ID, span_use, msg,\n                 lint::builtin::BuiltinLintDiagnostics::"}, {"sha": "84d3d3a48b03923410c3a53915a1e5d293ce334a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -247,9 +247,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n         Ok(InvocationRes::Single(ext))\n     }\n \n-    fn check_unused_macros(&self) {\n+    fn check_unused_macros(&mut self) {\n         for (&node_id, &span) in self.unused_macros.iter() {\n-            self.session.buffer_lint(\n+            self.lint_buffer.buffer_lint(\n                 lint::builtin::UNUSED_MACROS, node_id, span, \"unused macro definition\"\n             );\n         }\n@@ -789,15 +789,17 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn check_stability_and_deprecation(&self, ext: &SyntaxExtension, path: &ast::Path) {\n+    fn check_stability_and_deprecation(&mut self, ext: &SyntaxExtension, path: &ast::Path) {\n         let span = path.span;\n         if let Some(stability) = &ext.stability {\n             if let StabilityLevel::Unstable { reason, issue, is_soft } = stability.level {\n                 let feature = stability.feature;\n                 if !self.active_features.contains(&feature) && !span.allows_unstable(feature) {\n                     let node_id = ast::CRATE_NODE_ID;\n-                    let soft_handler =\n-                        |lint, span, msg: &_| self.session.buffer_lint(lint, node_id, span, msg);\n+                    let lint_buffer = &mut self.lint_buffer;\n+                    let soft_handler = |lint, span, msg: &_| {\n+                        lint_buffer.buffer_lint(lint, node_id, span, msg)\n+                    };\n                     stability::report_unstable(\n                         self.session, feature, reason, issue, is_soft, span, soft_handler\n                     );\n@@ -807,14 +809,14 @@ impl<'a> Resolver<'a> {\n                 let path = pprust::path_to_string(path);\n                 let (message, lint) = stability::rustc_deprecation_message(depr, &path);\n                 stability::early_report_deprecation(\n-                    self.session, &message, depr.suggestion, lint, span\n+                    &mut self.lint_buffer, &message, depr.suggestion, lint, span\n                 );\n             }\n         }\n         if let Some(depr) = &ext.deprecation {\n             let path = pprust::path_to_string(&path);\n             let (message, lint) = stability::deprecation_message(depr, &path);\n-            stability::early_report_deprecation(self.session, &message, None, lint, span);\n+            stability::early_report_deprecation(&mut self.lint_buffer, &message, None, lint, span);\n         }\n     }\n "}, {"sha": "c39f0c90f98a5e6de74ed3e2e1b31b74932093f5", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -496,7 +496,7 @@ impl<'a> Resolver<'a> {\n                         if let (&NameBindingKind::Res(_, true), &NameBindingKind::Res(_, true)) =\n                                (&old_binding.kind, &binding.kind) {\n \n-                            this.session.buffer_lint_with_diagnostic(\n+                            this.lint_buffer.buffer_lint_with_diagnostic(\n                                 DUPLICATE_MACRO_EXPORTS,\n                                 CRATE_NODE_ID,\n                                 binding.span,\n@@ -979,7 +979,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                    !max_vis.get().is_at_least(directive.vis.get(), &*self) {\n                     let msg =\n                     \"glob import doesn't reexport anything because no candidate is public enough\";\n-                    self.r.session.buffer_lint(UNUSED_IMPORTS, directive.id, directive.span, msg);\n+                    self.r.lint_buffer.buffer_lint(\n+                        UNUSED_IMPORTS, directive.id, directive.span, msg,\n+                    );\n                 }\n                 return None;\n             }\n@@ -1148,7 +1150,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                    re-exported (error E0365), consider declaring with \\\n                                    `pub`\",\n                                    ident);\n-                self.r.session.buffer_lint(PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n+                self.r.lint_buffer.buffer_lint(PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n                                          directive.id,\n                                          directive.span,\n                                          &msg);\n@@ -1273,7 +1275,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             let mut redundant_spans: Vec<_> = redundant_span.present_items().collect();\n             redundant_spans.sort();\n             redundant_spans.dedup();\n-            self.r.session.buffer_lint_with_diagnostic(\n+            self.r.lint_buffer.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n                 directive.id,\n                 directive.span,"}, {"sha": "d79b691058790f58ed5444b73774de97b8a331a0", "filename": "src/libsyntax_expand/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibsyntax_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6e47851b51a413db5d721f25d714653e7549fd/src%2Flibsyntax_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbase.rs?ref=ab6e47851b51a413db5d721f25d714653e7549fd", "patch": "@@ -858,7 +858,7 @@ pub trait Resolver {\n         &mut self, invoc: &Invocation, eager_expansion_root: ExpnId, force: bool\n     ) -> Result<InvocationRes, Indeterminate>;\n \n-    fn check_unused_macros(&self);\n+    fn check_unused_macros(&mut self);\n \n     fn has_derives(&self, expn_id: ExpnId, derives: SpecialDerives) -> bool;\n     fn add_derives(&mut self, expn_id: ExpnId, derives: SpecialDerives);\n@@ -1053,7 +1053,7 @@ impl<'a> ExtCtxt<'a> {\n         Symbol::intern(st)\n     }\n \n-    pub fn check_unused_macros(&self) {\n+    pub fn check_unused_macros(&mut self) {\n         self.resolver.check_unused_macros();\n     }\n "}]}