{"sha": "8ffe4068a6d8ff79cfccc0244a96e728387bbeb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZmU0MDY4YTZkOGZmNzljZmNjYzAyNDRhOTZlNzI4Mzg3YmJlYjY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-23T17:26:38Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-23T17:26:38Z"}, "message": "keep the AST node-id when lowering ExprKind::Range\n\nWhen the Range expression is the root of a constant, its node-id is\nused for the def-id of the body, so it has to be preserved in the AST ->\nHIR lowering.\n\nFixes #40749.", "tree": {"sha": "8cde636b4d62f99c74e21b62e5edb2a8ccfcd13a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cde636b4d62f99c74e21b62e5edb2a8ccfcd13a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ffe4068a6d8ff79cfccc0244a96e728387bbeb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ffe4068a6d8ff79cfccc0244a96e728387bbeb6", "html_url": "https://github.com/rust-lang/rust/commit/8ffe4068a6d8ff79cfccc0244a96e728387bbeb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ffe4068a6d8ff79cfccc0244a96e728387bbeb6/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90346eae18e83887517e096c17678a74838ff995", "url": "https://api.github.com/repos/rust-lang/rust/commits/90346eae18e83887517e096c17678a74838ff995", "html_url": "https://github.com/rust-lang/rust/commit/90346eae18e83887517e096c17678a74838ff995"}], "stats": {"total": 111, "additions": 52, "deletions": 59}, "files": [{"sha": "6ca0c971ea4979951919b7e1e6e388e443acb8b9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 36, "deletions": 59, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8ffe4068a6d8ff79cfccc0244a96e728387bbeb6/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ffe4068a6d8ff79cfccc0244a96e728387bbeb6/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8ffe4068a6d8ff79cfccc0244a96e728387bbeb6", "patch": "@@ -1900,57 +1900,45 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprIndex(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n             ExprKind::Range(ref e1, ref e2, lims) => {\n-                fn make_struct(this: &mut LoweringContext,\n-                               ast_expr: &Expr,\n-                               path: &[&str],\n-                               fields: &[(&str, &P<Expr>)]) -> hir::Expr {\n-                    let struct_path = &iter::once(&\"ops\").chain(path).map(|s| *s)\n-                                                         .collect::<Vec<_>>();\n-                    let unstable_span = this.allow_internal_unstable(\"...\", ast_expr.span);\n-\n-                    if fields.len() == 0 {\n-                        this.expr_std_path(unstable_span, struct_path,\n-                                           ast_expr.attrs.clone())\n-                    } else {\n-                        let fields = fields.into_iter().map(|&(s, e)| {\n-                            let expr = P(this.lower_expr(&e));\n-                            let unstable_span = this.allow_internal_unstable(\"...\", e.span);\n-                            this.field(Symbol::intern(s), expr, unstable_span)\n-                        }).collect();\n-                        let attrs = ast_expr.attrs.clone();\n-\n-                        this.expr_std_struct(unstable_span, struct_path, fields, None, attrs)\n-                    }\n-                }\n-\n                 use syntax::ast::RangeLimits::*;\n \n-                return match (e1, e2, lims) {\n-                    (&None,         &None,         HalfOpen) =>\n-                        make_struct(self, e, &[\"RangeFull\"], &[]),\n-\n-                    (&Some(ref e1), &None,         HalfOpen) =>\n-                        make_struct(self, e, &[\"RangeFrom\"],\n-                                             &[(\"start\", e1)]),\n-\n-                    (&None,         &Some(ref e2), HalfOpen) =>\n-                        make_struct(self, e, &[\"RangeTo\"],\n-                                             &[(\"end\", e2)]),\n-\n-                    (&Some(ref e1), &Some(ref e2), HalfOpen) =>\n-                        make_struct(self, e, &[\"Range\"],\n-                                             &[(\"start\", e1), (\"end\", e2)]),\n-\n-                    (&None,         &Some(ref e2), Closed)   =>\n-                        make_struct(self, e, &[\"RangeToInclusive\"],\n-                                             &[(\"end\", e2)]),\n-\n-                    (&Some(ref e1), &Some(ref e2), Closed)   =>\n-                        make_struct(self, e, &[\"RangeInclusive\", \"NonEmpty\"],\n-                                             &[(\"start\", e1), (\"end\", e2)]),\n+                let (path, variant) = match (e1, e2, lims) {\n+                    (&None, &None, HalfOpen) => (\"RangeFull\", None),\n+                    (&Some(..), &None, HalfOpen) => (\"RangeFrom\", None),\n+                    (&None, &Some(..), HalfOpen) => (\"RangeTo\", None),\n+                    (&Some(..), &Some(..), HalfOpen) => (\"Range\", None),\n+                    (&None, &Some(..), Closed) => (\"RangeToInclusive\", None),\n+                    (&Some(..), &Some(..), Closed) => (\"RangeInclusive\", Some(\"NonEmpty\")),\n+                    (_, &None, Closed) =>\n+                        panic!(self.diagnostic().span_fatal(\n+                            e.span, \"inclusive range with no end\")),\n+                };\n \n-                    _ => panic!(self.diagnostic()\n-                                    .span_fatal(e.span, \"inclusive range with no end\")),\n+                let fields =\n+                    e1.iter().map(|e| (\"start\", e)).chain(e2.iter().map(|e| (\"end\", e)))\n+                    .map(|(s, e)| {\n+                        let expr = P(self.lower_expr(&e));\n+                        let unstable_span = self.allow_internal_unstable(\"...\", e.span);\n+                        self.field(Symbol::intern(s), expr, unstable_span)\n+                    }).collect::<P<[hir::Field]>>();\n+\n+                let is_unit = fields.is_empty();\n+                let unstable_span = self.allow_internal_unstable(\"...\", e.span);\n+                let struct_path =\n+                    iter::once(\"ops\").chain(iter::once(path)).chain(variant)\n+                    .collect::<Vec<_>>();\n+                let struct_path = self.std_path(unstable_span, &struct_path, is_unit);\n+                let struct_path = hir::QPath::Resolved(None, P(struct_path));\n+\n+                return hir::Expr {\n+                    id: self.lower_node_id(e.id),\n+                    node: if is_unit {\n+                        hir::ExprPath(struct_path)\n+                    } else {\n+                        hir::ExprStruct(struct_path, fields, None)\n+                    },\n+                    span: unstable_span,\n+                    attrs: e.attrs.clone(),\n                 };\n             }\n             ExprKind::Path(ref qself, ref path) => {\n@@ -2613,17 +2601,6 @@ impl<'a> LoweringContext<'a> {\n         P(self.expr(sp, hir::ExprTup(exprs), ThinVec::new()))\n     }\n \n-    fn expr_std_struct(&mut self,\n-                       span: Span,\n-                       components: &[&str],\n-                       fields: hir::HirVec<hir::Field>,\n-                       e: Option<P<hir::Expr>>,\n-                       attrs: ThinVec<Attribute>) -> hir::Expr {\n-        let path = self.std_path(span, components, false);\n-        let qpath = hir::QPath::Resolved(None, P(path));\n-        self.expr(span, hir::ExprStruct(qpath, fields, e), attrs)\n-    }\n-\n     fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> hir::Expr {\n         hir::Expr {\n             id: self.next_id(),"}, {"sha": "261ed49d10c1ea215ec06a10525a3fae911d0593", "filename": "src/test/compile-fail/issue-40749.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ffe4068a6d8ff79cfccc0244a96e728387bbeb6/src%2Ftest%2Fcompile-fail%2Fissue-40749.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ffe4068a6d8ff79cfccc0244a96e728387bbeb6/src%2Ftest%2Fcompile-fail%2Fissue-40749.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40749.rs?ref=8ffe4068a6d8ff79cfccc0244a96e728387bbeb6", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    [0; ..10];\n+    //~^ ERROR mismatched types\n+    //~| expected type `usize`\n+    //~| found type `std::ops::RangeTo<{integer}>`\n+}"}]}