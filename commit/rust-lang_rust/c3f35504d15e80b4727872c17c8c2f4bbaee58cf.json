{"sha": "c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "node_id": "C_kwDOAAsO6NoAKGMzZjM1NTA0ZDE1ZTgwYjQ3Mjc4NzJjMTdjOGMyZjRiYmFlZTU4Y2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-19T05:46:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-19T05:46:45Z"}, "message": "Auto merge of #98189 - mystor:fast_ident_literal, r=eddyb\n\nproc_macro/bridge: stop using a remote object handle for proc_macro Ident and Literal\n\nThis is the fourth part of https://github.com/rust-lang/rust/pull/86822, split off as requested in https://github.com/rust-lang/rust/pull/86822#pullrequestreview-1008655452. This patch transforms the `Ident` and `Group` types into structs serialized over IPC rather than handles.\n\nSymbol values are interned on both the client and server when deserializing, to avoid unnecessary string copies and keep the size of `TokenTree` down. To do the interning efficiently on the client, the proc-macro crate is given a vendored version of the fxhash hasher, as `SipHash` appeared to cause performance issues. This was done rather than depending on `rustc_hash` as it is unfortunately difficult to depend on crates from within `proc_macro` due to it being built at the same time as `std`.\n\nIn addition, a custom arena allocator and symbol store was also added, inspired by those in `rustc_arena` and `rustc_span`. To prevent symbol re-use across multiple invocations of a macro on the same thread, a new range of `Symbol` names are used for each invocation of the macro, and symbols from previous invocations are cleaned-up.\n\nIn order to keep `Ident` creation efficient, a special ASCII-only case was added to perform ident validation without using RPC for simple identifiers. Full identifier validation couldn't be easily added, as it would require depending on the `rustc_lexer` and `unicode-normalization` crates from within `proc_macro`. Unicode identifiers are validated and normalized using RPC.\n\nSee the individual commit messages for more details on trade-offs and design decisions behind these patches.", "tree": {"sha": "8af534a987d8f59454b90ac7781c4994678fdbe9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8af534a987d8f59454b90ac7781c4994678fdbe9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "html_url": "https://github.com/rust-lang/rust/commit/c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96c2df810b0b681fee63cae11ca63844792b6190", "url": "https://api.github.com/repos/rust-lang/rust/commits/96c2df810b0b681fee63cae11ca63844792b6190", "html_url": "https://github.com/rust-lang/rust/commit/96c2df810b0b681fee63cae11ca63844792b6190"}, {"sha": "c4acac64432aa6026ae24422abfee7c3014576e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4acac64432aa6026ae24422abfee7c3014576e3", "html_url": "https://github.com/rust-lang/rust/commit/c4acac64432aa6026ae24422abfee7c3014576e3"}], "stats": {"total": 1236, "additions": 857, "deletions": 379}, "files": [{"sha": "176c77ca6edc6af8439fc65bfadfe1f711b112a5", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 173, "deletions": 229, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -11,13 +11,14 @@ use rustc_parse::lexer::nfc_normalize;\n use rustc_parse::parse_stream_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_span::def_id::CrateNum;\n-use rustc_span::symbol::{self, kw, sym, Symbol};\n+use rustc_span::symbol::{self, sym, Symbol};\n use rustc_span::{BytePos, FileName, Pos, SourceFile, Span};\n \n-use pm::bridge::{server, DelimSpan, ExpnGlobals, Group, Punct, TokenTree};\n+use pm::bridge::{\n+    server, DelimSpan, ExpnGlobals, Group, Ident, LitKind, Literal, Punct, TokenTree,\n+};\n use pm::{Delimiter, Level, LineColumn};\n use std::ops::Bound;\n-use std::{ascii, panic};\n \n trait FromInternal<T> {\n     fn from_internal(x: T) -> Self;\n@@ -49,9 +50,40 @@ impl ToInternal<token::Delimiter> for Delimiter {\n     }\n }\n \n-impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n-    for Vec<TokenTree<TokenStream, Span, Ident, Literal>>\n-{\n+impl FromInternal<token::LitKind> for LitKind {\n+    fn from_internal(kind: token::LitKind) -> Self {\n+        match kind {\n+            token::Byte => LitKind::Byte,\n+            token::Char => LitKind::Char,\n+            token::Integer => LitKind::Integer,\n+            token::Float => LitKind::Float,\n+            token::Str => LitKind::Str,\n+            token::StrRaw(n) => LitKind::StrRaw(n),\n+            token::ByteStr => LitKind::ByteStr,\n+            token::ByteStrRaw(n) => LitKind::ByteStrRaw(n),\n+            token::Err => LitKind::Err,\n+            token::Bool => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl ToInternal<token::LitKind> for LitKind {\n+    fn to_internal(self) -> token::LitKind {\n+        match self {\n+            LitKind::Byte => token::Byte,\n+            LitKind::Char => token::Char,\n+            LitKind::Integer => token::Integer,\n+            LitKind::Float => token::Float,\n+            LitKind::Str => token::Str,\n+            LitKind::StrRaw(n) => token::StrRaw(n),\n+            LitKind::ByteStr => token::ByteStr,\n+            LitKind::ByteStrRaw(n) => token::ByteStrRaw(n),\n+            LitKind::Err => token::Err,\n+        }\n+    }\n+}\n+\n+impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)> for Vec<TokenTree<TokenStream, Span, Symbol>> {\n     fn from_internal((stream, rustc): (TokenStream, &mut Rustc<'_, '_>)) -> Self {\n         use rustc_ast::token::*;\n \n@@ -135,16 +167,22 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n                 Question => op(\"?\"),\n                 SingleQuote => op(\"'\"),\n \n-                Ident(name, false) if name == kw::DollarCrate => trees.push(TokenTree::Ident(Ident::dollar_crate(span))),\n-                Ident(name, is_raw) => trees.push(TokenTree::Ident(Ident::new(rustc.sess(), name, is_raw, span))),\n+                Ident(sym, is_raw) => trees.push(TokenTree::Ident(Ident { sym, is_raw, span })),\n                 Lifetime(name) => {\n                     let ident = symbol::Ident::new(name, span).without_first_quote();\n                     trees.extend([\n                         TokenTree::Punct(Punct { ch: b'\\'', joint: true, span }),\n-                        TokenTree::Ident(Ident::new(rustc.sess(), ident.name, false, span)),\n+                        TokenTree::Ident(Ident { sym: ident.name, is_raw: false, span }),\n                     ]);\n                 }\n-                Literal(lit) => trees.push(TokenTree::Literal(self::Literal { lit, span })),\n+                Literal(token::Lit { kind, symbol, suffix }) => {\n+                    trees.push(TokenTree::Literal(self::Literal {\n+                        kind: FromInternal::from_internal(kind),\n+                        symbol,\n+                        suffix,\n+                        span,\n+                    }));\n+                }\n                 DocComment(_, attr_style, data) => {\n                     let mut escaped = String::new();\n                     for ch in data.as_str().chars() {\n@@ -170,7 +208,7 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n                 }\n \n                 Interpolated(nt) if let NtIdent(ident, is_raw) = *nt => {\n-                    trees.push(TokenTree::Ident(Ident::new(rustc.sess(), ident.name, is_raw, ident.span)))\n+                    trees.push(TokenTree::Ident(Ident { sym: ident.name, is_raw, span: ident.span }))\n                 }\n \n                 Interpolated(nt) => {\n@@ -200,11 +238,12 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n     }\n }\n \n-impl ToInternal<TokenStream> for TokenTree<TokenStream, Span, Ident, Literal> {\n+impl ToInternal<TokenStream> for (TokenTree<TokenStream, Span, Symbol>, &mut Rustc<'_, '_>) {\n     fn to_internal(self) -> TokenStream {\n         use rustc_ast::token::*;\n \n-        let (ch, joint, span) = match self {\n+        let (tree, rustc) = self;\n+        let (ch, joint, span) = match tree {\n             TokenTree::Punct(Punct { ch, joint, span }) => (ch, joint, span),\n             TokenTree::Group(Group { delimiter, stream, span: DelimSpan { open, close, .. } }) => {\n                 return tokenstream::TokenTree::Delimited(\n@@ -215,10 +254,13 @@ impl ToInternal<TokenStream> for TokenTree<TokenStream, Span, Ident, Literal> {\n                 .into();\n             }\n             TokenTree::Ident(self::Ident { sym, is_raw, span }) => {\n+                rustc.sess().symbol_gallery.insert(sym, span);\n                 return tokenstream::TokenTree::token(Ident(sym, is_raw), span).into();\n             }\n             TokenTree::Literal(self::Literal {\n-                lit: token::Lit { kind: token::Integer, symbol, suffix },\n+                kind: self::LitKind::Integer,\n+                symbol,\n+                suffix,\n                 span,\n             }) if symbol.as_str().starts_with('-') => {\n                 let minus = BinOp(BinOpToken::Minus);\n@@ -229,7 +271,9 @@ impl ToInternal<TokenStream> for TokenTree<TokenStream, Span, Ident, Literal> {\n                 return [a, b].into_iter().collect();\n             }\n             TokenTree::Literal(self::Literal {\n-                lit: token::Lit { kind: token::Float, symbol, suffix },\n+                kind: self::LitKind::Float,\n+                symbol,\n+                suffix,\n                 span,\n             }) if symbol.as_str().starts_with('-') => {\n                 let minus = BinOp(BinOpToken::Minus);\n@@ -239,8 +283,12 @@ impl ToInternal<TokenStream> for TokenTree<TokenStream, Span, Ident, Literal> {\n                 let b = tokenstream::TokenTree::token(float, span);\n                 return [a, b].into_iter().collect();\n             }\n-            TokenTree::Literal(self::Literal { lit, span }) => {\n-                return tokenstream::TokenTree::token(Literal(lit), span).into();\n+            TokenTree::Literal(self::Literal { kind, symbol, suffix, span }) => {\n+                return tokenstream::TokenTree::token(\n+                    TokenKind::lit(kind.to_internal(), symbol, suffix),\n+                    span,\n+                )\n+                .into();\n             }\n         };\n \n@@ -289,40 +337,6 @@ impl ToInternal<rustc_errors::Level> for Level {\n \n pub struct FreeFunctions;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Ident {\n-    sym: Symbol,\n-    is_raw: bool,\n-    span: Span,\n-}\n-\n-impl Ident {\n-    fn new(sess: &ParseSess, sym: Symbol, is_raw: bool, span: Span) -> Ident {\n-        let sym = nfc_normalize(sym.as_str());\n-        let string = sym.as_str();\n-        if !rustc_lexer::is_ident(string) {\n-            panic!(\"`{:?}` is not a valid identifier\", string)\n-        }\n-        if is_raw && !sym.can_be_raw() {\n-            panic!(\"`{}` cannot be a raw identifier\", string);\n-        }\n-        sess.symbol_gallery.insert(sym, span);\n-        Ident { sym, is_raw, span }\n-    }\n-\n-    fn dollar_crate(span: Span) -> Ident {\n-        // `$crate` is accepted as an ident only if it comes from the compiler.\n-        Ident { sym: kw::DollarCrate, is_raw: false, span }\n-    }\n-}\n-\n-// FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n-#[derive(Clone, Debug)]\n-pub struct Literal {\n-    lit: token::Lit,\n-    span: Span,\n-}\n-\n pub(crate) struct Rustc<'a, 'b> {\n     ecx: &'a mut ExtCtxt<'b>,\n     def_site: Span,\n@@ -348,21 +362,16 @@ impl<'a, 'b> Rustc<'a, 'b> {\n     fn sess(&self) -> &ParseSess {\n         self.ecx.parse_sess()\n     }\n-\n-    fn lit(&mut self, kind: token::LitKind, symbol: Symbol, suffix: Option<Symbol>) -> Literal {\n-        Literal { lit: token::Lit::new(kind, symbol, suffix), span: self.call_site }\n-    }\n }\n \n impl server::Types for Rustc<'_, '_> {\n     type FreeFunctions = FreeFunctions;\n     type TokenStream = TokenStream;\n-    type Ident = Ident;\n-    type Literal = Literal;\n     type SourceFile = Lrc<SourceFile>;\n     type MultiSpan = Vec<Span>;\n     type Diagnostic = Diagnostic;\n     type Span = Span;\n+    type Symbol = Symbol;\n }\n \n impl server::FreeFunctions for Rustc<'_, '_> {\n@@ -376,6 +385,57 @@ impl server::FreeFunctions for Rustc<'_, '_> {\n     fn track_path(&mut self, path: &str) {\n         self.sess().file_depinfo.borrow_mut().insert(Symbol::intern(path));\n     }\n+\n+    fn literal_from_str(&mut self, s: &str) -> Result<Literal<Self::Span, Self::Symbol>, ()> {\n+        let name = FileName::proc_macro_source_code(s);\n+        let mut parser = rustc_parse::new_parser_from_source_str(self.sess(), name, s.to_owned());\n+\n+        let first_span = parser.token.span.data();\n+        let minus_present = parser.eat(&token::BinOp(token::Minus));\n+\n+        let lit_span = parser.token.span.data();\n+        let token::Literal(mut lit) = parser.token.kind else {\n+            return Err(());\n+        };\n+\n+        // Check no comment or whitespace surrounding the (possibly negative)\n+        // literal, or more tokens after it.\n+        if (lit_span.hi.0 - first_span.lo.0) as usize != s.len() {\n+            return Err(());\n+        }\n+\n+        if minus_present {\n+            // If minus is present, check no comment or whitespace in between it\n+            // and the literal token.\n+            if first_span.hi.0 != lit_span.lo.0 {\n+                return Err(());\n+            }\n+\n+            // Check literal is a kind we allow to be negated in a proc macro token.\n+            match lit.kind {\n+                token::LitKind::Bool\n+                | token::LitKind::Byte\n+                | token::LitKind::Char\n+                | token::LitKind::Str\n+                | token::LitKind::StrRaw(_)\n+                | token::LitKind::ByteStr\n+                | token::LitKind::ByteStrRaw(_)\n+                | token::LitKind::Err => return Err(()),\n+                token::LitKind::Integer | token::LitKind::Float => {}\n+            }\n+\n+            // Synthesize a new symbol that includes the minus sign.\n+            let symbol = Symbol::intern(&s[..1 + lit.symbol.as_str().len()]);\n+            lit = token::Lit::new(lit.kind, symbol, lit.suffix);\n+        }\n+        let token::Lit { kind, symbol, suffix } = lit;\n+        Ok(Literal {\n+            kind: FromInternal::from_internal(kind),\n+            symbol,\n+            suffix,\n+            span: self.call_site,\n+        })\n+    }\n }\n \n impl server::TokenStream for Rustc<'_, '_> {\n@@ -453,22 +513,22 @@ impl server::TokenStream for Rustc<'_, '_> {\n \n     fn from_token_tree(\n         &mut self,\n-        tree: TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>,\n+        tree: TokenTree<Self::TokenStream, Self::Span, Self::Symbol>,\n     ) -> Self::TokenStream {\n-        tree.to_internal()\n+        (tree, &mut *self).to_internal()\n     }\n \n     fn concat_trees(\n         &mut self,\n         base: Option<Self::TokenStream>,\n-        trees: Vec<TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>>,\n+        trees: Vec<TokenTree<Self::TokenStream, Self::Span, Self::Symbol>>,\n     ) -> Self::TokenStream {\n         let mut builder = tokenstream::TokenStreamBuilder::new();\n         if let Some(base) = base {\n             builder.push(base);\n         }\n         for tree in trees {\n-            builder.push(tree.to_internal());\n+            builder.push((tree, &mut *self).to_internal());\n         }\n         builder.build()\n     }\n@@ -491,178 +551,11 @@ impl server::TokenStream for Rustc<'_, '_> {\n     fn into_trees(\n         &mut self,\n         stream: Self::TokenStream,\n-    ) -> Vec<TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>> {\n+    ) -> Vec<TokenTree<Self::TokenStream, Self::Span, Self::Symbol>> {\n         FromInternal::from_internal((stream, self))\n     }\n }\n \n-impl server::Ident for Rustc<'_, '_> {\n-    fn new(&mut self, string: &str, span: Self::Span, is_raw: bool) -> Self::Ident {\n-        Ident::new(self.sess(), Symbol::intern(string), is_raw, span)\n-    }\n-\n-    fn span(&mut self, ident: Self::Ident) -> Self::Span {\n-        ident.span\n-    }\n-\n-    fn with_span(&mut self, ident: Self::Ident, span: Self::Span) -> Self::Ident {\n-        Ident { span, ..ident }\n-    }\n-}\n-\n-impl server::Literal for Rustc<'_, '_> {\n-    fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n-        let name = FileName::proc_macro_source_code(s);\n-        let mut parser = rustc_parse::new_parser_from_source_str(self.sess(), name, s.to_owned());\n-\n-        let first_span = parser.token.span.data();\n-        let minus_present = parser.eat(&token::BinOp(token::Minus));\n-\n-        let lit_span = parser.token.span.data();\n-        let token::Literal(mut lit) = parser.token.kind else {\n-            return Err(());\n-        };\n-\n-        // Check no comment or whitespace surrounding the (possibly negative)\n-        // literal, or more tokens after it.\n-        if (lit_span.hi.0 - first_span.lo.0) as usize != s.len() {\n-            return Err(());\n-        }\n-\n-        if minus_present {\n-            // If minus is present, check no comment or whitespace in between it\n-            // and the literal token.\n-            if first_span.hi.0 != lit_span.lo.0 {\n-                return Err(());\n-            }\n-\n-            // Check literal is a kind we allow to be negated in a proc macro token.\n-            match lit.kind {\n-                token::LitKind::Bool\n-                | token::LitKind::Byte\n-                | token::LitKind::Char\n-                | token::LitKind::Str\n-                | token::LitKind::StrRaw(_)\n-                | token::LitKind::ByteStr\n-                | token::LitKind::ByteStrRaw(_)\n-                | token::LitKind::Err => return Err(()),\n-                token::LitKind::Integer | token::LitKind::Float => {}\n-            }\n-\n-            // Synthesize a new symbol that includes the minus sign.\n-            let symbol = Symbol::intern(&s[..1 + lit.symbol.as_str().len()]);\n-            lit = token::Lit::new(lit.kind, symbol, lit.suffix);\n-        }\n-\n-        Ok(Literal { lit, span: self.call_site })\n-    }\n-\n-    fn to_string(&mut self, literal: &Self::Literal) -> String {\n-        literal.lit.to_string()\n-    }\n-\n-    fn debug_kind(&mut self, literal: &Self::Literal) -> String {\n-        format!(\"{:?}\", literal.lit.kind)\n-    }\n-\n-    fn symbol(&mut self, literal: &Self::Literal) -> String {\n-        literal.lit.symbol.to_string()\n-    }\n-\n-    fn suffix(&mut self, literal: &Self::Literal) -> Option<String> {\n-        literal.lit.suffix.as_ref().map(Symbol::to_string)\n-    }\n-\n-    fn integer(&mut self, n: &str) -> Self::Literal {\n-        self.lit(token::Integer, Symbol::intern(n), None)\n-    }\n-\n-    fn typed_integer(&mut self, n: &str, kind: &str) -> Self::Literal {\n-        self.lit(token::Integer, Symbol::intern(n), Some(Symbol::intern(kind)))\n-    }\n-\n-    fn float(&mut self, n: &str) -> Self::Literal {\n-        self.lit(token::Float, Symbol::intern(n), None)\n-    }\n-\n-    fn f32(&mut self, n: &str) -> Self::Literal {\n-        self.lit(token::Float, Symbol::intern(n), Some(sym::f32))\n-    }\n-\n-    fn f64(&mut self, n: &str) -> Self::Literal {\n-        self.lit(token::Float, Symbol::intern(n), Some(sym::f64))\n-    }\n-\n-    fn string(&mut self, string: &str) -> Self::Literal {\n-        let quoted = format!(\"{:?}\", string);\n-        assert!(quoted.starts_with('\"') && quoted.ends_with('\"'));\n-        let symbol = &quoted[1..quoted.len() - 1];\n-        self.lit(token::Str, Symbol::intern(symbol), None)\n-    }\n-\n-    fn character(&mut self, ch: char) -> Self::Literal {\n-        let quoted = format!(\"{:?}\", ch);\n-        assert!(quoted.starts_with('\\'') && quoted.ends_with('\\''));\n-        let symbol = &quoted[1..quoted.len() - 1];\n-        self.lit(token::Char, Symbol::intern(symbol), None)\n-    }\n-\n-    fn byte_string(&mut self, bytes: &[u8]) -> Self::Literal {\n-        let string = bytes\n-            .iter()\n-            .cloned()\n-            .flat_map(ascii::escape_default)\n-            .map(Into::<char>::into)\n-            .collect::<String>();\n-        self.lit(token::ByteStr, Symbol::intern(&string), None)\n-    }\n-\n-    fn span(&mut self, literal: &Self::Literal) -> Self::Span {\n-        literal.span\n-    }\n-\n-    fn set_span(&mut self, literal: &mut Self::Literal, span: Self::Span) {\n-        literal.span = span;\n-    }\n-\n-    fn subspan(\n-        &mut self,\n-        literal: &Self::Literal,\n-        start: Bound<usize>,\n-        end: Bound<usize>,\n-    ) -> Option<Self::Span> {\n-        let span = literal.span;\n-        let length = span.hi().to_usize() - span.lo().to_usize();\n-\n-        let start = match start {\n-            Bound::Included(lo) => lo,\n-            Bound::Excluded(lo) => lo.checked_add(1)?,\n-            Bound::Unbounded => 0,\n-        };\n-\n-        let end = match end {\n-            Bound::Included(hi) => hi.checked_add(1)?,\n-            Bound::Excluded(hi) => hi,\n-            Bound::Unbounded => length,\n-        };\n-\n-        // Bounds check the values, preventing addition overflow and OOB spans.\n-        if start > u32::MAX as usize\n-            || end > u32::MAX as usize\n-            || (u32::MAX - start as u32) < span.lo().to_u32()\n-            || (u32::MAX - end as u32) < span.lo().to_u32()\n-            || start >= end\n-            || end > length\n-        {\n-            return None;\n-        }\n-\n-        let new_lo = span.lo() + BytePos::from_usize(start);\n-        let new_hi = span.lo() + BytePos::from_usize(end);\n-        Some(span.with_lo(new_lo).with_hi(new_hi))\n-    }\n-}\n-\n impl server::SourceFile for Rustc<'_, '_> {\n     fn eq(&mut self, file1: &Self::SourceFile, file2: &Self::SourceFile) -> bool {\n         Lrc::ptr_eq(file1, file2)\n@@ -767,6 +660,42 @@ impl server::Span for Rustc<'_, '_> {\n         Some(first.to(second))\n     }\n \n+    fn subspan(\n+        &mut self,\n+        span: Self::Span,\n+        start: Bound<usize>,\n+        end: Bound<usize>,\n+    ) -> Option<Self::Span> {\n+        let length = span.hi().to_usize() - span.lo().to_usize();\n+\n+        let start = match start {\n+            Bound::Included(lo) => lo,\n+            Bound::Excluded(lo) => lo.checked_add(1)?,\n+            Bound::Unbounded => 0,\n+        };\n+\n+        let end = match end {\n+            Bound::Included(hi) => hi.checked_add(1)?,\n+            Bound::Excluded(hi) => hi,\n+            Bound::Unbounded => length,\n+        };\n+\n+        // Bounds check the values, preventing addition overflow and OOB spans.\n+        if start > u32::MAX as usize\n+            || end > u32::MAX as usize\n+            || (u32::MAX - start as u32) < span.lo().to_u32()\n+            || (u32::MAX - end as u32) < span.lo().to_u32()\n+            || start >= end\n+            || end > length\n+        {\n+            return None;\n+        }\n+\n+        let new_lo = span.lo() + BytePos::from_usize(start);\n+        let new_hi = span.lo() + BytePos::from_usize(end);\n+        Some(span.with_lo(new_lo).with_hi(new_hi))\n+    }\n+\n     fn resolved_at(&mut self, span: Self::Span, at: Self::Span) -> Self::Span {\n         span.with_ctxt(at.ctxt())\n     }\n@@ -812,6 +741,13 @@ impl server::Span for Rustc<'_, '_> {\n     }\n }\n \n+impl server::Symbol for Rustc<'_, '_> {\n+    fn normalize_and_validate_ident(&mut self, string: &str) -> Result<Self::Symbol, ()> {\n+        let sym = nfc_normalize(string);\n+        if rustc_lexer::is_ident(sym.as_str()) { Ok(sym) } else { Err(()) }\n+    }\n+}\n+\n impl server::Server for Rustc<'_, '_> {\n     fn globals(&mut self) -> ExpnGlobals<Self::Span> {\n         ExpnGlobals {\n@@ -820,4 +756,12 @@ impl server::Server for Rustc<'_, '_> {\n             mixed_site: self.mixed_site,\n         }\n     }\n+\n+    fn intern_symbol(string: &str) -> Self::Symbol {\n+        Symbol::intern(string)\n+    }\n+\n+    fn with_symbol_string(symbol: &Self::Symbol, f: impl FnOnce(&str)) {\n+        f(&symbol.as_str())\n+    }\n }"}, {"sha": "fa72d2816ebfe7f7b2f906640e7fd1e1c2031628", "filename": "library/proc_macro/src/bridge/arena.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Farena.rs?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -0,0 +1,113 @@\n+//! A minimal arena allocator inspired by `rustc_arena::DroplessArena`.\n+//!\n+//! This is unfortunately a minimal re-implementation rather than a dependency\n+//! as it is difficult to depend on crates from within `proc_macro`, due to it\n+//! being built at the same time as `std`.\n+\n+use std::cell::{Cell, RefCell};\n+use std::cmp;\n+use std::mem::MaybeUninit;\n+use std::ops::Range;\n+use std::ptr;\n+use std::slice;\n+use std::str;\n+\n+// The arenas start with PAGE-sized chunks, and then each new chunk is twice as\n+// big as its predecessor, up until we reach HUGE_PAGE-sized chunks, whereupon\n+// we stop growing. This scales well, from arenas that are barely used up to\n+// arenas that are used for 100s of MiBs. Note also that the chosen sizes match\n+// the usual sizes of pages and huge pages on Linux.\n+const PAGE: usize = 4096;\n+const HUGE_PAGE: usize = 2 * 1024 * 1024;\n+\n+/// A minimal arena allocator inspired by `rustc_arena::DroplessArena`.\n+///\n+/// This is unfortunately a complete re-implementation rather than a dependency\n+/// as it is difficult to depend on crates from within `proc_macro`, due to it\n+/// being built at the same time as `std`.\n+///\n+/// This arena doesn't have support for allocating anything other than byte\n+/// slices, as that is all that is necessary.\n+pub(crate) struct Arena {\n+    start: Cell<*mut MaybeUninit<u8>>,\n+    end: Cell<*mut MaybeUninit<u8>>,\n+    chunks: RefCell<Vec<Box<[MaybeUninit<u8>]>>>,\n+}\n+\n+impl Arena {\n+    pub(crate) fn new() -> Self {\n+        Arena {\n+            start: Cell::new(ptr::null_mut()),\n+            end: Cell::new(ptr::null_mut()),\n+            chunks: RefCell::new(Vec::new()),\n+        }\n+    }\n+\n+    /// Add a new chunk with at least `additional` free bytes.\n+    #[inline(never)]\n+    #[cold]\n+    fn grow(&self, additional: usize) {\n+        let mut chunks = self.chunks.borrow_mut();\n+        let mut new_cap;\n+        if let Some(last_chunk) = chunks.last_mut() {\n+            // If the previous chunk's len is less than HUGE_PAGE\n+            // bytes, then this chunk will be least double the previous\n+            // chunk's size.\n+            new_cap = last_chunk.len().min(HUGE_PAGE / 2);\n+            new_cap *= 2;\n+        } else {\n+            new_cap = PAGE;\n+        }\n+        // Also ensure that this chunk can fit `additional`.\n+        new_cap = cmp::max(additional, new_cap);\n+\n+        let mut chunk = Box::new_uninit_slice(new_cap);\n+        let Range { start, end } = chunk.as_mut_ptr_range();\n+        self.start.set(start);\n+        self.end.set(end);\n+        chunks.push(chunk);\n+    }\n+\n+    /// Allocates a byte slice with specified size from the current memory\n+    /// chunk. Returns `None` if there is no free space left to satisfy the\n+    /// request.\n+    fn alloc_raw_without_grow(&self, bytes: usize) -> Option<&mut [MaybeUninit<u8>]> {\n+        let start = self.start.get().addr();\n+        let old_end = self.end.get();\n+        let end = old_end.addr();\n+\n+        let new_end = end.checked_sub(bytes)?;\n+        if start <= new_end {\n+            let new_end = old_end.with_addr(new_end);\n+            self.end.set(new_end);\n+            // SAFETY: `bytes` bytes starting at `new_end` were just reserved.\n+            Some(unsafe { slice::from_raw_parts_mut(new_end, bytes) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn alloc_raw(&self, bytes: usize) -> &mut [MaybeUninit<u8>] {\n+        if bytes == 0 {\n+            return &mut [];\n+        }\n+\n+        loop {\n+            if let Some(a) = self.alloc_raw_without_grow(bytes) {\n+                break a;\n+            }\n+            // No free space left. Allocate a new chunk to satisfy the request.\n+            // On failure the grow will panic or abort.\n+            self.grow(bytes);\n+        }\n+    }\n+\n+    pub(crate) fn alloc_str<'a>(&'a self, string: &str) -> &'a mut str {\n+        let alloc = self.alloc_raw(string.len());\n+        let bytes = MaybeUninit::write_slice(alloc, string.as_bytes());\n+\n+        // SAFETY: we convert from `&str` to `&[u8]`, clone it into the arena,\n+        // and immediately convert the clone back to `&str`.\n+        unsafe { str::from_utf8_unchecked_mut(bytes) }\n+    }\n+}"}, {"sha": "1516f084ab8b65b3db8821f78cc314dd6712cd2b", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -175,13 +175,11 @@ define_handles! {\n     'owned:\n     FreeFunctions,\n     TokenStream,\n-    Literal,\n     SourceFile,\n     MultiSpan,\n     Diagnostic,\n \n     'interned:\n-    Ident,\n     Span,\n }\n \n@@ -197,25 +195,6 @@ impl Clone for TokenStream {\n     }\n }\n \n-impl Clone for Literal {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n-impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Literal\")\n-            // format the kind without quotes, as in `kind: Float`\n-            .field(\"kind\", &format_args!(\"{}\", &self.debug_kind()))\n-            .field(\"symbol\", &self.symbol())\n-            // format `Some(\"...\")` on one line even in {:#?} mode\n-            .field(\"suffix\", &format_args!(\"{:?}\", &self.suffix()))\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n impl Clone for SourceFile {\n     fn clone(&self) -> Self {\n         self.clone()\n@@ -242,6 +221,8 @@ impl fmt::Debug for Span {\n     }\n }\n \n+pub(crate) use super::symbol::Symbol;\n+\n macro_rules! define_client_side {\n     ($($name:ident {\n         $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n@@ -405,6 +386,9 @@ fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n     panic::catch_unwind(panic::AssertUnwindSafe(|| {\n         maybe_install_panic_hook(force_show_panics);\n \n+        // Make sure the symbol store is empty before decoding inputs.\n+        Symbol::invalidate_all();\n+\n         let reader = &mut &buf[..];\n         let (globals, input) = <(ExpnGlobals<Span>, A)>::decode(reader, &mut ());\n \n@@ -438,6 +422,10 @@ fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n         buf.clear();\n         Err::<(), _>(e).encode(&mut buf, &mut ());\n     });\n+\n+    // Now that a response has been serialized, invalidate all symbols\n+    // registered with the interner.\n+    Symbol::invalidate_all();\n     buf\n }\n "}, {"sha": "4b1e412e24b709e2ed77e6dd1ccebb3be2a11a1d", "filename": "library/proc_macro/src/bridge/fxhash.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Ffxhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Ffxhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Ffxhash.rs?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -0,0 +1,117 @@\n+//! This is a copy of the `rustc_hash` crate, adapted to work as a module.\n+//!\n+//! If in the future it becomes more reasonable to add dependencies to\n+//! `proc_macro`, this module should be removed and replaced with a dependency\n+//! on the `rustc_hash` crate.\n+\n+use std::collections::HashMap;\n+use std::convert::TryInto;\n+use std::default::Default;\n+use std::hash::BuildHasherDefault;\n+use std::hash::Hasher;\n+use std::mem::size_of;\n+use std::ops::BitXor;\n+\n+/// Type alias for a hashmap using the `fx` hash algorithm.\n+pub type FxHashMap<K, V> = HashMap<K, V, BuildHasherDefault<FxHasher>>;\n+\n+/// A speedy hash algorithm for use within rustc. The hashmap in liballoc\n+/// by default uses SipHash which isn't quite as speedy as we want. In the\n+/// compiler we're not really worried about DOS attempts, so we use a fast\n+/// non-cryptographic hash.\n+///\n+/// This is the same as the algorithm used by Firefox -- which is a homespun\n+/// one not based on any widely-known algorithm -- though modified to produce\n+/// 64-bit hash values instead of 32-bit hash values. It consistently\n+/// out-performs an FNV-based hash within rustc itself -- the collision rate is\n+/// similar or slightly worse than FNV, but the speed of the hash function\n+/// itself is much higher because it works on up to 8 bytes at a time.\n+pub struct FxHasher {\n+    hash: usize,\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+const K: usize = 0x9e3779b9;\n+#[cfg(target_pointer_width = \"64\")]\n+const K: usize = 0x517cc1b727220a95;\n+\n+impl Default for FxHasher {\n+    #[inline]\n+    fn default() -> FxHasher {\n+        FxHasher { hash: 0 }\n+    }\n+}\n+\n+impl FxHasher {\n+    #[inline]\n+    fn add_to_hash(&mut self, i: usize) {\n+        self.hash = self.hash.rotate_left(5).bitxor(i).wrapping_mul(K);\n+    }\n+}\n+\n+impl Hasher for FxHasher {\n+    #[inline]\n+    fn write(&mut self, mut bytes: &[u8]) {\n+        #[cfg(target_pointer_width = \"32\")]\n+        let read_usize = |bytes: &[u8]| u32::from_ne_bytes(bytes[..4].try_into().unwrap());\n+        #[cfg(target_pointer_width = \"64\")]\n+        let read_usize = |bytes: &[u8]| u64::from_ne_bytes(bytes[..8].try_into().unwrap());\n+\n+        let mut hash = FxHasher { hash: self.hash };\n+        assert!(size_of::<usize>() <= 8);\n+        while bytes.len() >= size_of::<usize>() {\n+            hash.add_to_hash(read_usize(bytes) as usize);\n+            bytes = &bytes[size_of::<usize>()..];\n+        }\n+        if (size_of::<usize>() > 4) && (bytes.len() >= 4) {\n+            hash.add_to_hash(u32::from_ne_bytes(bytes[..4].try_into().unwrap()) as usize);\n+            bytes = &bytes[4..];\n+        }\n+        if (size_of::<usize>() > 2) && bytes.len() >= 2 {\n+            hash.add_to_hash(u16::from_ne_bytes(bytes[..2].try_into().unwrap()) as usize);\n+            bytes = &bytes[2..];\n+        }\n+        if (size_of::<usize>() > 1) && bytes.len() >= 1 {\n+            hash.add_to_hash(bytes[0] as usize);\n+        }\n+        self.hash = hash.hash;\n+    }\n+\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.add_to_hash(i as usize);\n+        self.add_to_hash((i >> 32) as usize);\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.add_to_hash(i);\n+    }\n+\n+    #[inline]\n+    fn finish(&self) -> u64 {\n+        self.hash as u64\n+    }\n+}"}, {"sha": "00954107b7769c8af31d6d2c3e5f3a938716926c", "filename": "library/proc_macro/src/bridge/handle.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fhandle.rs?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -1,11 +1,13 @@\n //! Server-side handles and storage for per-handle data.\n \n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::{BuildHasher, Hash};\n+use std::collections::BTreeMap;\n+use std::hash::Hash;\n use std::num::NonZeroU32;\n use std::ops::{Index, IndexMut};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n+use super::fxhash::FxHashMap;\n+\n pub(super) type Handle = NonZeroU32;\n \n /// A store that associates values of type `T` with numeric handles. A value can\n@@ -51,31 +53,15 @@ impl<T> IndexMut<Handle> for OwnedStore<T> {\n     }\n }\n \n-// HACK(eddyb) deterministic `std::collections::hash_map::RandomState` replacement\n-// that doesn't require adding any dependencies to `proc_macro` (like `rustc-hash`).\n-#[derive(Clone)]\n-struct NonRandomState;\n-\n-impl BuildHasher for NonRandomState {\n-    type Hasher = std::collections::hash_map::DefaultHasher;\n-    #[inline]\n-    fn build_hasher(&self) -> Self::Hasher {\n-        Self::Hasher::new()\n-    }\n-}\n-\n /// Like `OwnedStore`, but avoids storing any value more than once.\n pub(super) struct InternedStore<T: 'static> {\n     owned: OwnedStore<T>,\n-    interner: HashMap<T, Handle, NonRandomState>,\n+    interner: FxHashMap<T, Handle>,\n }\n \n impl<T: Copy + Eq + Hash> InternedStore<T> {\n     pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n-        InternedStore {\n-            owned: OwnedStore::new(counter),\n-            interner: HashMap::with_hasher(NonRandomState),\n-        }\n+        InternedStore { owned: OwnedStore::new(counter), interner: FxHashMap::default() }\n     }\n \n     pub(super) fn alloc(&mut self, x: T) -> Handle {"}, {"sha": "5cde966bf173d163efa4130f18ae2180ea21fef8", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 65, "deletions": 36, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -56,6 +56,7 @@ macro_rules! with_api {\n                 fn drop($self: $S::FreeFunctions);\n                 fn track_env_var(var: &str, value: Option<&str>);\n                 fn track_path(path: &str);\n+                fn literal_from_str(s: &str) -> Result<Literal<$S::Span, $S::Symbol>, ()>;\n             },\n             TokenStream {\n                 fn drop($self: $S::TokenStream);\n@@ -65,48 +66,19 @@ macro_rules! with_api {\n                 fn from_str(src: &str) -> $S::TokenStream;\n                 fn to_string($self: &$S::TokenStream) -> String;\n                 fn from_token_tree(\n-                    tree: TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>,\n+                    tree: TokenTree<$S::TokenStream, $S::Span, $S::Symbol>,\n                 ) -> $S::TokenStream;\n                 fn concat_trees(\n                     base: Option<$S::TokenStream>,\n-                    trees: Vec<TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>>,\n+                    trees: Vec<TokenTree<$S::TokenStream, $S::Span, $S::Symbol>>,\n                 ) -> $S::TokenStream;\n                 fn concat_streams(\n                     base: Option<$S::TokenStream>,\n                     streams: Vec<$S::TokenStream>,\n                 ) -> $S::TokenStream;\n                 fn into_trees(\n                     $self: $S::TokenStream\n-                ) -> Vec<TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>>;\n-            },\n-            Ident {\n-                fn new(string: &str, span: $S::Span, is_raw: bool) -> $S::Ident;\n-                fn span($self: $S::Ident) -> $S::Span;\n-                fn with_span($self: $S::Ident, span: $S::Span) -> $S::Ident;\n-            },\n-            Literal {\n-                fn drop($self: $S::Literal);\n-                fn clone($self: &$S::Literal) -> $S::Literal;\n-                fn from_str(s: &str) -> Result<$S::Literal, ()>;\n-                fn to_string($self: &$S::Literal) -> String;\n-                fn debug_kind($self: &$S::Literal) -> String;\n-                fn symbol($self: &$S::Literal) -> String;\n-                fn suffix($self: &$S::Literal) -> Option<String>;\n-                fn integer(n: &str) -> $S::Literal;\n-                fn typed_integer(n: &str, kind: &str) -> $S::Literal;\n-                fn float(n: &str) -> $S::Literal;\n-                fn f32(n: &str) -> $S::Literal;\n-                fn f64(n: &str) -> $S::Literal;\n-                fn string(string: &str) -> $S::Literal;\n-                fn character(ch: char) -> $S::Literal;\n-                fn byte_string(bytes: &[u8]) -> $S::Literal;\n-                fn span($self: &$S::Literal) -> $S::Span;\n-                fn set_span($self: &mut $S::Literal, span: $S::Span);\n-                fn subspan(\n-                    $self: &$S::Literal,\n-                    start: Bound<usize>,\n-                    end: Bound<usize>,\n-                ) -> Option<$S::Span>;\n+                ) -> Vec<TokenTree<$S::TokenStream, $S::Span, $S::Symbol>>;\n             },\n             SourceFile {\n                 fn drop($self: $S::SourceFile);\n@@ -141,11 +113,15 @@ macro_rules! with_api {\n                 fn before($self: $S::Span) -> $S::Span;\n                 fn after($self: $S::Span) -> $S::Span;\n                 fn join($self: $S::Span, other: $S::Span) -> Option<$S::Span>;\n+                fn subspan($self: $S::Span, start: Bound<usize>, end: Bound<usize>) -> Option<$S::Span>;\n                 fn resolved_at($self: $S::Span, at: $S::Span) -> $S::Span;\n                 fn source_text($self: $S::Span) -> Option<String>;\n                 fn save_span($self: $S::Span) -> usize;\n                 fn recover_proc_macro_span(id: usize) -> $S::Span;\n             },\n+            Symbol {\n+                fn normalize_and_validate_ident(string: &str) -> Result<$S::Symbol, ()>;\n+            },\n         }\n     };\n }\n@@ -170,13 +146,17 @@ macro_rules! reverse_decode {\n     }\n }\n \n+#[allow(unsafe_code)]\n+mod arena;\n #[allow(unsafe_code)]\n mod buffer;\n #[forbid(unsafe_code)]\n pub mod client;\n #[allow(unsafe_code)]\n mod closure;\n #[forbid(unsafe_code)]\n+mod fxhash;\n+#[forbid(unsafe_code)]\n mod handle;\n #[macro_use]\n #[forbid(unsafe_code)]\n@@ -187,6 +167,8 @@ mod scoped_cell;\n mod selfless_reify;\n #[forbid(unsafe_code)]\n pub mod server;\n+#[allow(unsafe_code)]\n+mod symbol;\n \n use buffer::Buffer;\n pub use rpc::PanicMessage;\n@@ -328,6 +310,7 @@ mark_noop! {\n     u8,\n     usize,\n     Delimiter,\n+    LitKind,\n     Level,\n     LineColumn,\n     Spacing,\n@@ -357,6 +340,33 @@ rpc_encode_decode!(\n     }\n );\n \n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+pub enum LitKind {\n+    Byte,\n+    Char,\n+    Integer,\n+    Float,\n+    Str,\n+    StrRaw(u8),\n+    ByteStr,\n+    ByteStrRaw(u8),\n+    Err,\n+}\n+\n+rpc_encode_decode!(\n+    enum LitKind {\n+        Byte,\n+        Char,\n+        Integer,\n+        Float,\n+        Str,\n+        StrRaw(n),\n+        ByteStr,\n+        ByteStrRaw(n),\n+        Err,\n+    }\n+);\n+\n macro_rules! mark_compound {\n     (struct $name:ident <$($T:ident),+> { $($field:ident),* $(,)? }) => {\n         impl<$($T: Mark),+> Mark for $name <$($T),+> {\n@@ -464,16 +474,35 @@ pub struct Punct<Span> {\n \n compound_traits!(struct Punct<Span> { ch, joint, span });\n \n+#[derive(Copy, Clone, Eq, PartialEq)]\n+pub struct Ident<Span, Symbol> {\n+    pub sym: Symbol,\n+    pub is_raw: bool,\n+    pub span: Span,\n+}\n+\n+compound_traits!(struct Ident<Span, Symbol> { sym, is_raw, span });\n+\n+#[derive(Clone, Eq, PartialEq)]\n+pub struct Literal<Span, Symbol> {\n+    pub kind: LitKind,\n+    pub symbol: Symbol,\n+    pub suffix: Option<Symbol>,\n+    pub span: Span,\n+}\n+\n+compound_traits!(struct Literal<Sp, Sy> { kind, symbol, suffix, span });\n+\n #[derive(Clone)]\n-pub enum TokenTree<TokenStream, Span, Ident, Literal> {\n+pub enum TokenTree<TokenStream, Span, Symbol> {\n     Group(Group<TokenStream, Span>),\n     Punct(Punct<Span>),\n-    Ident(Ident),\n-    Literal(Literal),\n+    Ident(Ident<Span, Symbol>),\n+    Literal(Literal<Span, Symbol>),\n }\n \n compound_traits!(\n-    enum TokenTree<TokenStream, Span, Ident, Literal> {\n+    enum TokenTree<TokenStream, Span, Symbol> {\n         Group(tt),\n         Punct(tt),\n         Ident(tt),"}, {"sha": "d46e325951d72fd2013fa34c3245f21dffa204dc", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -8,12 +8,11 @@ use super::client::HandleStore;\n pub trait Types {\n     type FreeFunctions: 'static;\n     type TokenStream: 'static + Clone;\n-    type Ident: 'static + Copy + Eq + Hash;\n-    type Literal: 'static + Clone;\n     type SourceFile: 'static + Clone;\n     type MultiSpan: 'static;\n     type Diagnostic: 'static;\n     type Span: 'static + Copy + Eq + Hash;\n+    type Symbol: 'static;\n }\n \n /// Declare an associated fn of one of the traits below, adding necessary\n@@ -38,6 +37,12 @@ macro_rules! declare_server_traits {\n \n         pub trait Server: Types $(+ $name)* {\n             fn globals(&mut self) -> ExpnGlobals<Self::Span>;\n+\n+            /// Intern a symbol received from RPC\n+            fn intern_symbol(ident: &str) -> Self::Symbol;\n+\n+            /// Recover the string value of a symbol, and invoke a callback with it.\n+            fn with_symbol_string(symbol: &Self::Symbol, f: impl FnOnce(&str));\n         }\n     }\n }\n@@ -49,6 +54,12 @@ impl<S: Server> Server for MarkedTypes<S> {\n     fn globals(&mut self) -> ExpnGlobals<Self::Span> {\n         <_>::mark(Server::globals(&mut self.0))\n     }\n+    fn intern_symbol(ident: &str) -> Self::Symbol {\n+        <_>::mark(S::intern_symbol(ident))\n+    }\n+    fn with_symbol_string(symbol: &Self::Symbol, f: impl FnOnce(&str)) {\n+        S::with_symbol_string(symbol.unmark(), f)\n+    }\n }\n \n macro_rules! define_mark_types_impls {\n@@ -81,11 +92,13 @@ macro_rules! define_dispatcher_impl {\n         pub trait DispatcherTrait {\n             // HACK(eddyb) these are here to allow `Self::$name` to work below.\n             $(type $name;)*\n+\n             fn dispatch(&mut self, buf: Buffer) -> Buffer;\n         }\n \n         impl<S: Server> DispatcherTrait for Dispatcher<MarkedTypes<S>> {\n             $(type $name = <MarkedTypes<S> as Types>::$name;)*\n+\n             fn dispatch(&mut self, mut buf: Buffer) -> Buffer {\n                 let Dispatcher { handle_store, server } = self;\n "}, {"sha": "930c111455df0977005a5b82702b8601df62a289", "filename": "library/proc_macro/src/bridge/symbol.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Fbridge%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fsymbol.rs?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -0,0 +1,205 @@\n+//! Client-side interner used for symbols.\n+//!\n+//! This is roughly based on the symbol interner from `rustc_span` and the\n+//! DroplessArena from `rustc_arena`. It is unfortunately a complete\n+//! copy/re-implementation rather than a dependency as it is difficult to depend\n+//! on crates from within `proc_macro`, due to it being built at the same time\n+//! as `std`.\n+//!\n+//! If at some point in the future it becomes easier to add dependencies to\n+//! proc_macro, this module should probably be removed or simplified.\n+\n+use std::cell::RefCell;\n+use std::num::NonZeroU32;\n+use std::str;\n+\n+use super::*;\n+\n+/// Handle for a symbol string stored within the Interner.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Symbol(NonZeroU32);\n+\n+impl !Send for Symbol {}\n+impl !Sync for Symbol {}\n+\n+impl Symbol {\n+    /// Intern a new `Symbol`\n+    pub(crate) fn new(string: &str) -> Self {\n+        INTERNER.with_borrow_mut(|i| i.intern(string))\n+    }\n+\n+    /// Create a new `Symbol` for an identifier.\n+    ///\n+    /// Validates and normalizes before converting it to a symbol.\n+    pub(crate) fn new_ident(string: &str, is_raw: bool) -> Self {\n+        // Fast-path: check if this is a valid ASCII identifier\n+        if Self::is_valid_ascii_ident(string.as_bytes()) {\n+            if is_raw && !Self::can_be_raw(string) {\n+                panic!(\"`{}` cannot be a raw identifier\", string);\n+            }\n+            return Self::new(string);\n+        }\n+\n+        // Slow-path: If the string is already ASCII we're done, otherwise ask\n+        // our server to do this for us over RPC.\n+        // We don't need to check for identifiers which can't be raw here,\n+        // because all of them are ASCII.\n+        if string.is_ascii() {\n+            Err(())\n+        } else {\n+            client::Symbol::normalize_and_validate_ident(string)\n+        }\n+        .unwrap_or_else(|_| panic!(\"`{:?}` is not a valid identifier\", string))\n+    }\n+\n+    /// Run a callback with the symbol's string value.\n+    pub(crate) fn with<R>(self, f: impl FnOnce(&str) -> R) -> R {\n+        INTERNER.with_borrow(|i| f(i.get(self)))\n+    }\n+\n+    /// Clear out the thread-local symbol interner, making all previously\n+    /// created symbols invalid such that `with` will panic when called on them.\n+    pub(crate) fn invalidate_all() {\n+        INTERNER.with_borrow_mut(|i| i.clear());\n+    }\n+\n+    /// Check if the ident is a valid ASCII identifier.\n+    ///\n+    /// This is a short-circuit which is cheap to implement within the\n+    /// proc-macro client to avoid RPC when creating simple idents, but may\n+    /// return `false` for a valid identifier if it contains non-ASCII\n+    /// characters.\n+    fn is_valid_ascii_ident(bytes: &[u8]) -> bool {\n+        matches!(bytes.first(), Some(b'_' | b'a'..=b'z' | b'A'..=b'Z'))\n+            && bytes[1..]\n+                .iter()\n+                .all(|b| matches!(b, b'_' | b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9'))\n+    }\n+\n+    // Mimics the behaviour of `Symbol::can_be_raw` from `rustc_span`\n+    fn can_be_raw(string: &str) -> bool {\n+        match string {\n+            \"_\" | \"super\" | \"self\" | \"Self\" | \"crate\" => false,\n+            _ => true,\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Symbol {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.with(|s| fmt::Debug::fmt(s, f))\n+    }\n+}\n+\n+impl ToString for Symbol {\n+    fn to_string(&self) -> String {\n+        self.with(|s| s.to_owned())\n+    }\n+}\n+\n+impl fmt::Display for Symbol {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.with(|s| fmt::Display::fmt(s, f))\n+    }\n+}\n+\n+impl<S> Encode<S> for Symbol {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.with(|sym| sym.encode(w, s))\n+    }\n+}\n+\n+impl<S: server::Server> DecodeMut<'_, '_, client::HandleStore<server::MarkedTypes<S>>>\n+    for Marked<S::Symbol, Symbol>\n+{\n+    fn decode(r: &mut Reader<'_>, s: &mut client::HandleStore<server::MarkedTypes<S>>) -> Self {\n+        Mark::mark(S::intern_symbol(<&str>::decode(r, s)))\n+    }\n+}\n+\n+impl<S: server::Server> Encode<client::HandleStore<server::MarkedTypes<S>>>\n+    for Marked<S::Symbol, Symbol>\n+{\n+    fn encode(self, w: &mut Writer, s: &mut client::HandleStore<server::MarkedTypes<S>>) {\n+        S::with_symbol_string(&self.unmark(), |sym| sym.encode(w, s))\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for Symbol {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        Symbol::new(<&str>::decode(r, s))\n+    }\n+}\n+\n+thread_local! {\n+    static INTERNER: RefCell<Interner> = RefCell::new(Interner {\n+        arena: arena::Arena::new(),\n+        names: fxhash::FxHashMap::default(),\n+        strings: Vec::new(),\n+        // Start with a base of 1 to make sure that `NonZeroU32` works.\n+        sym_base: NonZeroU32::new(1).unwrap(),\n+    });\n+}\n+\n+/// Basic interner for a `Symbol`, inspired by the one in `rustc_span`.\n+struct Interner {\n+    arena: arena::Arena,\n+    // SAFETY: These `'static` lifetimes are actually references to data owned\n+    // by the Arena. This is safe, as we never return them as static references\n+    // from `Interner`.\n+    names: fxhash::FxHashMap<&'static str, Symbol>,\n+    strings: Vec<&'static str>,\n+    // The offset to apply to symbol names stored in the interner. This is used\n+    // to ensure that symbol names are not re-used after the interner is\n+    // cleared.\n+    sym_base: NonZeroU32,\n+}\n+\n+impl Interner {\n+    fn intern(&mut self, string: &str) -> Symbol {\n+        if let Some(&name) = self.names.get(string) {\n+            return name;\n+        }\n+\n+        let name = Symbol(\n+            self.sym_base\n+                .checked_add(self.strings.len() as u32)\n+                .expect(\"`proc_macro` symbol name overflow\"),\n+        );\n+\n+        let string: &str = self.arena.alloc_str(string);\n+\n+        // SAFETY: we can extend the arena allocation to `'static` because we\n+        // only access these while the arena is still alive.\n+        let string: &'static str = unsafe { &*(string as *const str) };\n+        self.strings.push(string);\n+        self.names.insert(string, name);\n+        name\n+    }\n+\n+    /// Read a symbol's value from the store while it is held.\n+    fn get(&self, symbol: Symbol) -> &str {\n+        // NOTE: Subtract out the offset which was added to make the symbol\n+        // nonzero and prevent symbol name re-use.\n+        let name = symbol\n+            .0\n+            .get()\n+            .checked_sub(self.sym_base.get())\n+            .expect(\"use-after-free of `proc_macro` symbol\");\n+        self.strings[name as usize]\n+    }\n+\n+    /// Clear all symbols from the store, invalidating them such that `get` will\n+    /// panic if they are accessed in the future.\n+    fn clear(&mut self) {\n+        // NOTE: Be careful not to panic here, as we may be called on the client\n+        // when a `catch_unwind` isn't installed.\n+        self.sym_base = self.sym_base.saturating_add(self.strings.len() as u32);\n+        self.names.clear();\n+        self.strings.clear();\n+\n+        // SAFETY: This is cleared after the names and strings tables are\n+        // cleared out, so no references into the arena should remain.\n+        self.arena = arena::Arena::new();\n+    }\n+}"}, {"sha": "5cf16bdd08cdd6c04c1a376c26e6a68f7b980a1e", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 142, "deletions": 43, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -24,10 +24,14 @@\n #![feature(staged_api)]\n #![feature(allow_internal_unstable)]\n #![feature(decl_macro)]\n+#![feature(local_key_cell_methods)]\n+#![feature(maybe_uninit_write_slice)]\n #![feature(negative_impls)]\n+#![feature(new_uninit)]\n #![feature(restricted_std)]\n #![feature(rustc_attrs)]\n #![feature(min_specialization)]\n+#![feature(strict_provenance)]\n #![recursion_limit = \"256\"]\n \n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n@@ -211,12 +215,7 @@ pub use quote::{quote, quote_span};\n \n fn tree_to_bridge_tree(\n     tree: TokenTree,\n-) -> bridge::TokenTree<\n-    bridge::client::TokenStream,\n-    bridge::client::Span,\n-    bridge::client::Ident,\n-    bridge::client::Literal,\n-> {\n+) -> bridge::TokenTree<bridge::client::TokenStream, bridge::client::Span, bridge::client::Symbol> {\n     match tree {\n         TokenTree::Group(tt) => bridge::TokenTree::Group(tt.0),\n         TokenTree::Punct(tt) => bridge::TokenTree::Punct(tt.0),\n@@ -240,8 +239,7 @@ struct ConcatTreesHelper {\n         bridge::TokenTree<\n             bridge::client::TokenStream,\n             bridge::client::Span,\n-            bridge::client::Ident,\n-            bridge::client::Literal,\n+            bridge::client::Symbol,\n         >,\n     >,\n }\n@@ -367,8 +365,7 @@ pub mod token_stream {\n             bridge::TokenTree<\n                 bridge::client::TokenStream,\n                 bridge::client::Span,\n-                bridge::client::Ident,\n-                bridge::client::Literal,\n+                bridge::client::Symbol,\n             >,\n         >,\n     );\n@@ -1004,6 +1001,13 @@ impl Punct {\n     }\n }\n \n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+impl ToString for Punct {\n+    fn to_string(&self) -> String {\n+        self.as_char().to_string()\n+    }\n+}\n+\n /// Prints the punctuation character as a string that should be losslessly convertible\n /// back into the same character.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n@@ -1041,7 +1045,7 @@ impl PartialEq<Punct> for char {\n /// An identifier (`ident`).\n #[derive(Clone)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-pub struct Ident(bridge::client::Ident);\n+pub struct Ident(bridge::Ident<bridge::client::Span, bridge::client::Symbol>);\n \n impl Ident {\n     /// Creates a new `Ident` with the given `string` as well as the specified\n@@ -1065,7 +1069,11 @@ impl Ident {\n     /// tokens, requires a `Span` to be specified at construction.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(string: &str, span: Span) -> Ident {\n-        Ident(bridge::client::Ident::new(string, span.0, false))\n+        Ident(bridge::Ident {\n+            sym: bridge::client::Symbol::new_ident(string, false),\n+            is_raw: false,\n+            span: span.0,\n+        })\n     }\n \n     /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n@@ -1074,38 +1082,45 @@ impl Ident {\n     /// (e.g. `self`, `super`) are not supported, and will cause a panic.\n     #[stable(feature = \"proc_macro_raw_ident\", since = \"1.47.0\")]\n     pub fn new_raw(string: &str, span: Span) -> Ident {\n-        Ident(bridge::client::Ident::new(string, span.0, true))\n+        Ident(bridge::Ident {\n+            sym: bridge::client::Symbol::new_ident(string, true),\n+            is_raw: true,\n+            span: span.0,\n+        })\n     }\n \n     /// Returns the span of this `Ident`, encompassing the entire string returned\n-    /// by [`to_string`](Self::to_string).\n+    /// by [`to_string`](ToString::to_string).\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n-        Span(self.0.span())\n+        Span(self.0.span)\n     }\n \n     /// Configures the span of this `Ident`, possibly changing its hygiene context.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n-        self.0 = self.0.with_span(span.0);\n+        self.0.span = span.0;\n     }\n }\n \n-// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n-// based on it (the reverse of the usual relationship between the two).\n-#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n+/// Converts the identifier to a string that should be losslessly convertible\n+/// back into the same identifier.\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl ToString for Ident {\n     fn to_string(&self) -> String {\n-        TokenStream::from(TokenTree::from(self.clone())).to_string()\n+        self.0.sym.with(|sym| if self.0.is_raw { [\"r#\", sym].concat() } else { sym.to_owned() })\n     }\n }\n \n-/// Prints the identifier as a string that should be losslessly convertible\n-/// back into the same identifier.\n+/// Prints the identifier as a string that should be losslessly convertible back\n+/// into the same identifier.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n+        if self.0.is_raw {\n+            f.write_str(\"r#\")?;\n+        }\n+        fmt::Display::fmt(&self.0.sym, f)\n     }\n }\n \n@@ -1125,7 +1140,7 @@ impl fmt::Debug for Ident {\n /// Boolean literals like `true` and `false` do not belong here, they are `Ident`s.\n #[derive(Clone)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-pub struct Literal(bridge::client::Literal);\n+pub struct Literal(bridge::Literal<bridge::client::Span, bridge::client::Symbol>);\n \n macro_rules! suffixed_int_literals {\n     ($($name:ident => $kind:ident,)*) => ($(\n@@ -1142,7 +1157,12 @@ macro_rules! suffixed_int_literals {\n         /// below.\n         #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n         pub fn $name(n: $kind) -> Literal {\n-            Literal(bridge::client::Literal::typed_integer(&n.to_string(), stringify!($kind)))\n+            Literal(bridge::Literal {\n+                kind: bridge::LitKind::Integer,\n+                symbol: bridge::client::Symbol::new(&n.to_string()),\n+                suffix: Some(bridge::client::Symbol::new(stringify!($kind))),\n+                span: Span::call_site().0,\n+            })\n         }\n     )*)\n }\n@@ -1164,12 +1184,26 @@ macro_rules! unsuffixed_int_literals {\n         /// below.\n         #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n         pub fn $name(n: $kind) -> Literal {\n-            Literal(bridge::client::Literal::integer(&n.to_string()))\n+            Literal(bridge::Literal {\n+                kind: bridge::LitKind::Integer,\n+                symbol: bridge::client::Symbol::new(&n.to_string()),\n+                suffix: None,\n+                span: Span::call_site().0,\n+            })\n         }\n     )*)\n }\n \n impl Literal {\n+    fn new(kind: bridge::LitKind, value: &str, suffix: Option<&str>) -> Self {\n+        Literal(bridge::Literal {\n+            kind,\n+            symbol: bridge::client::Symbol::new(value),\n+            suffix: suffix.map(bridge::client::Symbol::new),\n+            span: Span::call_site().0,\n+        })\n+    }\n+\n     suffixed_int_literals! {\n         u8_suffixed => u8,\n         u16_suffixed => u16,\n@@ -1221,7 +1255,7 @@ impl Literal {\n         if !repr.contains('.') {\n             repr.push_str(\".0\");\n         }\n-        Literal(bridge::client::Literal::float(&repr))\n+        Literal::new(bridge::LitKind::Float, &repr, None)\n     }\n \n     /// Creates a new suffixed floating-point literal.\n@@ -1242,7 +1276,7 @@ impl Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {n}\");\n         }\n-        Literal(bridge::client::Literal::f32(&n.to_string()))\n+        Literal::new(bridge::LitKind::Float, &n.to_string(), Some(\"f32\"))\n     }\n \n     /// Creates a new unsuffixed floating-point literal.\n@@ -1266,7 +1300,7 @@ impl Literal {\n         if !repr.contains('.') {\n             repr.push_str(\".0\");\n         }\n-        Literal(bridge::client::Literal::float(&repr))\n+        Literal::new(bridge::LitKind::Float, &repr, None)\n     }\n \n     /// Creates a new suffixed floating-point literal.\n@@ -1287,37 +1321,49 @@ impl Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {n}\");\n         }\n-        Literal(bridge::client::Literal::f64(&n.to_string()))\n+        Literal::new(bridge::LitKind::Float, &n.to_string(), Some(\"f64\"))\n     }\n \n     /// String literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn string(string: &str) -> Literal {\n-        Literal(bridge::client::Literal::string(string))\n+        let quoted = format!(\"{:?}\", string);\n+        assert!(quoted.starts_with('\"') && quoted.ends_with('\"'));\n+        let symbol = &quoted[1..quoted.len() - 1];\n+        Literal::new(bridge::LitKind::Str, symbol, None)\n     }\n \n     /// Character literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn character(ch: char) -> Literal {\n-        Literal(bridge::client::Literal::character(ch))\n+        let quoted = format!(\"{:?}\", ch);\n+        assert!(quoted.starts_with('\\'') && quoted.ends_with('\\''));\n+        let symbol = &quoted[1..quoted.len() - 1];\n+        Literal::new(bridge::LitKind::Char, symbol, None)\n     }\n \n     /// Byte string literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn byte_string(bytes: &[u8]) -> Literal {\n-        Literal(bridge::client::Literal::byte_string(bytes))\n+        let string = bytes\n+            .iter()\n+            .cloned()\n+            .flat_map(std::ascii::escape_default)\n+            .map(Into::<char>::into)\n+            .collect::<String>();\n+        Literal::new(bridge::LitKind::ByteStr, &string, None)\n     }\n \n     /// Returns the span encompassing this literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n-        Span(self.0.span())\n+        Span(self.0.span)\n     }\n \n     /// Configures the span associated for this literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n-        self.0.set_span(span.0);\n+        self.0.span = span.0;\n     }\n \n     /// Returns a `Span` that is a subset of `self.span()` containing only the\n@@ -1333,7 +1379,50 @@ impl Literal {\n     // was 'c' or whether it was '\\u{63}'.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span> {\n-        self.0.subspan(range.start_bound().cloned(), range.end_bound().cloned()).map(Span)\n+        self.0.span.subspan(range.start_bound().cloned(), range.end_bound().cloned()).map(Span)\n+    }\n+\n+    fn with_symbol_and_suffix<R>(&self, f: impl FnOnce(&str, &str) -> R) -> R {\n+        self.0.symbol.with(|symbol| match self.0.suffix {\n+            Some(suffix) => suffix.with(|suffix| f(symbol, suffix)),\n+            None => f(symbol, \"\"),\n+        })\n+    }\n+\n+    /// Invokes the callback with a `&[&str]` consisting of each part of the\n+    /// literal's representation. This is done to allow the `ToString` and\n+    /// `Display` implementations to borrow references to symbol values, and\n+    /// both be optimized to reduce overhead.\n+    fn with_stringify_parts<R>(&self, f: impl FnOnce(&[&str]) -> R) -> R {\n+        /// Returns a string containing exactly `num` '#' characters.\n+        /// Uses a 256-character source string literal which is always safe to\n+        /// index with a `u8` index.\n+        fn get_hashes_str(num: u8) -> &'static str {\n+            const HASHES: &str = \"\\\n+            ################################################################\\\n+            ################################################################\\\n+            ################################################################\\\n+            ################################################################\\\n+            \";\n+            const _: () = assert!(HASHES.len() == 256);\n+            &HASHES[..num as usize]\n+        }\n+\n+        self.with_symbol_and_suffix(|symbol, suffix| match self.0.kind {\n+            bridge::LitKind::Byte => f(&[\"b'\", symbol, \"'\", suffix]),\n+            bridge::LitKind::Char => f(&[\"'\", symbol, \"'\", suffix]),\n+            bridge::LitKind::Str => f(&[\"\\\"\", symbol, \"\\\"\", suffix]),\n+            bridge::LitKind::StrRaw(n) => {\n+                let hashes = get_hashes_str(n);\n+                f(&[\"r\", hashes, \"\\\"\", symbol, \"\\\"\", hashes, suffix])\n+            }\n+            bridge::LitKind::ByteStr => f(&[\"b\\\"\", symbol, \"\\\"\", suffix]),\n+            bridge::LitKind::ByteStrRaw(n) => {\n+                let hashes = get_hashes_str(n);\n+                f(&[\"br\", hashes, \"\\\"\", symbol, \"\\\"\", hashes, suffix])\n+            }\n+            _ => f(&[symbol, suffix]),\n+        })\n     }\n }\n \n@@ -1352,19 +1441,17 @@ impl FromStr for Literal {\n     type Err = LexError;\n \n     fn from_str(src: &str) -> Result<Self, LexError> {\n-        match bridge::client::Literal::from_str(src) {\n+        match bridge::client::FreeFunctions::literal_from_str(src) {\n             Ok(literal) => Ok(Literal(literal)),\n             Err(()) => Err(LexError),\n         }\n     }\n }\n \n-// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n-// based on it (the reverse of the usual relationship between the two).\n-#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl ToString for Literal {\n     fn to_string(&self) -> String {\n-        self.0.to_string()\n+        self.with_stringify_parts(|parts| parts.concat())\n     }\n }\n \n@@ -1373,14 +1460,26 @@ impl ToString for Literal {\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Literal {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n+        self.with_stringify_parts(|parts| {\n+            for part in parts {\n+                fmt::Display::fmt(part, f)?;\n+            }\n+            Ok(())\n+        })\n     }\n }\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Literal {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n+        f.debug_struct(\"Literal\")\n+            // format the kind on one line even in {:#?} mode\n+            .field(\"kind\", &format_args!(\"{:?}\", &self.0.kind))\n+            .field(\"symbol\", &self.0.symbol)\n+            // format `Some(\"...\")` on one line even in {:#?} mode\n+            .field(\"suffix\", &format_args!(\"{:?}\", &self.0.suffix))\n+            .field(\"span\", &self.0.span)\n+            .finish()\n     }\n }\n "}, {"sha": "151f6203439f793136bf2f6124d07b60962160e0", "filename": "src/test/ui/proc-macro/invalid-punct-ident-2.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -1,17 +1,9 @@\n // aux-build:invalid-punct-ident.rs\n-// rustc-env:RUST_BACKTRACE=0\n-\n-// FIXME https://github.com/rust-lang/rust/issues/59998\n-// normalize-stderr-test \"thread.*panicked.*proc_macro_server.rs.*\\n\" -> \"\"\n-// normalize-stderr-test \"note:.*RUST_BACKTRACE=1.*\\n\" -> \"\"\n-// normalize-stderr-test \"\\nerror: internal compiler error.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note:.*unexpectedly panicked.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note: we would appreciate a bug report.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note: rustc.*running on.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"query stack during panic:\\n\" -> \"\"\n-// normalize-stderr-test \"we're just showing a limited slice of the query stack\\n\" -> \"\"\n-// normalize-stderr-test \"end of query stack\\n\" -> \"\"\n+// ignore-stage1\n+// only-linux\n+//\n+// FIXME: This should be a normal (stage1, all platforms) test in\n+// src/test/ui/proc-macro once issue #59998 is fixed.\n \n #[macro_use]\n extern crate invalid_punct_ident;"}, {"sha": "0bd07bd649e47605e416e4ffb95782a78fa55140", "filename": "src/test/ui/proc-macro/invalid-punct-ident-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.stderr?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -1,5 +1,5 @@\n error: proc macro panicked\n-  --> $DIR/invalid-punct-ident-2.rs:19:1\n+  --> $DIR/invalid-punct-ident-2.rs:11:1\n    |\n LL | invalid_ident!();\n    | ^^^^^^^^^^^^^^^^"}, {"sha": "7c22a56b6fbe9fbedfb43da3a69d33d78b19c10d", "filename": "src/test/ui/proc-macro/invalid-punct-ident-3.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -1,17 +1,9 @@\n // aux-build:invalid-punct-ident.rs\n-// rustc-env:RUST_BACKTRACE=0\n-\n-// FIXME https://github.com/rust-lang/rust/issues/59998\n-// normalize-stderr-test \"thread.*panicked.*proc_macro_server.rs.*\\n\" -> \"\"\n-// normalize-stderr-test \"note:.*RUST_BACKTRACE=1.*\\n\" -> \"\"\n-// normalize-stderr-test \"\\nerror: internal compiler error.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note:.*unexpectedly panicked.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note: we would appreciate a bug report.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note: rustc.*running on.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"query stack during panic:\\n\" -> \"\"\n-// normalize-stderr-test \"we're just showing a limited slice of the query stack\\n\" -> \"\"\n-// normalize-stderr-test \"end of query stack\\n\" -> \"\"\n+// ignore-stage1\n+// only-linux\n+//\n+// FIXME: This should be a normal (stage1, all platforms) test in\n+// src/test/ui/proc-macro once issue #59998 is fixed.\n \n #[macro_use]\n extern crate invalid_punct_ident;"}, {"sha": "a0cc5ef6e2d621552f8175007c37ab33383b6098", "filename": "src/test/ui/proc-macro/invalid-punct-ident-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c3f35504d15e80b4727872c17c8c2f4bbaee58cf/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.stderr?ref=c3f35504d15e80b4727872c17c8c2f4bbaee58cf", "patch": "@@ -1,5 +1,5 @@\n error: proc macro panicked\n-  --> $DIR/invalid-punct-ident-3.rs:19:1\n+  --> $DIR/invalid-punct-ident-3.rs:11:1\n    |\n LL | invalid_raw_ident!();\n    | ^^^^^^^^^^^^^^^^^^^^"}]}