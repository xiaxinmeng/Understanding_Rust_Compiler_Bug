{"sha": "1a51bb8174e97251a37fcd83ff8750b7773e762a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNTFiYjgxNzRlOTcyNTFhMzdmY2Q4M2ZmODc1MGI3NzczZTc2MmE=", "commit": {"author": {"name": "tyler", "email": "tyler@brainiumstudios.com", "date": "2019-01-16T04:09:06Z"}, "committer": {"name": "tyler", "email": "tyler@brainiumstudios.com", "date": "2019-01-16T04:09:06Z"}, "message": "OSX: fix #57534 registering thread dtors while running thread dtors", "tree": {"sha": "6be072ace8dc30fa353030cdce39cf768aa4c896", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6be072ace8dc30fa353030cdce39cf768aa4c896"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a51bb8174e97251a37fcd83ff8750b7773e762a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a51bb8174e97251a37fcd83ff8750b7773e762a", "html_url": "https://github.com/rust-lang/rust/commit/1a51bb8174e97251a37fcd83ff8750b7773e762a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a51bb8174e97251a37fcd83ff8750b7773e762a/comments", "author": {"login": "mtak-", "id": 6643140, "node_id": "MDQ6VXNlcjY2NDMxNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6643140?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mtak-", "html_url": "https://github.com/mtak-", "followers_url": "https://api.github.com/users/mtak-/followers", "following_url": "https://api.github.com/users/mtak-/following{/other_user}", "gists_url": "https://api.github.com/users/mtak-/gists{/gist_id}", "starred_url": "https://api.github.com/users/mtak-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mtak-/subscriptions", "organizations_url": "https://api.github.com/users/mtak-/orgs", "repos_url": "https://api.github.com/users/mtak-/repos", "events_url": "https://api.github.com/users/mtak-/events{/privacy}", "received_events_url": "https://api.github.com/users/mtak-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mtak-", "id": 6643140, "node_id": "MDQ6VXNlcjY2NDMxNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6643140?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mtak-", "html_url": "https://github.com/mtak-", "followers_url": "https://api.github.com/users/mtak-/followers", "following_url": "https://api.github.com/users/mtak-/following{/other_user}", "gists_url": "https://api.github.com/users/mtak-/gists{/gist_id}", "starred_url": "https://api.github.com/users/mtak-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mtak-/subscriptions", "organizations_url": "https://api.github.com/users/mtak-/orgs", "repos_url": "https://api.github.com/users/mtak-/repos", "events_url": "https://api.github.com/users/mtak-/events{/privacy}", "received_events_url": "https://api.github.com/users/mtak-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2f221c75932de7a29845c8d6f1f73536ad00c41", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2f221c75932de7a29845c8d6f1f73536ad00c41", "html_url": "https://github.com/rust-lang/rust/commit/e2f221c75932de7a29845c8d6f1f73536ad00c41"}], "stats": {"total": 69, "additions": 45, "deletions": 24}, "files": [{"sha": "742ffd12b883dc89035c73c81aae9379a2a02bf7", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1a51bb8174e97251a37fcd83ff8750b7773e762a/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a51bb8174e97251a37fcd83ff8750b7773e762a/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=1a51bb8174e97251a37fcd83ff8750b7773e762a", "patch": "@@ -33,30 +33,57 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n     register_dtor_fallback(t, dtor);\n }\n \n-// macOS's analog of the above linux function is this _tlv_atexit function.\n-// The disassembly of thread_local globals in C++ (at least produced by\n-// clang) will have this show up in the output.\n+// This implementation is very similar to register_dtor_fallback in\n+// sys_common/thread_local.rs. The main difference is that we want to hook into\n+// macOS's analog of the above linux function, _tlv_atexit. OSX will run the\n+// registered dtors before any TLS slots get freed, and when the main thread\n+// exits.\n+//\n+// Unfortunately, calling _tlv_atexit while tls dtors are running is UB. The\n+// workaround below is to register, via _tlv_atexit, a custom DTOR list once per\n+// thread. thread_local dtors are pushed to the DTOR list without calling\n+// _tlv_atexit.\n #[cfg(target_os = \"macos\")]\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    use cell::Cell;\n+    use ptr;\n+\n+    #[thread_local]\n+    static REGISTERED: Cell<bool> = Cell::new(false);\n+    if !REGISTERED.get() {\n+        _tlv_atexit(run_dtors, ptr::null_mut());\n+        REGISTERED.set(true);\n+    }\n+\n+    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n+\n+    #[thread_local]\n+    static DTORS: Cell<*mut List> = Cell::new(ptr::null_mut());\n+    if DTORS.get().is_null() {\n+        let v: Box<List> = box Vec::new();\n+        DTORS.set(Box::into_raw(v));\n+    }\n+\n     extern {\n         fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),\n                        arg: *mut u8);\n     }\n-    _tlv_atexit(dtor, t);\n+\n+    let list: &mut List = &mut *DTORS.get();\n+    list.push((t, dtor));\n+\n+    unsafe extern fn run_dtors(_: *mut u8) {\n+        let mut ptr = DTORS.replace(ptr::null_mut());\n+        while !ptr.is_null() {\n+            let list = Box::from_raw(ptr);\n+            for (ptr, dtor) in list.into_iter() {\n+                dtor(ptr);\n+            }\n+            ptr = DTORS.replace(ptr::null_mut());\n+        }\n+    }\n }\n \n pub fn requires_move_before_drop() -> bool {\n-    // The macOS implementation of TLS apparently had an odd aspect to it\n-    // where the pointer we have may be overwritten while this destructor\n-    // is running. Specifically if a TLS destructor re-accesses TLS it may\n-    // trigger a re-initialization of all TLS variables, paving over at\n-    // least some destroyed ones with initial values.\n-    //\n-    // This means that if we drop a TLS value in place on macOS that we could\n-    // revert the value to its original state halfway through the\n-    // destructor, which would be bad!\n-    //\n-    // Hence, we use `ptr::read` on macOS (to move to a \"safe\" location)\n-    // instead of drop_in_place.\n-    cfg!(target_os = \"macos\")\n+    false\n }"}, {"sha": "5d2eb5f8e7320e09210a927efd3411ff3b0b9791", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a51bb8174e97251a37fcd83ff8750b7773e762a/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a51bb8174e97251a37fcd83ff8750b7773e762a/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=1a51bb8174e97251a37fcd83ff8750b7773e762a", "patch": "@@ -69,9 +69,6 @@ use mem;\n ///    destroyed, but not all platforms have this guard. Those platforms that do\n ///    not guard typically have a synthetic limit after which point no more\n ///    destructors are run.\n-/// 3. On macOS, initializing TLS during destruction of other TLS slots can\n-///    sometimes cancel *all* destructors for the current thread, whether or not\n-///    the slots have already had their destructors run or not.\n ///\n /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n /// [`thread_local!`]: ../../std/macro.thread_local.html\n@@ -604,11 +601,8 @@ mod tests {\n     }\n \n     // Note that this test will deadlock if TLS destructors aren't run (this\n-    // requires the destructor to be run to pass the test). macOS has a known bug\n-    // where dtors-in-dtors may cancel other destructors, so we just ignore this\n-    // test on macOS.\n+    // requires the destructor to be run to pass the test).\n     #[test]\n-    #[cfg_attr(target_os = \"macos\", ignore)]\n     fn dtors_in_dtors_in_dtors() {\n         struct S1(Sender<()>);\n         thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));"}]}