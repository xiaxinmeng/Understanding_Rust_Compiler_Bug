{"sha": "df7c42bcc8df8401a508ec3a26d28467f2349cab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmN2M0MmJjYzhkZjg0MDFhNTA4ZWMzYTI2ZDI4NDY3ZjIzNDljYWI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-28T08:16:36Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-01T07:56:21Z"}, "message": "Move a method used everywhere out of `intrinsic.rs`", "tree": {"sha": "c937581d55b6abd3c889d92ff550570d04bb3b6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c937581d55b6abd3c889d92ff550570d04bb3b6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df7c42bcc8df8401a508ec3a26d28467f2349cab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmANCUACgkQpp+NIls6\n19ni8Q//beUPCwJbFe0FnTkCUYE2a4Nm3DELXNy8D1RxwHN+Z0iVmbYTI5FI2gMq\nP8mYDwbcaZxpJLFLdFAZj5/iWTmYmwS+WI7ED8c1JQGB/loSGs3VJwWWVV5XGY1E\n6oH1AkLzuYIg/6w5uhdr5/hICgCsU93lrUyYApw+9xltgQegOJM1do9zJNJ2j1fl\nlv25GM0CD4jPgjL4pWRxW27URfO1vdM+lHncbRURxduyQDFQobX8T2tHVUkmVWGi\nkcfLUuyQnQtZ7pMgPG2SjRsjGxYsfiPTqUQ5+QCthHMBBpkGXFJg1/fLA9mOcLpu\nBgyVcBgWaZVZOzFpG0ISrMo1H95wcc+BTjd5p6IYnKUxa535oduBxQwJf+BP0Z2C\neSOTnyxWPWdTif0bQxqHeaz0eJNTLNC5nBdCqz7GHkrhk83pkuxCm4XMqJx9FCft\nFagqGTsn4jDmSbd+7SBcvjs84wQfypMuQYaEvLur6ARLI+nffIxzQ8um2I7Z5YNp\nHrM5ljFzPTc1pohaLAgZaPKG/oLyLzv6Vel+ct0IHneuJB6UTLqmWXi5c8qp0k9O\n2h0KHQDQ+I18X+ziL0T9j2lOeHc0XgNMRjK9qnnu2iXSEQMw6RrwSV0QbR18z8D4\nf4PFCR++aBjoG+vQBlC3iMCVbvITlYUgOv+EtMIWjKHTCi4vLF0=\n=VOPR\n-----END PGP SIGNATURE-----", "payload": "tree c937581d55b6abd3c889d92ff550570d04bb3b6f\nparent e15d374ddabc0340df0bc7776ba5218da98799b3\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501229796 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501574181 +0200\n\nMove a method used everywhere out of `intrinsic.rs`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df7c42bcc8df8401a508ec3a26d28467f2349cab", "html_url": "https://github.com/rust-lang/rust/commit/df7c42bcc8df8401a508ec3a26d28467f2349cab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df7c42bcc8df8401a508ec3a26d28467f2349cab/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e15d374ddabc0340df0bc7776ba5218da98799b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e15d374ddabc0340df0bc7776ba5218da98799b3", "html_url": "https://github.com/rust-lang/rust/commit/e15d374ddabc0340df0bc7776ba5218da98799b3"}], "stats": {"total": 198, "additions": 96, "deletions": 102}, "files": [{"sha": "2b2e1f30c88e151b32c535cf51bd686745e71023", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 95, "deletions": 9, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/df7c42bcc8df8401a508ec3a26d28467f2349cab/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7c42bcc8df8401a508ec3a26d28467f2349cab/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=df7c42bcc8df8401a508ec3a26d28467f2349cab", "patch": "@@ -7,7 +7,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::middle::region::CodeExtent;\n use rustc::mir;\n use rustc::traits::Reveal;\n-use rustc::ty::layout::{self, Layout, Size};\n+use rustc::ty::layout::{self, Layout, Size, Align};\n use rustc::ty::subst::{Subst, Substs, Kind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Binder};\n use rustc::traits;\n@@ -277,6 +277,98 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.tcx.erase_regions(&value)\n     }\n \n+    pub fn size_and_align_of_dst(\n+        &mut self,\n+        ty: ty::Ty<'tcx>,\n+        value: Value,\n+    ) -> EvalResult<'tcx, (u64, u64)> {\n+        if let Some(size) = self.type_size(ty)? {\n+            Ok((size as u64, self.type_align(ty)? as u64))\n+        } else {\n+            match ty.sty {\n+                ty::TyAdt(def, substs) => {\n+                    // First get the size of all statically known fields.\n+                    // Don't use type_of::sizing_type_of because that expects t to be sized,\n+                    // and it also rounds up to alignment, which we want to avoid,\n+                    // as the unsized field's alignment could be smaller.\n+                    assert!(!ty.is_simd());\n+                    let layout = self.type_layout(ty)?;\n+                    debug!(\"DST {} layout: {:?}\", ty, layout);\n+\n+                    let (sized_size, sized_align) = match *layout {\n+                        ty::layout::Layout::Univariant { ref variant, .. } => {\n+                            (variant.offsets.last().map_or(0, |o| o.bytes()), variant.align)\n+                        }\n+                        _ => {\n+                            bug!(\"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\",\n+                                 ty, layout);\n+                        }\n+                    };\n+                    debug!(\"DST {} statically sized prefix size: {} align: {:?}\",\n+                           ty, sized_size, sized_align);\n+\n+                    // Recurse to get the size of the dynamically sized field (must be\n+                    // the last field).\n+                    let last_field = def.struct_variant().fields.last().unwrap();\n+                    let field_ty = self.field_ty(substs, last_field);\n+                    let (unsized_size, unsized_align) = self.size_and_align_of_dst(field_ty, value)?;\n+\n+                    // FIXME (#26403, #27023): We should be adding padding\n+                    // to `sized_size` (to accommodate the `unsized_align`\n+                    // required of the unsized field that follows) before\n+                    // summing it with `sized_size`. (Note that since #26403\n+                    // is unfixed, we do not yet add the necessary padding\n+                    // here. But this is where the add would go.)\n+\n+                    // Return the sum of sizes and max of aligns.\n+                    let size = sized_size + unsized_size;\n+\n+                    // Choose max of two known alignments (combined value must\n+                    // be aligned according to more restrictive of the two).\n+                    let align = sized_align.max(Align::from_bytes(unsized_align, unsized_align).unwrap());\n+\n+                    // Issue #27023: must add any necessary padding to `size`\n+                    // (to make it a multiple of `align`) before returning it.\n+                    //\n+                    // Namely, the returned size should be, in C notation:\n+                    //\n+                    //   `size + ((size & (align-1)) ? align : 0)`\n+                    //\n+                    // emulated via the semi-standard fast bit trick:\n+                    //\n+                    //   `(size + (align-1)) & -align`\n+\n+                    let size = Size::from_bytes(size).abi_align(align).bytes();\n+                    Ok((size, align.abi()))\n+                }\n+                ty::TyDynamic(..) => {\n+                    let (_, vtable) = value.into_ptr_vtable_pair(&mut self.memory)?;\n+                    // the second entry in the vtable is the dynamic size of the object.\n+                    self.read_size_and_align_from_vtable(vtable)\n+                }\n+\n+                ty::TySlice(_) | ty::TyStr => {\n+                    let elem_ty = ty.sequence_element_type(self.tcx);\n+                    let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as u64;\n+                    let (_, len) = value.into_slice(&mut self.memory)?;\n+                    let align = self.type_align(elem_ty)?;\n+                    Ok((len * elem_size, align as u64))\n+                }\n+\n+                _ => bug!(\"size_of_val::<{:?}>\", ty),\n+            }\n+        }\n+    }\n+\n+    /// Returns the normalized type of a struct field\n+    fn field_ty(\n+        &self,\n+        param_substs: &Substs<'tcx>,\n+        f: &ty::FieldDef,\n+    ) -> ty::Ty<'tcx> {\n+        self.tcx.normalize_associated_type(&f.ty(self.tcx, param_substs))\n+    }\n+\n     pub(super) fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n         self.type_size_with_substs(ty, self.substs())\n     }\n@@ -1556,8 +1648,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let dest = self.force_allocation(dest)?.to_ptr()?;\n                 let iter = src_fields.zip(dst_fields).enumerate();\n                 for (i, (src_f, dst_f)) in iter {\n-                    let src_fty = monomorphize_field_ty(self.tcx, src_f, substs_a);\n-                    let dst_fty = monomorphize_field_ty(self.tcx, dst_f, substs_b);\n+                    let src_fty = self.field_ty(substs_a, src_f);\n+                    let dst_fty = self.field_ty(substs_b, dst_f);\n                     if self.type_size(dst_fty)? == Some(0) {\n                         continue;\n                     }\n@@ -1726,12 +1818,6 @@ impl IntegerExt for layout::Integer {\n     }\n }\n \n-\n-pub fn monomorphize_field_ty<'a, 'tcx:'a >(tcx: TyCtxt<'a, 'tcx, 'tcx>, f: &ty::FieldDef, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-    let substituted = f.ty(tcx, substs);\n-    tcx.normalize_associated_type(&substituted)\n-}\n-\n pub fn is_inhabited<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.uninhabited_from(&mut HashMap::default(), tcx).is_empty()\n }"}, {"sha": "7c81b76ba416915bd4b767cf1e7ec720d2f8a15e", "filename": "src/librustc_mir/interpret/terminator/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 93, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/df7c42bcc8df8401a508ec3a26d28467f2349cab/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7c42bcc8df8401a508ec3a26d28467f2349cab/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs?ref=df7c42bcc8df8401a508ec3a26d28467f2349cab", "patch": "@@ -1,7 +1,6 @@\n use rustc::mir;\n use rustc::traits::Reveal;\n-use rustc::ty::layout::{Layout, Size, Align};\n-use rustc::ty::subst::Substs;\n+use rustc::ty::layout::Layout;\n use rustc::ty::{self, Ty};\n \n use interpret::{\n@@ -487,97 +486,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // current frame.\n         Ok(())\n     }\n-\n-    pub fn size_and_align_of_dst(\n-        &mut self,\n-        ty: ty::Ty<'tcx>,\n-        value: Value,\n-    ) -> EvalResult<'tcx, (u64, u64)> {\n-        if let Some(size) = self.type_size(ty)? {\n-            Ok((size as u64, self.type_align(ty)? as u64))\n-        } else {\n-            match ty.sty {\n-                ty::TyAdt(def, substs) => {\n-                    // First get the size of all statically known fields.\n-                    // Don't use type_of::sizing_type_of because that expects t to be sized,\n-                    // and it also rounds up to alignment, which we want to avoid,\n-                    // as the unsized field's alignment could be smaller.\n-                    assert!(!ty.is_simd());\n-                    let layout = self.type_layout(ty)?;\n-                    debug!(\"DST {} layout: {:?}\", ty, layout);\n-\n-                    let (sized_size, sized_align) = match *layout {\n-                        ty::layout::Layout::Univariant { ref variant, .. } => {\n-                            (variant.offsets.last().map_or(0, |o| o.bytes()), variant.align)\n-                        }\n-                        _ => {\n-                            bug!(\"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\",\n-                                 ty, layout);\n-                        }\n-                    };\n-                    debug!(\"DST {} statically sized prefix size: {} align: {:?}\",\n-                           ty, sized_size, sized_align);\n-\n-                    // Recurse to get the size of the dynamically sized field (must be\n-                    // the last field).\n-                    let last_field = def.struct_variant().fields.last().unwrap();\n-                    let field_ty = self.field_ty(substs, last_field);\n-                    let (unsized_size, unsized_align) = self.size_and_align_of_dst(field_ty, value)?;\n-\n-                    // FIXME (#26403, #27023): We should be adding padding\n-                    // to `sized_size` (to accommodate the `unsized_align`\n-                    // required of the unsized field that follows) before\n-                    // summing it with `sized_size`. (Note that since #26403\n-                    // is unfixed, we do not yet add the necessary padding\n-                    // here. But this is where the add would go.)\n-\n-                    // Return the sum of sizes and max of aligns.\n-                    let size = sized_size + unsized_size;\n-\n-                    // Choose max of two known alignments (combined value must\n-                    // be aligned according to more restrictive of the two).\n-                    let align = sized_align.max(Align::from_bytes(unsized_align, unsized_align).unwrap());\n-\n-                    // Issue #27023: must add any necessary padding to `size`\n-                    // (to make it a multiple of `align`) before returning it.\n-                    //\n-                    // Namely, the returned size should be, in C notation:\n-                    //\n-                    //   `size + ((size & (align-1)) ? align : 0)`\n-                    //\n-                    // emulated via the semi-standard fast bit trick:\n-                    //\n-                    //   `(size + (align-1)) & -align`\n-\n-                    let size = Size::from_bytes(size).abi_align(align).bytes();\n-                    Ok((size, align.abi()))\n-                }\n-                ty::TyDynamic(..) => {\n-                    let (_, vtable) = value.into_ptr_vtable_pair(&self.memory)?;\n-                    // the second entry in the vtable is the dynamic size of the object.\n-                    self.read_size_and_align_from_vtable(vtable)\n-                }\n-\n-                ty::TySlice(_) | ty::TyStr => {\n-                    let elem_ty = ty.sequence_element_type(self.tcx);\n-                    let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as u64;\n-                    let (_, len) = value.into_slice(&self.memory)?;\n-                    let align = self.type_align(elem_ty)?;\n-                    Ok((len * elem_size, align as u64))\n-                }\n-\n-                _ => bug!(\"size_of_val::<{:?}>\", ty),\n-            }\n-        }\n-    }\n-    /// Returns the normalized type of a struct field\n-    fn field_ty(\n-        &self,\n-        param_substs: &Substs<'tcx>,\n-        f: &ty::FieldDef,\n-    ) -> ty::Ty<'tcx> {\n-        self.tcx.normalize_associated_type(&f.ty(self.tcx, param_substs))\n-    }\n }\n \n fn numeric_intrinsic<'tcx>("}]}