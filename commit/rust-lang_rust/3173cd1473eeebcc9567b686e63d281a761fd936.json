{"sha": "3173cd1473eeebcc9567b686e63d281a761fd936", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxNzNjZDE0NzNlZWViY2M5NTY3YjY4NmU2M2QyODFhNzYxZmQ5MzY=", "commit": {"author": {"name": "Amos Onn", "email": "amosonn@gmail.com", "date": "2020-01-28T21:14:04Z"}, "committer": {"name": "Amos Onn", "email": "amosonn@gmail.com", "date": "2020-02-03T00:03:33Z"}, "message": "Optimize core::ptr::align_offset\n\n- When calculating the inverse, it's enough to work `mod a/g` instead\n  of `mod a`.", "tree": {"sha": "f673080897a6f7b89bb88a1cdbad31f9215034b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f673080897a6f7b89bb88a1cdbad31f9215034b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3173cd1473eeebcc9567b686e63d281a761fd936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3173cd1473eeebcc9567b686e63d281a761fd936", "html_url": "https://github.com/rust-lang/rust/commit/3173cd1473eeebcc9567b686e63d281a761fd936", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3173cd1473eeebcc9567b686e63d281a761fd936/comments", "author": {"login": "amosonn", "id": 3142573, "node_id": "MDQ6VXNlcjMxNDI1NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3142573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amosonn", "html_url": "https://github.com/amosonn", "followers_url": "https://api.github.com/users/amosonn/followers", "following_url": "https://api.github.com/users/amosonn/following{/other_user}", "gists_url": "https://api.github.com/users/amosonn/gists{/gist_id}", "starred_url": "https://api.github.com/users/amosonn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amosonn/subscriptions", "organizations_url": "https://api.github.com/users/amosonn/orgs", "repos_url": "https://api.github.com/users/amosonn/repos", "events_url": "https://api.github.com/users/amosonn/events{/privacy}", "received_events_url": "https://api.github.com/users/amosonn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "amosonn", "id": 3142573, "node_id": "MDQ6VXNlcjMxNDI1NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3142573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amosonn", "html_url": "https://github.com/amosonn", "followers_url": "https://api.github.com/users/amosonn/followers", "following_url": "https://api.github.com/users/amosonn/following{/other_user}", "gists_url": "https://api.github.com/users/amosonn/gists{/gist_id}", "starred_url": "https://api.github.com/users/amosonn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amosonn/subscriptions", "organizations_url": "https://api.github.com/users/amosonn/orgs", "repos_url": "https://api.github.com/users/amosonn/repos", "events_url": "https://api.github.com/users/amosonn/events{/privacy}", "received_events_url": "https://api.github.com/users/amosonn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e835d0d761945bb242d271f5ccedf0aee54a4ca8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e835d0d761945bb242d271f5ccedf0aee54a4ca8", "html_url": "https://github.com/rust-lang/rust/commit/e835d0d761945bb242d271f5ccedf0aee54a4ca8"}], "stats": {"total": 33, "additions": 20, "deletions": 13}, "files": [{"sha": "805404b101b74f2fa2aefce7f3f4870b6c4b342b", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3173cd1473eeebcc9567b686e63d281a761fd936/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3173cd1473eeebcc9567b686e63d281a761fd936/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=3173cd1473eeebcc9567b686e63d281a761fd936", "patch": "@@ -1115,26 +1115,33 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n     let gcd = 1usize << gcdpow;\n \n-    if p as usize & (gcd - 1) == 0 {\n+    if p as usize & (gcd.wrapping_sub(1)) == 0 {\n         // This branch solves for the following linear congruence equation:\n         //\n-        // $$ p + so \u2261 0 mod a $$\n+        // ` p + so = 0 mod a `\n         //\n-        // $p$ here is the pointer value, $s$ \u2013 stride of `T`, $o$ offset in `T`s, and $a$ \u2013 the\n+        // `p` here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the\n         // requested alignment.\n         //\n-        // g = gcd(a, s)\n-        // o = (a - (p mod a))/g * ((s/g)\u207b\u00b9 mod a)\n+        // With `g = gcd(a, s)`, and the above asserting that `p` is also divisible by `g`, we can\n+        // denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n         //\n-        // The first term is \u201cthe relative alignment of p to a\u201d, the second term is \u201chow does\n-        // incrementing p by s bytes change the relative alignment of p\u201d. Division by `g` is\n-        // necessary to make this equation well formed if $a$ and $s$ are not co-prime.\n+        // ` p' + s'o = 0 mod a' `\n+        // ` o = (a' - (p' mod a')) * (s'^-1 mod a') `\n         //\n-        // Furthermore, the result produced by this solution is not \u201cminimal\u201d, so it is necessary\n-        // to take the result $o mod lcm(s, a)$. We can replace $lcm(s, a)$ with just a $a / g$.\n-        let j = a.wrapping_sub(pmoda) >> gcdpow;\n-        let k = smoda >> gcdpow;\n-        return (j.wrapping_mul(mod_inv(k, a))) & ((a >> gcdpow).wrapping_sub(1));\n+        // The first term is \"the relative alignment of `p` to `a`\" (divided by the `g`), the second\n+        // term is \"how does incrementing `p` by `s` bytes change the relative alignment of `p`\" (again\n+        // divided by `g`).\n+        // Division by `g` is necessary to make the inverse well formed if `a` and `s` are not\n+        // co-prime.\n+        //\n+        // Furthermore, the result produced by this solution is not \"minimal\", so it is necessary\n+        // to take the result `o mod lcm(s, a)`. We can replace `lcm(s, a)` with just a `a'`.\n+        let a2 = a >> gcdpow;\n+        let a2minus1 = a2.wrapping_sub(1);\n+        let s2 = smoda >> gcdpow;\n+        let minusp2 = a2.wrapping_sub(pmoda >> gcdpow);\n+        return (minusp2.wrapping_mul(mod_inv(s2, a2))) & a2minus1;\n     }\n \n     // Cannot be aligned at all."}]}