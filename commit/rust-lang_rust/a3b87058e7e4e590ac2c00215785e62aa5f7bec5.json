{"sha": "a3b87058e7e4e590ac2c00215785e62aa5f7bec5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYjg3MDU4ZTdlNGU1OTBhYzJjMDAyMTU3ODVlNjJhYTVmN2JlYzU=", "commit": {"author": {"name": "James Duley", "email": "james.duley@arm.com", "date": "2018-09-18T16:51:49Z"}, "committer": {"name": "James Duley", "email": "james.duley@arm.com", "date": "2018-09-18T17:06:16Z"}, "message": "Expand synchronization comments in `park`/`unpark`", "tree": {"sha": "a97238ce71c7c9c3ed0ebe117d61361d47e926d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a97238ce71c7c9c3ed0ebe117d61361d47e926d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3b87058e7e4e590ac2c00215785e62aa5f7bec5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3b87058e7e4e590ac2c00215785e62aa5f7bec5", "html_url": "https://github.com/rust-lang/rust/commit/a3b87058e7e4e590ac2c00215785e62aa5f7bec5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3b87058e7e4e590ac2c00215785e62aa5f7bec5/comments", "author": null, "committer": null, "parents": [{"sha": "f8a78bdfdfffffe74f516eec4303d7f3d4ac879e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8a78bdfdfffffe74f516eec4303d7f3d4ac879e", "html_url": "https://github.com/rust-lang/rust/commit/f8a78bdfdfffffe74f516eec4303d7f3d4ac879e"}], "stats": {"total": 21, "additions": 13, "deletions": 8}, "files": [{"sha": "3987ae83866e5c472fe6cebb13f1730c4e7d3768", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a3b87058e7e4e590ac2c00215785e62aa5f7bec5/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3b87058e7e4e590ac2c00215785e62aa5f7bec5/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=a3b87058e7e4e590ac2c00215785e62aa5f7bec5", "patch": "@@ -800,9 +800,12 @@ pub fn park() {\n     match thread.inner.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n         Ok(_) => {}\n         Err(NOTIFIED) => {\n-            // We must read again here, even though we know it will be NOTIFY,\n-            // to synchronize with an write in `unpark` that occurred since we\n-            // last read.\n+            // We must read here, even though we know it will be `NOTIFIED`.\n+            // This is because `unpark` may have been called again since we read\n+            // `NOTIFIED` in the `compare_exchange` above. We must perform an\n+            // acquire operation that synchronizes with that `unpark` to observe\n+            // any writes it made before the call to unpark. To do that we must\n+            // read from the write it made to `state`.\n             let old = thread.inner.state.swap(EMPTY, SeqCst);\n             assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n             return;\n@@ -893,9 +896,7 @@ pub fn park_timeout(dur: Duration) {\n     match thread.inner.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n         Ok(_) => {}\n         Err(NOTIFIED) => {\n-            // We must read again here, even though we know it will be NOTIFY,\n-            // to synchronize with an write in `unpark` that occurred since we\n-            // last read.\n+            // We must read again here, see `park`.\n             let old = thread.inner.state.swap(EMPTY, SeqCst);\n             assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n             return;\n@@ -1066,8 +1067,12 @@ impl Thread {\n     /// [park]: fn.park.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unpark(&self) {\n-        // We must unconditionally write NOTIFIED here to\n-        // synchronize with a read in `park`.\n+        // To ensure the unparked thread will observe any writes we made\n+        // before this call, we must perform a release operation that `park`\n+        // can synchronize with. To do that we must write `NOTIFIED` even if\n+        // `state` is already `NOTIFIED`. That is why this must be a swap\n+        // rather than a compare-and-swap that returns if it reads `NOTIFIED`\n+        // on failure.\n         match self.inner.state.swap(NOTIFIED, SeqCst) {\n             EMPTY => return, // no one was waiting\n             NOTIFIED => return, // already unparked"}]}