{"sha": "548e681f2f8c206c04158add722f737940a81269", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0OGU2ODFmMmY4YzIwNmMwNDE1OGFkZDcyMmY3Mzc5NDBhODEyNjk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-12T10:24:17Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-28T03:12:41Z"}, "message": "rustc_privacy: switch private-in-public checking to Ty.", "tree": {"sha": "6cbdd30880a9889b823462be4a0ed4ec30b4b3a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cbdd30880a9889b823462be4a0ed4ec30b4b3a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/548e681f2f8c206c04158add722f737940a81269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/548e681f2f8c206c04158add722f737940a81269", "html_url": "https://github.com/rust-lang/rust/commit/548e681f2f8c206c04158add722f737940a81269", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/548e681f2f8c206c04158add722f737940a81269/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcdb4def834b581739df7f2d044d015c557d3f32", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcdb4def834b581739df7f2d044d015c557d3f32", "html_url": "https://github.com/rust-lang/rust/commit/fcdb4def834b581739df7f2d044d015c557d3f32"}], "stats": {"total": 523, "additions": 289, "deletions": 234}, "files": [{"sha": "ee18968ff35e3b61bb3099eff84d675c5e084af8", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 183, "deletions": 149, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/548e681f2f8c206c04158add722f737940a81269/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548e681f2f8c206c04158add722f737940a81269/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=548e681f2f8c206c04158add722f737940a81269", "patch": "@@ -31,7 +31,7 @@ use rustc::hir::{self, PatKind};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor};\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::itemlikevisit::DeepVisitor;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::lint;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n@@ -899,190 +899,174 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    item_def_id: DefId,\n+    span: Span,\n     /// The visitor checks that each component type is at least this visible\n     required_visibility: ty::Visibility,\n     /// The visibility of the least visible component that has been visited\n     min_visibility: ty::Visibility,\n-    old_error_set: &'a NodeSet,\n+    has_old_errors: bool,\n }\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, old_error_set: &'a NodeSet) -> Self {\n-        SearchInterfaceForPrivateItemsVisitor {\n-            tcx: tcx,\n-            min_visibility: ty::Visibility::Public,\n-            required_visibility: ty::Visibility::PrivateExternal,\n-            old_error_set: old_error_set,\n-        }\n+    fn generics(&mut self) -> &mut Self {\n+        self.tcx.item_generics(self.item_def_id).visit_with(self);\n+        self\n     }\n-}\n \n-impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    // Return the visibility of the type alias's least visible component type when substituted\n-    fn substituted_alias_visibility(&self, item: &hir::Item, segment: &hir::PathSegment)\n-                                    -> Option<ty::Visibility> {\n-        // Type alias is considered public if the aliased type is\n-        // public, even if the type alias itself is private. So, something\n-        // like `type A = u8; pub fn f() -> A {...}` doesn't cause an error.\n-        if let hir::ItemTy(ref ty, ref generics) = item.node {\n-            let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx,\n-                                                                       self.old_error_set);\n-            check.visit_ty(ty);\n-            // If a private type alias with default type parameters is used in public\n-            // interface we must ensure, that the defaults are public if they are actually used.\n-            // ```\n-            // type Alias<T = Private> = T;\n-            // pub fn f() -> Alias {...} // `Private` is implicitly used here, so it must be public\n-            // ```\n-            let provided_params = segment.parameters.types().len();\n-            for ty_param in &generics.ty_params[provided_params..] {\n-                if let Some(ref default_ty) = ty_param.default {\n-                    check.visit_ty(default_ty);\n-                }\n-            }\n-            Some(check.min_visibility)\n-        } else {\n-            None\n-        }\n+    fn predicates(&mut self) -> &mut Self {\n+        self.tcx.item_predicates(self.item_def_id).visit_with(self);\n+        self\n+    }\n+\n+    fn item_type(&mut self) -> &mut Self {\n+        self.tcx.item_type(self.item_def_id).visit_with(self);\n+        self\n+    }\n+\n+    fn impl_trait_ref(&mut self) -> &mut Self {\n+        self.tcx.impl_trait_ref(self.item_def_id).visit_with(self);\n+        self\n     }\n }\n \n-impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n-        let def_and_segment = match ty.node {\n-            hir::TyPath(hir::QPath::Resolved(_, ref path)) => {\n-                Some((path.def, path.segments.last().unwrap()))\n-            }\n-            hir::TyPath(hir::QPath::TypeRelative(_, ref segment)) => {\n-                Some((self.tcx.tables().type_relative_path_defs[&ty.id], &**segment))\n-            }\n-            _ => None\n-        };\n-        if let Some((def, segment)) = def_and_segment {\n-            match def {\n-                Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n-                    // Public\n-                }\n-                Def::AssociatedTy(..)\n-                    if self.required_visibility == ty::Visibility::PrivateExternal => {\n+impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        let ty_def_id = match ty.sty {\n+            ty::TyAdt(adt, _) => Some(adt.did),\n+            ty::TyTrait(ref obj) => Some(obj.principal.def_id()),\n+            ty::TyProjection(ref proj) => {\n+                if self.required_visibility == ty::Visibility::PrivateExternal {\n                     // Conservatively approximate the whole type alias as public without\n                     // recursing into its components when determining impl publicity.\n                     // For example, `impl <Type as Trait>::Alias {...}` may be a public impl\n                     // even if both `Type` and `Trait` are private.\n                     // Ideally, associated types should be substituted in the same way as\n                     // free type aliases, but this isn't done yet.\n-                    return\n+                    return false;\n                 }\n-                Def::Struct(def_id) | Def::Union(def_id) | Def::Enum(def_id) |\n-                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id) => {\n-                    // Non-local means public (private items can't leave their crate, modulo bugs)\n-                    if let Some(mut node_id) = self.tcx.map.as_local_node_id(def_id) {\n-                        // Check the trait for associated types.\n-                        if let hir::map::NodeTraitItem(_) = self.tcx.map.get(node_id) {\n-                            node_id = self.tcx.map.get_parent(node_id);\n-                        }\n \n-                        let item = self.tcx.map.expect_item(node_id);\n-                        let vis = match self.substituted_alias_visibility(item, segment) {\n-                            Some(vis) => vis,\n-                            None => ty::Visibility::from_hir(&item.vis, node_id, self.tcx),\n-                        };\n+                Some(proj.trait_ref.def_id)\n+            }\n+            _ => None\n+        };\n \n-                        if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n-                            self.min_visibility = vis;\n-                        }\n-                        if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n-                            if self.tcx.sess.features.borrow().pub_restricted ||\n-                               self.old_error_set.contains(&ty.id) {\n-                                let mut err = struct_span_err!(self.tcx.sess, ty.span, E0446,\n-                                          \"private type in public interface\");\n-                                err.span_label(ty.span, &format!(\"can't leak private type\"));\n-                                err.emit();\n-                            } else {\n-                                self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                                       node_id,\n-                                                       ty.span,\n-                                                       format!(\"private type in public \\\n-                                                                interface (error E0446)\"));\n-                            }\n-                        }\n+        if let Some(def_id) = ty_def_id {\n+            // Non-local means public (private items can't leave their crate, modulo bugs)\n+            if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+                let item = self.tcx.map.expect_item(node_id);\n+                let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n+\n+                if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n+                    self.min_visibility = vis;\n+                }\n+                if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n+                    if self.tcx.sess.features.borrow().pub_restricted || self.has_old_errors {\n+                        let mut err = struct_span_err!(self.tcx.sess, self.span, E0446,\n+                            \"private type `{}` in public interface\", ty);\n+                        err.span_label(self.span, &format!(\"can't leak private type\"));\n+                        err.emit();\n+                    } else {\n+                        self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                               node_id,\n+                                               self.span,\n+                                               format!(\"private type `{}` in public \\\n+                                                        interface (error E0446)\", ty));\n                     }\n                 }\n-                _ => {}\n             }\n         }\n \n-        intravisit::walk_ty(self, ty);\n+        if let ty::TyProjection(ref proj) = ty.sty {\n+            // Avoid calling `visit_trait_ref` below on the trait,\n+            // as we have already checked the trait itself above.\n+            proj.trait_ref.super_visit_with(self)\n+        } else {\n+            ty.super_visit_with(self)\n+        }\n     }\n \n-    fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n+    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n         // Non-local means public (private items can't leave their crate, modulo bugs)\n-        let def_id = trait_ref.path.def.def_id();\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(trait_ref.def_id) {\n             let item = self.tcx.map.expect_item(node_id);\n             let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n \n             if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n                 self.min_visibility = vis;\n             }\n             if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n-                if self.tcx.sess.features.borrow().pub_restricted ||\n-                   self.old_error_set.contains(&trait_ref.ref_id) {\n-                    struct_span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n-                                     \"private trait in public interface\")\n-                        .span_label(trait_ref.path.span, &format!(\n+                if self.tcx.sess.features.borrow().pub_restricted || self.has_old_errors {\n+                    struct_span_err!(self.tcx.sess, self.span, E0445,\n+                                     \"private trait `{}` in public interface\", trait_ref)\n+                        .span_label(self.span, &format!(\n                                     \"private trait can't be public\"))\n                         .emit();\n                 } else {\n                     self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n                                            node_id,\n-                                           trait_ref.path.span,\n-                                           \"private trait in public interface (error E0445)\"\n-                                                .to_string());\n+                                           self.span,\n+                                           format!(\"private trait `{}` in public \\\n+                                                    interface (error E0445)\", trait_ref));\n                 }\n             }\n         }\n \n-        intravisit::walk_trait_ref(self, trait_ref);\n+        trait_ref.super_visit_with(self)\n     }\n-\n-    // Don't recurse into function bodies\n-    fn visit_block(&mut self, _: &hir::Block) {}\n-    // Don't recurse into expressions in array sizes or const initializers\n-    fn visit_expr(&mut self, _: &hir::Expr) {}\n-    // Don't recurse into patterns in function arguments\n-    fn visit_pat(&mut self, _: &hir::Pat) {}\n }\n \n struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     old_error_set: &'a NodeSet,\n+    inner_visibility: ty::Visibility,\n }\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n-    // A type is considered public if it doesn't contain any private components\n-    fn ty_visibility(&self, ty: &hir::Ty) -> ty::Visibility {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n-        check.visit_ty(ty);\n-        check.min_visibility\n-    }\n+    fn check(&self, item_id: ast::NodeId, required_visibility: ty::Visibility)\n+             -> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+        let mut has_old_errors = false;\n+\n+        // Slow path taken only if there any errors in the crate.\n+        for &id in self.old_error_set {\n+            // Walk up the nodes until we find `item_id` (or we hit a root).\n+            let mut id = id;\n+            loop {\n+                if id == item_id {\n+                    has_old_errors = true;\n+                    break;\n+                }\n+                let parent = self.tcx.map.get_parent_node(id);\n+                if parent == id {\n+                    break;\n+                }\n+                id = parent;\n+            }\n+\n+            if has_old_errors {\n+                break;\n+            }\n+        }\n \n-    // A trait reference is considered public if it doesn't contain any private components\n-    fn trait_ref_visibility(&self, trait_ref: &hir::TraitRef) -> ty::Visibility {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n-        check.visit_trait_ref(trait_ref);\n-        check.min_visibility\n+        SearchInterfaceForPrivateItemsVisitor {\n+            tcx: self.tcx,\n+            item_def_id: self.tcx.map.local_def_id(item_id),\n+            span: self.tcx.map.span(item_id),\n+            min_visibility: ty::Visibility::Public,\n+            required_visibility: required_visibility,\n+            has_old_errors: has_old_errors,\n+        }\n     }\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n+        let tcx = self.tcx;\n         let min = |vis1: ty::Visibility, vis2| {\n-            if vis1.is_at_least(vis2, &self.tcx.map) { vis2 } else { vis1 }\n+            if vis1.is_at_least(vis2, &tcx.map) { vis2 } else { vis1 }\n         };\n \n-        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n-        let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, self.tcx);\n+        let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, tcx);\n \n         match item.node {\n             // Crates are always public\n@@ -1093,56 +1077,87 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for PrivateItemsInPublicInterfacesVisitor\n             hir::ItemUse(..) => {}\n             // Subitems of these items have inherited publicity\n             hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n-            hir::ItemEnum(..) | hir::ItemTrait(..) | hir::ItemTy(..) => {\n-                check.required_visibility = item_visibility;\n-                check.visit_item(item);\n+            hir::ItemTy(..) => {\n+                self.check(item.id, item_visibility).generics().predicates().item_type();\n+\n+                // Recurse for e.g. `impl Trait` (see `visit_ty`).\n+                self.inner_visibility = item_visibility;\n+                intravisit::walk_item(self, item);\n+            }\n+            hir::ItemTrait(.., ref trait_items) => {\n+                self.check(item.id, item_visibility).generics().predicates();\n+\n+                for trait_item in trait_items {\n+                    let mut check = self.check(trait_item.id, item_visibility);\n+                    check.generics().predicates();\n+\n+                    if let hir::TypeTraitItem(_, None) = trait_item.node {\n+                        // No type to visit.\n+                    } else {\n+                        check.item_type();\n+                    }\n+                }\n+            }\n+            hir::ItemEnum(ref def, _) => {\n+                self.check(item.id, item_visibility).generics().predicates();\n+\n+                for variant in &def.variants {\n+                    for field in variant.node.data.fields() {\n+                        self.check(field.id, item_visibility).item_type();\n+                    }\n+                }\n             }\n             // Subitems of foreign modules have their own publicity\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    check.required_visibility =\n-                        ty::Visibility::from_hir(&foreign_item.vis, item.id, self.tcx);\n-                    check.visit_foreign_item(foreign_item);\n+                    let vis = ty::Visibility::from_hir(&foreign_item.vis, item.id, tcx);\n+                    self.check(foreign_item.id, vis).generics().predicates().item_type();\n                 }\n             }\n             // Subitems of structs and unions have their own publicity\n-            hir::ItemStruct(ref struct_def, ref generics) |\n-            hir::ItemUnion(ref struct_def, ref generics) => {\n-                check.required_visibility = item_visibility;\n-                check.visit_generics(generics);\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n+                self.check(item.id, item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n-                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, self.tcx);\n-                    check.required_visibility = min(item_visibility, field_visibility);\n-                    check.visit_struct_field(field);\n+                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, tcx);\n+                    self.check(field.id, min(item_visibility, field_visibility)).item_type();\n                 }\n             }\n             // The interface is empty\n             hir::ItemDefaultImpl(..) => {}\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n-            hir::ItemImpl(.., ref generics, None, ref ty, ref impl_item_refs) => {\n-                let ty_vis = self.ty_visibility(ty);\n-                check.required_visibility = ty_vis;\n-                check.visit_generics(generics);\n+            hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n+                let ty_vis = self.check(item.id, ty::Visibility::PrivateExternal)\n+                                 .item_type().min_visibility;\n+                self.check(item.id, ty_vis).generics().predicates();\n \n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     let impl_item_vis =\n-                        ty::Visibility::from_hir(&impl_item.vis, item.id, self.tcx);\n-                    check.required_visibility = min(impl_item_vis, ty_vis);\n-                    check.visit_impl_item(impl_item);\n+                        ty::Visibility::from_hir(&impl_item.vis, item.id, tcx);\n+                    self.check(impl_item.id, min(impl_item_vis, ty_vis))\n+                        .generics().predicates().item_type();\n+\n+                    // Recurse for e.g. `impl Trait` (see `visit_ty`).\n+                    self.inner_visibility = impl_item_vis;\n+                    intravisit::walk_impl_item(self, impl_item);\n                 }\n             }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n-            hir::ItemImpl(.., ref generics, Some(ref trait_ref), ref ty, ref impl_item_refs) => {\n-                let vis = min(self.ty_visibility(ty), self.trait_ref_visibility(trait_ref));\n-                check.required_visibility = vis;\n-                check.visit_generics(generics);\n+            hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n+                let vis = self.check(item.id, ty::Visibility::PrivateExternal)\n+                              .item_type().impl_trait_ref().min_visibility;\n+                self.check(item.id, vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n-                    check.visit_impl_item(impl_item);\n+                    self.check(impl_item.id, vis).generics().predicates().item_type();\n+\n+                    // Recurse for e.g. `impl Trait` (see `visit_ty`).\n+                    self.inner_visibility = vis;\n+                    intravisit::walk_impl_item(self, impl_item);\n                 }\n             }\n         }\n@@ -1151,6 +1166,24 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for PrivateItemsInPublicInterfacesVisitor\n     fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n         // handled in `visit_item` above\n     }\n+\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n+        if let hir::TyImplTrait(..) = ty.node {\n+            // Check the traits being exposed, as they're separate,\n+            // e.g. `impl Iterator<Item=T>` has two predicates,\n+            // `X: Iterator` and `<X as Iterator>::Item == T`,\n+            // where `X` is the `impl Iterator<Item=T>` itself,\n+            // stored in `item_predicates`, not in the `Ty` itself.\n+            self.check(ty.id, self.inner_visibility).predicates();\n+        }\n+\n+        intravisit::walk_ty(self, ty);\n+    }\n+\n+    // Don't recurse into expressions in array sizes or const initializers\n+    fn visit_expr(&mut self, _: &hir::Expr) {}\n+    // Don't recurse into patterns in function arguments\n+    fn visit_pat(&mut self, _: &hir::Pat) {}\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1202,8 +1235,9 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n             tcx: tcx,\n             old_error_set: &visitor.old_error_set,\n+            inner_visibility: ty::Visibility::Public,\n         };\n-        krate.visit_all_item_likes(&mut visitor);\n+        krate.visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n     }\n \n     visitor.access_levels"}, {"sha": "efef8305e53547734b7fd1255dd9c809bcaeff79", "filename": "src/test/compile-fail/E0445.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2FE0445.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2FE0445.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0445.rs?ref=548e681f2f8c206c04158add722f737940a81269", "patch": "@@ -13,13 +13,13 @@ trait Foo {\n }\n \n pub trait Bar : Foo {}\n-//~^ ERROR private trait in public interface [E0445]\n+//~^ ERROR private trait `Foo` in public interface [E0445]\n //~| NOTE private trait can't be public\n pub struct Bar2<T: Foo>(pub T);\n-//~^ ERROR private trait in public interface [E0445]\n+//~^ ERROR private trait `Foo` in public interface [E0445]\n //~| NOTE private trait can't be public\n pub fn foo<T: Foo> (t: T) {}\n-//~^ ERROR private trait in public interface [E0445]\n+//~^ ERROR private trait `Foo` in public interface [E0445]\n //~| NOTE private trait can't be public\n \n fn main() {}"}, {"sha": "aad3d52153a2d471b25dc5b5c54f1ddf0284773f", "filename": "src/test/compile-fail/issue-18389.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs?ref=548e681f2f8c206c04158add722f737940a81269", "patch": "@@ -14,7 +14,8 @@ use std::any::TypeId;\n trait Private<P, R> {\n     fn call(&self, p: P, r: R);\n }\n-pub trait Public: Private< //~ ERROR private trait in public interface\n+pub trait Public: Private<\n+//~^ ERROR private trait `Private<<Self as Public>::P, <Self as Public>::R>` in public interface\n     <Self as Public>::P,\n     <Self as Public>::R\n > {"}, {"sha": "3488310b128834dbbd866cbb4fa43e06addcf8a3", "filename": "src/test/compile-fail/issue-28514.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2Fissue-28514.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2Fissue-28514.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28514.rs?ref=548e681f2f8c206c04158add722f737940a81269", "patch": "@@ -21,7 +21,7 @@ mod inner {\n         fn b(&self) { }\n     }\n \n-    pub trait C: A + B { //~ ERROR private trait in public interface\n+    pub trait C: A + B { //~ ERROR private trait `inner::A` in public interface\n                          //~^ WARN will become a hard error\n         fn c(&self) { }\n     }"}, {"sha": "15b7edb32d41ddebac3326b6491bbfd4d1222608", "filename": "src/test/compile-fail/issue-30079.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2Fissue-30079.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2Fissue-30079.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30079.rs?ref=548e681f2f8c206c04158add722f737940a81269", "patch": "@@ -16,7 +16,7 @@ struct SemiPriv;\n mod m1 {\n     struct Priv;\n     impl ::SemiPriv {\n-        pub fn f(_: Priv) {} //~ ERROR private type in public interface\n+        pub fn f(_: Priv) {} //~ ERROR private type `m1::Priv` in public interface\n         //~^ WARNING hard error\n     }\n \n@@ -28,7 +28,7 @@ mod m1 {\n mod m2 {\n     struct Priv;\n     impl ::std::ops::Deref for ::SemiPriv {\n-        type Target = Priv; //~ ERROR private type in public interface\n+        type Target = Priv; //~ ERROR private type `m2::Priv` in public interface\n         //~^ WARNING hard error\n         fn deref(&self) -> &Self::Target { unimplemented!() }\n     }\n@@ -46,7 +46,7 @@ trait SemiPrivTrait {\n mod m3 {\n     struct Priv;\n     impl ::SemiPrivTrait for () {\n-        type Assoc = Priv; //~ ERROR private type in public interface\n+        type Assoc = Priv; //~ ERROR private type `m3::Priv` in public interface\n         //~^ WARNING hard error\n     }\n }"}, {"sha": "030fbfc4914497aacc910ecf9db41f8f2bdc6425", "filename": "src/test/compile-fail/private-in-public-lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs?ref=548e681f2f8c206c04158add722f737940a81269", "patch": "@@ -13,7 +13,7 @@ mod m1 {\n     struct Priv;\n \n     impl Pub {\n-        pub fn f() -> Priv {Priv} //~ ERROR private type in public interface\n+        pub fn f() -> Priv {Priv} //~ ERROR private type `m1::Priv` in public interface\n     }\n }\n \n@@ -24,7 +24,7 @@ mod m2 {\n     struct Priv;\n \n     impl Pub {\n-        pub fn f() -> Priv {Priv} //~ ERROR private type in public interface\n+        pub fn f() -> Priv {Priv} //~ ERROR private type `m2::Priv` in public interface\n     }\n }\n "}, {"sha": "3496348985d8d174ca8faae75cdb8e6013e2772d", "filename": "src/test/compile-fail/private-in-public-warn.rs", "status": "modified", "additions": 53, "deletions": 44, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs?ref=548e681f2f8c206c04158add722f737940a81269", "patch": "@@ -24,34 +24,34 @@ mod types {\n         type Alias;\n     }\n \n-    pub type Alias = Priv; //~ ERROR private type in public interface\n+    pub type Alias = Priv; //~ ERROR private type `types::Priv` in public interface\n     //~^ WARNING hard error\n     pub enum E {\n-        V1(Priv), //~ ERROR private type in public interface\n+        V1(Priv), //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n-        V2 { field: Priv }, //~ ERROR private type in public interface\n+        V2 { field: Priv }, //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n     }\n     pub trait Tr {\n-        const C: Priv = Priv; //~ ERROR private type in public interface\n+        const C: Priv = Priv; //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n-        type Alias = Priv; //~ ERROR private type in public interface\n+        type Alias = Priv; //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n-        fn f1(arg: Priv) {} //~ ERROR private type in public interface\n+        fn f1(arg: Priv) {} //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n-        fn f2() -> Priv { panic!() } //~ ERROR private type in public interface\n+        fn f2() -> Priv { panic!() } //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n     }\n     extern {\n-        pub static ES: Priv; //~ ERROR private type in public interface\n+        pub static ES: Priv; //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n-        pub fn ef1(arg: Priv); //~ ERROR private type in public interface\n+        pub fn ef1(arg: Priv); //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n-        pub fn ef2() -> Priv; //~ ERROR private type in public interface\n+        pub fn ef2() -> Priv; //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n     }\n     impl PubTr for Pub {\n-        type Alias = Priv; //~ ERROR private type in public interface\n+        type Alias = Priv; //~ ERROR private type `types::Priv` in public interface\n         //~^ WARNING hard error\n     }\n }\n@@ -61,22 +61,23 @@ mod traits {\n     pub struct Pub<T>(T);\n     pub trait PubTr {}\n \n-    pub type Alias<T: PrivTr> = T; //~ ERROR private trait in public interface\n+    pub type Alias<T: PrivTr> = T; //~ ERROR private trait `traits::PrivTr` in public interface\n     //~^ WARN trait bounds are not (yet) enforced in type definitions\n     //~| WARNING hard error\n-    pub trait Tr1: PrivTr {} //~ ERROR private trait in public interface\n+    pub trait Tr1: PrivTr {} //~ ERROR private trait `traits::PrivTr` in public interface\n     //~^ WARNING hard error\n-    pub trait Tr2<T: PrivTr> {} //~ ERROR private trait in public interface\n+    pub trait Tr2<T: PrivTr> {} //~ ERROR private trait `traits::PrivTr` in public interface\n         //~^ WARNING hard error\n     pub trait Tr3 {\n-        type Alias: PrivTr; //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n-        fn f<T: PrivTr>(arg: T) {} //~ ERROR private trait in public interface\n+        //~^ ERROR private trait `traits::PrivTr` in public interface\n+        //~| WARNING hard error\n+        type Alias: PrivTr;\n+        fn f<T: PrivTr>(arg: T) {} //~ ERROR private trait `traits::PrivTr` in public interface\n         //~^ WARNING hard error\n     }\n-    impl<T: PrivTr> Pub<T> {} //~ ERROR private trait in public interface\n+    impl<T: PrivTr> Pub<T> {} //~ ERROR private trait `traits::PrivTr` in public interface\n         //~^ WARNING hard error\n-    impl<T: PrivTr> PubTr for Pub<T> {} //~ ERROR private trait in public interface\n+    impl<T: PrivTr> PubTr for Pub<T> {} //~ ERROR private trait `traits::PrivTr` in public interface\n         //~^ WARNING hard error\n }\n \n@@ -85,18 +86,23 @@ mod traits_where {\n     pub struct Pub<T>(T);\n     pub trait PubTr {}\n \n-    pub type Alias<T> where T: PrivTr = T; //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n-    pub trait Tr2<T> where T: PrivTr {} //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n+    pub type Alias<T> where T: PrivTr = T;\n+        //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+        //~| WARNING hard error\n+    pub trait Tr2<T> where T: PrivTr {}\n+        //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+        //~| WARNING hard error\n     pub trait Tr3 {\n-        fn f<T>(arg: T) where T: PrivTr {} //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n+        fn f<T>(arg: T) where T: PrivTr {}\n+        //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+        //~| WARNING hard error\n     }\n-    impl<T> Pub<T> where T: PrivTr {} //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n-    impl<T> PubTr for Pub<T> where T: PrivTr {} //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n+    impl<T> Pub<T> where T: PrivTr {}\n+        //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+        //~| WARNING hard error\n+    impl<T> PubTr for Pub<T> where T: PrivTr {}\n+        //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+        //~| WARNING hard error\n }\n \n mod generics {\n@@ -105,13 +111,14 @@ mod generics {\n     trait PrivTr<T> {}\n     pub trait PubTr<T> {}\n \n-    pub trait Tr1: PrivTr<Pub> {} //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n-    pub trait Tr2: PubTr<Priv> {} //~ ERROR private type in public interface\n+    pub trait Tr1: PrivTr<Pub> {}\n+        //~^ ERROR private trait `generics::PrivTr<generics::Pub>` in public interface\n+        //~| WARNING hard error\n+    pub trait Tr2: PubTr<Priv> {} //~ ERROR private type `generics::Priv` in public interface\n         //~^ WARNING hard error\n-    pub trait Tr3: PubTr<[Priv; 1]> {} //~ ERROR private type in public interface\n+    pub trait Tr3: PubTr<[Priv; 1]> {} //~ ERROR private type `generics::Priv` in public interface\n         //~^ WARNING hard error\n-    pub trait Tr4: PubTr<Pub<Priv>> {} //~ ERROR private type in public interface\n+    pub trait Tr4: PubTr<Pub<Priv>> {} //~ ERROR private type `generics::Priv` in public interface\n         //~^ WARNING hard error\n }\n \n@@ -138,7 +145,7 @@ mod impls {\n         type Alias = Priv; // OK\n     }\n     impl PubTr for Pub {\n-        type Alias = Priv; //~ ERROR private type in public interface\n+        type Alias = Priv; //~ ERROR private type `impls::Priv` in public interface\n         //~^ WARNING hard error\n     }\n }\n@@ -210,23 +217,23 @@ mod aliases_pub {\n     pub trait Tr2: PrivUseAliasTr<PrivAlias> {} // OK\n \n     impl PrivAlias {\n-        pub fn f(arg: Priv) {} //~ ERROR private type in public interface\n+        pub fn f(arg: Priv) {} //~ ERROR private type `aliases_pub::Priv` in public interface\n         //~^ WARNING hard error\n     }\n     // This doesn't even parse\n     // impl <Priv as PrivTr>::AssocAlias {\n-    //     pub fn f(arg: Priv) {} // ERROR private type in public interface\n+    //     pub fn f(arg: Priv) {} // ERROR private type `aliases_pub::Priv` in public interface\n     // }\n     impl PrivUseAliasTr for PrivUseAlias {\n-        type Check = Priv; //~ ERROR private type in public interface\n+        type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n         //~^ WARNING hard error\n     }\n     impl PrivUseAliasTr for PrivAlias {\n-        type Check = Priv; //~ ERROR private type in public interface\n+        type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n         //~^ WARNING hard error\n     }\n     impl PrivUseAliasTr for <Priv as PrivTr>::AssocAlias {\n-        type Check = Priv; //~ ERROR private type in public interface\n+        type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n         //~^ WARNING hard error\n     }\n }\n@@ -251,11 +258,13 @@ mod aliases_priv {\n         type AssocAlias = Priv3;\n     }\n \n-    pub trait Tr1: PrivUseAliasTr {} //~ ERROR private trait in public interface\n-        //~^ WARNING hard error\n-    pub trait Tr2: PrivUseAliasTr<PrivAlias> {} //~ ERROR private trait in public interface\n-     //~^ ERROR private type in public interface\n+    pub trait Tr1: PrivUseAliasTr {}\n+        //~^ ERROR private trait `aliases_priv::PrivTr1` in public interface\n+        //~| WARNING hard error\n+    pub trait Tr2: PrivUseAliasTr<PrivAlias> {}\n+        //~^ ERROR private trait `aliases_priv::PrivTr1<aliases_priv::Priv2>` in public interface\n         //~| WARNING hard error\n+        //~| ERROR private type `aliases_priv::Priv2` in public interface\n         //~| WARNING hard error\n \n     impl PrivUseAlias {"}, {"sha": "b819ef116efe91d5c8eb0949404edd441c4ff79f", "filename": "src/test/compile-fail/private-in-public.rs", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2Fprivate-in-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548e681f2f8c206c04158add722f737940a81269/src%2Ftest%2Fcompile-fail%2Fprivate-in-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public.rs?ref=548e681f2f8c206c04158add722f737940a81269", "patch": "@@ -21,16 +21,16 @@ mod types {\n         type Alias;\n     }\n \n-    pub const C: Priv = Priv; //~ ERROR private type in public interface\n-    pub static S: Priv = Priv; //~ ERROR private type in public interface\n-    pub fn f1(arg: Priv) {} //~ ERROR private type in public interface\n-    pub fn f2() -> Priv { panic!() } //~ ERROR private type in public interface\n-    pub struct S1(pub Priv); //~ ERROR private type in public interface\n-    pub struct S2 { pub field: Priv } //~ ERROR private type in public interface\n+    pub const C: Priv = Priv; //~ ERROR private type `types::Priv` in public interface\n+    pub static S: Priv = Priv; //~ ERROR private type `types::Priv` in public interface\n+    pub fn f1(arg: Priv) {} //~ ERROR private type `types::Priv` in public interface\n+    pub fn f2() -> Priv { panic!() } //~ ERROR private type `types::Priv` in public interface\n+    pub struct S1(pub Priv); //~ ERROR private type `types::Priv` in public interface\n+    pub struct S2 { pub field: Priv } //~ ERROR private type `types::Priv` in public interface\n     impl Pub {\n-        pub const C: Priv = Priv; //~ ERROR private type in public interface\n-        pub fn f1(arg: Priv) {} //~ ERROR private type in public interface\n-        pub fn f2() -> Priv { panic!() } //~ ERROR private type in public interface\n+        pub const C: Priv = Priv; //~ ERROR private type `types::Priv` in public interface\n+        pub fn f1(arg: Priv) {} //~ ERROR private type `types::Priv` in public interface\n+        pub fn f2() -> Priv { panic!() } //~ ERROR private type `types::Priv` in public interface\n     }\n }\n \n@@ -39,11 +39,11 @@ mod traits {\n     pub struct Pub<T>(T);\n     pub trait PubTr {}\n \n-    pub enum E<T: PrivTr> { V(T) } //~ ERROR private trait in public interface\n-    pub fn f<T: PrivTr>(arg: T) {} //~ ERROR private trait in public interface\n-    pub struct S1<T: PrivTr>(T); //~ ERROR private trait in public interface\n-    impl<T: PrivTr> Pub<T> {\n-        pub fn f<U: PrivTr>(arg: U) {} //~ ERROR private trait in public interface\n+    pub enum E<T: PrivTr> { V(T) } //~ ERROR private trait `traits::PrivTr` in public interface\n+    pub fn f<T: PrivTr>(arg: T) {} //~ ERROR private trait `traits::PrivTr` in public interface\n+    pub struct S1<T: PrivTr>(T); //~ ERROR private trait `traits::PrivTr` in public interface\n+    impl<T: PrivTr> Pub<T> { //~ ERROR private trait `traits::PrivTr` in public interface\n+        pub fn f<U: PrivTr>(arg: U) {} //~ ERROR private trait `traits::PrivTr` in public interface\n     }\n }\n \n@@ -52,11 +52,16 @@ mod traits_where {\n     pub struct Pub<T>(T);\n     pub trait PubTr {}\n \n-    pub enum E<T> where T: PrivTr { V(T) } //~ ERROR private trait in public interface\n-    pub fn f<T>(arg: T) where T: PrivTr {} //~ ERROR private trait in public interface\n-    pub struct S1<T>(T) where T: PrivTr; //~ ERROR private trait in public interface\n+    pub enum E<T> where T: PrivTr { V(T) }\n+    //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+    pub fn f<T>(arg: T) where T: PrivTr {}\n+    //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+    pub struct S1<T>(T) where T: PrivTr;\n+    //~^ ERROR private trait `traits_where::PrivTr` in public interface\n     impl<T> Pub<T> where T: PrivTr {\n-        pub fn f<U>(arg: U) where U: PrivTr {} //~ ERROR private trait in public interface\n+    //~^ ERROR private trait `traits_where::PrivTr` in public interface\n+        pub fn f<U>(arg: U) where U: PrivTr {}\n+        //~^ ERROR private trait `traits_where::PrivTr` in public interface\n     }\n }\n \n@@ -66,9 +71,10 @@ mod generics {\n     trait PrivTr<T> {}\n     pub trait PubTr<T> {}\n \n-    pub fn f1(arg: [Priv; 1]) {} //~ ERROR private type in public interface\n-    pub fn f2(arg: Pub<Priv>) {} //~ ERROR private type in public interface\n-    pub fn f3(arg: Priv<Pub>) {} //~ ERROR private type in public interface\n+    pub fn f1(arg: [Priv; 1]) {} //~ ERROR private type `generics::Priv` in public interface\n+    pub fn f2(arg: Pub<Priv>) {} //~ ERROR private type `generics::Priv` in public interface\n+    pub fn f3(arg: Priv<Pub>) {}\n+    //~^ ERROR private type `generics::Priv<generics::Pub>` in public interface\n }\n \n mod impls {\n@@ -82,7 +88,7 @@ mod impls {\n     }\n \n     impl Pub {\n-        pub fn f(arg: Priv) {} //~ ERROR private type in public interface\n+        pub fn f(arg: Priv) {} //~ ERROR private type `impls::Priv` in public interface\n     }\n }\n \n@@ -101,15 +107,17 @@ mod aliases_pub {\n     use self::m::PubTr as PrivUseAliasTr;\n     type PrivAlias = m::Pub2;\n     trait PrivTr {\n-        type AssocAlias = m::Pub3;\n+        type Assoc = m::Pub3;\n     }\n     impl PrivTr for Priv {}\n \n     // This should be OK, but associated type aliases are not substituted yet\n-    pub fn f3(arg: <Priv as PrivTr>::AssocAlias) {} //~ ERROR private type in public interface\n+    pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n+    //~^ ERROR private type `<aliases_pub::Priv as aliases_pub::PrivTr>::Assoc` in public interface\n+    //~| ERROR private type `aliases_pub::Priv` in public interface\n \n     impl PrivUseAlias {\n-        pub fn f(arg: Priv) {} //~ ERROR private type in public interface\n+        pub fn f(arg: Priv) {} //~ ERROR private type `aliases_pub::Priv` in public interface\n     }\n }\n \n@@ -127,22 +135,25 @@ mod aliases_priv {\n     use self::PrivTr1 as PrivUseAliasTr;\n     type PrivAlias = Priv2;\n     trait PrivTr {\n-        type AssocAlias = Priv3;\n+        type Assoc = Priv3;\n     }\n     impl PrivTr for Priv {}\n \n-    pub fn f1(arg: PrivUseAlias) {} //~ ERROR private type in public interface\n-    pub fn f2(arg: PrivAlias) {} //~ ERROR private type in public interface\n-    pub fn f3(arg: <Priv as PrivTr>::AssocAlias) {} //~ ERROR private type in public interface\n+    pub fn f1(arg: PrivUseAlias) {} //~ ERROR private type `aliases_priv::Priv1` in public interface\n+    pub fn f2(arg: PrivAlias) {} //~ ERROR private type `aliases_priv::Priv2` in public interface\n+    pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n+    //~^ ERROR private type `<aliases_priv::Priv as aliases_priv::PrivTr>::Assoc` in public\n+    //~| ERROR private type `aliases_priv::Priv` in public interface\n }\n \n mod aliases_params {\n     struct Priv;\n     type PrivAliasGeneric<T = Priv> = T;\n     type Result<T> = ::std::result::Result<T, Priv>;\n \n-    pub fn f2(arg: PrivAliasGeneric) {} //~ ERROR private type in public interface\n-    pub fn f3(arg: Result<u8>) {} //~ ERROR private type in public interface\n+    pub fn f2(arg: PrivAliasGeneric) {}\n+    //~^ ERROR private type `aliases_params::Priv` in public interface\n+    pub fn f3(arg: Result<u8>) {} //~ ERROR private type `aliases_params::Priv` in public interface\n }\n \n fn main() {}"}]}