{"sha": "1475e2c923746c253da8027079c462d7e3d1022d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NzVlMmM5MjM3NDZjMjUzZGE4MDI3MDc5YzQ2MmQ3ZTNkMTAyMmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-11T15:14:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-11T15:14:32Z"}, "message": "Auto merge of #42388 - tschottdorf:projty-substs, r=nikomatsakis\n\nDowngrade ProjectionTy's TraitRef to its substs\n\nAddresses the second part of #42171 by removing the `TraitRef` from\n`ProjectionTy`, and directly storing its `Substs`.\n\nCloses #42171.", "tree": {"sha": "98051165e8511565e4fd4a6825b6b9c0711a2b53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98051165e8511565e4fd4a6825b6b9c0711a2b53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1475e2c923746c253da8027079c462d7e3d1022d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1475e2c923746c253da8027079c462d7e3d1022d", "html_url": "https://github.com/rust-lang/rust/commit/1475e2c923746c253da8027079c462d7e3d1022d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1475e2c923746c253da8027079c462d7e3d1022d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dddf24d96fedea7f2c91748ef8eb4500095a91a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dddf24d96fedea7f2c91748ef8eb4500095a91a8", "html_url": "https://github.com/rust-lang/rust/commit/dddf24d96fedea7f2c91748ef8eb4500095a91a8"}, {"sha": "687ee7fee4c8dd4121d5d3b3f9504acbd59652b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/687ee7fee4c8dd4121d5d3b3f9504acbd59652b7", "html_url": "https://github.com/rust-lang/rust/commit/687ee7fee4c8dd4121d5d3b3f9504acbd59652b7"}], "stats": {"total": 635, "additions": 341, "deletions": 294}, "files": [{"sha": "a1dd2caf786c207951ab26e97024d7e13734be44", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -187,7 +187,7 @@ for ty::OutlivesPredicate<A, B>\n }\n \n impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty });\n-impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { trait_ref, item_def_id });\n+impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { substs, item_def_id });\n \n \n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Predicate<'tcx> {\n@@ -599,8 +599,8 @@ impl_stable_hash_for!(struct ty::ExistentialTraitRef<'tcx> {\n });\n \n impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n-    trait_ref,\n-    item_name,\n+    item_def_id,\n+    substs,\n     ty\n });\n "}, {"sha": "7154ce9e38f5e855632258b4f757b8aba118e989", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -274,7 +274,7 @@ pub enum LateBoundRegionConversionTime {\n     HigherRankedType,\n \n     /// when projecting an associated type\n-    AssocTypeProjection(ast::Name),\n+    AssocTypeProjection(ast::Name), // FIXME(tschottdorf): should contain DefId, not Name\n }\n \n /// Reasons to create a region inference variable\n@@ -1277,14 +1277,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                            match_b: ty::TraitRef<'tcx>)\n                                            -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>>\n     {\n+        let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref(self.tcx), p.ty));\n         let span = cause.span;\n-        let match_trait_ref = match_a.skip_binder().projection_ty.trait_ref;\n         let trace = TypeTrace {\n             cause,\n-            values: TraitRefs(ExpectedFound::new(true, match_trait_ref, match_b))\n+            values: TraitRefs(ExpectedFound::new(true, match_pair.skip_binder().0, match_b))\n         };\n \n-        let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref, p.ty));\n         let mut combine = self.combine_fields(trace, param_env);\n         let result = combine.higher_ranked_match(span, &match_pair, &match_b, true)?;\n         Ok(InferOk { value: result, obligations: combine.obligations })"}, {"sha": "57f2f748b246ea892b7927b6efd82abcb3910fa9", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -1550,8 +1550,7 @@ impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n     pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n-            GenericKind::Projection(ref p) => tcx.mk_projection(\n-                p.trait_ref.clone(), p.item_name(tcx)),\n+            GenericKind::Projection(ref p) => tcx.mk_projection(p.item_def_id, p.substs),\n         }\n     }\n }"}, {"sha": "4f1eb6169209b2696c3803e29fd2c27858588195", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -470,8 +470,9 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n             let project_obligation = obligation.with(data.clone());\n             match project::poly_project_and_unify_type(selcx, &project_obligation) {\n                 Ok(None) => {\n+                    let tcx = selcx.tcx();\n                     pending_obligation.stalled_on =\n-                        trait_ref_type_vars(selcx, data.to_poly_trait_ref());\n+                        trait_ref_type_vars(selcx, data.to_poly_trait_ref(tcx));\n                     Ok(None)\n                 }\n                 Ok(v) => Ok(v),"}, {"sha": "9c04c013c4b1a63a73dbc40d779921eed243b791", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -354,7 +354,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     // direct equality here because all of these types\n                     // are part of the formal parameter listing, and\n                     // hence there should be no inference variables.\n-                    let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n+                    let projection_trait_ref = ty::Binder(data.trait_ref(self));\n                     let is_supertrait_of_current_trait =\n                         supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n "}, {"sha": "b5284852747f928e961b38c1ed21d7277200d7bd", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -365,9 +365,7 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // information is available.\n \n             let tcx = selcx.infcx().tcx;\n-            let def_id = tcx.associated_items(projection_ty.trait_ref.def_id).find(|i|\n-                i.name == projection_ty.item_name(tcx) && i.kind == ty::AssociatedKind::Type\n-            ).map(|i| i.def_id).unwrap();\n+            let def_id = projection_ty.item_def_id;\n             let ty_var = selcx.infcx().next_ty_var(\n                 TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n             let projection = ty::Binder(ty::ProjectionPredicate {\n@@ -447,8 +445,8 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // normalization. In that case, I think we will want this code:\n             //\n             // ```\n-            // let ty = selcx.tcx().mk_projection(projection_ty.trait_ref,\n-            //                                    projection_ty.item_name(tcx);\n+            // let ty = selcx.tcx().mk_projection(projection_ty.item_def_id,\n+            //                                    projection_ty.substs;\n             // return Some(NormalizedTy { value: v, obligations: vec![] });\n             // ```\n \n@@ -585,15 +583,13 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n                                       depth: usize)\n                                       -> NormalizedTy<'tcx>\n {\n-    let trait_ref = projection_ty.trait_ref.to_poly_trait_ref();\n+    let trait_ref = projection_ty.trait_ref(selcx.tcx()).to_poly_trait_ref();\n     let trait_obligation = Obligation { cause,\n                                         recursion_depth: depth,\n                                         param_env,\n                                         predicate: trait_ref.to_predicate() };\n     let tcx = selcx.infcx().tcx;\n-    let def_id = tcx.associated_items(projection_ty.trait_ref.def_id).find(|i|\n-        i.name == projection_ty.item_name(tcx) && i.kind == ty::AssociatedKind::Type\n-    ).map(|i| i.def_id).unwrap();\n+    let def_id = projection_ty.item_def_id;\n     let new_value = selcx.infcx().next_ty_var(\n         TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n     Normalized {\n@@ -654,7 +650,7 @@ fn project_type<'cx, 'gcx, 'tcx>(\n         selcx.infcx().report_overflow_error(&obligation, true);\n     }\n \n-    let obligation_trait_ref = &obligation.predicate.trait_ref;\n+    let obligation_trait_ref = &obligation.predicate.trait_ref(selcx.tcx());\n \n     debug!(\"project: obligation_trait_ref={:?}\", obligation_trait_ref);\n \n@@ -743,12 +739,10 @@ fn project_type<'cx, 'gcx, 'tcx>(\n                                   &obligation_trait_ref,\n                                   candidate)))\n         }\n-        None => {\n-            Ok(ProjectedTy::NoProgress(\n-                selcx.tcx().mk_projection(\n-                    obligation.predicate.trait_ref.clone(),\n-                    obligation.predicate.item_name(selcx.tcx()))))\n-        }\n+        None => Ok(ProjectedTy::NoProgress(\n+                    selcx.tcx().mk_projection(\n+                        obligation.predicate.item_def_id,\n+                        obligation.predicate.substs)))\n     }\n }\n \n@@ -788,10 +782,11 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n {\n     debug!(\"assemble_candidates_from_trait_def(..)\");\n \n+    let tcx = selcx.tcx();\n     // Check whether the self-type is itself a projection.\n     let (def_id, substs) = match obligation_trait_ref.self_ty().sty {\n         ty::TyProjection(ref data) => {\n-            (data.trait_ref.def_id, data.trait_ref.substs)\n+            (data.trait_ref(tcx).def_id, data.substs)\n         }\n         ty::TyAnon(def_id, substs) => (def_id, substs),\n         ty::TyInfer(ty::TyVar(_)) => {\n@@ -804,9 +799,9 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     };\n \n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_predicates = selcx.tcx().predicates_of(def_id);\n-    let bounds = trait_predicates.instantiate(selcx.tcx(), substs);\n-    let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates);\n+    let trait_predicates = tcx.predicates_of(def_id);\n+    let bounds = trait_predicates.instantiate(tcx, substs);\n+    let bounds = elaborate_predicates(tcx, bounds.predicates);\n     assemble_candidates_from_predicates(selcx,\n                                         obligation,\n                                         obligation_trait_ref,\n@@ -832,12 +827,12 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                predicate);\n         match predicate {\n             ty::Predicate::Projection(ref data) => {\n-                let tcx = selcx.tcx();\n-                let same_name = data.item_name(tcx) == obligation.predicate.item_name(tcx);\n+                let same_def_id =\n+                    data.0.projection_ty.item_def_id == obligation.predicate.item_def_id;\n \n-                let is_match = same_name && infcx.probe(|_| {\n+                let is_match = same_def_id && infcx.probe(|_| {\n                     let data_poly_trait_ref =\n-                        data.to_poly_trait_ref();\n+                        data.to_poly_trait_ref(infcx.tcx);\n                     let obligation_poly_trait_ref =\n                         obligation_trait_ref.to_poly_trait_ref();\n                     infcx.at(&obligation.cause, obligation.param_env)\n@@ -850,8 +845,8 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                 });\n \n                 debug!(\"assemble_candidates_from_predicates: candidate={:?} \\\n-                                                             is_match={} same_name={}\",\n-                       data, is_match, same_name);\n+                                                             is_match={} same_def_id={}\",\n+                       data, is_match, same_def_id);\n \n                 if is_match {\n                     candidate_set.vec.push(ctor(data.clone()));\n@@ -916,9 +911,10 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 // In either case, we handle this by not adding a\n                 // candidate for an impl if it contains a `default`\n                 // type.\n+                let item_name = selcx.tcx().associated_item(obligation.predicate.item_def_id).name;\n                 let node_item = assoc_ty_def(selcx,\n                                              impl_data.impl_def_id,\n-                                             obligation.predicate.item_name(selcx.tcx()));\n+                                             item_name);\n \n                 let is_default = if node_item.node.is_from_trait() {\n                     // If true, the impl inherited a `type Foo = Bar`\n@@ -1091,10 +1087,9 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n \n         // select only those projections that are actually projecting an\n         // item with the correct name\n-        let tcx = selcx.tcx();\n         let env_predicates = env_predicates.filter_map(|p| match p {\n             ty::Predicate::Projection(data) =>\n-                if data.item_name(tcx) == obligation.predicate.item_name(tcx) {\n+                if data.0.projection_ty.item_def_id == obligation.predicate.item_def_id {\n                     Some(data)\n                 } else {\n                     None\n@@ -1104,7 +1099,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n \n         // select those with a relevant trait-ref\n         let mut env_predicates = env_predicates.filter(|data| {\n-            let data_poly_trait_ref = data.to_poly_trait_ref();\n+            let data_poly_trait_ref = data.to_poly_trait_ref(selcx.tcx());\n             let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n             selcx.infcx().probe(|_| {\n                 selcx.infcx().at(&obligation.cause, obligation.param_env)\n@@ -1202,7 +1197,7 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n     // Note: we unwrap the binder here but re-create it below (1)\n     let ty::Binder((trait_ref, ret_type)) =\n         tcx.closure_trait_ref_and_return_type(fn_once_def_id,\n-                                              obligation.predicate.trait_ref.self_ty(),\n+                                              obligation.predicate.self_ty(),\n                                               fn_sig,\n                                               flag);\n \n@@ -1227,7 +1222,7 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n     let infcx = selcx.infcx();\n     let cause = obligation.cause.clone();\n     let param_env = obligation.param_env;\n-    let trait_ref = obligation.predicate.trait_ref;\n+    let trait_ref = obligation.predicate.trait_ref(infcx.tcx);\n     match infcx.match_poly_projection_predicate(cause, param_env, poly_projection, trait_ref) {\n         Ok(InferOk { value: ty_match, obligations }) => {\n             Progress {\n@@ -1258,7 +1253,8 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n \n     let tcx = selcx.tcx();\n     let param_env = obligation.param_env;\n-    let assoc_ty = assoc_ty_def(selcx, impl_def_id, obligation.predicate.item_name(tcx));\n+    let assoc_ty = assoc_ty_def(selcx, impl_def_id,\n+        tcx.associated_item(obligation.predicate.item_def_id).name);\n \n     let ty = if !assoc_ty.item.defaultness.has_value() {\n         // This means that the impl is missing a definition for the\n@@ -1267,7 +1263,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n         // just return TyError.\n         debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n                assoc_ty.item.name,\n-               obligation.predicate.trait_ref);\n+               obligation.predicate);\n         tcx.types.err\n     } else {\n         tcx.type_of(assoc_ty.item.def_id)"}, {"sha": "79da04df1df086c42538758c19cbb4f511b1bb28", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -1335,7 +1335,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                skol_map);\n \n         let (def_id, substs) = match skol_trait_predicate.trait_ref.self_ty().sty {\n-            ty::TyProjection(ref data) => (data.trait_ref.def_id, data.trait_ref.substs),\n+            ty::TyProjection(ref data) =>\n+                (data.trait_ref(self.tcx()).def_id, data.substs),\n             ty::TyAnon(def_id, substs) => (def_id, substs),\n             _ => {\n                 span_bug!("}, {"sha": "9c6047b28b5b0fc2e453be6c204eeaa197e79a5a", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -203,9 +203,9 @@ impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n         let def_ids: Vec<DefId> =\n             key.walk()\n                .filter_map(|t| match t.sty {\n-                   ty::TyAdt(adt_def, _) => Some(adt_def.did),\n-                   ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n-                   _ => None,\n+                    ty::TyAdt(adt_def, _) => Some(adt_def.did),\n+                    ty::TyProjection(ref proj) => Some(proj.item_def_id),\n+                    _ => None,\n                })\n                .collect();\n "}, {"sha": "c234f43e38779d67a4c7c1439209f9241fac08f1", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -28,7 +28,7 @@ use mir::transform::Passes;\n use ty::subst::{Kind, Substs};\n use ty::ReprOptions;\n use traits;\n-use ty::{self, TraitRef, Ty, TypeAndMut};\n+use ty::{self, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n@@ -1387,12 +1387,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_projection(self,\n-                         trait_ref: TraitRef<'tcx>,\n-                         item_name: Name)\n+                         item_def_id: DefId,\n+                         substs: &'tcx Substs<'tcx>)\n         -> Ty<'tcx> {\n-            // take a copy of substs so that we own the vectors inside\n-            let inner = ProjectionTy::from_ref_and_name(self, trait_ref, item_name);\n-            self.mk_ty(TyProjection(inner))\n+            self.mk_ty(TyProjection(ProjectionTy {\n+                item_def_id: item_def_id,\n+                substs: substs,\n+            }))\n         }\n \n     pub fn mk_closure(self,"}, {"sha": "3442cf0ef698a5fc86ece592800f4a4f59d11861", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -14,7 +14,7 @@ use ty::{self, BoundRegion, DefIdTree, Region, Ty, TyCtxt};\n \n use std::fmt;\n use syntax::abi;\n-use syntax::ast::{self, Name};\n+use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n@@ -47,7 +47,7 @@ pub enum TypeError<'tcx> {\n     Traits(ExpectedFound<DefId>),\n     VariadicMismatch(ExpectedFound<bool>),\n     CyclicTy,\n-    ProjectionNameMismatched(ExpectedFound<Name>),\n+    ProjectionMismatched(ExpectedFound<DefId>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n     TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>),\n@@ -154,11 +154,11 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        if values.expected { \"variadic\" } else { \"non-variadic\" },\n                        if values.found { \"variadic\" } else { \"non-variadic\" })\n             }\n-            ProjectionNameMismatched(ref values) => {\n+            ProjectionMismatched(ref values) => ty::tls::with(|tcx| {\n                 write!(f, \"expected {}, found {}\",\n-                       values.expected,\n-                       values.found)\n-            }\n+                       tcx.item_path_str(values.expected),\n+                       tcx.item_path_str(values.found))\n+            }),\n             ProjectionBoundsLength(ref values) => {\n                 write!(f, \"expected {} associated type bindings, found {}\",\n                        values.expected,"}, {"sha": "ce2bb23660ce09f13eadc47cbb61eb795ecf4bd2", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -193,12 +193,12 @@ impl FlagComputation {\n     }\n \n     fn add_existential_projection(&mut self, projection: &ty::ExistentialProjection) {\n-        self.add_substs(projection.trait_ref.substs);\n+        self.add_substs(projection.substs);\n         self.add_ty(projection.ty);\n     }\n \n     fn add_projection_ty(&mut self, projection_ty: &ty::ProjectionTy) {\n-        self.add_substs(projection_ty.trait_ref.substs);\n+        self.add_substs(projection_ty.substs);\n     }\n \n     fn add_substs(&mut self, substs: &Substs) {"}, {"sha": "a1cd92c7609154e2c2534162379d5aaa107d1f41", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -150,10 +150,6 @@ pub trait TypeVisitor<'tcx> : Sized {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n-        trait_ref.super_visit_with(self)\n-    }\n-\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n         r.super_visit_with(self)\n     }"}, {"sha": "3f1302e72e97492560ba3df8cad86436c9323141", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -1030,8 +1030,13 @@ pub struct ProjectionPredicate<'tcx> {\n pub type PolyProjectionPredicate<'tcx> = Binder<ProjectionPredicate<'tcx>>;\n \n impl<'tcx> PolyProjectionPredicate<'tcx> {\n-    pub fn item_name(&self, tcx: TyCtxt) -> Name {\n-        self.0.projection_ty.item_name(tcx) // safe to skip the binder to access a name\n+    pub fn to_poly_trait_ref(&self, tcx: TyCtxt) -> PolyTraitRef<'tcx> {\n+        // Note: unlike with TraitRef::to_poly_trait_ref(),\n+        // self.0.trait_ref is permitted to have escaping regions.\n+        // This is because here `self` has a `Binder` and so does our\n+        // return value, so we are preserving the number of binding\n+        // levels.\n+        ty::Binder(self.0.projection_ty.trait_ref(tcx))\n     }\n }\n \n@@ -1052,17 +1057,6 @@ impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> ToPolyTraitRef<'tcx> for PolyProjectionPredicate<'tcx> {\n-    fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n-        // Note: unlike with TraitRef::to_poly_trait_ref(),\n-        // self.0.trait_ref is permitted to have escaping regions.\n-        // This is because here `self` has a `Binder` and so does our\n-        // return value, so we are preserving the number of binding\n-        // levels.\n-        ty::Binder(self.0.projection_ty.trait_ref)\n-    }\n-}\n-\n pub trait ToPredicate<'tcx> {\n     fn to_predicate(&self) -> Predicate<'tcx>;\n }\n@@ -1132,8 +1126,7 @@ impl<'tcx> Predicate<'tcx> {\n                 vec![]\n             }\n             ty::Predicate::Projection(ref data) => {\n-                let trait_inputs = data.0.projection_ty.trait_ref.input_types();\n-                trait_inputs.chain(Some(data.0.ty)).collect()\n+                data.0.projection_ty.substs.types().chain(Some(data.0.ty)).collect()\n             }\n             ty::Predicate::WellFormed(data) => {\n                 vec![data]"}, {"sha": "0d9ef8196c79451aee01ff55727221a8b043a57e", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -225,13 +225,15 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n                            -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n-        let tcx = relation.tcx();\n-        if a.item_name(tcx) != b.item_name(tcx) {\n-            Err(TypeError::ProjectionNameMismatched(\n-                expected_found(relation, &a.item_name(tcx), &b.item_name(tcx))))\n+        if a.item_def_id != b.item_def_id {\n+            Err(TypeError::ProjectionMismatched(\n+                expected_found(relation, &a.item_def_id, &b.item_def_id)))\n         } else {\n-            let trait_ref = relation.relate(&a.trait_ref, &b.trait_ref)?;\n-            Ok(ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, a.item_name(tcx)))\n+            let substs = relation.relate(&a.substs, &b.substs)?;\n+            Ok(ty::ProjectionTy {\n+                item_def_id: a.item_def_id,\n+                substs: &substs,\n+            })\n         }\n     }\n }\n@@ -243,15 +245,15 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n                            -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n-        if a.item_name != b.item_name {\n-            Err(TypeError::ProjectionNameMismatched(\n-                expected_found(relation, &a.item_name, &b.item_name)))\n+        if a.item_def_id != b.item_def_id {\n+            Err(TypeError::ProjectionMismatched(\n+                expected_found(relation, &a.item_def_id, &b.item_def_id)))\n         } else {\n-            let trait_ref = relation.relate(&a.trait_ref, &b.trait_ref)?;\n             let ty = relation.relate(&a.ty, &b.ty)?;\n+            let substs = relation.relate(&a.substs, &b.substs)?;\n             Ok(ty::ExistentialProjection {\n-                trait_ref,\n-                item_name: a.item_name,\n+                item_def_id: a.item_def_id,\n+                substs: substs,\n                 ty,\n             })\n         }\n@@ -456,7 +458,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         (&ty::TyProjection(ref a_data), &ty::TyProjection(ref b_data)) =>\n         {\n             let projection_ty = relation.relate(a_data, b_data)?;\n-            Ok(tcx.mk_projection(projection_ty.trait_ref, projection_ty.item_name(tcx)))\n+            Ok(tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs))\n         }\n \n         (&ty::TyAnon(a_def_id, a_substs), &ty::TyAnon(b_def_id, b_substs))"}, {"sha": "b81bd595e25b0743ad14d18ed5749ac0ba5eba32", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -134,8 +134,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n     type Lifted = ty::ProjectionTy<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n                              -> Option<ty::ProjectionTy<'tcx>> {\n-        tcx.lift(&self.trait_ref).map(|trait_ref| {\n-            ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, self.item_name(tcx))\n+        tcx.lift(&self.substs).map(|substs| {\n+            ty::ProjectionTy {\n+                item_def_id: self.item_def_id,\n+                substs: substs,\n+            }\n         })\n     }\n }\n@@ -156,11 +159,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n     type Lifted = ty::ExistentialProjection<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&(self.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n+        tcx.lift(&self.substs).map(|substs| {\n             ty::ExistentialProjection {\n-                trait_ref,\n-                item_name: self.item_name,\n-                ty,\n+                substs,\n+                ty: tcx.lift(&self.ty).expect(\"type must lift when substs do\"),\n+                item_def_id: self.item_def_id,\n             }\n         })\n     }\n@@ -356,7 +359,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             Traits(x) => Traits(x),\n             VariadicMismatch(x) => VariadicMismatch(x),\n             CyclicTy => CyclicTy,\n-            ProjectionNameMismatched(x) => ProjectionNameMismatched(x),\n+            ProjectionMismatched(x) => ProjectionMismatched(x),\n             ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n \n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n@@ -621,10 +624,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.substs.visit_with(visitor)\n     }\n-\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        visitor.visit_trait_ref(*self)\n-    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialTraitRef<'tcx> {\n@@ -847,27 +846,27 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialProjection<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ExistentialProjection {\n-            trait_ref: self.trait_ref.fold_with(folder),\n-            item_name: self.item_name,\n             ty: self.ty.fold_with(folder),\n+            substs: self.substs.fold_with(folder),\n+            item_def_id: self.item_def_id,\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.trait_ref.visit_with(visitor) || self.ty.visit_with(visitor)\n+        self.substs.visit_with(visitor) || self.ty.visit_with(visitor)\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ProjectionTy {\n-            trait_ref: self.trait_ref.fold_with(folder),\n+            substs: self.substs.fold_with(folder),\n             item_def_id: self.item_def_id,\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.trait_ref.visit_with(visitor)\n+        self.substs.visit_with(visitor)\n     }\n }\n \n@@ -1018,7 +1017,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             Traits(x) => Traits(x),\n             VariadicMismatch(x) => VariadicMismatch(x),\n             CyclicTy => CyclicTy,\n-            ProjectionNameMismatched(x) => ProjectionNameMismatched(x),\n+            ProjectionMismatched(x) => ProjectionMismatched(x),\n             ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n             Sorts(x) => Sorts(x.fold_with(folder)),\n             TyParamDefaultMismatch(ref x) => TyParamDefaultMismatch(x.fold_with(folder)),\n@@ -1054,7 +1053,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             Traits(_) |\n             VariadicMismatch(_) |\n             CyclicTy |\n-            ProjectionNameMismatched(_) |\n+            ProjectionMismatched(_) |\n             ProjectionBoundsLength(_) => false,\n         }\n     }"}, {"sha": "5f89714b33fdabd9814396d90ebb2eb3de4ce047", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -11,7 +11,6 @@\n //! This module contains TypeVariants and its major components\n \n use hir::def_id::DefId;\n-use hir::map::DefPathHash;\n \n use middle::region;\n use ty::subst::{Substs, Subst};\n@@ -24,7 +23,7 @@ use std::iter;\n use std::cmp::Ordering;\n use syntax::abi;\n use syntax::ast::{self, Name};\n-use syntax::symbol::{keywords, InternedString};\n+use syntax::symbol::keywords;\n use util::nodemap::FxHashMap;\n \n use serialize;\n@@ -291,7 +290,8 @@ impl<'a, 'gcx, 'tcx> ExistentialPredicate<'tcx> {\n         use self::ExistentialPredicate::*;\n         match (*self, *other) {\n             (Trait(_), Trait(_)) => Ordering::Equal,\n-            (Projection(ref a), Projection(ref b)) => a.sort_key(tcx).cmp(&b.sort_key(tcx)),\n+            (Projection(ref a), Projection(ref b)) =>\n+                tcx.def_path_hash(a.item_def_id).cmp(&tcx.def_path_hash(b.item_def_id)),\n             (AutoTrait(ref a), AutoTrait(ref b)) =>\n                 tcx.trait_def(*a).def_path_hash.cmp(&tcx.trait_def(*b).def_path_hash),\n             (Trait(_), _) => Ordering::Less,\n@@ -551,8 +551,8 @@ impl fmt::Debug for TypeFlags {\n /// form this would be written `<T as Trait<..>>::N`.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ProjectionTy<'tcx> {\n-    /// The trait reference `T as Trait<..>`.\n-    pub trait_ref: ty::TraitRef<'tcx>,\n+    /// The parameters of the associated item.\n+    pub substs: &'tcx Substs<'tcx>,\n \n     /// The DefId of the TraitItem for the associated type N.\n     ///\n@@ -568,16 +568,28 @@ impl<'a, 'tcx> ProjectionTy<'tcx> {\n         tcx: TyCtxt, trait_ref: ty::TraitRef<'tcx>, item_name: Name\n     ) -> ProjectionTy<'tcx> {\n         let item_def_id = tcx.associated_items(trait_ref.def_id).find(\n-            |item| item.name == item_name).unwrap().def_id;\n+            |item| item.name == item_name && item.kind == ty::AssociatedKind::Type\n+        ).unwrap().def_id;\n \n         ProjectionTy {\n-            trait_ref,\n+            substs: trait_ref.substs,\n             item_def_id,\n         }\n     }\n \n-    pub fn item_name(self, tcx: TyCtxt) -> Name {\n-        tcx.associated_item(self.item_def_id).name\n+    /// Extracts the underlying trait reference from this projection.\n+    /// For example, if this is a projection of `<T as Iterator>::Item`,\n+    /// then this function would return a `T: Iterator` trait reference.\n+    pub fn trait_ref(&self, tcx: TyCtxt) -> ty::TraitRef<'tcx> {\n+        let def_id = tcx.associated_item(self.item_def_id).container.id();\n+        ty::TraitRef {\n+            def_id: def_id,\n+            substs: self.substs,\n+        }\n+    }\n+\n+    pub fn self_ty(&self) -> Ty<'tcx> {\n+        self.substs.type_at(0)\n     }\n }\n \n@@ -861,29 +873,24 @@ pub enum InferTy {\n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ExistentialProjection<'tcx> {\n-    pub trait_ref: ExistentialTraitRef<'tcx>,\n-    pub item_name: Name,\n+    pub item_def_id: DefId,\n+    pub substs: &'tcx Substs<'tcx>,\n     pub ty: Ty<'tcx>,\n }\n \n pub type PolyExistentialProjection<'tcx> = Binder<ExistentialProjection<'tcx>>;\n \n impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n-    pub fn item_name(&self) -> Name {\n-        self.item_name // safe to skip the binder to access a name\n-    }\n-\n-    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (DefPathHash, InternedString) {\n-        // We want something here that is stable across crate boundaries.\n-        // The DefId isn't but the `deterministic_hash` of the corresponding\n-        // DefPath is.\n-        let trait_def = tcx.trait_def(self.trait_ref.def_id);\n-        let def_path_hash = trait_def.def_path_hash;\n-\n-        // An `ast::Name` is also not stable (it's just an index into an\n-        // interning table), so map to the corresponding `InternedString`.\n-        let item_name = self.item_name.as_str();\n-        (def_path_hash, item_name)\n+    /// Extracts the underlying existential trait reference from this projection.\n+    /// For example, if this is a projection of `exists T. <T as Iterator>::Item == X`,\n+    /// then this function would return a `exists T. T: Iterator` existential trait\n+    /// reference.\n+    pub fn trait_ref(&self, tcx: TyCtxt) -> ty::ExistentialTraitRef<'tcx> {\n+        let def_id = tcx.associated_item(self.item_def_id).container.id();\n+        ty::ExistentialTraitRef{\n+            def_id: def_id,\n+            substs: self.substs,\n+        }\n     }\n \n     pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -894,24 +901,17 @@ impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n         assert!(!self_ty.has_escaping_regions());\n \n         ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy::from_ref_and_name(\n-                tcx,\n-                self.trait_ref.with_self_ty(tcx, self_ty),\n-                self.item_name),\n+            projection_ty: ty::ProjectionTy {\n+                item_def_id: self.item_def_id,\n+                substs: tcx.mk_substs(\n+                iter::once(Kind::from(self_ty)).chain(self.substs.iter().cloned())),\n+            },\n             ty: self.ty,\n         }\n     }\n }\n \n impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n-    pub fn item_name(&self) -> Name {\n-        self.skip_binder().item_name()\n-    }\n-\n-    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (DefPathHash, InternedString) {\n-        self.skip_binder().sort_key(tcx)\n-    }\n-\n     pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n         -> ty::PolyProjectionPredicate<'tcx> {\n         self.map_bound(|p| p.with_self_ty(tcx, self_ty))\n@@ -1397,7 +1397,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 substs.substs.regions().collect()\n             }\n             TyProjection(ref data) => {\n-                data.trait_ref.substs.regions().collect()\n+                data.substs.regions().collect()\n             }\n             TyFnDef(..) |\n             TyFnPtr(_) |"}, {"sha": "a7f0bafe9b67d04ba78335430dcddf3843d24ece", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -90,14 +90,14 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n             stack.push(mt.ty);\n         }\n         ty::TyProjection(ref data) => {\n-            stack.extend(data.trait_ref.substs.types().rev());\n+            stack.extend(data.substs.types().rev());\n         }\n         ty::TyDynamic(ref obj, ..) => {\n             stack.extend(obj.iter().rev().flat_map(|predicate| {\n                 let (substs, opt_ty) = match *predicate.skip_binder() {\n                     ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n                     ty::ExistentialPredicate::Projection(p) =>\n-                        (p.trait_ref.substs, Some(p.ty)),\n+                        (p.substs, Some(p.ty)),\n                     ty::ExistentialPredicate::AutoTrait(_) =>\n                         // Empty iterator\n                         (ty::Substs::empty(), None),"}, {"sha": "c24c583ad1e19a384056197b4f1fe579040562c8", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -155,11 +155,11 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         // A projection is well-formed if (a) the trait ref itself is\n         // WF and (b) the trait-ref holds.  (It may also be\n         // normalizable and be WF that way.)\n-\n-        self.compute_trait_ref(&data.trait_ref);\n+        let trait_ref = data.trait_ref(self.infcx.tcx);\n+        self.compute_trait_ref(&trait_ref);\n \n         if !data.has_escaping_regions() {\n-            let predicate = data.trait_ref.to_predicate();\n+            let predicate = trait_ref.to_predicate();\n             let cause = self.cause(traits::ProjectionWf(data));\n             self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }"}, {"sha": "d9c99ccd50843d79e6e4bcadc974f771de3d2a4a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -224,7 +224,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         start_or_continue(f, \"<\", \", \")?;\n         ty::tls::with(|tcx|\n             write!(f, \"{}={}\",\n-            projection.projection_ty.item_name(tcx),\n+            tcx.associated_item(projection.projection_ty.item_def_id).name,\n             projection.ty)\n         )?;\n     }\n@@ -958,9 +958,14 @@ impl<'tcx> fmt::Display for ty::ProjectionPredicate<'tcx> {\n \n impl<'tcx> fmt::Display for ty::ProjectionTy<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let item_name = ty::tls::with(|tcx| self.item_name(tcx));\n+        // FIXME(tschottdorf): use something like\n+        //   parameterized(f, self.substs, self.item_def_id, &[])\n+        // (which currently ICEs).\n+        let (trait_ref, item_name) = ty::tls::with(|tcx|\n+            (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).name)\n+        );\n         write!(f, \"{:?}::{}\",\n-               self.trait_ref,\n+               trait_ref,\n                item_name)\n     }\n }"}, {"sha": "64af24d92eecb5f47304e5048b12f22d827b0b02", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 118, "deletions": 67, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n             ty::TyAdt(adt, _) => adt.did,\n             ty::TyDynamic(ref obj, ..) if obj.principal().is_some() =>\n                 obj.principal().unwrap().def_id(),\n-            ty::TyProjection(ref proj) => proj.trait_ref.def_id,\n+            ty::TyProjection(ref proj) => proj.trait_ref(self.tcx).def_id,\n             _ => return Some(AccessLevel::Public)\n         };\n         if let Some(node_id) = self.tcx.hir.as_local_node_id(ty_def_id) {\n@@ -395,7 +395,22 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     }\n \n     fn predicates(&mut self) -> &mut Self {\n-        self.ev.tcx.predicates_of(self.item_def_id).visit_with(self);\n+        let predicates = self.ev.tcx.predicates_of(self.item_def_id);\n+        for predicate in &predicates.predicates {\n+            predicate.visit_with(self);\n+            match predicate {\n+                &ty::Predicate::Trait(poly_predicate) => {\n+                    self.check_trait_ref(poly_predicate.skip_binder().trait_ref);\n+                },\n+                &ty::Predicate::Projection(poly_predicate) => {\n+                    let tcx = self.ev.tcx;\n+                    self.check_trait_ref(\n+                        poly_predicate.skip_binder().projection_ty.trait_ref(tcx)\n+                    );\n+                },\n+                _ => (),\n+            };\n+        }\n         self\n     }\n \n@@ -411,17 +426,27 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     }\n \n     fn impl_trait_ref(&mut self) -> &mut Self {\n-        self.ev.tcx.impl_trait_ref(self.item_def_id).visit_with(self);\n+        if let Some(impl_trait_ref) = self.ev.tcx.impl_trait_ref(self.item_def_id) {\n+            self.check_trait_ref(impl_trait_ref);\n+            impl_trait_ref.super_visit_with(self);\n+        }\n         self\n     }\n+\n+    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) {\n+        if let Some(node_id) = self.ev.tcx.hir.as_local_node_id(trait_ref.def_id) {\n+            let item = self.ev.tcx.hir.expect_item(node_id);\n+            self.ev.update(item.id, Some(AccessLevel::Reachable));\n+        }\n+    }\n }\n \n impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty_def_id = match ty.sty {\n             ty::TyAdt(adt, _) => Some(adt.did),\n             ty::TyDynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n-            ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n+            ty::TyProjection(ref proj) => Some(proj.item_def_id),\n             ty::TyFnDef(def_id, ..) |\n             ty::TyAnon(def_id, _) => Some(def_id),\n             _ => None\n@@ -435,15 +460,6 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n \n         ty.super_visit_with(self)\n     }\n-\n-    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n-        if let Some(node_id) = self.ev.tcx.hir.as_local_node_id(trait_ref.def_id) {\n-            let item = self.ev.tcx.hir.expect_item(node_id);\n-            self.ev.update(item.id, Some(AccessLevel::Reachable));\n-        }\n-\n-        trait_ref.super_visit_with(self)\n-    }\n }\n \n //////////////////////////////////////////////////////////////////////////////////////\n@@ -633,14 +649,42 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn predicates(&mut self) -> &mut Self {\n-        self.tcx.predicates_of(self.current_item).visit_with(self);\n+        let predicates = self.tcx.predicates_of(self.current_item);\n+        for predicate in &predicates.predicates {\n+            predicate.visit_with(self);\n+            match predicate {\n+                &ty::Predicate::Trait(poly_predicate) => {\n+                    self.check_trait_ref(poly_predicate.skip_binder().trait_ref);\n+                },\n+                &ty::Predicate::Projection(poly_predicate) => {\n+                    let tcx = self.tcx;\n+                    self.check_trait_ref(\n+                        poly_predicate.skip_binder().projection_ty.trait_ref(tcx)\n+                    );\n+                },\n+                _ => (),\n+            };\n+        }\n         self\n     }\n \n     fn impl_trait_ref(&mut self) -> &mut Self {\n-        self.tcx.impl_trait_ref(self.current_item).visit_with(self);\n+        if let Some(impl_trait_ref) = self.tcx.impl_trait_ref(self.current_item) {\n+            self.check_trait_ref(impl_trait_ref);\n+        }\n+        self.tcx.predicates_of(self.current_item).visit_with(self);\n         self\n     }\n+\n+    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n+        if !self.item_is_accessible(trait_ref.def_id) {\n+            let msg = format!(\"trait `{}` is private\", trait_ref);\n+            self.tcx.sess.span_err(self.span, &msg);\n+            return true;\n+        }\n+\n+        trait_ref.super_visit_with(self)\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n@@ -817,7 +861,8 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                 let is_private = predicates.skip_binder().iter().any(|predicate| {\n                     let def_id = match *predicate {\n                         ty::ExistentialPredicate::Trait(trait_ref) => trait_ref.def_id,\n-                        ty::ExistentialPredicate::Projection(proj) => proj.trait_ref.def_id,\n+                        ty::ExistentialPredicate::Projection(proj) =>\n+                            proj.trait_ref(self.tcx).def_id,\n                         ty::ExistentialPredicate::AutoTrait(def_id) => def_id,\n                     };\n                     !self.item_is_accessible(def_id)\n@@ -828,6 +873,12 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                     return true;\n                 }\n             }\n+            ty::TyProjection(ref proj) => {\n+                let tcx = self.tcx;\n+                if self.check_trait_ref(proj.trait_ref(tcx)) {\n+                    return true;\n+                }\n+            }\n             ty::TyAnon(def_id, ..) => {\n                 for predicate in &self.tcx.predicates_of(def_id).predicates {\n                     let trait_ref = match *predicate {\n@@ -838,7 +889,8 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                             if poly_projection_predicate.skip_binder().ty.visit_with(self) {\n                                 return true;\n                             }\n-                            Some(poly_projection_predicate.skip_binder().projection_ty.trait_ref)\n+                            Some(poly_projection_predicate.skip_binder()\n+                                                          .projection_ty.trait_ref(self.tcx))\n                         }\n                         ty::Predicate::TypeOutlives(..) => None,\n                         _ => bug!(\"unexpected predicate: {:?}\", predicate),\n@@ -863,16 +915,6 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n         ty.super_visit_with(self)\n     }\n-\n-    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n-        if !self.item_is_accessible(trait_ref.def_id) {\n-            let msg = format!(\"trait `{}` is private\", trait_ref);\n-            self.tcx.sess.span_err(self.span, &msg);\n-            return true;\n-        }\n-\n-        trait_ref.super_visit_with(self)\n-    }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -1249,7 +1291,22 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     }\n \n     fn predicates(&mut self) -> &mut Self {\n-        self.tcx.predicates_of(self.item_def_id).visit_with(self);\n+        let predicates = self.tcx.predicates_of(self.item_def_id);\n+        for predicate in &predicates.predicates {\n+            predicate.visit_with(self);\n+            match predicate {\n+                &ty::Predicate::Trait(poly_predicate) => {\n+                    self.check_trait_ref(poly_predicate.skip_binder().trait_ref);\n+                },\n+                &ty::Predicate::Projection(poly_predicate) => {\n+                    let tcx = self.tcx;\n+                    self.check_trait_ref(\n+                        poly_predicate.skip_binder().projection_ty.trait_ref(tcx)\n+                    );\n+                },\n+                _ => (),\n+            };\n+        }\n         self\n     }\n \n@@ -1265,9 +1322,38 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     }\n \n     fn impl_trait_ref(&mut self) -> &mut Self {\n-        self.tcx.impl_trait_ref(self.item_def_id).visit_with(self);\n+        if let Some(impl_trait_ref) = self.tcx.impl_trait_ref(self.item_def_id) {\n+            self.check_trait_ref(impl_trait_ref);\n+            impl_trait_ref.super_visit_with(self);\n+        }\n         self\n     }\n+\n+    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) {\n+        // Non-local means public (private items can't leave their crate, modulo bugs)\n+        if let Some(node_id) = self.tcx.hir.as_local_node_id(trait_ref.def_id) {\n+            let item = self.tcx.hir.expect_item(node_id);\n+            let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n+            if !vis.is_at_least(self.min_visibility, self.tcx) {\n+                self.min_visibility = vis;\n+            }\n+            if !vis.is_at_least(self.required_visibility, self.tcx) {\n+                if self.has_pub_restricted || self.has_old_errors {\n+                    struct_span_err!(self.tcx.sess, self.span, E0445,\n+                                     \"private trait `{}` in public interface\", trait_ref)\n+                        .span_label(self.span, format!(\n+                                    \"private trait can't be public\"))\n+                        .emit();\n+                } else {\n+                    self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                           node_id,\n+                                           self.span,\n+                                           format!(\"private trait `{}` in public \\\n+                                                    interface (error E0445)\", trait_ref));\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n@@ -1285,8 +1371,8 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n                     // free type aliases, but this isn't done yet.\n                     return false;\n                 }\n-\n-                Some(proj.trait_ref.def_id)\n+                let trait_ref = proj.trait_ref(self.tcx);\n+                Some(trait_ref.def_id)\n             }\n             _ => None\n         };\n@@ -1317,42 +1403,7 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n             }\n         }\n \n-        if let ty::TyProjection(ref proj) = ty.sty {\n-            // Avoid calling `visit_trait_ref` below on the trait,\n-            // as we have already checked the trait itself above.\n-            proj.trait_ref.super_visit_with(self)\n-        } else {\n-            ty.super_visit_with(self)\n-        }\n-    }\n-\n-    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n-        // Non-local means public (private items can't leave their crate, modulo bugs)\n-        if let Some(node_id) = self.tcx.hir.as_local_node_id(trait_ref.def_id) {\n-            let item = self.tcx.hir.expect_item(node_id);\n-            let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n-\n-            if !vis.is_at_least(self.min_visibility, self.tcx) {\n-                self.min_visibility = vis;\n-            }\n-            if !vis.is_at_least(self.required_visibility, self.tcx) {\n-                if self.has_pub_restricted || self.has_old_errors {\n-                    struct_span_err!(self.tcx.sess, self.span, E0445,\n-                                     \"private trait `{}` in public interface\", trait_ref)\n-                        .span_label(self.span, format!(\n-                                    \"private trait can't be public\"))\n-                        .emit();\n-                } else {\n-                    self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                           node_id,\n-                                           self.span,\n-                                           format!(\"private trait `{}` in public \\\n-                                                    interface (error E0445)\", trait_ref));\n-                }\n-            }\n-        }\n-\n-        trait_ref.super_visit_with(self)\n+        ty.super_visit_with(self)\n     }\n }\n "}, {"sha": "ac2baa9e8b1d2b44fcffb532fa1e7758245fabbe", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -608,13 +608,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         hir::QPath::TypeRelative(..) => {\n                             let ty = hir_ty_to_ty(self.tcx, ty);\n                             if let ty::TyProjection(proj) = ty.sty {\n-                                for item in self.tcx.associated_items(proj.trait_ref.def_id) {\n-                                    if item.kind == ty::AssociatedKind::Type {\n-                                        if item.name == proj.item_name(self.tcx) {\n-                                            return HirDef::AssociatedTy(item.def_id);\n-                                        }\n-                                    }\n-                                }\n+                                return HirDef::AssociatedTy(proj.item_def_id);\n                             }\n                             HirDef::Err\n                         }"}, {"sha": "8a77b2658099966f09ccf00057729302f59d0f3f", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -558,7 +558,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n         for projection in projections {\n             let projection = projection.skip_binder();\n-            let name = &projection.item_name.as_str();\n+            let name = &self.tcx.associated_item(projection.item_def_id).name.as_str();\n             output.push_str(name);\n             output.push_str(\"=\");\n             self.push_type_name(projection.ty, output);"}, {"sha": "bb6e478738aa2b052dd5cceeaa3c70ad64e9038d", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -66,8 +66,8 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// late-bound regions.\n     fn projected_ty_from_poly_trait_ref(&self,\n                                         span: Span,\n-                                        poly_trait_ref: ty::PolyTraitRef<'tcx>,\n-                                        item_name: ast::Name)\n+                                        item_def_id: DefId,\n+                                        poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                                         -> Ty<'tcx>;\n \n     /// Normalize an associated type coming from the user.\n@@ -651,11 +651,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         });\n         let existential_projections = projection_bounds.iter().map(|bound| {\n             bound.map_bound(|b| {\n-                let p = b.projection_ty;\n+                let trait_ref = self.trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n                 ty::ExistentialProjection {\n-                    trait_ref: self.trait_ref_to_existential(p.trait_ref),\n-                    item_name: p.item_name(tcx),\n-                    ty: b.ty\n+                    ty: b.ty,\n+                    item_def_id: b.projection_ty.item_def_id,\n+                    substs: trait_ref.substs,\n                 }\n             })\n         });\n@@ -676,22 +676,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         for tr in traits::supertraits(tcx, principal) {\n             associated_types.extend(tcx.associated_items(tr.def_id())\n                 .filter(|item| item.kind == ty::AssociatedKind::Type)\n-                .map(|item| (tr.def_id(), item.name)));\n+                .map(|item| item.def_id));\n         }\n \n         for projection_bound in &projection_bounds {\n-            let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n-                        projection_bound.0.projection_ty.item_name(tcx));\n-            associated_types.remove(&pair);\n+            associated_types.remove(&projection_bound.0.projection_ty.item_def_id);\n         }\n \n-        for (trait_def_id, name) in associated_types {\n+        for item_def_id in associated_types {\n+            let assoc_item = tcx.associated_item(item_def_id);\n+            let trait_def_id = assoc_item.container.id();\n             struct_span_err!(tcx.sess, span, E0191,\n                 \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n-                        name,\n+                        assoc_item.name,\n                         tcx.item_path_str(trait_def_id))\n                         .span_label(span, format!(\n-                            \"missing associated type `{}` value\", name))\n+                            \"missing associated type `{}` value\", assoc_item.name))\n                         .emit();\n         }\n \n@@ -896,11 +896,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n \n         let trait_did = bound.0.def_id;\n-        let ty = self.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n-        let ty = self.normalize_ty(span, ty);\n-\n         let item = tcx.associated_items(trait_did).find(|i| i.name == assoc_name)\n                                                   .expect(\"missing associated type\");\n+\n+        let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, bound);\n+        let ty = self.normalize_ty(span, ty);\n+\n         let def = Def::AssociatedTy(item.def_id);\n         let def_scope = tcx.adjust(assoc_name, item.container.id(), ref_id).1;\n         if !item.vis.is_accessible_from(def_scope, tcx) {\n@@ -915,12 +916,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn qpath_to_ty(&self,\n                    span: Span,\n                    opt_self_ty: Option<Ty<'tcx>>,\n-                   trait_def_id: DefId,\n+                   item_def_id: DefId,\n                    trait_segment: &hir::PathSegment,\n                    item_segment: &hir::PathSegment)\n                    -> Ty<'tcx>\n     {\n         let tcx = self.tcx();\n+        let trait_def_id = tcx.parent_def_id(item_def_id).unwrap();\n \n         self.prohibit_type_params(slice::ref_slice(item_segment));\n \n@@ -944,7 +946,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"qpath_to_ty: trait_ref={:?}\", trait_ref);\n \n-        self.normalize_ty(span, tcx.mk_projection(trait_ref, item_segment.name))\n+        self.normalize_ty(span, tcx.mk_projection(item_def_id, trait_ref.substs))\n     }\n \n     pub fn prohibit_type_params(&self, segments: &[hir::PathSegment]) {\n@@ -1050,10 +1052,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             Def::AssociatedTy(def_id) => {\n                 self.prohibit_type_params(&path.segments[..path.segments.len()-2]);\n-                let trait_did = tcx.parent_def_id(def_id).unwrap();\n                 self.qpath_to_ty(span,\n                                  opt_self_ty,\n-                                 trait_did,\n+                                 def_id,\n                                  &path.segments[path.segments.len()-2],\n                                  path.segments.last().unwrap())\n             }"}, {"sha": "802eee91efcf33d456bc935c0850ff1bafaf09db", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n                     ty::Predicate::Projection(ref proj_predicate) => {\n-                        let trait_ref = proj_predicate.to_poly_trait_ref();\n+                        let trait_ref = proj_predicate.to_poly_trait_ref(self.tcx);\n                         self.self_type_matches_expected_vid(trait_ref, expected_vid)\n                             .and_then(|_| self.deduce_sig_from_projection(proj_predicate))\n                     }\n@@ -174,7 +174,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .map(|obligation| &obligation.obligation)\n             .filter_map(|obligation| {\n                 let opt_trait_ref = match obligation.predicate {\n-                    ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref()),\n+                    ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref(self.tcx)),\n                     ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n                     ty::Predicate::Equate(..) => None,\n                     ty::Predicate::Subtype(..) => None,\n@@ -211,7 +211,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"deduce_sig_from_projection({:?})\", projection);\n \n-        let trait_ref = projection.to_poly_trait_ref();\n+        let trait_ref = projection.to_poly_trait_ref(tcx);\n \n         if tcx.lang_items.fn_trait_kind(trait_ref.def_id()).is_none() {\n             return None;"}, {"sha": "dfc5cd00b6eabcef882caa746ef98bff2f92e25c", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -861,7 +861,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             debug!(\"assemble_projection_candidates: step={:?}\", step);\n \n             let (def_id, substs) = match step.self_ty.sty {\n-                ty::TyProjection(ref data) => (data.trait_ref.def_id, data.trait_ref.substs),\n+                ty::TyProjection(ref data) => {\n+                    let trait_ref = data.trait_ref(self.tcx);\n+                    (trait_ref.def_id, trait_ref.substs)\n+                },\n                 ty::TyAnon(def_id, substs) => (def_id, substs),\n                 _ => continue,\n             };"}, {"sha": "6e2c36c86a328f8854aa258b5834967478e2333e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -1620,17 +1620,18 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn projected_ty_from_poly_trait_ref(&self,\n                                         span: Span,\n-                                        poly_trait_ref: ty::PolyTraitRef<'tcx>,\n-                                        item_name: ast::Name)\n+                                        item_def_id: DefId,\n+                                        poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                                         -> Ty<'tcx>\n     {\n+        let item = self.tcx().associated_item(item_def_id);\n         let (trait_ref, _) =\n             self.replace_late_bound_regions_with_fresh_var(\n                 span,\n-                infer::LateBoundRegionConversionTime::AssocTypeProjection(item_name),\n+                infer::LateBoundRegionConversionTime::AssocTypeProjection(item.name),\n                 &poly_trait_ref);\n \n-        self.tcx().mk_projection(trait_ref, item_name)\n+        self.tcx().mk_projection(item_def_id, trait_ref.substs)\n     }\n \n     fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {"}, {"sha": "82207428efc4fb3080135971c35b37758b2bdad7", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -1595,15 +1595,15 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // the problem is to add `T: 'r`, which isn't true. So, if there are no\n         // inference variables, we use a verify constraint instead of adding\n         // edges, which winds up enforcing the same condition.\n-        let needs_infer = projection_ty.trait_ref.needs_infer();\n+        let needs_infer = projection_ty.needs_infer();\n         if env_bounds.is_empty() && needs_infer {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n-            for component_ty in projection_ty.trait_ref.substs.types() {\n+            for component_ty in projection_ty.substs.types() {\n                 self.type_must_outlive(origin.clone(), component_ty, region);\n             }\n \n-            for r in projection_ty.trait_ref.substs.regions() {\n+            for r in projection_ty.substs.regions() {\n                 self.sub_regions(origin.clone(), region, r);\n             }\n \n@@ -1621,7 +1621,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n             let unique_bound = env_bounds[0];\n             debug!(\"projection_must_outlive: unique declared bound = {:?}\", unique_bound);\n-            if projection_ty.trait_ref.substs.regions().any(|r| env_bounds.contains(&r)) {\n+            if projection_ty.substs.regions().any(|r| env_bounds.contains(&r)) {\n                 debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n                 self.sub_regions(origin.clone(), region, unique_bound);\n                 return;\n@@ -1691,8 +1691,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                declared_bounds, projection_ty);\n \n         // see the extensive comment in projection_must_outlive\n-        let item_name = projection_ty.item_name(self.tcx);\n-        let ty = self.tcx.mk_projection(projection_ty.trait_ref, item_name);\n+        let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n         let recursive_bound = self.recursive_type_bound(span, ty);\n \n         VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n@@ -1758,9 +1757,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"projection_bounds(projection_ty={:?})\",\n                projection_ty);\n-        let item_name = projection_ty.item_name(self.tcx);\n-        let ty = self.tcx.mk_projection(projection_ty.trait_ref.clone(),\n-                                        item_name);\n+        let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n \n         // Say we have a projection `<T as SomeTrait<'a>>::SomeType`. We are interested\n         // in looking for a trait definition like:\n@@ -1772,7 +1769,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // ```\n         //\n         // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-        let trait_predicates = self.tcx.predicates_of(projection_ty.trait_ref.def_id);\n+        let trait_predicates = self.tcx.predicates_of(projection_ty.trait_ref(self.tcx).def_id);\n         assert_eq!(trait_predicates.parent, None);\n         let predicates = trait_predicates.predicates.as_slice().to_vec();\n         traits::elaborate_predicates(self.tcx, predicates)\n@@ -1788,7 +1785,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n                 // apply the substitutions (and normalize any projected types)\n                 let outlives = self.instantiate_type_scheme(span,\n-                                                            projection_ty.trait_ref.substs,\n+                                                            projection_ty.substs,\n                                                             &outlives);\n \n                 debug!(\"projection_bounds: outlives={:?} (2)\",\n@@ -1798,7 +1795,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     let (outlives, _) =\n                         self.replace_late_bound_regions_with_fresh_var(\n                             span,\n-                            infer::AssocTypeProjection(projection_ty.item_name(self.tcx)),\n+                            infer::AssocTypeProjection(\n+                                self.tcx.associated_item(projection_ty.item_def_id).name),\n                             &outlives);\n \n                     debug!(\"projection_bounds: outlives={:?} (3)\","}, {"sha": "69cd141462875af1d959e30a64fb83b563b58178", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -508,7 +508,8 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                      .map(|(index, _)| Parameter(index as u32))\n                      .collect();\n \n-        identify_constrained_type_params(ty_predicates.predicates.as_slice(),\n+        identify_constrained_type_params(self.tcx,\n+                                         ty_predicates.predicates.as_slice(),\n                                          None,\n                                          &mut constrained_parameters);\n "}, {"sha": "002a148c459a3be506f7196e64ee7b91b8ab3f1b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -225,12 +225,12 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n \n     fn projected_ty_from_poly_trait_ref(&self,\n                                         span: Span,\n-                                        poly_trait_ref: ty::PolyTraitRef<'tcx>,\n-                                        item_name: ast::Name)\n+                                        item_def_id: DefId,\n+                                        poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                                         -> Ty<'tcx>\n     {\n         if let Some(trait_ref) = self.tcx().no_late_bound_regions(&poly_trait_ref) {\n-            self.tcx().mk_projection(trait_ref, item_name)\n+            self.tcx().mk_projection(item_def_id, trait_ref.substs)\n         } else {\n             // no late-bound regions, we can just ignore the binder\n             span_err!(self.tcx().sess, span, E0212,\n@@ -1438,7 +1438,10 @@ fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n             };\n \n-            let assoc_ty = tcx.mk_projection(self_trait_ref, trait_item.name);\n+            let assoc_ty = tcx.mk_projection(\n+                tcx.hir.local_def_id(trait_item.id),\n+                self_trait_ref.substs,\n+            );\n \n             let bounds = compute_bounds(&ItemCtxt::new(tcx, def_id),\n                                         assoc_ty,\n@@ -1458,7 +1461,8 @@ fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let NodeItem(&Item { node: ItemImpl(..), .. }) = node {\n         let self_ty = tcx.type_of(def_id);\n         let trait_ref = tcx.impl_trait_ref(def_id);\n-        ctp::setup_constraining_predicates(&mut predicates,\n+        ctp::setup_constraining_predicates(tcx,\n+                                           &mut predicates,\n                                            trait_ref,\n                                            &mut ctp::parameters_for_impl(self_ty, trait_ref));\n     }"}, {"sha": "7742194dfe6e0e40dc2e1b9d470e65058b3d87c0", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -86,12 +86,13 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     }\n }\n \n-pub fn identify_constrained_type_params<'tcx>(predicates: &[ty::Predicate<'tcx>],\n+pub fn identify_constrained_type_params<'tcx>(tcx: ty::TyCtxt,\n+                                              predicates: &[ty::Predicate<'tcx>],\n                                               impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                               input_parameters: &mut FxHashSet<Parameter>)\n {\n     let mut predicates = predicates.to_owned();\n-    setup_constraining_predicates(&mut predicates, impl_trait_ref, input_parameters);\n+    setup_constraining_predicates(tcx, &mut predicates, impl_trait_ref, input_parameters);\n }\n \n \n@@ -135,7 +136,8 @@ pub fn identify_constrained_type_params<'tcx>(predicates: &[ty::Predicate<'tcx>]\n /// which is determined by 1, which requires `U`, that is determined\n /// by 0. I should probably pick a less tangled example, but I can't\n /// think of any.\n-pub fn setup_constraining_predicates<'tcx>(predicates: &mut [ty::Predicate<'tcx>],\n+pub fn setup_constraining_predicates<'tcx>(tcx: ty::TyCtxt,\n+                                           predicates: &mut [ty::Predicate<'tcx>],\n                                            impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                            input_parameters: &mut FxHashSet<Parameter>)\n {\n@@ -175,7 +177,7 @@ pub fn setup_constraining_predicates<'tcx>(predicates: &mut [ty::Predicate<'tcx>\n                 // Special case: watch out for some kind of sneaky attempt\n                 // to project out an associated type defined by this very\n                 // trait.\n-                let unbound_trait_ref = &projection.projection_ty.trait_ref;\n+                let unbound_trait_ref = projection.projection_ty.trait_ref(tcx);\n                 if Some(unbound_trait_ref.clone()) == impl_trait_ref {\n                     continue;\n                 }\n@@ -185,8 +187,7 @@ pub fn setup_constraining_predicates<'tcx>(predicates: &mut [ty::Predicate<'tcx>\n                 //     `<<T as Bar>::Baz as Iterator>::Output = <U as Iterator>::Output`\n                 // Then the projection only applies if `T` is known, but it still\n                 // does not determine `U`.\n-\n-                let inputs = parameters_for(&projection.projection_ty.trait_ref, true);\n+                let inputs = parameters_for(&projection.projection_ty.trait_ref(tcx), true);\n                 let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n                 if !relies_only_on_inputs {\n                     continue;"}, {"sha": "14e48b9302964904db67f98a144d09ecf701fd60", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -102,7 +102,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let mut input_parameters = ctp::parameters_for_impl(impl_self_ty, impl_trait_ref);\n     ctp::identify_constrained_type_params(\n-        &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n+        tcx, &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n     // Disallow ANY unconstrained type parameters.\n     for (ty_param, param) in impl_generics.types.iter().zip(&impl_hir_generics.ty_params) {"}, {"sha": "284c9c5cfc398aa6572fc14992d229592b05fb70", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -324,7 +324,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyProjection(ref data) => {\n-                self.add_constraints_from_trait_ref(current, data.trait_ref, variance);\n+                let tcx = self.tcx();\n+                self.add_constraints_from_trait_ref(current, data.trait_ref(tcx), variance);\n             }\n \n             ty::TyAnon(_, substs) => {"}, {"sha": "9d0b5b41a913fcf13b9fc7c6aebec079c9e9efa1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1475e2c923746c253da8027079c462d7e3d1022d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1475e2c923746c253da8027079c462d7e3d1022d", "patch": "@@ -952,15 +952,15 @@ impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n \n impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Type {\n-        let trait_ = match self.trait_ref.clean(cx) {\n+        let trait_ = match self.trait_ref(cx.tcx).clean(cx) {\n             TyParamBound::TraitBound(t, _) => t.trait_,\n             TyParamBound::RegionBound(_) => {\n                 panic!(\"cleaning a trait got a region\")\n             }\n         };\n         Type::QPath {\n-            name: self.item_name(cx.tcx).clean(cx),\n-            self_type: box self.trait_ref.self_ty().clean(cx),\n+            name: cx.tcx.associated_item(self.item_def_id).name.clean(cx),\n+            self_type: box self.self_ty().clean(cx),\n             trait_: box trait_\n         }\n     }\n@@ -1784,7 +1784,7 @@ impl Clean<Type> for hir::Ty {\n                 let mut def = Def::Err;\n                 let ty = hir_ty_to_ty(cx.tcx, self);\n                 if let ty::TyProjection(proj) = ty.sty {\n-                    def = Def::Trait(proj.trait_ref.def_id);\n+                    def = Def::Trait(proj.trait_ref(cx.tcx).def_id);\n                 }\n                 let trait_path = hir::Path {\n                     span: self.span,\n@@ -1901,7 +1901,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     let mut bindings = vec![];\n                     for ty::Binder(ref pb) in obj.projection_bounds() {\n                         bindings.push(TypeBinding {\n-                            name: pb.item_name.clean(cx),\n+                            name: cx.tcx.associated_item(pb.item_def_id).name.clean(cx),\n                             ty: pb.ty.clean(cx)\n                         });\n                     }"}]}