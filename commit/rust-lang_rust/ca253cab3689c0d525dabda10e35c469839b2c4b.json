{"sha": "ca253cab3689c0d525dabda10e35c469839b2c4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMjUzY2FiMzY4OWMwZDUyNWRhYmRhMTBlMzVjNDY5ODM5YjJjNGI=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-13T14:51:37Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-16T10:53:01Z"}, "message": "Clean up or comment every unwrap in BTreeMap's main code.", "tree": {"sha": "64943a32dae9e4019d9b95e7ea69d46fcd608902", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64943a32dae9e4019d9b95e7ea69d46fcd608902"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca253cab3689c0d525dabda10e35c469839b2c4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca253cab3689c0d525dabda10e35c469839b2c4b", "html_url": "https://github.com/rust-lang/rust/commit/ca253cab3689c0d525dabda10e35c469839b2c4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca253cab3689c0d525dabda10e35c469839b2c4b/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cd0ee9343da86d9770bf0a514a682d240e0dce8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cd0ee9343da86d9770bf0a514a682d240e0dce8", "html_url": "https://github.com/rust-lang/rust/commit/4cd0ee9343da86d9770bf0a514a682d240e0dce8"}], "stats": {"total": 86, "additions": 40, "deletions": 46}, "files": [{"sha": "d94c9539e6dc58e2a3b8ac28aa7d3d9b4a9dcf99", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 35, "deletions": 46, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ca253cab3689c0d525dabda10e35c469839b2c4b/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca253cab3689c0d525dabda10e35c469839b2c4b/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=ca253cab3689c0d525dabda10e35c469839b2c4b", "patch": "@@ -151,7 +151,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                     let mut out_tree = BTreeMap { root: Some(node::Root::new_leaf()), length: 0 };\n \n                     {\n-                        let root = out_tree.root.as_mut().unwrap();\n+                        let root = out_tree.root.as_mut().unwrap(); // unwrap succeeds because we just wrapped\n                         let mut out_node = match root.as_mut().force() {\n                             Leaf(leaf) => leaf,\n                             Internal(_) => unreachable!(),\n@@ -171,14 +171,10 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                 }\n                 Internal(internal) => {\n                     let mut out_tree = clone_subtree(internal.first_edge().descend());\n-                    out_tree.ensure_root_is_owned();\n \n                     {\n-                        // Ideally we'd use the return of ensure_root_is_owned\n-                        // instead of re-unwrapping here but unfortunately that\n-                        // borrows all of out_tree and we need access to the\n-                        // length below.\n-                        let mut out_node = out_tree.root.as_mut().unwrap().push_level();\n+                        let out_root = BTreeMap::ensure_is_owned(&mut out_tree.root);\n+                        let mut out_node = out_root.push_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n@@ -212,7 +208,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             // Ord` constraint, which this method lacks.\n             BTreeMap { root: None, length: 0 }\n         } else {\n-            clone_subtree(self.root.as_ref().unwrap().as_ref())\n+            clone_subtree(self.root.as_ref().unwrap().as_ref()) // unwrap succeeds because not empty\n         }\n     }\n }\n@@ -243,8 +239,8 @@ where\n     }\n \n     fn replace(&mut self, key: K) -> Option<K> {\n-        self.ensure_root_is_owned();\n-        match search::search_tree::<marker::Mut<'_>, K, (), K>(self.root.as_mut()?.as_mut(), &key) {\n+        let root = Self::ensure_is_owned(&mut self.root);\n+        match search::search_tree::<marker::Mut<'_>, K, (), K>(root.as_mut(), &key) {\n             Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n             GoDown(handle) => {\n                 VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData }\n@@ -943,7 +939,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         // Second, we build a tree from the sorted sequence in linear time.\n         self.from_sorted_iter(iter);\n-        self.fix_right_edge();\n     }\n \n     /// Constructs a double-ended iterator over a sub-range of elements in the map.\n@@ -1058,8 +1053,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n-        self.ensure_root_is_owned();\n-        match search::search_tree(self.root.as_mut().unwrap().as_mut(), &key) {\n+        let root = Self::ensure_is_owned(&mut self.root);\n+        match search::search_tree(root.as_mut(), &key) {\n             Found(handle) => {\n                 Occupied(OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData })\n             }\n@@ -1070,8 +1065,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n-        self.ensure_root_is_owned();\n-        let mut cur_node = self.root.as_mut().unwrap().as_mut().last_leaf_edge().into_node();\n+        let root = Self::ensure_is_owned(&mut self.root);\n+        let mut cur_node = root.as_mut().last_leaf_edge().into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n             // Try to push key-value pair into the current leaf node.\n@@ -1116,11 +1111,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n             self.length += 1;\n         }\n+        Self::fix_right_edge(root)\n     }\n \n-    fn fix_right_edge(&mut self) {\n+    fn fix_right_edge(root: &mut node::Root<K, V>) {\n         // Handle underfull nodes, start from the top.\n-        let mut cur_node = self.root.as_mut().unwrap().as_mut();\n+        let mut cur_node = root.as_mut();\n         while let Internal(internal) = cur_node.force() {\n             // Check if right-most child is underfull.\n             let mut last_edge = internal.last_edge();\n@@ -1179,16 +1175,17 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n \n         let total_num = self.len();\n+        let left_root = self.root.as_mut().unwrap(); // unwrap succeeds because not empty\n \n         let mut right = Self::new();\n-        let right_root = right.ensure_root_is_owned();\n-        for _ in 0..(self.root.as_ref().unwrap().as_ref().height()) {\n+        let right_root = Self::ensure_is_owned(&mut right.root);\n+        for _ in 0..left_root.height() {\n             right_root.push_level();\n         }\n \n         {\n-            let mut left_node = self.root.as_mut().unwrap().as_mut();\n-            let mut right_node = right.root.as_mut().unwrap().as_mut();\n+            let mut left_node = left_root.as_mut();\n+            let mut right_node = right_root.as_mut();\n \n             loop {\n                 let mut split_edge = match search::search_node(left_node, key) {\n@@ -1214,12 +1211,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             }\n         }\n \n-        self.fix_right_border();\n-        right.fix_left_border();\n+        Self::fix_right_border(left_root);\n+        Self::fix_left_border(right_root);\n \n-        if self.root.as_ref().unwrap().as_ref().height()\n-            < right.root.as_ref().unwrap().as_ref().height()\n-        {\n+        if left_root.height() < right_root.height() {\n             self.recalc_length();\n             right.length = total_num - self.len();\n         } else {\n@@ -1303,23 +1298,17 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n \n     /// Removes empty levels on the top.\n-    fn fix_top(&mut self) {\n-        loop {\n-            {\n-                let node = self.root.as_ref().unwrap().as_ref();\n-                if node.height() == 0 || node.len() > 0 {\n-                    break;\n-                }\n-            }\n-            self.root.as_mut().unwrap().pop_level();\n+    fn fix_top(root: &mut node::Root<K, V>) {\n+        while root.height() > 0 && root.as_ref().len() == 0 {\n+            root.pop_level();\n         }\n     }\n \n-    fn fix_right_border(&mut self) {\n-        self.fix_top();\n+    fn fix_right_border(root: &mut node::Root<K, V>) {\n+        Self::fix_top(root);\n \n         {\n-            let mut cur_node = self.root.as_mut().unwrap().as_mut();\n+            let mut cur_node = root.as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut last_kv = node.last_kv();\n@@ -1337,15 +1326,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             }\n         }\n \n-        self.fix_top();\n+        Self::fix_top(root);\n     }\n \n     /// The symmetric clone of `fix_right_border`.\n-    fn fix_left_border(&mut self) {\n-        self.fix_top();\n+    fn fix_left_border(root: &mut node::Root<K, V>) {\n+        Self::fix_top(root);\n \n         {\n-            let mut cur_node = self.root.as_mut().unwrap().as_mut();\n+            let mut cur_node = root.as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut first_kv = node.first_kv();\n@@ -1362,7 +1351,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             }\n         }\n \n-        self.fix_top();\n+        Self::fix_top(root);\n     }\n }\n \n@@ -2321,9 +2310,9 @@ impl<K, V> BTreeMap<K, V> {\n     }\n \n     /// If the root node is the empty (non-allocated) root node, allocate our\n-    /// own node.\n-    fn ensure_root_is_owned(&mut self) -> &mut node::Root<K, V> {\n-        self.root.get_or_insert_with(node::Root::new_leaf)\n+    /// own node. Is an associated function to avoid borrowing the entire BTreeMap.\n+    fn ensure_is_owned(root: &mut Option<node::Root<K, V>>) -> &mut node::Root<K, V> {\n+        root.get_or_insert_with(node::Root::new_leaf)\n     }\n }\n "}, {"sha": "f7bd64608d63cd40205364fa604979009f141b21", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ca253cab3689c0d525dabda10e35c469839b2c4b/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca253cab3689c0d525dabda10e35c469839b2c4b/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=ca253cab3689c0d525dabda10e35c469839b2c4b", "patch": "@@ -153,6 +153,11 @@ unsafe impl<K: Sync, V: Sync> Sync for Root<K, V> {}\n unsafe impl<K: Send, V: Send> Send for Root<K, V> {}\n \n impl<K, V> Root<K, V> {\n+    /// Returns the number of levels below the root.\n+    pub fn height(&self) -> usize {\n+        self.height\n+    }\n+\n     /// Returns a new owned tree, with its own root node that is initially empty.\n     pub fn new_leaf() -> Self {\n         Root { node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })), height: 0 }"}]}