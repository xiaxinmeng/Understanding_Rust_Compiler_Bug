{"sha": "98f287240ff9518c1ea5519c5cd03dc2ba6d4452", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZjI4NzI0MGZmOTUxOGMxZWE1NTE5YzVjZDAzZGMyYmE2ZDQ0NTI=", "commit": {"author": {"name": "Alisdair Owens", "email": "awo101@zepler.net", "date": "2015-07-10T16:34:07Z"}, "committer": {"name": "Alisdair Owens", "email": "awo101@zepler.net", "date": "2015-07-15T20:30:18Z"}, "message": "Add specializations of read_to_end for Stdin, TcpStream and File,\nallowing them to read into a buffer containing uninitialized data,\nrather than pay the cost of zeroing.", "tree": {"sha": "ccf70108ba915d7280d99035f647a663ae0c1711", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccf70108ba915d7280d99035f647a663ae0c1711"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98f287240ff9518c1ea5519c5cd03dc2ba6d4452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98f287240ff9518c1ea5519c5cd03dc2ba6d4452", "html_url": "https://github.com/rust-lang/rust/commit/98f287240ff9518c1ea5519c5cd03dc2ba6d4452", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/comments", "author": {"login": "AlisdairO", "id": 6296622, "node_id": "MDQ6VXNlcjYyOTY2MjI=", "avatar_url": "https://avatars.githubusercontent.com/u/6296622?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AlisdairO", "html_url": "https://github.com/AlisdairO", "followers_url": "https://api.github.com/users/AlisdairO/followers", "following_url": "https://api.github.com/users/AlisdairO/following{/other_user}", "gists_url": "https://api.github.com/users/AlisdairO/gists{/gist_id}", "starred_url": "https://api.github.com/users/AlisdairO/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AlisdairO/subscriptions", "organizations_url": "https://api.github.com/users/AlisdairO/orgs", "repos_url": "https://api.github.com/users/AlisdairO/repos", "events_url": "https://api.github.com/users/AlisdairO/events{/privacy}", "received_events_url": "https://api.github.com/users/AlisdairO/received_events", "type": "User", "site_admin": false}, "committer": {"login": "AlisdairO", "id": 6296622, "node_id": "MDQ6VXNlcjYyOTY2MjI=", "avatar_url": "https://avatars.githubusercontent.com/u/6296622?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AlisdairO", "html_url": "https://github.com/AlisdairO", "followers_url": "https://api.github.com/users/AlisdairO/followers", "following_url": "https://api.github.com/users/AlisdairO/following{/other_user}", "gists_url": "https://api.github.com/users/AlisdairO/gists{/gist_id}", "starred_url": "https://api.github.com/users/AlisdairO/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AlisdairO/subscriptions", "organizations_url": "https://api.github.com/users/AlisdairO/orgs", "repos_url": "https://api.github.com/users/AlisdairO/repos", "events_url": "https://api.github.com/users/AlisdairO/events{/privacy}", "received_events_url": "https://api.github.com/users/AlisdairO/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4e93196e16030ebf7a20c473849534235d676f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4e93196e16030ebf7a20c473849534235d676f8", "html_url": "https://github.com/rust-lang/rust/commit/e4e93196e16030ebf7a20c473849534235d676f8"}], "stats": {"total": 166, "additions": 166, "deletions": 0}, "files": [{"sha": "2c78b2894311d641d76cea2184585076b3291670", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=98f287240ff9518c1ea5519c5cd03dc2ba6d4452", "patch": "@@ -25,6 +25,7 @@ use io::{self, SeekFrom, Seek, Read, Write};\n use path::{Path, PathBuf};\n use sys::fs as fs_imp;\n use sys_common::{AsInnerMut, FromInner, AsInner};\n+use sys_common::io::read_to_end_uninitialized;\n use vec::Vec;\n \n /// A reference to an open file on the filesystem.\n@@ -328,6 +329,9 @@ impl Read for File {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for File {"}, {"sha": "d0453c2e77692145aec4d2742935c92ed62864e1", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=98f287240ff9518c1ea5519c5cd03dc2ba6d4452", "patch": "@@ -906,6 +906,8 @@ mod tests {\n     use io::prelude::*;\n     use io;\n     use super::Cursor;\n+    use test;\n+    use super::repeat;\n \n     #[test]\n     fn read_until() {\n@@ -1024,4 +1026,13 @@ mod tests {\n         let mut buf = [0; 1];\n         assert_eq!(0, R.take(0).read(&mut buf).unwrap());\n     }\n+\n+    #[bench]\n+    fn bench_read_to_end(b: &mut test::Bencher) {\n+        b.iter(|| {\n+            let mut lr = repeat(1).take(10000000);\n+            let mut vec = Vec::with_capacity(1024);\n+            super::read_to_end(&mut lr, &mut vec);\n+        });\n+    }\n }"}, {"sha": "d8b7c8a282ca297760d90d2b18ebf655efba77fe", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=98f287240ff9518c1ea5519c5cd03dc2ba6d4452", "patch": "@@ -18,6 +18,7 @@ use io::lazy::Lazy;\n use io::{self, BufReader, LineWriter};\n use sync::{Arc, Mutex, MutexGuard};\n use sys::stdio;\n+use sys_common::io::{read_to_end_uninitialized};\n use sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use libc;\n \n@@ -277,6 +278,9 @@ impl<'a> Read for StdinLock<'a> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "66c8403b2685e244775dfdaa777ec38b615ecde7", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=98f287240ff9518c1ea5519c5cd03dc2ba6d4452", "patch": "@@ -19,6 +19,7 @@ use io;\n use net::{ToSocketAddrs, SocketAddr, Shutdown};\n use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner};\n+use sys_common::io::read_to_end_uninitialized;\n use time::Duration;\n \n /// A structure which represents a TCP stream between a local socket and a\n@@ -189,6 +190,9 @@ impl TcpStream {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for TcpStream {\n@@ -198,6 +202,9 @@ impl Write for TcpStream {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Read for &'a TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for &'a TcpStream {"}, {"sha": "151d853fc9f7e033576df32ea0a093db9a0412c5", "filename": "src/libstd/sys/common/io.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs?ref=98f287240ff9518c1ea5519c5cd03dc2ba6d4452", "patch": "@@ -0,0 +1,139 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use prelude::v1::*;\n+use io;\n+use io::ErrorKind;\n+use io::Read;\n+use slice::from_raw_parts_mut;\n+\n+// Provides read_to_end functionality over an uninitialized buffer.\n+// This function is unsafe because it calls the underlying\n+// read function with a slice into uninitialized memory. The default\n+// implementation of read_to_end for readers will zero out new memory in\n+// the buf before passing it to read, but avoiding this zero can often\n+// lead to a fairly significant performance win.\n+//\n+// Implementations using this method have to adhere to two guarantees:\n+//  *  The implementation of read never reads the buffer provided.\n+//  *  The implementation of read correctly reports how many bytes were written.\n+pub unsafe fn read_to_end_uninitialized(r: &mut Read, buf: &mut Vec<u8>) -> io::Result<usize> {\n+\n+    let start_len = buf.len();\n+    buf.reserve(16);\n+\n+    // Always try to read into the empty space of the vector (from the length to the capacity).\n+    // If the vector ever fills up then we reserve an extra byte which should trigger the normal\n+    // reallocation routines for the vector, which will likely double the size.\n+    //\n+    // This function is similar to the read_to_end function in std::io, but the logic about\n+    // reservations and slicing is different enough that this is duplicated here.\n+    loop {\n+        if buf.len() == buf.capacity() {\n+            buf.reserve(1);\n+        }\n+\n+        let buf_slice = from_raw_parts_mut(buf.as_mut_ptr().offset(buf.len() as isize),\n+                                           buf.capacity() - buf.len());\n+\n+        match r.read(buf_slice) {\n+            Ok(0) => { return Ok(buf.len() - start_len); }\n+            Ok(n) => { let len = buf.len() + n; buf.set_len(len); },\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => { }\n+            Err(e) => { return Err(e); }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use io::prelude::*;\n+    use super::*;\n+    use io;\n+    use io::{ErrorKind, Take, Repeat, repeat};\n+    use test;\n+    use slice::from_raw_parts;\n+\n+    struct ErrorRepeat {\n+        lr: Take<Repeat>\n+    }\n+\n+    fn error_repeat(byte: u8, limit: u64) -> ErrorRepeat {\n+        ErrorRepeat { lr: repeat(byte).take(limit) }\n+    }\n+\n+    impl Read for ErrorRepeat {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            let ret = self.lr.read(buf);\n+            if let Ok(0) = ret {\n+                return Err(io::Error::new(ErrorKind::Other, \"\"))\n+            }\n+            ret\n+        }\n+    }\n+\n+    fn init_vec_data() -> Vec<u8> {\n+        let mut vec = vec![10u8; 200];\n+        unsafe { vec.set_len(0); }\n+        vec\n+    }\n+\n+    fn assert_all_eq(buf: &[u8], value: u8) {\n+        for n in buf {\n+            assert_eq!(*n, value);\n+        }\n+    }\n+\n+    fn validate(buf: &Vec<u8>, good_read_len: usize) {\n+        assert_all_eq(buf, 1u8);\n+        let cap = buf.capacity();\n+        let end_slice = unsafe { from_raw_parts(buf.as_ptr().offset(good_read_len as isize),\n+                                                    cap - good_read_len) };\n+        assert_all_eq(end_slice, 10u8);\n+    }\n+\n+    #[test]\n+    fn read_to_end_uninit_error() {\n+        let mut er = error_repeat(1,100);\n+        let mut vec = init_vec_data();\n+        if let Err(_) = unsafe { read_to_end_uninitialized(&mut er, &mut vec) } {\n+            validate(&vec, 100);\n+        } else {\n+            assert!(false);\n+        }\n+    }\n+\n+    #[test]\n+    fn read_to_end_uninit_zero_len_vec() {\n+        let mut er = repeat(1).take(100);\n+        let mut vec = Vec::new();\n+        let n = unsafe{ read_to_end_uninitialized(&mut er, &mut vec).unwrap() };\n+        assert_all_eq(&vec, 1u8);\n+        assert_eq!(vec.len(), n);\n+    }\n+\n+    #[test]\n+    fn read_to_end_uninit_good() {\n+        let mut er = repeat(1).take(100);\n+        let mut vec = init_vec_data();\n+        let n = unsafe{ read_to_end_uninitialized(&mut er, &mut vec).unwrap() };\n+        validate(&vec, 100);\n+        assert_eq!(vec.len(), n);\n+    }\n+\n+    #[bench]\n+    fn bench_uninitialized(b: &mut test::Bencher) {\n+        b.iter(|| {\n+            let mut lr = repeat(1).take(10000000);\n+            let mut vec = Vec::with_capacity(1024);\n+            unsafe { read_to_end_uninitialized(&mut lr, &mut vec) };\n+        });\n+    }\n+}"}, {"sha": "69c54f989175973ee851e1ef54b212bf245dd233", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f287240ff9518c1ea5519c5cd03dc2ba6d4452/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=98f287240ff9518c1ea5519c5cd03dc2ba6d4452", "patch": "@@ -16,6 +16,7 @@ pub mod backtrace;\n pub mod condvar;\n pub mod mutex;\n pub mod net;\n+pub mod io;\n pub mod poison;\n pub mod remutex;\n pub mod rwlock;"}]}