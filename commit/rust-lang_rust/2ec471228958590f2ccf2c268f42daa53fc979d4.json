{"sha": "2ec471228958590f2ccf2c268f42daa53fc979d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYzQ3MTIyODk1ODU5MGYyY2NmMmMyNjhmNDJkYWE1M2ZjOTc5ZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-13T10:56:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-13T10:56:43Z"}, "message": "auto merge of #10895 : sfackler/rust/io-util, r=alexcrichton\n\nThis adds a bunch of useful Reader and Writer implementations. I'm not a\r\nhuge fan of the name `util` but I can't think of a better name and I\r\ndon't want to make `std::io` any longer than it already is.", "tree": {"sha": "35b5025e72780fdfb5dc11c11ba1ee5bdf2a0098", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35b5025e72780fdfb5dc11c11ba1ee5bdf2a0098"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ec471228958590f2ccf2c268f42daa53fc979d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ec471228958590f2ccf2c268f42daa53fc979d4", "html_url": "https://github.com/rust-lang/rust/commit/2ec471228958590f2ccf2c268f42daa53fc979d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ec471228958590f2ccf2c268f42daa53fc979d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bbef13702561b955bc1fd71608502d3a10a4acc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bbef13702561b955bc1fd71608502d3a10a4acc", "html_url": "https://github.com/rust-lang/rust/commit/9bbef13702561b955bc1fd71608502d3a10a4acc"}, {"sha": "7fe5e3082394ba73f54ceeadd3ed092fd54ee0ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fe5e3082394ba73f54ceeadd3ed092fd54ee0ff", "html_url": "https://github.com/rust-lang/rust/commit/7fe5e3082394ba73f54ceeadd3ed092fd54ee0ff"}], "stats": {"total": 298, "additions": 298, "deletions": 0}, "files": [{"sha": "c5ae6457515901a546e8b9efb6d120ed2e76d89d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ec471228958590f2ccf2c268f42daa53fc979d4/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec471228958590f2ccf2c268f42daa53fc979d4/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=2ec471228958590f2ccf2c268f42daa53fc979d4", "patch": "@@ -335,6 +335,9 @@ pub mod native;\n /// Signal handling\n pub mod signal;\n \n+/// Utility implementations of Reader and Writer\n+pub mod util;\n+\n /// The default buffer size for various I/O operations\n static DEFAULT_BUF_SIZE: uint = 1024 * 64;\n "}, {"sha": "75be56113e9301b0bcf6d4e9ceb5f753a876da8a", "filename": "src/libstd/io/util.rs", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/2ec471228958590f2ccf2c268f42daa53fc979d4/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec471228958590f2ccf2c268f42daa53fc979d4/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=2ec471228958590f2ccf2c268f42daa53fc979d4", "patch": "@@ -0,0 +1,295 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use prelude::*;\n+use cmp;\n+use vec::bytes::MutableByteVector;\n+\n+/// Wraps a `Reader`, limiting the number of bytes that can be read from it.\n+pub struct LimitReader<'a, R> {\n+    priv limit: uint,\n+    priv inner: &'a mut R\n+}\n+\n+impl<'a, R: Reader> LimitReader<'a, R> {\n+    /// Creates a new `LimitReader`\n+    pub fn new<'a>(r: &'a mut R, limit: uint) -> LimitReader<'a, R> {\n+        LimitReader { limit: limit, inner: r }\n+    }\n+}\n+\n+impl<'a, R: Reader> Reader for LimitReader<'a, R> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        if self.limit == 0 {\n+            return None;\n+        }\n+\n+        let len = cmp::min(self.limit, buf.len());\n+        self.inner.read(buf.mut_slice_to(len)).map(|len| {\n+            self.limit -= len;\n+            len\n+        })\n+    }\n+\n+    fn eof(&mut self) -> bool {\n+        self.limit == 0 || self.inner.eof()\n+    }\n+}\n+\n+/// A `Writer` which ignores bytes written to it, like /dev/null.\n+pub struct NullWriter;\n+\n+impl Writer for NullWriter {\n+    #[inline]\n+    fn write(&mut self, _buf: &[u8]) { }\n+}\n+\n+/// A `Reader` which returns an infinite stream of 0 bytes, like /dev/zero.\n+pub struct ZeroReader;\n+\n+impl Reader for ZeroReader {\n+    #[inline]\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        buf.set_memory(0);\n+        Some(buf.len())\n+    }\n+\n+    #[inline]\n+    fn eof(&mut self) -> bool {\n+        false\n+    }\n+}\n+\n+/// A `Reader` which is always at EOF, like /dev/null.\n+pub struct NullReader;\n+\n+impl Reader for NullReader {\n+    #[inline]\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> {\n+        None\n+    }\n+\n+    #[inline]\n+    fn eof(&mut self) -> bool {\n+        true\n+    }\n+}\n+\n+/// A `Writer` which multiplexes writes to a set of `Writers`.\n+pub struct MultiWriter {\n+    priv writers: ~[~Writer]\n+}\n+\n+impl MultiWriter {\n+    /// Creates a new `MultiWriter`\n+    pub fn new(writers: ~[~Writer]) -> MultiWriter {\n+        MultiWriter { writers: writers }\n+    }\n+}\n+\n+impl Writer for MultiWriter {\n+    #[inline]\n+    fn write(&mut self, buf: &[u8]) {\n+        for writer in self.writers.mut_iter() {\n+            writer.write(buf);\n+        }\n+    }\n+\n+    #[inline]\n+    fn flush(&mut self) {\n+        for writer in self.writers.mut_iter() {\n+            writer.flush();\n+        }\n+    }\n+}\n+\n+/// A `Reader` which chains input from multiple `Readers`, reading each to\n+/// completion before moving onto the next.\n+pub struct ChainedReader<I, R> {\n+    priv readers: I,\n+    priv cur_reader: Option<R>,\n+}\n+\n+impl<R: Reader, I: Iterator<R>> ChainedReader<I, R> {\n+    /// Creates a new `ChainedReader`\n+    pub fn new(mut readers: I) -> ChainedReader<I, R> {\n+        let r = readers.next();\n+        ChainedReader { readers: readers, cur_reader: r }\n+    }\n+}\n+\n+impl<R: Reader, I: Iterator<R>> Reader for ChainedReader<I, R> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        loop {\n+            match self.cur_reader {\n+                Some(ref mut r) => {\n+                    match r.read(buf) {\n+                        Some(len) => return Some(len),\n+                        None => {}\n+                    }\n+                }\n+                None => break\n+            }\n+            self.cur_reader = self.readers.next()\n+        }\n+        None\n+    }\n+\n+    fn eof(&mut self) -> bool {\n+        self.cur_reader.is_none()\n+    }\n+}\n+\n+/// A `Reader` which forwards input from another `Reader`, passing it along to\n+/// a `Writer` as well. Similar to the `tee(1)` command.\n+pub struct TeeReader<R, W> {\n+    priv reader: R,\n+    priv writer: W\n+}\n+\n+impl<R: Reader, W: Writer> TeeReader<R, W> {\n+    /// Creates a new `TeeReader`\n+    pub fn new(r: R, w: W) -> TeeReader<R, W> {\n+        TeeReader { reader: r, writer: w }\n+    }\n+\n+    /// Consumes the `TeeReader`, returning the underlying `Reader` and\n+    /// `Writer`.\n+    pub fn unwrap(self) -> (R, W) {\n+        let TeeReader { reader, writer } = self;\n+        (reader, writer)\n+    }\n+}\n+\n+impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        self.reader.read(buf).map(|len| {\n+            self.writer.write(buf.slice_to(len));\n+            len\n+        })\n+    }\n+\n+    fn eof(&mut self) -> bool {\n+        self.reader.eof()\n+    }\n+}\n+\n+/// Copies all data from a `Reader` to a `Writer`.\n+pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) {\n+    let mut buf = [0, ..super::DEFAULT_BUF_SIZE];\n+    loop {\n+        match r.read(buf) {\n+            Some(len) => w.write(buf.slice_to(len)),\n+            None => break\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use io::mem::{MemReader, MemWriter};\n+    use super::*;\n+    use prelude::*;\n+\n+    #[test]\n+    fn test_bounded_reader_unlimited() {\n+        let mut r = MemReader::new(~[0, 1, 2]);\n+        {\n+            let mut r = LimitReader::new(&mut r, 4);\n+            assert_eq!(~[0, 1, 2], r.read_to_end());\n+        }\n+        assert!(r.eof());\n+    }\n+\n+    #[test]\n+    fn test_bound_reader_limited() {\n+        let mut r = MemReader::new(~[0, 1, 2]);\n+        {\n+            let mut r = LimitReader::new(&mut r, 2);\n+            assert_eq!(~[0, 1], r.read_to_end());\n+        }\n+        assert_eq!(~[2], r.read_to_end());\n+    }\n+\n+    #[test]\n+    fn test_null_writer() {\n+        let mut s = NullWriter;\n+        let mut buf = ~[0, 0, 0];\n+        s.write(buf);\n+        s.flush();\n+    }\n+\n+    #[test]\n+    fn test_zero_reader() {\n+        let mut s = ZeroReader;\n+        let mut buf = ~[1, 2, 3];\n+        assert_eq!(s.read(buf), Some(3));\n+        assert_eq!(~[0, 0, 0], buf);\n+    }\n+\n+    #[test]\n+    fn test_null_reader() {\n+        let mut r = NullReader;\n+        let mut buf = ~[0];\n+        assert_eq!(r.read(buf), None);\n+        assert!(r.eof());\n+    }\n+\n+    #[test]\n+    fn test_multi_writer() {\n+        static mut writes: uint = 0;\n+        static mut flushes: uint = 0;\n+\n+        struct TestWriter;\n+        impl Writer for TestWriter {\n+            fn write(&mut self, buf: &[u8]) {\n+                unsafe { writes += 1 }\n+            }\n+\n+            fn flush(&mut self) {\n+                unsafe { flushes += 1 }\n+            }\n+        }\n+\n+        let mut multi = MultiWriter::new(~[~TestWriter as ~Writer,\n+                                           ~TestWriter as ~Writer]);\n+        multi.write([1, 2, 3]);\n+        assert_eq!(2, unsafe { writes });\n+        assert_eq!(0, unsafe { flushes });\n+        multi.flush();\n+        assert_eq!(2, unsafe { writes });\n+        assert_eq!(2, unsafe { flushes });\n+    }\n+\n+    #[test]\n+    fn test_chained_reader() {\n+        let rs = ~[MemReader::new(~[0, 1]), MemReader::new(~[]),\n+                   MemReader::new(~[2, 3])];\n+        let mut r = ChainedReader::new(rs.move_iter());\n+        assert_eq!(~[0, 1, 2, 3], r.read_to_end());\n+    }\n+\n+    #[test]\n+    fn test_tee_reader() {\n+        let mut r = TeeReader::new(MemReader::new(~[0, 1, 2]),\n+                                   MemWriter::new());\n+        assert_eq!(~[0, 1, 2], r.read_to_end());\n+        let (_, w) = r.unwrap();\n+        assert_eq!(~[0, 1, 2], w.inner());\n+    }\n+\n+    #[test]\n+    fn test_copy() {\n+        let mut r = MemReader::new(~[0, 1, 2, 3, 4]);\n+        let mut w = MemWriter::new();\n+        copy(&mut r, &mut w);\n+        assert!(r.eof());\n+        assert_eq!(~[0, 1, 2, 3, 4], w.inner());\n+    }\n+}"}]}