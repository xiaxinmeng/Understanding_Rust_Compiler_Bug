{"sha": "3874676dc6bcb311fa134baa5232d971d6573b29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NzQ2NzZkYzZiY2IzMTFmYTEzNGJhYTUyMzJkOTcxZDY1NzNiMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-24T01:06:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-24T01:06:21Z"}, "message": "Auto merge of #51726 - petrochenkov:hygclean, r=oli-obk\n\nexpansion/hygiene: Some renaming, refactoring and comments\n\nPure refactoring, no functional changes.\nCommits are isolated and self-descriptive.", "tree": {"sha": "3fa5144ff883bebfd8ee9f82cd00d8556d119488", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fa5144ff883bebfd8ee9f82cd00d8556d119488"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3874676dc6bcb311fa134baa5232d971d6573b29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3874676dc6bcb311fa134baa5232d971d6573b29", "html_url": "https://github.com/rust-lang/rust/commit/3874676dc6bcb311fa134baa5232d971d6573b29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3874676dc6bcb311fa134baa5232d971d6573b29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fb1180d27e7aaa3aa7ad7f0d961703af9d7bb7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fb1180d27e7aaa3aa7ad7f0d961703af9d7bb7a", "html_url": "https://github.com/rust-lang/rust/commit/8fb1180d27e7aaa3aa7ad7f0d961703af9d7bb7a"}, {"sha": "20ce91076af125eda82bb36e446e67b1c7af4218", "url": "https://api.github.com/repos/rust-lang/rust/commits/20ce91076af125eda82bb36e446e67b1c7af4218", "html_url": "https://github.com/rust-lang/rust/commit/20ce91076af125eda82bb36e446e67b1c7af4218"}], "stats": {"total": 940, "additions": 495, "deletions": 445}, "files": [{"sha": "4cd822aa9d0b969689318d6e08d2e850beea3ac3", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -85,9 +85,6 @@ impl ProcMacro for Quoter {\n                    _: ::syntax_pos::Span,\n                    stream: tokenstream::TokenStream)\n                    -> tokenstream::TokenStream {\n-        let mut info = cx.current_expansion.mark.expn_info().unwrap();\n-        info.callee.allow_internal_unstable = true;\n-        cx.current_expansion.mark.set_expn_info(info);\n         ::__internal::set_sess(cx, || TokenStream(stream).quote().0)\n     }\n }"}, {"sha": "4f470e1c26b46176871db7dce29bc80b81ff5c94", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -612,13 +612,11 @@ impl<'a> LoweringContext<'a> {\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(codemap::ExpnInfo {\n             call_site: span,\n-            callee: codemap::NameAndSpan {\n-                format: codemap::CompilerDesugaring(reason),\n-                span: Some(span),\n-                allow_internal_unstable: true,\n-                allow_internal_unsafe: false,\n-                edition: codemap::hygiene::default_edition(),\n-            },\n+            def_site: Some(span),\n+            format: codemap::CompilerDesugaring(reason),\n+            allow_internal_unstable: true,\n+            allow_internal_unsafe: false,\n+            edition: codemap::hygiene::default_edition(),\n         });\n         span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     }"}, {"sha": "b2365e22cc66f39268d0f4fc14a6af1cf16a14f8", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -157,8 +157,13 @@ pub struct Definitions {\n     node_to_def_index: NodeMap<DefIndex>,\n     def_index_to_node: [Vec<ast::NodeId>; 2],\n     pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n-    macro_def_scopes: FxHashMap<Mark, DefId>,\n-    expansions: FxHashMap<DefIndex, Mark>,\n+    /// If `Mark` is an ID of some macro expansion,\n+    /// then `DefId` is the normal module (`mod`) in which the expanded macro was defined.\n+    parent_modules_of_macro_defs: FxHashMap<Mark, DefId>,\n+    /// Item with a given `DefIndex` was defined during opaque macro expansion with ID `Mark`.\n+    /// It can actually be defined during transparent macro expansions inside that opaque expansion,\n+    /// but transparent expansions are ignored here.\n+    opaque_expansions_that_defined: FxHashMap<DefIndex, Mark>,\n     next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n     def_index_to_span: FxHashMap<DefIndex, Span>,\n }\n@@ -175,8 +180,8 @@ impl Clone for Definitions {\n                 self.def_index_to_node[1].clone(),\n             ],\n             node_to_hir_id: self.node_to_hir_id.clone(),\n-            macro_def_scopes: self.macro_def_scopes.clone(),\n-            expansions: self.expansions.clone(),\n+            parent_modules_of_macro_defs: self.parent_modules_of_macro_defs.clone(),\n+            opaque_expansions_that_defined: self.opaque_expansions_that_defined.clone(),\n             next_disambiguator: self.next_disambiguator.clone(),\n             def_index_to_span: self.def_index_to_span.clone(),\n         }\n@@ -397,8 +402,8 @@ impl Definitions {\n             node_to_def_index: NodeMap(),\n             def_index_to_node: [vec![], vec![]],\n             node_to_hir_id: IndexVec::new(),\n-            macro_def_scopes: FxHashMap(),\n-            expansions: FxHashMap(),\n+            parent_modules_of_macro_defs: FxHashMap(),\n+            opaque_expansions_that_defined: FxHashMap(),\n             next_disambiguator: FxHashMap(),\n             def_index_to_span: FxHashMap(),\n         }\n@@ -580,7 +585,7 @@ impl Definitions {\n \n         let expansion = expansion.modern();\n         if expansion != Mark::root() {\n-            self.expansions.insert(index, expansion);\n+            self.opaque_expansions_that_defined.insert(index, expansion);\n         }\n \n         // The span is added if it isn't DUMMY_SP\n@@ -600,16 +605,16 @@ impl Definitions {\n         self.node_to_hir_id = mapping;\n     }\n \n-    pub fn expansion(&self, index: DefIndex) -> Mark {\n-        self.expansions.get(&index).cloned().unwrap_or(Mark::root())\n+    pub fn opaque_expansion_that_defined(&self, index: DefIndex) -> Mark {\n+        self.opaque_expansions_that_defined.get(&index).cloned().unwrap_or(Mark::root())\n     }\n \n-    pub fn macro_def_scope(&self, mark: Mark) -> DefId {\n-        self.macro_def_scopes[&mark]\n+    pub fn parent_module_of_macro_def(&self, mark: Mark) -> DefId {\n+        self.parent_modules_of_macro_defs[&mark]\n     }\n \n-    pub fn add_macro_def_scope(&mut self, mark: Mark, scope: DefId) {\n-        self.macro_def_scopes.insert(mark, scope);\n+    pub fn add_parent_module_of_macro_def(&mut self, mark: Mark, module: DefId) {\n+        self.parent_modules_of_macro_defs.insert(mark, module);\n     }\n }\n "}, {"sha": "935bc4c8c6d8c532e017942150cc4ad53fe38d56", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -391,15 +391,11 @@ impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n \n impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnInfo {\n     call_site,\n-    callee\n-});\n-\n-impl_stable_hash_for!(struct ::syntax_pos::hygiene::NameAndSpan {\n+    def_site,\n     format,\n     allow_internal_unstable,\n     allow_internal_unsafe,\n-    edition,\n-    span\n+    edition\n });\n \n impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {"}, {"sha": "0d7d39ccf40dfcff2e069e7537c8d5472f5becba", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -366,9 +366,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if let Some(k) = obligation.cause.span.compiler_desugaring_kind() {\n-            let desugaring = k.as_symbol().as_str();\n             flags.push((\"from_desugaring\".to_string(), None));\n-            flags.push((\"from_desugaring\".to_string(), Some(desugaring.to_string())));\n+            flags.push((\"from_desugaring\".to_string(), Some(k.name().to_string())));\n         }\n         let generics = self.tcx.generics_of(def_id);\n         let self_ty = trait_ref.self_ty();"}, {"sha": "ce7098314557939fc59623815997c138ba2b01e7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -2732,13 +2732,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: NodeId) -> (Ident, DefId) {\n-        let expansion = match scope.krate {\n-            LOCAL_CRATE => self.hir.definitions().expansion(scope.index),\n+        ident = ident.modern();\n+        let target_expansion = match scope.krate {\n+            LOCAL_CRATE => self.hir.definitions().opaque_expansion_that_defined(scope.index),\n             _ => Mark::root(),\n         };\n-        ident = ident.modern();\n-        let scope = match ident.span.adjust(expansion) {\n-            Some(macro_def) => self.hir.definitions().macro_def_scope(macro_def),\n+        let scope = match ident.span.adjust(target_expansion) {\n+            Some(actual_expansion) =>\n+                self.hir.definitions().parent_module_of_macro_def(actual_expansion),\n             None if block == DUMMY_NODE_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId\n             None => self.hir.get_module_parent(block),\n         };"}, {"sha": "a9530964bffa2ab0874e119ea2d15891dbec7010", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -15,7 +15,7 @@ use syntax::ast::{Arg, FnHeader, Generics, Mac, Mutability, Ty, Unsafety};\n use syntax::ast::{self, Expr, Ident, Item, ItemKind, TyKind, VisibilityKind};\n use syntax::attr;\n use syntax::codemap::respan;\n-use syntax::codemap::{ExpnInfo, MacroAttribute, NameAndSpan};\n+use syntax::codemap::{ExpnInfo, MacroAttribute};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::base::Resolver;\n use syntax::ext::build::AstBuilder;\n@@ -80,13 +80,11 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(ExpnInfo {\n             call_site: DUMMY_SP,\n-            callee: NameAndSpan {\n-                format: MacroAttribute(Symbol::intern(name)),\n-                span: None,\n-                allow_internal_unstable: true,\n-                allow_internal_unsafe: false,\n-                edition: hygiene::default_edition(),\n-            },\n+            def_site: None,\n+            format: MacroAttribute(Symbol::intern(name)),\n+            allow_internal_unstable: true,\n+            allow_internal_unsafe: false,\n+            edition: hygiene::default_edition(),\n         });\n         let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n         let ecfg = ExpansionConfig::default(name.to_string());"}, {"sha": "1a13335a0e49d34bfc44b62f02b7011ecd4126b1", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -570,7 +570,7 @@ impl<'a> CrateLoader<'a> {\n                                         name: &str,\n                                         expand: fn(TokenStream) -> TokenStream) {\n                 let expand = SyntaxExtension::ProcMacro(\n-                    Box::new(BangProcMacro { inner: expand }), self.edition\n+                    Box::new(BangProcMacro { inner: expand }), false, self.edition\n                 );\n                 self.extensions.push((Symbol::intern(name), Lrc::new(expand)));\n             }"}, {"sha": "d0e4e54e63d677f86f615ff5004b4620d3c5b644", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -519,7 +519,7 @@ impl CrateStore for cstore::CStore {\n         } else if data.name == \"proc_macro\" &&\n                   self.get_crate_data(id.krate).item_name(id.index) == \"quote\" {\n             let ext = SyntaxExtension::ProcMacro(Box::new(::proc_macro::__internal::Quoter),\n-                                                 data.root.edition);\n+                                                 true, data.root.edition);\n             return LoadedMacro::ProcMacro(Lrc::new(ext));\n         }\n "}, {"sha": "2052918747b39301f1f14364c7d244b77a7eb00c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -45,7 +45,7 @@ use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n use syntax::codemap::CodeMap;\n-use syntax::ext::hygiene::{Mark, MarkKind, SyntaxContext};\n+use syntax::ext::hygiene::{Mark, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n@@ -1988,7 +1988,7 @@ impl<'a> Resolver<'a> {\n             // When resolving `$crate` from a `macro_rules!` invoked in a `macro`,\n             // we don't want to pretend that the `macro_rules!` definition is in the `macro`\n             // as described in `SyntaxContext::apply_mark`, so we ignore prepended modern marks.\n-            ctxt.marks().into_iter().find(|&mark| mark.kind() != MarkKind::Modern)\n+            ctxt.marks().into_iter().find(|&mark| mark.transparency() != Transparency::Opaque)\n         } else {\n             ctxt = ctxt.modern();\n             ctxt.adjust(Mark::root())"}, {"sha": "ebdaa456170b215a33bd16d653d040821e8fd934", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -23,8 +23,8 @@ use syntax::attr::{self, HasAttrs};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n-use syntax::ext::expand::{Expansion, ExpansionKind, Invocation, InvocationKind, find_attr_invoc};\n-use syntax::ext::hygiene::{self, Mark, MarkKind};\n+use syntax::ext::expand::{self, AstFragment, AstFragmentKind, Invocation, InvocationKind};\n+use syntax::ext::hygiene::{self, Mark, Transparency};\n use syntax::ext::placeholders::placeholder;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n@@ -187,9 +187,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.whitelisted_legacy_custom_derives.contains(&name)\n     }\n \n-    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]) {\n+    fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n+                                            derives: &[Mark]) {\n         let invocation = self.invocations[&mark];\n-        self.collect_def_ids(mark, invocation, expansion);\n+        self.collect_def_ids(mark, invocation, fragment);\n \n         self.current_module = invocation.module.get();\n         self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n@@ -202,7 +203,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             legacy_scope: LegacyScope::Invocation(invocation),\n             expansion: mark,\n         };\n-        expansion.visit_with(&mut visitor);\n+        fragment.visit_with(&mut visitor);\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n@@ -326,14 +327,15 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.macro_defs.insert(invoc.expansion_data.mark, def_id);\n         let normal_module_def_id =\n             self.macro_def_scope(invoc.expansion_data.mark).normal_ancestor_id;\n-        self.definitions.add_macro_def_scope(invoc.expansion_data.mark, normal_module_def_id);\n+        self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.mark,\n+                                                        normal_module_def_id);\n \n         self.unused_macros.remove(&def_id);\n         let ext = self.get_macro(def);\n         if ext.is_modern() {\n-            invoc.expansion_data.mark.set_kind(MarkKind::Modern);\n+            invoc.expansion_data.mark.set_transparency(Transparency::Opaque);\n         } else if def_id.krate == BUILTIN_MACROS_CRATE {\n-            invoc.expansion_data.mark.set_kind(MarkKind::Builtin);\n+            invoc.expansion_data.mark.set_is_builtin(true);\n         }\n         Ok(Some(ext))\n     }\n@@ -396,14 +398,14 @@ impl<'a> Resolver<'a> {\n                 Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs, _) = *ext {\n                     if inert_attrs.contains(&attr_name) {\n                         // FIXME(jseyfried) Avoid `mem::replace` here.\n-                        let dummy_item = placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n+                        let dummy_item = placeholder(AstFragmentKind::Items, ast::DUMMY_NODE_ID)\n                             .make_items().pop().unwrap();\n                         let dummy_item = Annotatable::Item(dummy_item);\n                         *item = mem::replace(item, dummy_item).map_attrs(|mut attrs| {\n                             let inert_attr = attr.take().unwrap();\n                             attr::mark_known(&inert_attr);\n                             if self.proc_macro_enabled {\n-                                *attr = find_attr_invoc(&mut attrs);\n+                                *attr = expand::find_attr_invoc(&mut attrs);\n                             }\n                             attrs.push(inert_attr);\n                             attrs\n@@ -769,7 +771,7 @@ impl<'a> Resolver<'a> {\n     fn collect_def_ids(&mut self,\n                        mark: Mark,\n                        invocation: &'a InvocationData<'a>,\n-                       expansion: &Expansion) {\n+                       fragment: &AstFragment) {\n         let Resolver { ref mut invocations, arenas, graph_root, .. } = *self;\n         let InvocationData { def_index, .. } = *invocation;\n \n@@ -787,7 +789,7 @@ impl<'a> Resolver<'a> {\n         let mut def_collector = DefCollector::new(&mut self.definitions, mark);\n         def_collector.visit_macro_invoc = Some(visit_macro_invoc);\n         def_collector.with_parent(def_index, |def_collector| {\n-            expansion.visit_with(def_collector)\n+            fragment.visit_with(def_collector)\n         });\n     }\n "}, {"sha": "deb91774175667d148bc7b79a7f48b1f1990c940", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -844,7 +844,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let callsite = span.source_callsite();\n         let callsite_span = self.span_from_span(callsite);\n         let callee = span.source_callee()?;\n-        let callee_span = callee.span?;\n+        let callee_span = callee.def_site?;\n \n         // Ignore attribute macros, their spans are usually mangled\n         if let MacroAttribute(_) = callee.format {\n@@ -872,7 +872,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let callee_span = self.span_from_span(callee_span);\n         Some(MacroRef {\n             span: callsite_span,\n-            qualname: callee.name().to_string(), // FIXME: generate the real qualname\n+            qualname: callee.format.name().to_string(), // FIXME: generate the real qualname\n             callee_span,\n         })\n     }"}, {"sha": "8e4b7660a1ccef89c20739d2134588f25e7852bb", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -19,7 +19,7 @@\n \n \n pub use syntax_pos::*;\n-pub use syntax_pos::hygiene::{ExpnFormat, ExpnInfo, NameAndSpan};\n+pub use syntax_pos::hygiene::{ExpnFormat, ExpnInfo};\n pub use self::ExpnFormat::*;\n \n use rustc_data_structures::fx::FxHashMap;"}, {"sha": "16d786dd6cad2f76450618c0c917a80991d12e36", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -16,7 +16,7 @@ use codemap::{self, CodeMap, Spanned, respan};\n use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n use edition::Edition;\n use errors::{DiagnosticBuilder, DiagnosticId};\n-use ext::expand::{self, Expansion, Invocation};\n+use ext::expand::{self, AstFragment, Invocation};\n use ext::hygiene::{self, Mark, SyntaxContext};\n use fold::{self, Folder};\n use parse::{self, parser, DirectoryOwnership};\n@@ -597,7 +597,11 @@ pub enum SyntaxExtension {\n     MultiModifier(Box<MultiItemModifier + sync::Sync + sync::Send>),\n \n     /// A function-like procedural macro. TokenStream -> TokenStream.\n-    ProcMacro(Box<ProcMacro + sync::Sync + sync::Send>, Edition),\n+    ProcMacro(\n+        /* expander: */ Box<ProcMacro + sync::Sync + sync::Send>,\n+        /* allow_internal_unstable: */ bool,\n+        /* edition: */ Edition,\n+    ),\n \n     /// An attribute-like procedural macro. TokenStream, TokenStream -> TokenStream.\n     /// The first TokenSteam is the attribute, the second is the annotated item.\n@@ -697,7 +701,8 @@ pub trait Resolver {\n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item>;\n     fn is_whitelisted_legacy_custom_derive(&self, name: Name) -> bool;\n \n-    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]);\n+    fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n+                                            derives: &[Mark]);\n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n \n     fn resolve_imports(&mut self);\n@@ -726,7 +731,8 @@ impl Resolver for DummyResolver {\n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> { item }\n     fn is_whitelisted_legacy_custom_derive(&self, _name: Name) -> bool { false }\n \n-    fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion, _derives: &[Mark]) {}\n+    fn visit_ast_fragment_with_placeholders(&mut self, _invoc: Mark, _fragment: &AstFragment,\n+                                            _derives: &[Mark]) {}\n     fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n \n     fn resolve_imports(&mut self) {}\n@@ -828,7 +834,7 @@ impl<'a> ExtCtxt<'a> {\n         let mut last_macro = None;\n         loop {\n             if ctxt.outer().expn_info().map_or(None, |info| {\n-                if info.callee.name() == \"include\" {\n+                if info.format.name() == \"include\" {\n                     // Stop going up the backtrace once include! is encountered\n                     return None;\n                 }"}, {"sha": "940fb6405f1b6065c170dfd7d7abc5ec9fdfd006", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -10,7 +10,7 @@\n \n use attr::HasAttrs;\n use ast;\n-use codemap::{hygiene, ExpnInfo, NameAndSpan, ExpnFormat};\n+use codemap::{hygiene, ExpnInfo, ExpnFormat};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use parse::parser::PathStyle;\n@@ -60,13 +60,11 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path]\n \n     cx.current_expansion.mark.set_expn_info(ExpnInfo {\n         call_site: span,\n-        callee: NameAndSpan {\n-            format: ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)),\n-            span: None,\n-            allow_internal_unstable: true,\n-            allow_internal_unsafe: false,\n-            edition: hygiene::default_edition(),\n-        },\n+        def_site: None,\n+        format: ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)),\n+        allow_internal_unstable: true,\n+        allow_internal_unsafe: false,\n+        edition: hygiene::default_edition(),\n     });\n \n     let span = span.with_ctxt(cx.backtrace());"}, {"sha": "69c99c63aafe3e55692d41ec91785063c00879c4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 252, "deletions": 230, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -11,7 +11,7 @@\n use ast::{self, Block, Ident, NodeId, PatKind, Path};\n use ast::{MacStmtStyle, StmtKind, ItemKind};\n use attr::{self, HasAttrs};\n-use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute, dummy_spanned, respan};\n+use codemap::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, respan};\n use config::{is_test_or_bench, StripUnconfigured};\n use errors::{Applicability, FatalError};\n use ext::base::*;\n@@ -40,126 +40,149 @@ use std::mem;\n use std::rc::Rc;\n use std::path::PathBuf;\n \n-macro_rules! expansions {\n-    ($($kind:ident: $ty:ty [$($vec:ident, $ty_elt:ty)*], $kind_name:expr, .$make:ident,\n-            $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n-            $(.$visit:ident)*  $(lift .$visit_elt:ident)*;)*) => {\n+macro_rules! ast_fragments {\n+    (\n+        $($Kind:ident($AstTy:ty) {\n+            $kind_name:expr;\n+            $(one fn $fold_ast:ident; fn $visit_ast:ident;)?\n+            $(many fn $fold_ast_elt:ident; fn $visit_ast_elt:ident;)?\n+            fn $make_ast:ident;\n+        })*\n+    ) => {\n+        /// A fragment of AST that can be produced by a single macro expansion.\n+        /// Can also serve as an input and intermediate result for macro expansion operations.\n+        pub enum AstFragment {\n+            OptExpr(Option<P<ast::Expr>>),\n+            $($Kind($AstTy),)*\n+        }\n+\n+        /// \"Discriminant\" of an AST fragment.\n         #[derive(Copy, Clone, PartialEq, Eq)]\n-        pub enum ExpansionKind { OptExpr, $( $kind, )*  }\n-        pub enum Expansion { OptExpr(Option<P<ast::Expr>>), $( $kind($ty), )* }\n+        pub enum AstFragmentKind {\n+            OptExpr,\n+            $($Kind,)*\n+        }\n \n-        impl ExpansionKind {\n+        impl AstFragmentKind {\n             pub fn name(self) -> &'static str {\n                 match self {\n-                    ExpansionKind::OptExpr => \"expression\",\n-                    $( ExpansionKind::$kind => $kind_name, )*\n+                    AstFragmentKind::OptExpr => \"expression\",\n+                    $(AstFragmentKind::$Kind => $kind_name,)*\n                 }\n             }\n \n-            fn make_from<'a>(self, result: Box<MacResult + 'a>) -> Option<Expansion> {\n+            fn make_from<'a>(self, result: Box<MacResult + 'a>) -> Option<AstFragment> {\n                 match self {\n-                    ExpansionKind::OptExpr => result.make_expr().map(Some).map(Expansion::OptExpr),\n-                    $( ExpansionKind::$kind => result.$make().map(Expansion::$kind), )*\n+                    AstFragmentKind::OptExpr =>\n+                        result.make_expr().map(Some).map(AstFragment::OptExpr),\n+                    $(AstFragmentKind::$Kind => result.$make_ast().map(AstFragment::$Kind),)*\n                 }\n             }\n         }\n \n-        impl Expansion {\n+        impl AstFragment {\n             pub fn make_opt_expr(self) -> Option<P<ast::Expr>> {\n                 match self {\n-                    Expansion::OptExpr(expr) => expr,\n-                    _ => panic!(\"Expansion::make_* called on the wrong kind of expansion\"),\n+                    AstFragment::OptExpr(expr) => expr,\n+                    _ => panic!(\"AstFragment::make_* called on the wrong kind of fragment\"),\n                 }\n             }\n-            $( pub fn $make(self) -> $ty {\n+\n+            $(pub fn $make_ast(self) -> $AstTy {\n                 match self {\n-                    Expansion::$kind(ast) => ast,\n-                    _ => panic!(\"Expansion::make_* called on the wrong kind of expansion\"),\n+                    AstFragment::$Kind(ast) => ast,\n+                    _ => panic!(\"AstFragment::make_* called on the wrong kind of fragment\"),\n                 }\n-            } )*\n+            })*\n \n             pub fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n-                use self::Expansion::*;\n                 match self {\n-                    OptExpr(expr) => OptExpr(expr.and_then(|expr| folder.fold_opt_expr(expr))),\n-                    $($( $kind(ast) => $kind(folder.$fold(ast)), )*)*\n-                    $($( $kind(ast) => {\n-                        $kind(ast.into_iter().flat_map(|ast| folder.$fold_elt(ast)).collect())\n-                    }, )*)*\n+                    AstFragment::OptExpr(expr) =>\n+                        AstFragment::OptExpr(expr.and_then(|expr| folder.fold_opt_expr(expr))),\n+                    $($(AstFragment::$Kind(ast) =>\n+                        AstFragment::$Kind(folder.$fold_ast(ast)),)?)*\n+                    $($(AstFragment::$Kind(ast) =>\n+                        AstFragment::$Kind(ast.into_iter()\n+                                              .flat_map(|ast| folder.$fold_ast_elt(ast))\n+                                              .collect()),)?)*\n                 }\n             }\n \n             pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n                 match *self {\n-                    Expansion::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n-                    Expansion::OptExpr(None) => {}\n-                    $($( Expansion::$kind(ref ast) => visitor.$visit(ast), )*)*\n-                    $($( Expansion::$kind(ref ast) => for ast in &ast[..] {\n-                        visitor.$visit_elt(ast);\n-                    }, )*)*\n+                    AstFragment::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n+                    AstFragment::OptExpr(None) => {}\n+                    $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)?)*\n+                    $($(AstFragment::$Kind(ref ast) => for ast_elt in &ast[..] {\n+                        visitor.$visit_ast_elt(ast_elt);\n+                    })?)*\n                 }\n             }\n         }\n \n         impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n             fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-                self.expand(Expansion::OptExpr(Some(expr))).make_opt_expr()\n+                self.expand_fragment(AstFragment::OptExpr(Some(expr))).make_opt_expr()\n             }\n-            $($(fn $fold(&mut self, node: $ty) -> $ty {\n-                self.expand(Expansion::$kind(node)).$make()\n-            })*)*\n-            $($(fn $fold_elt(&mut self, node: $ty_elt) -> $ty {\n-                self.expand(Expansion::$kind(SmallVector::one(node))).$make()\n-            })*)*\n+            $($(fn $fold_ast(&mut self, ast: $AstTy) -> $AstTy {\n+                self.expand_fragment(AstFragment::$Kind(ast)).$make_ast()\n+            })?)*\n+            $($(fn $fold_ast_elt(&mut self, ast_elt: <$AstTy as IntoIterator>::Item) -> $AstTy {\n+                self.expand_fragment(AstFragment::$Kind(SmallVector::one(ast_elt))).$make_ast()\n+            })?)*\n         }\n \n         impl<'a> MacResult for ::ext::tt::macro_rules::ParserAnyMacro<'a> {\n-            $(fn $make(self: Box<::ext::tt::macro_rules::ParserAnyMacro<'a>>) -> Option<$ty> {\n-                Some(self.make(ExpansionKind::$kind).$make())\n+            $(fn $make_ast(self: Box<::ext::tt::macro_rules::ParserAnyMacro<'a>>)\n+                           -> Option<$AstTy> {\n+                Some(self.make(AstFragmentKind::$Kind).$make_ast())\n             })*\n         }\n     }\n }\n \n-expansions! {\n-    Expr: P<ast::Expr> [], \"expression\", .make_expr, .fold_expr, .visit_expr;\n-    Pat: P<ast::Pat>   [], \"pattern\",    .make_pat,  .fold_pat,  .visit_pat;\n-    Ty: P<ast::Ty>     [], \"type\",       .make_ty,   .fold_ty,   .visit_ty;\n-    Stmts: SmallVector<ast::Stmt> [SmallVector, ast::Stmt],\n-        \"statement\",  .make_stmts,       lift .fold_stmt, lift .visit_stmt;\n-    Items: SmallVector<P<ast::Item>> [SmallVector, P<ast::Item>],\n-        \"item\",       .make_items,       lift .fold_item, lift .visit_item;\n-    TraitItems: SmallVector<ast::TraitItem> [SmallVector, ast::TraitItem],\n-        \"trait item\", .make_trait_items, lift .fold_trait_item, lift .visit_trait_item;\n-    ImplItems: SmallVector<ast::ImplItem> [SmallVector, ast::ImplItem],\n-        \"impl item\",  .make_impl_items,  lift .fold_impl_item,  lift .visit_impl_item;\n-    ForeignItems: SmallVector<ast::ForeignItem> [SmallVector, ast::ForeignItem],\n-        \"foreign item\", .make_foreign_items, lift .fold_foreign_item, lift .visit_foreign_item;\n+ast_fragments! {\n+    Expr(P<ast::Expr>) { \"expression\"; one fn fold_expr; fn visit_expr; fn make_expr; }\n+    Pat(P<ast::Pat>) { \"pattern\"; one fn fold_pat; fn visit_pat; fn make_pat; }\n+    Ty(P<ast::Ty>) { \"type\"; one fn fold_ty; fn visit_ty; fn make_ty; }\n+    Stmts(SmallVector<ast::Stmt>) { \"statement\"; many fn fold_stmt; fn visit_stmt; fn make_stmts; }\n+    Items(SmallVector<P<ast::Item>>) { \"item\"; many fn fold_item; fn visit_item; fn make_items; }\n+    TraitItems(SmallVector<ast::TraitItem>) {\n+        \"trait item\"; many fn fold_trait_item; fn visit_trait_item; fn make_trait_items;\n+    }\n+    ImplItems(SmallVector<ast::ImplItem>) {\n+        \"impl item\"; many fn fold_impl_item; fn visit_impl_item; fn make_impl_items;\n+    }\n+    ForeignItems(SmallVector<ast::ForeignItem>) {\n+        \"foreign item\"; many fn fold_foreign_item; fn visit_foreign_item; fn make_foreign_items;\n+    }\n }\n \n-impl ExpansionKind {\n-    fn dummy(self, span: Span) -> Option<Expansion> {\n+impl AstFragmentKind {\n+    fn dummy(self, span: Span) -> Option<AstFragment> {\n         self.make_from(DummyResult::any(span))\n     }\n \n-    fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I) -> Expansion {\n+    fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I)\n+                                                                     -> AstFragment {\n         let mut items = items.into_iter();\n         match self {\n-            ExpansionKind::Items =>\n-                Expansion::Items(items.map(Annotatable::expect_item).collect()),\n-            ExpansionKind::ImplItems =>\n-                Expansion::ImplItems(items.map(Annotatable::expect_impl_item).collect()),\n-            ExpansionKind::TraitItems =>\n-                Expansion::TraitItems(items.map(Annotatable::expect_trait_item).collect()),\n-            ExpansionKind::ForeignItems =>\n-                Expansion::ForeignItems(items.map(Annotatable::expect_foreign_item).collect()),\n-            ExpansionKind::Stmts => Expansion::Stmts(items.map(Annotatable::expect_stmt).collect()),\n-            ExpansionKind::Expr => Expansion::Expr(\n+            AstFragmentKind::Items =>\n+                AstFragment::Items(items.map(Annotatable::expect_item).collect()),\n+            AstFragmentKind::ImplItems =>\n+                AstFragment::ImplItems(items.map(Annotatable::expect_impl_item).collect()),\n+            AstFragmentKind::TraitItems =>\n+                AstFragment::TraitItems(items.map(Annotatable::expect_trait_item).collect()),\n+            AstFragmentKind::ForeignItems =>\n+                AstFragment::ForeignItems(items.map(Annotatable::expect_foreign_item).collect()),\n+            AstFragmentKind::Stmts =>\n+                AstFragment::Stmts(items.map(Annotatable::expect_stmt).collect()),\n+            AstFragmentKind::Expr => AstFragment::Expr(\n                 items.next().expect(\"expected exactly one expression\").expect_expr()\n             ),\n-            ExpansionKind::OptExpr =>\n-                Expansion::OptExpr(items.next().map(Annotatable::expect_expr)),\n-            ExpansionKind::Pat | ExpansionKind::Ty =>\n+            AstFragmentKind::OptExpr =>\n+                AstFragment::OptExpr(items.next().map(Annotatable::expect_expr)),\n+            AstFragmentKind::Pat | AstFragmentKind::Ty =>\n                 panic!(\"patterns and types aren't annotatable\"),\n         }\n     }\n@@ -187,7 +210,7 @@ fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n \n pub struct Invocation {\n     pub kind: InvocationKind,\n-    expansion_kind: ExpansionKind,\n+    fragment_kind: AstFragmentKind,\n     pub expansion_data: ExpansionData,\n }\n \n@@ -244,7 +267,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         let orig_mod_span = krate.module.inner;\n \n-        let krate_item = Expansion::Items(SmallVector::one(P(ast::Item {\n+        let krate_item = AstFragment::Items(SmallVector::one(P(ast::Item {\n             attrs: krate.attrs,\n             span: krate.span,\n             node: ast::ItemKind::Mod(krate.module),\n@@ -254,7 +277,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             tokens: None,\n         })));\n \n-        match self.expand(krate_item).make_items().pop().map(P::into_inner) {\n+        match self.expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n             Some(ast::Item { attrs, node: ast::ItemKind::Mod(module), .. }) => {\n                 krate.attrs = attrs;\n                 krate.module = module;\n@@ -273,16 +296,25 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         krate\n     }\n \n-    // Fully expand all the invocations in `expansion`.\n-    fn expand(&mut self, expansion: Expansion) -> Expansion {\n+    // Fully expand all macro invocations in this AST fragment.\n+    fn expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n         self.cx.current_expansion.depth = 0;\n \n-        let (expansion, mut invocations) = self.collect_invocations(expansion, &[]);\n+        // Collect all macro invocations and replace them with placeholders.\n+        let (fragment_with_placeholders, mut invocations)\n+            = self.collect_invocations(input_fragment, &[]);\n+\n+        // Optimization: if we resolve all imports now,\n+        // we'll be able to immediately resolve most of imported macros.\n         self.resolve_imports();\n-        invocations.reverse();\n \n-        let mut expansions = Vec::new();\n+        // Resolve paths in all invocations and produce ouput expanded fragments for them, but\n+        // do not insert them into our input AST fragment yet, only store in `expanded_fragments`.\n+        // The output fragments also go through expansion recursively until no invocations are left.\n+        // Unresolved macros produce dummy outputs as a recovery measure.\n+        invocations.reverse();\n+        let mut expanded_fragments = Vec::new();\n         let mut derives = HashMap::new();\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n@@ -314,11 +346,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             self.cx.current_expansion.mark = scope;\n             // FIXME(jseyfried): Refactor out the following logic\n-            let (expansion, new_invocations) = if let Some(ext) = ext {\n+            let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n                 if let Some(ext) = ext {\n-                    let dummy = invoc.expansion_kind.dummy(invoc.span()).unwrap();\n-                    let expansion = self.expand_invoc(invoc, &*ext).unwrap_or(dummy);\n-                    self.collect_invocations(expansion, &[])\n+                    let dummy = invoc.fragment_kind.dummy(invoc.span()).unwrap();\n+                    let fragment = self.expand_invoc(invoc, &*ext).unwrap_or(dummy);\n+                    self.collect_invocations(fragment, &[])\n                 } else if let InvocationKind::Attr { attr: None, traits, item } = invoc.kind {\n                     if !item.derive_allowed() {\n                         let attr = attr::find_by_name(item.attrs(), \"derive\")\n@@ -359,43 +391,44 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         };\n                         invocations.push(Invocation {\n                             kind: InvocationKind::Derive { path: path.clone(), item: item },\n-                            expansion_kind: invoc.expansion_kind,\n+                            fragment_kind: invoc.fragment_kind,\n                             expansion_data: ExpansionData {\n                                 mark,\n                                 ..invoc.expansion_data.clone()\n                             },\n                         });\n                     }\n-                    let expansion = invoc.expansion_kind\n+                    let fragment = invoc.fragment_kind\n                         .expect_from_annotatables(::std::iter::once(item_with_markers));\n-                    self.collect_invocations(expansion, derives)\n+                    self.collect_invocations(fragment, derives)\n                 } else {\n                     unreachable!()\n                 }\n             } else {\n-                self.collect_invocations(invoc.expansion_kind.dummy(invoc.span()).unwrap(), &[])\n+                self.collect_invocations(invoc.fragment_kind.dummy(invoc.span()).unwrap(), &[])\n             };\n \n-            if expansions.len() < depth {\n-                expansions.push(Vec::new());\n+            if expanded_fragments.len() < depth {\n+                expanded_fragments.push(Vec::new());\n             }\n-            expansions[depth - 1].push((mark, expansion));\n+            expanded_fragments[depth - 1].push((mark, expanded_fragment));\n             if !self.cx.ecfg.single_step {\n                 invocations.extend(new_invocations.into_iter().rev());\n             }\n         }\n \n         self.cx.current_expansion = orig_expansion_data;\n \n+        // Finally incorporate all the expanded macros into the input AST fragment.\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n-        while let Some(expansions) = expansions.pop() {\n-            for (mark, expansion) in expansions.into_iter().rev() {\n+        while let Some(expanded_fragments) = expanded_fragments.pop() {\n+            for (mark, expanded_fragment) in expanded_fragments.into_iter().rev() {\n                 let derives = derives.remove(&mark).unwrap_or_else(Vec::new);\n-                placeholder_expander.add(NodeId::placeholder_from_mark(mark), expansion, derives);\n+                placeholder_expander.add(NodeId::placeholder_from_mark(mark),\n+                                         expanded_fragment, derives);\n             }\n         }\n-\n-        expansion.fold_with(&mut placeholder_expander)\n+        fragment_with_placeholders.fold_with(&mut placeholder_expander)\n     }\n \n     fn resolve_imports(&mut self) {\n@@ -406,9 +439,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn collect_invocations(&mut self, expansion: Expansion, derives: &[Mark])\n-                           -> (Expansion, Vec<Invocation>) {\n-        let result = {\n+    /// Collect all macro invocations reachable at this time in this AST fragment, and replace\n+    /// them with \"placeholders\" - dummy macro invocations with specially crafted `NodeId`s.\n+    /// Then call into resolver that builds a skeleton (\"reduced graph\") of the fragment and\n+    /// prepares data for resolving paths of macro invocations.\n+    fn collect_invocations(&mut self, fragment: AstFragment, derives: &[Mark])\n+                           -> (AstFragment, Vec<Invocation>) {\n+        let (fragment_with_placeholders, invocations) = {\n             let mut collector = InvocationCollector {\n                 cfg: StripUnconfigured {\n                     should_test: self.cx.ecfg.should_test,\n@@ -419,17 +456,18 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 invocations: Vec::new(),\n                 monotonic: self.monotonic,\n             };\n-            (expansion.fold_with(&mut collector), collector.invocations)\n+            (fragment.fold_with(&mut collector), collector.invocations)\n         };\n \n         if self.monotonic {\n             let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n             let mark = self.cx.current_expansion.mark;\n-            self.cx.resolver.visit_expansion(mark, &result.0, derives);\n+            self.cx.resolver.visit_ast_fragment_with_placeholders(mark, &fragment_with_placeholders,\n+                                                                  derives);\n             self.cx.resolve_err_count += self.cx.parse_sess.span_diagnostic.err_count() - err_count;\n         }\n \n-        result\n+        (fragment_with_placeholders, invocations)\n     }\n \n     fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n@@ -464,7 +502,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> Option<Expansion> {\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> Option<AstFragment> {\n         let result = match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext)?,\n             InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext)?,\n@@ -476,7 +514,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n             let mut err = self.cx.struct_span_err(info.call_site,\n                 &format!(\"recursion limit reached while expanding the macro `{}`\",\n-                         info.callee.name()));\n+                         info.format.name()));\n             err.help(&format!(\n                 \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n                 suggested_limit));\n@@ -491,8 +529,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn expand_attr_invoc(&mut self,\n                          invoc: Invocation,\n                          ext: &SyntaxExtension)\n-                         -> Option<Expansion> {\n-        let Invocation { expansion_kind: kind, .. } = invoc;\n+                         -> Option<AstFragment> {\n         let (attr, item) = match invoc.kind {\n             InvocationKind::Attr { attr, item, .. } => (attr?, item),\n             _ => unreachable!(),\n@@ -501,29 +538,27 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         attr::mark_used(&attr);\n         invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n             call_site: attr.span,\n-            callee: NameAndSpan {\n-                format: MacroAttribute(Symbol::intern(&format!(\"{}\", attr.path))),\n-                span: None,\n-                allow_internal_unstable: false,\n-                allow_internal_unsafe: false,\n-                edition: ext.edition(),\n-            }\n+            def_site: None,\n+            format: MacroAttribute(Symbol::intern(&format!(\"{}\", attr.path))),\n+            allow_internal_unstable: false,\n+            allow_internal_unsafe: false,\n+            edition: ext.edition(),\n         });\n \n         match *ext {\n             MultiModifier(ref mac) => {\n                 let meta = attr.parse_meta(self.cx.parse_sess)\n                                .map_err(|mut e| { e.emit(); }).ok()?;\n                 let item = mac.expand(self.cx, attr.span, &meta, item);\n-                Some(kind.expect_from_annotatables(item))\n+                Some(invoc.fragment_kind.expect_from_annotatables(item))\n             }\n             MultiDecorator(ref mac) => {\n                 let mut items = Vec::new();\n                 let meta = attr.parse_meta(self.cx.parse_sess)\n                                .expect(\"derive meta should already have been parsed\");\n                 mac.expand(self.cx, attr.span, &meta, &item, &mut |item| items.push(item));\n                 items.push(item);\n-                Some(kind.expect_from_annotatables(items))\n+                Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             AttrProcMacro(ref mac, ..) => {\n                 self.gate_proc_macro_attr_item(attr.span, &item);\n@@ -537,20 +572,21 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 })).into();\n                 let input = self.extract_proc_macro_attr_input(attr.tokens, attr.span);\n                 let tok_result = mac.expand(self.cx, attr.span, input, item_tok);\n-                let res = self.parse_expansion(tok_result, kind, &attr.path, attr.span);\n+                let res = self.parse_ast_fragment(tok_result, invoc.fragment_kind,\n+                                                  &attr.path, attr.span);\n                 self.gate_proc_macro_expansion(attr.span, &res);\n                 res\n             }\n             ProcMacroDerive(..) | BuiltinDerive(..) => {\n                 self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", attr.path));\n                 self.cx.trace_macros_diag();\n-                kind.dummy(attr.span)\n+                invoc.fragment_kind.dummy(attr.span)\n             }\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used in attributes\", attr.path);\n                 self.cx.span_err(attr.span, msg);\n                 self.cx.trace_macros_diag();\n-                kind.dummy(attr.span)\n+                invoc.fragment_kind.dummy(attr.span)\n             }\n         }\n     }\n@@ -598,16 +634,16 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         );\n     }\n \n-    fn gate_proc_macro_expansion(&self, span: Span, expansion: &Option<Expansion>) {\n+    fn gate_proc_macro_expansion(&self, span: Span, fragment: &Option<AstFragment>) {\n         if self.cx.ecfg.proc_macro_gen() {\n             return\n         }\n-        let expansion = match expansion {\n-            Some(expansion) => expansion,\n+        let fragment = match fragment {\n+            Some(fragment) => fragment,\n             None => return,\n         };\n \n-        expansion.visit_with(&mut DisallowModules {\n+        fragment.visit_with(&mut DisallowModules {\n             span,\n             parse_sess: self.cx.parse_sess,\n         });\n@@ -642,12 +678,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    /// Expand a macro invocation. Returns the result of expansion.\n+    /// Expand a macro invocation. Returns the resulting expanded AST fragment.\n     fn expand_bang_invoc(&mut self,\n                          invoc: Invocation,\n                          ext: &SyntaxExtension)\n-                         -> Option<Expansion> {\n-        let (mark, kind) = (invoc.expansion_data.mark, invoc.expansion_kind);\n+                         -> Option<AstFragment> {\n+        let (mark, kind) = (invoc.expansion_data.mark, invoc.fragment_kind);\n         let (mac, ident, span) = match invoc.kind {\n             InvocationKind::Bang { mac, ident, span } => (mac, ident, span),\n             _ => unreachable!(),\n@@ -689,13 +725,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n             mark.set_expn_info(ExpnInfo {\n                 call_site: span,\n-                callee: NameAndSpan {\n-                    format: macro_bang_format(path),\n-                    span: def_site_span,\n-                    allow_internal_unstable,\n-                    allow_internal_unsafe,\n-                    edition,\n-                },\n+                def_site: def_site_span,\n+                format: macro_bang_format(path),\n+                allow_internal_unstable,\n+                allow_internal_unsafe,\n+                edition,\n             });\n             Ok(())\n         };\n@@ -739,13 +773,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 } else {\n                     invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n                         call_site: span,\n-                        callee: NameAndSpan {\n-                            format: macro_bang_format(path),\n-                            span: tt_span,\n-                            allow_internal_unstable,\n-                            allow_internal_unsafe: false,\n-                            edition: hygiene::default_edition(),\n-                        }\n+                        def_site: tt_span,\n+                        format: macro_bang_format(path),\n+                        allow_internal_unstable,\n+                        allow_internal_unsafe: false,\n+                        edition: hygiene::default_edition(),\n                     });\n \n                     let input: Vec<_> = mac.node.stream().into_trees().collect();\n@@ -766,7 +798,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 kind.dummy(span)\n             }\n \n-            ProcMacro(ref expandfun, edition) => {\n+            ProcMacro(ref expandfun, allow_internal_unstable, edition) => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n@@ -777,20 +809,18 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.gate_proc_macro_expansion_kind(span, kind);\n                     invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n                         call_site: span,\n-                        callee: NameAndSpan {\n-                            format: macro_bang_format(path),\n-                            // FIXME procedural macros do not have proper span info\n-                            // yet, when they do, we should use it here.\n-                            span: None,\n-                            // FIXME probably want to follow macro_rules macros here.\n-                            allow_internal_unstable: false,\n-                            allow_internal_unsafe: false,\n-                            edition,\n-                        },\n+                        // FIXME procedural macros do not have proper span info\n+                        // yet, when they do, we should use it here.\n+                        def_site: None,\n+                        format: macro_bang_format(path),\n+                        // FIXME probably want to follow macro_rules macros here.\n+                        allow_internal_unstable,\n+                        allow_internal_unsafe: false,\n+                        edition,\n                     });\n \n                     let tok_result = expandfun.expand(self.cx, span, mac.node.stream());\n-                    let result = self.parse_expansion(tok_result, kind, path, span);\n+                    let result = self.parse_ast_fragment(tok_result, kind, path, span);\n                     self.gate_proc_macro_expansion(span, &result);\n                     result\n                 }\n@@ -808,17 +838,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn gate_proc_macro_expansion_kind(&self, span: Span, kind: ExpansionKind) {\n+    fn gate_proc_macro_expansion_kind(&self, span: Span, kind: AstFragmentKind) {\n         let kind = match kind {\n-            ExpansionKind::Expr => \"expressions\",\n-            ExpansionKind::OptExpr => \"expressions\",\n-            ExpansionKind::Pat => \"patterns\",\n-            ExpansionKind::Ty => \"types\",\n-            ExpansionKind::Stmts => \"statements\",\n-            ExpansionKind::Items => return,\n-            ExpansionKind::TraitItems => return,\n-            ExpansionKind::ImplItems => return,\n-            ExpansionKind::ForeignItems => return,\n+            AstFragmentKind::Expr => \"expressions\",\n+            AstFragmentKind::OptExpr => \"expressions\",\n+            AstFragmentKind::Pat => \"patterns\",\n+            AstFragmentKind::Ty => \"types\",\n+            AstFragmentKind::Stmts => \"statements\",\n+            AstFragmentKind::Items => return,\n+            AstFragmentKind::TraitItems => return,\n+            AstFragmentKind::ImplItems => return,\n+            AstFragmentKind::ForeignItems => return,\n         };\n         if self.cx.ecfg.proc_macro_non_items() {\n             return\n@@ -832,12 +862,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         );\n     }\n \n-    /// Expand a derive invocation. Returns the result of expansion.\n+    /// Expand a derive invocation. Returns the resulting expanded AST fragment.\n     fn expand_derive_invoc(&mut self,\n                            invoc: Invocation,\n                            ext: &SyntaxExtension)\n-                           -> Option<Expansion> {\n-        let Invocation { expansion_kind: kind, .. } = invoc;\n+                           -> Option<AstFragment> {\n         let (path, item) = match invoc.kind {\n             InvocationKind::Derive { path, item } => (path, item),\n             _ => unreachable!(),\n@@ -857,13 +886,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         let mut expn_info = ExpnInfo {\n             call_site: span,\n-            callee: NameAndSpan {\n-                format: MacroAttribute(pretty_name),\n-                span: None,\n-                allow_internal_unstable: false,\n-                allow_internal_unsafe: false,\n-                edition: ext.edition(),\n-            }\n+            def_site: None,\n+            format: MacroAttribute(pretty_name),\n+            allow_internal_unstable: false,\n+            allow_internal_unsafe: false,\n+            edition: ext.edition(),\n         };\n \n         match *ext {\n@@ -876,36 +903,36 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     node: ast::MetaItemKind::Word,\n                 };\n                 let items = ext.expand(self.cx, span, &dummy, item);\n-                Some(kind.expect_from_annotatables(items))\n+                Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             BuiltinDerive(func) => {\n-                expn_info.callee.allow_internal_unstable = true;\n+                expn_info.allow_internal_unstable = true;\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let mut items = Vec::new();\n                 func(self.cx, span, &attr.meta()?, &item, &mut |a| items.push(a));\n-                Some(kind.expect_from_annotatables(items))\n+                Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n                 self.cx.span_err(span, msg);\n                 self.cx.trace_macros_diag();\n-                kind.dummy(span)\n+                invoc.fragment_kind.dummy(span)\n             }\n         }\n     }\n \n-    fn parse_expansion(&mut self,\n-                       toks: TokenStream,\n-                       kind: ExpansionKind,\n-                       path: &Path,\n-                       span: Span)\n-                       -> Option<Expansion> {\n+    fn parse_ast_fragment(&mut self,\n+                          toks: TokenStream,\n+                          kind: AstFragmentKind,\n+                          path: &Path,\n+                          span: Span)\n+                          -> Option<AstFragment> {\n         let mut parser = self.cx.new_parser_from_tts(&toks.into_trees().collect::<Vec<_>>());\n-        match parser.parse_expansion(kind, false) {\n-            Ok(expansion) => {\n+        match parser.parse_ast_fragment(kind, false) {\n+            Ok(fragment) => {\n                 parser.ensure_complete_parse(path, kind.name(), span);\n-                Some(expansion)\n+                Some(fragment)\n             }\n             Err(mut err) => {\n                 err.set_span(span);\n@@ -918,40 +945,40 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n }\n \n impl<'a> Parser<'a> {\n-    pub fn parse_expansion(&mut self, kind: ExpansionKind, macro_legacy_warnings: bool)\n-                           -> PResult<'a, Expansion> {\n+    pub fn parse_ast_fragment(&mut self, kind: AstFragmentKind, macro_legacy_warnings: bool)\n+                              -> PResult<'a, AstFragment> {\n         Ok(match kind {\n-            ExpansionKind::Items => {\n+            AstFragmentKind::Items => {\n                 let mut items = SmallVector::new();\n                 while let Some(item) = self.parse_item()? {\n                     items.push(item);\n                 }\n-                Expansion::Items(items)\n+                AstFragment::Items(items)\n             }\n-            ExpansionKind::TraitItems => {\n+            AstFragmentKind::TraitItems => {\n                 let mut items = SmallVector::new();\n                 while self.token != token::Eof {\n                     items.push(self.parse_trait_item(&mut false)?);\n                 }\n-                Expansion::TraitItems(items)\n+                AstFragment::TraitItems(items)\n             }\n-            ExpansionKind::ImplItems => {\n+            AstFragmentKind::ImplItems => {\n                 let mut items = SmallVector::new();\n                 while self.token != token::Eof {\n                     items.push(self.parse_impl_item(&mut false)?);\n                 }\n-                Expansion::ImplItems(items)\n+                AstFragment::ImplItems(items)\n             }\n-            ExpansionKind::ForeignItems => {\n+            AstFragmentKind::ForeignItems => {\n                 let mut items = SmallVector::new();\n                 while self.token != token::Eof {\n                     if let Some(item) = self.parse_foreign_item()? {\n                         items.push(item);\n                     }\n                 }\n-                Expansion::ForeignItems(items)\n+                AstFragment::ForeignItems(items)\n             }\n-            ExpansionKind::Stmts => {\n+            AstFragmentKind::Stmts => {\n                 let mut stmts = SmallVector::new();\n                 while self.token != token::Eof &&\n                       // won't make progress on a `}`\n@@ -960,18 +987,18 @@ impl<'a> Parser<'a> {\n                         stmts.push(stmt);\n                     }\n                 }\n-                Expansion::Stmts(stmts)\n+                AstFragment::Stmts(stmts)\n             }\n-            ExpansionKind::Expr => Expansion::Expr(self.parse_expr()?),\n-            ExpansionKind::OptExpr => {\n+            AstFragmentKind::Expr => AstFragment::Expr(self.parse_expr()?),\n+            AstFragmentKind::OptExpr => {\n                 if self.token != token::Eof {\n-                    Expansion::OptExpr(Some(self.parse_expr()?))\n+                    AstFragment::OptExpr(Some(self.parse_expr()?))\n                 } else {\n-                    Expansion::OptExpr(None)\n+                    AstFragment::OptExpr(None)\n                 }\n             },\n-            ExpansionKind::Ty => Expansion::Ty(self.parse_ty()?),\n-            ExpansionKind::Pat => Expansion::Pat(self.parse_pat()?),\n+            AstFragmentKind::Ty => AstFragment::Ty(self.parse_ty()?),\n+            AstFragmentKind::Pat => AstFragment::Pat(self.parse_pat()?),\n         })\n     }\n \n@@ -998,30 +1025,30 @@ struct InvocationCollector<'a, 'b: 'a> {\n }\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n-    fn collect(&mut self, expansion_kind: ExpansionKind, kind: InvocationKind) -> Expansion {\n+    fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n         let mark = Mark::fresh(self.cx.current_expansion.mark);\n         self.invocations.push(Invocation {\n             kind,\n-            expansion_kind,\n+            fragment_kind,\n             expansion_data: ExpansionData {\n                 mark,\n                 depth: self.cx.current_expansion.depth + 1,\n                 ..self.cx.current_expansion.clone()\n             },\n         });\n-        placeholder(expansion_kind, NodeId::placeholder_from_mark(mark))\n+        placeholder(fragment_kind, NodeId::placeholder_from_mark(mark))\n     }\n \n-    fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: ExpansionKind) -> Expansion {\n+    fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: AstFragmentKind) -> AstFragment {\n         self.collect(kind, InvocationKind::Bang { mac: mac, ident: None, span: span })\n     }\n \n     fn collect_attr(&mut self,\n                     attr: Option<ast::Attribute>,\n                     traits: Vec<Path>,\n                     item: Annotatable,\n-                    kind: ExpansionKind)\n-                    -> Expansion {\n+                    kind: AstFragmentKind)\n+                    -> AstFragment {\n         self.collect(kind, InvocationKind::Attr { attr, traits, item })\n     }\n \n@@ -1119,14 +1146,14 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             // expansion will eat the attribute so it won't error later\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n-            // ExpansionKind::Expr requires the macro to emit an expression\n-            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)), ExpansionKind::Expr)\n-                .make_expr();\n+            // AstFragmentKind::Expr requires the macro to emit an expression\n+            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n+                                     AstFragmentKind::Expr).make_expr();\n         }\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n             self.check_attributes(&expr.attrs);\n-            self.collect_bang(mac, expr.span, ExpansionKind::Expr).make_expr()\n+            self.collect_bang(mac, expr.span, AstFragmentKind::Expr).make_expr()\n         } else {\n             P(noop_fold_expr(expr, self))\n         }\n@@ -1143,13 +1170,13 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n             return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     ExpansionKind::OptExpr)\n+                                     AstFragmentKind::OptExpr)\n                 .make_opt_expr();\n         }\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n             self.check_attributes(&expr.attrs);\n-            self.collect_bang(mac, expr.span, ExpansionKind::OptExpr).make_opt_expr()\n+            self.collect_bang(mac, expr.span, AstFragmentKind::OptExpr).make_opt_expr()\n         } else {\n             Some(P(noop_fold_expr(expr, self)))\n         }\n@@ -1163,7 +1190,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         }\n \n         pat.and_then(|pat| match pat.node {\n-            PatKind::Mac(mac) => self.collect_bang(mac, pat.span, ExpansionKind::Pat).make_pat(),\n+            PatKind::Mac(mac) => self.collect_bang(mac, pat.span, AstFragmentKind::Pat).make_pat(),\n             _ => unreachable!(),\n         })\n     }\n@@ -1187,7 +1214,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n             if attr.is_some() || !derives.is_empty() {\n                 return self.collect_attr(attr, derives,\n-                                         Annotatable::Stmt(P(stmt_)), ExpansionKind::Stmts)\n+                                         Annotatable::Stmt(P(stmt_)), AstFragmentKind::Stmts)\n                     .make_stmts();\n             }\n \n@@ -1197,7 +1224,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         if let StmtKind::Mac(mac) = stmt.node {\n             let (mac, style, attrs) = mac.into_inner();\n             self.check_attributes(&attrs);\n-            let mut placeholder = self.collect_bang(mac, stmt.span, ExpansionKind::Stmts)\n+            let mut placeholder = self.collect_bang(mac, stmt.span, AstFragmentKind::Stmts)\n                                         .make_stmts();\n \n             // If this is a macro invocation with a semicolon, then apply that\n@@ -1233,15 +1260,15 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         let (attr, traits, mut item) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             let item = Annotatable::Item(item);\n-            return self.collect_attr(attr, traits, item, ExpansionKind::Items).make_items();\n+            return self.collect_attr(attr, traits, item, AstFragmentKind::Items).make_items();\n         }\n \n         match item.node {\n             ast::ItemKind::Mac(..) => {\n                 self.check_attributes(&item.attrs);\n                 item.and_then(|item| match item.node {\n                     ItemKind::Mac(mac) => {\n-                        self.collect(ExpansionKind::Items, InvocationKind::Bang {\n+                        self.collect(AstFragmentKind::Items, InvocationKind::Bang {\n                             mac,\n                             ident: Some(item.ident),\n                             span: item.span,\n@@ -1317,15 +1344,15 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         let (attr, traits, item) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             let item = Annotatable::TraitItem(P(item));\n-            return self.collect_attr(attr, traits, item, ExpansionKind::TraitItems)\n+            return self.collect_attr(attr, traits, item, AstFragmentKind::TraitItems)\n                 .make_trait_items()\n         }\n \n         match item.node {\n             ast::TraitItemKind::Macro(mac) => {\n                 let ast::TraitItem { attrs, span, .. } = item;\n                 self.check_attributes(&attrs);\n-                self.collect_bang(mac, span, ExpansionKind::TraitItems).make_trait_items()\n+                self.collect_bang(mac, span, AstFragmentKind::TraitItems).make_trait_items()\n             }\n             _ => fold::noop_fold_trait_item(item, self),\n         }\n@@ -1337,15 +1364,15 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         let (attr, traits, item) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             let item = Annotatable::ImplItem(P(item));\n-            return self.collect_attr(attr, traits, item, ExpansionKind::ImplItems)\n+            return self.collect_attr(attr, traits, item, AstFragmentKind::ImplItems)\n                 .make_impl_items();\n         }\n \n         match item.node {\n             ast::ImplItemKind::Macro(mac) => {\n                 let ast::ImplItem { attrs, span, .. } = item;\n                 self.check_attributes(&attrs);\n-                self.collect_bang(mac, span, ExpansionKind::ImplItems).make_impl_items()\n+                self.collect_bang(mac, span, AstFragmentKind::ImplItems).make_impl_items()\n             }\n             _ => fold::noop_fold_impl_item(item, self),\n         }\n@@ -1358,7 +1385,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         };\n \n         match ty.node {\n-            ast::TyKind::Mac(mac) => self.collect_bang(mac, ty.span, ExpansionKind::Ty).make_ty(),\n+            ast::TyKind::Mac(mac) => self.collect_bang(mac, ty.span, AstFragmentKind::Ty).make_ty(),\n             _ => unreachable!(),\n         }\n     }\n@@ -1386,7 +1413,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             }\n \n             let item = Annotatable::ForeignItem(P(foreign_item));\n-            return self.collect_attr(attr, traits, item, ExpansionKind::ForeignItems)\n+            return self.collect_attr(attr, traits, item, AstFragmentKind::ForeignItems)\n                 .make_foreign_items();\n         }\n \n@@ -1398,7 +1425,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                                  GateIssue::Language, explain);\n             }\n \n-            return self.collect_bang(mac, foreign_item.span, ExpansionKind::ForeignItems)\n+            return self.collect_bang(mac, foreign_item.span, AstFragmentKind::ForeignItems)\n                 .make_foreign_items();\n         }\n \n@@ -1569,11 +1596,6 @@ impl<'feat> ExpansionConfig<'feat> {\n pub struct Marker(pub Mark);\n \n impl Folder for Marker {\n-    fn fold_ident(&mut self, mut ident: Ident) -> Ident {\n-        ident.span = ident.span.apply_mark(self.0);\n-        ident\n-    }\n-\n     fn new_span(&mut self, span: Span) -> Span {\n         span.apply_mark(self.0)\n     }"}, {"sha": "968cf508edaaae102ff17ce5566b012204f702b5", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -11,7 +11,7 @@\n use ast::{self, NodeId};\n use codemap::{DUMMY_SP, dummy_spanned};\n use ext::base::ExtCtxt;\n-use ext::expand::{Expansion, ExpansionKind};\n+use ext::expand::{AstFragment, AstFragmentKind};\n use ext::hygiene::Mark;\n use tokenstream::TokenStream;\n use fold::*;\n@@ -22,7 +22,7 @@ use util::small_vector::SmallVector;\n \n use std::collections::HashMap;\n \n-pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n+pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n     fn mac_placeholder() -> ast::Mac {\n         dummy_spanned(ast::Mac_ {\n             path: ast::Path { span: DUMMY_SP, segments: Vec::new() },\n@@ -43,43 +43,44 @@ pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     });\n \n     match kind {\n-        ExpansionKind::Expr => Expansion::Expr(expr_placeholder()),\n-        ExpansionKind::OptExpr => Expansion::OptExpr(Some(expr_placeholder())),\n-        ExpansionKind::Items => Expansion::Items(SmallVector::one(P(ast::Item {\n+        AstFragmentKind::Expr => AstFragment::Expr(expr_placeholder()),\n+        AstFragmentKind::OptExpr => AstFragment::OptExpr(Some(expr_placeholder())),\n+        AstFragmentKind::Items => AstFragment::Items(SmallVector::one(P(ast::Item {\n             id, span, ident, vis, attrs,\n             node: ast::ItemKind::Mac(mac_placeholder()),\n             tokens: None,\n         }))),\n-        ExpansionKind::TraitItems => Expansion::TraitItems(SmallVector::one(ast::TraitItem {\n+        AstFragmentKind::TraitItems => AstFragment::TraitItems(SmallVector::one(ast::TraitItem {\n             id, span, ident, attrs, generics,\n             node: ast::TraitItemKind::Macro(mac_placeholder()),\n             tokens: None,\n         })),\n-        ExpansionKind::ImplItems => Expansion::ImplItems(SmallVector::one(ast::ImplItem {\n+        AstFragmentKind::ImplItems => AstFragment::ImplItems(SmallVector::one(ast::ImplItem {\n             id, span, ident, vis, attrs, generics,\n             node: ast::ImplItemKind::Macro(mac_placeholder()),\n             defaultness: ast::Defaultness::Final,\n             tokens: None,\n         })),\n-        ExpansionKind::ForeignItems => Expansion::ForeignItems(SmallVector::one(ast::ForeignItem {\n-            id, span, ident, vis, attrs,\n-            node: ast::ForeignItemKind::Macro(mac_placeholder()),\n-        })),\n-        ExpansionKind::Pat => Expansion::Pat(P(ast::Pat {\n+        AstFragmentKind::ForeignItems =>\n+            AstFragment::ForeignItems(SmallVector::one(ast::ForeignItem {\n+                id, span, ident, vis, attrs,\n+                node: ast::ForeignItemKind::Macro(mac_placeholder()),\n+            })),\n+        AstFragmentKind::Pat => AstFragment::Pat(P(ast::Pat {\n             id, span, node: ast::PatKind::Mac(mac_placeholder()),\n         })),\n-        ExpansionKind::Ty => Expansion::Ty(P(ast::Ty {\n+        AstFragmentKind::Ty => AstFragment::Ty(P(ast::Ty {\n             id, span, node: ast::TyKind::Mac(mac_placeholder()),\n         })),\n-        ExpansionKind::Stmts => Expansion::Stmts(SmallVector::one({\n+        AstFragmentKind::Stmts => AstFragment::Stmts(SmallVector::one({\n             let mac = P((mac_placeholder(), ast::MacStmtStyle::Braces, ast::ThinVec::new()));\n             ast::Stmt { id, span, node: ast::StmtKind::Mac(mac) }\n         })),\n     }\n }\n \n pub struct PlaceholderExpander<'a, 'b: 'a> {\n-    expansions: HashMap<ast::NodeId, Expansion>,\n+    expanded_fragments: HashMap<ast::NodeId, AstFragment>,\n     cx: &'a mut ExtCtxt<'b>,\n     monotonic: bool,\n }\n@@ -88,27 +89,27 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n     pub fn new(cx: &'a mut ExtCtxt<'b>, monotonic: bool) -> Self {\n         PlaceholderExpander {\n             cx,\n-            expansions: HashMap::new(),\n+            expanded_fragments: HashMap::new(),\n             monotonic,\n         }\n     }\n \n-    pub fn add(&mut self, id: ast::NodeId, expansion: Expansion, derives: Vec<Mark>) {\n-        let mut expansion = expansion.fold_with(self);\n-        if let Expansion::Items(mut items) = expansion {\n+    pub fn add(&mut self, id: ast::NodeId, fragment: AstFragment, derives: Vec<Mark>) {\n+        let mut fragment = fragment.fold_with(self);\n+        if let AstFragment::Items(mut items) = fragment {\n             for derive in derives {\n                 match self.remove(NodeId::placeholder_from_mark(derive)) {\n-                    Expansion::Items(derived_items) => items.extend(derived_items),\n+                    AstFragment::Items(derived_items) => items.extend(derived_items),\n                     _ => unreachable!(),\n                 }\n             }\n-            expansion = Expansion::Items(items);\n+            fragment = AstFragment::Items(items);\n         }\n-        self.expansions.insert(id, expansion);\n+        self.expanded_fragments.insert(id, fragment);\n     }\n \n-    fn remove(&mut self, id: ast::NodeId) -> Expansion {\n-        self.expansions.remove(&id).unwrap()\n+    fn remove(&mut self, id: ast::NodeId) -> AstFragment {\n+        self.expanded_fragments.remove(&id).unwrap()\n     }\n }\n \n@@ -159,18 +160,18 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n     }\n \n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        let (style, mut expansion) = match stmt.node {\n+        let (style, mut stmts) = match stmt.node {\n             ast::StmtKind::Mac(mac) => (mac.1, self.remove(stmt.id).make_stmts()),\n             _ => return noop_fold_stmt(stmt, self),\n         };\n \n         if style == ast::MacStmtStyle::Semicolon {\n-            if let Some(stmt) = expansion.pop() {\n-                expansion.push(stmt.add_trailing_semicolon());\n+            if let Some(stmt) = stmts.pop() {\n+                stmts.push(stmt.add_trailing_semicolon());\n             }\n         }\n \n-        expansion\n+        stmts\n     }\n \n     fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {"}, {"sha": "4ee5357f4766cc1186d36299a0e78f19e2d47d5e", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -13,7 +13,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use edition::Edition;\n use ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n use ext::base::{NormalTT, TTMacroExpander};\n-use ext::expand::{Expansion, ExpansionKind};\n+use ext::expand::{AstFragment, AstFragmentKind};\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n@@ -43,21 +43,21 @@ pub struct ParserAnyMacro<'a> {\n }\n \n impl<'a> ParserAnyMacro<'a> {\n-    pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: ExpansionKind) -> Expansion {\n+    pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro { site_span, macro_ident, ref mut parser } = *self;\n-        let expansion = panictry!(parser.parse_expansion(kind, true));\n+        let fragment = panictry!(parser.parse_ast_fragment(kind, true));\n \n         // We allow semicolons at the end of expressions -- e.g. the semicolon in\n         // `macro_rules! m { () => { panic!(); } }` isn't parsed by `.parse_expr()`,\n         // but `m!()` is allowed in expression positions (c.f. issue #34706).\n-        if kind == ExpansionKind::Expr && parser.token == token::Semi {\n+        if kind == AstFragmentKind::Expr && parser.token == token::Semi {\n             parser.bump();\n         }\n \n         // Make sure we don't have any tokens left to parse so we don't silently drop anything.\n         let path = ast::Path::from_ident(macro_ident.with_span_pos(site_span));\n         parser.ensure_complete_parse(&path, kind.name(), site_span);\n-        expansion\n+        fragment\n     }\n }\n "}, {"sha": "1ace9193dc69dafaf675a0fb9e9c270d6d77a039", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -19,13 +19,14 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(attr(deny(warnings))))]\n \n-#![feature(unicode_internals)]\n-#![feature(rustc_diagnostic_macros)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(const_atomic_usize_new)]\n+#![feature(crate_visibility_modifier)]\n+#![feature(macro_at_most_once_rep)]\n #![feature(rustc_attrs)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(slice_sort_by_cached_key)]\n #![feature(str_escape)]\n-#![feature(crate_visibility_modifier)]\n+#![feature(unicode_internals)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "70c4324a056a0ff62028a7bddf1dcc234b81a1d6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -18,7 +18,7 @@ use util::parser::{self, AssocOp, Fixity};\n use attr;\n use codemap::{self, CodeMap};\n use syntax_pos::{self, BytePos};\n-use syntax_pos::hygiene::{Mark, MarkKind, SyntaxContext};\n+use syntax_pos::hygiene::{Mark, SyntaxContext};\n use parse::token::{self, BinOpToken, Token};\n use parse::lexer::comments;\n use parse::{self, ParseSess};\n@@ -842,7 +842,7 @@ pub trait PrintState<'a> {\n     fn print_dollar_crate(&mut self, mut ctxt: SyntaxContext) -> io::Result<()> {\n         if let Some(mark) = ctxt.adjust(Mark::root()) {\n             // Make a best effort to print something that complies\n-            if mark.kind() == MarkKind::Builtin {\n+            if mark.is_builtin() {\n                 if let Some(name) = std_inject::injected_crate_name() {\n                     self.writer().word(\"::\")?;\n                     self.writer().word(name)?;"}, {"sha": "66e8e0d7a9c6c76e52dcaa0b0b850d62cce71ba9", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -14,7 +14,7 @@ use std::cell::Cell;\n use ext::hygiene::{Mark, SyntaxContext};\n use symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n-use codemap::{ExpnInfo, NameAndSpan, MacroAttribute, dummy_spanned, hygiene, respan};\n+use codemap::{ExpnInfo, MacroAttribute, dummy_spanned, hygiene, respan};\n use ptr::P;\n use tokenstream::TokenStream;\n \n@@ -25,13 +25,11 @@ fn ignored_span(sp: Span) -> Span {\n     let mark = Mark::fresh(Mark::root());\n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n-        callee: NameAndSpan {\n-            format: MacroAttribute(Symbol::intern(\"std_inject\")),\n-            span: None,\n-            allow_internal_unstable: true,\n-            allow_internal_unsafe: false,\n-            edition: hygiene::default_edition(),\n-        }\n+        def_site: None,\n+        format: MacroAttribute(Symbol::intern(\"std_inject\")),\n+        allow_internal_unstable: true,\n+        allow_internal_unsafe: false,\n+        edition: hygiene::default_edition(),\n     });\n     sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n }"}, {"sha": "141fd122ff57b6647cea156804d3da4b15322f8b", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -22,7 +22,7 @@ use std::vec;\n use attr::{self, HasAttrs};\n use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, FileMap, BytePos};\n \n-use codemap::{self, CodeMap, ExpnInfo, NameAndSpan, MacroAttribute, dummy_spanned};\n+use codemap::{self, CodeMap, ExpnInfo, MacroAttribute, dummy_spanned};\n use errors;\n use config;\n use entry::{self, EntryPointType};\n@@ -307,13 +307,11 @@ fn generate_test_harness(sess: &ParseSess,\n \n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n-        callee: NameAndSpan {\n-            format: MacroAttribute(Symbol::intern(\"test\")),\n-            span: None,\n-            allow_internal_unstable: true,\n-            allow_internal_unsafe: false,\n-            edition: hygiene::default_edition(),\n-        }\n+        def_site: None,\n+        format: MacroAttribute(Symbol::intern(\"test\")),\n+        allow_internal_unstable: true,\n+        allow_internal_unsafe: false,\n+        edition: hygiene::default_edition(),\n     });\n \n     TestHarnessGenerator {"}, {"sha": "e6a1434ca9d10ca540432f668a1008ed6be7da3f", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -157,11 +157,11 @@ fn call_intrinsic(cx: &ExtCtxt,\n                   intrinsic: &str,\n                   args: Vec<P<ast::Expr>>)\n                   -> P<ast::Expr> {\n-    if cx.current_expansion.mark.expn_info().unwrap().callee.allow_internal_unstable {\n+    if cx.current_expansion.mark.expn_info().unwrap().allow_internal_unstable {\n         span = span.with_ctxt(cx.backtrace());\n     } else { // Avoid instability errors with user defined curstom derives, cc #36316\n         let mut info = cx.current_expansion.mark.expn_info().unwrap();\n-        info.callee.allow_internal_unstable = true;\n+        info.allow_internal_unstable = true;\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(info);\n         span = span.with_ctxt(SyntaxContext::empty().apply_mark(mark));"}, {"sha": "ee343e47bd8905c5d44c4ce6bee4bdc892df6879", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -14,7 +14,7 @@ use errors;\n \n use syntax::ast::{self, Ident, NodeId};\n use syntax::attr;\n-use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute, hygiene, respan};\n+use syntax::codemap::{ExpnInfo, MacroAttribute, hygiene, respan};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n@@ -364,13 +364,11 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let mark = Mark::fresh(Mark::root());\n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n-        callee: NameAndSpan {\n-            format: MacroAttribute(Symbol::intern(\"proc_macro\")),\n-            span: None,\n-            allow_internal_unstable: true,\n-            allow_internal_unsafe: false,\n-            edition: hygiene::default_edition(),\n-        }\n+        def_site: None,\n+        format: MacroAttribute(Symbol::intern(\"proc_macro\")),\n+        allow_internal_unstable: true,\n+        allow_internal_unsafe: false,\n+        edition: hygiene::default_edition(),\n     });\n     let span = DUMMY_SP.apply_mark(mark);\n "}, {"sha": "08b7f7c76cb65782f76a38d23538e65d32cce809", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 88, "deletions": 53, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -29,7 +29,7 @@ use std::fmt;\n #[derive(Clone, Copy, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n pub struct SyntaxContext(pub(super) u32);\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub struct SyntaxContextData {\n     pub outer_mark: Mark,\n     pub prev_ctxt: SyntaxContext,\n@@ -40,23 +40,44 @@ pub struct SyntaxContextData {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Mark(u32);\n \n+#[derive(Debug)]\n struct MarkData {\n     parent: Mark,\n-    kind: MarkKind,\n+    transparency: Transparency,\n+    is_builtin: bool,\n     expn_info: Option<ExpnInfo>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n-pub enum MarkKind {\n-    Modern,\n-    Builtin,\n-    Legacy,\n+/// A property of a macro expansion that determines how identifiers\n+/// produced by that expansion are resolved.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Transparency {\n+    /// Identifier produced by a transparent expansion is always resolved at call-site.\n+    /// Call-site spans in procedural macros, hygiene opt-out in `macro` should use this.\n+    /// (Not used yet.)\n+    Transparent,\n+    /// Identifier produced by a semi-transparent expansion may be resolved\n+    /// either at call-site or at definition-site.\n+    /// If it's a local variable, label or `$crate` then it's resolved at def-site.\n+    /// Otherwise it's resolved at call-site.\n+    /// `macro_rules` macros behave like this, built-in macros currently behave like this too,\n+    /// but that's an implementation detail.\n+    SemiTransparent,\n+    /// Identifier produced by an opaque expansion is always resolved at definition-site.\n+    /// Def-site spans in procedural macros, identifiers from `macro` by default use this.\n+    Opaque,\n }\n \n impl Mark {\n     pub fn fresh(parent: Mark) -> Self {\n         HygieneData::with(|data| {\n-            data.marks.push(MarkData { parent: parent, kind: MarkKind::Legacy, expn_info: None });\n+            data.marks.push(MarkData {\n+                parent,\n+                // By default expansions behave like `macro_rules`.\n+                transparency: Transparency::SemiTransparent,\n+                is_builtin: false,\n+                expn_info: None,\n+            });\n             Mark(data.marks.len() as u32 - 1)\n         })\n     }\n@@ -84,28 +105,45 @@ impl Mark {\n \n     #[inline]\n     pub fn set_expn_info(self, info: ExpnInfo) {\n-        HygieneData::with(|data| data.marks[self.0 as usize].expn_info = Some(info))\n+        HygieneData::with(|data| {\n+            let old_info = &mut data.marks[self.0 as usize].expn_info;\n+            if let Some(old_info) = old_info {\n+                panic!(\"expansion info is reset for the mark {}\\nold: {:#?}\\nnew: {:#?}\",\n+                       self.0, old_info, info);\n+            }\n+            *old_info = Some(info);\n+        })\n     }\n \n     pub fn modern(mut self) -> Mark {\n         HygieneData::with(|data| {\n-            loop {\n-                if self == Mark::root() || data.marks[self.0 as usize].kind == MarkKind::Modern {\n-                    return self;\n-                }\n+            while data.marks[self.0 as usize].transparency != Transparency::Opaque {\n                 self = data.marks[self.0 as usize].parent;\n             }\n+            self\n         })\n     }\n \n     #[inline]\n-    pub fn kind(self) -> MarkKind {\n-        HygieneData::with(|data| data.marks[self.0 as usize].kind)\n+    pub fn transparency(self) -> Transparency {\n+        assert_ne!(self, Mark::root());\n+        HygieneData::with(|data| data.marks[self.0 as usize].transparency)\n     }\n \n     #[inline]\n-    pub fn set_kind(self, kind: MarkKind) {\n-        HygieneData::with(|data| data.marks[self.0 as usize].kind = kind)\n+    pub fn set_transparency(self, transparency: Transparency) {\n+        assert_ne!(self, Mark::root());\n+        HygieneData::with(|data| data.marks[self.0 as usize].transparency = transparency)\n+    }\n+\n+    #[inline]\n+    pub fn is_builtin(self) -> bool {\n+        HygieneData::with(|data| data.marks[self.0 as usize].is_builtin)\n+    }\n+\n+    #[inline]\n+    pub fn set_is_builtin(self, is_builtin: bool) {\n+        HygieneData::with(|data| data.marks[self.0 as usize].is_builtin = is_builtin)\n     }\n \n     pub fn is_descendant_of(mut self, ancestor: Mark) -> bool {\n@@ -147,6 +185,7 @@ impl Mark {\n     }\n }\n \n+#[derive(Debug)]\n pub struct HygieneData {\n     marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n@@ -160,7 +199,10 @@ impl HygieneData {\n         HygieneData {\n             marks: vec![MarkData {\n                 parent: Mark::root(),\n-                kind: MarkKind::Builtin,\n+                // If the root is opaque, then loops searching for an opaque mark\n+                // will automatically stop after reaching it.\n+                transparency: Transparency::Opaque,\n+                is_builtin: true,\n                 expn_info: None,\n             }],\n             syntax_contexts: vec![SyntaxContextData {\n@@ -206,8 +248,9 @@ impl SyntaxContext {\n         HygieneData::with(|data| {\n             data.marks.push(MarkData {\n                 parent: Mark::root(),\n-                kind: MarkKind::Legacy,\n-                expn_info: Some(expansion_info)\n+                transparency: Transparency::SemiTransparent,\n+                is_builtin: false,\n+                expn_info: Some(expansion_info),\n             });\n \n             let mark = Mark(data.marks.len() as u32 - 1);\n@@ -223,7 +266,7 @@ impl SyntaxContext {\n \n     /// Extend a syntax context with a given mark\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n-        if mark.kind() == MarkKind::Modern {\n+        if mark.transparency() == Transparency::Opaque {\n             return self.apply_mark_internal(mark);\n         }\n \n@@ -253,7 +296,7 @@ impl SyntaxContext {\n         HygieneData::with(|data| {\n             let syntax_contexts = &mut data.syntax_contexts;\n             let mut modern = syntax_contexts[self.0 as usize].modern;\n-            if data.marks[mark.0 as usize].kind == MarkKind::Modern {\n+            if data.marks[mark.0 as usize].transparency == Transparency::Opaque {\n                 modern = *data.markings.entry((modern, mark)).or_insert_with(|| {\n                     let len = syntax_contexts.len() as u32;\n                     syntax_contexts.push(SyntaxContextData {\n@@ -439,12 +482,11 @@ pub struct ExpnInfo {\n     /// call_site span would have its own ExpnInfo, with the call_site\n     /// pointing to the `foo!` invocation.\n     pub call_site: Span,\n-    /// Information about the expansion.\n-    pub callee: NameAndSpan\n-}\n-\n-#[derive(Clone, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct NameAndSpan {\n+    /// The span of the macro definition itself. The macro may not\n+    /// have a sensible definition span (e.g. something defined\n+    /// completely inside libsyntax) in which case this is None.\n+    /// This span serves only informational purpose and is not used for resolution.\n+    pub def_site: Option<Span>,\n     /// The format with which the macro was invoked.\n     pub format: ExpnFormat,\n     /// Whether the macro is allowed to use #[unstable]/feature-gated\n@@ -456,20 +498,6 @@ pub struct NameAndSpan {\n     pub allow_internal_unsafe: bool,\n     /// Edition of the crate in which the macro is defined.\n     pub edition: Edition,\n-    /// The span of the macro definition itself. The macro may not\n-    /// have a sensible definition span (e.g. something defined\n-    /// completely inside libsyntax) in which case this is None.\n-    pub span: Option<Span>\n-}\n-\n-impl NameAndSpan {\n-    pub fn name(&self) -> Symbol {\n-        match self.format {\n-            ExpnFormat::MacroAttribute(s) |\n-            ExpnFormat::MacroBang(s) => s,\n-            ExpnFormat::CompilerDesugaring(ref kind) => kind.as_symbol(),\n-        }\n-    }\n }\n \n /// The source of expansion.\n@@ -483,8 +511,17 @@ pub enum ExpnFormat {\n     CompilerDesugaring(CompilerDesugaringKind)\n }\n \n+impl ExpnFormat {\n+    pub fn name(&self) -> Symbol {\n+        match *self {\n+            ExpnFormat::MacroBang(name) | ExpnFormat::MacroAttribute(name) => name,\n+            ExpnFormat::CompilerDesugaring(kind) => kind.name(),\n+        }\n+    }\n+}\n+\n /// The kind of compiler desugaring.\n-#[derive(Clone, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum CompilerDesugaringKind {\n     DotFill,\n     QuestionMark,\n@@ -497,16 +534,14 @@ pub enum CompilerDesugaringKind {\n }\n \n impl CompilerDesugaringKind {\n-    pub fn as_symbol(&self) -> Symbol {\n-        use CompilerDesugaringKind::*;\n-        let s = match *self {\n-            Async => \"async\",\n-            DotFill => \"...\",\n-            QuestionMark => \"?\",\n-            Catch => \"do catch\",\n-            ExistentialReturnType => \"existental type\",\n-        };\n-        Symbol::intern(s)\n+    pub fn name(self) -> Symbol {\n+        Symbol::intern(match self {\n+            CompilerDesugaringKind::Async => \"async\",\n+            CompilerDesugaringKind::DotFill => \"...\",\n+            CompilerDesugaringKind::QuestionMark => \"?\",\n+            CompilerDesugaringKind::Catch => \"do catch\",\n+            CompilerDesugaringKind::ExistentialReturnType => \"existental type\",\n+        })\n     }\n }\n "}, {"sha": "a4fb9571ecbe9a75e260e9c40be19a74ceb9815d", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3874676dc6bcb311fa134baa5232d971d6573b29/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=3874676dc6bcb311fa134baa5232d971d6573b29", "patch": "@@ -51,7 +51,7 @@ extern crate unicode_width;\n \n pub mod edition;\n pub mod hygiene;\n-pub use hygiene::{Mark, SyntaxContext, ExpnInfo, ExpnFormat, NameAndSpan, CompilerDesugaringKind};\n+pub use hygiene::{Mark, SyntaxContext, ExpnInfo, ExpnFormat, CompilerDesugaringKind};\n \n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n@@ -303,19 +303,19 @@ impl Span {\n     /// Edition of the crate from which this span came.\n     pub fn edition(self) -> edition::Edition {\n         self.ctxt().outer().expn_info().map_or_else(|| hygiene::default_edition(),\n-                                                    |einfo| einfo.callee.edition)\n+                                                    |einfo| einfo.edition)\n     }\n \n     /// Return the source callee.\n     ///\n-    /// Returns None if the supplied span has no expansion trace,\n-    /// else returns the NameAndSpan for the macro definition\n+    /// Returns `None` if the supplied span has no expansion trace,\n+    /// else returns the `ExpnInfo` for the macro definition\n     /// corresponding to the source callsite.\n-    pub fn source_callee(self) -> Option<NameAndSpan> {\n-        fn source_callee(info: ExpnInfo) -> NameAndSpan {\n+    pub fn source_callee(self) -> Option<ExpnInfo> {\n+        fn source_callee(info: ExpnInfo) -> ExpnInfo {\n             match info.call_site.ctxt().outer().expn_info() {\n                 Some(info) => source_callee(info),\n-                None => info.callee,\n+                None => info,\n             }\n         }\n         self.ctxt().outer().expn_info().map(source_callee)\n@@ -326,15 +326,15 @@ impl Span {\n     /// `#[allow_internal_unstable]`).\n     pub fn allows_unstable(&self) -> bool {\n         match self.ctxt().outer().expn_info() {\n-            Some(info) => info.callee.allow_internal_unstable,\n+            Some(info) => info.allow_internal_unstable,\n             None => false,\n         }\n     }\n \n     /// Check if this span arises from a compiler desugaring of kind `kind`.\n     pub fn is_compiler_desugaring(&self, kind: CompilerDesugaringKind) -> bool {\n         match self.ctxt().outer().expn_info() {\n-            Some(info) => match info.callee.format {\n+            Some(info) => match info.format {\n                 ExpnFormat::CompilerDesugaring(k) => k == kind,\n                 _ => false,\n             },\n@@ -346,7 +346,7 @@ impl Span {\n     /// if this span is not from a desugaring.\n     pub fn compiler_desugaring_kind(&self) -> Option<CompilerDesugaringKind> {\n         match self.ctxt().outer().expn_info() {\n-            Some(info) => match info.callee.format {\n+            Some(info) => match info.format {\n                 ExpnFormat::CompilerDesugaring(k) => Some(k),\n                 _ => None\n             },\n@@ -359,7 +359,7 @@ impl Span {\n     //  (that is, a macro marked with `#[allow_internal_unsafe]`).\n     pub fn allows_unsafe(&self) -> bool {\n         match self.ctxt().outer().expn_info() {\n-            Some(info) => info.callee.allow_internal_unsafe,\n+            Some(info) => info.allow_internal_unsafe,\n             None => false,\n         }\n     }\n@@ -368,20 +368,17 @@ impl Span {\n         let mut prev_span = DUMMY_SP;\n         let mut result = vec![];\n         while let Some(info) = self.ctxt().outer().expn_info() {\n-            let (pre, post) = match info.callee.format {\n-                ExpnFormat::MacroAttribute(..) => (\"#[\", \"]\"),\n-                ExpnFormat::MacroBang(..) => (\"\", \"!\"),\n-                ExpnFormat::CompilerDesugaring(..) => (\"desugaring of `\", \"`\"),\n-            };\n-            let macro_decl_name = format!(\"{}{}{}\", pre, info.callee.name(), post);\n-            let def_site_span = info.callee.span;\n-\n             // Don't print recursive invocations\n             if !info.call_site.source_equal(&prev_span) {\n+                let (pre, post) = match info.format {\n+                    ExpnFormat::MacroAttribute(..) => (\"#[\", \"]\"),\n+                    ExpnFormat::MacroBang(..) => (\"\", \"!\"),\n+                    ExpnFormat::CompilerDesugaring(..) => (\"desugaring of `\", \"`\"),\n+                };\n                 result.push(MacroBacktrace {\n                     call_site: info.call_site,\n-                    macro_decl_name,\n-                    def_site_span,\n+                    macro_decl_name: format!(\"{}{}{}\", pre, info.format.name(), post),\n+                    def_site_span: info.def_site,\n                 });\n             }\n "}]}