{"sha": "c07ae16de18ad24004e1d1c425c08bcf3e7c4811", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwN2FlMTZkZTE4YWQyNDAwNGUxZDFjNDI1YzA4YmNmM2U3YzQ4MTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-22T19:06:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-28T18:01:59Z"}, "message": "rename assign to coerce, remove some bad copies\n\nr=brson", "tree": {"sha": "ca3c7bf8106089a3a22e5d9365c7e4c940d22007", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca3c7bf8106089a3a22e5d9365c7e4c940d22007"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c07ae16de18ad24004e1d1c425c08bcf3e7c4811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c07ae16de18ad24004e1d1c425c08bcf3e7c4811", "html_url": "https://github.com/rust-lang/rust/commit/c07ae16de18ad24004e1d1c425c08bcf3e7c4811", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c07ae16de18ad24004e1d1c425c08bcf3e7c4811/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05b6df49b86024eb4f41fb94478ad9cd80dc172c", "url": "https://api.github.com/repos/rust-lang/rust/commits/05b6df49b86024eb4f41fb94478ad9cd80dc172c", "html_url": "https://github.com/rust-lang/rust/commit/05b6df49b86024eb4f41fb94478ad9cd80dc172c"}], "stats": {"total": 162, "additions": 78, "deletions": 84}, "files": [{"sha": "c8aaf2ca61b495cc3f461549802e398e7421edbb", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c07ae16de18ad24004e1d1c425c08bcf3e7c4811/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07ae16de18ad24004e1d1c425c08bcf3e7c4811/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=c07ae16de18ad24004e1d1c425c08bcf3e7c4811", "patch": "@@ -49,8 +49,8 @@ fn eqtype(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t) {\n     }\n }\n \n-// Checks that the type `actual` can be assigned to `expected`.\n-fn assign(fcx: @fn_ctxt, sp: span, expected: ty::t, expr: @ast::expr) {\n+// Checks that the type `actual` can be coerced to `expected`.\n+fn coerce(fcx: @fn_ctxt, sp: span, expected: ty::t, expr: @ast::expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       result::Ok(()) => { /* ok */ }"}, {"sha": "2d823ff02dd9103e8c8505a245de7e846e5bc1cc", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c07ae16de18ad24004e1d1c425c08bcf3e7c4811/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07ae16de18ad24004e1d1c425c08bcf3e7c4811/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c07ae16de18ad24004e1d1c425c08bcf3e7c4811", "patch": "@@ -812,7 +812,7 @@ impl @fn_ctxt {\n     fn mk_assignty(expr: @ast::expr, sub: ty::t, sup: ty::t)\n         -> Result<(), ty::type_err>\n     {\n-        match infer::mk_assignty(self.infcx(), false, expr.span, sub, sup) {\n+        match infer::mk_coercety(self.infcx(), false, expr.span, sub, sup) {\n             Ok(None) => result::Ok(()),\n             Err(ref e) => result::Err((*e)),\n             Ok(Some(adjustment)) => {\n@@ -823,7 +823,7 @@ impl @fn_ctxt {\n     }\n \n     fn can_mk_assignty(sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n-        infer::can_mk_assignty(self.infcx(), sub, sup)\n+        infer::can_mk_coercety(self.infcx(), sub, sup)\n     }\n \n     fn mk_eqty(a_is_expected: bool, span: span,\n@@ -986,12 +986,12 @@ fn check_expr_has_type(\n     }\n }\n \n-fn check_expr_assignable_to_type(\n+fn check_expr_coercable_to_type(\n     fcx: @fn_ctxt, expr: @ast::expr,\n     expected: ty::t) -> bool\n {\n     do check_expr_with_unifier(fcx, expr, Some(expected)) {\n-        demand::assign(fcx, expr.span, expected, expr)\n+        demand::coerce(fcx, expr.span, expected, expr)\n     }\n }\n \n@@ -1225,7 +1225,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     }\n \n                     // mismatch error happens in here\n-                    bot |= check_expr_assignable_to_type(\n+                    bot |= check_expr_coercable_to_type(\n                         fcx, *arg, formal_ty);\n \n                 }\n@@ -1243,7 +1243,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                      -> bool {\n         let mut bot = check_expr(fcx, lhs);\n         let lhs_type = fcx.expr_ty(lhs);\n-        bot |= check_expr_assignable_to_type(fcx, rhs, lhs_type);\n+        bot |= check_expr_has_type(fcx, rhs, lhs_type);\n         fcx.write_ty(id, ty::mk_nil(fcx.ccx.tcx));\n         return bot;\n     }\n@@ -1739,7 +1739,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                         ty::lookup_field_type(\n                             tcx, class_id, field_id, substitutions);\n                     bot |=\n-                        check_expr_assignable_to_type(\n+                        check_expr_coercable_to_type(\n                             fcx,\n                             field.node.expr,\n                             expected_field_type);\n@@ -2552,7 +2552,7 @@ fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n                           init: @ast::expr) -> bool {\n     let lty = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, init.span, nid));\n-    return check_expr_assignable_to_type(fcx, init, lty);\n+    return check_expr_coercable_to_type(fcx, init, lty);\n }\n \n fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {"}, {"sha": "84fe51b65ec518c8db031890c5ff31ec37bf9c2f", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "renamed", "additions": 56, "deletions": 60, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c07ae16de18ad24004e1d1c425c08bcf3e7c4811/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07ae16de18ad24004e1d1c425c08bcf3e7c4811/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=c07ae16de18ad24004e1d1c425c08bcf3e7c4811", "patch": "@@ -79,73 +79,69 @@ fn to_ares<T>(+c: cres<T>) -> ares {\n     }\n }\n \n-// Note: Assign is not actually a combiner, in that it does not\n+// Note: Coerce is not actually a combiner, in that it does not\n // conform to the same interface, though it performs a similar\n // function.\n-enum Assign = CombineFields;\n+pub enum Coerce = CombineFields;\n \n-impl Assign {\n-    fn tys(a: ty::t, b: ty::t) -> ares {\n-        debug!(\"Assign.tys(%s => %s)\",\n+impl Coerce {\n+    fn tys(&self, a: ty::t, b: ty::t) -> ares {\n+        debug!(\"Coerce.tys(%s => %s)\",\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n-        let _r = indenter();\n-\n-        debug!(\"Assign.tys: copying first type\");\n-        let copy_a = copy ty::get(a).sty;\n-        debug!(\"Assign.tys: copying second type\");\n-        let copy_b = copy ty::get(b).sty;\n-        debug!(\"Assign.tys: performing match\");\n-\n-        let r = match (copy_a, copy_b) {\n-            (ty::ty_bot, _) => {\n+        let _indent = indenter();\n+        let r = match (&ty::get(a).sty, &ty::get(b).sty) {\n+            (&ty::ty_bot, _) => {\n                 Ok(None)\n             }\n \n-            (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n+            (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n                 let nde_a = self.infcx.get(a_id);\n                 let nde_b = self.infcx.get(b_id);\n                 let a_bounds = nde_a.possible_types;\n                 let b_bounds = nde_b.possible_types;\n \n                 let a_bnd = option::or(a_bounds.ub, a_bounds.lb);\n                 let b_bnd = option::or(b_bounds.lb, b_bounds.ub);\n-                self.assign_tys_or_sub(a, b, a_bnd, b_bnd)\n+                self.coerce_tys_or_sub(a, b, a_bnd, b_bnd)\n             }\n \n-            (ty::ty_infer(TyVar(a_id)), _) => {\n+            (&ty::ty_infer(TyVar(a_id)), _) => {\n                 let nde_a = self.infcx.get(a_id);\n                 let a_bounds = nde_a.possible_types;\n \n                 let a_bnd = option::or(a_bounds.ub, a_bounds.lb);\n-                self.assign_tys_or_sub(a, b, a_bnd, Some(b))\n+                self.coerce_tys_or_sub(a, b, a_bnd, Some(b))\n             }\n \n-            (_, ty::ty_infer(TyVar(b_id))) => {\n+            (_, &ty::ty_infer(TyVar(b_id))) => {\n                 let nde_b = self.infcx.get(b_id);\n                 let b_bounds = nde_b.possible_types;\n \n                 let b_bnd = option::or(b_bounds.lb, b_bounds.ub);\n-                self.assign_tys_or_sub(a, b, Some(a), b_bnd)\n+                self.coerce_tys_or_sub(a, b, Some(a), b_bnd)\n             }\n \n             (_, _) => {\n-                self.assign_tys_or_sub(a, b, Some(a), Some(b))\n+                self.coerce_tys_or_sub(a, b, Some(a), Some(b))\n             }\n         };\n \n-        debug!(\"Assign.tys end\");\n+        debug!(\"Coerce.tys end\");\n \n         move r\n     }\n }\n \n-priv impl Assign {\n-    fn assign_tys_or_sub(\n-        a: ty::t, b: ty::t,\n-        +a_bnd: Option<ty::t>, +b_bnd: Option<ty::t>) -> ares {\n-\n-        debug!(\"Assign.assign_tys_or_sub(%s => %s, %s => %s)\",\n+impl Coerce {\n+    fn coerce_tys_or_sub(\n+        &self,\n+        +a: ty::t,\n+        +b: ty::t,\n+        +a_bnd: Option<ty::t>,\n+        +b_bnd: Option<ty::t>) -> ares\n+    {\n+        debug!(\"Coerce.coerce_tys_or_sub(%s => %s, %s => %s)\",\n                a.inf_str(self.infcx), b.inf_str(self.infcx),\n                a_bnd.inf_str(self.infcx), b_bnd.inf_str(self.infcx));\n         let _r = indenter();\n@@ -167,59 +163,58 @@ priv impl Assign {\n \n         match (a_bnd, b_bnd) {\n             (Some(a_bnd), Some(b_bnd)) => {\n-                match (/*bad*/copy ty::get(a_bnd).sty,\n-                       /*bad*/copy ty::get(b_bnd).sty) {\n+                match (&ty::get(a_bnd).sty, &ty::get(b_bnd).sty) {\n                     // check for a case where a non-region pointer (@, ~) is\n-                    // being assigned to a region pointer:\n-                    (ty::ty_box(_), ty::ty_rptr(r_b, mt_b)) => {\n+                    // being coerceed to a region pointer:\n+                    (&ty::ty_box(_), &ty::ty_rptr(r_b, mt_b)) => {\n                         let nr_b = ty::mk_box(self.infcx.tcx,\n                                               ty::mt {ty: mt_b.ty,\n                                                       mutbl: m_const});\n-                        self.try_assign(1, ty::AutoPtr,\n+                        self.try_coerce(1, ty::AutoPtr,\n                                         a, nr_b,\n                                         mt_b.mutbl, r_b)\n                     }\n-                    (ty::ty_uniq(_), ty::ty_rptr(r_b, mt_b)) => {\n+                    (&ty::ty_uniq(_), &ty::ty_rptr(r_b, mt_b)) => {\n                         let nr_b = ty::mk_uniq(self.infcx.tcx,\n                                                ty::mt {ty: mt_b.ty,\n                                                        mutbl: m_const});\n-                        self.try_assign(1, ty::AutoPtr,\n+                        self.try_coerce(1, ty::AutoPtr,\n                                         a, nr_b,\n                                         mt_b.mutbl, r_b)\n                     }\n-                    (ty::ty_estr(vs_a),\n-                     ty::ty_estr(ty::vstore_slice(r_b)))\n+                    (&ty::ty_estr(vs_a),\n+                     &ty::ty_estr(ty::vstore_slice(r_b)))\n                     if is_borrowable(vs_a) => {\n                         let nr_b = ty::mk_estr(self.infcx.tcx, vs_a);\n-                        self.try_assign(0, ty::AutoBorrowVec,\n+                        self.try_coerce(0, ty::AutoBorrowVec,\n                                         a, nr_b,\n                                         m_imm, r_b)\n                     }\n \n-                    (ty::ty_evec(_, vs_a),\n-                     ty::ty_evec(mt_b, ty::vstore_slice(r_b)))\n+                    (&ty::ty_evec(_, vs_a),\n+                     &ty::ty_evec(mt_b, ty::vstore_slice(r_b)))\n                     if is_borrowable(vs_a) => {\n                         let nr_b = ty::mk_evec(self.infcx.tcx,\n                                                ty::mt {ty: mt_b.ty,\n                                                        mutbl: m_const},\n                                                vs_a);\n-                        self.try_assign(0, ty::AutoBorrowVec,\n+                        self.try_coerce(0, ty::AutoBorrowVec,\n                                         a, nr_b,\n                                         mt_b.mutbl, r_b)\n                     }\n \n-                    (ty::ty_fn(ref a_f), ty::ty_fn(ref b_f))\n+                    (&ty::ty_fn(ref a_f), &ty::ty_fn(ref b_f))\n                     if borrowable_protos(a_f.meta.proto, b_f.meta.proto) => {\n                         let nr_b = ty::mk_fn(self.infcx.tcx, ty::FnTyBase {\n                             meta: ty::FnMeta {proto: a_f.meta.proto,\n                                               ..b_f.meta},\n                             sig: copy b_f.sig\n                         });\n-                        self.try_assign(0, ty::AutoBorrowFn,\n+                        self.try_coerce(0, ty::AutoBorrowFn,\n                                         a, nr_b, m_imm, b_f.meta.region)\n                     }\n \n-                    (ty::ty_fn(ref a_f), ty::ty_fn(ref b_f))\n+                    (&ty::ty_fn(ref a_f), &ty::ty_fn(ref b_f))\n                     if a_f.meta.proto == ast::ProtoBare => {\n                         let b1_f = ty::FnTyBase {\n                             meta: ty::FnMeta {proto: ast::ProtoBare,\n@@ -229,49 +224,50 @@ priv impl Assign {\n                         // Eventually we will need to add some sort of\n                         // adjustment here so that trans can add an\n                         // extra NULL env pointer:\n-                        to_ares(Sub(*self).fns(a_f, &b1_f))\n+                        to_ares(Sub(**self).fns(a_f, &b1_f))\n                     }\n \n-                    // check for &T being assigned to *T:\n-                    (ty::ty_rptr(_, ref a_t), ty::ty_ptr(ref b_t)) => {\n-                        to_ares(Sub(*self).mts(*a_t, *b_t))\n+                    // check for &T being coerced to *T:\n+                    (&ty::ty_rptr(_, ref a_t), &ty::ty_ptr(ref b_t)) => {\n+                        to_ares(Sub(**self).mts(*a_t, *b_t))\n                     }\n \n-                    // otherwise, assignment follows normal subtype rules:\n+                    // otherwise, coercement follows normal subtype rules:\n                     _ => {\n-                        to_ares(Sub(*self).tys(a, b))\n+                        to_ares(Sub(**self).tys(a, b))\n                     }\n                 }\n             }\n             _ => {\n                 // if insufficient bounds were available, just follow\n                 // normal subtype rules:\n-                to_ares(Sub(*self).tys(a, b))\n+                to_ares(Sub(**self).tys(a, b))\n             }\n         }\n     }\n \n-    /// Given an assignment from a type like `@a` to `&r_b/m nr_b`,\n+    /// Given an coercement from a type like `@a` to `&r_b/m nr_b`,\n     /// this function checks that `a <: nr_b`.  In that case, the\n-    /// assignment is permitted, so it constructs a fresh region\n-    /// variable `r_a >= r_b` and returns a corresponding assignment\n+    /// coercement is permitted, so it constructs a fresh region\n+    /// variable `r_a >= r_b` and returns a corresponding coercement\n     /// record.  See the discussion at the top of this file for more\n     /// details.\n-    fn try_assign(autoderefs: uint,\n+    fn try_coerce(&self,\n+                  autoderefs: uint,\n                   kind: ty::AutoRefKind,\n                   a: ty::t,\n                   nr_b: ty::t,\n                   m: ast::mutability,\n-                  r_b: ty::Region) -> ares {\n-\n-        debug!(\"try_assign(a=%s, nr_b=%s, m=%?, r_b=%s)\",\n+                  r_b: ty::Region) -> ares\n+    {\n+        debug!(\"try_coerce(a=%s, nr_b=%s, m=%?, r_b=%s)\",\n                a.inf_str(self.infcx),\n                nr_b.inf_str(self.infcx),\n                m,\n                r_b.inf_str(self.infcx));\n \n         do indent {\n-            let sub = Sub(*self);\n+            let sub = Sub(**self);\n             do sub.tys(a, nr_b).chain |_t| {\n                 let r_a = self.infcx.next_region_var_nb(self.span);\n                 do sub.contraregions(r_a, r_b).chain |_r| {", "previous_filename": "src/librustc/middle/typeck/infer/assignment.rs"}, {"sha": "8ec7e68176a56c2fcec18611888af6164654d8a6", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c07ae16de18ad24004e1d1c425c08bcf3e7c4811/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07ae16de18ad24004e1d1c425c08bcf3e7c4811/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=c07ae16de18ad24004e1d1c425c08bcf3e7c4811", "patch": "@@ -217,11 +217,11 @@ when possible but otherwise merge the variables\" strategy.  In other\n words, `GLB(A, B)` where `A` and `B` are variables will often result\n in `A` and `B` being merged and the result being `A`.\n \n-## Type assignment\n+## Type coercion\n \n We have a notion of assignability which differs somewhat from\n subtyping; in particular it may cause region borrowing to occur.  See\n-the big comment later in this file on Type Assignment for specifics.\n+the big comment later in this file on Type Coercion for specifics.\n \n ### In conclusion\n \n@@ -254,7 +254,7 @@ use middle::ty::{ty_int, ty_uint, get, terr_fn, TyVar, IntVar, FloatVar};\n use middle::ty::IntVarValue;\n use middle::ty;\n use middle::typeck::check::regionmanip::{replace_bound_regions_in_fn_sig};\n-use middle::typeck::infer::assignment::Assign;\n+use middle::typeck::infer::coercion::Coerce;\n use middle::typeck::infer::combine::{CombineFields, eq_tys};\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n@@ -293,17 +293,15 @@ export new_infer_ctxt;\n export mk_subty, can_mk_subty;\n export mk_subr;\n export mk_eqty;\n-export mk_assignty, can_mk_assignty;\n+export mk_coercety, can_mk_coercety;\n export resolve_nested_tvar, resolve_rvar, resolve_ivar, resolve_all;\n export force_tvar, force_rvar, force_ivar, force_all;\n export resolve_and_force_all_but_regions, not_regions;\n export resolve_type, resolve_region;\n export resolve_borrowings;\n export cres, fres, fixup_err, fixup_err_to_str;\n-export assignment;\n export root, to_str;\n export int_ty_set_all;\n-export assignment;\n export combine;\n export glb;\n export integral;\n@@ -312,6 +310,7 @@ export lub;\n export region_inference;\n export resolve;\n export sub;\n+export coercion;\n export to_str;\n export unify;\n export uok;\n@@ -323,8 +322,7 @@ export infer_ctxt;\n export fixup_err;\n export IntVarValue, IntType, UintType;\n \n-#[legacy_exports]\n-mod assignment;\n+mod coercion;\n #[legacy_exports]\n mod combine;\n #[legacy_exports]\n@@ -458,22 +456,22 @@ fn mk_eqty(cx: @InferCtxt, a_is_expected: bool, span: span,\n     }.to_ures()\n }\n \n-fn mk_assignty(cx: @InferCtxt, a_is_expected: bool, span: span,\n+fn mk_coercety(cx: @InferCtxt, a_is_expected: bool, span: span,\n                a: ty::t, b: ty::t) -> ares {\n-    debug!(\"mk_assignty(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n+    debug!(\"mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            Assign(cx.combine_fields(a_is_expected, span)).tys(a, b)\n+            Coerce(cx.combine_fields(a_is_expected, span)).tys(a, b)\n         }\n     }\n }\n \n-fn can_mk_assignty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n-    debug!(\"can_mk_assignty(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n+fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n+    debug!(\"can_mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n             let span = ast_util::dummy_sp();\n-            Assign(cx.combine_fields(true, span)).tys(a, b)\n+            Coerce(cx.combine_fields(true, span)).tys(a, b)\n         }\n     }.to_ures()\n }"}]}