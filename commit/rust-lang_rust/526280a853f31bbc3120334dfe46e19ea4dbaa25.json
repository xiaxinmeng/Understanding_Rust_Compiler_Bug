{"sha": "526280a853f31bbc3120334dfe46e19ea4dbaa25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNjI4MGE4NTNmMzFiYmMzMTIwMzM0ZGZlNDZlMTllYTRkYmFhMjU=", "commit": {"author": {"name": "XAMPPRocky", "email": "4464295+XAMPPRocky@users.noreply.github.com", "date": "2020-02-26T20:39:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-26T20:39:30Z"}, "message": "Merge branch 'master' into relnotes-1.42.0", "tree": {"sha": "cd35561be4cdcd7591d98bae715726c0e40995b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd35561be4cdcd7591d98bae715726c0e40995b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/526280a853f31bbc3120334dfe46e19ea4dbaa25", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeVteCCRBK7hj4Ov3rIwAAdHIIACE+mNSBWD/3mPOqY4xPrBLr\nKhTyQxXDFbaOC8kdfEgClEaYhyP1hBJa2zfDb19lkn+HTtMOYghYLOKbxfhUQD9I\nG3TTuFdwD+EzaFl6rnOJoNnq3OGuD02VGfUXwb+p8CVtb6Y0kV1PxO2wdFjC8uN8\nCgrMHUwiBFqyvjKxqMW6PCmK2MfkPH4wYqQlB+rFlfW4vLJseMQx+qsGStnydgWU\nARPWe1udjvfflKa7omTvSWTTj98sm0Dl8NWX73rVbKzDSBpigeCpN3PZcwHzfqLO\nefOxAQRYBMCV+0prJ9afjGTLvuL9xaxpjNonAkisMSqNK4iOhRusS9bxGsK4df8=\n=0ffY\n-----END PGP SIGNATURE-----\n", "payload": "tree cd35561be4cdcd7591d98bae715726c0e40995b7\nparent e7a344fb745a0a663e21be947b2619df05df6d31\nparent abc3073c92df034636a823c5382ece2186d22b9e\nauthor XAMPPRocky <4464295+XAMPPRocky@users.noreply.github.com> 1582749570 +0100\ncommitter GitHub <noreply@github.com> 1582749570 +0100\n\nMerge branch 'master' into relnotes-1.42.0"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/526280a853f31bbc3120334dfe46e19ea4dbaa25", "html_url": "https://github.com/rust-lang/rust/commit/526280a853f31bbc3120334dfe46e19ea4dbaa25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/526280a853f31bbc3120334dfe46e19ea4dbaa25/comments", "author": {"login": "XAMPPRocky", "id": 4464295, "node_id": "MDQ6VXNlcjQ0NjQyOTU=", "avatar_url": "https://avatars.githubusercontent.com/u/4464295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/XAMPPRocky", "html_url": "https://github.com/XAMPPRocky", "followers_url": "https://api.github.com/users/XAMPPRocky/followers", "following_url": "https://api.github.com/users/XAMPPRocky/following{/other_user}", "gists_url": "https://api.github.com/users/XAMPPRocky/gists{/gist_id}", "starred_url": "https://api.github.com/users/XAMPPRocky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/XAMPPRocky/subscriptions", "organizations_url": "https://api.github.com/users/XAMPPRocky/orgs", "repos_url": "https://api.github.com/users/XAMPPRocky/repos", "events_url": "https://api.github.com/users/XAMPPRocky/events{/privacy}", "received_events_url": "https://api.github.com/users/XAMPPRocky/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7a344fb745a0a663e21be947b2619df05df6d31", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a344fb745a0a663e21be947b2619df05df6d31", "html_url": "https://github.com/rust-lang/rust/commit/e7a344fb745a0a663e21be947b2619df05df6d31"}, {"sha": "abc3073c92df034636a823c5382ece2186d22b9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/abc3073c92df034636a823c5382ece2186d22b9e", "html_url": "https://github.com/rust-lang/rust/commit/abc3073c92df034636a823c5382ece2186d22b9e"}], "stats": {"total": 61499, "additions": 37772, "deletions": 23727}, "files": [{"sha": "e5aad52ef4b792b1d1f52e23a100a5fea6b38f12", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -114,6 +114,7 @@ James Deng <cnjamesdeng@gmail.com> <cnJamesDeng@gmail.com>\n James Miller <bladeon@gmail.com> <james@aatch.net>\n James Perry <james.austin.perry@gmail.com>\n Jason Fager <jfager@gmail.com>\n+Jason Liquorish <jason@liquori.sh> <Bassetts@users.noreply.github.com>\n Jason Orendorff <jorendorff@mozilla.com> <jason.orendorff@gmail.com>\n Jason Orendorff <jorendorff@mozilla.com> <jason@mozmac-2.local>\n Jason Toffaletti <toffaletti@gmail.com> Jason Toffaletti <jason@topsy.com>"}, {"sha": "beda3993353f4820024f20e7c3c2e971668bf787", "filename": "Cargo.lock", "status": "modified", "additions": 283, "deletions": 138, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -121,9 +121,9 @@ checksum = \"1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2\"\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.40\"\n+version = \"0.3.44\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"924c76597f0d9ca25d762c25a4d369d51267536465dc5064bdf0eb073ed477ea\"\n+checksum = \"e4036b9bf40f3cf16aba72a3d65e8a520fc4bafcdc7079aea8f848c58c5b5536\"\n dependencies = [\n  \"backtrace-sys\",\n  \"cfg-if\",\n@@ -281,7 +281,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.43.0\"\n+version = \"0.44.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n@@ -292,6 +292,7 @@ dependencies = [\n  \"clap\",\n  \"core-foundation 0.7.0\",\n  \"crates-io\",\n+ \"crossbeam-channel\",\n  \"crossbeam-utils 0.7.0\",\n  \"crypto-hash\",\n  \"curl\",\n@@ -497,7 +498,7 @@ dependencies = [\n  \"itertools 0.8.0\",\n  \"lazy_static 1.4.0\",\n  \"matches\",\n- \"pulldown-cmark 0.6.1\",\n+ \"pulldown-cmark 0.7.0\",\n  \"quine-mc_cluskey\",\n  \"regex-syntax\",\n  \"semver\",\n@@ -575,9 +576,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.24\"\n+version = \"0.1.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b9975aefa63997ef75ca9cf013ff1bb81487aaa0b622c21053afd3b92979a7af\"\n+checksum = \"438ac08ddc5efe81452f984a9e33ba425b00b31d1f48e6acd9e2210aa28cc52e\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -721,12 +722,11 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.3.8\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0f0ed1a4de2235cabda8558ff5840bffb97fcb64c97827f354a451307df5f72b\"\n+checksum = \"acec9a3b0b3559f15aee4f90746c4e5e293b701c0f7d3925d24e01645267b68c\"\n dependencies = [\n- \"crossbeam-utils 0.6.5\",\n- \"smallvec 0.6.10\",\n+ \"crossbeam-utils 0.7.0\",\n ]\n \n [[package]]\n@@ -879,14 +879,13 @@ dependencies = [\n \n [[package]]\n name = \"derive_more\"\n-version = \"0.13.0\"\n+version = \"0.99.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f57d78cf3bd45270dad4e70c21ec77a960b36c7a841ff9db76aaa775a8fb871\"\n+checksum = \"2159be042979966de68315bce7034bb000c775f22e3e834e1c52ff78f041cae8\"\n dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"rustc_version\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n@@ -1077,13 +1076,14 @@ checksum = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.4\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2df5c1a8c4be27e7707789dc42ae65976e60b394afd293d1419ab915833e646\"\n+checksum = \"1ff6d4dab0aa0c8e6346d46052e93b13a16cf847b54ed357087c35011048cc7d\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -1537,9 +1537,9 @@ checksum = \"c3360c7b59e5ffa2653671fb74b4741a5d343c03f331c0a4aeda42b5c2b0ec7d\"\n \n [[package]]\n name = \"ignore\"\n-version = \"0.4.10\"\n+version = \"0.4.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0ec16832258409d571aaef8273f3c3cc5b060d784e159d1a0f3b0017308f84a7\"\n+checksum = \"522daefc3b69036f80c7d2990b28ff9e0471c683bad05ca258e0a01dd22c5a1e\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"globset\",\n@@ -1548,7 +1548,7 @@ dependencies = [\n  \"memchr\",\n  \"regex\",\n  \"same-file\",\n- \"thread_local\",\n+ \"thread_local 1.0.1\",\n  \"walkdir\",\n  \"winapi-util\",\n ]\n@@ -1564,7 +1564,7 @@ dependencies = [\n  \"rand_xoshiro\",\n  \"sized-chunks\",\n  \"typenum\",\n- \"version_check 0.9.1\",\n+ \"version_check\",\n ]\n \n [[package]]\n@@ -1657,9 +1657,9 @@ checksum = \"9ad0485404155f45cce53a40d4b2d6ac356418300daed05273d9e26f91c390be\"\n \n [[package]]\n name = \"jsonrpc-client-transports\"\n-version = \"13.1.0\"\n+version = \"14.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39577db48b004cffb4c5b8e5c9b993c177c52599ecbee88711e815acf65144db\"\n+checksum = \"0a9ae166c4d1f702d297cd76d4b55758ace80272ffc6dbb139fdc1bf810de40b\"\n dependencies = [\n  \"failure\",\n  \"futures\",\n@@ -1676,9 +1676,9 @@ dependencies = [\n \n [[package]]\n name = \"jsonrpc-core\"\n-version = \"13.2.0\"\n+version = \"14.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"91d767c183a7e58618a609499d359ce3820700b3ebb4823a18c343b4a2a41a0d\"\n+checksum = \"fe3b688648f1ef5d5072229e2d672ecb92cbff7d1c79bcf3fd5898f3f3df0970\"\n dependencies = [\n  \"futures\",\n  \"log\",\n@@ -1689,63 +1689,62 @@ dependencies = [\n \n [[package]]\n name = \"jsonrpc-core-client\"\n-version = \"13.1.0\"\n+version = \"14.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f047c10738edee7c3c6acf5241a0ce33df32ef9230c1a7fb03e4a77ee72c992f\"\n+checksum = \"080dc110be17701097df238fad3c816d4a478a1899dfbcf8ec8957dd40ec7304\"\n dependencies = [\n  \"jsonrpc-client-transports\",\n ]\n \n [[package]]\n name = \"jsonrpc-derive\"\n-version = \"13.1.0\"\n+version = \"14.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"29f9149f785deaae92a4c834a9a1a83a4313b8cfedccf15362cd4cf039a64501\"\n+checksum = \"8609af8f63b626e8e211f52441fcdb6ec54f1a446606b10d5c89ae9bf8a20058\"\n dependencies = [\n  \"proc-macro-crate\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n name = \"jsonrpc-ipc-server\"\n-version = \"13.1.0\"\n+version = \"14.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"256c5e4292c17b4c2ecdf542299dc8e9d6b3939c075c54825570ad9317fe5751\"\n+checksum = \"b579cd0840d7db3ebaadf52f6f31ec601a260e78d610e44f68634f919e34497a\"\n dependencies = [\n  \"jsonrpc-core\",\n  \"jsonrpc-server-utils\",\n  \"log\",\n  \"parity-tokio-ipc\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"tokio-service\",\n ]\n \n [[package]]\n name = \"jsonrpc-pubsub\"\n-version = \"13.1.0\"\n+version = \"14.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2c08b444cc0ed70263798834343d0ac875e664257df8079160f23ac1ea79446\"\n+checksum = \"5b31c9b90731276fdd24d896f31bb10aecf2e5151733364ae81123186643d939\"\n dependencies = [\n  \"jsonrpc-core\",\n  \"log\",\n- \"parking_lot\",\n+ \"parking_lot 0.10.0\",\n  \"serde\",\n ]\n \n [[package]]\n name = \"jsonrpc-server-utils\"\n-version = \"13.1.0\"\n+version = \"14.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"44561bfdd31401bad790527f1e951dde144f2341ddc3e1b859d32945e1a34eff\"\n+checksum = \"95b7635e618a0edbbe0d2a2bbbc69874277c49383fcf6c3c0414491cfb517d22\"\n dependencies = [\n  \"bytes\",\n  \"globset\",\n  \"jsonrpc-core\",\n  \"lazy_static 1.4.0\",\n  \"log\",\n- \"num_cpus\",\n  \"tokio\",\n  \"tokio-codec\",\n  \"unicase\",\n@@ -2009,15 +2008,15 @@ checksum = \"fef709d3257013bba7cff14fc504e07e80631d3fe0f6d38ce63b8f6510ccb932\"\n dependencies = [\n  \"byteorder\",\n  \"memmap\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"rustc-hash\",\n ]\n \n [[package]]\n name = \"memchr\"\n-version = \"2.2.0\"\n+version = \"2.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2efc7bc57c883d4a4d6e3246905283d8dae951bb3bd32f49d6ef297f546e1c39\"\n+checksum = \"53445de381a1f436797497c61d851644d0e8e88e6140f22872ad33a704933978\"\n \n [[package]]\n name = \"memmap\"\n@@ -2351,10 +2350,20 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f842b1982eb6c2fe34036a4fbfb06dd185a3f5c8edfaacdf7d1ea10b07de6252\"\n dependencies = [\n  \"lock_api\",\n- \"parking_lot_core\",\n+ \"parking_lot_core 0.6.2\",\n  \"rustc_version\",\n ]\n \n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"92e98c49ab0b7ce5b222f2cc9193fc4efe11c6d0bd4f648e374684a6857b1cfc\"\n+dependencies = [\n+ \"lock_api\",\n+ \"parking_lot_core 0.7.0\",\n+]\n+\n [[package]]\n name = \"parking_lot_core\"\n version = \"0.6.2\"\n@@ -2370,6 +2379,20 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7582838484df45743c8434fbff785e8edf260c28748353d44bc0da32e0ceabf1\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"cloudabi\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"smallvec 1.0.0\",\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"percent-encoding\"\n version = \"1.0.1\"\n@@ -2504,12 +2527,11 @@ dependencies = [\n \n [[package]]\n name = \"pretty_env_logger\"\n-version = \"0.3.0\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"df8b3f4e0475def7d9c2e5de8e5a1306949849761e107b360d03e98eafaffd61\"\n+checksum = \"926d36b9553851b8b0005f1275891b392ee4d2d833852c417ed025477350fb9d\"\n dependencies = [\n- \"chrono\",\n- \"env_logger 0.6.2\",\n+ \"env_logger 0.7.1\",\n  \"log\",\n ]\n \n@@ -2582,23 +2604,23 @@ dependencies = [\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.5.3\"\n+version = \"0.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"77043da1282374688ee212dc44b3f37ff929431de9c9adc3053bd3cee5630357\"\n+checksum = \"1c205cc82214f3594e2d50686730314f817c67ffa80fe800cf0db78c3c2b9d9e\"\n dependencies = [\n  \"bitflags\",\n+ \"getopts\",\n  \"memchr\",\n  \"unicase\",\n ]\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.6.1\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1c205cc82214f3594e2d50686730314f817c67ffa80fe800cf0db78c3c2b9d9e\"\n+checksum = \"2c2d7fd131800e0d63df52aff46201acaab70b431a4a1ec6f0343fe8e64f35a4\"\n dependencies = [\n  \"bitflags\",\n- \"getopts\",\n  \"memchr\",\n  \"unicase\",\n ]\n@@ -2641,18 +2663,24 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.29\"\n+version = \"2.1.31\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7a6d7ffceb4da3e0a29c18986f0469c209f4db3ab9f2ffe286eaa1104a3e5028\"\n+checksum = \"0ff33fa15ac0384376741d16ddb05a65263dde4e2c5d0f7a9f3747db788764aa\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n  \"derive_more\",\n- \"env_logger 0.6.2\",\n- \"humantime 1.3.0\",\n+ \"env_logger 0.7.1\",\n+ \"humantime 2.0.0\",\n  \"lazy_static 1.4.0\",\n  \"log\",\n  \"rls-span\",\n+ \"rustc-ap-rustc_ast_pretty\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_parse\",\n+ \"rustc-ap-rustc_session\",\n+ \"rustc-ap-rustc_span\",\n  \"rustc-ap-syntax\",\n ]\n \n@@ -2876,7 +2904,7 @@ dependencies = [\n  \"aho-corasick\",\n  \"memchr\",\n  \"regex-syntax\",\n- \"thread_local\",\n+ \"thread_local 0.3.6\",\n  \"utf8-ranges\",\n ]\n \n@@ -3033,7 +3061,6 @@ version = \"0.6.0\"\n dependencies = [\n  \"clippy_lints\",\n  \"env_logger 0.7.1\",\n- \"failure\",\n  \"futures\",\n  \"log\",\n  \"rand 0.7.3\",\n@@ -3084,12 +3111,10 @@ dependencies = [\n  \"bitflags\",\n  \"byteorder\",\n  \"chalk-engine\",\n- \"fmt_macros\",\n- \"graphviz\",\n  \"jobserver\",\n  \"log\",\n  \"measureme\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"polonius-engine\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -3112,85 +3137,136 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-arena\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7475f4c707269b56eb7144c53591e3cd6369a5aa1d66434829ea11df96d5e7e3\"\n+checksum = \"ea82fa3d9a8add7422228ca1a2cbba0784fa8861f56148ff64da08b3c7921b03\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n- \"smallvec 0.6.10\",\n+ \"smallvec 1.0.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-graphviz\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6e59a55520f140a70a3e0fad80a36e807caa85e9d7016167b91a5b521ea929be\"\n+checksum = \"638d0b2b3bcf99824e0cb5a25dbc547b61dc20942e11daf6a97e981918aa18e5\"\n+\n+[[package]]\n+name = \"rustc-ap-rustc_ast_pretty\"\n+version = \"642.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d38bab04dd676dee6d2f9670506a18c31bfce38bf7f8420aa83eb1140ecde049\"\n+dependencies = [\n+ \"log\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_span\",\n+ \"rustc-ap-syntax\",\n+]\n+\n+[[package]]\n+name = \"rustc-ap-rustc_attr\"\n+version = \"642.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"10b843ba8b1ed43739133047673b9f6a54d3b3b4d328d69c6ea89ff971395f35\"\n+dependencies = [\n+ \"rustc-ap-rustc_ast_pretty\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_feature\",\n+ \"rustc-ap-rustc_macros\",\n+ \"rustc-ap-rustc_session\",\n+ \"rustc-ap-rustc_span\",\n+ \"rustc-ap-serialize\",\n+ \"rustc-ap-syntax\",\n+ \"smallvec 1.0.0\",\n+]\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6420857d5a088f680ec1ba736ffba4ee9c1964b0d397e6318f38d461f4f7d5cb\"\n+checksum = \"dc3d1c6d0a80ab0c1df76405377cec0f3d5423fb5b0953a8eac70a2ad6c44df2\"\n dependencies = [\n+ \"bitflags\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.6.5\",\n  \"ena\",\n  \"indexmap\",\n  \"jobserver\",\n  \"lazy_static 1.4.0\",\n  \"log\",\n- \"parking_lot\",\n+ \"measureme\",\n+ \"parking_lot 0.9.0\",\n  \"rustc-ap-graphviz\",\n  \"rustc-ap-rustc_index\",\n  \"rustc-ap-serialize\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n- \"smallvec 0.6.10\",\n+ \"smallvec 1.0.0\",\n  \"stable_deref_trait\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8abfca0960131262254a91d02ff4903526a261ede730d7a2c75b4234c867cdc0\"\n+checksum = \"4909a1eca29331332257230f29120a8ff68c9e37d868c564fcd599e430cf8914\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_span\",\n  \"rustc-ap-serialize\",\n- \"rustc-ap-syntax_pos\",\n- \"term_size\",\n  \"termcolor\",\n+ \"termize\",\n  \"unicode-width\",\n+ \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"rustc-ap-rustc_feature\"\n+version = \"642.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"63ab887a181d795cf5fd3edadf367760deafb90aefb844f168ab5255266e3478\"\n+dependencies = [\n+ \"lazy_static 1.4.0\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_span\",\n+]\n+\n+[[package]]\n+name = \"rustc-ap-rustc_fs_util\"\n+version = \"642.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"70814116df3c5fbec8f06f6a1d013ca481f620fd22a9475754e9bf3ee9ba70d8\"\n+\n [[package]]\n name = \"rustc-ap-rustc_index\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5a395509dcb90a92c1479c085639594624e06b4ab3fc7c1b795b46a61f2d4f65\"\n+checksum = \"ac1bf1d3cf3d119d41353d6fd229ef7272d5097bc0924de021c0294bf86d48bf\"\n dependencies = [\n  \"rustc-ap-serialize\",\n- \"smallvec 0.6.10\",\n+ \"smallvec 1.0.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"64eac8a0e6efb8f55292aa24be0208c7c0538236c613e79952fd1fa3d54bcf8e\"\n+checksum = \"4cda21a32cebdc11ec4f5393aa2fcde5ed1b2f673a8571e5a4dcdf07e4ae9cac\"\n dependencies = [\n  \"unicode-xid 0.2.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f99795e8be4877e9e05d59f201e1740c1cf673364655def5848606d9e25b75af\"\n+checksum = \"75c47b48ea51910ecfd853c9248a9bf4c767bc823449ab6a1d864dff65fbae16\"\n dependencies = [\n  \"itertools 0.8.0\",\n  \"proc-macro2 1.0.3\",\n@@ -3200,63 +3276,102 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"rustc-ap-rustc_target\"\n-version = \"610.0.0\"\n+name = \"rustc-ap-rustc_parse\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f22e21fdd8e1c0030f507158fa79b9f1e080e6241aba994d0f97c14a0a07a826\"\n+checksum = \"abd88e89cd5b5d28dcd3a347a3d534c08627d9455570dc1a2d402cb8437b9d30\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n+ \"rustc-ap-rustc_ast_pretty\",\n+ \"rustc-ap-rustc_attr\",\n  \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_feature\",\n+ \"rustc-ap-rustc_lexer\",\n+ \"rustc-ap-rustc_session\",\n+ \"rustc-ap-rustc_span\",\n+ \"rustc-ap-syntax\",\n+ \"smallvec 1.0.0\",\n+ \"unicode-normalization\",\n+]\n+\n+[[package]]\n+name = \"rustc-ap-rustc_session\"\n+version = \"642.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5b8487b4575fbb2d1fc6f1cd61225efd108a4d36817e6fb9b643d57fcae9cb12\"\n+dependencies = [\n+ \"log\",\n+ \"num_cpus\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_feature\",\n+ \"rustc-ap-rustc_fs_util\",\n  \"rustc-ap-rustc_index\",\n+ \"rustc-ap-rustc_span\",\n+ \"rustc-ap-rustc_target\",\n  \"rustc-ap-serialize\",\n- \"rustc-ap-syntax_pos\",\n+ \"rustc-ap-syntax\",\n ]\n \n [[package]]\n-name = \"rustc-ap-serialize\"\n-version = \"610.0.0\"\n+name = \"rustc-ap-rustc_span\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb1cd6ef5135408d62559866e79986ca261f4c1333253d500e5e66fe66d1432e\"\n+checksum = \"f69746c0d4c21bf20a5bb2bd247261a1aa8631f04202d7303352942dde70d987\"\n dependencies = [\n- \"indexmap\",\n- \"smallvec 0.6.10\",\n+ \"cfg-if\",\n+ \"log\",\n+ \"rustc-ap-arena\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_index\",\n+ \"rustc-ap-rustc_macros\",\n+ \"rustc-ap-serialize\",\n+ \"scoped-tls\",\n+ \"unicode-width\",\n ]\n \n [[package]]\n-name = \"rustc-ap-syntax\"\n-version = \"610.0.0\"\n+name = \"rustc-ap-rustc_target\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61fc1c901d2cbd24cae95d7bc5a58aa7661ec3dc5320c78c32830a52a685c33c\"\n+checksum = \"8bbc6ae09b5d42ec66edd520e8412e0615c53a7c93607fe33dc4abab60ba7c8b\"\n dependencies = [\n  \"bitflags\",\n- \"lazy_static 1.4.0\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n- \"rustc-ap-rustc_errors\",\n  \"rustc-ap-rustc_index\",\n- \"rustc-ap-rustc_lexer\",\n- \"rustc-ap-rustc_target\",\n+ \"rustc-ap-rustc_macros\",\n+ \"rustc-ap-rustc_span\",\n  \"rustc-ap-serialize\",\n- \"rustc-ap-syntax_pos\",\n- \"scoped-tls\",\n- \"smallvec 0.6.10\",\n ]\n \n [[package]]\n-name = \"rustc-ap-syntax_pos\"\n-version = \"610.0.0\"\n+name = \"rustc-ap-serialize\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"230534f638255853bb9f13987537e00a818435a0cc54b68d97221b6822c8f1bc\"\n+checksum = \"e13a1ead0252fc3d96da4c336a95950be6795f2b00c84a67ccadf26142f8cb41\"\n dependencies = [\n- \"cfg-if\",\n- \"rustc-ap-arena\",\n+ \"indexmap\",\n+ \"smallvec 1.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc-ap-syntax\"\n+version = \"642.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e1f59f48ca3a2ec16a7e82e718ed5aadf9c9e08cf63015d28b4e774767524a6a\"\n+dependencies = [\n+ \"log\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_index\",\n+ \"rustc-ap-rustc_lexer\",\n  \"rustc-ap-rustc_macros\",\n+ \"rustc-ap-rustc_span\",\n  \"rustc-ap-serialize\",\n  \"scoped-tls\",\n- \"unicode-width\",\n+ \"smallvec 1.0.0\",\n ]\n \n [[package]]\n@@ -3442,6 +3557,7 @@ dependencies = [\n  \"flate2\",\n  \"libc\",\n  \"log\",\n+ \"measureme\",\n  \"rustc\",\n  \"rustc-demangle\",\n  \"rustc_attr\",\n@@ -3522,7 +3638,7 @@ dependencies = [\n  \"lazy_static 1.4.0\",\n  \"log\",\n  \"measureme\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -3542,6 +3658,7 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_ast_pretty\",\n+ \"rustc_codegen_ssa\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n@@ -3619,6 +3736,7 @@ version = \"0.0.0\"\n name = \"rustc_hir\"\n version = \"0.0.0\"\n dependencies = [\n+ \"lazy_static 1.4.0\",\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -3656,6 +3774,28 @@ dependencies = [\n  \"smallvec 1.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_infer\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"fmt_macros\",\n+ \"graphviz\",\n+ \"log\",\n+ \"rustc\",\n+ \"rustc_attr\",\n+ \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n+ \"rustc_errors\",\n+ \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"smallvec 1.0.0\",\n+ \"syntax\",\n+]\n+\n [[package]]\n name = \"rustc_interface\"\n version = \"0.0.0\"\n@@ -3676,6 +3816,7 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_hir\",\n  \"rustc_incremental\",\n+ \"rustc_infer\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n@@ -3718,6 +3859,7 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_infer\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3738,7 +3880,6 @@ dependencies = [\n name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n- \"itertools 0.8.0\",\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n  \"syn 1.0.11\",\n@@ -3788,6 +3929,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_infer\",\n  \"rustc_lexer\",\n  \"rustc_macros\",\n  \"rustc_span\",\n@@ -3802,7 +3944,6 @@ name = \"rustc_mir_build\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena\",\n- \"itertools 0.8.0\",\n  \"log\",\n  \"rustc\",\n  \"rustc_apfloat\",\n@@ -3811,6 +3952,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_infer\",\n  \"rustc_macros\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -3851,6 +3993,7 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_infer\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3901,6 +4044,7 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n+ \"rustc_infer\",\n  \"rustc_metadata\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -3990,6 +4134,7 @@ dependencies = [\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n+ \"rustc_infer\",\n  \"rustc_macros\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4005,7 +4150,9 @@ dependencies = [\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n+ \"rustc_infer\",\n  \"rustc_span\",\n+ \"rustc_target\",\n ]\n \n [[package]]\n@@ -4020,6 +4167,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_infer\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec 1.0.0\",\n@@ -4041,7 +4189,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"itertools 0.8.0\",\n  \"minifier\",\n- \"pulldown-cmark 0.5.3\",\n+ \"pulldown-cmark 0.7.0\",\n  \"rustc-rayon\",\n  \"serde\",\n  \"serde_json\",\n@@ -4095,7 +4243,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.11\"\n+version = \"1.4.12\"\n dependencies = [\n  \"annotate-snippets\",\n  \"bytecount\",\n@@ -4111,9 +4259,14 @@ dependencies = [\n  \"lazy_static 1.4.0\",\n  \"log\",\n  \"regex\",\n+ \"rustc-ap-rustc_ast_pretty\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_parse\",\n+ \"rustc-ap-rustc_session\",\n+ \"rustc-ap-rustc_span\",\n  \"rustc-ap-rustc_target\",\n  \"rustc-ap-syntax\",\n- \"rustc-ap-syntax_pos\",\n  \"rustc-workspace-hack\",\n  \"rustfmt-config_proc_macro\",\n  \"serde\",\n@@ -4547,9 +4700,9 @@ dependencies = [\n \n [[package]]\n name = \"tar\"\n-version = \"0.4.20\"\n+version = \"0.4.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a303ba60a099fcd2aaa646b14d2724591a96a75283e4b7ed3d1a1658909d9ae2\"\n+checksum = \"b3196bfbffbba3e57481b6ea32249fbaf590396a52505a2615adbb79d9d826d3\"\n dependencies = [\n  \"filetime\",\n  \"libc\",\n@@ -4601,17 +4754,6 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n-[[package]]\n-name = \"term_size\"\n-version = \"0.3.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9e5b9a66db815dcfd2da92db471106457082577c3c278d4138ab3e3b4e189327\"\n-dependencies = [\n- \"kernel32-sys\",\n- \"libc\",\n- \"winapi 0.2.8\",\n-]\n-\n [[package]]\n name = \"termcolor\"\n version = \"1.0.4\"\n@@ -4685,6 +4827,15 @@ dependencies = [\n  \"lazy_static 1.4.0\",\n ]\n \n+[[package]]\n+name = \"thread_local\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d40c6d1b69745a6ec6fb1ca717914848da4b44ae29d9b3080cbee91d72a69b14\"\n+dependencies = [\n+ \"lazy_static 1.4.0\",\n+]\n+\n [[package]]\n name = \"tidy\"\n version = \"0.1.0\"\n@@ -4839,7 +4990,7 @@ dependencies = [\n  \"log\",\n  \"mio\",\n  \"num_cpus\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"slab\",\n  \"tokio-executor\",\n  \"tokio-io\",\n@@ -5038,11 +5189,11 @@ checksum = \"535c204ee4d8434478593480b8f86ab45ec9aae0e83c568ca81abf0fd0e88f86\"\n \n [[package]]\n name = \"unicase\"\n-version = \"2.5.1\"\n+version = \"2.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2e2e6bd1e59e56598518beb94fd6db628ded570326f0a98c679a304bd9f00150\"\n+checksum = \"50f37be617794602aabbeee0be4f259dc1778fabe05e2d67ee8f79326d5cb4f6\"\n dependencies = [\n- \"version_check 0.1.5\",\n+ \"version_check\",\n ]\n \n [[package]]\n@@ -5212,12 +5363,6 @@ dependencies = [\n  \"failure\",\n ]\n \n-[[package]]\n-name = \"version_check\"\n-version = \"0.1.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"914b1a6776c4c929a602fafd8bc742e06365d4bcbe48c30f9cca5824f70dc9dd\"\n-\n [[package]]\n name = \"version_check\"\n version = \"0.9.1\""}, {"sha": "7e18f1befddecb3afc8ebbd4f9549912baa15c49", "filename": "RELEASES.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -95,6 +95,17 @@ Compatibility Notes\n [`CondVar::wait_timeout_while`]: https://doc.rust-lang.org/stable/std/sync/struct.Condvar.html#method.wait_timeout_while\n \n \n+Version 1.41.1 (2020-02-27)\n+===========================\n+\n+* [Always check types of static items][69145]\n+* [Always check lifetime bounds of `Copy` impls][69145]\n+* [Fix miscompilation in callers of `Layout::repeat`][69225]\n+\n+[69225]: https://github.com/rust-lang/rust/issues/69225\n+[69145]: https://github.com/rust-lang/rust/pull/69145\n+\n+\n Version 1.41.0 (2020-01-30)\n ===========================\n "}, {"sha": "9b7327ea69e0b1663f3c83b5ed6f9f0bacf36ed0", "filename": "config.toml.example", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -395,6 +395,15 @@\n # rustc to execute.\n #lld = false\n \n+# Indicates whether LLD will be used to link Rust crates during bootstrap on\n+# supported platforms. The LLD from the bootstrap distribution will be used\n+# and not the LLD compiled during the bootstrap.\n+#\n+# LLD will not be used if we're cross linking or running tests.\n+#\n+# Explicitly setting the linker for a target will override this option.\n+#use-lld = false\n+\n # Indicates whether some LLVM tools, like llvm-objdump, will be made available in the\n # sysroot.\n #llvm-tools = false\n@@ -435,6 +444,10 @@\n # Use LLVM libunwind as the implementation for Rust's unwinder.\n #llvm-libunwind = false\n \n+# Enable Windows Control Flow Guard checks in the standard library.\n+# This only applies from stage 1 onwards, and only for Windows targets.\n+#control-flow-guard = false\n+\n # =============================================================================\n # Options for specific targets\n #\n@@ -463,6 +476,7 @@\n # Linker to be used to link Rust code. Note that the\n # default value is platform specific, and if not specified it may also depend on\n # what platform is crossing to what platform.\n+# Setting this will override the `use-lld` option for Rust code.\n #linker = \"cc\"\n \n # Path to the `llvm-config` binary of the installation of a custom LLVM to link"}, {"sha": "8f4c901fb9740919dae8d6b72a8e122a97250317", "filename": "rustfmt.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -7,6 +7,7 @@ merge_derives = false\n # tidy only checks files which are not ignored, each entry follows gitignore style\n ignore = [\n     \"build\",\n+    \"/vendor/\",\n \n     # tests for now are not formatted, as they are sometimes pretty-printing constrained\n     # (and generally rustfmt can move around comments in UI-testing incompatible ways)"}, {"sha": "daa030c59d64139cf19951f3b6d63fcb4abba553", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -134,6 +134,11 @@ fn main() {\n             cmd.arg(format!(\"-Clinker={}\", host_linker));\n         }\n \n+        // Override linker flavor if necessary.\n+        if let Ok(host_linker_flavor) = env::var(\"RUSTC_HOST_LINKER_FLAVOR\") {\n+            cmd.arg(format!(\"-Clinker-flavor={}\", host_linker_flavor));\n+        }\n+\n         if let Ok(s) = env::var(\"RUSTC_HOST_CRT_STATIC\") {\n             if s == \"true\" {\n                 cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");"}, {"sha": "50e1726240fffd29936c469d15386e60fad3a52b", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -80,7 +80,7 @@ def _download(path, url, probably_big, verbose, exception):\n             option = \"-s\"\n         run([\"curl\", option,\n              \"-y\", \"30\", \"-Y\", \"10\",    # timeout if speed is < 10 bytes/sec for > 30 seconds\n-             \"--connect-timeout\", \"30\", # timeout if cannot connect within 30 seconds\n+             \"--connect-timeout\", \"30\",  # timeout if cannot connect within 30 seconds\n              \"--retry\", \"3\", \"-Sf\", \"-o\", path, url],\n             verbose=verbose,\n             exception=exception)\n@@ -332,7 +332,6 @@ def __init__(self):\n         self.use_vendored_sources = ''\n         self.verbose = False\n \n-\n     def download_stage0(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n \n@@ -351,7 +350,7 @@ def support_xz():\n             try:\n                 with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n                     temp_path = temp_file.name\n-                with tarfile.open(temp_path, \"w:xz\") as tar:\n+                with tarfile.open(temp_path, \"w:xz\"):\n                     pass\n                 return True\n             except tarfile.CompressionError:\n@@ -825,7 +824,7 @@ def check_vendored_status(self):\n                 if not os.path.exists(vendor_dir):\n                     print('error: vendoring required, but vendor directory does not exist.')\n                     print('       Run `cargo vendor` without sudo to initialize the '\n-                        'vendor directory.')\n+                          'vendor directory.')\n                     raise Exception(\"{} not found\".format(vendor_dir))\n \n         if self.use_vendored_sources:\n@@ -839,7 +838,7 @@ def check_vendored_status(self):\n                     \"\\n\"\n                     \"[source.vendored-sources]\\n\"\n                     \"directory = '{}/vendor'\\n\"\n-                .format(self.rust_root))\n+                    .format(self.rust_root))\n         else:\n             if os.path.exists('.cargo'):\n                 shutil.rmtree('.cargo')"}, {"sha": "e4b57cddfb891e86e1ed005d0e996216e230010f", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -692,7 +692,7 @@ impl<'a> Builder<'a> {\n         cmd.env_remove(\"MAKEFLAGS\");\n         cmd.env_remove(\"MFLAGS\");\n \n-        if let Some(linker) = self.linker(compiler.host) {\n+        if let Some(linker) = self.linker(compiler.host, true) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n         cmd\n@@ -952,10 +952,31 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        if let Some(host_linker) = self.linker(compiler.host) {\n+        // FIXME: Don't use LLD if we're compiling libtest, since it fails to link it.\n+        // See https://github.com/rust-lang/rust/issues/68647.\n+        let can_use_lld = mode != Mode::Std;\n+\n+        // FIXME: The beta compiler doesn't pick the `lld-link` flavor for `*-pc-windows-msvc`\n+        // Remove `RUSTC_HOST_LINKER_FLAVOR` when this is fixed\n+        let lld_linker_flavor = |linker: &Path, target: Interned<String>| {\n+            compiler.stage == 0\n+                && linker.file_name() == Some(OsStr::new(\"rust-lld\"))\n+                && target.contains(\"pc-windows-msvc\")\n+        };\n+\n+        if let Some(host_linker) = self.linker(compiler.host, can_use_lld) {\n+            if lld_linker_flavor(host_linker, compiler.host) {\n+                cargo.env(\"RUSTC_HOST_LINKER_FLAVOR\", \"lld-link\");\n+            }\n+\n             cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n         }\n-        if let Some(target_linker) = self.linker(target) {\n+\n+        if let Some(target_linker) = self.linker(target, can_use_lld) {\n+            if lld_linker_flavor(target_linker, target) {\n+                rustflags.arg(\"-Clinker-flavor=lld-link\");\n+            }\n+\n             let target = crate::envify(&target);\n             cargo.env(&format!(\"CARGO_TARGET_{}_LINKER\", target), target_linker);\n         }\n@@ -1114,6 +1135,20 @@ impl<'a> Builder<'a> {\n             );\n         }\n \n+        // If Control Flow Guard is enabled, pass the `control_flow_guard=checks` flag to rustc\n+        // when compiling the standard library, since this might be linked into the final outputs\n+        // produced by rustc. Since this mitigation is only available on Windows, only enable it\n+        // for the standard library in case the compiler is run on a non-Windows platform.\n+        // This is not needed for stage 0 artifacts because these will only be used for building\n+        // the stage 1 compiler.\n+        if cfg!(windows)\n+            && mode == Mode::Std\n+            && self.config.control_flow_guard\n+            && compiler.stage >= 1\n+        {\n+            rustflags.arg(\"-Zcontrol_flow_guard=checks\");\n+        }\n+\n         // For `cargo doc` invocations, make rustdoc print the Rust version into the docs\n         cargo.env(\"RUSTDOC_CRATE_VERSION\", self.rust_version());\n "}, {"sha": "746cddbabd6397469cf9292d9618eee52cf722a3", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -82,6 +82,7 @@ pub struct Config {\n     pub llvm_use_linker: Option<String>,\n     pub llvm_allow_old_toolchain: Option<bool>,\n \n+    pub use_lld: bool,\n     pub lld_enabled: bool,\n     pub lldb_enabled: bool,\n     pub llvm_tools_enabled: bool,\n@@ -115,6 +116,7 @@ pub struct Config {\n     pub targets: Vec<Interned<String>>,\n     pub local_rebuild: bool,\n     pub jemalloc: bool,\n+    pub control_flow_guard: bool,\n \n     // dist misc\n     pub dist_sign_folder: Option<PathBuf>,\n@@ -175,6 +177,15 @@ pub struct Target {\n     pub no_std: bool,\n }\n \n+impl Target {\n+    pub fn from_triple(triple: &str) -> Self {\n+        let mut target: Self = Default::default();\n+        if triple.contains(\"-none-\") || triple.contains(\"nvptx\") {\n+            target.no_std = true;\n+        }\n+        target\n+    }\n+}\n /// Structure of the `config.toml` file that configuration is read from.\n ///\n /// This structure uses `Decodable` to automatically decode a TOML configuration\n@@ -321,6 +332,7 @@ struct Rust {\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n     lld: Option<bool>,\n+    use_lld: Option<bool>,\n     llvm_tools: Option<bool>,\n     lldb: Option<bool>,\n     deny_warnings: Option<bool>,\n@@ -331,6 +343,7 @@ struct Rust {\n     jemalloc: Option<bool>,\n     test_compare_mode: Option<bool>,\n     llvm_libunwind: Option<bool>,\n+    control_flow_guard: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -349,6 +362,7 @@ struct TomlTarget {\n     musl_root: Option<String>,\n     wasi_root: Option<String>,\n     qemu_rootfs: Option<String>,\n+    no_std: Option<bool>,\n }\n \n impl Config {\n@@ -565,6 +579,7 @@ impl Config {\n             if let Some(true) = rust.incremental {\n                 config.incremental = true;\n             }\n+            set(&mut config.use_lld, rust.use_lld);\n             set(&mut config.lld_enabled, rust.lld);\n             set(&mut config.lldb_enabled, rust.lldb);\n             set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n@@ -577,6 +592,7 @@ impl Config {\n             set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n             config.rust_thin_lto_import_instr_limit = rust.thin_lto_import_instr_limit;\n             set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n+            set(&mut config.control_flow_guard, rust.control_flow_guard);\n \n             if let Some(ref backends) = rust.codegen_backends {\n                 config.rust_codegen_backends =\n@@ -589,7 +605,7 @@ impl Config {\n \n         if let Some(ref t) = toml.target {\n             for (triple, cfg) in t {\n-                let mut target = Target::default();\n+                let mut target = Target::from_triple(triple);\n \n                 if let Some(ref s) = cfg.llvm_config {\n                     target.llvm_config = Some(config.src.join(s));\n@@ -600,6 +616,9 @@ impl Config {\n                 if let Some(ref s) = cfg.android_ndk {\n                     target.ndk = Some(config.src.join(s));\n                 }\n+                if let Some(s) = cfg.no_std {\n+                    target.no_std = s;\n+                }\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n                 target.cxx = cfg.cxx.clone().map(PathBuf::from);\n                 target.ar = cfg.ar.clone().map(PathBuf::from);"}, {"sha": "2a46c563d1f8792c2dd8a777aa0b1ce8897eda53", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -60,10 +60,11 @@ def v(*args):\n o(\"lldb\", \"rust.lldb\", \"build lldb\")\n o(\"missing-tools\", \"dist.missing-tools\", \"allow failures when building tools\")\n o(\"use-libcxx\", \"llvm.use-libcxx\", \"build LLVM with libc++\")\n+o(\"control-flow-guard\", \"rust.control-flow-guard\", \"Enable Control Flow Guard\")\n \n-o(\"cflags\", \"llvm.cflags\", \"build LLVM with these extra compiler flags\")\n-o(\"cxxflags\", \"llvm.cxxflags\", \"build LLVM with these extra compiler flags\")\n-o(\"ldflags\", \"llvm.ldflags\", \"build LLVM with these extra linker flags\")\n+v(\"llvm-cflags\", \"llvm.cflags\", \"build LLVM with these extra compiler flags\")\n+v(\"llvm-cxxflags\", \"llvm.cxxflags\", \"build LLVM with these extra compiler flags\")\n+v(\"llvm-ldflags\", \"llvm.ldflags\", \"build LLVM with these extra linker flags\")\n \n o(\"llvm-libunwind\", \"rust.llvm-libunwind\", \"use LLVM libunwind\")\n \n@@ -392,11 +393,12 @@ def set(key, value):\n \n \n def is_number(value):\n-  try:\n-    float(value)\n-    return True\n-  except ValueError:\n-    return False\n+    try:\n+        float(value)\n+        return True\n+    except ValueError:\n+        return False\n+\n \n # Here we walk through the constructed configuration we have from the parsed\n # command line arguments. We then apply each piece of configuration by"}, {"sha": "a476d25f10214116918d3447ea9f60cab8966280", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -103,7 +103,6 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-#![feature(core_intrinsics)]\n #![feature(drain_filter)]\n \n use std::cell::{Cell, RefCell};\n@@ -239,9 +238,10 @@ pub struct Build {\n     hosts: Vec<Interned<String>>,\n     targets: Vec<Interned<String>>,\n \n-    // Stage 0 (downloaded) compiler and cargo or their local rust equivalents\n+    // Stage 0 (downloaded) compiler, lld and cargo or their local rust equivalents\n     initial_rustc: PathBuf,\n     initial_cargo: PathBuf,\n+    initial_lld: PathBuf,\n \n     // Runtime state filled in later on\n     // C/C++ compilers and archiver for all targets\n@@ -343,9 +343,18 @@ impl Build {\n         // we always try to use git for LLVM builds\n         let in_tree_llvm_info = channel::GitInfo::new(false, &src.join(\"src/llvm-project\"));\n \n+        let initial_sysroot = config.initial_rustc.parent().unwrap().parent().unwrap();\n+        let initial_lld = initial_sysroot\n+            .join(\"lib\")\n+            .join(\"rustlib\")\n+            .join(config.build)\n+            .join(\"bin\")\n+            .join(\"rust-lld\");\n+\n         let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n+            initial_lld,\n             local_rebuild: config.local_rebuild,\n             fail_fast: config.cmd.fail_fast(),\n             doc_tests: config.cmd.doc_tests(),\n@@ -810,7 +819,7 @@ impl Build {\n     }\n \n     /// Returns the path to the linker for the given target if it needs to be overridden.\n-    fn linker(&self, target: Interned<String>) -> Option<&Path> {\n+    fn linker(&self, target: Interned<String>, can_use_lld: bool) -> Option<&Path> {\n         if let Some(linker) = self.config.target_config.get(&target).and_then(|c| c.linker.as_ref())\n         {\n             Some(linker)\n@@ -819,6 +828,8 @@ impl Build {\n             && !target.contains(\"msvc\")\n         {\n             Some(self.cc(target))\n+        } else if can_use_lld && self.config.use_lld && self.build == target {\n+            Some(&self.initial_lld)\n         } else {\n             None\n         }"}, {"sha": "21dcb1d8aa0e1bc2a7908d6a9cbc09209b54fd9e", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -262,7 +262,7 @@ impl Step for Llvm {\n             cfg.define(\"PYTHON_EXECUTABLE\", python);\n         }\n \n-        configure_cmake(builder, target, &mut cfg);\n+        configure_cmake(builder, target, &mut cfg, true);\n \n         // FIXME: we don't actually need to build all LLVM tools and all LLVM\n         //        libraries here, e.g., we just want a few components and a few\n@@ -301,7 +301,12 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     panic!(\"\\n\\nbad LLVM version: {}, need >=7.0\\n\\n\", version)\n }\n \n-fn configure_cmake(builder: &Builder<'_>, target: Interned<String>, cfg: &mut cmake::Config) {\n+fn configure_cmake(\n+    builder: &Builder<'_>,\n+    target: Interned<String>,\n+    cfg: &mut cmake::Config,\n+    use_compiler_launcher: bool,\n+) {\n     // Do not print installation messages for up-to-date files.\n     // LLVM and LLD builds can produce a lot of those and hit CI limits on log size.\n     cfg.define(\"CMAKE_INSTALL_MESSAGE\", \"LAZY\");\n@@ -372,9 +377,11 @@ fn configure_cmake(builder: &Builder<'_>, target: Interned<String>, cfg: &mut cm\n     } else {\n         // If ccache is configured we inform the build a little differently how\n         // to invoke ccache while also invoking our compilers.\n-        if let Some(ref ccache) = builder.config.ccache {\n-            cfg.define(\"CMAKE_C_COMPILER_LAUNCHER\", ccache)\n-                .define(\"CMAKE_CXX_COMPILER_LAUNCHER\", ccache);\n+        if use_compiler_launcher {\n+            if let Some(ref ccache) = builder.config.ccache {\n+                cfg.define(\"CMAKE_C_COMPILER_LAUNCHER\", ccache)\n+                    .define(\"CMAKE_CXX_COMPILER_LAUNCHER\", ccache);\n+            }\n         }\n         cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n             .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n@@ -458,7 +465,7 @@ impl Step for Lld {\n         t!(fs::create_dir_all(&out_dir));\n \n         let mut cfg = cmake::Config::new(builder.src.join(\"src/llvm-project/lld\"));\n-        configure_cmake(builder, target, &mut cfg);\n+        configure_cmake(builder, target, &mut cfg, true);\n \n         // This is an awful, awful hack. Discovered when we migrated to using\n         // clang-cl to compile LLVM/LLD it turns out that LLD, when built out of\n@@ -571,7 +578,7 @@ impl Step for Sanitizers {\n         }\n \n         let out_dir = builder.native_dir(self.target).join(\"sanitizers\");\n-        let runtimes = supported_sanitizers(&out_dir, self.target);\n+        let runtimes = supported_sanitizers(&out_dir, self.target, &builder.config.channel);\n         if runtimes.is_empty() {\n             return runtimes;\n         }\n@@ -595,10 +602,7 @@ impl Step for Sanitizers {\n         let _time = util::timeit(&builder);\n \n         let mut cfg = cmake::Config::new(&compiler_rt_dir);\n-        cfg.target(&self.target);\n-        cfg.host(&builder.config.build);\n         cfg.profile(\"Release\");\n-\n         cfg.define(\"CMAKE_C_COMPILER_TARGET\", self.target);\n         cfg.define(\"COMPILER_RT_BUILD_BUILTINS\", \"OFF\");\n         cfg.define(\"COMPILER_RT_BUILD_CRT\", \"OFF\");\n@@ -610,6 +614,12 @@ impl Step for Sanitizers {\n         cfg.define(\"COMPILER_RT_USE_LIBCXX\", \"OFF\");\n         cfg.define(\"LLVM_CONFIG_PATH\", &llvm_config);\n \n+        // On Darwin targets the sanitizer runtimes are build as universal binaries.\n+        // Unfortunately sccache currently lacks support to build them successfully.\n+        // Disable compiler launcher on Darwin targets to avoid potential issues.\n+        let use_compiler_launcher = !self.target.contains(\"apple-darwin\");\n+        configure_cmake(builder, self.target, &mut cfg, use_compiler_launcher);\n+\n         t!(fs::create_dir_all(&out_dir));\n         cfg.out_dir(out_dir);\n \n@@ -635,7 +645,11 @@ pub struct SanitizerRuntime {\n }\n \n /// Returns sanitizers available on a given target.\n-fn supported_sanitizers(out_dir: &Path, target: Interned<String>) -> Vec<SanitizerRuntime> {\n+fn supported_sanitizers(\n+    out_dir: &Path,\n+    target: Interned<String>,\n+    channel: &str,\n+) -> Vec<SanitizerRuntime> {\n     let mut result = Vec::new();\n     match &*target {\n         \"x86_64-apple-darwin\" => {\n@@ -644,7 +658,7 @@ fn supported_sanitizers(out_dir: &Path, target: Interned<String>) -> Vec<Sanitiz\n                     cmake_target: format!(\"clang_rt.{}_osx_dynamic\", s),\n                     path: out_dir\n                         .join(&format!(\"build/lib/darwin/libclang_rt.{}_osx_dynamic.dylib\", s)),\n-                    name: format!(\"librustc_rt.{}.dylib\", s),\n+                    name: format!(\"librustc-{}_rt.{}.dylib\", channel, s),\n                 });\n             }\n         }\n@@ -653,7 +667,7 @@ fn supported_sanitizers(out_dir: &Path, target: Interned<String>) -> Vec<Sanitiz\n                 result.push(SanitizerRuntime {\n                     cmake_target: format!(\"clang_rt.{}-x86_64\", s),\n                     path: out_dir.join(&format!(\"build/lib/linux/libclang_rt.{}-x86_64.a\", s)),\n-                    name: format!(\"librustc_rt.{}.a\", s),\n+                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n                 });\n             }\n         }\n@@ -662,7 +676,7 @@ fn supported_sanitizers(out_dir: &Path, target: Interned<String>) -> Vec<Sanitiz\n                 result.push(SanitizerRuntime {\n                     cmake_target: format!(\"clang_rt.{}-x86_64\", s),\n                     path: out_dir.join(&format!(\"build/lib/fuchsia/libclang_rt.{}-x86_64.a\", s)),\n-                    name: format!(\"librustc_rt.{}.a\", s),\n+                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n                 });\n             }\n         }\n@@ -671,7 +685,7 @@ fn supported_sanitizers(out_dir: &Path, target: Interned<String>) -> Vec<Sanitiz\n                 result.push(SanitizerRuntime {\n                     cmake_target: format!(\"clang_rt.{}-aarch64\", s),\n                     path: out_dir.join(&format!(\"build/lib/fuchsia/libclang_rt.{}-aarch64.a\", s)),\n-                    name: format!(\"librustc_rt.{}.a\", s),\n+                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n                 });\n             }\n         }"}, {"sha": "530e74da8cac0d9b4703a39effd2c836e9b4aa1d", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -17,6 +17,7 @@ use std::process::Command;\n \n use build_helper::{output, t};\n \n+use crate::config::Target;\n use crate::Build;\n \n struct Finder {\n@@ -192,13 +193,9 @@ pub fn check(build: &mut Build) {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n-        if target.contains(\"-none-\") || target.contains(\"nvptx\") {\n-            if build.no_std(*target).is_none() {\n-                let target = build.config.target_config.entry(target.clone()).or_default();\n-\n-                target.no_std = true;\n-            }\n+        build.config.target_config.entry(target.clone()).or_insert(Target::from_triple(target));\n \n+        if target.contains(\"-none-\") || target.contains(\"nvptx\") {\n             if build.no_std(*target) == Some(false) {\n                 panic!(\"All the *-none-* and nvptx* targets are no-std targets\")\n             }"}, {"sha": "4cfda606c4bc8a45a4b977a5a8dcbc84ee4de177", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 71, "deletions": 34, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -388,6 +388,8 @@ impl Step for Miri {\n             cargo.env(\"XARGO_RUST_SRC\", builder.src.join(\"src\"));\n             // Debug things.\n             cargo.env(\"RUST_BACKTRACE\", \"1\");\n+            // Overwrite bootstrap's `rustc` wrapper overwriting our flags.\n+            cargo.env(\"RUSTC_DEBUG_ASSERTIONS\", \"true\");\n             // Let cargo-miri know where xargo ended up.\n             cargo.env(\"XARGO\", builder.out.join(\"bin\").join(\"xargo\"));\n \n@@ -397,7 +399,7 @@ impl Step for Miri {\n             }\n \n             // # Determine where Miri put its sysroot.\n-            // To this end, we run `cargo miri setup --env` and capture the output.\n+            // To this end, we run `cargo miri setup --print-sysroot` and capture the output.\n             // (We do this separately from the above so that when the setup actually\n             // happens we get some output.)\n             // We re-use the `cargo` from above.\n@@ -596,7 +598,7 @@ impl Step for RustdocTheme {\n             .env(\"RUSTDOC_REAL\", builder.rustdoc(self.compiler))\n             .env(\"RUSTDOC_CRATE_VERSION\", builder.rust_version())\n             .env(\"RUSTC_BOOTSTRAP\", \"1\");\n-        if let Some(linker) = builder.linker(self.compiler.host) {\n+        if let Some(linker) = builder.linker(self.compiler.host, true) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n         try_run(builder, &mut cmd);\n@@ -662,7 +664,7 @@ impl Step for RustdocJSNotStd {\n                 target: self.target,\n                 mode: \"js-doc-test\",\n                 suite: \"rustdoc-js\",\n-                path: None,\n+                path: \"src/test/rustdoc-js\",\n                 compare_mode: None,\n             });\n         } else {\n@@ -698,7 +700,7 @@ impl Step for RustdocUi {\n             target: self.target,\n             mode: \"ui\",\n             suite: \"rustdoc-ui\",\n-            path: Some(\"src/test/rustdoc-ui\"),\n+            path: \"src/test/rustdoc-ui\",\n             compare_mode: None,\n         })\n     }\n@@ -843,7 +845,7 @@ macro_rules! test_definitions {\n                     target: self.target,\n                     mode: $mode,\n                     suite: $suite,\n-                    path: Some($path),\n+                    path: $path,\n                     compare_mode: $compare_mode,\n                 })\n             }\n@@ -926,7 +928,7 @@ struct Compiletest {\n     target: Interned<String>,\n     mode: &'static str,\n     suite: &'static str,\n-    path: Option<&'static str>,\n+    path: &'static str,\n     compare_mode: Option<&'static str>,\n }\n \n@@ -949,7 +951,7 @@ impl Step for Compiletest {\n         let suite = self.suite;\n \n         // Path for test suite\n-        let suite_path = self.path.unwrap_or(\"\");\n+        let suite_path = self.path;\n \n         // Skip codegen tests if they aren't enabled in configuration.\n         if !builder.config.codegen_tests && suite == \"codegen\" {\n@@ -1035,7 +1037,8 @@ impl Step for Compiletest {\n         flags.push(\"-Zunstable-options\".to_string());\n         flags.push(builder.config.cmd.rustc_args().join(\" \"));\n \n-        if let Some(linker) = builder.linker(target) {\n+        // Don't use LLD here since we want to test that rustc finds and uses a linker by itself.\n+        if let Some(linker) = builder.linker(target, false) {\n             cmd.arg(\"--linker\").arg(linker);\n         }\n \n@@ -1050,10 +1053,10 @@ impl Step for Compiletest {\n         cmd.arg(\"--docck-python\").arg(builder.python());\n \n         if builder.config.build.ends_with(\"apple-darwin\") {\n-            // Force /usr/bin/python on macOS for LLDB tests because we're loading the\n+            // Force /usr/bin/python3 on macOS for LLDB tests because we're loading the\n             // LLDB plugin's compiled module which only works with the system python\n             // (namely not Homebrew-installed python)\n-            cmd.arg(\"--lldb-python\").arg(\"/usr/bin/python\");\n+            cmd.arg(\"--lldb-python\").arg(\"/usr/bin/python3\");\n         } else {\n             cmd.arg(\"--lldb-python\").arg(builder.python());\n         }\n@@ -1263,28 +1266,75 @@ impl Step for Compiletest {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-struct DocTest {\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+struct BookTest {\n     compiler: Compiler,\n-    path: &'static str,\n+    path: PathBuf,\n     name: &'static str,\n     is_ext_doc: bool,\n }\n \n-impl Step for DocTest {\n+impl Step for BookTest {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n-    /// Runs `rustdoc --test` for all documentation in `src/doc`.\n+    /// Runs the documentation tests for a book in `src/doc`.\n     ///\n-    /// This will run all tests in our markdown documentation (e.g., the book)\n-    /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n-    /// `compiler`.\n+    /// This uses the `rustdoc` that sits next to `compiler`.\n     fn run(self, builder: &Builder<'_>) {\n+        // External docs are different from local because:\n+        // - Some books need pre-processing by mdbook before being tested.\n+        // - They need to save their state to toolstate.\n+        // - They are only tested on the \"checktools\" builders.\n+        //\n+        // The local docs are tested by default, and we don't want to pay the\n+        // cost of building mdbook, so they use `rustdoc --test` directly.\n+        // Also, the unstable book is special because SUMMARY.md is generated,\n+        // so it is easier to just run `rustdoc` on its files.\n+        if self.is_ext_doc {\n+            self.run_ext_doc(builder);\n+        } else {\n+            self.run_local_doc(builder);\n+        }\n+    }\n+}\n+\n+impl BookTest {\n+    /// This runs the equivalent of `mdbook test` (via the rustbook wrapper)\n+    /// which in turn runs `rustdoc --test` on each file in the book.\n+    fn run_ext_doc(self, builder: &Builder<'_>) {\n+        let compiler = self.compiler;\n+\n+        builder.ensure(compile::Std { compiler, target: compiler.host });\n+\n+        // mdbook just executes a binary named \"rustdoc\", so we need to update\n+        // PATH so that it points to our rustdoc.\n+        let mut rustdoc_path = builder.rustdoc(compiler);\n+        rustdoc_path.pop();\n+        let old_path = env::var_os(\"PATH\").unwrap_or_default();\n+        let new_path = env::join_paths(iter::once(rustdoc_path).chain(env::split_paths(&old_path)))\n+            .expect(\"could not add rustdoc to PATH\");\n+\n+        let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n+        let path = builder.src.join(&self.path);\n+        rustbook_cmd.env(\"PATH\", new_path).arg(\"test\").arg(path);\n+        builder.add_rust_test_threads(&mut rustbook_cmd);\n+        builder.info(&format!(\"Testing rustbook {}\", self.path.display()));\n+        let _time = util::timeit(&builder);\n+        let toolstate = if try_run(builder, &mut rustbook_cmd) {\n+            ToolState::TestPass\n+        } else {\n+            ToolState::TestFail\n+        };\n+        builder.save_toolstate(self.name, toolstate);\n+    }\n+\n+    /// This runs `rustdoc --test` on all `.md` files in the path.\n+    fn run_local_doc(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n         builder.ensure(compile::Std { compiler, target: compiler.host });\n@@ -1293,7 +1343,6 @@ impl Step for DocTest {\n         // tests for all files that end in `*.md`\n         let mut stack = vec![builder.src.join(self.path)];\n         let _time = util::timeit(&builder);\n-\n         let mut files = Vec::new();\n         while let Some(p) = stack.pop() {\n             if p.is_dir() {\n@@ -1305,25 +1354,13 @@ impl Step for DocTest {\n                 continue;\n             }\n \n-            // The nostarch directory in the book is for no starch, and so isn't\n-            // guaranteed to builder. We don't care if it doesn't build, so skip it.\n-            if p.to_str().map_or(false, |p| p.contains(\"nostarch\")) {\n-                continue;\n-            }\n-\n             files.push(p);\n         }\n \n         files.sort();\n \n-        let mut toolstate = ToolState::TestPass;\n         for file in files {\n-            if !markdown_test(builder, compiler, &file) {\n-                toolstate = ToolState::TestFail;\n-            }\n-        }\n-        if self.is_ext_doc {\n-            builder.save_toolstate(self.name, toolstate);\n+            markdown_test(builder, compiler, &file);\n         }\n     }\n }\n@@ -1352,9 +1389,9 @@ macro_rules! test_book {\n                 }\n \n                 fn run(self, builder: &Builder<'_>) {\n-                    builder.ensure(DocTest {\n+                    builder.ensure(BookTest {\n                         compiler: self.compiler,\n-                        path: $path,\n+                        path: PathBuf::from($path),\n                         name: $book_name,\n                         is_ext_doc: !$default,\n                     });"}, {"sha": "74b7469ea27b7f64de3063543aa8092a8bc75e4d", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -63,7 +63,7 @@ jobs:\n - job: macOS\n   timeoutInMinutes: 600\n   pool:\n-    vmImage: macos-10.13\n+    vmImage: macos-10.15\n   steps:\n   - template: steps/run.yml\n   strategy:"}, {"sha": "ee9425aa1c51f94afabe6876bf67ce166e5ed75b", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -31,6 +31,9 @@ steps:\n - bash: src/ci/scripts/setup-environment.sh\n   displayName: Setup environment\n \n+- bash: src/ci/scripts/clean-disk.sh\n+  displayName: Clean disk\n+\n - bash: src/ci/scripts/should-skip-this.sh\n   displayName: Decide whether to run this job\n \n@@ -48,10 +51,6 @@ steps:\n   displayName: Install clang\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n-- bash: src/ci/scripts/switch-xcode.sh\n-  displayName: Switch to Xcode 9.3\n-  condition: and(succeeded(), not(variables.SKIP_JOB))\n-\n - bash: src/ci/scripts/install-wix.sh\n   displayName: Install wix\n   condition: and(succeeded(), not(variables.SKIP_JOB))"}, {"sha": "f8ddf0eb46cfd1d23b29f01960ad17962724d33c", "filename": "src/ci/azure-pipelines/try.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fazure-pipelines%2Ftry.yml", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fazure-pipelines%2Ftry.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Ftry.yml?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -25,7 +25,7 @@ jobs:\n # - job: macOS\n #   timeoutInMinutes: 600\n #   pool:\n-#     vmImage: macos-10.13\n+#     vmImage: macos-10.15\n #   steps:\n #   - template: steps/run.yml\n #   strategy:"}, {"sha": "78ac060368193964fb3fb8420e63894810802863", "filename": "src/ci/cpu-usage-over-time.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fcpu-usage-over-time.py", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fcpu-usage-over-time.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fcpu-usage-over-time.py?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -148,11 +148,11 @@ def idle_since(self, prev):\n     print('unknown platform', sys.platform)\n     sys.exit(1)\n \n-cur_state = State();\n+cur_state = State()\n print(\"Time,Idle\")\n while True:\n-    time.sleep(1);\n-    next_state = State();\n+    time.sleep(1)\n+    next_state = State()\n     now = datetime.datetime.utcnow().isoformat()\n     idle = next_state.idle_since(cur_state)\n     print(\"%s,%s\" % (now, idle))"}, {"sha": "5bb5436bec59d3faafa838e5d3fb32b232a17292", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -48,7 +48,7 @@ RUN /tmp/build-solaris-toolchain.sh sparcv9 sparcv9 solaris-sparc\n COPY dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh /tmp/\n # We pass the commit id of the port of LLVM's libunwind to the build script.\n # Any update to the commit id here, should cause the container image to be re-built from this point on.\n-RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh \"53b586346f2c7870e20b170decdc30729d97c42b\"\n+RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh \"5125c169b30837208a842f85f7ae44a83533bd0e\"\n \n COPY dist-various-2/build-wasi-toolchain.sh /tmp/\n RUN /tmp/build-wasi-toolchain.sh"}, {"sha": "c50de37c492b422decb2542a70afd7c8fd93f4b1", "filename": "src/ci/scripts/clean-disk.sh", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fscripts%2Fclean-disk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fscripts%2Fclean-disk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fclean-disk.sh?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -0,0 +1,16 @@\n+#!/bin/bash\n+# This script deletes some of the Azure-provided artifacts. We don't use these,\n+# and disk space is at a premium on our builders.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+# All the Linux builds happen inside Docker.\n+if isLinux; then\n+    # 6.7GB\n+    sudo rm -rf /opt/ghc\n+    # 16GB\n+    sudo rm -rf /usr/share/dotnet\n+fi"}, {"sha": "c242f5d4562690ba8f0c310bd86df305cee523ef", "filename": "src/ci/scripts/install-clang.sh", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fscripts%2Finstall-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fci%2Fscripts%2Finstall-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-clang.sh?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -19,9 +19,7 @@ if isMacOS; then\n     # native clang is configured to use the correct path, but our custom one\n     # doesn't. This sets the SDKROOT environment variable to the SDK so that\n     # our own clang can figure out the correct include path on its own.\n-    if ! [[ -d \"/usr/include\" ]]; then\n-        ciCommandSetEnv SDKROOT \"$(xcrun --sdk macosx --show-sdk-path)\"\n-    fi\n+    ciCommandSetEnv SDKROOT \"$(xcrun --sdk macosx --show-sdk-path)\"\n \n     # Configure `AR` specifically so rustbuild doesn't try to infer it as\n     # `clang-ar` by accident."}, {"sha": "2cbb2ddbc7046ab77caf06977f76aad5e750568f", "filename": "src/ci/scripts/switch-xcode.sh", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Fci%2Fscripts%2Fswitch-xcode.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Fci%2Fscripts%2Fswitch-xcode.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fswitch-xcode.sh?ref=e7a344fb745a0a663e21be947b2619df05df6d31", "patch": "@@ -1,13 +0,0 @@\n-#!/bin/bash\n-# Switch to XCode 9.3 on OSX since it seems to be the last version that supports\n-# i686-apple-darwin. We'll eventually want to upgrade this and it will probably\n-# force us to drop i686-apple-darwin, but let's keep the wheels turning for now.\n-\n-set -euo pipefail\n-IFS=$'\\n\\t'\n-\n-source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n-\n-if isMacOS; then\n-    sudo xcode-select --switch /Applications/Xcode_9.3.app\n-fi"}, {"sha": "6fb3705e5230311b096d47f7e2c91f9ce24393d0", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1 +1 @@\n-Subproject commit 87dd6843678575f8dda962f239d14ef4be14b352\n+Subproject commit 6fb3705e5230311b096d47f7e2c91f9ce24393d0"}, {"sha": "37f9e6848411188a1062ead1bd8ebe4b8aa16899", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1 +1 @@\n-Subproject commit 1a2390247ad6d08160e0dd74f40a01a9578659c2\n+Subproject commit 37f9e6848411188a1062ead1bd8ebe4b8aa16899"}, {"sha": "b2e1092bf67bd4d7686c4553f186edbb7f5f92db", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1 +1 @@\n-Subproject commit 4d78994915af1bde9a95c04a8c27d8dca066232a\n+Subproject commit b2e1092bf67bd4d7686c4553f186edbb7f5f92db"}, {"sha": "64239df6d173562b9deb4f012e4c3e6e960c4754", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1 +1 @@\n-Subproject commit 11e893fc1357bc688418ddf1087c2b7aa25d154d\n+Subproject commit 64239df6d173562b9deb4f012e4c3e6e960c4754"}, {"sha": "32facd5522ddbbf37baf01e4e4b6562bc55c071a", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1 +1 @@\n-Subproject commit 1c2bd024d13f8011307e13386cf1fea2180352b5\n+Subproject commit 32facd5522ddbbf37baf01e4e4b6562bc55c071a"}, {"sha": "659f8f65e65d2defdbdcdfbe3a461f3991ac551b", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -215,21 +215,29 @@ This controls which [target](targets/index.md) to produce.\n \n This flag will set which lints should be set to the [warn level](lints/levels.md#warn).\n \n+_Note:_ The order of these lint level arguments is taken into account, see [lint level via compiler flag](lints/levels.md#via-compiler-flag) for more information.\n+\n <a id=\"option-a-allow\"></a>\n ## `-A`: set lint allowed\n \n This flag will set which lints should be set to the [allow level](lints/levels.md#allow).\n \n+_Note:_ The order of these lint level arguments is taken into account, see [lint level via compiler flag](lints/levels.md#via-compiler-flag) for more information.\n+\n <a id=\"option-d-deny\"></a>\n ## `-D`: set lint denied\n \n This flag will set which lints should be set to the [deny level](lints/levels.md#deny).\n \n+_Note:_ The order of these lint level arguments is taken into account, see [lint level via compiler flag](lints/levels.md#via-compiler-flag) for more information.\n+\n <a id=\"option-f-forbid\"></a>\n ## `-F`: set lint forbidden\n \n This flag will set which lints should be set to the [forbid level](lints/levels.md#forbid).\n \n+_Note:_ The order of these lint level arguments is taken into account, see [lint level via compiler flag](lints/levels.md#via-compiler-flag) for more information.\n+\n <a id=\"option-z-unstable\"></a>\n ## `-Z`: set unstable options\n "}, {"sha": "3cfe2f698f3e01cf9a55afa67d3132d56aad52e1", "filename": "src/doc/rustc/src/lints/levels.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -164,6 +164,18 @@ And of course, you can mix these four flags together:\n $ rustc lib.rs --crate-type=lib -D missing-docs -A unused-variables\n ```\n \n+The order of these command line arguments is taken into account. The following allows the `unused-variables` lint, because it is the last argument for that lint:\n+\n+```bash\n+$ rustc lib.rs --crate-type=lib -D unused-variables -A unused-variables\n+```\n+\n+You can make use of this behavior by overriding the level of one specific lint out of a group of lints. The following example denies all the lints in the `unused` group, but explicitly allows the `unused-variables` lint in that group:\n+\n+```bash\n+$ rustc lib.rs --crate-type=lib -D unused -A unused-variables\n+```\n+\n ### Via an attribute\n \n You can also modify the lint level with a crate-wide attribute:"}, {"sha": "ba30c107667edbab1b3bdcb47d3b24b7bc26e184", "filename": "src/doc/rustdoc/book.toml", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fdoc%2Frustdoc%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fdoc%2Frustdoc%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fbook.toml?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -0,0 +1,4 @@\n+[book]\n+authors = [\"The Rust Project Developers\"]\n+src = \"src\"\n+title = \"The rustdoc book\""}, {"sha": "f871df46250bad569081a30e083ef0df778d2067", "filename": "src/doc/unstable-book/src/compiler-flags/control-flow-guard.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -0,0 +1,34 @@\n+# `control_flow_guard`\n+\n+The tracking issue for this feature is: [#68793](https://github.com/rust-lang/rust/issues/68793).\n+\n+------------------------\n+\n+The `-Zcontrol_flow_guard=checks` compiler flag enables the Windows [Control Flow Guard][cfguard-docs] platform security feature. When enabled, the compiler outputs a list of valid indirect call targets, and inserts runtime checks on all indirect jump instructions to ensure that the destination is in the list of valid call targets.\n+\n+[cfguard-docs]: https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard\n+\n+For testing purposes, the `-Zcontrol_flow_guard=nochecks` compiler flag can be used to emit only the list of valid call targets, but not the runtime checks.\n+\n+It is strongly recommended to also enable Control Flow Guard checks in all linked libraries, including the standard library. \n+\n+To enable Control Flow Guard in the standard library, you can use the [cargo `-Zbuild-std` functionality][build-std] to recompile the standard library with the same configuration options as the main program. \n+\n+[build-std]: https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std\n+\n+For example:\n+```cmd\n+rustup toolchain install --force nightly\n+rustup component add rust-src\n+SET RUSTFLAGS=-Zcontrol_flow_guard=checks\n+cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n+```\n+\n+```PowerShell\n+rustup toolchain install --force nightly\n+rustup component add rust-src\n+$Env:RUSTFLAGS = \"-Zcontrol_flow_guard=checks\"\n+cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n+```\n+\n+Alternatively, if you are building the standard library from source, you can set `control-flow-guard = true` in the config.toml file."}, {"sha": "3ce18743be50801360ef737c510d6ebc0e86ba61", "filename": "src/doc/unstable-book/src/compiler-flags/self-profile-events.md", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile-events.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile-events.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile-events.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -0,0 +1,74 @@\n+# `self-profile-events`\n+\n+---------------------\n+\n+The `-Zself-profile-events` compiler flag controls what events are recorded by the self-profiler when it is enabled via the `-Zself-profile` flag.\n+\n+This flag takes a comma delimited list of event types to record.\n+\n+For example:\n+\n+```console\n+$ rustc -Zself-profile -Zself-profile-events=default,args\n+```\n+\n+## Event types\n+\n+- `query-provider`\n+  - Traces each query used internally by the compiler.\n+\n+- `generic-activity`\n+  - Traces other parts of the compiler not covered by the query system.\n+\n+- `query-cache-hit`\n+  - Adds tracing information that records when the in-memory query cache is \"hit\" and does not need to re-execute a query which has been cached.\n+  - Disabled by default because this significantly increases the trace file size.\n+\n+- `query-blocked`\n+  - Tracks time that a query tries to run but is blocked waiting on another thread executing the same query to finish executing.\n+  - Query blocking only occurs when the compiler is built with parallel mode support.\n+\n+- `incr-cache-load`\n+  - Tracks time that is spent loading and deserializing query results from the incremental compilation on-disk cache.\n+\n+- `query-keys`\n+  - Adds a serialized representation of each query's query key to the tracing data.\n+  - Disabled by default because this significantly increases the trace file size.\n+\n+- `function-args`\n+  - Adds additional tracing data to some `generic-activity` events.\n+  - Disabled by default for parity with `query-keys`.\n+\n+- `llvm`\n+  - Adds tracing information about LLVM passes and codegeneration.\n+  - Disabled by default because this only works when `-Znew-llvm-pass-manager` is enabled.\n+\n+## Event synonyms\n+\n+- `none`\n+  - Disables all events.\n+  Equivalent to the self-profiler being disabled.\n+\n+- `default`\n+  - The default set of events which stikes a balance between providing detailed tracing data and adding additional overhead to the compilation.\n+\n+- `args`\n+  - Equivalent to `query-keys` and `function-args`.\n+\n+- `all`\n+  - Enables all events.\n+\n+## Examples\n+\n+Enable the profiler and capture the default set of events (both invocations are equivalent):\n+\n+```console\n+$ rustc -Zself-profile\n+$ rustc -Zself-profile -Zself-profile-events=default\n+```\n+\n+Enable the profiler and capture the default events and their arguments:\n+\n+```console\n+$ rustc -Zself-profile -Zself-profile-events=default,args\n+```"}, {"sha": "6de1c774f7cd7d19255cfa60042d838663efca4e", "filename": "src/doc/unstable-book/src/compiler-flags/self-profile.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fself-profile.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -0,0 +1,47 @@\n+# `self-profile`\n+\n+--------------------\n+\n+The `-Zself-profile` compiler flag enables rustc's internal profiler.\n+When enabled, the compiler will output three binary files in the specified directory (or the current working directory if no directory is specified).\n+These files can be analyzed by using the tools in the [`measureme`] repository.\n+\n+To control the data recorded in the trace files, use the `-Zself-profile-events` flag.\n+\n+For example:\n+\n+First, run a compilation session and provide the `-Zself-profile` flag:\n+\n+```console\n+$ rustc --crate-name foo -Zself-profile`\n+```\n+\n+This will generate three files in the working directory such as:\n+\n+- `foo-1234.events`\n+- `foo-1234.string_data`\n+- `foo-1234.string_index`\n+\n+Where `foo` is the name of the crate and `1234` is the process id of the rustc process.\n+\n+To get a summary of where the compiler is spending its time:\n+\n+```console\n+$ ../measureme/target/release/summarize summarize foo-1234\n+```\n+\n+To generate a flamegraph of the same data:\n+\n+```console\n+$ ../measureme/target/release/inferno foo-1234\n+```\n+\n+To dump the event data in a Chromium-profiler compatible format:\n+\n+```console\n+$ ../measureme/target/release/crox foo-1234\n+```\n+\n+For more information, consult the [`measureme`] documentation.\n+\n+[`measureme`]: https://github.com/rust-lang/measureme.git"}, {"sha": "b3f8f50636bee754b81d0280b505ece3bb9f1a51", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -212,7 +212,6 @@ def __classify_struct(self):\n         # REGULAR STRUCT\n         return TYPE_KIND_REGULAR_STRUCT\n \n-\n     def __classify_union(self):\n         assert self.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION\n \n@@ -233,7 +232,6 @@ def __classify_union(self):\n         else:\n             return TYPE_KIND_REGULAR_UNION\n \n-\n     def __conforms_to_field_layout(self, expected_fields):\n         actual_fields = self.get_fields()\n         actual_field_count = len(actual_fields)\n@@ -363,6 +361,7 @@ def extract_tail_head_ptr_and_cap_from_std_vecdeque(vec_val):\n     assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n     return (tail, head, data_ptr, capacity)\n \n+\n def extract_length_and_ptr_from_slice(slice_val):\n     assert (slice_val.type.get_type_kind() == TYPE_KIND_SLICE or\n             slice_val.type.get_type_kind() == TYPE_KIND_STR_SLICE)\n@@ -376,8 +375,10 @@ def extract_length_and_ptr_from_slice(slice_val):\n     assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n     return (length, data_ptr)\n \n+\n UNQUALIFIED_TYPE_MARKERS = frozenset([\"(\", \"[\", \"&\", \"*\"])\n \n+\n def extract_type_name(qualified_type_name):\n     \"\"\"Extracts the type name from a fully qualified path\"\"\"\n     if qualified_type_name[0] in UNQUALIFIED_TYPE_MARKERS:\n@@ -393,6 +394,7 @@ def extract_type_name(qualified_type_name):\n     else:\n         return qualified_type_name[index + 2:]\n \n+\n try:\n     compat_str = unicode  # Python 2\n except NameError:"}, {"sha": "4979882ffeaffecebfaf2a856b7d50191d2a4483", "filename": "src/etc/dec2flt_table.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Fdec2flt_table.py", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Fdec2flt_table.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdec2flt_table.py?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -14,7 +14,6 @@\n even larger, and it's already uncomfortably large (6 KiB).\n \"\"\"\n from __future__ import print_function\n-import sys\n from math import ceil, log\n from fractions import Fraction\n from collections import namedtuple\n@@ -82,6 +81,7 @@ def error(f, e, z):\n     ulp_err = abs_err / Fraction(2) ** z.exp\n     return float(ulp_err)\n \n+\n HEADER = \"\"\"\n //! Tables of approximations of powers of ten.\n //! DO NOT MODIFY: Generated by `src/etc/dec2flt_table.py`"}, {"sha": "0914c22eb13f03d0b9d0c94474ac7e5b57795195", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -9,7 +9,7 @@\n if sys.version_info[0] >= 3:\n     xrange = range\n \n-rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string = True)\n+rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string=True)\n \n # The btree pretty-printers fail in a confusing way unless\n # https://sourceware.org/bugzilla/show_bug.cgi?id=21763 is fixed.\n@@ -21,9 +21,10 @@\n     if int(_match.group(1)) > 8 or (int(_match.group(1)) == 8 and int(_match.group(2)) >= 1):\n         gdb_81 = True\n \n-#===============================================================================\n+# ===============================================================================\n # GDB Pretty Printing Module for Rust\n-#===============================================================================\n+# ===============================================================================\n+\n \n class GdbType(rustpp.Type):\n \n@@ -133,39 +134,39 @@ def rust_pretty_printer_lookup_function(gdb_val):\n \n     if type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT:\n         return RustStructPrinter(val,\n-                                 omit_first_field = False,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = False)\n+                                 omit_first_field=False,\n+                                 omit_type_name=False,\n+                                 is_tuple_like=False)\n \n     if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n         return RustStructPrinter(val,\n-                                 omit_first_field = True,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = False)\n+                                 omit_first_field=True,\n+                                 omit_type_name=False,\n+                                 is_tuple_like=False)\n \n     if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n         return RustStringSlicePrinter(val)\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE:\n         return RustStructPrinter(val,\n-                                 omit_first_field = False,\n-                                 omit_type_name = True,\n-                                 is_tuple_like = True)\n+                                 omit_first_field=False,\n+                                 omit_type_name=True,\n+                                 is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n         return RustStructPrinter(val,\n-                                 omit_first_field = False,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = True)\n+                                 omit_first_field=False,\n+                                 omit_type_name=False,\n+                                 is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n         return RustCStyleVariantPrinter(val.get_child_at_index(0))\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n         return RustStructPrinter(val,\n-                                 omit_first_field = True,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = True)\n+                                 omit_first_field=True,\n+                                 omit_type_name=False,\n+                                 is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n         variant = get_field_at_index(gdb_val, 0)\n@@ -189,9 +190,9 @@ def rust_pretty_printer_lookup_function(gdb_val):\n     return None\n \n \n-#=------------------------------------------------------------------------------\n+# =------------------------------------------------------------------------------\n # Pretty Printer Classes\n-#=------------------------------------------------------------------------------\n+# =------------------------------------------------------------------------------\n class RustEmptyPrinter(object):\n     def __init__(self, val):\n         self.__val = val\n@@ -355,6 +356,7 @@ def children_of_node(boxed_node, height, want_values):\n             else:\n                 yield keys[i]['value']['value']\n \n+\n class RustStdBTreeSetPrinter(object):\n     def __init__(self, val):\n         self.__val = val\n@@ -429,6 +431,7 @@ def to_string(self):\n     def display_hint(self):\n         return \"string\"\n \n+\n class RustCStyleVariantPrinter(object):\n     def __init__(self, val):\n         assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ENUM"}, {"sha": "c42f942c63cf5fa4597ef663afde6ee1c14704b8", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -8,7 +8,8 @@\n sample usage: src/etc/generate-deriving-span-tests.py\n \"\"\"\n \n-import os, stat\n+import os\n+import stat\n \n TEST_DIR = os.path.abspath(\n     os.path.join(os.path.dirname(__file__), '../test/ui/derives/'))\n@@ -56,15 +57,17 @@\n \n ENUM_TUPLE, ENUM_STRUCT, STRUCT_FIELDS, STRUCT_TUPLE = range(4)\n \n+\n def create_test_case(type, trait, super_traits, error_count):\n     string = [ENUM_STRING, ENUM_STRUCT_VARIANT_STRING, STRUCT_STRING, STRUCT_TUPLE_STRING][type]\n     all_traits = ','.join([trait] + super_traits)\n     super_traits = ','.join(super_traits)\n     error_deriving = '#[derive(%s)]' % super_traits if super_traits else ''\n \n     errors = '\\n'.join('//~%s ERROR' % ('^' * n) for n in range(error_count))\n-    code = string.format(traits = all_traits, errors = errors)\n-    return TEMPLATE.format(error_deriving=error_deriving, code = code)\n+    code = string.format(traits=all_traits, errors=errors)\n+    return TEMPLATE.format(error_deriving=error_deriving, code=code)\n+\n \n def write_file(name, string):\n     test_file = os.path.join(TEST_DIR, 'derives-span-%s.rs' % name)\n@@ -86,10 +89,10 @@ def write_file(name, string):\n \n traits = {\n     'Default': (STRUCT, [], 1),\n-    'FromPrimitive': (0, [], 0), # only works for C-like enums\n+    'FromPrimitive': (0, [], 0),  # only works for C-like enums\n \n-    'Decodable': (0, [], 0), # FIXME: quoting gives horrible spans\n-    'Encodable': (0, [], 0), # FIXME: quoting gives horrible spans\n+    'Decodable': (0, [], 0),  # FIXME: quoting gives horrible spans\n+    'Encodable': (0, [], 0),  # FIXME: quoting gives horrible spans\n }\n \n for (trait, supers, errs) in [('Clone', [], 1),"}, {"sha": "77c3d2758c6dcd6bcfb188cf7ceafd36fa53d2f1", "filename": "src/etc/generate-keyword-tests.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Fgenerate-keyword-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Fgenerate-keyword-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-keyword-tests.py?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -11,7 +11,6 @@\n \n import sys\n import os\n-import datetime\n import stat\n \n "}, {"sha": "7789b24b62c83be1ce1297ebf08893e0bc611805", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -131,6 +131,7 @@\n except NameError:\n     unichr = chr\n \n+\n class CustomHTMLParser(HTMLParser):\n     \"\"\"simplified HTML parser.\n \n@@ -169,21 +170,25 @@ def close(self):\n         HTMLParser.close(self)\n         return self.__builder.close()\n \n+\n Command = namedtuple('Command', 'negated cmd args lineno context')\n \n+\n class FailedCheck(Exception):\n     pass\n \n+\n class InvalidCheck(Exception):\n     pass\n \n+\n def concat_multi_lines(f):\n     \"\"\"returns a generator out of the file object, which\n     - removes `\\\\` then `\\n` then a shared prefix with the previous line then\n       optional whitespace;\n     - keeps a line number (starting from 0) of the first line being\n       concatenated.\"\"\"\n-    lastline = None # set to the last line when the last line has a backslash\n+    lastline = None  # set to the last line when the last line has a backslash\n     firstlineno = None\n     catenated = ''\n     for lineno, line in enumerate(f):\n@@ -208,6 +213,7 @@ def concat_multi_lines(f):\n     if lastline is not None:\n         print_err(lineno, line, 'Trailing backslash at the end of the file')\n \n+\n LINE_PATTERN = re.compile(r'''\n     (?<=(?<!\\S)@)(?P<negated>!?)\n     (?P<cmd>[A-Za-z]+(?:-[A-Za-z]+)*)\n@@ -252,7 +258,7 @@ def flatten(node):\n \n def normalize_xpath(path):\n     if path.startswith('//'):\n-        return '.' + path # avoid warnings\n+        return '.' + path  # avoid warnings\n     elif path.startswith('.//'):\n         return path\n     else:\n@@ -316,7 +322,7 @@ def get_dir(self, path):\n \n def check_string(data, pat, regexp):\n     if not pat:\n-        return True # special case a presence testing\n+        return True  # special case a presence testing\n     elif regexp:\n         return re.search(pat, data, flags=re.UNICODE) is not None\n     else:\n@@ -353,7 +359,7 @@ def check_tree_text(tree, path, pat, regexp):\n                 ret = check_string(value, pat, regexp)\n                 if ret:\n                     break\n-    except Exception as e:\n+    except Exception:\n         print('Failed to get path \"{}\"'.format(path))\n         raise\n     return ret\n@@ -363,6 +369,7 @@ def get_tree_count(tree, path):\n     path = normalize_xpath(path)\n     return len(tree.findall(path))\n \n+\n def stderr(*args):\n     if sys.version_info.major < 3:\n         file = codecs.getwriter('utf-8')(sys.stderr)\n@@ -371,6 +378,7 @@ def stderr(*args):\n \n     print(*args, file=file)\n \n+\n def print_err(lineno, context, err, message=None):\n     global ERR_COUNT\n     ERR_COUNT += 1\n@@ -381,48 +389,50 @@ def print_err(lineno, context, err, message=None):\n     if context:\n         stderr(\"\\t{}\".format(context))\n \n+\n ERR_COUNT = 0\n \n+\n def check_command(c, cache):\n     try:\n         cerr = \"\"\n-        if c.cmd == 'has' or c.cmd == 'matches': # string test\n+        if c.cmd == 'has' or c.cmd == 'matches':  # string test\n             regexp = (c.cmd == 'matches')\n-            if len(c.args) == 1 and not regexp: # @has <path> = file existence\n+            if len(c.args) == 1 and not regexp:  # @has <path> = file existence\n                 try:\n                     cache.get_file(c.args[0])\n                     ret = True\n                 except FailedCheck as err:\n                     cerr = str(err)\n                     ret = False\n-            elif len(c.args) == 2: # @has/matches <path> <pat> = string test\n+            elif len(c.args) == 2:  # @has/matches <path> <pat> = string test\n                 cerr = \"`PATTERN` did not match\"\n                 ret = check_string(cache.get_file(c.args[0]), c.args[1], regexp)\n-            elif len(c.args) == 3: # @has/matches <path> <pat> <match> = XML tree test\n+            elif len(c.args) == 3:  # @has/matches <path> <pat> <match> = XML tree test\n                 cerr = \"`XPATH PATTERN` did not match\"\n                 tree = cache.get_tree(c.args[0])\n                 pat, sep, attr = c.args[1].partition('/@')\n-                if sep: # attribute\n+                if sep:  # attribute\n                     tree = cache.get_tree(c.args[0])\n                     ret = check_tree_attr(tree, pat, attr, c.args[2], regexp)\n-                else: # normalized text\n+                else:  # normalized text\n                     pat = c.args[1]\n                     if pat.endswith('/text()'):\n                         pat = pat[:-7]\n                     ret = check_tree_text(cache.get_tree(c.args[0]), pat, c.args[2], regexp)\n             else:\n                 raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n \n-        elif c.cmd == 'count': # count test\n-            if len(c.args) == 3: # @count <path> <pat> <count> = count test\n+        elif c.cmd == 'count':  # count test\n+            if len(c.args) == 3:  # @count <path> <pat> <count> = count test\n                 expected = int(c.args[2])\n                 found = get_tree_count(cache.get_tree(c.args[0]), c.args[1])\n                 cerr = \"Expected {} occurrences but found {}\".format(expected, found)\n                 ret = expected == found\n             else:\n                 raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n-        elif c.cmd == 'has-dir': # has-dir test\n-            if len(c.args) == 1: # @has-dir <path> = has-dir test\n+        elif c.cmd == 'has-dir':  # has-dir test\n+            if len(c.args) == 1:  # @has-dir <path> = has-dir test\n                 try:\n                     cache.get_dir(c.args[0])\n                     ret = True\n@@ -448,11 +458,13 @@ def check_command(c, cache):\n     except InvalidCheck as err:\n         print_err(c.lineno, c.context, str(err))\n \n+\n def check(target, commands):\n     cache = CachedFiles(target)\n     for c in commands:\n         check_command(c, cache)\n \n+\n if __name__ == '__main__':\n     if len(sys.argv) != 3:\n         stderr('Usage: {} <doc dir> <template>'.format(sys.argv[0]))"}, {"sha": "99ee7507fa2fb0d121ca340682204ca92a1b781e", "filename": "src/etc/installer/gfx/rust-logo.png", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Finstaller%2Fgfx%2Frust-logo.png", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Finstaller%2Fgfx%2Frust-logo.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fgfx%2Frust-logo.png?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "d9c4bc5562f00a19bcf38981e4378ed62c619d18", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -157,6 +157,7 @@ def watchdog():\n # ~main\n ####################################################################################################\n \n+\n if len(sys.argv) != 3:\n     print(\"usage: python lldb_batchmode.py target-path script-path\")\n     sys.exit(1)"}, {"sha": "0c4021b36fb6f6ac7435ea2f40873a26584b5c69", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,10 +1,10 @@\n import lldb\n-import re\n import debugger_pretty_printers_common as rustpp\n \n-#===============================================================================\n+# ===============================================================================\n # LLDB Pretty Printing Module for Rust\n-#===============================================================================\n+# ===============================================================================\n+\n \n class LldbType(rustpp.Type):\n \n@@ -84,16 +84,16 @@ def print_val(lldb_val, internal_dict):\n         type_kind == rustpp.TYPE_KIND_EMPTY):\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = False,\n-                                omit_type_name = False,\n-                                is_tuple_like = False)\n+                                omit_first_field=False,\n+                                omit_type_name=False,\n+                                is_tuple_like=False)\n \n     if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = True,\n-                                omit_type_name = False,\n-                                is_tuple_like = False)\n+                                omit_first_field=True,\n+                                omit_type_name=False,\n+                                is_tuple_like=False)\n \n     if type_kind == rustpp.TYPE_KIND_SLICE:\n         return print_vec_slice_val(val, internal_dict)\n@@ -110,26 +110,26 @@ def print_val(lldb_val, internal_dict):\n     if type_kind == rustpp.TYPE_KIND_TUPLE:\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = False,\n-                                omit_type_name = True,\n-                                is_tuple_like = True)\n+                                omit_first_field=False,\n+                                omit_type_name=True,\n+                                is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = False,\n-                                omit_type_name = False,\n-                                is_tuple_like = True)\n+                                omit_first_field=False,\n+                                omit_type_name=False,\n+                                is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n         return val.type.get_unqualified_type_name()\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = True,\n-                                omit_type_name = False,\n-                                is_tuple_like = True)\n+                                omit_first_field=True,\n+                                omit_type_name=False,\n+                                is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n         return print_val(lldb_val.GetChildAtIndex(0), internal_dict)\n@@ -157,9 +157,9 @@ def print_val(lldb_val, internal_dict):\n     return lldb_val.GetValue()\n \n \n-#=--------------------------------------------------------------------------------------------------\n+# =---------------------------------------------------------------------------------------\n # Type-Specialized Printing Functions\n-#=--------------------------------------------------------------------------------------------------\n+# =---------------------------------------------------------------------------------------\n \n def print_struct_val(val, internal_dict, omit_first_field, omit_type_name, is_tuple_like):\n     \"\"\"\n@@ -212,6 +212,7 @@ def render_child(child_index):\n     return template % {\"type_name\": type_name,\n                        \"body\": body}\n \n+\n def print_pointer_val(val, internal_dict):\n     \"\"\"Prints a pointer value with Rust syntax\"\"\"\n     assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n@@ -253,18 +254,21 @@ def print_std_vec_val(val, internal_dict):\n                                               length,\n                                               internal_dict)\n \n+\n def print_str_slice_val(val, internal_dict):\n     (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(val)\n     return read_utf8_string(data_ptr, length)\n \n+\n def print_std_string_val(val, internal_dict):\n     vec = val.get_child_at_index(0)\n     (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n     return read_utf8_string(data_ptr, length)\n \n-#=--------------------------------------------------------------------------------------------------\n+# =-----------------------------------------------------------------------\n # Helper Functions\n-#=--------------------------------------------------------------------------------------------------\n+# =-----------------------------------------------------------------------\n+\n \n def print_array_of_values(array_name, data_ptr_val, length, internal_dict):\n     \"\"\"Prints a contiguous memory range, interpreting it as values of the"}, {"sha": "f41404bf8cab97ff5eb94a1084393e9297e90fad", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -200,21 +200,27 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n         align as *mut u8\n     } else {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        let ptr = alloc(layout);\n-        if !ptr.is_null() { ptr } else { handle_alloc_error(layout) }\n+        match Global.alloc(layout) {\n+            Ok(ptr) => ptr.as_ptr(),\n+            Err(_) => handle_alloc_error(layout),\n+        }\n     }\n }\n \n #[cfg_attr(not(test), lang = \"box_free\")]\n #[inline]\n+// This signature has to be the same as `Box`, otherwise an ICE will happen.\n+// When an additional parameter to `Box` is added (like `A: AllocRef`), this has to be added here as\n+// well.\n+// For example if `Box` is changed to  `struct Box<T: ?Sized, A: AllocRef>(Unique<T>, A)`,\n+// this function has to be changed to `fn box_free<T: ?Sized, A: AllocRef>(Unique<T>, A)` as well.\n pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n-    let ptr = ptr.as_ptr();\n-    let size = size_of_val(&*ptr);\n-    let align = min_align_of_val(&*ptr);\n+    let size = size_of_val(ptr.as_ref());\n+    let align = min_align_of_val(ptr.as_ref());\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n     if size != 0 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        dealloc(ptr as *mut u8, layout);\n+        Global.dealloc(ptr.cast().into(), layout);\n     }\n }\n "}, {"sha": "3ac4bd82a3a10fa4919d078b9dcefc53d88bd1b9", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -196,12 +196,14 @@ impl<T> Box<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n-        if layout.size() == 0 {\n-            return Box(NonNull::dangling().into());\n+        unsafe {\n+            let ptr = if layout.size() == 0 {\n+                NonNull::dangling()\n+            } else {\n+                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast()\n+            };\n+            Box::from_raw(ptr.as_ptr())\n         }\n-        let ptr =\n-            unsafe { Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)) };\n-        Box(ptr.cast().into())\n     }\n \n     /// Constructs a new `Box` with uninitialized contents, with the memory\n@@ -264,15 +266,14 @@ impl<T> Box<[T]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n         let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n-        let ptr = if layout.size() == 0 {\n-            NonNull::dangling()\n-        } else {\n-            unsafe {\n+        unsafe {\n+            let ptr = if layout.size() == 0 {\n+                NonNull::dangling()\n+            } else {\n                 Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast()\n-            }\n-        };\n-        let slice = unsafe { slice::from_raw_parts_mut(ptr.as_ptr(), len) };\n-        Box(Unique::from(slice))\n+            };\n+            Box::from_raw(slice::from_raw_parts_mut(ptr.as_ptr(), len))\n+        }\n     }\n }\n \n@@ -308,7 +309,7 @@ impl<T> Box<mem::MaybeUninit<T>> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<T> {\n-        Box(Box::into_unique(self).cast())\n+        Box::from_raw(Box::into_raw(self) as *mut T)\n     }\n }\n \n@@ -346,7 +347,7 @@ impl<T> Box<[mem::MaybeUninit<T>]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<[T]> {\n-        Box(Unique::new_unchecked(Box::into_raw(self) as _))\n+        Box::from_raw(Box::into_raw(self) as *mut [T])\n     }\n }\n "}, {"sha": "f38fe997b732c8effae96bbbd60722cc9673369e", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -147,7 +147,7 @@\n \n use core::fmt;\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n-use core::mem::{size_of, swap, ManuallyDrop};\n+use core::mem::{self, size_of, swap, ManuallyDrop};\n use core::ops::{Deref, DerefMut};\n use core::ptr;\n \n@@ -1239,7 +1239,19 @@ pub struct DrainSorted<'a, T: Ord> {\n impl<'a, T: Ord> Drop for DrainSorted<'a, T> {\n     /// Removes heap elements in heap order.\n     fn drop(&mut self) {\n-        while let Some(_) = self.inner.pop() {}\n+        struct DropGuard<'r, 'a, T: Ord>(&'r mut DrainSorted<'a, T>);\n+\n+        impl<'r, 'a, T: Ord> Drop for DropGuard<'r, 'a, T> {\n+            fn drop(&mut self) {\n+                while let Some(_) = self.0.inner.pop() {}\n+            }\n+        }\n+\n+        while let Some(item) = self.inner.pop() {\n+            let guard = DropGuard(self);\n+            drop(item);\n+            mem::forget(guard);\n+        }\n     }\n }\n "}, {"sha": "b1f0ef0085f2d42a91f4145302ff788c7aea8358", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -227,7 +227,7 @@ impl<K: Clone, V: Clone> BTreeClone for BTreeMap<K, V> {\n impl<K: Clone + Ord, V: Clone> BTreeClone for BTreeMap<K, V> {\n     fn clone_from(&mut self, other: &Self) {\n         // This truncates `self` to `other.len()` by calling `split_off` on\n-        // the first key after `other.len()` elements if it exists\n+        // the first key after `other.len()` elements if it exists.\n         let split_off_key = if self.len() > other.len() {\n             let diff = self.len() - other.len();\n             if diff <= other.len() {\n@@ -247,19 +247,18 @@ impl<K: Clone + Ord, V: Clone> BTreeClone for BTreeMap<K, V> {\n         // After truncation, `self` is at most as long as `other` so this loop\n         // replaces every key-value pair in `self`. Since `oiter` is in sorted\n         // order and the structure of the `BTreeMap` stays the same,\n-        // the BTree invariants are maintained at the end of the loop\n+        // the BTree invariants are maintained at the end of the loop.\n         while !siter.is_empty() {\n             if let Some((ok, ov)) = oiter.next() {\n-                // SAFETY: This is safe because the `siter.front != siter.back` check\n-                // ensures that `siter` is nonempty\n+                // SAFETY: This is safe because `siter` is nonempty.\n                 let (sk, sv) = unsafe { siter.next_unchecked() };\n                 sk.clone_from(ok);\n                 sv.clone_from(ov);\n             } else {\n                 break;\n             }\n         }\n-        // If `other` is longer than `self`, the remaining elements are inserted\n+        // If `other` is longer than `self`, the remaining elements are inserted.\n         self.extend(oiter.map(|(k, v)| ((*k).clone(), (*v).clone())));\n     }\n }\n@@ -675,13 +674,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        match self.length {\n-            0 => None,\n-            _ => Some(OccupiedEntry {\n-                handle: self.root.as_mut().first_kv(),\n+        let front = self.root.as_mut().first_leaf_edge();\n+        if let Ok(kv) = front.right_kv() {\n+            Some(OccupiedEntry {\n+                handle: kv.forget_node_type(),\n                 length: &mut self.length,\n                 _marker: PhantomData,\n-            }),\n+            })\n+        } else {\n+            None\n         }\n     }\n \n@@ -736,13 +737,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        match self.length {\n-            0 => None,\n-            _ => Some(OccupiedEntry {\n-                handle: self.root.as_mut().last_kv(),\n+        let back = self.root.as_mut().last_leaf_edge();\n+        if let Ok(kv) = back.left_kv() {\n+            Some(OccupiedEntry {\n+                handle: kv.forget_node_type(),\n                 length: &mut self.length,\n                 _marker: PhantomData,\n-            }),\n+            })\n+        } else {\n+            None\n         }\n     }\n \n@@ -1467,7 +1470,22 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n #[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n impl<K, V> Drop for IntoIter<K, V> {\n     fn drop(&mut self) {\n-        self.for_each(drop);\n+        struct DropGuard<'a, K, V>(&'a mut IntoIter<K, V>);\n+\n+        impl<'a, K, V> Drop for DropGuard<'a, K, V> {\n+            fn drop(&mut self) {\n+                // Continue the same loop we perform below. This only runs when unwinding, so we\n+                // don't have to care about panics this time (they'll abort).\n+                while let Some(_) = self.0.next() {}\n+            }\n+        }\n+\n+        while let Some(pair) = self.next() {\n+            let guard = DropGuard(self);\n+            drop(pair);\n+            mem::forget(guard);\n+        }\n+\n         unsafe {\n             let leaf_node = ptr::read(&self.front).into_node();\n             if leaf_node.is_shared_root() {"}, {"sha": "a9b4e3e4706b80dbde8281823290abf574076fa4", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -878,6 +878,52 @@ impl<T> LinkedList<T> {\n         unsafe { self.split_off_after_node(split_node, at) }\n     }\n \n+    /// Removes the element at the given index and returns it.\n+    ///\n+    /// This operation should compute in O(n) time.\n+    ///\n+    /// # Panics\n+    /// Panics if at >= len\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(linked_list_remove)]\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut d = LinkedList::new();\n+    ///\n+    /// d.push_front(1);\n+    /// d.push_front(2);\n+    /// d.push_front(3);\n+    ///\n+    /// assert_eq!(d.remove(1), 2);\n+    /// assert_eq!(d.remove(0), 3);\n+    /// assert_eq!(d.remove(0), 1);\n+    /// ```\n+    #[unstable(feature = \"linked_list_remove\", issue = \"69210\")]\n+    pub fn remove(&mut self, at: usize) -> T {\n+        let len = self.len();\n+        assert!(at < len, \"Cannot remove at an index outside of the list bounds\");\n+\n+        // Below, we iterate towards the node at the given index, either from\n+        // the start or the end, depending on which would be faster.\n+        let offset_from_end = len - at - 1;\n+        if at <= offset_from_end {\n+            let mut cursor = self.cursor_front_mut();\n+            for _ in 0..at {\n+                cursor.move_next();\n+            }\n+            cursor.remove_current().unwrap()\n+        } else {\n+            let mut cursor = self.cursor_back_mut();\n+            for _ in 0..offset_from_end {\n+                cursor.move_prev();\n+            }\n+            cursor.remove_current().unwrap()\n+        }\n+    }\n+\n     /// Creates an iterator which uses a closure to determine if an element should be removed.\n     ///\n     /// If the closure returns true, then the element is removed and yielded.\n@@ -1565,7 +1611,24 @@ where\n     F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n-        self.for_each(drop);\n+        struct DropGuard<'r, 'a, T, F>(&'r mut DrainFilter<'a, T, F>)\n+        where\n+            F: FnMut(&mut T) -> bool;\n+\n+        impl<'r, 'a, T, F> Drop for DropGuard<'r, 'a, T, F>\n+        where\n+            F: FnMut(&mut T) -> bool,\n+        {\n+            fn drop(&mut self) {\n+                self.0.for_each(drop);\n+            }\n+        }\n+\n+        while let Some(item) = self.next() {\n+            let guard = DropGuard(self);\n+            drop(item);\n+            mem::forget(guard);\n+        }\n     }\n }\n "}, {"sha": "85d1d98b8a9c23bfb3b908baeb7f7f78d99f481c", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 21, "deletions": 108, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -22,6 +22,11 @@ use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+pub use self::drain::Drain;\n+\n+mod drain;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -866,6 +871,18 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n     pub fn truncate(&mut self, len: usize) {\n+        /// Runs the destructor for all items in the slice when it gets dropped (normally or\n+        /// during unwinding).\n+        struct Dropper<'a, T>(&'a mut [T]);\n+\n+        impl<'a, T> Drop for Dropper<'a, T> {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    ptr::drop_in_place(self.0);\n+                }\n+            }\n+        }\n+\n         // Safe because:\n         //\n         // * Any slice passed to `drop_in_place` is valid; the second case has\n@@ -888,8 +905,11 @@ impl<T> VecDeque<T> {\n                 let drop_back = back as *mut _;\n                 let drop_front = front.get_unchecked_mut(len..) as *mut _;\n                 self.head = self.wrap_sub(self.head, num_dropped);\n+\n+                // Make sure the second half is dropped even when a destructor\n+                // in the first one panics.\n+                let _back_dropper = Dropper(&mut *drop_back);\n                 ptr::drop_in_place(drop_front);\n-                ptr::drop_in_place(drop_back);\n             }\n         }\n     }\n@@ -2526,113 +2546,6 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n-/// A draining iterator over the elements of a `VecDeque`.\n-///\n-/// This `struct` is created by the [`drain`] method on [`VecDeque`]. See its\n-/// documentation for more.\n-///\n-/// [`drain`]: struct.VecDeque.html#method.drain\n-/// [`VecDeque`]: struct.VecDeque.html\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-pub struct Drain<'a, T: 'a> {\n-    after_tail: usize,\n-    after_head: usize,\n-    iter: Iter<'a, T>,\n-    deque: NonNull<VecDeque<T>>,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Drain\")\n-            .field(&self.after_tail)\n-            .field(&self.after_head)\n-            .field(&self.iter)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Send> Send for Drain<'_, T> {}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> Drop for Drain<'_, T> {\n-    fn drop(&mut self) {\n-        self.for_each(drop);\n-\n-        let source_deque = unsafe { self.deque.as_mut() };\n-\n-        // T = source_deque_tail; H = source_deque_head; t = drain_tail; h = drain_head\n-        //\n-        //        T   t   h   H\n-        // [. . . o o x x o o . . .]\n-        //\n-        let orig_tail = source_deque.tail;\n-        let drain_tail = source_deque.head;\n-        let drain_head = self.after_tail;\n-        let orig_head = self.after_head;\n-\n-        let tail_len = count(orig_tail, drain_tail, source_deque.cap());\n-        let head_len = count(drain_head, orig_head, source_deque.cap());\n-\n-        // Restore the original head value\n-        source_deque.head = orig_head;\n-\n-        match (tail_len, head_len) {\n-            (0, 0) => {\n-                source_deque.head = 0;\n-                source_deque.tail = 0;\n-            }\n-            (0, _) => {\n-                source_deque.tail = drain_head;\n-            }\n-            (_, 0) => {\n-                source_deque.head = drain_tail;\n-            }\n-            _ => unsafe {\n-                if tail_len <= head_len {\n-                    source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n-                    source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n-                } else {\n-                    source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n-                    source_deque.wrap_copy(drain_tail, drain_head, head_len);\n-                }\n-            },\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> Iterator for Drain<'_, T> {\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<T> {\n-        self.iter.next().map(|elt| unsafe { ptr::read(elt) })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> DoubleEndedIterator for Drain<'_, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n-        self.iter.next_back().map(|elt| unsafe { ptr::read(elt) })\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> ExactSizeIterator for Drain<'_, T> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Drain<'_, T> {}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for VecDeque<A> {\n     fn eq(&self, other: &VecDeque<A>) -> bool {"}, {"sha": "1ae94de75adb7174f076a4cb61b10260089c142a", "filename": "src/liballoc/collections/vec_deque/drain.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fcollections%2Fvec_deque%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fcollections%2Fvec_deque%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Fdrain.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -0,0 +1,126 @@\n+use core::iter::FusedIterator;\n+use core::ptr::{self, NonNull};\n+use core::{fmt, mem};\n+\n+use super::{count, Iter, VecDeque};\n+\n+/// A draining iterator over the elements of a `VecDeque`.\n+///\n+/// This `struct` is created by the [`drain`] method on [`VecDeque`]. See its\n+/// documentation for more.\n+///\n+/// [`drain`]: struct.VecDeque.html#method.drain\n+/// [`VecDeque`]: struct.VecDeque.html\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+pub struct Drain<'a, T: 'a> {\n+    pub(crate) after_tail: usize,\n+    pub(crate) after_head: usize,\n+    pub(crate) iter: Iter<'a, T>,\n+    pub(crate) deque: NonNull<VecDeque<T>>,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Drain\")\n+            .field(&self.after_tail)\n+            .field(&self.after_head)\n+            .field(&self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+unsafe impl<T: Send> Send for Drain<'_, T> {}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T> Drop for Drain<'_, T> {\n+    fn drop(&mut self) {\n+        struct DropGuard<'r, 'a, T>(&'r mut Drain<'a, T>);\n+\n+        impl<'r, 'a, T> Drop for DropGuard<'r, 'a, T> {\n+            fn drop(&mut self) {\n+                self.0.for_each(drop);\n+\n+                let source_deque = unsafe { self.0.deque.as_mut() };\n+\n+                // T = source_deque_tail; H = source_deque_head; t = drain_tail; h = drain_head\n+                //\n+                //        T   t   h   H\n+                // [. . . o o x x o o . . .]\n+                //\n+                let orig_tail = source_deque.tail;\n+                let drain_tail = source_deque.head;\n+                let drain_head = self.0.after_tail;\n+                let orig_head = self.0.after_head;\n+\n+                let tail_len = count(orig_tail, drain_tail, source_deque.cap());\n+                let head_len = count(drain_head, orig_head, source_deque.cap());\n+\n+                // Restore the original head value\n+                source_deque.head = orig_head;\n+\n+                match (tail_len, head_len) {\n+                    (0, 0) => {\n+                        source_deque.head = 0;\n+                        source_deque.tail = 0;\n+                    }\n+                    (0, _) => {\n+                        source_deque.tail = drain_head;\n+                    }\n+                    (_, 0) => {\n+                        source_deque.head = drain_tail;\n+                    }\n+                    _ => unsafe {\n+                        if tail_len <= head_len {\n+                            source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n+                            source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n+                        } else {\n+                            source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n+                            source_deque.wrap_copy(drain_tail, drain_head, head_len);\n+                        }\n+                    },\n+                }\n+            }\n+        }\n+\n+        while let Some(item) = self.next() {\n+            let guard = DropGuard(self);\n+            drop(item);\n+            mem::forget(guard);\n+        }\n+\n+        DropGuard(self);\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T> Iterator for Drain<'_, T> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.iter.next().map(|elt| unsafe { ptr::read(elt) })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T> DoubleEndedIterator for Drain<'_, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        self.iter.next_back().map(|elt| unsafe { ptr::read(elt) })\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T> ExactSizeIterator for Drain<'_, T> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for Drain<'_, T> {}"}, {"sha": "144654946a2acb53225ac5dedb413f4a2aa95dd4", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -280,7 +280,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            let (new_cap, uniq) = match self.current_layout() {\n+            let (new_cap, ptr) = match self.current_layout() {\n                 Some(cur) => {\n                     // Since we guarantee that we never allocate more than\n                     // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n@@ -297,7 +297,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                     alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n                     let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(), cur, new_size);\n                     match ptr_res {\n-                        Ok(ptr) => (new_cap, ptr.cast().into()),\n+                        Ok(ptr) => (new_cap, ptr),\n                         Err(_) => handle_alloc_error(Layout::from_size_align_unchecked(\n                             new_size,\n                             cur.align(),\n@@ -308,13 +308,14 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                     // Skip to 4 because tiny `Vec`'s are dumb; but not if that\n                     // would cause overflow.\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n-                    match self.a.alloc_array::<T>(new_cap) {\n-                        Ok(ptr) => (new_cap, ptr.into()),\n-                        Err(_) => handle_alloc_error(Layout::array::<T>(new_cap).unwrap()),\n+                    let layout = Layout::array::<T>(new_cap).unwrap();\n+                    match self.a.alloc(layout) {\n+                        Ok(ptr) => (new_cap, ptr),\n+                        Err(_) => handle_alloc_error(layout),\n                     }\n                 }\n             };\n-            self.ptr = uniq;\n+            self.ptr = ptr.cast().into();\n             self.cap = new_cap;\n         }\n     }"}, {"sha": "f5afea15d655ee76ffc4587a28f22dd1fda46e84", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -319,7 +319,7 @@ pub struct String {\n /// assert_eq!(vec![0, 159], value.unwrap_err().into_bytes());\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Debug)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FromUtf8Error {\n     bytes: Vec<u8>,\n     error: Utf8Error,\n@@ -2106,26 +2106,19 @@ impl ops::DerefMut for String {\n     }\n }\n \n-/// An error when parsing a `String`.\n+/// A type alias for [`Infallible`].\n ///\n-/// This `enum` is slightly awkward: it will never actually exist. This error is\n-/// part of the type signature of the implementation of [`FromStr`] on\n-/// [`String`]. The return type of [`from_str`], requires that an error be\n-/// defined, but, given that a [`String`] can always be made into a new\n-/// [`String`] without error, this type will never actually be returned. As\n-/// such, it is only here to satisfy said signature, and is useless otherwise.\n+/// This alias exists for backwards compatibility, and may be eventually deprecated.\n ///\n-/// [`FromStr`]: ../../std/str/trait.FromStr.html\n-/// [`String`]: struct.String.html\n-/// [`from_str`]: ../../std/str/trait.FromStr.html#tymethod.from_str\n+/// [`Infallible`]: ../../core/convert/enum.Infallible.html\n #[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n pub type ParseError = core::convert::Infallible;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for String {\n     type Err = core::convert::Infallible;\n     #[inline]\n-    fn from_str(s: &str) -> Result<String, ParseError> {\n+    fn from_str(s: &str) -> Result<String, Self::Err> {\n         Ok(String::from(s))\n     }\n }\n@@ -2208,6 +2201,14 @@ impl AsRef<str> for String {\n     }\n }\n \n+#[stable(feature = \"string_as_mut\", since = \"1.43.0\")]\n+impl AsMut<str> for String {\n+    #[inline]\n+    fn as_mut(&mut self) -> &mut str {\n+        self\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<[u8]> for String {\n     #[inline]"}, {"sha": "be5516f54f37b75a519084609b90dd6eed9343a9", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,6 +1,8 @@\n use std::collections::binary_heap::{Drain, PeekMut};\n use std::collections::BinaryHeap;\n use std::iter::TrustedLen;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::sync::atomic::{AtomicU32, Ordering};\n \n #[test]\n fn test_iterator() {\n@@ -275,6 +277,37 @@ fn test_drain_sorted() {\n     assert!(q.is_empty());\n }\n \n+#[test]\n+fn test_drain_sorted_leak() {\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+    struct D(u32, bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            DROPS.fetch_add(1, Ordering::SeqCst);\n+\n+            if self.1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut q = BinaryHeap::from(vec![\n+        D(0, false),\n+        D(1, false),\n+        D(2, false),\n+        D(3, true),\n+        D(4, false),\n+        D(5, false),\n+    ]);\n+\n+    catch_unwind(AssertUnwindSafe(|| drop(q.drain_sorted()))).ok();\n+\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 6);\n+}\n+\n #[test]\n fn test_extend_ref() {\n     let mut a = BinaryHeap::new();"}, {"sha": "fd07a4d3926c3897bf26e789fc30ca5386ba5da2", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 65, "deletions": 20, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -5,7 +5,9 @@ use std::fmt::Debug;\n use std::iter::FromIterator;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n+use std::panic::catch_unwind;\n use std::rc::Rc;\n+use std::sync::atomic::{AtomicU32, Ordering};\n \n use super::DeterministicRng;\n \n@@ -15,14 +17,19 @@ fn test_basic_large() {\n     #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n     #[cfg(miri)]\n-    let size = 200;\n+    let size = 144; // to obtain height 3 tree (having edges to both kinds of nodes)\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n         assert_eq!(map.insert(i, 10 * i), None);\n         assert_eq!(map.len(), i + 1);\n     }\n \n+    assert_eq!(map.first_key_value(), Some((&0, &0)));\n+    assert_eq!(map.last_key_value(), Some((&(size - 1), &(10 * (size - 1)))));\n+    assert_eq!(map.first_entry().unwrap().key(), &0);\n+    assert_eq!(map.last_entry().unwrap().key(), &(size - 1));\n+\n     for i in 0..size {\n         assert_eq!(map.get(&i).unwrap(), &(i * 10));\n     }\n@@ -376,8 +383,8 @@ fn test_range_small() {\n }\n \n #[test]\n-fn test_range_depth_2() {\n-    // Assuming that node.CAPACITY is 11, having 12 pairs implies a depth 2 tree\n+fn test_range_height_2() {\n+    // Assuming that node.CAPACITY is 11, having 12 pairs implies a height 2 tree\n     // with 2 leaves. Depending on details we don't want or need to rely upon,\n     // the single key at the root will be 6 or 7.\n \n@@ -519,7 +526,7 @@ fn test_range_1000() {\n     #[cfg(not(miri))] // Miri is too slow\n     let size = 1000;\n     #[cfg(miri)]\n-    let size = 200;\n+    let size = 144; // to obtain height 3 tree (having edges to both kinds of nodes)\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n@@ -556,14 +563,15 @@ fn test_range_borrowed_key() {\n \n #[test]\n fn test_range() {\n-    #[cfg(not(miri))] // Miri is too slow\n     let size = 200;\n+    #[cfg(not(miri))] // Miri is too slow\n+    let step = 1;\n     #[cfg(miri)]\n-    let size = 30;\n+    let step = 66;\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-    for i in 0..size {\n-        for j in i..size {\n+    for i in (0..size).step_by(step) {\n+        for j in (i..size).step_by(step) {\n             let mut kvs = map.range((Included(&i), Included(&j))).map(|(&k, &v)| (k, v));\n             let mut pairs = (i..=j).map(|i| (i, i));\n \n@@ -578,14 +586,15 @@ fn test_range() {\n \n #[test]\n fn test_range_mut() {\n-    #[cfg(not(miri))] // Miri is too slow\n     let size = 200;\n+    #[cfg(not(miri))] // Miri is too slow\n+    let step = 1;\n     #[cfg(miri)]\n-    let size = 30;\n+    let step = 66;\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-    for i in 0..size {\n-        for j in i..size {\n+    for i in (0..size).step_by(step) {\n+        for j in (i..size).step_by(step) {\n             let mut kvs = map.range_mut((Included(&i), Included(&j))).map(|(&k, &mut v)| (k, v));\n             let mut pairs = (i..=j).map(|i| (i, i));\n \n@@ -753,10 +762,7 @@ fn test_bad_zst() {\n #[test]\n fn test_clone() {\n     let mut map = BTreeMap::new();\n-    #[cfg(not(miri))] // Miri is too slow\n-    let size = 100;\n-    #[cfg(miri)]\n-    let size = 30;\n+    let size = 12; // to obtain height 2 tree (having edges to leaf nodes)\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -783,24 +789,36 @@ fn test_clone() {\n         assert_eq!(map.len(), size / 2 - i - 1);\n         assert_eq!(map, map.clone());\n     }\n+\n+    // Full 2-level and minimal 3-level tree (sizes 143, 144 -- the only ones we clone for).\n+    for i in 1..=144 {\n+        assert_eq!(map.insert(i, i), None);\n+        assert_eq!(map.len(), i);\n+        if i >= 143 {\n+            assert_eq!(map, map.clone());\n+        }\n+    }\n }\n \n #[test]\n fn test_clone_from() {\n     let mut map1 = BTreeMap::new();\n-    let size = 30;\n+    let max_size = 12; // to obtain height 2 tree (having edges to leaf nodes)\n \n-    for i in 0..size {\n+    // Range to max_size inclusive, because i is the size of map1 being tested.\n+    for i in 0..=max_size {\n         let mut map2 = BTreeMap::new();\n         for j in 0..i {\n             let mut map1_copy = map2.clone();\n-            map1_copy.clone_from(&map1);\n+            map1_copy.clone_from(&map1); // small cloned from large\n             assert_eq!(map1_copy, map1);\n             let mut map2_copy = map1.clone();\n-            map2_copy.clone_from(&map2);\n+            map2_copy.clone_from(&map2); // large cloned from small\n             assert_eq!(map2_copy, map2);\n             map2.insert(100 * j + 1, 2 * j + 1);\n         }\n+        map2.clone_from(&map1); // same length\n+        assert_eq!(map2, map1);\n         map1.insert(i, 10 * i);\n     }\n }\n@@ -951,6 +969,7 @@ create_append_test!(test_append_145, 145);\n // Tests for several randomly chosen sizes.\n create_append_test!(test_append_170, 170);\n create_append_test!(test_append_181, 181);\n+#[cfg(not(miri))] // Miri is too slow\n create_append_test!(test_append_239, 239);\n #[cfg(not(miri))] // Miri is too slow\n create_append_test!(test_append_1700, 1700);\n@@ -1000,3 +1019,29 @@ fn test_split_off_large_random_sorted() {\n     assert!(map.into_iter().eq(data.clone().into_iter().filter(|x| x.0 < key)));\n     assert!(right.into_iter().eq(data.into_iter().filter(|x| x.0 >= key)));\n }\n+\n+#[test]\n+fn test_into_iter_drop_leak() {\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    struct D;\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            if DROPS.fetch_add(1, Ordering::SeqCst) == 3 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut map = BTreeMap::new();\n+    map.insert(\"a\", D);\n+    map.insert(\"b\", D);\n+    map.insert(\"c\", D);\n+    map.insert(\"d\", D);\n+    map.insert(\"e\", D);\n+\n+    catch_unwind(move || drop(map.into_iter())).ok();\n+\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 5);\n+}"}, {"sha": "1a2b62d026b2ec969a38ef9186e9eff027a26eeb", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -487,21 +487,26 @@ fn test_first_last() {\n     a.insert(2);\n     assert_eq!(a.first(), Some(&1));\n     assert_eq!(a.last(), Some(&2));\n-    a.insert(3);\n+    for i in 3..=12 {\n+        a.insert(i);\n+    }\n     assert_eq!(a.first(), Some(&1));\n-    assert_eq!(a.last(), Some(&3));\n-\n-    assert_eq!(a.len(), 3);\n+    assert_eq!(a.last(), Some(&12));\n     assert_eq!(a.pop_first(), Some(1));\n-    assert_eq!(a.len(), 2);\n-    assert_eq!(a.pop_last(), Some(3));\n-    assert_eq!(a.len(), 1);\n+    assert_eq!(a.pop_last(), Some(12));\n     assert_eq!(a.pop_first(), Some(2));\n-    assert_eq!(a.len(), 0);\n-    assert_eq!(a.pop_last(), None);\n-    assert_eq!(a.len(), 0);\n+    assert_eq!(a.pop_last(), Some(11));\n+    assert_eq!(a.pop_first(), Some(3));\n+    assert_eq!(a.pop_last(), Some(10));\n+    assert_eq!(a.pop_first(), Some(4));\n+    assert_eq!(a.pop_first(), Some(5));\n+    assert_eq!(a.pop_first(), Some(6));\n+    assert_eq!(a.pop_first(), Some(7));\n+    assert_eq!(a.pop_first(), Some(8));\n+    assert_eq!(a.clone().pop_last(), Some(9));\n+    assert_eq!(a.pop_first(), Some(9));\n     assert_eq!(a.pop_first(), None);\n-    assert_eq!(a.len(), 0);\n+    assert_eq!(a.pop_last(), None);\n }\n \n fn rand_data(len: usize) -> Vec<u32> {"}, {"sha": "ea75f8903c3685fdd73203a18a810889c2e49615", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -12,6 +12,7 @@\n #![feature(binary_heap_into_iter_sorted)]\n #![feature(binary_heap_drain_sorted)]\n #![feature(vec_remove_item)]\n+#![feature(split_inclusive)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "afcb9e03fd097db71203c13a44c58322341e3777", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,5 +1,5 @@\n use std::collections::LinkedList;\n-use std::panic::catch_unwind;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n \n #[test]\n fn test_basic() {\n@@ -531,6 +531,74 @@ fn drain_filter_complex() {\n     }\n }\n \n+#[test]\n+fn drain_filter_drop_panic_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    struct D(bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut q = LinkedList::new();\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_front(D(false));\n+    q.push_front(D(true));\n+    q.push_front(D(false));\n+\n+    catch_unwind(AssertUnwindSafe(|| drop(q.drain_filter(|_| true)))).ok();\n+\n+    assert_eq!(unsafe { DROPS }, 8);\n+    assert!(q.is_empty());\n+}\n+\n+#[test]\n+fn drain_filter_pred_panic_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    #[derive(Debug)]\n+    struct D(u32);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut q = LinkedList::new();\n+    q.push_back(D(3));\n+    q.push_back(D(4));\n+    q.push_back(D(5));\n+    q.push_back(D(6));\n+    q.push_back(D(7));\n+    q.push_front(D(2));\n+    q.push_front(D(1));\n+    q.push_front(D(0));\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        drop(q.drain_filter(|item| if item.0 >= 2 { panic!() } else { true }))\n+    }))\n+    .ok();\n+\n+    assert_eq!(unsafe { DROPS }, 2); // 0 and 1\n+    assert_eq!(q.len(), 6);\n+}\n+\n #[test]\n fn test_drop() {\n     static mut DROPS: i32 = 0;"}, {"sha": "3d6b4bff5e06046fff2321769cda7c812bdb80ea", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -851,6 +851,86 @@ fn test_splitator() {\n     assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n }\n \n+#[test]\n+fn test_splitator_inclusive() {\n+    let xs = &[1, 2, 3, 4, 5];\n+\n+    let splits: &[&[_]] = &[&[1, 2], &[3, 4], &[5]];\n+    assert_eq!(xs.split_inclusive(|x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 1).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 5).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 10).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[2], &[3], &[4], &[5]];\n+    assert_eq!(xs.split_inclusive(|_| true).collect::<Vec<&[i32]>>(), splits);\n+\n+    let xs: &[i32] = &[];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n+}\n+\n+#[test]\n+fn test_splitator_inclusive_reverse() {\n+    let xs = &[1, 2, 3, 4, 5];\n+\n+    let splits: &[&[_]] = &[&[5], &[3, 4], &[1, 2]];\n+    assert_eq!(xs.split_inclusive(|x| *x % 2 == 0).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[2, 3, 4, 5], &[1]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 1).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 10).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[5], &[4], &[3], &[2], &[1]];\n+    assert_eq!(xs.split_inclusive(|_| true).rev().collect::<Vec<_>>(), splits);\n+\n+    let xs: &[i32] = &[];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+}\n+\n+#[test]\n+fn test_splitator_mut_inclusive() {\n+    let xs = &mut [1, 2, 3, 4, 5];\n+\n+    let splits: &[&[_]] = &[&[1, 2], &[3, 4], &[5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 1).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 5).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 10).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[2], &[3], &[4], &[5]];\n+    assert_eq!(xs.split_inclusive_mut(|_| true).collect::<Vec<_>>(), splits);\n+\n+    let xs: &mut [i32] = &mut [];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 5).collect::<Vec<_>>(), splits);\n+}\n+\n+#[test]\n+fn test_splitator_mut_inclusive_reverse() {\n+    let xs = &mut [1, 2, 3, 4, 5];\n+\n+    let splits: &[&[_]] = &[&[5], &[3, 4], &[1, 2]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x % 2 == 0).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[2, 3, 4, 5], &[1]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 1).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 10).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[5], &[4], &[3], &[2], &[1]];\n+    assert_eq!(xs.split_inclusive_mut(|_| true).rev().collect::<Vec<_>>(), splits);\n+\n+    let xs: &mut [i32] = &mut [];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+}\n+\n #[test]\n fn test_splitnator() {\n     let xs = &[1, 2, 3, 4, 5];"}, {"sha": "b703df6f3cb7de00a6d1974b418482ae2919a676", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1247,6 +1247,49 @@ fn test_split_char_iterator_no_trailing() {\n     assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n }\n \n+#[test]\n+fn test_split_char_iterator_inclusive() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.split_inclusive('\\n').collect();\n+    assert_eq!(split, [\"\\n\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\", \"Little l\u00e4mb\\n\"]);\n+\n+    let uppercase_separated = \"SheePSharKTurtlECaT\";\n+    let mut first_char = true;\n+    let split: Vec<&str> = uppercase_separated\n+        .split_inclusive(|c: char| {\n+            let split = !first_char && c.is_uppercase();\n+            first_char = split;\n+            split\n+        })\n+        .collect();\n+    assert_eq!(split, [\"SheeP\", \"SharK\", \"TurtlE\", \"CaT\"]);\n+}\n+\n+#[test]\n+fn test_split_char_iterator_inclusive_rev() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.split_inclusive('\\n').rev().collect();\n+    assert_eq!(split, [\"Little l\u00e4mb\\n\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\", \"\\n\"]);\n+\n+    // Note that the predicate is stateful and thus dependent\n+    // on the iteration order.\n+    // (A different predicate is needed for reverse iterator vs normal iterator.)\n+    // Not sure if anything can be done though.\n+    let uppercase_separated = \"SheePSharKTurtlECaT\";\n+    let mut term_char = true;\n+    let split: Vec<&str> = uppercase_separated\n+        .split_inclusive(|c: char| {\n+            let split = term_char && c.is_uppercase();\n+            term_char = c.is_uppercase();\n+            split\n+        })\n+        .rev()\n+        .collect();\n+    assert_eq!(split, [\"CaT\", \"TurtlE\", \"SharK\", \"SheeP\"]);\n+}\n+\n #[test]\n fn test_rsplit() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "08859b2b24bde0b2c715cbb569f95ef1cd0c18e1", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -50,7 +50,11 @@ fn test_from_utf8() {\n \n     let xs = b\"hello\\xFF\".to_vec();\n     let err = String::from_utf8(xs).unwrap_err();\n+    assert_eq!(err.as_bytes(), b\"hello\\xff\");\n+    let err_clone = err.clone();\n+    assert_eq!(err, err_clone);\n     assert_eq!(err.into_bytes(), b\"hello\\xff\".to_vec());\n+    assert_eq!(err_clone.utf8_error().valid_up_to(), 5);\n }\n \n #[test]"}, {"sha": "9c4ac52acac2a749b9c55803b7645ed180af24d5", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,6 +1,7 @@\n use std::borrow::Cow;\n use std::collections::TryReserveError::*;\n use std::mem::size_of;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::vec::{Drain, IntoIter};\n use std::{isize, usize};\n \n@@ -585,6 +586,44 @@ fn test_drain_inclusive_out_of_bounds() {\n     v.drain(5..=5);\n }\n \n+#[test]\n+fn test_drain_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct D(u32, bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut v = vec![\n+        D(0, false),\n+        D(1, false),\n+        D(2, false),\n+        D(3, false),\n+        D(4, true),\n+        D(5, false),\n+        D(6, false),\n+    ];\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        v.drain(2..=5);\n+    }))\n+    .ok();\n+\n+    assert_eq!(unsafe { DROPS }, 4);\n+    assert_eq!(v, vec![D(0, false), D(1, false), D(6, false),]);\n+}\n+\n #[test]\n fn test_splice() {\n     let mut v = vec![1, 2, 3, 4, 5];\n@@ -726,6 +765,31 @@ fn test_into_iter_clone() {\n     assert_eq!(it.next(), None);\n }\n \n+#[test]\n+fn test_into_iter_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    struct D(bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let v = vec![D(false), D(true), D(false)];\n+\n+    catch_unwind(move || drop(v.into_iter())).ok();\n+\n+    assert_eq!(unsafe { DROPS }, 3);\n+}\n+\n #[test]\n fn test_cow_from() {\n     let borrowed: &[_] = &[\"borrowed\", \"(slice)\"];"}, {"sha": "101dd67d97a9a4a37bc37218ad21e9b22a16ea7b", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -2,7 +2,7 @@ use std::collections::TryReserveError::*;\n use std::collections::{vec_deque::Drain, VecDeque};\n use std::fmt::Debug;\n use std::mem::size_of;\n-use std::panic::catch_unwind;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::{isize, usize};\n \n use crate::hash;\n@@ -1573,3 +1573,75 @@ fn test_try_rfold_moves_iter() {\n     assert_eq!(iter.try_rfold(0_i8, |acc, &x| acc.checked_add(x)), None);\n     assert_eq!(iter.next_back(), Some(&70));\n }\n+\n+#[test]\n+fn truncate_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    struct D(bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut q = VecDeque::new();\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_front(D(true));\n+    q.push_front(D(false));\n+    q.push_front(D(false));\n+\n+    catch_unwind(AssertUnwindSafe(|| q.truncate(1))).ok();\n+\n+    assert_eq!(unsafe { DROPS }, 7);\n+}\n+\n+#[test]\n+fn test_drain_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct D(u32, bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut v = VecDeque::new();\n+    v.push_back(D(4, false));\n+    v.push_back(D(5, false));\n+    v.push_back(D(6, false));\n+    v.push_front(D(3, false));\n+    v.push_front(D(2, true));\n+    v.push_front(D(1, false));\n+    v.push_front(D(0, false));\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        v.drain(1..=4);\n+    }))\n+    .ok();\n+\n+    assert_eq!(unsafe { DROPS }, 4);\n+    assert_eq!(v.len(), 3);\n+    drop(v);\n+    assert_eq!(unsafe { DROPS }, 7);\n+}"}, {"sha": "29987ac44e6f9db2037392a817cb3194f7ce01b2", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -2622,7 +2622,9 @@ impl<T: Clone> Clone for IntoIter<T> {\n unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n-        for _x in self.by_ref() {}\n+        unsafe {\n+            ptr::drop_in_place(self.as_mut_slice());\n+        }\n \n         // RawVec handles deallocation\n         let _ = unsafe { RawVec::from_raw_parts(self.buf.as_ptr(), self.cap) };\n@@ -2702,23 +2704,42 @@ impl<T> DoubleEndedIterator for Drain<'_, T> {\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<T> Drop for Drain<'_, T> {\n     fn drop(&mut self) {\n-        // exhaust self first\n-        self.for_each(drop);\n+        /// Continues dropping the remaining elements in the `Drain`, then moves back the\n+        /// un-`Drain`ed elements to restore the original `Vec`.\n+        struct DropGuard<'r, 'a, T>(&'r mut Drain<'a, T>);\n \n-        if self.tail_len > 0 {\n-            unsafe {\n-                let source_vec = self.vec.as_mut();\n-                // memmove back untouched tail, update to new length\n-                let start = source_vec.len();\n-                let tail = self.tail_start;\n-                if tail != start {\n-                    let src = source_vec.as_ptr().add(tail);\n-                    let dst = source_vec.as_mut_ptr().add(start);\n-                    ptr::copy(src, dst, self.tail_len);\n+        impl<'r, 'a, T> Drop for DropGuard<'r, 'a, T> {\n+            fn drop(&mut self) {\n+                // Continue the same loop we have below. If the loop already finished, this does\n+                // nothing.\n+                self.0.for_each(drop);\n+\n+                if self.0.tail_len > 0 {\n+                    unsafe {\n+                        let source_vec = self.0.vec.as_mut();\n+                        // memmove back untouched tail, update to new length\n+                        let start = source_vec.len();\n+                        let tail = self.0.tail_start;\n+                        if tail != start {\n+                            let src = source_vec.as_ptr().add(tail);\n+                            let dst = source_vec.as_mut_ptr().add(start);\n+                            ptr::copy(src, dst, self.0.tail_len);\n+                        }\n+                        source_vec.set_len(start + self.0.tail_len);\n+                    }\n                 }\n-                source_vec.set_len(start + self.tail_len);\n             }\n         }\n+\n+        // exhaust self first\n+        while let Some(item) = self.next() {\n+            let guard = DropGuard(self);\n+            drop(item);\n+            mem::forget(guard);\n+        }\n+\n+        // Drop a `DropGuard` to move back the non-drained tail of `self`.\n+        DropGuard(self);\n     }\n }\n "}, {"sha": "a04e75bc7ce7c6d32ab0644ffba781203006b11b", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 146, "deletions": 204, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -241,11 +241,13 @@ impl Layout {\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n     #[inline]\n     pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n-        // This cannot overflow. Quoting from the invariant of Layout:\n-        // > `size`, when rounded up to the nearest multiple of `align`,\n-        // > must not overflow (i.e., the rounded value must be less than\n-        // > `usize::MAX`)\n-        let padded_size = self.size() + self.padding_needed_for(self.align());\n+        // Warning, removing the checked_add here led to segfaults in #67174. Further\n+        // analysis in #69225 seems to indicate that this is an LTO-related\n+        // miscompilation, so #67174 might be able to be reapplied in the future.\n+        let padded_size = self\n+            .size()\n+            .checked_add(self.padding_needed_for(self.align()))\n+            .ok_or(LayoutErr { private: () })?;\n         let alloc_size = padded_size.checked_mul(n).ok_or(LayoutErr { private: () })?;\n \n         unsafe {\n@@ -593,9 +595,8 @@ pub unsafe trait GlobalAlloc {\n ///\n /// * the starting address for that memory block was previously\n ///   returned by a previous call to an allocation method (`alloc`,\n-///   `alloc_zeroed`, `alloc_excess`, `alloc_one`, `alloc_array`) or\n-///   reallocation method (`realloc`, `realloc_excess`, or\n-///   `realloc_array`), and\n+///   `alloc_zeroed`, `alloc_excess`) or reallocation method\n+///   (`realloc`, `realloc_excess`), and\n ///\n /// * the memory block has not been subsequently deallocated, where\n ///   blocks are deallocated either by being passed to a deallocation\n@@ -606,11 +607,6 @@ pub unsafe trait GlobalAlloc {\n /// methods in the `AllocRef` trait state that allocation requests\n /// must be non-zero size, or else undefined behavior can result.\n ///\n-/// * However, some higher-level allocation methods (`alloc_one`,\n-///   `alloc_array`) are well-defined on zero-sized types and can\n-///   optionally support them: it is left up to the implementor\n-///   whether to return `Err`, or to return `Ok` with some pointer.\n-///\n /// * If an `AllocRef` implementation chooses to return `Ok` in this\n ///   case (i.e., the pointer denotes a zero-sized inaccessible block)\n ///   then that returned pointer must be considered \"currently\n@@ -853,6 +849,59 @@ pub unsafe trait AllocRef {\n         result\n     }\n \n+    /// Behaves like `realloc`, but also ensures that the new contents\n+    /// are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `realloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err` only if the new layout\n+    /// does not meet the allocator's size\n+    /// and alignment constraints of the allocator, or if reallocation\n+    /// otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory\n+    /// exhaustion rather than panicking or aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn realloc_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<NonNull<u8>, AllocErr> {\n+        let old_size = layout.size();\n+\n+        if new_size >= old_size {\n+            if let Ok(()) = self.grow_in_place_zeroed(ptr, layout, new_size) {\n+                return Ok(ptr);\n+            }\n+        } else if new_size < old_size {\n+            if let Ok(()) = self.shrink_in_place(ptr, layout, new_size) {\n+                return Ok(ptr);\n+            }\n+        }\n+\n+        // otherwise, fall back on alloc + copy + dealloc.\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let result = self.alloc_zeroed(new_layout);\n+        if let Ok(new_ptr) = result {\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n+            self.dealloc(ptr, layout);\n+        }\n+        result\n+    }\n+\n     /// Behaves like `alloc`, but also ensures that the contents\n     /// are set to zero before being returned.\n     ///\n@@ -904,6 +953,31 @@ pub unsafe trait AllocRef {\n         self.alloc(layout).map(|p| Excess(p, usable_size.1))\n     }\n \n+    /// Behaves like `alloc`, but also returns the whole size of\n+    /// the returned block. For some `layout` inputs, like arrays, this\n+    /// may include extra storage usable for additional data.\n+    /// Also it ensures that the contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn alloc_excess_zeroed(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n+        let usable_size = self.usable_size(&layout);\n+        self.alloc_zeroed(layout).map(|p| Excess(p, usable_size.1))\n+    }\n+\n     /// Behaves like `realloc`, but also returns the whole size of\n     /// the returned block. For some `layout` inputs, like arrays, this\n     /// may include extra storage usable for additional data.\n@@ -934,6 +1008,37 @@ pub unsafe trait AllocRef {\n         self.realloc(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n     }\n \n+    /// Behaves like `realloc`, but also returns the whole size of\n+    /// the returned block. For some `layout` inputs, like arrays, this\n+    /// may include extra storage usable for additional data.\n+    /// Also it ensures that the contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `realloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `realloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn realloc_excess_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<Excess, AllocErr> {\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let usable_size = self.usable_size(&new_layout);\n+        self.realloc_zeroed(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n+    }\n+\n     /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n@@ -983,6 +1088,34 @@ pub unsafe trait AllocRef {\n         if new_size <= u { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n \n+    /// Behaves like `grow_in_place`, but also ensures that the new\n+    /// contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `grow_in_place` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n+    /// unable to assert that the memory block referenced by `ptr`\n+    /// could fit `layout`.\n+    ///\n+    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n+    /// function; clients are expected either to be able to recover from\n+    /// `grow_in_place` failures without aborting, or to fall back on\n+    /// another reallocation method before resorting to an abort.\n+    unsafe fn grow_in_place_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<(), CannotReallocInPlace> {\n+        self.grow_in_place(ptr, layout, new_size)?;\n+        ptr.as_ptr().add(layout.size()).write_bytes(0, new_size - layout.size());\n+        Ok(())\n+    }\n+\n     /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n@@ -1035,195 +1168,4 @@ pub unsafe trait AllocRef {\n         // new_layout.size() <= layout.size()        [required by this method]\n         if l <= new_size { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n-\n-    // == COMMON USAGE PATTERNS ==\n-    // alloc_one, dealloc_one, alloc_array, realloc_array. dealloc_array\n-\n-    /// Allocates a block suitable for holding an instance of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n-    /// must be considered \"currently allocated\" and must be\n-    /// acceptable input to methods such as `realloc` or `dealloc`,\n-    /// *even if* `T` is a zero-sized type. In other words, if your\n-    /// `AllocRef` implementation overrides this method in a manner\n-    /// that can return a zero-sized `ptr`, then all reallocation and\n-    /// deallocation methods need to be similarly overridden to accept\n-    /// such values as input.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `T` does not meet allocator's size or alignment constraints.\n-    ///\n-    /// For zero-sized `T`, may return either of `Ok` or `Err`, but\n-    /// will *not* yield undefined behavior.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_one<T>(&mut self) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        let k = Layout::new::<T>();\n-        if k.size() > 0 { unsafe { self.alloc(k).map(|p| p.cast()) } } else { Err(AllocErr) }\n-    }\n-\n-    /// Deallocates a block suitable for holding an instance of `T`.\n-    ///\n-    /// The given block must have been produced by this allocator,\n-    /// and must be suitable for storing a `T` (in terms of alignment\n-    /// as well as minimum and maximum size); otherwise yields\n-    /// undefined behavior.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure both:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via this allocator\n-    ///\n-    /// * the layout of `T` must *fit* that block of memory.\n-    unsafe fn dealloc_one<T>(&mut self, ptr: NonNull<T>)\n-    where\n-        Self: Sized,\n-    {\n-        let k = Layout::new::<T>();\n-        if k.size() > 0 {\n-            self.dealloc(ptr.cast(), k);\n-        }\n-    }\n-\n-    /// Allocates a block suitable for holding `n` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n-    /// must be considered \"currently allocated\" and must be\n-    /// acceptable input to methods such as `realloc` or `dealloc`,\n-    /// *even if* `T` is a zero-sized type. In other words, if your\n-    /// `AllocRef` implementation overrides this method in a manner\n-    /// that can return a zero-sized `ptr`, then all reallocation and\n-    /// deallocation methods need to be similarly overridden to accept\n-    /// such values as input.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `[T; n]` does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// For zero-sized `T` or `n == 0`, may return either of `Ok` or\n-    /// `Err`, but will *not* yield undefined behavior.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_array<T>(&mut self, n: usize) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match Layout::array::<T>(n) {\n-            Ok(layout) if layout.size() > 0 => unsafe { self.alloc(layout).map(|p| p.cast()) },\n-            _ => Err(AllocErr),\n-        }\n-    }\n-\n-    /// Reallocates a block previously suitable for holding `n_old`\n-    /// instances of `T`, returning a block suitable for holding\n-    /// `n_new` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * the layout of `[T; n_old]` must *fit* that block of memory.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `[T; n_new]` does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// For zero-sized `T` or `n_new == 0`, may return either of `Ok` or\n-    /// `Err`, but will *not* yield undefined behavior.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_array<T>(\n-        &mut self,\n-        ptr: NonNull<T>,\n-        n_old: usize,\n-        n_new: usize,\n-    ) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match (Layout::array::<T>(n_old), Layout::array::<T>(n_new)) {\n-            (Ok(k_old), Ok(k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n-                debug_assert!(k_old.align() == k_new.align());\n-                self.realloc(ptr.cast(), k_old, k_new.size()).map(NonNull::cast)\n-            }\n-            _ => Err(AllocErr),\n-        }\n-    }\n-\n-    /// Deallocates a block suitable for holding `n` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure both:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via this allocator\n-    ///\n-    /// * the layout of `[T; n]` must *fit* that block of memory.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either `[T; n]` or the given\n-    /// memory block does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    unsafe fn dealloc_array<T>(&mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match Layout::array::<T>(n) {\n-            Ok(k) if k.size() > 0 => Ok(self.dealloc(ptr.cast(), k)),\n-            _ => Err(AllocErr),\n-        }\n-    }\n }"}, {"sha": "9ebb317641875ae42b31634c61f3eeff9781cff2", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1245,6 +1245,38 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         let borrow = orig.borrow.clone();\n         (Ref { value: a, borrow }, Ref { value: b, borrow: orig.borrow })\n     }\n+\n+    /// Convert into a reference to the underlying data.\n+    ///\n+    /// The underlying `RefCell` can never be mutably borrowed from again and will always appear\n+    /// already immutably borrowed. It is not a good idea to leak more than a constant number of\n+    /// references. The `RefCell` can be immutably borrowed again if only a smaller number of leaks\n+    /// have occurred in total.\n+    ///\n+    /// This is an associated function that needs to be used as\n+    /// `Ref::leak(...)`. A method would interfere with methods of the\n+    /// same name on the contents of a `RefCell` used through `Deref`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cell_leak)]\n+    /// use std::cell::{RefCell, Ref};\n+    /// let cell = RefCell::new(0);\n+    ///\n+    /// let value = Ref::leak(cell.borrow());\n+    /// assert_eq!(*value, 0);\n+    ///\n+    /// assert!(cell.try_borrow().is_ok());\n+    /// assert!(cell.try_borrow_mut().is_err());\n+    /// ```\n+    #[unstable(feature = \"cell_leak\", issue = \"69099\")]\n+    pub fn leak(orig: Ref<'b, T>) -> &'b T {\n+        // By forgetting this Ref we ensure that the borrow counter in the RefCell never goes back\n+        // to UNUSED again. No further mutable references can be created from the original cell.\n+        mem::forget(orig.borrow);\n+        orig.value\n+    }\n }\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n@@ -1330,6 +1362,37 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         let borrow = orig.borrow.clone();\n         (RefMut { value: a, borrow }, RefMut { value: b, borrow: orig.borrow })\n     }\n+\n+    /// Convert into a mutable reference to the underlying data.\n+    ///\n+    /// The underlying `RefCell` can not be borrowed from again and will always appear already\n+    /// mutably borrowed, making the returned reference the only to the interior.\n+    ///\n+    /// This is an associated function that needs to be used as\n+    /// `RefMut::leak(...)`. A method would interfere with methods of the\n+    /// same name on the contents of a `RefCell` used through `Deref`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cell_leak)]\n+    /// use std::cell::{RefCell, RefMut};\n+    /// let cell = RefCell::new(0);\n+    ///\n+    /// let value = RefMut::leak(cell.borrow_mut());\n+    /// assert_eq!(*value, 0);\n+    /// *value = 1;\n+    ///\n+    /// assert!(cell.try_borrow_mut().is_err());\n+    /// ```\n+    #[unstable(feature = \"cell_leak\", issue = \"69099\")]\n+    pub fn leak(orig: RefMut<'b, T>) -> &'b mut T {\n+        // By forgetting this BorrowRefMut we ensure that the borrow counter in the RefCell never\n+        // goes back to UNUSED again. No further references can be created from the original cell,\n+        // making the current borrow the only reference for the remaining lifetime.\n+        mem::forget(orig.borrow);\n+        orig.value\n+    }\n }\n \n struct BorrowRefMut<'b> {\n@@ -1475,6 +1538,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n #[lang = \"unsafe_cell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(transparent)]\n+#[cfg_attr(not(bootstrap), repr(no_niche))] // rust-lang/rust#68303.\n pub struct UnsafeCell<T: ?Sized> {\n     value: T,\n }"}, {"sha": "302400744e25df541fbda73dcfbdb17dc240997f", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 60, "deletions": 20, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1072,9 +1072,13 @@ impl char {\n     /// assert!(!esc.is_ascii_alphabetic());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_alphabetic(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_alphabetic()\n+    pub const fn is_ascii_alphabetic(&self) -> bool {\n+        match *self {\n+            'A'..='Z' | 'a'..='z' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII uppercase character:\n@@ -1104,9 +1108,13 @@ impl char {\n     /// assert!(!esc.is_ascii_uppercase());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_uppercase(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_uppercase()\n+    pub const fn is_ascii_uppercase(&self) -> bool {\n+        match *self {\n+            'A'..='Z' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII lowercase character:\n@@ -1136,9 +1144,13 @@ impl char {\n     /// assert!(!esc.is_ascii_lowercase());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_lowercase(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_lowercase()\n+    pub const fn is_ascii_lowercase(&self) -> bool {\n+        match *self {\n+            'a'..='z' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII alphanumeric character:\n@@ -1171,9 +1183,13 @@ impl char {\n     /// assert!(!esc.is_ascii_alphanumeric());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_alphanumeric(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_alphanumeric()\n+    pub const fn is_ascii_alphanumeric(&self) -> bool {\n+        match *self {\n+            '0'..='9' | 'A'..='Z' | 'a'..='z' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII decimal digit:\n@@ -1203,9 +1219,13 @@ impl char {\n     /// assert!(!esc.is_ascii_digit());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_digit(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_digit()\n+    pub const fn is_ascii_digit(&self) -> bool {\n+        match *self {\n+            '0'..='9' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII hexadecimal digit:\n@@ -1238,9 +1258,13 @@ impl char {\n     /// assert!(!esc.is_ascii_hexdigit());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_hexdigit(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_hexdigit()\n+    pub const fn is_ascii_hexdigit(&self) -> bool {\n+        match *self {\n+            '0'..='9' | 'A'..='F' | 'a'..='f' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII punctuation character:\n@@ -1274,9 +1298,13 @@ impl char {\n     /// assert!(!esc.is_ascii_punctuation());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_punctuation(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_punctuation()\n+    pub const fn is_ascii_punctuation(&self) -> bool {\n+        match *self {\n+            '!'..='/' | ':'..='@' | '['..='`' | '{'..='~' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII graphic character:\n@@ -1306,9 +1334,13 @@ impl char {\n     /// assert!(!esc.is_ascii_graphic());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_graphic(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_graphic()\n+    pub const fn is_ascii_graphic(&self) -> bool {\n+        match *self {\n+            '!'..='~' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII whitespace character:\n@@ -1355,9 +1387,13 @@ impl char {\n     /// assert!(!esc.is_ascii_whitespace());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_whitespace(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_whitespace()\n+    pub const fn is_ascii_whitespace(&self) -> bool {\n+        match *self {\n+            '\\t' | '\\n' | '\\x0C' | '\\r' | ' ' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII control character:\n@@ -1389,8 +1425,12 @@ impl char {\n     /// assert!(esc.is_ascii_control());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_control(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_control()\n+    pub const fn is_ascii_control(&self) -> bool {\n+        match *self {\n+            '\\0'..='\\x1F' | '\\x7F' => true,\n+            _ => false,\n+        }\n     }\n }"}, {"sha": "604be7d5f68d0f78f8617ee809c1149b468d517d", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -361,6 +361,7 @@ impl Ordering {\n     /// assert!(data == b);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reverse(self) -> Ordering {\n         match self {\n@@ -398,6 +399,7 @@ impl Ordering {\n     /// assert_eq!(result, Ordering::Less);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n     pub fn then(self, other: Ordering) -> Ordering {\n         match self {\n@@ -435,6 +437,7 @@ impl Ordering {\n     /// assert_eq!(result, Ordering::Less);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n     pub fn then_with<F: FnOnce() -> Ordering>(self, f: F) -> Ordering {\n         match self {\n@@ -576,6 +579,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(10.cmp(&5), Ordering::Greater);\n     /// assert_eq!(5.cmp(&5), Ordering::Equal);\n     /// ```\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Self) -> Ordering;\n \n@@ -591,6 +595,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// ```\n     #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     #[inline]\n+    #[must_use]\n     fn max(self, other: Self) -> Self\n     where\n         Self: Sized,\n@@ -610,6 +615,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// ```\n     #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     #[inline]\n+    #[must_use]\n     fn min(self, other: Self) -> Self\n     where\n         Self: Sized,\n@@ -635,6 +641,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert!(0.clamp(-2, 1) == 0);\n     /// assert!(2.clamp(-2, 1) == 1);\n     /// ```\n+    #[must_use]\n     #[unstable(feature = \"clamp\", issue = \"44095\")]\n     fn clamp(self, min: Self, max: Self) -> Self\n     where\n@@ -915,6 +922,7 @@ pub macro PartialOrd($item:item) {\n /// assert_eq!(2, cmp::min(2, 2));\n /// ```\n #[inline]\n+#[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     v1.min(v2)\n@@ -935,6 +943,7 @@ pub fn min<T: Ord>(v1: T, v2: T) -> T {\n /// assert_eq!(cmp::min_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n /// ```\n #[inline]\n+#[must_use]\n #[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n     match compare(&v1, &v2) {\n@@ -958,6 +967,7 @@ pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n /// assert_eq!(cmp::min_by_key(-2, 2, |x: &i32| x.abs()), -2);\n /// ```\n #[inline]\n+#[must_use]\n #[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n     min_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n@@ -978,6 +988,7 @@ pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n /// assert_eq!(2, cmp::max(2, 2));\n /// ```\n #[inline]\n+#[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     v1.max(v2)\n@@ -998,6 +1009,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n /// assert_eq!(cmp::max_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 2);\n /// ```\n #[inline]\n+#[must_use]\n #[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n     match compare(&v1, &v2) {\n@@ -1021,6 +1033,7 @@ pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n /// assert_eq!(cmp::max_by_key(-2, 2, |x: &i32| x.abs()), 2);\n /// ```\n #[inline]\n+#[must_use]\n #[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n pub fn max_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n     max_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))"}, {"sha": "5ef673009bb6d8469d765d081344db442194d33a", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -29,7 +29,6 @@ where\n             *num,\n             sign,\n             precision,\n-            false,\n             buf.get_mut(),\n             parts.get_mut(),\n         );\n@@ -59,7 +58,6 @@ where\n             *num,\n             sign,\n             precision,\n-            false,\n             buf.get_mut(),\n             parts.get_mut(),\n         );"}, {"sha": "993b1073493e9dd731b54217675dc6da4fd0d5fb", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -238,16 +238,8 @@ pub struct Formatter<'a> {\n // NB. Argument is essentially an optimized partially applied formatting function,\n // equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n \n-struct Void {\n-    _priv: (),\n-    /// Erases all oibits, because `Void` erases the type of the object that\n-    /// will be used to produce formatted output. Since we do not know what\n-    /// oibits the real types have (and they can have any or none), we need to\n-    /// take the most conservative approach and forbid all oibits.\n-    ///\n-    /// It was added after #45197 showed that one could share a `!Sync`\n-    /// object across threads by passing it into `format_args!`.\n-    _oibit_remover: PhantomData<*mut dyn Fn()>,\n+extern \"C\" {\n+    type Opaque;\n }\n \n /// This struct represents the generic \"argument\" which is taken by the Xprintf\n@@ -259,16 +251,23 @@ struct Void {\n #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n #[doc(hidden)]\n pub struct ArgumentV1<'a> {\n-    value: &'a Void,\n-    formatter: fn(&Void, &mut Formatter<'_>) -> Result,\n+    value: &'a Opaque,\n+    formatter: fn(&Opaque, &mut Formatter<'_>) -> Result,\n }\n \n-impl<'a> ArgumentV1<'a> {\n-    #[inline(never)]\n-    fn show_usize(x: &usize, f: &mut Formatter<'_>) -> Result {\n-        Display::fmt(x, f)\n-    }\n+// This gurantees a single stable value for the function pointer associated with\n+// indices/counts in the formatting infrastructure.\n+//\n+// Note that a function defined as such would not be correct as functions are\n+// always tagged unnamed_addr with the current lowering to LLVM IR, so their\n+// address is not considered important to LLVM and as such the as_usize cast\n+// could have been miscompiled. In practice, we never call as_usize on non-usize\n+// containing data (as a matter of static generation of the formatting\n+// arguments), so this is merely an additional check.\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n+static USIZE_MARKER: fn(&usize, &mut Formatter<'_>) -> Result = |_, _| loop {};\n \n+impl<'a> ArgumentV1<'a> {\n     #[doc(hidden)]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n@@ -278,11 +277,13 @@ impl<'a> ArgumentV1<'a> {\n     #[doc(hidden)]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n-        ArgumentV1::new(x, ArgumentV1::show_usize)\n+        ArgumentV1::new(x, USIZE_MARKER)\n     }\n \n     fn as_usize(&self) -> Option<usize> {\n-        if self.formatter as usize == ArgumentV1::show_usize as usize {\n+        if self.formatter as usize == USIZE_MARKER as usize {\n+            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n+            // the value is a usize, so this is safe\n             Some(unsafe { *(self.value as *const _ as *const usize) })\n         } else {\n             None\n@@ -1356,11 +1357,11 @@ impl<'a> Formatter<'a> {\n             let mut align = old_align;\n             if self.sign_aware_zero_pad() {\n                 // a sign always goes first\n-                let sign = unsafe { str::from_utf8_unchecked(formatted.sign) };\n+                let sign = formatted.sign;\n                 self.buf.write_str(sign)?;\n \n                 // remove the sign from the formatted parts\n-                formatted.sign = b\"\";\n+                formatted.sign = \"\";\n                 width = width.saturating_sub(sign.len());\n                 align = rt::v1::Alignment::Right;\n                 self.fill = '0';\n@@ -1392,7 +1393,7 @@ impl<'a> Formatter<'a> {\n         }\n \n         if !formatted.sign.is_empty() {\n-            write_bytes(self.buf, formatted.sign)?;\n+            self.buf.write_str(formatted.sign)?;\n         }\n         for part in formatted.parts {\n             match *part {"}, {"sha": "5dfd3a8ecdbd695672699c9621995f40229fac16", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -4,6 +4,7 @@\n \n use crate::fmt;\n use crate::mem::MaybeUninit;\n+use crate::num::flt2dec;\n use crate::ops::{Div, Rem, Sub};\n use crate::ptr;\n use crate::slice;\n@@ -256,6 +257,161 @@ macro_rules! impl_Display {\n     };\n }\n \n+macro_rules! impl_Exp {\n+    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) => {\n+        fn $name(\n+            mut n: $u,\n+            is_nonnegative: bool,\n+            upper: bool,\n+            f: &mut fmt::Formatter<'_>\n+        ) -> fmt::Result {\n+            let (mut n, mut exponent, trailing_zeros, added_precision) = {\n+                let mut exponent = 0;\n+                // count and remove trailing decimal zeroes\n+                while n % 10 == 0 && n >= 10 {\n+                    n /= 10;\n+                    exponent += 1;\n+                }\n+                let trailing_zeros = exponent;\n+\n+                let (added_precision, subtracted_precision) = match f.precision() {\n+                    Some(fmt_prec) => {\n+                        // number of decimal digits minus 1\n+                        let mut tmp = n;\n+                        let mut prec = 0;\n+                        while tmp >= 10 {\n+                            tmp /= 10;\n+                            prec += 1;\n+                        }\n+                        (fmt_prec.saturating_sub(prec), prec.saturating_sub(fmt_prec))\n+                    }\n+                    None => (0,0)\n+                };\n+                for _ in 1..subtracted_precision {\n+                    n/=10;\n+                    exponent += 1;\n+                }\n+                if subtracted_precision != 0 {\n+                    let rem = n % 10;\n+                    n /= 10;\n+                    exponent += 1;\n+                    // round up last digit\n+                    if rem >= 5 {\n+                        n += 1;\n+                    }\n+                }\n+                (n, exponent, trailing_zeros, added_precision)\n+            };\n+\n+            // 39 digits (worst case u128) + . = 40\n+            let mut buf = [MaybeUninit::<u8>::uninit(); 40];\n+            let mut curr = buf.len() as isize; //index for buf\n+            let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n+            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n+\n+            // decode 2 chars at a time\n+            while n >= 100 {\n+                let d1 = ((n % 100) as isize) << 1;\n+                curr -= 2;\n+                unsafe {\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                }\n+                n /= 100;\n+                exponent += 2;\n+            }\n+            // n is <= 99, so at most 2 chars long\n+            let mut n = n as isize; // possibly reduce 64bit math\n+            // decode second-to-last character\n+            if n >= 10 {\n+                curr -= 1;\n+                unsafe {\n+                    *buf_ptr.offset(curr) = (n as u8 % 10_u8) + b'0';\n+                }\n+                n /= 10;\n+                exponent += 1;\n+            }\n+            // add decimal point iff >1 mantissa digit will be printed\n+            if exponent != trailing_zeros || added_precision != 0 {\n+                curr -= 1;\n+                unsafe {\n+                    *buf_ptr.offset(curr) = b'.';\n+                }\n+            }\n+\n+            let buf_slice = unsafe {\n+                // decode last character\n+                curr -= 1;\n+                *buf_ptr.offset(curr) = (n as u8) + b'0';\n+\n+                let len = buf.len() - curr as usize;\n+                slice::from_raw_parts(buf_ptr.offset(curr), len)\n+            };\n+\n+            // stores 'e' (or 'E') and the up to 2-digit exponent\n+            let mut exp_buf = [MaybeUninit::<u8>::uninit(); 3];\n+            let exp_ptr = MaybeUninit::first_ptr_mut(&mut exp_buf);\n+            let exp_slice = unsafe {\n+                *exp_ptr.offset(0) = if upper {b'E'} else {b'e'};\n+                let len = if exponent < 10 {\n+                    *exp_ptr.offset(1) = (exponent as u8) + b'0';\n+                    2\n+                } else {\n+                    let off = exponent << 1;\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(off), exp_ptr.offset(1), 2);\n+                    3\n+                };\n+                slice::from_raw_parts(exp_ptr, len)\n+            };\n+\n+            let parts = &[\n+                flt2dec::Part::Copy(buf_slice),\n+                flt2dec::Part::Zero(added_precision),\n+                flt2dec::Part::Copy(exp_slice)\n+            ];\n+            let sign = if !is_nonnegative {\n+                \"-\"\n+            } else if f.sign_plus() {\n+                \"+\"\n+            } else {\n+                \"\"\n+            };\n+            let formatted = flt2dec::Formatted{sign, parts};\n+            f.pad_formatted_parts(&formatted)\n+        }\n+\n+        $(\n+            #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n+            impl fmt::LowerExp for $t {\n+                #[allow(unused_comparisons)]\n+                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                    let is_nonnegative = *self >= 0;\n+                    let n = if is_nonnegative {\n+                        self.$conv_fn()\n+                    } else {\n+                        // convert the negative num to positive by summing 1 to it's 2 complement\n+                        (!self.$conv_fn()).wrapping_add(1)\n+                    };\n+                    $name(n, is_nonnegative, false, f)\n+                }\n+            })*\n+        $(\n+            #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n+            impl fmt::UpperExp for $t {\n+                #[allow(unused_comparisons)]\n+                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                    let is_nonnegative = *self >= 0;\n+                    let n = if is_nonnegative {\n+                        self.$conv_fn()\n+                    } else {\n+                        // convert the negative num to positive by summing 1 to it's 2 complement\n+                        (!self.$conv_fn()).wrapping_add(1)\n+                    };\n+                    $name(n, is_nonnegative, true, f)\n+                }\n+            })*\n+    };\n+}\n+\n // Include wasm32 in here since it doesn't reflect the native pointer size, and\n // often cares strongly about getting a smaller code size.\n #[cfg(any(target_pointer_width = \"64\", target_arch = \"wasm32\"))]\n@@ -265,13 +421,20 @@ mod imp {\n         i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n             as u64 via to_u64 named fmt_u64\n     );\n+    impl_Exp!(\n+        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n+            as u64 via to_u64 named exp_u64\n+    );\n }\n \n #[cfg(not(any(target_pointer_width = \"64\", target_arch = \"wasm32\")))]\n mod imp {\n     use super::*;\n     impl_Display!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named fmt_u32);\n     impl_Display!(i64, u64 as u64 via to_u64 named fmt_u64);\n+    impl_Exp!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named exp_u32);\n+    impl_Exp!(i64, u64 as u64 via to_u64 named exp_u64);\n }\n \n impl_Display!(i128, u128 as u128 via to_u128 named fmt_u128);\n+impl_Exp!(i128, u128 as u128 via to_u128 named exp_u128);"}, {"sha": "c4fbd9dbadaeab583543a35a56584e5ad29150d4", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -121,7 +121,9 @@ macro_rules! load_int_le {\n     }};\n }\n \n-/// Loads an u64 using up to 7 bytes of a byte slice.\n+/// Loads a u64 using up to 7 bytes of a byte slice. It looks clumsy but the\n+/// `copy_nonoverlapping` calls that occur (via `load_int_le!`) all have fixed\n+/// sizes and avoid calling `memcpy`, which is good for speed.\n ///\n /// Unsafe because: unchecked indexing at start..start+len\n #[inline]"}, {"sha": "43f8cfc0c473fcadad0e4b9585ec9b47a60cee80", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1515,6 +1515,7 @@ fn overlaps<T>(src: *const T, dst: *const T, count: usize) -> bool {\n /// ```\n ///\n /// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n+#[doc(alias = \"memcpy\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[inline]\n pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n@@ -1579,6 +1580,7 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n ///     dst\n /// }\n /// ```\n+#[doc(alias = \"memmove\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[inline]\n pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {"}, {"sha": "58606531a1acee91d4a98f07ee89bc56d51b63d7", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1890,17 +1890,15 @@ where\n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n         // Can't just add n + self.n due to overflow.\n-        if self.n == 0 {\n-            self.iter.nth(n)\n-        } else {\n+        if self.n > 0 {\n             let to_skip = self.n;\n             self.n = 0;\n             // nth(n) skips n+1\n             if self.iter.nth(to_skip - 1).is_none() {\n                 return None;\n             }\n-            self.iter.nth(n)\n         }\n+        self.iter.nth(n)\n     }\n \n     #[inline]\n@@ -1916,17 +1914,13 @@ where\n \n     #[inline]\n     fn last(mut self) -> Option<I::Item> {\n-        if self.n == 0 {\n-            self.iter.last()\n-        } else {\n-            let next = self.next();\n-            if next.is_some() {\n-                // recurse. n should be 0.\n-                self.last().or(next)\n-            } else {\n-                None\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return None;\n             }\n         }\n+        self.iter.last()\n     }\n \n     #[inline]"}, {"sha": "28fbd00f36b33558e8f05ccf06632f9d299cf8fb", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -341,16 +341,15 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n         let is_iterating = self.start < self.end;\n-        self.is_empty = Some(!is_iterating);\n         Some(if is_iterating {\n             let n = self.start.add_one();\n             mem::replace(&mut self.start, n)\n         } else {\n+            self.exhausted = true;\n             self.start.clone()\n         })\n     }\n@@ -369,8 +368,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n \n@@ -379,21 +377,20 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n             match plus_n.partial_cmp(&self.end) {\n                 Some(Less) => {\n-                    self.is_empty = Some(false);\n                     self.start = plus_n.add_one();\n                     return Some(plus_n);\n                 }\n                 Some(Equal) => {\n-                    self.is_empty = Some(true);\n                     self.start = plus_n.clone();\n+                    self.exhausted = true;\n                     return Some(plus_n);\n                 }\n                 _ => {}\n             }\n         }\n \n         self.start = self.end.clone();\n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n         None\n     }\n \n@@ -404,8 +401,6 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Ok = B>,\n     {\n-        self.compute_is_empty();\n-\n         if self.is_empty() {\n             return Try::from_ok(init);\n         }\n@@ -418,7 +413,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n             accum = f(accum, n)?;\n         }\n \n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n \n         if self.start == self.end {\n             accum = f(accum, self.start.clone())?;\n@@ -447,24 +442,22 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n         let is_iterating = self.start < self.end;\n-        self.is_empty = Some(!is_iterating);\n         Some(if is_iterating {\n             let n = self.end.sub_one();\n             mem::replace(&mut self.end, n)\n         } else {\n+            self.exhausted = true;\n             self.end.clone()\n         })\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n \n@@ -473,21 +466,20 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n \n             match minus_n.partial_cmp(&self.start) {\n                 Some(Greater) => {\n-                    self.is_empty = Some(false);\n                     self.end = minus_n.sub_one();\n                     return Some(minus_n);\n                 }\n                 Some(Equal) => {\n-                    self.is_empty = Some(true);\n                     self.end = minus_n.clone();\n+                    self.exhausted = true;\n                     return Some(minus_n);\n                 }\n                 _ => {}\n             }\n         }\n \n         self.end = self.start.clone();\n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n         None\n     }\n \n@@ -498,8 +490,6 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Ok = B>,\n     {\n-        self.compute_is_empty();\n-\n         if self.is_empty() {\n             return Try::from_ok(init);\n         }\n@@ -512,7 +502,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n             accum = f(accum, n)?;\n         }\n \n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n \n         if self.start == self.end {\n             accum = f(accum, self.start.clone())?;"}, {"sha": "7bd1d00e84ca1e184339949ecbdea7c120e31b44", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -70,13 +70,17 @@\n #![feature(bound_cloned)]\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n+#![feature(const_ascii_ctype_on_intrinsics)]\n #![feature(const_alloc_layout)]\n #![feature(const_if_match)]\n+#![feature(const_loop)]\n #![feature(const_checked_int_methods)]\n #![feature(const_euclidean_int_methods)]\n #![feature(const_overflowing_int_methods)]\n #![feature(const_saturating_int_methods)]\n #![feature(const_int_unchecked_arith)]\n+#![feature(const_int_pow)]\n+#![feature(constctlz)]\n #![feature(const_panic)]\n #![feature(const_fn_union)]\n #![feature(const_generics)]\n@@ -138,6 +142,7 @@\n #![feature(const_type_id)]\n #![feature(const_caller_location)]\n #![feature(assoc_int_consts)]\n+#![cfg_attr(not(bootstrap), feature(no_niche))] // rust-lang/rust#68303\n \n #[prelude_import]\n #[allow(unused)]\n@@ -262,6 +267,9 @@ mod bool;\n mod tuple;\n mod unit;\n \n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub mod primitive;\n+\n // Pull in the `core_arch` crate directly into libcore. The contents of\n // `core_arch` are in a different repository: rust-lang/stdarch.\n //"}, {"sha": "2800f11cc01b1ae43600b4e82df2ceac154050e8", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -727,6 +727,10 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// [`Pin<P>`]: ../pin/struct.Pin.html\n /// [`pin module`]: ../../std/pin/index.html\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n+#[rustc_on_unimplemented(\n+    on(_Self = \"std::future::Future\", note = \"consider using `Box::pin`\",),\n+    message = \"`{Self}` cannot be unpinned\"\n+)]\n #[lang = \"unpin\"]\n pub auto trait Unpin {}\n "}, {"sha": "58aaac21ad751fcc2a9f5f80cb3cf3c5ad172c82", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -669,7 +669,7 @@ impl<T> MaybeUninit<T> {\n     /// // Now we can use `buf` as a normal slice:\n     /// buf.sort_unstable();\n     /// assert!(\n-    ///     buf.chunks(2).all(|chunk| chunk[0] <= chunk[1]),\n+    ///     buf.windows(2).all(|pair| pair[0] <= pair[1]),\n     ///     \"buffer is sorted\",\n     /// );\n     /// ```"}, {"sha": "0a4fc6464ca977f0dc99e0f8eed30317c5876962", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -130,15 +130,15 @@ pub mod consts {\n     pub const LOG2_E: f32 = 1.44269504088896340735992468100189214_f32;\n \n     /// log<sub>2</sub>(10)\n-    #[unstable(feature = \"extra_log_consts\", issue = \"50540\")]\n+    #[stable(feature = \"extra_log_consts\", since = \"1.43.0\")]\n     pub const LOG2_10: f32 = 3.32192809488736234787031942948939018_f32;\n \n     /// log<sub>10</sub>(e)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const LOG10_E: f32 = 0.434294481903251827651128918916605082_f32;\n \n     /// log<sub>10</sub>(2)\n-    #[unstable(feature = \"extra_log_consts\", issue = \"50540\")]\n+    #[stable(feature = \"extra_log_consts\", since = \"1.43.0\")]\n     pub const LOG10_2: f32 = 0.301029995663981195213738894724493027_f32;\n \n     /// ln(2)"}, {"sha": "a3acf0f23c4e2076abad096491768bbeb32ea80b", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -126,15 +126,15 @@ pub mod consts {\n     pub const E: f64 = 2.71828182845904523536028747135266250_f64;\n \n     /// log<sub>2</sub>(10)\n-    #[unstable(feature = \"extra_log_consts\", issue = \"50540\")]\n+    #[stable(feature = \"extra_log_consts\", since = \"1.43.0\")]\n     pub const LOG2_10: f64 = 3.32192809488736234787031942948939018_f64;\n \n     /// log<sub>2</sub>(e)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const LOG2_E: f64 = 1.44269504088896340735992468100189214_f64;\n \n     /// log<sub>10</sub>(2)\n-    #[unstable(feature = \"extra_log_consts\", issue = \"50540\")]\n+    #[stable(feature = \"extra_log_consts\", since = \"1.43.0\")]\n     pub const LOG10_2: f64 = 0.301029995663981195213738894724493027_f64;\n \n     /// log<sub>10</sub>(e)"}, {"sha": "f5cd26a1852d61efbb1bd9d0303218059091f0f5", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -237,7 +237,7 @@ impl<'a> Part<'a> {\n #[derive(Clone)]\n pub struct Formatted<'a> {\n     /// A byte slice representing a sign, either `\"\"`, `\"-\"` or `\"+\"`.\n-    pub sign: &'static [u8],\n+    pub sign: &'static str,\n     /// Formatted parts to be rendered after a sign and optional zero padding.\n     pub parts: &'a [Part<'a>],\n }\n@@ -259,7 +259,7 @@ impl<'a> Formatted<'a> {\n         if out.len() < self.sign.len() {\n             return None;\n         }\n-        out[..self.sign.len()].copy_from_slice(self.sign);\n+        out[..self.sign.len()].copy_from_slice(self.sign.as_bytes());\n \n         let mut written = self.sign.len();\n         for part in self.parts {\n@@ -402,38 +402,38 @@ pub enum Sign {\n }\n \n /// Returns the static byte string corresponding to the sign to be formatted.\n-/// It can be either `b\"\"`, `b\"+\"` or `b\"-\"`.\n-fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static [u8] {\n+/// It can be either `\"\"`, `\"+\"` or `\"-\"`.\n+fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static str {\n     match (*decoded, sign) {\n-        (FullDecoded::Nan, _) => b\"\",\n-        (FullDecoded::Zero, Sign::Minus) => b\"\",\n+        (FullDecoded::Nan, _) => \"\",\n+        (FullDecoded::Zero, Sign::Minus) => \"\",\n         (FullDecoded::Zero, Sign::MinusRaw) => {\n             if negative {\n-                b\"-\"\n+                \"-\"\n             } else {\n-                b\"\"\n+                \"\"\n             }\n         }\n-        (FullDecoded::Zero, Sign::MinusPlus) => b\"+\",\n+        (FullDecoded::Zero, Sign::MinusPlus) => \"+\",\n         (FullDecoded::Zero, Sign::MinusPlusRaw) => {\n             if negative {\n-                b\"-\"\n+                \"-\"\n             } else {\n-                b\"+\"\n+                \"+\"\n             }\n         }\n         (_, Sign::Minus) | (_, Sign::MinusRaw) => {\n             if negative {\n-                b\"-\"\n+                \"-\"\n             } else {\n-                b\"\"\n+                \"\"\n             }\n         }\n         (_, Sign::MinusPlus) | (_, Sign::MinusPlusRaw) => {\n             if negative {\n-                b\"-\"\n+                \"-\"\n             } else {\n-                b\"+\"\n+                \"+\"\n             }\n         }\n     }\n@@ -462,7 +462,6 @@ pub fn to_shortest_str<'a, T, F>(\n     v: T,\n     sign: Sign,\n     frac_digits: usize,\n-    _upper: bool,\n     buf: &'a mut [u8],\n     parts: &'a mut [Part<'a>],\n ) -> Formatted<'a>\n@@ -679,7 +678,6 @@ pub fn to_exact_fixed_str<'a, T, F>(\n     v: T,\n     sign: Sign,\n     frac_digits: usize,\n-    _upper: bool,\n     buf: &'a mut [u8],\n     parts: &'a mut [Part<'a>],\n ) -> Formatted<'a>"}, {"sha": "43c5f7cf6b939c4a418400c464f5292425ffdf8d", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 70, "deletions": 35, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -8,9 +8,18 @@ use crate::convert::Infallible;\n use crate::fmt;\n use crate::intrinsics;\n use crate::mem;\n-use crate::ops;\n use crate::str::FromStr;\n \n+// Used because the `?` operator is not allowed in a const context.\n+macro_rules! try_opt {\n+    ($e:expr) => {\n+        match $e {\n+            Some(x) => x,\n+            None => return None,\n+        }\n+    };\n+}\n+\n macro_rules! impl_nonzero_fmt {\n     ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n         $(\n@@ -69,8 +78,9 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n \n                 /// Creates a non-zero if the given value is not zero.\n                 #[$stability]\n+                #[rustc_const_unstable(feature = \"const_nonzero_int_methods\", issue = \"53718\")]\n                 #[inline]\n-                pub fn new(n: $Int) -> Option<Self> {\n+                pub const fn new(n: $Int) -> Option<Self> {\n                     if n != 0 {\n                         // SAFETY: we just checked that there's no `0`\n                         Some(unsafe { Self(n) })\n@@ -992,26 +1002,27 @@ $EndFeature, \"\n ```\"),\n \n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n                 while exp > 1 {\n                     if (exp & 1) == 1 {\n-                        acc = acc.checked_mul(base)?;\n+                        acc = try_opt!(acc.checked_mul(base));\n                     }\n                     exp /= 2;\n-                    base = base.checked_mul(base)?;\n+                    base = try_opt!(base.checked_mul(base));\n                 }\n \n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n                 if exp == 1 {\n-                    acc = acc.checked_mul(base)?;\n+                    acc = try_opt!(acc.checked_mul(base));\n                 }\n \n                 Some(acc)\n@@ -1179,10 +1190,11 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn saturating_pow(self, exp: u32) -> Self {\n+            pub const fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n                     Some(x) => x,\n                     None if self < 0 && exp % 2 == 1 => Self::min_value(),\n@@ -1522,10 +1534,11 @@ assert_eq!(3i8.wrapping_pow(6), -39);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_pow(self, mut exp: u32) -> Self {\n+            pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -1899,10 +1912,11 @@ assert_eq!(3i8.overflowing_pow(5), (-13, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n                 let mut base = self;\n                 let mut acc: Self = 1;\n                 let mut overflown = false;\n@@ -1948,11 +1962,12 @@ assert_eq!(x.pow(5), 32);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn pow(self, mut exp: u32) -> Self {\n+            pub const fn pow(self, mut exp: u32) -> Self {\n                 let mut base = self;\n                 let mut acc = 1;\n \n@@ -3118,26 +3133,27 @@ Basic usage:\n assert_eq!(\", stringify!($SelfT), \"::max_value().checked_pow(2), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n                 while exp > 1 {\n                     if (exp & 1) == 1 {\n-                        acc = acc.checked_mul(base)?;\n+                        acc = try_opt!(acc.checked_mul(base));\n                     }\n                     exp /= 2;\n-                    base = base.checked_mul(base)?;\n+                    base = try_opt!(base.checked_mul(base));\n                 }\n \n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n                 if exp == 1 {\n-                    acc = acc.checked_mul(base)?;\n+                    acc = try_opt!(acc.checked_mul(base));\n                 }\n \n                 Some(acc)\n@@ -3233,10 +3249,11 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn saturating_pow(self, exp: u32) -> Self {\n+            pub const fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n                     Some(x) => x,\n                     None => Self::max_value(),\n@@ -3526,10 +3543,11 @@ Basic usage:\n assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_pow(self, mut exp: u32) -> Self {\n+            pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -3852,10 +3870,11 @@ Basic usage:\n assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n                 let mut base = self;\n                 let mut acc: Self = 1;\n                 let mut overflown = false;\n@@ -3898,11 +3917,12 @@ Basic usage:\n \", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\", $EndFeature, \"\n ```\"),\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n         #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n-        pub fn pow(self, mut exp: u32) -> Self {\n+        pub const fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n             let mut acc = 1;\n \n@@ -4013,7 +4033,8 @@ assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n         // overflow cases it instead ends up returning the maximum value\n         // of the type, and can return 0 for 0.\n         #[inline]\n-        fn one_less_than_next_power_of_two(self) -> Self {\n+        #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+        const fn one_less_than_next_power_of_two(self) -> Self {\n             if self <= 1 { return 0; }\n \n             let p = self - 1;\n@@ -4041,10 +4062,11 @@ Basic usage:\n assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[inline]\n-            pub fn next_power_of_two(self) -> Self {\n-                // Call the trait to get overflow checks\n-                ops::Add::add(self.one_less_than_next_power_of_two(), 1)\n+            #[rustc_inherit_overflow_checks]\n+            pub const fn next_power_of_two(self) -> Self {\n+                self.one_less_than_next_power_of_two() + 1\n             }\n         }\n \n@@ -4066,7 +4088,8 @@ $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            pub fn checked_next_power_of_two(self) -> Option<Self> {\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            pub const fn checked_next_power_of_two(self) -> Option<Self> {\n                 self.one_less_than_next_power_of_two().checked_add(1)\n             }\n         }\n@@ -4090,7 +4113,8 @@ $EndFeature, \"\n ```\"),\n             #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                        reason = \"needs decision on wrapping behaviour\")]\n-            pub fn wrapping_next_power_of_two(self) -> Self {\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            pub const fn wrapping_next_power_of_two(self) -> Self {\n                 self.one_less_than_next_power_of_two().wrapping_add(1)\n             }\n         }\n@@ -4300,8 +4324,9 @@ impl u8 {\n     /// assert!(!non_ascii.is_ascii());\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.43.0\")]\n     #[inline]\n-    pub fn is_ascii(&self) -> bool {\n+    pub const fn is_ascii(&self) -> bool {\n         *self & 128 == 0\n     }\n \n@@ -4448,8 +4473,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_alphabetic());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_alphabetic(&self) -> bool {\n+    pub const fn is_ascii_alphabetic(&self) -> bool {\n         matches!(*self, b'A'..=b'Z' | b'a'..=b'z')\n     }\n \n@@ -4480,8 +4506,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_uppercase());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_uppercase(&self) -> bool {\n+    pub const fn is_ascii_uppercase(&self) -> bool {\n         matches!(*self, b'A'..=b'Z')\n     }\n \n@@ -4512,8 +4539,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_lowercase());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_lowercase(&self) -> bool {\n+    pub const fn is_ascii_lowercase(&self) -> bool {\n         matches!(*self, b'a'..=b'z')\n     }\n \n@@ -4547,8 +4575,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_alphanumeric());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_alphanumeric(&self) -> bool {\n+    pub const fn is_ascii_alphanumeric(&self) -> bool {\n         matches!(*self, b'0'..=b'9' | b'A'..=b'Z' | b'a'..=b'z')\n     }\n \n@@ -4579,8 +4608,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_digit());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_digit(&self) -> bool {\n+    pub const fn is_ascii_digit(&self) -> bool {\n         matches!(*self, b'0'..=b'9')\n     }\n \n@@ -4614,8 +4644,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_hexdigit());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_hexdigit(&self) -> bool {\n+    pub const fn is_ascii_hexdigit(&self) -> bool {\n         matches!(*self, b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f')\n     }\n \n@@ -4650,8 +4681,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_punctuation());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_punctuation(&self) -> bool {\n+    pub const fn is_ascii_punctuation(&self) -> bool {\n         matches!(*self, b'!'..=b'/' | b':'..=b'@' | b'['..=b'`' | b'{'..=b'~')\n     }\n \n@@ -4682,8 +4714,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_graphic());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_graphic(&self) -> bool {\n+    pub const fn is_ascii_graphic(&self) -> bool {\n         matches!(*self, b'!'..=b'~')\n     }\n \n@@ -4731,8 +4764,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_whitespace());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_whitespace(&self) -> bool {\n+    pub const fn is_ascii_whitespace(&self) -> bool {\n         matches!(*self, b'\\t' | b'\\n' | b'\\x0C' | b'\\r' | b' ')\n     }\n \n@@ -4765,8 +4799,9 @@ impl u8 {\n     /// assert!(esc.is_ascii_control());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_control(&self) -> bool {\n+    pub const fn is_ascii_control(&self) -> bool {\n         matches!(*self, b'\\0'..=b'\\x1F' | b'\\x7F')\n     }\n }"}, {"sha": "8ffad82b69d7c688816b15d7157586701f9ede7b", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 14, "deletions": 31, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -340,24 +340,21 @@ pub struct RangeInclusive<Idx> {\n     // support that mode.\n     pub(crate) start: Idx,\n     pub(crate) end: Idx,\n-    pub(crate) is_empty: Option<bool>,\n+\n     // This field is:\n-    //  - `None` when next() or next_back() was never called\n-    //  - `Some(false)` when `start < end`\n-    //  - `Some(true)` when `end < start`\n-    //  - `Some(false)` when `start == end` and the range hasn't yet completed iteration\n-    //  - `Some(true)` when `start == end` and the range has completed iteration\n-    // The field cannot be a simple `bool` because the `..=` constructor can\n-    // accept non-PartialOrd types, also we want the constructor to be const.\n+    //  - `false` upon construction\n+    //  - `false` when iteration has yielded an element and the iterator is not exhausted\n+    //  - `true` when iteration has been used to exhaust the iterator\n+    //\n+    // This is required to support PartialEq and Hash without a PartialOrd bound or specialization.\n+    pub(crate) exhausted: bool,\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n-        self.start == other.start\n-            && self.end == other.end\n-            && self.is_exhausted() == other.is_exhausted()\n+        self.start == other.start && self.end == other.end && self.exhausted == other.exhausted\n     }\n }\n \n@@ -369,8 +366,7 @@ impl<Idx: Hash> Hash for RangeInclusive<Idx> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.start.hash(state);\n         self.end.hash(state);\n-        // Ideally we would hash `is_exhausted` here as well, but there's no\n-        // way for us to call it.\n+        self.exhausted.hash(state);\n     }\n }\n \n@@ -389,7 +385,7 @@ impl<Idx> RangeInclusive<Idx> {\n     #[rustc_promotable]\n     #[rustc_const_stable(feature = \"const_range_new\", since = \"1.32.0\")]\n     pub const fn new(start: Idx, end: Idx) -> Self {\n-        Self { start, end, is_empty: None }\n+        Self { start, end, exhausted: false }\n     }\n \n     /// Returns the lower bound of the range (inclusive).\n@@ -465,18 +461,13 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n         self.start.fmt(fmt)?;\n         write!(fmt, \"..=\")?;\n         self.end.fmt(fmt)?;\n+        if self.exhausted {\n+            write!(fmt, \" (exhausted)\")?;\n+        }\n         Ok(())\n     }\n }\n \n-impl<Idx: PartialEq<Idx>> RangeInclusive<Idx> {\n-    // Returns true if this is a range that started non-empty, and was iterated\n-    // to exhaustion.\n-    fn is_exhausted(&self) -> bool {\n-        Some(true) == self.is_empty && self.start == self.end\n-    }\n-}\n-\n impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n@@ -544,15 +535,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n     #[inline]\n     pub fn is_empty(&self) -> bool {\n-        self.is_empty.unwrap_or_else(|| !(self.start <= self.end))\n-    }\n-\n-    // If this range's `is_empty` is field is unknown (`None`), update it to be a concrete value.\n-    #[inline]\n-    pub(crate) fn compute_is_empty(&mut self) {\n-        if self.is_empty.is_none() {\n-            self.is_empty = Some(!(self.start <= self.end));\n-        }\n+        self.exhausted || !(self.start <= self.end)\n     }\n }\n "}, {"sha": "9b32442371c37a32c77577b8e66e2f6551972911", "filename": "src/libcore/option.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -317,7 +317,7 @@ impl<T> Option<T> {\n     // Getting to contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Unwraps an option, yielding the content of a [`Some`].\n+    /// Returns the contained [`Some`] value, consuming the `self` value.\n     ///\n     /// # Panics\n     ///\n@@ -348,17 +348,22 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Moves the value `v` out of the `Option<T>` if it is [`Some(v)`].\n+    /// Returns the contained [`Some`] value, consuming the `self` value.\n     ///\n-    /// In general, because this function may panic, its use is discouraged.\n+    /// Because this function may panic, its use is generally discouraged.\n     /// Instead, prefer to use pattern matching and handle the [`None`]\n-    /// case explicitly.\n+    /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n+    /// [`unwrap_or_default`].\n+    ///\n+    /// [`unwrap_or`]: #method.unwrap_or\n+    /// [`unwrap_or_else`]: #method.unwrap_or_else\n+    /// [`unwrap_or_default`]: #method.unwrap_or_default\n     ///\n     /// # Panics\n     ///\n     /// Panics if the self value equals [`None`].\n     ///\n-    /// [`Some(v)`]: #variant.Some\n+    /// [`Some`]: #variant.Some\n     /// [`None`]: #variant.None\n     ///\n     /// # Examples\n@@ -382,12 +387,13 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns the contained value or a default.\n+    /// Returns the contained [`Some`] value or a provided default.\n     ///\n     /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n     /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n     /// which is lazily evaluated.\n     ///\n+    /// [`Some`]: #variant.Some\n     /// [`unwrap_or_else`]: #method.unwrap_or_else\n     ///\n     /// # Examples\n@@ -405,7 +411,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns the contained value or computes it from a closure.\n+    /// Returns the contained [`Some`] value or computes it from a closure.\n     ///\n     /// # Examples\n     ///\n@@ -986,7 +992,7 @@ impl<T: Clone> Option<&mut T> {\n }\n \n impl<T: fmt::Debug> Option<T> {\n-    /// Unwraps an option, expecting [`None`] and returning nothing.\n+    /// Consumes `self` while expecting [`None`] and returning nothing.\n     ///\n     /// # Panics\n     ///\n@@ -1029,7 +1035,7 @@ impl<T: fmt::Debug> Option<T> {\n         }\n     }\n \n-    /// Unwraps an option, expecting [`None`] and returning nothing.\n+    /// Consumes `self` while expecting [`None`] and returning nothing.\n     ///\n     /// # Panics\n     ///\n@@ -1074,7 +1080,7 @@ impl<T: fmt::Debug> Option<T> {\n }\n \n impl<T: Default> Option<T> {\n-    /// Returns the contained value or a default\n+    /// Returns the contained [`Some`] value or a default\n     ///\n     /// Consumes the `self` argument then, if [`Some`], returns the contained\n     /// value, otherwise if [`None`], returns the [default value] for that"}, {"sha": "e20b2c5c9382a116b35385d680195eef3b4e17d0", "filename": "src/libcore/primitive.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprimitive.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -0,0 +1,67 @@\n+//! This module reexports the primitive types to allow usage that is not\n+//! possibly shadowed by other declared types.\n+//!\n+//! This is normally only useful in macro generated code.\n+//!\n+//! An example of this is when generating a new struct and an impl for it:\n+//!\n+//! ```rust,compile_fail\n+//! pub struct bool;\n+//!\n+//! impl QueryId for bool {\n+//!     const SOME_PROPERTY: bool = true;\n+//! }\n+//!\n+//! # trait QueryId { const SOME_PROPERTY: core::primitive::bool; }\n+//! ```\n+//!\n+//! Note that the `SOME_PROPERTY` associated constant would not compile, as its\n+//! type `bool` refers to the struct, rather than to the primitive bool type.\n+//!\n+//! A correct implementation could look like:\n+//!\n+//! ```rust\n+//! # #[allow(non_camel_case_types)]\n+//! pub struct bool;\n+//!\n+//! impl QueryId for bool {\n+//!     const SOME_PROPERTY: core::primitive::bool = true;\n+//! }\n+//!\n+//! # trait QueryId { const SOME_PROPERTY: core::primitive::bool; }\n+//! ```\n+\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use bool;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use char;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use f32;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use f64;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use i128;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use i16;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use i32;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use i64;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use i8;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use isize;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use str;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use u128;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use u16;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use u32;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use u64;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use u8;\n+#[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n+pub use usize;"}, {"sha": "88b490a25d5ddcaf6efdf53f1da17f5436325d13", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -119,10 +119,13 @@ mod mut_ptr;\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * `to_drop` must be [valid] for reads.\n+/// * `to_drop` must be [valid] for both reads and writes.\n ///\n /// * `to_drop` must be properly aligned.\n ///\n+/// * The value `to_drop` points to must be valid for dropping, which may mean it must uphold\n+///   additional invariants - this is type-dependent.\n+///\n /// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n /// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n /// foo` counts as a use because it will cause the value to be dropped\n@@ -289,7 +292,7 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * Both `x` and `y` must be [valid] for reads and writes.\n+/// * Both `x` and `y` must be [valid] for both reads and writes.\n ///\n /// * Both `x` and `y` must be properly aligned.\n ///\n@@ -355,7 +358,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * Both `x` and `y` must be [valid] for reads and writes of `count *\n+/// * Both `x` and `y` must be [valid] for both reads and writes of `count *\n ///   size_of::<T>()` bytes.\n ///\n /// * Both `x` and `y` must be properly aligned.\n@@ -471,10 +474,12 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// * `dst` must be [valid] for writes.\n+/// * `dst` must be [valid] for both reads and writes.\n ///\n /// * `dst` must be properly aligned.\n ///\n+/// * `dst` must point to a properly initialized value of type `T`.\n+///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n /// [valid]: ../ptr/index.html#safety\n@@ -514,6 +519,8 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n /// * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n ///   case.\n ///\n+/// * `src` must point to a properly initialized value of type `T`.\n+///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n /// # Examples\n@@ -628,6 +635,8 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///\n /// * `src` must be [valid] for reads.\n ///\n+/// * `src` must point to a properly initialized value of type `T`.\n+///\n /// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n@@ -922,6 +931,8 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// * `src` must be properly aligned.\n ///\n+/// * `src` must point to a properly initialized value of type `T`.\n+///\n /// Like [`read`], `read_volatile` creates a bitwise copy of `T`, regardless of\n /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership]."}, {"sha": "0bc29e1bc662cfb94dc28f43b808d2d933401be6", "filename": "src/libcore/result.rs", "status": "modified", "additions": 59, "deletions": 53, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -798,8 +798,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an [`Ok`].\n-    /// Else, it returns `optb`.\n+    /// Returns the contained [`Ok`] value or a provided default.\n     ///\n     /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n     /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n@@ -814,27 +813,25 @@ impl<T, E> Result<T, E> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// let optb = 2;\n+    /// let default = 2;\n     /// let x: Result<u32, &str> = Ok(9);\n-    /// assert_eq!(x.unwrap_or(optb), 9);\n+    /// assert_eq!(x.unwrap_or(default), 9);\n     ///\n     /// let x: Result<u32, &str> = Err(\"error\");\n-    /// assert_eq!(x.unwrap_or(optb), optb);\n+    /// assert_eq!(x.unwrap_or(default), default);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or(self, optb: T) -> T {\n+    pub fn unwrap_or(self, default: T) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(_) => optb,\n+            Err(_) => default,\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an [`Ok`].\n-    /// If the value is an [`Err`] then it calls `op` with its value.\n+    /// Returns the contained [`Ok`] value or computes it from a closure.\n     ///\n     /// [`Ok`]: enum.Result.html#variant.Ok\n-    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -937,7 +934,44 @@ impl<T: Clone, E> Result<&mut T, E> {\n }\n \n impl<T, E: fmt::Debug> Result<T, E> {\n-    /// Unwraps a result, yielding the content of an [`Ok`].\n+    /// Returns the contained [`Ok`] value, consuming the `self` value.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is an [`Err`], with a panic message including the\n+    /// passed message, and the content of the [`Err`].\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```{.should_panic}\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n+    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n+    /// ```\n+    #[inline]\n+    #[track_caller]\n+    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n+    pub fn expect(self, msg: &str) -> T {\n+        match self {\n+            Ok(t) => t,\n+            Err(e) => unwrap_failed(msg, &e),\n+        }\n+    }\n+\n+    /// Returns the contained [`Ok`] value, consuming the `self` value.\n+    ///\n+    /// Because this function may panic, its use is generally discouraged.\n+    /// Instead, prefer to use pattern matching and handle the [`Err`]\n+    /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n+    /// [`unwrap_or_default`].\n+    ///\n+    /// [`unwrap_or`]: #method.unwrap_or\n+    /// [`unwrap_or_else`]: #method.unwrap_or_else\n+    /// [`unwrap_or_default`]: #method.unwrap_or_default\n     ///\n     /// # Panics\n     ///\n@@ -969,13 +1003,15 @@ impl<T, E: fmt::Debug> Result<T, E> {\n             Err(e) => unwrap_failed(\"called `Result::unwrap()` on an `Err` value\", &e),\n         }\n     }\n+}\n \n-    /// Unwraps a result, yielding the content of an [`Ok`].\n+impl<T: fmt::Debug, E> Result<T, E> {\n+    /// Returns the contained [`Err`] value, consuming the `self` value.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the value is an [`Err`], with a panic message including the\n-    /// passed message, and the content of the [`Err`].\n+    /// Panics if the value is an [`Ok`], with a panic message including the\n+    /// passed message, and the content of the [`Ok`].\n     ///\n     /// [`Ok`]: enum.Result.html#variant.Ok\n     /// [`Err`]: enum.Result.html#variant.Err\n@@ -985,22 +1021,20 @@ impl<T, E: fmt::Debug> Result<T, E> {\n     /// Basic usage:\n     ///\n     /// ```{.should_panic}\n-    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n+    /// let x: Result<u32, &str> = Ok(10);\n+    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n     /// ```\n     #[inline]\n     #[track_caller]\n-    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n-    pub fn expect(self, msg: &str) -> T {\n+    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n+    pub fn expect_err(self, msg: &str) -> E {\n         match self {\n-            Ok(t) => t,\n-            Err(e) => unwrap_failed(msg, &e),\n+            Ok(t) => unwrap_failed(msg, &t),\n+            Err(e) => e,\n         }\n     }\n-}\n \n-impl<T: fmt::Debug, E> Result<T, E> {\n-    /// Unwraps a result, yielding the content of an [`Err`].\n+    /// Returns the contained [`Err`] value, consuming the `self` value.\n     ///\n     /// # Panics\n     ///\n@@ -1031,38 +1065,10 @@ impl<T: fmt::Debug, E> Result<T, E> {\n             Err(e) => e,\n         }\n     }\n-\n-    /// Unwraps a result, yielding the content of an [`Err`].\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the value is an [`Ok`], with a panic message including the\n-    /// passed message, and the content of the [`Ok`].\n-    ///\n-    /// [`Ok`]: enum.Result.html#variant.Ok\n-    /// [`Err`]: enum.Result.html#variant.Err\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```{.should_panic}\n-    /// let x: Result<u32, &str> = Ok(10);\n-    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n-    /// ```\n-    #[inline]\n-    #[track_caller]\n-    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n-    pub fn expect_err(self, msg: &str) -> E {\n-        match self {\n-            Ok(t) => unwrap_failed(msg, &t),\n-            Err(e) => e,\n-        }\n-    }\n }\n \n impl<T: Default, E> Result<T, E> {\n-    /// Returns the contained value or a default\n+    /// Returns the contained [`Ok`] value or a default\n     ///\n     /// Consumes the `self` argument then, if [`Ok`], returns the contained\n     /// value, otherwise if [`Err`], returns the default value for that\n@@ -1101,7 +1107,7 @@ impl<T: Default, E> Result<T, E> {\n \n #[unstable(feature = \"unwrap_infallible\", reason = \"newly added\", issue = \"61695\")]\n impl<T, E: Into<!>> Result<T, E> {\n-    /// Unwraps a result that can never be an [`Err`], yielding the content of the [`Ok`].\n+    /// Returns the contained [`Ok`] value, but never panics.\n     ///\n     /// Unlike [`unwrap`], this method is known to never panic on the\n     /// result types it is implemented for. Therefore, it can be used"}, {"sha": "7c65f595790189f38d2aa7cccb94ac2b9a380eba", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 271, "deletions": 1, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1155,6 +1155,69 @@ impl<T> [T] {\n         SplitMut { v: self, pred, finished: false }\n     }\n \n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`. The matched element is contained in the end of the previous\n+    /// subslice as a terminator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let slice = [10, 40, 33, 20];\n+    /// let mut iter = slice.split_inclusive(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40, 33]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// If the last element of the slice is matched,\n+    /// that element will be considered the terminator of the preceding slice.\n+    /// That slice will be the last item returned by the iterator.\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let slice = [3, 10, 40, 33];\n+    /// let mut iter = slice.split_inclusive(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[3]);\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40, 33]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    #[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+    #[inline]\n+    pub fn split_inclusive<F>(&self, pred: F) -> SplitInclusive<'_, T, F>\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        SplitInclusive { v: self, pred, finished: false }\n+    }\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`. The matched element is contained in the previous\n+    /// subslice as a terminator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let mut v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.split_inclusive_mut(|num| *num % 3 == 0) {\n+    ///     let terminator_idx = group.len()-1;\n+    ///     group[terminator_idx] = 1;\n+    /// }\n+    /// assert_eq!(v, [10, 40, 1, 20, 1, 1]);\n+    /// ```\n+    #[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+    #[inline]\n+    pub fn split_inclusive_mut<F>(&mut self, pred: F) -> SplitInclusiveMut<'_, T, F>\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        SplitInclusiveMut { v: self, pred, finished: false }\n+    }\n+\n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, starting at the end of the slice and working backwards.\n     /// The matched element is not contained in the subslices.\n@@ -3675,7 +3738,106 @@ where\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T, P> FusedIterator for Split<'_, T, P> where P: FnMut(&T) -> bool {}\n \n-/// An iterator over the subslices of the vector which are separated\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function. Unlike `Split`, it contains the matched part as a terminator\n+/// of the subslice.\n+///\n+/// This struct is created by the [`split_inclusive`] method on [slices].\n+///\n+/// [`split_inclusive`]: ../../std/primitive.slice.html#method.split_inclusive\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+pub struct SplitInclusive<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    v: &'a [T],\n+    pred: P,\n+    finished: bool,\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitInclusive<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusive\")\n+            .field(\"v\", &self.v)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T, P> Clone for SplitInclusive<'_, T, P>\n+where\n+    P: Clone + FnMut(&T) -> bool,\n+{\n+    fn clone(&self) -> Self {\n+        SplitInclusive { v: self.v, pred: self.pred.clone(), finished: self.finished }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, T, P> Iterator for SplitInclusive<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let idx =\n+            self.v.iter().position(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(self.v.len());\n+        if idx == self.v.len() {\n+            self.finished = true;\n+        }\n+        let ret = Some(&self.v[..idx]);\n+        self.v = &self.v[idx..];\n+        ret\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished { (0, Some(0)) } else { (1, Some(self.v.len() + 1)) }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, T, P> DoubleEndedIterator for SplitInclusive<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        // The last index of self.v is already checked and found to match\n+        // by the last iteration, so we start searching a new match\n+        // one index to the left.\n+        let remainder = if self.v.len() == 0 { &[] } else { &self.v[..(self.v.len() - 1)] };\n+        let idx = remainder.iter().rposition(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(0);\n+        if idx == 0 {\n+            self.finished = true;\n+        }\n+        let ret = Some(&self.v[idx..]);\n+        self.v = &self.v[..idx];\n+        ret\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T, P> FusedIterator for SplitInclusive<'_, T, P> where P: FnMut(&T) -> bool {}\n+\n+/// An iterator over the mutable subslices of the vector which are separated\n /// by elements that match `pred`.\n ///\n /// This struct is created by the [`split_mut`] method on [slices].\n@@ -3789,6 +3951,114 @@ where\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T, P> FusedIterator for SplitMut<'_, T, P> where P: FnMut(&T) -> bool {}\n \n+/// An iterator over the mutable subslices of the vector which are separated\n+/// by elements that match `pred`. Unlike `SplitMut`, it contains the matched\n+/// parts in the ends of the subslices.\n+///\n+/// This struct is created by the [`split_inclusive_mut`] method on [slices].\n+///\n+/// [`split_inclusive_mut`]: ../../std/primitive.slice.html#method.split_inclusive_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+pub struct SplitInclusiveMut<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    v: &'a mut [T],\n+    pred: P,\n+    finished: bool,\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitInclusiveMut<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusiveMut\")\n+            .field(\"v\", &self.v)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, T, P> Iterator for SplitInclusiveMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let idx_opt = {\n+            // work around borrowck limitations\n+            let pred = &mut self.pred;\n+            self.v.iter().position(|x| (*pred)(x))\n+        };\n+        let idx = idx_opt.map(|idx| idx + 1).unwrap_or(self.v.len());\n+        if idx == self.v.len() {\n+            self.finished = true;\n+        }\n+        let tmp = mem::replace(&mut self.v, &mut []);\n+        let (head, tail) = tmp.split_at_mut(idx);\n+        self.v = tail;\n+        Some(head)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            // if the predicate doesn't match anything, we yield one slice\n+            // if it matches every element, we yield len+1 empty slices.\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, T, P> DoubleEndedIterator for SplitInclusiveMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let idx_opt = if self.v.len() == 0 {\n+            None\n+        } else {\n+            // work around borrowck limitations\n+            let pred = &mut self.pred;\n+\n+            // The last index of self.v is already checked and found to match\n+            // by the last iteration, so we start searching a new match\n+            // one index to the left.\n+            let remainder = &self.v[..(self.v.len() - 1)];\n+            remainder.iter().rposition(|x| (*pred)(x))\n+        };\n+        let idx = idx_opt.map(|idx| idx + 1).unwrap_or(0);\n+        if idx == 0 {\n+            self.finished = true;\n+        }\n+        let tmp = mem::replace(&mut self.v, &mut []);\n+        let (head, tail) = tmp.split_at_mut(idx);\n+        self.v = head;\n+        Some(tail)\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T, P> FusedIterator for SplitInclusiveMut<'_, T, P> where P: FnMut(&T) -> bool {}\n+\n /// An iterator over subslices separated by elements that match a predicate\n /// function, starting from the end of the slice.\n ///"}, {"sha": "9c0db5d98725dfe779a723303e4abee6d7d7a39a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 157, "deletions": 6, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1132,6 +1132,26 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n         }\n     }\n \n+    #[inline]\n+    fn next_inclusive(&mut self) -> Option<&'a str> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match() {\n+            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n+            // and self.start is either the start of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n+            Some((_, b)) => unsafe {\n+                let elt = haystack.get_unchecked(self.start..b);\n+                self.start = b;\n+                Some(elt)\n+            },\n+            None => self.get_end(),\n+        }\n+    }\n+\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str>\n     where\n@@ -1168,6 +1188,49 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n             },\n         }\n     }\n+\n+    #[inline]\n+    fn next_back_inclusive(&mut self) -> Option<&'a str>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n+    {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        if !self.allow_trailing_empty {\n+            self.allow_trailing_empty = true;\n+            match self.next_back_inclusive() {\n+                Some(elt) if !elt.is_empty() => return Some(elt),\n+                _ => {\n+                    if self.finished {\n+                        return None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match_back() {\n+            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n+            // and self.end is either the end of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n+            Some((_, b)) => unsafe {\n+                let elt = haystack.get_unchecked(b..self.end);\n+                self.end = b;\n+                Some(elt)\n+            },\n+            // SAFETY: self.start is either the start of the original string,\n+            // or start of a substring that represents the part of the string that hasn't\n+            // iterated yet. Either way, it is guaranteed to lie on unicode boundary.\n+            // self.end is either the end of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n+            None => unsafe {\n+                self.finished = true;\n+                Some(haystack.get_unchecked(self.start..self.end))\n+            },\n+        }\n+    }\n }\n \n generate_pattern_iterators! {\n@@ -1499,7 +1562,7 @@ fn contains_nonascii(x: usize) -> bool {\n \n /// Walks through `v` checking that it's a valid UTF-8 sequence,\n /// returning `Ok(())` in that case, or, if it is invalid, `Err(err)`.\n-#[inline]\n+#[inline(always)]\n fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n     let mut index = 0;\n     let len = v.len();\n@@ -2423,7 +2486,7 @@ impl str {\n     /// Callers of this function are responsible that these preconditions are\n     /// satisfied:\n     ///\n-    /// * The starting index must come before the ending index;\n+    /// * The starting index must not exceed the ending index;\n     /// * Indexes must be within bounds of the original slice;\n     /// * Indexes must lie on UTF-8 sequence boundaries.\n     ///\n@@ -2455,7 +2518,7 @@ impl str {\n     /// Callers of this function are responsible that these preconditions are\n     /// satisfied:\n     ///\n-    /// * The starting index must come before the ending index;\n+    /// * The starting index must not exceed the ending index;\n     /// * Indexes must be within bounds of the original slice;\n     /// * Indexes must lie on UTF-8 sequence boundaries.\n     ///\n@@ -2500,7 +2563,7 @@ impl str {\n     /// Callers of this function are responsible that three preconditions are\n     /// satisfied:\n     ///\n-    /// * `begin` must come before `end`.\n+    /// * `begin` must not exceed `end`.\n     /// * `begin` and `end` must be byte positions within the string slice.\n     /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n     ///\n@@ -2549,7 +2612,7 @@ impl str {\n     /// Callers of this function are responsible that three preconditions are\n     /// satisfied:\n     ///\n-    /// * `begin` must come before `end`.\n+    /// * `begin` must not exceed `end`.\n     /// * `begin` and `end` must be byte positions within the string slice.\n     /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n     #[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]\n@@ -2658,7 +2721,8 @@ impl str {\n     ///\n     /// It's important to remember that [`char`] represents a Unicode Scalar\n     /// Value, and may not match your idea of what a 'character' is. Iteration\n-    /// over grapheme clusters may be what you actually want.\n+    /// over grapheme clusters may be what you actually want. This functionality\n+    /// is not provided by Rust's standard library, check crates.io instead.\n     ///\n     /// # Examples\n     ///\n@@ -3212,6 +3276,42 @@ impl str {\n         })\n     }\n \n+    /// An iterator over substrings of this string slice, separated by\n+    /// characters matched by a pattern. Differs from the iterator produced by\n+    /// `split` in that `split_inclusive` leaves the matched part as the\n+    /// terminator of the substring.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\"\n+    ///     .split_inclusive('\\n').collect();\n+    /// assert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\"]);\n+    /// ```\n+    ///\n+    /// If the last element of the string is matched,\n+    /// that element will be considered the terminator of the preceding substring.\n+    /// That substring will be the last item returned by the iterator.\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\\n\"\n+    ///     .split_inclusive('\\n').collect();\n+    /// assert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\\n\"]);\n+    /// ```\n+    #[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+    #[inline]\n+    pub fn split_inclusive<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitInclusive<'a, P> {\n+        SplitInclusive(SplitInternal {\n+            start: 0,\n+            end: self.len(),\n+            matcher: pat.into_searcher(self),\n+            allow_trailing_empty: false,\n+            finished: false,\n+        })\n+    }\n+\n     /// An iterator over substrings of the given string slice, separated by\n     /// characters matched by a pattern and yielded in reverse order.\n     ///\n@@ -4405,6 +4505,19 @@ pub struct SplitAsciiWhitespace<'a> {\n     inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, BytesIsNotEmpty>, UnsafeBytesToStr>,\n }\n \n+/// An iterator over the substrings of a string,\n+/// terminated by a substring matching to a predicate function\n+/// Unlike `Split`, it contains the matched part as a terminator\n+/// of the subslice.\n+///\n+/// This struct is created by the [`split_inclusive`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_inclusive`]: ../../std/primitive.str.html#method.split_inclusive\n+/// [`str`]: ../../std/primitive.str.html\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+pub struct SplitInclusive<'a, P: Pattern<'a>>(SplitInternal<'a, P>);\n+\n impl_fn_for_zst! {\n     #[derive(Clone)]\n     struct IsWhitespace impl Fn = |c: char| -> bool {\n@@ -4495,6 +4608,44 @@ impl<'a> DoubleEndedIterator for SplitAsciiWhitespace<'a> {\n #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n impl FusedIterator for SplitAsciiWhitespace<'_> {}\n \n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, P: Pattern<'a>> Iterator for SplitInclusive<'a, P> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next_inclusive()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, P: Pattern<'a, Searcher: fmt::Debug>> fmt::Debug for SplitInclusive<'a, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusive\").field(\"0\", &self.0).finish()\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, P: Pattern<'a, Searcher: Clone>> Clone for SplitInclusive<'a, P> {\n+    fn clone(&self) -> Self {\n+        SplitInclusive(self.0.clone())\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, P: Pattern<'a, Searcher: ReverseSearcher<'a>>> DoubleEndedIterator\n+    for SplitInclusive<'a, P>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back_inclusive()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, P: Pattern<'a>> FusedIterator for SplitInclusive<'a, P> {}\n+\n /// An iterator of [`u16`] over the string encoded as UTF-16.\n ///\n /// [`u16`]: ../../std/primitive.u16.html"}, {"sha": "a50c2b46a919b320d68be0754608a46481bd5760", "filename": "src/libcore/tests/fmt/num.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -38,6 +38,16 @@ fn test_format_int() {\n     assert_eq!(format!(\"{:o}\", 1i16), \"1\");\n     assert_eq!(format!(\"{:o}\", 1i32), \"1\");\n     assert_eq!(format!(\"{:o}\", 1i64), \"1\");\n+    assert_eq!(format!(\"{:e}\", 1isize), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1i8), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1i16), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1i32), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1i64), \"1e0\");\n+    assert_eq!(format!(\"{:E}\", 1isize), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1i8), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1i16), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1i32), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1i64), \"1E0\");\n \n     assert_eq!(format!(\"{}\", 1usize), \"1\");\n     assert_eq!(format!(\"{}\", 1u8), \"1\");\n@@ -69,13 +79,79 @@ fn test_format_int() {\n     assert_eq!(format!(\"{:o}\", 1u16), \"1\");\n     assert_eq!(format!(\"{:o}\", 1u32), \"1\");\n     assert_eq!(format!(\"{:o}\", 1u64), \"1\");\n+    assert_eq!(format!(\"{:e}\", 1u8), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1u16), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1u32), \"1e0\");\n+    assert_eq!(format!(\"{:e}\", 1u64), \"1e0\");\n+    assert_eq!(format!(\"{:E}\", 1u8), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1u16), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1u32), \"1E0\");\n+    assert_eq!(format!(\"{:E}\", 1u64), \"1E0\");\n \n     // Test a larger number\n     assert_eq!(format!(\"{:b}\", 55), \"110111\");\n     assert_eq!(format!(\"{:o}\", 55), \"67\");\n     assert_eq!(format!(\"{}\", 55), \"55\");\n     assert_eq!(format!(\"{:x}\", 55), \"37\");\n     assert_eq!(format!(\"{:X}\", 55), \"37\");\n+    assert_eq!(format!(\"{:e}\", 55), \"5.5e1\");\n+    assert_eq!(format!(\"{:E}\", 55), \"5.5E1\");\n+    assert_eq!(format!(\"{:e}\", 10000000000u64), \"1e10\");\n+    assert_eq!(format!(\"{:E}\", 10000000000u64), \"1E10\");\n+    assert_eq!(format!(\"{:e}\", 10000000001u64), \"1.0000000001e10\");\n+    assert_eq!(format!(\"{:E}\", 10000000001u64), \"1.0000000001E10\");\n+}\n+\n+#[test]\n+fn test_format_int_exp_limits() {\n+    use core::{i128, i16, i32, i64, i8, u128, u16, u32, u64, u8};\n+    assert_eq!(format!(\"{:e}\", i8::MIN), \"-1.28e2\");\n+    assert_eq!(format!(\"{:e}\", i8::MAX), \"1.27e2\");\n+    assert_eq!(format!(\"{:e}\", i16::MIN), \"-3.2768e4\");\n+    assert_eq!(format!(\"{:e}\", i16::MAX), \"3.2767e4\");\n+    assert_eq!(format!(\"{:e}\", i32::MIN), \"-2.147483648e9\");\n+    assert_eq!(format!(\"{:e}\", i32::MAX), \"2.147483647e9\");\n+    assert_eq!(format!(\"{:e}\", i64::MIN), \"-9.223372036854775808e18\");\n+    assert_eq!(format!(\"{:e}\", i64::MAX), \"9.223372036854775807e18\");\n+    assert_eq!(format!(\"{:e}\", i128::MIN), \"-1.70141183460469231731687303715884105728e38\");\n+    assert_eq!(format!(\"{:e}\", i128::MAX), \"1.70141183460469231731687303715884105727e38\");\n+\n+    assert_eq!(format!(\"{:e}\", u8::MAX), \"2.55e2\");\n+    assert_eq!(format!(\"{:e}\", u16::MAX), \"6.5535e4\");\n+    assert_eq!(format!(\"{:e}\", u32::MAX), \"4.294967295e9\");\n+    assert_eq!(format!(\"{:e}\", u64::MAX), \"1.8446744073709551615e19\");\n+    assert_eq!(format!(\"{:e}\", u128::MAX), \"3.40282366920938463463374607431768211455e38\");\n+}\n+\n+#[test]\n+fn test_format_int_exp_precision() {\n+    use core::{i128, i16, i32, i64, i8};\n+\n+    //test that float and integer match\n+    let big_int: u32 = 314_159_265;\n+    assert_eq!(format!(\"{:.1e}\", big_int), format!(\"{:.1e}\", f64::from(big_int)));\n+\n+    //test adding precision\n+    assert_eq!(format!(\"{:.10e}\", i8::MIN), \"-1.2800000000e2\");\n+    assert_eq!(format!(\"{:.10e}\", i16::MIN), \"-3.2768000000e4\");\n+    assert_eq!(format!(\"{:.10e}\", i32::MIN), \"-2.1474836480e9\");\n+    assert_eq!(format!(\"{:.20e}\", i64::MIN), \"-9.22337203685477580800e18\");\n+    assert_eq!(format!(\"{:.40e}\", i128::MIN), \"-1.7014118346046923173168730371588410572800e38\");\n+\n+    //test rounding\n+    assert_eq!(format!(\"{:.1e}\", i8::MIN), \"-1.3e2\");\n+    assert_eq!(format!(\"{:.1e}\", i16::MIN), \"-3.3e4\");\n+    assert_eq!(format!(\"{:.1e}\", i32::MIN), \"-2.1e9\");\n+    assert_eq!(format!(\"{:.1e}\", i64::MIN), \"-9.2e18\");\n+    assert_eq!(format!(\"{:.1e}\", i128::MIN), \"-1.7e38\");\n+\n+    //test huge precision\n+    assert_eq!(format!(\"{:.1000e}\", 1), format!(\"1.{}e0\", \"0\".repeat(1000)));\n+    //test zero precision\n+    assert_eq!(format!(\"{:.0e}\", 1), format!(\"1e0\",));\n+\n+    //test padding with precision (and sign)\n+    assert_eq!(format!(\"{:+10.3e}\", 1), \"  +1.000e0\");\n }\n \n #[test]\n@@ -86,13 +162,17 @@ fn test_format_int_zero() {\n     assert_eq!(format!(\"{:o}\", 0), \"0\");\n     assert_eq!(format!(\"{:x}\", 0), \"0\");\n     assert_eq!(format!(\"{:X}\", 0), \"0\");\n+    assert_eq!(format!(\"{:e}\", 0), \"0e0\");\n+    assert_eq!(format!(\"{:E}\", 0), \"0E0\");\n \n     assert_eq!(format!(\"{}\", 0u32), \"0\");\n     assert_eq!(format!(\"{:?}\", 0u32), \"0\");\n     assert_eq!(format!(\"{:b}\", 0u32), \"0\");\n     assert_eq!(format!(\"{:o}\", 0u32), \"0\");\n     assert_eq!(format!(\"{:x}\", 0u32), \"0\");\n     assert_eq!(format!(\"{:X}\", 0u32), \"0\");\n+    assert_eq!(format!(\"{:e}\", 0u32), \"0e0\");\n+    assert_eq!(format!(\"{:E}\", 0u32), \"0E0\");\n }\n \n #[test]"}, {"sha": "e945d9c4a54ce26c09e3c88d3dab4ef5d7275139", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 224, "deletions": 236, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -500,102 +500,99 @@ where\n {\n     use core::num::flt2dec::Sign::*;\n \n-    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize, upper: bool) -> String\n+    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize) -> String\n     where\n         T: DecodableFloat,\n         F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n     {\n         to_string_with_parts(|buf, parts| {\n-            to_shortest_str(|d, b| f(d, b), v, sign, frac_digits, upper, buf, parts)\n+            to_shortest_str(|d, b| f(d, b), v, sign, frac_digits, buf, parts)\n         })\n     }\n \n     let f = &mut f_;\n \n-    assert_eq!(to_string(f, 0.0, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.0, MinusRaw, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlus, 0, false), \"+0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 0, false), \"+0\");\n-    assert_eq!(to_string(f, -0.0, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, -0.0, MinusRaw, 0, false), \"-0\");\n-    assert_eq!(to_string(f, -0.0, MinusPlus, 0, false), \"+0\");\n-    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 0, false), \"-0\");\n-    assert_eq!(to_string(f, 0.0, Minus, 1, true), \"0.0\");\n-    assert_eq!(to_string(f, 0.0, MinusRaw, 1, true), \"0.0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlus, 1, true), \"+0.0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 1, true), \"+0.0\");\n-    assert_eq!(to_string(f, -0.0, Minus, 8, true), \"0.00000000\");\n-    assert_eq!(to_string(f, -0.0, MinusRaw, 8, true), \"-0.00000000\");\n-    assert_eq!(to_string(f, -0.0, MinusPlus, 8, true), \"+0.00000000\");\n-    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8, true), \"-0.00000000\");\n-\n-    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 0, false), \"inf\");\n-    assert_eq!(to_string(f, 1.0 / 0.0, MinusRaw, 0, true), \"inf\");\n-    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlus, 0, false), \"+inf\");\n-    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlusRaw, 0, true), \"+inf\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 0, false), \"NaN\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, MinusRaw, 1, true), \"NaN\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlus, 8, false), \"NaN\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlusRaw, 64, true), \"NaN\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 0, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, MinusRaw, 1, true), \"-inf\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlus, 8, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlusRaw, 64, true), \"-inf\");\n-\n-    assert_eq!(to_string(f, 3.14, Minus, 0, false), \"3.14\");\n-    assert_eq!(to_string(f, 3.14, MinusRaw, 0, false), \"3.14\");\n-    assert_eq!(to_string(f, 3.14, MinusPlus, 0, false), \"+3.14\");\n-    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 0, false), \"+3.14\");\n-    assert_eq!(to_string(f, -3.14, Minus, 0, false), \"-3.14\");\n-    assert_eq!(to_string(f, -3.14, MinusRaw, 0, false), \"-3.14\");\n-    assert_eq!(to_string(f, -3.14, MinusPlus, 0, false), \"-3.14\");\n-    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 0, false), \"-3.14\");\n-    assert_eq!(to_string(f, 3.14, Minus, 1, true), \"3.14\");\n-    assert_eq!(to_string(f, 3.14, MinusRaw, 2, true), \"3.14\");\n-    assert_eq!(to_string(f, 3.14, MinusPlus, 3, true), \"+3.140\");\n-    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 4, true), \"+3.1400\");\n-    assert_eq!(to_string(f, -3.14, Minus, 8, true), \"-3.14000000\");\n-    assert_eq!(to_string(f, -3.14, MinusRaw, 8, true), \"-3.14000000\");\n-    assert_eq!(to_string(f, -3.14, MinusPlus, 8, true), \"-3.14000000\");\n-    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 8, true), \"-3.14000000\");\n-\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 0, false), \"0.000000000075\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 3, false), \"0.000000000075\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 12, false), \"0.000000000075\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 13, false), \"0.0000000000750\");\n-\n-    assert_eq!(to_string(f, 1.9971e20, Minus, 0, false), \"199710000000000000000\");\n-    assert_eq!(to_string(f, 1.9971e20, Minus, 1, false), \"199710000000000000000.0\");\n-    assert_eq!(to_string(f, 1.9971e20, Minus, 8, false), \"199710000000000000000.00000000\");\n-\n-    assert_eq!(to_string(f, f32::MAX, Minus, 0, false), format!(\"34028235{:0>31}\", \"\"));\n-    assert_eq!(to_string(f, f32::MAX, Minus, 1, false), format!(\"34028235{:0>31}.0\", \"\"));\n-    assert_eq!(to_string(f, f32::MAX, Minus, 8, false), format!(\"34028235{:0>31}.00000000\", \"\"));\n+    assert_eq!(to_string(f, 0.0, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 0.0, MinusRaw, 0), \"0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlus, 0), \"+0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 0), \"+0\");\n+    assert_eq!(to_string(f, -0.0, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw, 0), \"-0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus, 0), \"+0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 0), \"-0\");\n+    assert_eq!(to_string(f, 0.0, Minus, 1), \"0.0\");\n+    assert_eq!(to_string(f, 0.0, MinusRaw, 1), \"0.0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlus, 1), \"+0.0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 1), \"+0.0\");\n+    assert_eq!(to_string(f, -0.0, Minus, 8), \"0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw, 8), \"-0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus, 8), \"+0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8), \"-0.00000000\");\n+\n+    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 0), \"inf\");\n+    assert_eq!(to_string(f, 1.0 / 0.0, MinusRaw, 0), \"inf\");\n+    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlus, 0), \"+inf\");\n+    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlusRaw, 0), \"+inf\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 0), \"NaN\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, MinusRaw, 1), \"NaN\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlus, 8), \"NaN\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlusRaw, 64), \"NaN\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 0), \"-inf\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, MinusRaw, 1), \"-inf\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlus, 8), \"-inf\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlusRaw, 64), \"-inf\");\n+\n+    assert_eq!(to_string(f, 3.14, Minus, 0), \"3.14\");\n+    assert_eq!(to_string(f, 3.14, MinusRaw, 0), \"3.14\");\n+    assert_eq!(to_string(f, 3.14, MinusPlus, 0), \"+3.14\");\n+    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 0), \"+3.14\");\n+    assert_eq!(to_string(f, -3.14, Minus, 0), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw, 0), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus, 0), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 0), \"-3.14\");\n+    assert_eq!(to_string(f, 3.14, Minus, 1), \"3.14\");\n+    assert_eq!(to_string(f, 3.14, MinusRaw, 2), \"3.14\");\n+    assert_eq!(to_string(f, 3.14, MinusPlus, 3), \"+3.140\");\n+    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 4), \"+3.1400\");\n+    assert_eq!(to_string(f, -3.14, Minus, 8), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw, 8), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus, 8), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 8), \"-3.14000000\");\n+\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 0), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 3), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 12), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 13), \"0.0000000000750\");\n+\n+    assert_eq!(to_string(f, 1.9971e20, Minus, 0), \"199710000000000000000\");\n+    assert_eq!(to_string(f, 1.9971e20, Minus, 1), \"199710000000000000000.0\");\n+    assert_eq!(to_string(f, 1.9971e20, Minus, 8), \"199710000000000000000.00000000\");\n+\n+    assert_eq!(to_string(f, f32::MAX, Minus, 0), format!(\"34028235{:0>31}\", \"\"));\n+    assert_eq!(to_string(f, f32::MAX, Minus, 1), format!(\"34028235{:0>31}.0\", \"\"));\n+    assert_eq!(to_string(f, f32::MAX, Minus, 8), format!(\"34028235{:0>31}.00000000\", \"\"));\n \n     let minf32 = ldexp_f32(1.0, -149);\n-    assert_eq!(to_string(f, minf32, Minus, 0, false), format!(\"0.{:0>44}1\", \"\"));\n-    assert_eq!(to_string(f, minf32, Minus, 45, false), format!(\"0.{:0>44}1\", \"\"));\n-    assert_eq!(to_string(f, minf32, Minus, 46, false), format!(\"0.{:0>44}10\", \"\"));\n+    assert_eq!(to_string(f, minf32, Minus, 0), format!(\"0.{:0>44}1\", \"\"));\n+    assert_eq!(to_string(f, minf32, Minus, 45), format!(\"0.{:0>44}1\", \"\"));\n+    assert_eq!(to_string(f, minf32, Minus, 46), format!(\"0.{:0>44}10\", \"\"));\n \n-    assert_eq!(to_string(f, f64::MAX, Minus, 0, false), format!(\"17976931348623157{:0>292}\", \"\"));\n-    assert_eq!(to_string(f, f64::MAX, Minus, 1, false), format!(\"17976931348623157{:0>292}.0\", \"\"));\n-    assert_eq!(\n-        to_string(f, f64::MAX, Minus, 8, false),\n-        format!(\"17976931348623157{:0>292}.00000000\", \"\")\n-    );\n+    assert_eq!(to_string(f, f64::MAX, Minus, 0), format!(\"17976931348623157{:0>292}\", \"\"));\n+    assert_eq!(to_string(f, f64::MAX, Minus, 1), format!(\"17976931348623157{:0>292}.0\", \"\"));\n+    assert_eq!(to_string(f, f64::MAX, Minus, 8), format!(\"17976931348623157{:0>292}.00000000\", \"\"));\n \n     let minf64 = ldexp_f64(1.0, -1074);\n-    assert_eq!(to_string(f, minf64, Minus, 0, false), format!(\"0.{:0>323}5\", \"\"));\n-    assert_eq!(to_string(f, minf64, Minus, 324, false), format!(\"0.{:0>323}5\", \"\"));\n-    assert_eq!(to_string(f, minf64, Minus, 325, false), format!(\"0.{:0>323}50\", \"\"));\n+    assert_eq!(to_string(f, minf64, Minus, 0), format!(\"0.{:0>323}5\", \"\"));\n+    assert_eq!(to_string(f, minf64, Minus, 324), format!(\"0.{:0>323}5\", \"\"));\n+    assert_eq!(to_string(f, minf64, Minus, 325), format!(\"0.{:0>323}50\", \"\"));\n \n     if cfg!(miri) {\n         // Miri is too slow\n         return;\n     }\n \n     // very large output\n-    assert_eq!(to_string(f, 1.1, Minus, 80000, false), format!(\"1.1{:0>79999}\", \"\"));\n+    assert_eq!(to_string(f, 1.1, Minus, 80000), format!(\"1.1{:0>79999}\", \"\"));\n }\n \n pub fn to_shortest_exp_str_test<F>(mut f_: F)\n@@ -996,207 +993,198 @@ where\n {\n     use core::num::flt2dec::Sign::*;\n \n-    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize, upper: bool) -> String\n+    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize) -> String\n     where\n         T: DecodableFloat,\n         F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n     {\n         to_string_with_parts(|buf, parts| {\n-            to_exact_fixed_str(|d, b, l| f(d, b, l), v, sign, frac_digits, upper, buf, parts)\n+            to_exact_fixed_str(|d, b, l| f(d, b, l), v, sign, frac_digits, buf, parts)\n         })\n     }\n \n     let f = &mut f_;\n \n-    assert_eq!(to_string(f, 0.0, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.0, MinusRaw, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlus, 0, false), \"+0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 0, false), \"+0\");\n-    assert_eq!(to_string(f, -0.0, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, -0.0, MinusRaw, 0, false), \"-0\");\n-    assert_eq!(to_string(f, -0.0, MinusPlus, 0, false), \"+0\");\n-    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 0, false), \"-0\");\n-    assert_eq!(to_string(f, 0.0, Minus, 1, true), \"0.0\");\n-    assert_eq!(to_string(f, 0.0, MinusRaw, 1, true), \"0.0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlus, 1, true), \"+0.0\");\n-    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 1, true), \"+0.0\");\n-    assert_eq!(to_string(f, -0.0, Minus, 8, true), \"0.00000000\");\n-    assert_eq!(to_string(f, -0.0, MinusRaw, 8, true), \"-0.00000000\");\n-    assert_eq!(to_string(f, -0.0, MinusPlus, 8, true), \"+0.00000000\");\n-    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8, true), \"-0.00000000\");\n-\n-    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 0, false), \"inf\");\n-    assert_eq!(to_string(f, 1.0 / 0.0, MinusRaw, 1, true), \"inf\");\n-    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlus, 8, false), \"+inf\");\n-    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlusRaw, 64, true), \"+inf\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 0, false), \"NaN\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, MinusRaw, 1, true), \"NaN\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlus, 8, false), \"NaN\");\n-    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlusRaw, 64, true), \"NaN\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 0, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, MinusRaw, 1, true), \"-inf\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlus, 8, false), \"-inf\");\n-    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlusRaw, 64, true), \"-inf\");\n-\n-    assert_eq!(to_string(f, 3.14, Minus, 0, false), \"3\");\n-    assert_eq!(to_string(f, 3.14, MinusRaw, 0, false), \"3\");\n-    assert_eq!(to_string(f, 3.14, MinusPlus, 0, false), \"+3\");\n-    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 0, false), \"+3\");\n-    assert_eq!(to_string(f, -3.14, Minus, 0, false), \"-3\");\n-    assert_eq!(to_string(f, -3.14, MinusRaw, 0, false), \"-3\");\n-    assert_eq!(to_string(f, -3.14, MinusPlus, 0, false), \"-3\");\n-    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 0, false), \"-3\");\n-    assert_eq!(to_string(f, 3.14, Minus, 1, true), \"3.1\");\n-    assert_eq!(to_string(f, 3.14, MinusRaw, 2, true), \"3.14\");\n-    assert_eq!(to_string(f, 3.14, MinusPlus, 3, true), \"+3.140\");\n-    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 4, true), \"+3.1400\");\n-    assert_eq!(to_string(f, -3.14, Minus, 8, true), \"-3.14000000\");\n-    assert_eq!(to_string(f, -3.14, MinusRaw, 8, true), \"-3.14000000\");\n-    assert_eq!(to_string(f, -3.14, MinusPlus, 8, true), \"-3.14000000\");\n-    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 8, true), \"-3.14000000\");\n-\n-    assert_eq!(to_string(f, 0.195, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.195, MinusRaw, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.195, MinusPlus, 0, false), \"+0\");\n-    assert_eq!(to_string(f, 0.195, MinusPlusRaw, 0, false), \"+0\");\n-    assert_eq!(to_string(f, -0.195, Minus, 0, false), \"-0\");\n-    assert_eq!(to_string(f, -0.195, MinusRaw, 0, false), \"-0\");\n-    assert_eq!(to_string(f, -0.195, MinusPlus, 0, false), \"-0\");\n-    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 0, false), \"-0\");\n-    assert_eq!(to_string(f, 0.195, Minus, 1, true), \"0.2\");\n-    assert_eq!(to_string(f, 0.195, MinusRaw, 2, true), \"0.20\");\n-    assert_eq!(to_string(f, 0.195, MinusPlus, 3, true), \"+0.195\");\n-    assert_eq!(to_string(f, 0.195, MinusPlusRaw, 4, true), \"+0.1950\");\n-    assert_eq!(to_string(f, -0.195, Minus, 5, true), \"-0.19500\");\n-    assert_eq!(to_string(f, -0.195, MinusRaw, 6, true), \"-0.195000\");\n-    assert_eq!(to_string(f, -0.195, MinusPlus, 7, true), \"-0.1950000\");\n-    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 8, true), \"-0.19500000\");\n-\n-    assert_eq!(to_string(f, 999.5, Minus, 0, false), \"1000\");\n-    assert_eq!(to_string(f, 999.5, Minus, 1, false), \"999.5\");\n-    assert_eq!(to_string(f, 999.5, Minus, 2, false), \"999.50\");\n-    assert_eq!(to_string(f, 999.5, Minus, 3, false), \"999.500\");\n-    assert_eq!(to_string(f, 999.5, Minus, 30, false), \"999.500000000000000000000000000000\");\n-\n-    assert_eq!(to_string(f, 0.5, Minus, 0, false), \"1\");\n-    assert_eq!(to_string(f, 0.5, Minus, 1, false), \"0.5\");\n-    assert_eq!(to_string(f, 0.5, Minus, 2, false), \"0.50\");\n-    assert_eq!(to_string(f, 0.5, Minus, 3, false), \"0.500\");\n-\n-    assert_eq!(to_string(f, 0.95, Minus, 0, false), \"1\");\n-    assert_eq!(to_string(f, 0.95, Minus, 1, false), \"0.9\"); // because it really is less than 0.95\n-    assert_eq!(to_string(f, 0.95, Minus, 2, false), \"0.95\");\n-    assert_eq!(to_string(f, 0.95, Minus, 3, false), \"0.950\");\n-    assert_eq!(to_string(f, 0.95, Minus, 10, false), \"0.9500000000\");\n-    assert_eq!(to_string(f, 0.95, Minus, 30, false), \"0.949999999999999955591079014994\");\n-\n-    assert_eq!(to_string(f, 0.095, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.095, Minus, 1, false), \"0.1\");\n-    assert_eq!(to_string(f, 0.095, Minus, 2, false), \"0.10\");\n-    assert_eq!(to_string(f, 0.095, Minus, 3, false), \"0.095\");\n-    assert_eq!(to_string(f, 0.095, Minus, 4, false), \"0.0950\");\n-    assert_eq!(to_string(f, 0.095, Minus, 10, false), \"0.0950000000\");\n-    assert_eq!(to_string(f, 0.095, Minus, 30, false), \"0.095000000000000001110223024625\");\n-\n-    assert_eq!(to_string(f, 0.0095, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 0.0095, Minus, 1, false), \"0.0\");\n-    assert_eq!(to_string(f, 0.0095, Minus, 2, false), \"0.01\");\n-    assert_eq!(to_string(f, 0.0095, Minus, 3, false), \"0.009\"); // really is less than 0.0095\n-    assert_eq!(to_string(f, 0.0095, Minus, 4, false), \"0.0095\");\n-    assert_eq!(to_string(f, 0.0095, Minus, 5, false), \"0.00950\");\n-    assert_eq!(to_string(f, 0.0095, Minus, 10, false), \"0.0095000000\");\n-    assert_eq!(to_string(f, 0.0095, Minus, 30, false), \"0.009499999999999999764077607267\");\n-\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 3, false), \"0.000\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 10, false), \"0.0000000001\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 11, false), \"0.00000000007\"); // ditto\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 12, false), \"0.000000000075\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 13, false), \"0.0000000000750\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 20, false), \"0.00000000007500000000\");\n-    assert_eq!(to_string(f, 7.5e-11, Minus, 30, false), \"0.000000000074999999999999999501\");\n-\n-    assert_eq!(to_string(f, 1.0e25, Minus, 0, false), \"10000000000000000905969664\");\n-    assert_eq!(to_string(f, 1.0e25, Minus, 1, false), \"10000000000000000905969664.0\");\n-    assert_eq!(to_string(f, 1.0e25, Minus, 3, false), \"10000000000000000905969664.000\");\n-\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 3, false), \"0.000\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 6, false), \"0.000001\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 9, false), \"0.000001000\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 12, false), \"0.000001000000\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 22, false), \"0.0000010000000000000000\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 23, false), \"0.00000099999999999999995\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 24, false), \"0.000000999999999999999955\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 25, false), \"0.0000009999999999999999547\");\n-    assert_eq!(to_string(f, 1.0e-6, Minus, 35, false), \"0.00000099999999999999995474811182589\");\n+    assert_eq!(to_string(f, 0.0, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 0.0, MinusRaw, 0), \"0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlus, 0), \"+0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 0), \"+0\");\n+    assert_eq!(to_string(f, -0.0, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw, 0), \"-0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus, 0), \"+0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 0), \"-0\");\n+    assert_eq!(to_string(f, 0.0, Minus, 1), \"0.0\");\n+    assert_eq!(to_string(f, 0.0, MinusRaw, 1), \"0.0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlus, 1), \"+0.0\");\n+    assert_eq!(to_string(f, 0.0, MinusPlusRaw, 1), \"+0.0\");\n+    assert_eq!(to_string(f, -0.0, Minus, 8), \"0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw, 8), \"-0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus, 8), \"+0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8), \"-0.00000000\");\n+\n+    assert_eq!(to_string(f, 1.0 / 0.0, Minus, 0), \"inf\");\n+    assert_eq!(to_string(f, 1.0 / 0.0, MinusRaw, 1), \"inf\");\n+    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlus, 8), \"+inf\");\n+    assert_eq!(to_string(f, 1.0 / 0.0, MinusPlusRaw, 64), \"+inf\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, Minus, 0), \"NaN\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, MinusRaw, 1), \"NaN\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlus, 8), \"NaN\");\n+    assert_eq!(to_string(f, 0.0 / 0.0, MinusPlusRaw, 64), \"NaN\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, Minus, 0), \"-inf\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, MinusRaw, 1), \"-inf\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlus, 8), \"-inf\");\n+    assert_eq!(to_string(f, -1.0 / 0.0, MinusPlusRaw, 64), \"-inf\");\n+\n+    assert_eq!(to_string(f, 3.14, Minus, 0), \"3\");\n+    assert_eq!(to_string(f, 3.14, MinusRaw, 0), \"3\");\n+    assert_eq!(to_string(f, 3.14, MinusPlus, 0), \"+3\");\n+    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 0), \"+3\");\n+    assert_eq!(to_string(f, -3.14, Minus, 0), \"-3\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw, 0), \"-3\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus, 0), \"-3\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 0), \"-3\");\n+    assert_eq!(to_string(f, 3.14, Minus, 1), \"3.1\");\n+    assert_eq!(to_string(f, 3.14, MinusRaw, 2), \"3.14\");\n+    assert_eq!(to_string(f, 3.14, MinusPlus, 3), \"+3.140\");\n+    assert_eq!(to_string(f, 3.14, MinusPlusRaw, 4), \"+3.1400\");\n+    assert_eq!(to_string(f, -3.14, Minus, 8), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw, 8), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus, 8), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 8), \"-3.14000000\");\n+\n+    assert_eq!(to_string(f, 0.195, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 0.195, MinusRaw, 0), \"0\");\n+    assert_eq!(to_string(f, 0.195, MinusPlus, 0), \"+0\");\n+    assert_eq!(to_string(f, 0.195, MinusPlusRaw, 0), \"+0\");\n+    assert_eq!(to_string(f, -0.195, Minus, 0), \"-0\");\n+    assert_eq!(to_string(f, -0.195, MinusRaw, 0), \"-0\");\n+    assert_eq!(to_string(f, -0.195, MinusPlus, 0), \"-0\");\n+    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 0), \"-0\");\n+    assert_eq!(to_string(f, 0.195, Minus, 1), \"0.2\");\n+    assert_eq!(to_string(f, 0.195, MinusRaw, 2), \"0.20\");\n+    assert_eq!(to_string(f, 0.195, MinusPlus, 3), \"+0.195\");\n+    assert_eq!(to_string(f, 0.195, MinusPlusRaw, 4), \"+0.1950\");\n+    assert_eq!(to_string(f, -0.195, Minus, 5), \"-0.19500\");\n+    assert_eq!(to_string(f, -0.195, MinusRaw, 6), \"-0.195000\");\n+    assert_eq!(to_string(f, -0.195, MinusPlus, 7), \"-0.1950000\");\n+    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 8), \"-0.19500000\");\n+\n+    assert_eq!(to_string(f, 999.5, Minus, 0), \"1000\");\n+    assert_eq!(to_string(f, 999.5, Minus, 1), \"999.5\");\n+    assert_eq!(to_string(f, 999.5, Minus, 2), \"999.50\");\n+    assert_eq!(to_string(f, 999.5, Minus, 3), \"999.500\");\n+    assert_eq!(to_string(f, 999.5, Minus, 30), \"999.500000000000000000000000000000\");\n+\n+    assert_eq!(to_string(f, 0.5, Minus, 0), \"1\");\n+    assert_eq!(to_string(f, 0.5, Minus, 1), \"0.5\");\n+    assert_eq!(to_string(f, 0.5, Minus, 2), \"0.50\");\n+    assert_eq!(to_string(f, 0.5, Minus, 3), \"0.500\");\n+\n+    assert_eq!(to_string(f, 0.95, Minus, 0), \"1\");\n+    assert_eq!(to_string(f, 0.95, Minus, 1), \"0.9\"); // because it really is less than 0.95\n+    assert_eq!(to_string(f, 0.95, Minus, 2), \"0.95\");\n+    assert_eq!(to_string(f, 0.95, Minus, 3), \"0.950\");\n+    assert_eq!(to_string(f, 0.95, Minus, 10), \"0.9500000000\");\n+    assert_eq!(to_string(f, 0.95, Minus, 30), \"0.949999999999999955591079014994\");\n+\n+    assert_eq!(to_string(f, 0.095, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 0.095, Minus, 1), \"0.1\");\n+    assert_eq!(to_string(f, 0.095, Minus, 2), \"0.10\");\n+    assert_eq!(to_string(f, 0.095, Minus, 3), \"0.095\");\n+    assert_eq!(to_string(f, 0.095, Minus, 4), \"0.0950\");\n+    assert_eq!(to_string(f, 0.095, Minus, 10), \"0.0950000000\");\n+    assert_eq!(to_string(f, 0.095, Minus, 30), \"0.095000000000000001110223024625\");\n+\n+    assert_eq!(to_string(f, 0.0095, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 1), \"0.0\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 2), \"0.01\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 3), \"0.009\"); // really is less than 0.0095\n+    assert_eq!(to_string(f, 0.0095, Minus, 4), \"0.0095\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 5), \"0.00950\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 10), \"0.0095000000\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 30), \"0.009499999999999999764077607267\");\n+\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 3), \"0.000\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 10), \"0.0000000001\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 11), \"0.00000000007\"); // ditto\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 12), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 13), \"0.0000000000750\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 20), \"0.00000000007500000000\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 30), \"0.000000000074999999999999999501\");\n+\n+    assert_eq!(to_string(f, 1.0e25, Minus, 0), \"10000000000000000905969664\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 1), \"10000000000000000905969664.0\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 3), \"10000000000000000905969664.000\");\n+\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 3), \"0.000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 6), \"0.000001\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 9), \"0.000001000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 12), \"0.000001000000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 22), \"0.0000010000000000000000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 23), \"0.00000099999999999999995\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 24), \"0.000000999999999999999955\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 25), \"0.0000009999999999999999547\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 35), \"0.00000099999999999999995474811182589\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 45), \"0.000000999999999999999954748111825886258685614\");\n     assert_eq!(\n-        to_string(f, 1.0e-6, Minus, 45, false),\n-        \"0.000000999999999999999954748111825886258685614\"\n-    );\n-    assert_eq!(\n-        to_string(f, 1.0e-6, Minus, 55, false),\n+        to_string(f, 1.0e-6, Minus, 55),\n         \"0.0000009999999999999999547481118258862586856139387236908\"\n     );\n     assert_eq!(\n-        to_string(f, 1.0e-6, Minus, 65, false),\n+        to_string(f, 1.0e-6, Minus, 65),\n         \"0.00000099999999999999995474811182588625868561393872369080781936646\"\n     );\n     assert_eq!(\n-        to_string(f, 1.0e-6, Minus, 75, false),\n+        to_string(f, 1.0e-6, Minus, 75),\n         \"0.000000999999999999999954748111825886258685613938723690807819366455078125000\"\n     );\n \n-    assert_eq!(to_string(f, f32::MAX, Minus, 0, false), \"340282346638528859811704183484516925440\");\n-    assert_eq!(\n-        to_string(f, f32::MAX, Minus, 1, false),\n-        \"340282346638528859811704183484516925440.0\"\n-    );\n-    assert_eq!(\n-        to_string(f, f32::MAX, Minus, 2, false),\n-        \"340282346638528859811704183484516925440.00\"\n-    );\n+    assert_eq!(to_string(f, f32::MAX, Minus, 0), \"340282346638528859811704183484516925440\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 1), \"340282346638528859811704183484516925440.0\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 2), \"340282346638528859811704183484516925440.00\");\n \n     if cfg!(miri) {\n         // Miri is too slow\n         return;\n     }\n \n     let minf32 = ldexp_f32(1.0, -149);\n-    assert_eq!(to_string(f, minf32, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, minf32, Minus, 1, false), \"0.0\");\n-    assert_eq!(to_string(f, minf32, Minus, 2, false), \"0.00\");\n-    assert_eq!(to_string(f, minf32, Minus, 4, false), \"0.0000\");\n-    assert_eq!(to_string(f, minf32, Minus, 8, false), \"0.00000000\");\n-    assert_eq!(to_string(f, minf32, Minus, 16, false), \"0.0000000000000000\");\n-    assert_eq!(to_string(f, minf32, Minus, 32, false), \"0.00000000000000000000000000000000\");\n+    assert_eq!(to_string(f, minf32, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, minf32, Minus, 1), \"0.0\");\n+    assert_eq!(to_string(f, minf32, Minus, 2), \"0.00\");\n+    assert_eq!(to_string(f, minf32, Minus, 4), \"0.0000\");\n+    assert_eq!(to_string(f, minf32, Minus, 8), \"0.00000000\");\n+    assert_eq!(to_string(f, minf32, Minus, 16), \"0.0000000000000000\");\n+    assert_eq!(to_string(f, minf32, Minus, 32), \"0.00000000000000000000000000000000\");\n     assert_eq!(\n-        to_string(f, minf32, Minus, 64, false),\n+        to_string(f, minf32, Minus, 64),\n         \"0.0000000000000000000000000000000000000000000014012984643248170709\"\n     );\n     assert_eq!(\n-        to_string(f, minf32, Minus, 128, false),\n+        to_string(f, minf32, Minus, 128),\n         \"0.0000000000000000000000000000000000000000000014012984643248170709\\\n                   2372958328991613128026194187651577175706828388979108268586060149\"\n     );\n     assert_eq!(\n-        to_string(f, minf32, Minus, 256, false),\n+        to_string(f, minf32, Minus, 256),\n         \"0.0000000000000000000000000000000000000000000014012984643248170709\\\n                   2372958328991613128026194187651577175706828388979108268586060148\\\n                   6638188362121582031250000000000000000000000000000000000000000000\\\n                   0000000000000000000000000000000000000000000000000000000000000000\"\n     );\n \n     assert_eq!(\n-        to_string(f, f64::MAX, Minus, 0, false),\n+        to_string(f, f64::MAX, Minus, 0),\n         \"1797693134862315708145274237317043567980705675258449965989174768\\\n                 0315726078002853876058955863276687817154045895351438246423432132\\\n                 6889464182768467546703537516986049910576551282076245490090389328\\\n                 9440758685084551339423045832369032229481658085593321233482747978\\\n                 26204144723168738177180919299881250404026184124858368\"\n     );\n     assert_eq!(\n-        to_string(f, f64::MAX, Minus, 10, false),\n+        to_string(f, f64::MAX, Minus, 10),\n         \"1797693134862315708145274237317043567980705675258449965989174768\\\n                 0315726078002853876058955863276687817154045895351438246423432132\\\n                 6889464182768467546703537516986049910576551282076245490090389328\\\n@@ -1205,16 +1193,16 @@ where\n     );\n \n     let minf64 = ldexp_f64(1.0, -1074);\n-    assert_eq!(to_string(f, minf64, Minus, 0, false), \"0\");\n-    assert_eq!(to_string(f, minf64, Minus, 1, false), \"0.0\");\n-    assert_eq!(to_string(f, minf64, Minus, 10, false), \"0.0000000000\");\n+    assert_eq!(to_string(f, minf64, Minus, 0), \"0\");\n+    assert_eq!(to_string(f, minf64, Minus, 1), \"0.0\");\n+    assert_eq!(to_string(f, minf64, Minus, 10), \"0.0000000000\");\n     assert_eq!(\n-        to_string(f, minf64, Minus, 100, false),\n+        to_string(f, minf64, Minus, 100),\n         \"0.0000000000000000000000000000000000000000000000000000000000000000\\\n                   000000000000000000000000000000000000\"\n     );\n     assert_eq!(\n-        to_string(f, minf64, Minus, 1000, false),\n+        to_string(f, minf64, Minus, 1000),\n         \"0.0000000000000000000000000000000000000000000000000000000000000000\\\n                   0000000000000000000000000000000000000000000000000000000000000000\\\n                   0000000000000000000000000000000000000000000000000000000000000000\\\n@@ -1234,15 +1222,15 @@ where\n     );\n \n     // very large output\n-    assert_eq!(to_string(f, 0.0, Minus, 80000, false), format!(\"0.{:0>80000}\", \"\"));\n-    assert_eq!(to_string(f, 1.0e1, Minus, 80000, false), format!(\"10.{:0>80000}\", \"\"));\n-    assert_eq!(to_string(f, 1.0e0, Minus, 80000, false), format!(\"1.{:0>80000}\", \"\"));\n+    assert_eq!(to_string(f, 0.0, Minus, 80000), format!(\"0.{:0>80000}\", \"\"));\n+    assert_eq!(to_string(f, 1.0e1, Minus, 80000), format!(\"10.{:0>80000}\", \"\"));\n+    assert_eq!(to_string(f, 1.0e0, Minus, 80000), format!(\"1.{:0>80000}\", \"\"));\n     assert_eq!(\n-        to_string(f, 1.0e-1, Minus, 80000, false),\n+        to_string(f, 1.0e-1, Minus, 80000),\n         format!(\"0.1000000000000000055511151231257827021181583404541015625{:0>79945}\", \"\")\n     );\n     assert_eq!(\n-        to_string(f, 1.0e-20, Minus, 80000, false),\n+        to_string(f, 1.0e-20, Minus, 80000),\n         format!(\n             \"0.0000000000000000000099999999999999994515327145420957165172950370\\\n                           2787392447107715776066783064379706047475337982177734375{:0>79881}\","}, {"sha": "c1fbdf7df76fc1f3784b652ada5c29f9ae011194", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -11,6 +11,12 @@ fn creation() {\n     assert_eq!(Duration::from_millis(4000), Duration::new(4, 0));\n }\n \n+#[test]\n+#[should_panic]\n+fn new_overflow() {\n+    let _ = Duration::new(::core::u64::MAX, 1_000_000_000);\n+}\n+\n #[test]\n fn secs() {\n     assert_eq!(Duration::new(0, 0).as_secs(), 0);"}, {"sha": "a53e0012ca2210eee77bffc2b381eb3f90acf82b", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -597,6 +597,8 @@ pub enum RenderOption {\n     NoNodeLabels,\n     NoEdgeStyles,\n     NoNodeStyles,\n+\n+    Monospace,\n }\n \n /// Returns vec holding all the default render options.\n@@ -626,6 +628,14 @@ where\n     W: Write,\n {\n     writeln!(w, \"digraph {} {{\", g.graph_id().as_slice())?;\n+\n+    // Global graph properties\n+    if options.contains(&RenderOption::Monospace) {\n+        writeln!(w, r#\"    graph[fontname=\"monospace\"];\"#)?;\n+        writeln!(w, r#\"    node[fontname=\"monospace\"];\"#)?;\n+        writeln!(w, r#\"    edge[fontname=\"monospace\"];\"#)?;\n+    }\n+\n     for n in g.nodes().iter() {\n         write!(w, \"    \")?;\n         let id = g.node_id(n);"}, {"sha": "af2be30cc0a8611712ca9b5858ede0b704ccb0c4", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -12,8 +12,6 @@ doctest = false\n [dependencies]\n arena = { path = \"../libarena\" }\n bitflags = \"1.2.1\"\n-fmt_macros = { path = \"../libfmt_macros\" }\n-graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }"}, {"sha": "ca55d410ceba4695e537377243b2e52eb703d9f8", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -35,7 +35,8 @@ macro_rules! arena_types {\n                 rustc::mir::Promoted,\n                 rustc::mir::BodyAndCache<$tcx>\n             >,\n-            [] tables: rustc::ty::TypeckTables<$tcx>,\n+            [decode] tables: rustc::ty::TypeckTables<$tcx>,\n+            [decode] borrowck_result: rustc::mir::BorrowCheckResult<$tcx>,\n             [] const_allocs: rustc::mir::interpret::Allocation,\n             [] vtable_method: Option<(\n                 rustc_hir::def_id::DefId,\n@@ -47,22 +48,23 @@ macro_rules! arena_types {\n             [] item_local_set: rustc_hir::ItemLocalSet,\n             [decode] mir_const_qualif: rustc_index::bit_set::BitSet<rustc::mir::Local>,\n             [] trait_impls_of: rustc::ty::trait_def::TraitImpls,\n+            [] associated_items: rustc::ty::AssociatedItems,\n             [] dropck_outlives:\n                 rustc::infer::canonical::Canonical<'tcx,\n                     rustc::infer::canonical::QueryResponse<'tcx,\n-                        rustc::traits::query::dropck_outlives::DropckOutlivesResult<'tcx>\n+                        rustc::traits::query::DropckOutlivesResult<'tcx>\n                     >\n                 >,\n             [] normalize_projection_ty:\n                 rustc::infer::canonical::Canonical<'tcx,\n                     rustc::infer::canonical::QueryResponse<'tcx,\n-                        rustc::traits::query::normalize::NormalizationResult<'tcx>\n+                        rustc::traits::query::NormalizationResult<'tcx>\n                     >\n                 >,\n             [] implied_outlives_bounds:\n                 rustc::infer::canonical::Canonical<'tcx,\n                     rustc::infer::canonical::QueryResponse<'tcx,\n-                        Vec<rustc::traits::query::outlives_bounds::OutlivesBound<'tcx>>\n+                        Vec<rustc::traits::query::OutlivesBound<'tcx>>\n                     >\n                 >,\n             [] type_op_subtype:"}, {"sha": "eb7e2871bfcd8371b6c1c3414559fe1b2c89c269", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 42, "deletions": 97, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -76,10 +76,6 @@ macro_rules! erase {\n     ($x:tt) => {{}};\n }\n \n-macro_rules! replace {\n-    ($x:tt with $($y:tt)*) => ($($y)*)\n-}\n-\n macro_rules! is_anon_attr {\n     (anon) => {\n         true\n@@ -99,19 +95,18 @@ macro_rules! is_eval_always_attr {\n }\n \n macro_rules! contains_anon_attr {\n-    ($($attr:ident),*) => ({$(is_anon_attr!($attr) | )* false});\n+    ($($attr:ident $(($($attr_args:tt)*))* ),*) => ({$(is_anon_attr!($attr) | )* false});\n }\n \n macro_rules! contains_eval_always_attr {\n-    ($($attr:ident),*) => ({$(is_eval_always_attr!($attr) | )* false});\n+    ($($attr:ident $(($($attr_args:tt)*))* ),*) => ({$(is_eval_always_attr!($attr) | )* false});\n }\n \n macro_rules! define_dep_nodes {\n     (<$tcx:tt>\n     $(\n-        [$($attr:ident),* ]\n+        [$($attrs:tt)*]\n         $variant:ident $(( $tuple_arg_ty:ty $(,)? ))*\n-                       $({ $($struct_arg_name:ident : $struct_arg_ty:ty),* })*\n       ,)*\n     ) => (\n         #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n@@ -126,7 +121,7 @@ macro_rules! define_dep_nodes {\n                 match *self {\n                     $(\n                         DepKind :: $variant => {\n-                            if contains_anon_attr!($($attr),*) {\n+                            if contains_anon_attr!($($attrs)*) {\n                                 return false;\n                             }\n \n@@ -136,13 +131,6 @@ macro_rules! define_dep_nodes {\n                                     ::CAN_RECONSTRUCT_QUERY_KEY;\n                             })*\n \n-                            // struct args\n-                            $({\n-\n-                                return <( $($struct_arg_ty,)* ) as DepNodeParams>\n-                                    ::CAN_RECONSTRUCT_QUERY_KEY;\n-                            })*\n-\n                             true\n                         }\n                     )*\n@@ -152,15 +140,15 @@ macro_rules! define_dep_nodes {\n             pub fn is_anon(&self) -> bool {\n                 match *self {\n                     $(\n-                        DepKind :: $variant => { contains_anon_attr!($($attr),*) }\n+                        DepKind :: $variant => { contains_anon_attr!($($attrs)*) }\n                     )*\n                 }\n             }\n \n             pub fn is_eval_always(&self) -> bool {\n                 match *self {\n                     $(\n-                        DepKind :: $variant => { contains_eval_always_attr!($($attr), *) }\n+                        DepKind :: $variant => { contains_eval_always_attr!($($attrs)*) }\n                     )*\n                 }\n             }\n@@ -176,24 +164,50 @@ macro_rules! define_dep_nodes {\n                                 return true;\n                             })*\n \n-                            // struct args\n-                            $({\n-                                $(erase!($struct_arg_name);)*\n-                                return true;\n-                            })*\n-\n                             false\n                         }\n                     )*\n                 }\n             }\n         }\n \n-        pub enum DepConstructor<$tcx> {\n+        pub struct DepConstructor;\n+\n+        impl DepConstructor {\n             $(\n-                $variant $(( $tuple_arg_ty ))*\n-                         $({ $($struct_arg_name : $struct_arg_ty),* })*\n-            ),*\n+                #[inline(always)]\n+                #[allow(unreachable_code, non_snake_case)]\n+                pub fn $variant<'tcx>(_tcx: TyCtxt<'tcx>, $(arg: $tuple_arg_ty)*) -> DepNode {\n+                    // tuple args\n+                    $({\n+                        erase!($tuple_arg_ty);\n+                        let hash = DepNodeParams::to_fingerprint(&arg, _tcx);\n+                        let dep_node = DepNode {\n+                            kind: DepKind::$variant,\n+                            hash\n+                        };\n+\n+                        #[cfg(debug_assertions)]\n+                        {\n+                            if !dep_node.kind.can_reconstruct_query_key() &&\n+                            (_tcx.sess.opts.debugging_opts.incremental_info ||\n+                                _tcx.sess.opts.debugging_opts.query_dep_graph)\n+                            {\n+                                _tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n+                                    arg.to_debug_str(_tcx)\n+                                });\n+                            }\n+                        }\n+\n+                        return dep_node;\n+                    })*\n+\n+                    DepNode {\n+                        kind: DepKind::$variant,\n+                        hash: Fingerprint::ZERO,\n+                    }\n+                }\n+            )*\n         }\n \n         #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n@@ -204,75 +218,6 @@ macro_rules! define_dep_nodes {\n         }\n \n         impl DepNode {\n-            #[allow(unreachable_code, non_snake_case)]\n-            pub fn new<'tcx>(tcx: TyCtxt<'tcx>,\n-                                       dep: DepConstructor<'tcx>)\n-                                       -> DepNode\n-            {\n-                match dep {\n-                    $(\n-                        DepConstructor :: $variant $(( replace!(($tuple_arg_ty) with arg) ))*\n-                                                   $({ $($struct_arg_name),* })*\n-                            =>\n-                        {\n-                            // tuple args\n-                            $({\n-                                erase!($tuple_arg_ty);\n-                                let hash = DepNodeParams::to_fingerprint(&arg, tcx);\n-                                let dep_node = DepNode {\n-                                    kind: DepKind::$variant,\n-                                    hash\n-                                };\n-\n-                                #[cfg(debug_assertions)]\n-                                {\n-                                    if !dep_node.kind.can_reconstruct_query_key() &&\n-                                    (tcx.sess.opts.debugging_opts.incremental_info ||\n-                                        tcx.sess.opts.debugging_opts.query_dep_graph)\n-                                    {\n-                                        tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                            arg.to_debug_str(tcx)\n-                                        });\n-                                    }\n-                                }\n-\n-                                return dep_node;\n-                            })*\n-\n-                            // struct args\n-                            $({\n-                                let tupled_args = ( $($struct_arg_name,)* );\n-                                let hash = DepNodeParams::to_fingerprint(&tupled_args,\n-                                                                         tcx);\n-                                let dep_node = DepNode {\n-                                    kind: DepKind::$variant,\n-                                    hash\n-                                };\n-\n-                                #[cfg(debug_assertions)]\n-                                {\n-                                    if !dep_node.kind.can_reconstruct_query_key() &&\n-                                    (tcx.sess.opts.debugging_opts.incremental_info ||\n-                                        tcx.sess.opts.debugging_opts.query_dep_graph)\n-                                    {\n-                                        tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                            tupled_args.to_debug_str(tcx)\n-                                        });\n-                                    }\n-                                }\n-\n-                                return dep_node;\n-                            })*\n-\n-                            DepNode {\n-                                kind: DepKind::$variant,\n-                                hash: Fingerprint::ZERO,\n-                            }\n-                        }\n-                    )*\n-                }\n-            }\n-\n             /// Construct a DepNode from the given DepKind and DefPathHash. This\n             /// method will assert that the given DepKind actually requires a\n             /// single DefId/DefPathHash parameter."}, {"sha": "531a45b120c248dbd0d21091f2d4aebad4265550", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1122,6 +1122,7 @@ impl CurrentDepGraph {\n }\n \n impl DepGraphData {\n+    #[inline(never)]\n     fn read_index(&self, source: DepNodeIndex) {\n         ty::tls::with_context_opt(|icx| {\n             let icx = if let Some(icx) = icx { icx } else { return };"}, {"sha": "bf1fc09649a58e5041ec7e9f9d9729044f8fa21c", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -140,6 +140,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                 trait_impls: _,\n                 body_ids: _,\n                 modules: _,\n+                proc_macros: _,\n             } = *krate;\n \n             alloc_hir_dep_nodes("}, {"sha": "a4f9193c0eb649ed535b3fad399150158b027373", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{HirId, ItemLocalId};\n \n-pub fn check_crate(hir_map: &Map<'_>) {\n+pub fn check_crate(hir_map: &Map<'_>, sess: &rustc_session::Session) {\n     hir_map.dep_graph.assert_ignored();\n \n     let errors = Lock::new(Vec::new());\n@@ -24,7 +24,7 @@ pub fn check_crate(hir_map: &Map<'_>) {\n \n     if !errors.is_empty() {\n         let message = errors.iter().fold(String::new(), |s1, s2| s1 + \"\\n\" + s2);\n-        bug!(\"{}\", message);\n+        sess.delay_span_bug(rustc_span::DUMMY_SP, &message);\n     }\n }\n "}, {"sha": "adda0cde24fc08b17fb2b86a00d8d8e40a7de5e5", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1235,7 +1235,7 @@ pub fn map_crate<'hir>(\n     let map = Map { krate, dep_graph, crate_hash, map, hir_to_node_id, definitions };\n \n     sess.time(\"validate_HIR_map\", || {\n-        hir_id_validator::check_crate(&map);\n+        hir_id_validator::check_crate(&map, sess);\n     });\n \n     map"}, {"sha": "7d48280661a64232a6487687ab4dfc9b10c09eeb", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -2,7 +2,6 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n \n-pub mod check_attr;\n pub mod exports;\n pub mod map;\n "}, {"sha": "1a9c5d1f13fe1608e23a1c385edf2ec3deeb289d", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -149,7 +149,7 @@ impl<'a> StableHashingContext<'a> {\n     #[inline]\n     pub fn source_map(&mut self) -> &mut CachingSourceMapView<'a> {\n         match self.caching_source_map {\n-            Some(ref mut cm) => cm,\n+            Some(ref mut sm) => sm,\n             ref mut none => {\n                 *none = Some(CachingSourceMapView::new(self.raw_source_map));\n                 none.as_mut().unwrap()\n@@ -220,27 +220,8 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::HirId {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for ast::NodeId {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        match hcx.node_id_hashing_mode {\n-            NodeIdHashingMode::Ignore => {\n-                // Don't do anything.\n-            }\n-            NodeIdHashingMode::HashDefPath => {\n-                hcx.definitions.node_to_hir_id(*self).hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::NodeId {\n-    type KeyType = (DefPathHash, hir::ItemLocalId);\n-\n-    #[inline]\n-    fn to_stable_hash_key(\n-        &self,\n-        hcx: &StableHashingContext<'a>,\n-    ) -> (DefPathHash, hir::ItemLocalId) {\n-        hcx.definitions.node_to_hir_id(*self).to_stable_hash_key(hcx)\n+    fn hash_stable(&self, _: &mut StableHashingContext<'a>, _: &mut StableHasher) {\n+        panic!(\"Node IDs should not appear in incremental state\");\n     }\n }\n \n@@ -249,6 +230,12 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n         self.hash_spans\n     }\n \n+    #[inline]\n+    fn hash_def_id(&mut self, def_id: DefId, hasher: &mut StableHasher) {\n+        let hcx = self;\n+        hcx.def_path_hash(def_id).hash_stable(hcx, hasher);\n+    }\n+\n     fn byte_pos_to_line_and_col(\n         &mut self,\n         byte: BytePos,"}, {"sha": "eadc9ddeee6fc827af0b4736b02abc0bb7876f13", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -11,12 +11,6 @@ use smallvec::SmallVec;\n use std::mem;\n \n impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n-    #[inline]\n-    fn hash_def_id(&mut self, def_id: DefId, hasher: &mut StableHasher) {\n-        let hcx = self;\n-        hcx.def_path_hash(def_id).hash_stable(hcx, hasher);\n-    }\n-\n     #[inline]\n     fn hash_hir_id(&mut self, hir_id: hir::HirId, hasher: &mut StableHasher) {\n         let hcx = self;\n@@ -257,12 +251,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::def_id::DefIndex {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::LangItem {\n-    fn hash_stable(&self, _: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        ::std::hash::Hash::hash(self, hasher);\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n@@ -282,7 +270,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n \n         let import_keys = import_ids\n             .iter()\n-            .map(|node_id| hcx.node_to_hir_id(*node_id))\n             .map(|hir_id| (hcx.local_def_path_hash(hir_id.owner), hir_id.local_id))\n             .collect();\n         (hcx.def_path_hash(*def_id), import_keys)"}, {"sha": "76d0d57e233a34a1a0c22720aa4426b1efd53be0", "filename": "src/librustc/infer/canonical.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -21,7 +21,7 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use crate::infer::region_constraints::MemberConstraint;\n+use crate::infer::MemberConstraint;\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, BoundVar, List, Region, TyCtxt};\n use rustc_index::vec::IndexVec;", "previous_filename": "src/librustc/infer/types/canonical.rs"}, {"sha": "497d3811f281b0af514163f092e46969f40dabc6", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 21, "deletions": 1748, "changes": 1769, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,1759 +1,32 @@\n-//! See the Book for more information.\n-\n-pub use self::freshen::TypeFreshener;\n-pub use self::LateBoundRegionConversionTime::*;\n-pub use self::RegionVariableOrigin::*;\n-pub use self::SubregionOrigin::*;\n-pub use self::ValuePairs::*;\n-pub use crate::ty::IntVarValue;\n-\n-use crate::infer::canonical::{Canonical, CanonicalVarValues};\n-use crate::infer::unify_key::{ConstVarValue, ConstVariableValue};\n-use crate::middle::free_region::RegionRelations;\n-use crate::middle::lang_items;\n-use crate::middle::region;\n-use crate::session::config::BorrowckMode;\n-use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n-use crate::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use crate::ty::fold::{TypeFoldable, TypeFolder};\n-use crate::ty::relate::RelateResult;\n-use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n-use crate::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n-use crate::ty::{ConstVid, FloatVid, IntVid, TyVid};\n+pub mod canonical;\n+pub mod unify_key;\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use crate::ty::Region;\n+use crate::ty::Ty;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::unify as ut;\n-use rustc_errors::DiagnosticBuilder;\n-use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n-use std::cell::{Cell, Ref, RefCell, RefMut};\n-use std::collections::BTreeMap;\n-use std::fmt;\n-use syntax::ast;\n-\n-use self::combine::CombineFields;\n-use self::lexical_region_resolve::LexicalRegionResolutions;\n-use self::outlives::env::OutlivesEnvironment;\n-use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n-use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n-use self::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use self::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n-\n-pub mod at;\n-pub mod canonical;\n-mod combine;\n-mod equate;\n-pub mod error_reporting;\n-mod freshen;\n-mod fudge;\n-mod glb;\n-mod higher_ranked;\n-pub mod lattice;\n-mod lexical_region_resolve;\n-mod lub;\n-pub mod nll_relate;\n-pub mod opaque_types;\n-pub mod outlives;\n-pub mod region_constraints;\n-pub mod resolve;\n-mod sub;\n-pub mod type_variable;\n-mod types;\n-pub mod unify_key;\n-\n-#[must_use]\n-#[derive(Debug)]\n-pub struct InferOk<'tcx, T> {\n-    pub value: T,\n-    pub obligations: PredicateObligations<'tcx>,\n-}\n-pub type InferResult<'tcx, T> = Result<InferOk<'tcx, T>, TypeError<'tcx>>;\n-\n-pub type Bound<T> = Option<T>;\n-pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n-pub type FixupResult<'tcx, T> = Result<T, FixupError<'tcx>>; // \"fixup result\"\n-\n-/// A flag that is used to suppress region errors. This is normally\n-/// false, but sometimes -- when we are doing region checks that the\n-/// NLL borrow checker will also do -- it might be set to true.\n-#[derive(Copy, Clone, Default, Debug)]\n-pub struct SuppressRegionErrors {\n-    suppressed: bool,\n-}\n-\n-impl SuppressRegionErrors {\n-    pub fn suppressed(self) -> bool {\n-        self.suppressed\n-    }\n-\n-    /// Indicates that the MIR borrowck will repeat these region\n-    /// checks, so we should ignore errors if NLL is (unconditionally)\n-    /// enabled.\n-    pub fn when_nll_is_enabled(tcx: TyCtxt<'_>) -> Self {\n-        // FIXME(Centril): Once we actually remove `::Migrate` also make\n-        // this always `true` and then proceed to eliminate the dead code.\n-        match tcx.borrowck_mode() {\n-            // If we're on Migrate mode, report AST region errors\n-            BorrowckMode::Migrate => SuppressRegionErrors { suppressed: false },\n-\n-            // If we're on MIR, don't report AST region errors as they should be reported by NLL\n-            BorrowckMode::Mir => SuppressRegionErrors { suppressed: true },\n-        }\n-    }\n-}\n-\n-pub struct InferCtxt<'a, 'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-\n-    /// During type-checking/inference of a body, `in_progress_tables`\n-    /// contains a reference to the tables being built up, which are\n-    /// used for reading closure kinds/signatures as they are inferred,\n-    /// and for error reporting logic to read arbitrary node types.\n-    pub in_progress_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n-\n-    /// Cache for projections. This cache is snapshotted along with the\n-    /// infcx.\n-    ///\n-    /// Public so that `traits::project` can use it.\n-    pub projection_cache: RefCell<traits::ProjectionCache<'tcx>>,\n-\n-    /// We instantiate `UnificationTable` with `bounds<Ty>` because the\n-    /// types that might instantiate a general type variable have an\n-    /// order, represented by its upper and lower bounds.\n-    pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n-\n-    /// If set, this flag causes us to skip the 'leak check' during\n-    /// higher-ranked subtyping operations. This flag is a temporary one used\n-    /// to manage the removal of the leak-check: for the time being, we still run the\n-    /// leak-check, but we issue warnings. This flag can only be set to true\n-    /// when entering a snapshot.\n-    skip_leak_check: Cell<bool>,\n-\n-    /// Map from const parameter variable to the kind of const it represents.\n-    const_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>>,\n-\n-    /// Map from integral variable to the kind of integer it represents.\n-    int_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::IntVid>>>,\n-\n-    /// Map from floating variable to the kind of float it represents\n-    float_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::FloatVid>>>,\n-\n-    /// Tracks the set of region variables and the constraints between\n-    /// them.  This is initially `Some(_)` but when\n-    /// `resolve_regions_and_report_errors` is invoked, this gets set\n-    /// to `None` -- further attempts to perform unification etc may\n-    /// fail if new region constraints would've been added.\n-    region_constraints: RefCell<Option<RegionConstraintCollector<'tcx>>>,\n-\n-    /// Once region inference is done, the values for each variable.\n-    lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n-\n-    /// Caches the results of trait selection. This cache is used\n-    /// for things that have to do with the parameters in scope.\n-    pub selection_cache: traits::SelectionCache<'tcx>,\n-\n-    /// Caches the results of trait evaluation.\n-    pub evaluation_cache: traits::EvaluationCache<'tcx>,\n-\n-    /// the set of predicates on which errors have been reported, to\n-    /// avoid reporting the same error twice.\n-    pub reported_trait_errors: RefCell<FxHashMap<Span, Vec<ty::Predicate<'tcx>>>>,\n-\n-    pub reported_closure_mismatch: RefCell<FxHashSet<(Span, Option<Span>)>>,\n-\n-    /// When an error occurs, we want to avoid reporting \"derived\"\n-    /// errors that are due to this original failure. Normally, we\n-    /// handle this with the `err_count_on_creation` count, which\n-    /// basically just tracks how many errors were reported when we\n-    /// started type-checking a fn and checks to see if any new errors\n-    /// have been reported since then. Not great, but it works.\n-    ///\n-    /// However, when errors originated in other passes -- notably\n-    /// resolve -- this heuristic breaks down. Therefore, we have this\n-    /// auxiliary flag that one can set whenever one creates a\n-    /// type-error that is due to an error in a prior pass.\n-    ///\n-    /// Don't read this flag directly, call `is_tainted_by_errors()`\n-    /// and `set_tainted_by_errors()`.\n-    tainted_by_errors_flag: Cell<bool>,\n-\n-    /// Track how many errors were reported when this infcx is created.\n-    /// If the number of errors increases, that's also a sign (line\n-    /// `tained_by_errors`) to avoid reporting certain kinds of errors.\n-    // FIXME(matthewjasper) Merge into `tainted_by_errors_flag`\n-    err_count_on_creation: usize,\n-\n-    /// This flag is true while there is an active snapshot.\n-    in_snapshot: Cell<bool>,\n-\n-    /// A set of constraints that regionck must validate. Each\n-    /// constraint has the form `T:'a`, meaning \"some type `T` must\n-    /// outlive the lifetime 'a\". These constraints derive from\n-    /// instantiated type parameters. So if you had a struct defined\n-    /// like\n-    ///\n-    ///     struct Foo<T:'static> { ... }\n-    ///\n-    /// then in some expression `let x = Foo { ... }` it will\n-    /// instantiate the type parameter `T` with a fresh type `$0`. At\n-    /// the same time, it will record a region obligation of\n-    /// `$0:'static`. This will get checked later by regionck. (We\n-    /// can't generally check these things right away because we have\n-    /// to wait until types are resolved.)\n-    ///\n-    /// These are stored in a map keyed to the id of the innermost\n-    /// enclosing fn body / static initializer expression. This is\n-    /// because the location where the obligation was incurred can be\n-    /// relevant with respect to which sublifetime assumptions are in\n-    /// place. The reason that we store under the fn-id, and not\n-    /// something more fine-grained, is so that it is easier for\n-    /// regionck to be sure that it has found *all* the region\n-    /// obligations (otherwise, it's easy to fail to walk to a\n-    /// particular node-id).\n-    ///\n-    /// Before running `resolve_regions_and_report_errors`, the creator\n-    /// of the inference context is expected to invoke\n-    /// `process_region_obligations` (defined in `self::region_obligations`)\n-    /// for each body-id in this map, which will process the\n-    /// obligations within. This is expected to be done 'late enough'\n-    /// that all type inference variables have been bound and so forth.\n-    pub region_obligations: RefCell<Vec<(hir::HirId, RegionObligation<'tcx>)>>,\n-\n-    /// What is the innermost universe we have created? Starts out as\n-    /// `UniverseIndex::root()` but grows from there as we enter\n-    /// universal quantifiers.\n-    ///\n-    /// N.B., at present, we exclude the universal quantifiers on the\n-    /// item we are type-checking, and just consider those names as\n-    /// part of the root universe. So this would only get incremented\n-    /// when we enter into a higher-ranked (`for<..>`) type or trait\n-    /// bound.\n-    universe: Cell<ty::UniverseIndex>,\n-}\n-\n-/// A map returned by `replace_bound_vars_with_placeholders()`\n-/// indicating the placeholder region that each late-bound region was\n-/// replaced with.\n-pub type PlaceholderMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n-\n-/// See the `error_reporting` module for more details.\n-#[derive(Clone, Debug, PartialEq, Eq, TypeFoldable)]\n-pub enum ValuePairs<'tcx> {\n-    Types(ExpectedFound<Ty<'tcx>>),\n-    Regions(ExpectedFound<ty::Region<'tcx>>),\n-    Consts(ExpectedFound<&'tcx ty::Const<'tcx>>),\n-    TraitRefs(ExpectedFound<ty::TraitRef<'tcx>>),\n-    PolyTraitRefs(ExpectedFound<ty::PolyTraitRef<'tcx>>),\n-}\n-\n-/// The trace designates the path through inference that we took to\n-/// encounter an error or subtyping constraint.\n-///\n-/// See the `error_reporting` module for more details.\n-#[derive(Clone, Debug)]\n-pub struct TypeTrace<'tcx> {\n-    cause: ObligationCause<'tcx>,\n-    values: ValuePairs<'tcx>,\n-}\n-\n-/// The origin of a `r1 <= r2` constraint.\n-///\n-/// See `error_reporting` module for more details\n-#[derive(Clone, Debug)]\n-pub enum SubregionOrigin<'tcx> {\n-    /// Arose from a subtyping relation\n-    Subtype(Box<TypeTrace<'tcx>>),\n-\n-    /// Stack-allocated closures cannot outlive innermost loop\n-    /// or function so as to ensure we only require finite stack\n-    InfStackClosure(Span),\n-\n-    /// Invocation of closure must be within its lifetime\n-    InvokeClosure(Span),\n-\n-    /// Dereference of reference must be within its lifetime\n-    DerefPointer(Span),\n-\n-    /// Closure bound must not outlive captured variables\n-    ClosureCapture(Span, hir::HirId),\n-\n-    /// Index into slice must be within its lifetime\n-    IndexSlice(Span),\n-\n-    /// When casting `&'a T` to an `&'b Trait` object,\n-    /// relating `'a` to `'b`\n-    RelateObjectBound(Span),\n-\n-    /// Some type parameter was instantiated with the given type,\n-    /// and that type must outlive some region.\n-    RelateParamBound(Span, Ty<'tcx>),\n-\n-    /// The given region parameter was instantiated with a region\n-    /// that must outlive some other region.\n-    RelateRegionParamBound(Span),\n-\n-    /// A bound placed on type parameters that states that must outlive\n-    /// the moment of their instantiation.\n-    RelateDefaultParamBound(Span, Ty<'tcx>),\n-\n-    /// Creating a pointer `b` to contents of another reference\n-    Reborrow(Span),\n-\n-    /// Creating a pointer `b` to contents of an upvar\n-    ReborrowUpvar(Span, ty::UpvarId),\n-\n-    /// Data with type `Ty<'tcx>` was borrowed\n-    DataBorrowed(Ty<'tcx>, Span),\n-\n-    /// (&'a &'b T) where a >= b\n-    ReferenceOutlivesReferent(Ty<'tcx>, Span),\n-\n-    /// Type or region parameters must be in scope.\n-    ParameterInScope(ParameterOrigin, Span),\n-\n-    /// The type T of an expression E must outlive the lifetime for E.\n-    ExprTypeIsNotInScope(Ty<'tcx>, Span),\n \n-    /// A `ref b` whose region does not enclose the decl site\n-    BindingTypeIsNotValidAtDecl(Span),\n-\n-    /// Regions appearing in a method receiver must outlive method call\n-    CallRcvr(Span),\n-\n-    /// Regions appearing in a function argument must outlive func call\n-    CallArg(Span),\n-\n-    /// Region in return type of invoked fn must enclose call\n-    CallReturn(Span),\n-\n-    /// Operands must be in scope\n-    Operand(Span),\n-\n-    /// Region resulting from a `&` expr must enclose the `&` expr\n-    AddrOf(Span),\n-\n-    /// An auto-borrow that does not enclose the expr where it occurs\n-    AutoBorrow(Span),\n-\n-    /// Region constraint arriving from destructor safety\n-    SafeDestructor(Span),\n-\n-    /// Comparing the signature and requirements of an impl method against\n-    /// the containing trait.\n-    CompareImplMethodObligation {\n-        span: Span,\n-        item_name: ast::Name,\n-        impl_item_def_id: DefId,\n-        trait_item_def_id: DefId,\n-    },\n-}\n-\n-// `SubregionOrigin` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(SubregionOrigin<'_>, 32);\n-\n-/// Places that type/region parameters can appear.\n-#[derive(Clone, Copy, Debug)]\n-pub enum ParameterOrigin {\n-    Path,               // foo::bar\n-    MethodCall,         // foo.bar() <-- parameters on impl providing bar()\n-    OverloadedOperator, // a + b when overloaded\n-    OverloadedDeref,    // *a when overloaded\n-}\n-\n-/// Times when we replace late-bound regions with variables:\n-#[derive(Clone, Copy, Debug)]\n-pub enum LateBoundRegionConversionTime {\n-    /// when a fn is called\n-    FnCall,\n-\n-    /// when two higher-ranked types are compared\n-    HigherRankedType,\n-\n-    /// when projecting an associated type\n-    AssocTypeProjection(DefId),\n-}\n-\n-/// Reasons to create a region inference variable\n+/// Requires that `region` must be equal to one of the regions in `choice_regions`.\n+/// We often denote this using the syntax:\n ///\n-/// See `error_reporting` module for more details\n-#[derive(Copy, Clone, Debug)]\n-pub enum RegionVariableOrigin {\n-    /// Region variables created for ill-categorized reasons,\n-    /// mostly indicates places in need of refactoring\n-    MiscVariable(Span),\n-\n-    /// Regions created by a `&P` or `[...]` pattern\n-    PatternRegion(Span),\n-\n-    /// Regions created by `&` operator\n-    AddrOfRegion(Span),\n-\n-    /// Regions created as part of an autoref of a method receiver\n-    Autoref(Span),\n-\n-    /// Regions created as part of an automatic coercion\n-    Coercion(Span),\n-\n-    /// Region variables created as the values for early-bound regions\n-    EarlyBoundRegion(Span, Symbol),\n-\n-    /// Region variables created for bound regions\n-    /// in a function or method that is called\n-    LateBoundRegion(Span, ty::BoundRegion, LateBoundRegionConversionTime),\n-\n-    UpvarRegion(ty::UpvarId, Span),\n-\n-    BoundRegionInCoherence(ast::Name),\n-\n-    /// This origin is used for the inference variables that we create\n-    /// during NLL region processing.\n-    NLL(NLLRegionVariableOrigin),\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum NLLRegionVariableOrigin {\n-    /// During NLL region processing, we create variables for free\n-    /// regions that we encounter in the function signature and\n-    /// elsewhere. This origin indices we've got one of those.\n-    FreeRegion,\n-\n-    /// \"Universal\" instantiation of a higher-ranked region (e.g.,\n-    /// from a `for<'a> T` binder). Meant to represent \"any region\".\n-    Placeholder(ty::PlaceholderRegion),\n-\n-    Existential {\n-        /// If this is true, then this variable was created to represent a lifetime\n-        /// bound in a `for` binder. For example, it might have been created to\n-        /// represent the lifetime `'a` in a type like `for<'a> fn(&'a u32)`.\n-        /// Such variables are created when we are trying to figure out if there\n-        /// is any valid instantiation of `'a` that could fit into some scenario.\n-        ///\n-        /// This is used to inform error reporting: in the case that we are trying to\n-        /// determine whether there is any valid instantiation of a `'a` variable that meets\n-        /// some constraint C, we want to blame the \"source\" of that `for` type,\n-        /// rather than blaming the source of the constraint C.\n-        from_forall: bool,\n-    },\n-}\n-\n-impl NLLRegionVariableOrigin {\n-    pub fn is_universal(self) -> bool {\n-        match self {\n-            NLLRegionVariableOrigin::FreeRegion => true,\n-            NLLRegionVariableOrigin::Placeholder(..) => true,\n-            NLLRegionVariableOrigin::Existential { .. } => false,\n-        }\n-    }\n-\n-    pub fn is_existential(self) -> bool {\n-        !self.is_universal()\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum FixupError<'tcx> {\n-    UnresolvedIntTy(IntVid),\n-    UnresolvedFloatTy(FloatVid),\n-    UnresolvedTy(TyVid),\n-    UnresolvedConst(ConstVid<'tcx>),\n-}\n-\n-/// See the `region_obligations` field for more information.\n-#[derive(Clone)]\n-pub struct RegionObligation<'tcx> {\n-    pub sub_region: ty::Region<'tcx>,\n-    pub sup_type: Ty<'tcx>,\n-    pub origin: SubregionOrigin<'tcx>,\n-}\n-\n-impl<'tcx> fmt::Display for FixupError<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use self::FixupError::*;\n-\n-        match *self {\n-            UnresolvedIntTy(_) => write!(\n-                f,\n-                \"cannot determine the type of this integer; \\\n-                 add a suffix to specify the type explicitly\"\n-            ),\n-            UnresolvedFloatTy(_) => write!(\n-                f,\n-                \"cannot determine the type of this number; \\\n-                 add a suffix to specify the type explicitly\"\n-            ),\n-            UnresolvedTy(_) => write!(f, \"unconstrained type\"),\n-            UnresolvedConst(_) => write!(f, \"unconstrained const value\"),\n-        }\n-    }\n-}\n-\n-/// Helper type of a temporary returned by `tcx.infer_ctxt()`.\n-/// Necessary because we can't write the following bound:\n-/// `F: for<'b, 'tcx> where 'tcx FnOnce(InferCtxt<'b, 'tcx>)`.\n-pub struct InferCtxtBuilder<'tcx> {\n-    global_tcx: TyCtxt<'tcx>,\n-    fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n-}\n-\n-impl TyCtxt<'tcx> {\n-    pub fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder { global_tcx: self, fresh_tables: None }\n-    }\n-}\n-\n-impl<'tcx> InferCtxtBuilder<'tcx> {\n-    /// Used only by `rustc_typeck` during body type-checking/inference,\n-    /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n-    pub fn with_fresh_in_progress_tables(mut self, table_owner: DefId) -> Self {\n-        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty(Some(table_owner))));\n-        self\n-    }\n-\n-    /// Given a canonical value `C` as a starting point, create an\n-    /// inference context that contains each of the bound values\n-    /// within instantiated as a fresh variable. The `f` closure is\n-    /// invoked with the new infcx, along with the instantiated value\n-    /// `V` and a substitution `S`. This substitution `S` maps from\n-    /// the bound values in `C` to their instantiated values in `V`\n-    /// (in other words, `S(C) = V`).\n-    pub fn enter_with_canonical<T, R>(\n-        &mut self,\n-        span: Span,\n-        canonical: &Canonical<'tcx, T>,\n-        f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>, T, CanonicalVarValues<'tcx>) -> R,\n-    ) -> R\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.enter(|infcx| {\n-            let (value, subst) =\n-                infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);\n-            f(infcx, value, subst)\n-        })\n-    }\n-\n-    pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n-        let InferCtxtBuilder { global_tcx, ref fresh_tables } = *self;\n-        let in_progress_tables = fresh_tables.as_ref();\n-        global_tcx.enter_local(|tcx| {\n-            f(InferCtxt {\n-                tcx,\n-                in_progress_tables,\n-                projection_cache: Default::default(),\n-                type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-                const_unification_table: RefCell::new(ut::UnificationTable::new()),\n-                int_unification_table: RefCell::new(ut::UnificationTable::new()),\n-                float_unification_table: RefCell::new(ut::UnificationTable::new()),\n-                region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n-                lexical_region_resolutions: RefCell::new(None),\n-                selection_cache: Default::default(),\n-                evaluation_cache: Default::default(),\n-                reported_trait_errors: Default::default(),\n-                reported_closure_mismatch: Default::default(),\n-                tainted_by_errors_flag: Cell::new(false),\n-                err_count_on_creation: tcx.sess.err_count(),\n-                in_snapshot: Cell::new(false),\n-                skip_leak_check: Cell::new(false),\n-                region_obligations: RefCell::new(vec![]),\n-                universe: Cell::new(ty::UniverseIndex::ROOT),\n-            })\n-        })\n-    }\n-}\n-\n-impl<'tcx, T> InferOk<'tcx, T> {\n-    pub fn unit(self) -> InferOk<'tcx, ()> {\n-        InferOk { value: (), obligations: self.obligations }\n-    }\n-\n-    /// Extracts `value`, registering any obligations into `fulfill_cx`.\n-    pub fn into_value_registering_obligations(\n-        self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        fulfill_cx: &mut dyn TraitEngine<'tcx>,\n-    ) -> T {\n-        let InferOk { value, obligations } = self;\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(infcx, obligation);\n-        }\n-        value\n-    }\n-}\n-\n-impl<'tcx> InferOk<'tcx, ()> {\n-    pub fn into_obligations(self) -> PredicateObligations<'tcx> {\n-        self.obligations\n-    }\n-}\n-\n-#[must_use = \"once you start a snapshot, you should always consume it\"]\n-pub struct CombinedSnapshot<'a, 'tcx> {\n-    projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n-    type_snapshot: type_variable::Snapshot<'tcx>,\n-    const_snapshot: ut::Snapshot<ut::InPlace<ty::ConstVid<'tcx>>>,\n-    int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n-    float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n-    region_constraints_snapshot: RegionSnapshot,\n-    region_obligations_snapshot: usize,\n-    universe: ty::UniverseIndex,\n-    was_in_snapshot: bool,\n-    was_skip_leak_check: bool,\n-    _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n-}\n-\n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn is_in_snapshot(&self) -> bool {\n-        self.in_snapshot.get()\n-    }\n-\n-    pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n-        t.fold_with(&mut self.freshener())\n-    }\n-\n-    pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> bool {\n-        match ty.kind {\n-            ty::Infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n-        freshen::TypeFreshener::new(self)\n-    }\n+/// ```\n+/// R0 member of [O1..On]\n+/// ```\n+#[derive(Debug, Clone, HashStable, TypeFoldable, Lift)]\n+pub struct MemberConstraint<'tcx> {\n+    /// The `DefId` of the opaque type causing this constraint: used for error reporting.\n+    pub opaque_type_def_id: DefId,\n \n-    pub fn type_is_unconstrained_numeric(&'a self, ty: Ty<'_>) -> UnconstrainedNumeric {\n-        use crate::ty::error::UnconstrainedNumeric::Neither;\n-        use crate::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n-        match ty.kind {\n-            ty::Infer(ty::IntVar(vid)) => {\n-                if self.int_unification_table.borrow_mut().probe_value(vid).is_some() {\n-                    Neither\n-                } else {\n-                    UnconstrainedInt\n-                }\n-            }\n-            ty::Infer(ty::FloatVar(vid)) => {\n-                if self.float_unification_table.borrow_mut().probe_value(vid).is_some() {\n-                    Neither\n-                } else {\n-                    UnconstrainedFloat\n-                }\n-            }\n-            _ => Neither,\n-        }\n-    }\n+    /// The span where the hidden type was instantiated.\n+    pub definition_span: Span,\n \n-    pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {\n-        let mut type_variables = self.type_variables.borrow_mut();\n-        let mut int_unification_table = self.int_unification_table.borrow_mut();\n-        let mut float_unification_table = self.float_unification_table.borrow_mut();\n-        // FIXME(const_generics): should there be an equivalent function for const variables?\n+    /// The hidden type in which `member_region` appears: used for error reporting.\n+    pub hidden_ty: Ty<'tcx>,\n \n-        type_variables\n-            .unsolved_variables()\n-            .into_iter()\n-            .map(|t| self.tcx.mk_ty_var(t))\n-            .chain(\n-                (0..int_unification_table.len())\n-                    .map(|i| ty::IntVid { index: i as u32 })\n-                    .filter(|&vid| int_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_int_var(v)),\n-            )\n-            .chain(\n-                (0..float_unification_table.len())\n-                    .map(|i| ty::FloatVid { index: i as u32 })\n-                    .filter(|&vid| float_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_float_var(v)),\n-            )\n-            .collect()\n-    }\n-\n-    fn combine_fields(\n-        &'a self,\n-        trace: TypeTrace<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> CombineFields<'a, 'tcx> {\n-        CombineFields {\n-            infcx: self,\n-            trace,\n-            cause: None,\n-            param_env,\n-            obligations: PredicateObligations::new(),\n-        }\n-    }\n-\n-    /// Clear the \"currently in a snapshot\" flag, invoke the closure,\n-    /// then restore the flag to its original value. This flag is a\n-    /// debugging measure designed to detect cases where we start a\n-    /// snapshot, create type variables, and register obligations\n-    /// which may involve those type variables in the fulfillment cx,\n-    /// potentially leaving \"dangling type variables\" behind.\n-    /// In such cases, an assertion will fail when attempting to\n-    /// register obligations, within a snapshot. Very useful, much\n-    /// better than grovelling through megabytes of `RUSTC_LOG` output.\n-    ///\n-    /// HOWEVER, in some cases the flag is unhelpful. In particular, we\n-    /// sometimes create a \"mini-fulfilment-cx\" in which we enroll\n-    /// obligations. As long as this fulfillment cx is fully drained\n-    /// before we return, this is not a problem, as there won't be any\n-    /// escaping obligations in the main cx. In those cases, you can\n-    /// use this function.\n-    pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R\n-    where\n-        F: FnOnce(&Self) -> R,\n-    {\n-        let flag = self.in_snapshot.get();\n-        self.in_snapshot.set(false);\n-        let result = func(self);\n-        self.in_snapshot.set(flag);\n-        result\n-    }\n-\n-    fn start_snapshot(&self) -> CombinedSnapshot<'a, 'tcx> {\n-        debug!(\"start_snapshot()\");\n-\n-        let in_snapshot = self.in_snapshot.get();\n-        self.in_snapshot.set(true);\n-\n-        CombinedSnapshot {\n-            projection_cache_snapshot: self.projection_cache.borrow_mut().snapshot(),\n-            type_snapshot: self.type_variables.borrow_mut().snapshot(),\n-            const_snapshot: self.const_unification_table.borrow_mut().snapshot(),\n-            int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n-            float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n-            region_constraints_snapshot: self.borrow_region_constraints().start_snapshot(),\n-            region_obligations_snapshot: self.region_obligations.borrow().len(),\n-            universe: self.universe(),\n-            was_in_snapshot: in_snapshot,\n-            was_skip_leak_check: self.skip_leak_check.get(),\n-            // Borrow tables \"in progress\" (i.e., during typeck)\n-            // to ban writes from within a snapshot to them.\n-            _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n-        }\n-    }\n-\n-    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n-        debug!(\"rollback_to(cause={})\", cause);\n-        let CombinedSnapshot {\n-            projection_cache_snapshot,\n-            type_snapshot,\n-            const_snapshot,\n-            int_snapshot,\n-            float_snapshot,\n-            region_constraints_snapshot,\n-            region_obligations_snapshot,\n-            universe,\n-            was_in_snapshot,\n-            was_skip_leak_check,\n-            _in_progress_tables,\n-        } = snapshot;\n-\n-        self.in_snapshot.set(was_in_snapshot);\n-        self.universe.set(universe);\n-        self.skip_leak_check.set(was_skip_leak_check);\n-\n-        self.projection_cache.borrow_mut().rollback_to(projection_cache_snapshot);\n-        self.type_variables.borrow_mut().rollback_to(type_snapshot);\n-        self.const_unification_table.borrow_mut().rollback_to(const_snapshot);\n-        self.int_unification_table.borrow_mut().rollback_to(int_snapshot);\n-        self.float_unification_table.borrow_mut().rollback_to(float_snapshot);\n-        self.region_obligations.borrow_mut().truncate(region_obligations_snapshot);\n-        self.borrow_region_constraints().rollback_to(region_constraints_snapshot);\n-    }\n-\n-    fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n-        debug!(\"commit_from()\");\n-        let CombinedSnapshot {\n-            projection_cache_snapshot,\n-            type_snapshot,\n-            const_snapshot,\n-            int_snapshot,\n-            float_snapshot,\n-            region_constraints_snapshot,\n-            region_obligations_snapshot: _,\n-            universe: _,\n-            was_in_snapshot,\n-            was_skip_leak_check,\n-            _in_progress_tables,\n-        } = snapshot;\n-\n-        self.in_snapshot.set(was_in_snapshot);\n-        self.skip_leak_check.set(was_skip_leak_check);\n-\n-        self.projection_cache.borrow_mut().commit(projection_cache_snapshot);\n-        self.type_variables.borrow_mut().commit(type_snapshot);\n-        self.const_unification_table.borrow_mut().commit(const_snapshot);\n-        self.int_unification_table.borrow_mut().commit(int_snapshot);\n-        self.float_unification_table.borrow_mut().commit(float_snapshot);\n-        self.borrow_region_constraints().commit(region_constraints_snapshot);\n-    }\n-\n-    /// Executes `f` and commit the bindings.\n-    pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n-    where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n-    {\n-        debug!(\"commit_unconditionally()\");\n-        let snapshot = self.start_snapshot();\n-        let r = f(&snapshot);\n-        self.commit_from(snapshot);\n-        r\n-    }\n-\n-    /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`.\n-    pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n-    where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n-    {\n-        debug!(\"commit_if_ok()\");\n-        let snapshot = self.start_snapshot();\n-        let r = f(&snapshot);\n-        debug!(\"commit_if_ok() -- r.is_ok() = {}\", r.is_ok());\n-        match r {\n-            Ok(_) => {\n-                self.commit_from(snapshot);\n-            }\n-            Err(_) => {\n-                self.rollback_to(\"commit_if_ok -- error\", snapshot);\n-            }\n-        }\n-        r\n-    }\n-\n-    /// Execute `f` then unroll any bindings it creates.\n-    pub fn probe<R, F>(&self, f: F) -> R\n-    where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n-    {\n-        debug!(\"probe()\");\n-        let snapshot = self.start_snapshot();\n-        let r = f(&snapshot);\n-        self.rollback_to(\"probe\", snapshot);\n-        r\n-    }\n-\n-    /// If `should_skip` is true, then execute `f` then unroll any bindings it creates.\n-    pub fn probe_maybe_skip_leak_check<R, F>(&self, should_skip: bool, f: F) -> R\n-    where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n-    {\n-        debug!(\"probe()\");\n-        let snapshot = self.start_snapshot();\n-        let skip_leak_check = should_skip || self.skip_leak_check.get();\n-        self.skip_leak_check.set(skip_leak_check);\n-        let r = f(&snapshot);\n-        self.rollback_to(\"probe\", snapshot);\n-        r\n-    }\n-\n-    /// Scan the constraints produced since `snapshot` began and returns:\n-    ///\n-    /// - `None` -- if none of them involve \"region outlives\" constraints\n-    /// - `Some(true)` -- if there are `'a: 'b` constraints where `'a` or `'b` is a placeholder\n-    /// - `Some(false)` -- if there are `'a: 'b` constraints but none involve placeholders\n-    pub fn region_constraints_added_in_snapshot(\n-        &self,\n-        snapshot: &CombinedSnapshot<'a, 'tcx>,\n-    ) -> Option<bool> {\n-        self.borrow_region_constraints()\n-            .region_constraints_added_in_snapshot(&snapshot.region_constraints_snapshot)\n-    }\n-\n-    pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n-        self.borrow_region_constraints().add_given(sub, sup);\n-    }\n-\n-    pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n-    where\n-        T: at::ToTrace<'tcx>,\n-    {\n-        let origin = &ObligationCause::dummy();\n-        self.probe(|_| {\n-            self.at(origin, param_env).sub(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n-        })\n-    }\n-\n-    pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n-    where\n-        T: at::ToTrace<'tcx>,\n-    {\n-        let origin = &ObligationCause::dummy();\n-        self.probe(|_| {\n-            self.at(origin, param_env).eq(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n-        })\n-    }\n-\n-    pub fn sub_regions(\n-        &self,\n-        origin: SubregionOrigin<'tcx>,\n-        a: ty::Region<'tcx>,\n-        b: ty::Region<'tcx>,\n-    ) {\n-        debug!(\"sub_regions({:?} <: {:?})\", a, b);\n-        self.borrow_region_constraints().make_subregion(origin, a, b);\n-    }\n-\n-    /// Require that the region `r` be equal to one of the regions in\n-    /// the set `regions`.\n-    pub fn member_constraint(\n-        &self,\n-        opaque_type_def_id: DefId,\n-        definition_span: Span,\n-        hidden_ty: Ty<'tcx>,\n-        region: ty::Region<'tcx>,\n-        in_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n-    ) {\n-        debug!(\"member_constraint({:?} <: {:?})\", region, in_regions);\n-        self.borrow_region_constraints().member_constraint(\n-            opaque_type_def_id,\n-            definition_span,\n-            hidden_ty,\n-            region,\n-            in_regions,\n-        );\n-    }\n-\n-    pub fn subtype_predicate(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        predicate: &ty::PolySubtypePredicate<'tcx>,\n-    ) -> Option<InferResult<'tcx, ()>> {\n-        // Subtle: it's ok to skip the binder here and resolve because\n-        // `shallow_resolve` just ignores anything that is not a type\n-        // variable, and because type variable's can't (at present, at\n-        // least) capture any of the things bound by this binder.\n-        //\n-        // NOTE(nmatsakis): really, there is no *particular* reason to do this\n-        // `shallow_resolve` here except as a micro-optimization.\n-        // Naturally I could not resist.\n-        let two_unbound_type_vars = {\n-            let a = self.shallow_resolve(predicate.skip_binder().a);\n-            let b = self.shallow_resolve(predicate.skip_binder().b);\n-            a.is_ty_var() && b.is_ty_var()\n-        };\n-\n-        if two_unbound_type_vars {\n-            // Two unbound type variables? Can't make progress.\n-            return None;\n-        }\n-\n-        Some(self.commit_if_ok(|snapshot| {\n-            let (ty::SubtypePredicate { a_is_expected, a, b }, placeholder_map) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n-\n-            let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n-\n-            self.leak_check(false, &placeholder_map, snapshot)?;\n-\n-            Ok(ok.unit())\n-        }))\n-    }\n-\n-    pub fn region_outlives_predicate(\n-        &self,\n-        cause: &traits::ObligationCause<'tcx>,\n-        predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n-    ) -> UnitResult<'tcx> {\n-        self.commit_if_ok(|snapshot| {\n-            let (ty::OutlivesPredicate(r_a, r_b), placeholder_map) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n-            let origin = SubregionOrigin::from_obligation_cause(cause, || {\n-                RelateRegionParamBound(cause.span)\n-            });\n-            self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, &placeholder_map, snapshot)?;\n-            Ok(())\n-        })\n-    }\n-\n-    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n-        self.type_variables.borrow_mut().new_var(self.universe(), diverging, origin)\n-    }\n-\n-    pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_ty_var(self.next_ty_var_id(false, origin))\n-    }\n-\n-    pub fn next_ty_var_in_universe(\n-        &self,\n-        origin: TypeVariableOrigin,\n-        universe: ty::UniverseIndex,\n-    ) -> Ty<'tcx> {\n-        let vid = self.type_variables.borrow_mut().new_var(universe, false, origin);\n-        self.tcx.mk_ty_var(vid)\n-    }\n-\n-    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_ty_var(self.next_ty_var_id(true, origin))\n-    }\n-\n-    pub fn next_const_var(\n-        &self,\n-        ty: Ty<'tcx>,\n-        origin: ConstVariableOrigin,\n-    ) -> &'tcx ty::Const<'tcx> {\n-        self.tcx.mk_const_var(self.next_const_var_id(origin), ty)\n-    }\n-\n-    pub fn next_const_var_in_universe(\n-        &self,\n-        ty: Ty<'tcx>,\n-        origin: ConstVariableOrigin,\n-        universe: ty::UniverseIndex,\n-    ) -> &'tcx ty::Const<'tcx> {\n-        let vid = self\n-            .const_unification_table\n-            .borrow_mut()\n-            .new_key(ConstVarValue { origin, val: ConstVariableValue::Unknown { universe } });\n-        self.tcx.mk_const_var(vid, ty)\n-    }\n-\n-    pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {\n-        self.const_unification_table.borrow_mut().new_key(ConstVarValue {\n-            origin,\n-            val: ConstVariableValue::Unknown { universe: self.universe() },\n-        })\n-    }\n-\n-    fn next_int_var_id(&self) -> IntVid {\n-        self.int_unification_table.borrow_mut().new_key(None)\n-    }\n-\n-    pub fn next_int_var(&self) -> Ty<'tcx> {\n-        self.tcx.mk_int_var(self.next_int_var_id())\n-    }\n-\n-    fn next_float_var_id(&self) -> FloatVid {\n-        self.float_unification_table.borrow_mut().new_key(None)\n-    }\n-\n-    pub fn next_float_var(&self) -> Ty<'tcx> {\n-        self.tcx.mk_float_var(self.next_float_var_id())\n-    }\n-\n-    /// Creates a fresh region variable with the next available index.\n-    /// The variable will be created in the maximum universe created\n-    /// thus far, allowing it to name any region created thus far.\n-    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region<'tcx> {\n-        self.next_region_var_in_universe(origin, self.universe())\n-    }\n-\n-    /// Creates a fresh region variable with the next available index\n-    /// in the given universe; typically, you can use\n-    /// `next_region_var` and just use the maximal universe.\n-    pub fn next_region_var_in_universe(\n-        &self,\n-        origin: RegionVariableOrigin,\n-        universe: ty::UniverseIndex,\n-    ) -> ty::Region<'tcx> {\n-        let region_var = self.borrow_region_constraints().new_region_var(universe, origin);\n-        self.tcx.mk_region(ty::ReVar(region_var))\n-    }\n-\n-    /// Return the universe that the region `r` was created in.  For\n-    /// most regions (e.g., `'static`, named regions from the user,\n-    /// etc) this is the root universe U0. For inference variables or\n-    /// placeholders, however, it will return the universe which which\n-    /// they are associated.\n-    fn universe_of_region(&self, r: ty::Region<'tcx>) -> ty::UniverseIndex {\n-        self.borrow_region_constraints().universe(r)\n-    }\n-\n-    /// Number of region variables created so far.\n-    pub fn num_region_vars(&self) -> usize {\n-        self.borrow_region_constraints().num_region_vars()\n-    }\n-\n-    /// Just a convenient wrapper of `next_region_var` for using during NLL.\n-    pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin) -> ty::Region<'tcx> {\n-        self.next_region_var(RegionVariableOrigin::NLL(origin))\n-    }\n-\n-    /// Just a convenient wrapper of `next_region_var` for using during NLL.\n-    pub fn next_nll_region_var_in_universe(\n-        &self,\n-        origin: NLLRegionVariableOrigin,\n-        universe: ty::UniverseIndex,\n-    ) -> ty::Region<'tcx> {\n-        self.next_region_var_in_universe(RegionVariableOrigin::NLL(origin), universe)\n-    }\n-\n-    pub fn var_for_def(&self, span: Span, param: &ty::GenericParamDef) -> GenericArg<'tcx> {\n-        match param.kind {\n-            GenericParamDefKind::Lifetime => {\n-                // Create a region inference variable for the given\n-                // region parameter definition.\n-                self.next_region_var(EarlyBoundRegion(span, param.name)).into()\n-            }\n-            GenericParamDefKind::Type { .. } => {\n-                // Create a type inference variable for the given\n-                // type parameter definition. The substitutions are\n-                // for actual parameters that may be referred to by\n-                // the default of this type parameter, if it exists.\n-                // e.g., `struct Foo<A, B, C = (A, B)>(...);` when\n-                // used in a path such as `Foo::<T, U>::new()` will\n-                // use an inference variable for `C` with `[T, U]`\n-                // as the substitutions for the default, `(T, U)`.\n-                let ty_var_id = self.type_variables.borrow_mut().new_var(\n-                    self.universe(),\n-                    false,\n-                    TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeParameterDefinition(\n-                            param.name,\n-                            Some(param.def_id),\n-                        ),\n-                        span,\n-                    },\n-                );\n-\n-                self.tcx.mk_ty_var(ty_var_id).into()\n-            }\n-            GenericParamDefKind::Const { .. } => {\n-                let origin = ConstVariableOrigin {\n-                    kind: ConstVariableOriginKind::ConstParameterDefinition(param.name),\n-                    span,\n-                };\n-                let const_var_id =\n-                    self.const_unification_table.borrow_mut().new_key(ConstVarValue {\n-                        origin,\n-                        val: ConstVariableValue::Unknown { universe: self.universe() },\n-                    });\n-                self.tcx.mk_const_var(const_var_id, self.tcx.type_of(param.def_id)).into()\n-            }\n-        }\n-    }\n-\n-    /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n-    /// type/region parameter to a fresh inference variable.\n-    pub fn fresh_substs_for_item(&self, span: Span, def_id: DefId) -> SubstsRef<'tcx> {\n-        InternalSubsts::for_item(self.tcx, def_id, |param, _| self.var_for_def(span, param))\n-    }\n-\n-    /// Returns `true` if errors have been reported since this infcx was\n-    /// created. This is sometimes used as a heuristic to skip\n-    /// reporting errors that often occur as a result of earlier\n-    /// errors, but where it's hard to be 100% sure (e.g., unresolved\n-    /// inference variables, regionck errors).\n-    pub fn is_tainted_by_errors(&self) -> bool {\n-        debug!(\n-            \"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n-             tainted_by_errors_flag={})\",\n-            self.tcx.sess.err_count(),\n-            self.err_count_on_creation,\n-            self.tainted_by_errors_flag.get()\n-        );\n-\n-        if self.tcx.sess.err_count() > self.err_count_on_creation {\n-            return true; // errors reported since this infcx was made\n-        }\n-        self.tainted_by_errors_flag.get()\n-    }\n-\n-    /// Set the \"tainted by errors\" flag to true. We call this when we\n-    /// observe an error from a prior pass.\n-    pub fn set_tainted_by_errors(&self) {\n-        debug!(\"set_tainted_by_errors()\");\n-        self.tainted_by_errors_flag.set(true)\n-    }\n-\n-    /// Process the region constraints and report any errors that\n-    /// result. After this, no more unification operations should be\n-    /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    pub fn resolve_regions_and_report_errors(\n-        &self,\n-        region_context: DefId,\n-        region_map: &region::ScopeTree,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-        suppress: SuppressRegionErrors,\n-    ) {\n-        assert!(\n-            self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n-            \"region_obligations not empty: {:#?}\",\n-            self.region_obligations.borrow()\n-        );\n-\n-        let region_rels = &RegionRelations::new(\n-            self.tcx,\n-            region_context,\n-            region_map,\n-            outlives_env.free_region_map(),\n-        );\n-        let (var_infos, data) = self\n-            .region_constraints\n-            .borrow_mut()\n-            .take()\n-            .expect(\"regions already resolved\")\n-            .into_infos_and_data();\n-        let (lexical_region_resolutions, errors) =\n-            lexical_region_resolve::resolve(region_rels, var_infos, data);\n-\n-        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n-        assert!(old_value.is_none());\n-\n-        if !self.is_tainted_by_errors() {\n-            // As a heuristic, just skip reporting region errors\n-            // altogether if other errors have been reported while\n-            // this infcx was in use.  This is totally hokey but\n-            // otherwise we have a hard time separating legit region\n-            // errors from silly ones.\n-            self.report_region_errors(region_map, &errors, suppress);\n-        }\n-    }\n-\n-    /// Obtains (and clears) the current set of region\n-    /// constraints. The inference context is still usable: further\n-    /// unifications will simply add new constraints.\n-    ///\n-    /// This method is not meant to be used with normal lexical region\n-    /// resolution. Rather, it is used in the NLL mode as a kind of\n-    /// interim hack: basically we run normal type-check and generate\n-    /// region constraints as normal, but then we take them and\n-    /// translate them into the form that the NLL solver\n-    /// understands. See the NLL module for mode details.\n-    pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n-        assert!(\n-            self.region_obligations.borrow().is_empty(),\n-            \"region_obligations not empty: {:#?}\",\n-            self.region_obligations.borrow()\n-        );\n-\n-        self.borrow_region_constraints().take_and_reset_data()\n-    }\n-\n-    /// Gives temporary access to the region constraint data.\n-    #[allow(non_camel_case_types)] // bug with impl trait\n-    pub fn with_region_constraints<R>(\n-        &self,\n-        op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n-    ) -> R {\n-        let region_constraints = self.borrow_region_constraints();\n-        op(region_constraints.data())\n-    }\n-\n-    /// Takes ownership of the list of variable regions. This implies\n-    /// that all the region constraints have already been taken, and\n-    /// hence that `resolve_regions_and_report_errors` can never be\n-    /// called. This is used only during NLL processing to \"hand off\" ownership\n-    /// of the set of region variables into the NLL region context.\n-    pub fn take_region_var_origins(&self) -> VarInfos {\n-        let (var_infos, data) = self\n-            .region_constraints\n-            .borrow_mut()\n-            .take()\n-            .expect(\"regions already resolved\")\n-            .into_infos_and_data();\n-        assert!(data.is_empty());\n-        var_infos\n-    }\n-\n-    pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        self.resolve_vars_if_possible(&t).to_string()\n-    }\n-\n-    pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n-        let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_string(*t)).collect();\n-        format!(\"({})\", tstrs.join(\", \"))\n-    }\n-\n-    pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n-        self.resolve_vars_if_possible(t).print_only_trait_path().to_string()\n-    }\n-\n-    /// If `TyVar(vid)` resolves to a type, return that type. Else, return the\n-    /// universe index of `TyVar(vid)`.\n-    pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n-        use self::type_variable::TypeVariableValue;\n-\n-        match self.type_variables.borrow_mut().probe(vid) {\n-            TypeVariableValue::Known { value } => Ok(value),\n-            TypeVariableValue::Unknown { universe } => Err(universe),\n-        }\n-    }\n-\n-    /// Resolve any type variables found in `value` -- but only one\n-    /// level.  So, if the variable `?X` is bound to some type\n-    /// `Foo<?Y>`, then this would return `Foo<?Y>` (but `?Y` may\n-    /// itself be bound to a type).\n-    ///\n-    /// Useful when you only need to inspect the outermost level of\n-    /// the type and don't care about nested types (or perhaps you\n-    /// will be resolving them as well, e.g. in a loop).\n-    pub fn shallow_resolve<T>(&self, value: T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let mut r = ShallowResolver::new(self);\n-        value.fold_with(&mut r)\n-    }\n-\n-    pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n-        self.type_variables.borrow_mut().root_var(var)\n-    }\n-\n-    /// Where possible, replaces type/const variables in\n-    /// `value` with their final value. Note that region variables\n-    /// are unaffected. If a type/const variable has not been unified, it\n-    /// is left as is. This is an idempotent operation that does\n-    /// not affect inference state in any way and so you can do it\n-    /// at will.\n-    pub fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        if !value.needs_infer() {\n-            return value.clone(); // Avoid duplicated subst-folding.\n-        }\n-        let mut r = resolve::OpportunisticVarResolver::new(self);\n-        value.fold_with(&mut r)\n-    }\n-\n-    /// Returns the first unresolved variable contained in `T`. In the\n-    /// process of visiting `T`, this will resolve (where possible)\n-    /// type variables in `T`, but it never constructs the final,\n-    /// resolved type, so it's more efficient than\n-    /// `resolve_vars_if_possible()`.\n-    pub fn unresolved_type_vars<T>(&self, value: &T) -> Option<(Ty<'tcx>, Option<Span>)>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let mut r = resolve::UnresolvedTypeFinder::new(self);\n-        value.visit_with(&mut r);\n-        r.first_unresolved\n-    }\n-\n-    pub fn probe_const_var(\n-        &self,\n-        vid: ty::ConstVid<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, ty::UniverseIndex> {\n-        match self.const_unification_table.borrow_mut().probe_value(vid).val {\n-            ConstVariableValue::Known { value } => Ok(value),\n-            ConstVariableValue::Unknown { universe } => Err(universe),\n-        }\n-    }\n-\n-    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<'tcx, T> {\n-        /*!\n-         * Attempts to resolve all type/region/const variables in\n-         * `value`. Region inference must have been run already (e.g.,\n-         * by calling `resolve_regions_and_report_errors`). If some\n-         * variable was never unified, an `Err` results.\n-         *\n-         * This method is idempotent, but it not typically not invoked\n-         * except during the writeback phase.\n-         */\n-\n-        resolve::fully_resolve(self, value)\n-    }\n-\n-    // [Note-Type-error-reporting]\n-    // An invariant is that anytime the expected or actual type is Error (the special\n-    // error type, meaning that an error occurred when typechecking this expression),\n-    // this is a derived error. The error cascaded from another error (that was already\n-    // reported), so it's not useful to display it to the user.\n-    // The following methods implement this logic.\n-    // They check if either the actual or expected type is Error, and don't print the error\n-    // in this case. The typechecker should only ever report type errors involving mismatched\n-    // types using one of these methods, and should not call span_err directly for such\n-    // errors.\n-\n-    pub fn type_error_struct_with_diag<M>(\n-        &self,\n-        sp: Span,\n-        mk_diag: M,\n-        actual_ty: Ty<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx>\n-    where\n-        M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n-    {\n-        let actual_ty = self.resolve_vars_if_possible(&actual_ty);\n-        debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n-\n-        // Don't report an error if actual type is `Error`.\n-        if actual_ty.references_error() {\n-            return self.tcx.sess.diagnostic().struct_dummy();\n-        }\n-\n-        mk_diag(self.ty_to_string(actual_ty))\n-    }\n-\n-    pub fn report_mismatched_types(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        expected: Ty<'tcx>,\n-        actual: Ty<'tcx>,\n-        err: TypeError<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        let trace = TypeTrace::types(cause, true, expected, actual);\n-        self.report_and_explain_type_error(trace, &err)\n-    }\n-\n-    pub fn replace_bound_vars_with_fresh_vars<T>(\n-        &self,\n-        span: Span,\n-        lbrct: LateBoundRegionConversionTime,\n-        value: &ty::Binder<T>,\n-    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let fld_r = |br| self.next_region_var(LateBoundRegion(span, br, lbrct));\n-        let fld_t = |_| {\n-            self.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::MiscVariable,\n-                span,\n-            })\n-        };\n-        let fld_c = |_, ty| {\n-            self.next_const_var(\n-                ty,\n-                ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span },\n-            )\n-        };\n-        self.tcx.replace_bound_vars(value, fld_r, fld_t, fld_c)\n-    }\n-\n-    /// See the [`region_constraints::verify_generic_bound`] method.\n-    pub fn verify_generic_bound(\n-        &self,\n-        origin: SubregionOrigin<'tcx>,\n-        kind: GenericKind<'tcx>,\n-        a: ty::Region<'tcx>,\n-        bound: VerifyBound<'tcx>,\n-    ) {\n-        debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\", kind, a, bound);\n-\n-        self.borrow_region_constraints().verify_generic_bound(origin, kind, a, bound);\n-    }\n-\n-    pub fn type_is_copy_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool {\n-        let ty = self.resolve_vars_if_possible(&ty);\n-\n-        // Even if the type may have no inference variables, during\n-        // type-checking closure types are in local tables only.\n-        if !self.in_progress_tables.is_some() || !ty.has_closure_types() {\n-            if !(param_env, ty).has_local_value() {\n-                return ty.is_copy_modulo_regions(self.tcx, param_env, span);\n-            }\n-        }\n-\n-        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n-\n-        // This can get called from typeck (by euv), and `moves_by_default`\n-        // rightly refuses to work with inference variables, but\n-        // moves_by_default has a cache, which we want to use in other\n-        // cases.\n-        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id, span)\n-    }\n-\n-    /// Obtains the latest type of the given closure; this may be a\n-    /// closure in the current function, in which case its\n-    /// `ClosureKind` may not yet be known.\n-    pub fn closure_kind(\n-        &self,\n-        closure_def_id: DefId,\n-        closure_substs: SubstsRef<'tcx>,\n-    ) -> Option<ty::ClosureKind> {\n-        let closure_kind_ty = closure_substs.as_closure().kind_ty(closure_def_id, self.tcx);\n-        let closure_kind_ty = self.shallow_resolve(closure_kind_ty);\n-        closure_kind_ty.to_opt_closure_kind()\n-    }\n-\n-    /// Obtains the signature of a closure. For closures, unlike\n-    /// `tcx.fn_sig(def_id)`, this method will work during the\n-    /// type-checking of the enclosing function and return the closure\n-    /// signature in its partially inferred state.\n-    pub fn closure_sig(&self, def_id: DefId, substs: SubstsRef<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let closure_sig_ty = substs.as_closure().sig_ty(def_id, self.tcx);\n-        let closure_sig_ty = self.shallow_resolve(closure_sig_ty);\n-        closure_sig_ty.fn_sig(self.tcx)\n-    }\n-\n-    /// Normalizes associated types in `value`, potentially returning\n-    /// new obligations that must further be processed.\n-    pub fn partially_normalize_associated_types_in<T>(\n-        &self,\n-        span: Span,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n-    ) -> InferOk<'tcx, T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n-        let mut selcx = traits::SelectionContext::new(self);\n-        let cause = ObligationCause::misc(span, body_id);\n-        let traits::Normalized { value, obligations } =\n-            traits::normalize(&mut selcx, param_env, cause, value);\n-        debug!(\n-            \"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n-            value, obligations\n-        );\n-        InferOk { value, obligations }\n-    }\n-\n-    pub fn borrow_region_constraints(&self) -> RefMut<'_, RegionConstraintCollector<'tcx>> {\n-        RefMut::map(self.region_constraints.borrow_mut(), |c| {\n-            c.as_mut().expect(\"region constraints already solved\")\n-        })\n-    }\n-\n-    /// Clears the selection, evaluation, and projection caches. This is useful when\n-    /// repeatedly attempting to select an `Obligation` while changing only\n-    /// its `ParamEnv`, since `FulfillmentContext` doesn't use probing.\n-    pub fn clear_caches(&self) {\n-        self.selection_cache.clear();\n-        self.evaluation_cache.clear();\n-        self.projection_cache.borrow_mut().clear();\n-    }\n-\n-    fn universe(&self) -> ty::UniverseIndex {\n-        self.universe.get()\n-    }\n-\n-    /// Creates and return a fresh universe that extends all previous\n-    /// universes. Updates `self.universe` to that new universe.\n-    pub fn create_next_universe(&self) -> ty::UniverseIndex {\n-        let u = self.universe.get().next_universe();\n-        self.universe.set(u);\n-        u\n-    }\n-}\n-\n-pub struct ShallowResolver<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n-    #[inline(always)]\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n-        ShallowResolver { infcx }\n-    }\n-\n-    /// If `typ` is a type variable of some kind, resolve it one level\n-    /// (but do not resolve types found in the result). If `typ` is\n-    /// not a type variable, just return it unmodified.\n-    pub fn shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match typ.kind {\n-            ty::Infer(ty::TyVar(v)) => {\n-                // Not entirely obvious: if `typ` is a type variable,\n-                // it can be resolved to an int/float variable, which\n-                // can then be recursively resolved, hence the\n-                // recursion. Note though that we prevent type\n-                // variables from unifying to other type variables\n-                // directly (though they may be embedded\n-                // structurally), and we prevent cycles in any case,\n-                // so this recursion should always be of very limited\n-                // depth.\n-                self.infcx\n-                    .type_variables\n-                    .borrow_mut()\n-                    .probe(v)\n-                    .known()\n-                    .map(|t| self.fold_ty(t))\n-                    .unwrap_or(typ)\n-            }\n-\n-            ty::Infer(ty::IntVar(v)) => self\n-                .infcx\n-                .int_unification_table\n-                .borrow_mut()\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.infcx.tcx))\n-                .unwrap_or(typ),\n-\n-            ty::Infer(ty::FloatVar(v)) => self\n-                .infcx\n-                .float_unification_table\n-                .borrow_mut()\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.infcx.tcx))\n-                .unwrap_or(typ),\n-\n-            _ => typ,\n-        }\n-    }\n-\n-    // `resolver.shallow_resolve_changed(ty)` is equivalent to\n-    // `resolver.shallow_resolve(ty) != ty`, but more efficient. It's always\n-    // inlined, despite being large, because it has only two call sites that\n-    // are extremely hot.\n-    #[inline(always)]\n-    pub fn shallow_resolve_changed(&self, infer: ty::InferTy) -> bool {\n-        match infer {\n-            ty::TyVar(v) => {\n-                use self::type_variable::TypeVariableValue;\n-\n-                // If `inlined_probe` returns a `Known` value its `kind` never\n-                // matches `infer`.\n-                match self.infcx.type_variables.borrow_mut().inlined_probe(v) {\n-                    TypeVariableValue::Unknown { .. } => false,\n-                    TypeVariableValue::Known { .. } => true,\n-                }\n-            }\n-\n-            ty::IntVar(v) => {\n-                // If inlined_probe_value returns a value it's always a\n-                // `ty::Int(_)` or `ty::UInt(_)`, which nevers matches a\n-                // `ty::Infer(_)`.\n-                self.infcx.int_unification_table.borrow_mut().inlined_probe_value(v).is_some()\n-            }\n-\n-            ty::FloatVar(v) => {\n-                // If inlined_probe_value returns a value it's always a\n-                // `ty::Float(_)`, which nevers matches a `ty::Infer(_)`.\n-                //\n-                // Not `inlined_probe_value(v)` because this call site is colder.\n-                self.infcx.float_unification_table.borrow_mut().probe_value(v).is_some()\n-            }\n-\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.shallow_resolve(ty)\n-    }\n-\n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n-            self.infcx\n-                .const_unification_table\n-                .borrow_mut()\n-                .probe_value(*vid)\n-                .val\n-                .known()\n-                .unwrap_or(ct)\n-        } else {\n-            ct\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeTrace<'tcx> {\n-    pub fn span(&self) -> Span {\n-        self.cause.span\n-    }\n-\n-    pub fn types(\n-        cause: &ObligationCause<'tcx>,\n-        a_is_expected: bool,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-    ) -> TypeTrace<'tcx> {\n-        TypeTrace { cause: cause.clone(), values: Types(ExpectedFound::new(a_is_expected, a, b)) }\n-    }\n-\n-    pub fn dummy(tcx: TyCtxt<'tcx>) -> TypeTrace<'tcx> {\n-        TypeTrace {\n-            cause: ObligationCause::dummy(),\n-            values: Types(ExpectedFound { expected: tcx.types.err, found: tcx.types.err }),\n-        }\n-    }\n-}\n-\n-impl<'tcx> SubregionOrigin<'tcx> {\n-    pub fn span(&self) -> Span {\n-        match *self {\n-            Subtype(ref a) => a.span(),\n-            InfStackClosure(a) => a,\n-            InvokeClosure(a) => a,\n-            DerefPointer(a) => a,\n-            ClosureCapture(a, _) => a,\n-            IndexSlice(a) => a,\n-            RelateObjectBound(a) => a,\n-            RelateParamBound(a, _) => a,\n-            RelateRegionParamBound(a) => a,\n-            RelateDefaultParamBound(a, _) => a,\n-            Reborrow(a) => a,\n-            ReborrowUpvar(a, _) => a,\n-            DataBorrowed(_, a) => a,\n-            ReferenceOutlivesReferent(_, a) => a,\n-            ParameterInScope(_, a) => a,\n-            ExprTypeIsNotInScope(_, a) => a,\n-            BindingTypeIsNotValidAtDecl(a) => a,\n-            CallRcvr(a) => a,\n-            CallArg(a) => a,\n-            CallReturn(a) => a,\n-            Operand(a) => a,\n-            AddrOf(a) => a,\n-            AutoBorrow(a) => a,\n-            SafeDestructor(a) => a,\n-            CompareImplMethodObligation { span, .. } => span,\n-        }\n-    }\n-\n-    pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>, default: F) -> Self\n-    where\n-        F: FnOnce() -> Self,\n-    {\n-        match cause.code {\n-            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) => {\n-                SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span)\n-            }\n-\n-            traits::ObligationCauseCode::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            } => SubregionOrigin::CompareImplMethodObligation {\n-                span: cause.span,\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            },\n-\n-            _ => default(),\n-        }\n-    }\n-}\n-\n-impl RegionVariableOrigin {\n-    pub fn span(&self) -> Span {\n-        match *self {\n-            MiscVariable(a) => a,\n-            PatternRegion(a) => a,\n-            AddrOfRegion(a) => a,\n-            Autoref(a) => a,\n-            Coercion(a) => a,\n-            EarlyBoundRegion(a, ..) => a,\n-            LateBoundRegion(a, ..) => a,\n-            BoundRegionInCoherence(_) => rustc_span::DUMMY_SP,\n-            UpvarRegion(_, a) => a,\n-            NLL(..) => bug!(\"NLL variable used with `span`\"),\n-        }\n-    }\n-}\n+    /// The region `R0`.\n+    pub member_region: Region<'tcx>,\n \n-impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n-            self.sub_region, self.sup_type\n-        )\n-    }\n+    /// The options `O1..On`.\n+    pub choice_regions: Lrc<Vec<Region<'tcx>>>,\n }"}, {"sha": "534f4cb179c4f78eb7d2e5f183b55343e69fc74e", "filename": "src/librustc/infer/types/mod.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs?ref=e7a344fb745a0a663e21be947b2619df05df6d31", "patch": "@@ -1,31 +0,0 @@\n-pub mod canonical;\n-\n-use crate::ty::Region;\n-use crate::ty::Ty;\n-use rustc_data_structures::sync::Lrc;\n-use rustc_hir::def_id::DefId;\n-use rustc_span::Span;\n-\n-/// Requires that `region` must be equal to one of the regions in `choice_regions`.\n-/// We often denote this using the syntax:\n-///\n-/// ```\n-/// R0 member of [O1..On]\n-/// ```\n-#[derive(Debug, Clone, HashStable, TypeFoldable, Lift)]\n-pub struct MemberConstraint<'tcx> {\n-    /// The `DefId` of the opaque type causing this constraint: used for error reporting.\n-    pub opaque_type_def_id: DefId,\n-\n-    /// The span where the hidden type was instantiated.\n-    pub definition_span: Span,\n-\n-    /// The hidden type in which `member_region` appears: used for error reporting.\n-    pub hidden_ty: Ty<'tcx>,\n-\n-    /// The region `R0`.\n-    pub member_region: Region<'tcx>,\n-\n-    /// The options `O1..On`.\n-    pub choice_regions: Lrc<Vec<Region<'tcx>>>,\n-}"}, {"sha": "e205453a48c535176a9cec03853151f2c41d9127", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -4,7 +4,6 @@ use rustc_data_structures::unify::{EqUnifyValue, NoError, UnificationTable, Unif\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n \n-use std::cell::RefMut;\n use std::cmp;\n use std::marker::PhantomData;\n \n@@ -214,7 +213,7 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n impl<'tcx> EqUnifyValue for &'tcx ty::Const<'tcx> {}\n \n pub fn replace_if_possible(\n-    mut table: RefMut<'_, UnificationTable<InPlace<ty::ConstVid<'tcx>>>>,\n+    table: &mut UnificationTable<InPlace<ty::ConstVid<'tcx>>>,\n     c: &'tcx ty::Const<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n     if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = c {"}, {"sha": "055d70effc6e6886257703e4e0b2f330ba2bd61b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -13,10 +13,6 @@\n //!   defined in the `ty` module. This includes the **type context**\n //!   (or `tcx`), which is the central context during most of\n //!   compilation, containing the interners and other things.\n-//! - **Traits.** Trait resolution is implemented in the `traits` module.\n-//! - **Type inference.** The type inference code can be found in the `infer` module;\n-//!   this code handles low-level equality and subtyping operations. The\n-//!   type check pass in the compiler is found in the `librustc_typeck` crate.\n //!\n //! For more information about how rustc works, see the [rustc guide].\n //!\n@@ -27,7 +23,6 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![feature(arbitrary_self_types)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n@@ -39,24 +34,19 @@\n #![feature(marker_trait_attr)]\n #![feature(extern_types)]\n #![feature(nll)]\n-#![feature(optin_builtin_traits)]\n #![feature(option_expect_none)]\n #![feature(range_is_empty)]\n #![feature(specialization)]\n-#![feature(unboxed_closures)]\n-#![feature(thread_local)]\n-#![feature(trace_macros)]\n #![feature(trusted_len)]\n #![feature(vec_remove_item)]\n #![feature(stmt_expr_attributes)]\n-#![feature(integer_atomics)]\n #![feature(test)]\n #![feature(in_band_lifetimes)]\n #![feature(crate_visibility_modifier)]\n-#![feature(log_syntax)]\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n #![feature(hash_raw_entry)]\n+#![feature(int_error_matching)]\n #![recursion_limit = \"512\"]\n \n #[macro_use]"}, {"sha": "004835b230ab44e3260494aaa3c9611a34b28827", "filename": "src/librustc/lint.rs", "status": "modified", "additions": 138, "deletions": 106, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -174,132 +174,164 @@ impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n     }\n }\n \n-pub fn struct_lint_level<'a>(\n-    sess: &'a Session,\n+pub struct LintDiagnosticBuilder<'a>(DiagnosticBuilder<'a>);\n+\n+impl<'a> LintDiagnosticBuilder<'a> {\n+    /// Return the inner DiagnosticBuilder, first setting the primary message to `msg`.\n+    pub fn build(mut self, msg: &str) -> DiagnosticBuilder<'a> {\n+        self.0.set_primary_message(msg);\n+        self.0\n+    }\n+\n+    /// Create a LintDiagnosticBuilder from some existing DiagnosticBuilder.\n+    pub fn new(err: DiagnosticBuilder<'a>) -> LintDiagnosticBuilder<'a> {\n+        LintDiagnosticBuilder(err)\n+    }\n+}\n+\n+pub fn struct_lint_level<'s, 'd>(\n+    sess: &'s Session,\n     lint: &'static Lint,\n     level: Level,\n     src: LintSource,\n     span: Option<MultiSpan>,\n-    msg: &str,\n-) -> DiagnosticBuilder<'a> {\n-    let mut err = match (level, span) {\n-        (Level::Allow, _) => return sess.diagnostic().struct_dummy(),\n-        (Level::Warn, Some(span)) => sess.struct_span_warn(span, msg),\n-        (Level::Warn, None) => sess.struct_warn(msg),\n-        (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => sess.struct_span_err(span, msg),\n-        (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(msg),\n-    };\n+    decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>) + 'd,\n+) {\n+    // Avoid codegen bloat from monomorphization by immediately doing dyn dispatch of `decorate` to\n+    // the \"real\" work.\n+    fn struct_lint_level_impl(\n+        sess: &'s Session,\n+        lint: &'static Lint,\n+        level: Level,\n+        src: LintSource,\n+        span: Option<MultiSpan>,\n+        decorate: Box<dyn for<'b> FnOnce(LintDiagnosticBuilder<'b>) + 'd>,\n+    ) {\n+        let mut err = match (level, span) {\n+            (Level::Allow, _) => {\n+                return;\n+            }\n+            (Level::Warn, Some(span)) => sess.struct_span_warn(span, \"\"),\n+            (Level::Warn, None) => sess.struct_warn(\"\"),\n+            (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => {\n+                sess.struct_span_err(span, \"\")\n+            }\n+            (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(\"\"),\n+        };\n \n-    // Check for future incompatibility lints and issue a stronger warning.\n-    let lint_id = LintId::of(lint);\n-    let future_incompatible = lint.future_incompatible;\n-\n-    // If this code originates in a foreign macro, aka something that this crate\n-    // did not itself author, then it's likely that there's nothing this crate\n-    // can do about it. We probably want to skip the lint entirely.\n-    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n-        // Any suggestions made here are likely to be incorrect, so anything we\n-        // emit shouldn't be automatically fixed by rustfix.\n-        err.allow_suggestions(false);\n-\n-        // If this is a future incompatible lint it'll become a hard error, so\n-        // we have to emit *something*. Also allow lints to whitelist themselves\n-        // on a case-by-case basis for emission in a foreign macro.\n-        if future_incompatible.is_none() && !lint.report_in_external_macro {\n-            err.cancel();\n-            // Don't continue further, since we don't want to have\n-            // `diag_span_note_once` called for a diagnostic that isn't emitted.\n-            return err;\n+        // Check for future incompatibility lints and issue a stronger warning.\n+        let lint_id = LintId::of(lint);\n+        let future_incompatible = lint.future_incompatible;\n+\n+        // If this code originates in a foreign macro, aka something that this crate\n+        // did not itself author, then it's likely that there's nothing this crate\n+        // can do about it. We probably want to skip the lint entirely.\n+        if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n+            // Any suggestions made here are likely to be incorrect, so anything we\n+            // emit shouldn't be automatically fixed by rustfix.\n+            err.allow_suggestions(false);\n+\n+            // If this is a future incompatible lint it'll become a hard error, so\n+            // we have to emit *something*. Also allow lints to whitelist themselves\n+            // on a case-by-case basis for emission in a foreign macro.\n+            if future_incompatible.is_none() && !lint.report_in_external_macro {\n+                err.cancel();\n+                // Don't continue further, since we don't want to have\n+                // `diag_span_note_once` called for a diagnostic that isn't emitted.\n+                return;\n+            }\n         }\n-    }\n \n-    let name = lint.name_lower();\n-    match src {\n-        LintSource::Default => {\n-            sess.diag_note_once(\n-                &mut err,\n-                DiagnosticMessageId::from(lint),\n-                &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n-            );\n-        }\n-        LintSource::CommandLine(lint_flag_val) => {\n-            let flag = match level {\n-                Level::Warn => \"-W\",\n-                Level::Deny => \"-D\",\n-                Level::Forbid => \"-F\",\n-                Level::Allow => panic!(),\n-            };\n-            let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n-            if lint_flag_val.as_str() == name {\n+        let name = lint.name_lower();\n+        match src {\n+            LintSource::Default => {\n                 sess.diag_note_once(\n                     &mut err,\n                     DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"requested on the command line with `{} {}`\",\n-                        flag, hyphen_case_lint_name\n-                    ),\n-                );\n-            } else {\n-                let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n-                sess.diag_note_once(\n-                    &mut err,\n-                    DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"`{} {}` implied by `{} {}`\",\n-                        flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n-                    ),\n+                    &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n                 );\n             }\n-        }\n-        LintSource::Node(lint_attr_name, src, reason) => {\n-            if let Some(rationale) = reason {\n-                err.note(&rationale.as_str());\n+            LintSource::CommandLine(lint_flag_val) => {\n+                let flag = match level {\n+                    Level::Warn => \"-W\",\n+                    Level::Deny => \"-D\",\n+                    Level::Forbid => \"-F\",\n+                    Level::Allow => panic!(),\n+                };\n+                let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n+                if lint_flag_val.as_str() == name {\n+                    sess.diag_note_once(\n+                        &mut err,\n+                        DiagnosticMessageId::from(lint),\n+                        &format!(\n+                            \"requested on the command line with `{} {}`\",\n+                            flag, hyphen_case_lint_name\n+                        ),\n+                    );\n+                } else {\n+                    let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n+                    sess.diag_note_once(\n+                        &mut err,\n+                        DiagnosticMessageId::from(lint),\n+                        &format!(\n+                            \"`{} {}` implied by `{} {}`\",\n+                            flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n+                        ),\n+                    );\n+                }\n             }\n-            sess.diag_span_note_once(\n-                &mut err,\n-                DiagnosticMessageId::from(lint),\n-                src,\n-                \"the lint level is defined here\",\n-            );\n-            if lint_attr_name.as_str() != name {\n-                let level_str = level.as_str();\n-                sess.diag_note_once(\n+            LintSource::Node(lint_attr_name, src, reason) => {\n+                if let Some(rationale) = reason {\n+                    err.note(&rationale.as_str());\n+                }\n+                sess.diag_span_note_once(\n                     &mut err,\n                     DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"`#[{}({})]` implied by `#[{}({})]`\",\n-                        level_str, name, level_str, lint_attr_name\n-                    ),\n+                    src,\n+                    \"the lint level is defined here\",\n                 );\n+                if lint_attr_name.as_str() != name {\n+                    let level_str = level.as_str();\n+                    sess.diag_note_once(\n+                        &mut err,\n+                        DiagnosticMessageId::from(lint),\n+                        &format!(\n+                            \"`#[{}({})]` implied by `#[{}({})]`\",\n+                            level_str, name, level_str, lint_attr_name\n+                        ),\n+                    );\n+                }\n             }\n         }\n-    }\n \n-    err.code(DiagnosticId::Lint(name));\n-\n-    if let Some(future_incompatible) = future_incompatible {\n-        const STANDARD_MESSAGE: &str = \"this was previously accepted by the compiler but is being phased out; \\\n-             it will become a hard error\";\n-\n-        let explanation = if lint_id == LintId::of(builtin::UNSTABLE_NAME_COLLISIONS) {\n-            \"once this method is added to the standard library, \\\n-             the ambiguity may cause an error or change in behavior!\"\n-                .to_owned()\n-        } else if lint_id == LintId::of(builtin::MUTABLE_BORROW_RESERVATION_CONFLICT) {\n-            \"this borrowing pattern was not meant to be accepted, \\\n-             and may become a hard error in the future\"\n-                .to_owned()\n-        } else if let Some(edition) = future_incompatible.edition {\n-            format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)\n-        } else {\n-            format!(\"{} in a future release!\", STANDARD_MESSAGE)\n-        };\n-        let citation = format!(\"for more information, see {}\", future_incompatible.reference);\n-        err.warn(&explanation);\n-        err.note(&citation);\n-    }\n+        err.code(DiagnosticId::Lint(name));\n+\n+        if let Some(future_incompatible) = future_incompatible {\n+            const STANDARD_MESSAGE: &str = \"this was previously accepted by the compiler but is being phased out; \\\n+                 it will become a hard error\";\n+\n+            let explanation = if lint_id == LintId::of(builtin::UNSTABLE_NAME_COLLISIONS) {\n+                \"once this method is added to the standard library, \\\n+                 the ambiguity may cause an error or change in behavior!\"\n+                    .to_owned()\n+            } else if lint_id == LintId::of(builtin::MUTABLE_BORROW_RESERVATION_CONFLICT) {\n+                \"this borrowing pattern was not meant to be accepted, \\\n+                 and may become a hard error in the future\"\n+                    .to_owned()\n+            } else if let Some(edition) = future_incompatible.edition {\n+                format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)\n+            } else {\n+                format!(\"{} in a future release!\", STANDARD_MESSAGE)\n+            };\n+            let citation = format!(\"for more information, see {}\", future_incompatible.reference);\n+            err.warn(&explanation);\n+            err.note(&citation);\n+        }\n \n-    return err;\n+        // Finally, run `decorate`. This function is also responsible for emitting the diagnostic.\n+        decorate(LintDiagnosticBuilder::new(err));\n+    }\n+    struct_lint_level_impl(sess, lint, level, src, span, Box::new(decorate))\n }\n \n /// Returns whether `span` originates in a foreign crate's external macro."}, {"sha": "88ddd96eec8f5e66a61c1582bad4bd5b035d7ed0", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,40 +1,3 @@\n-macro_rules! enum_from_u32 {\n-    ($(#[$attr:meta])* pub enum $name:ident {\n-        $($variant:ident = $e:expr,)*\n-    }) => {\n-        $(#[$attr])*\n-        pub enum $name {\n-            $($variant = $e),*\n-        }\n-\n-        impl $name {\n-            pub fn from_u32(u: u32) -> Option<$name> {\n-                $(if u == $name::$variant as u32 {\n-                    return Some($name::$variant)\n-                })*\n-                None\n-            }\n-        }\n-    };\n-    ($(#[$attr:meta])* pub enum $name:ident {\n-        $($variant:ident,)*\n-    }) => {\n-        $(#[$attr])*\n-        pub enum $name {\n-            $($variant,)*\n-        }\n-\n-        impl $name {\n-            pub fn from_u32(u: u32) -> Option<$name> {\n-                $(if u == $name::$variant as u32 {\n-                    return Some($name::$variant)\n-                })*\n-                None\n-            }\n-        }\n-    }\n-}\n-\n #[macro_export]\n macro_rules! bug {\n     () => ( bug!(\"impossible case reached\") );"}, {"sha": "c8e284be6fc09cf5cad7615b2d19fd125163d61e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 35, "deletions": 390, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -9,401 +9,14 @@\n \n pub use self::LangItem::*;\n \n-use crate::hir::check_attr::Target;\n-use crate::middle::cstore::ExternCrate;\n-use crate::middle::weak_lang_items;\n use crate::ty::{self, TyCtxt};\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_macros::HashStable;\n-use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n-use syntax::ast;\n+use rustc_target::spec::PanicStrategy;\n \n-// The actual lang items defined come at the end of this file in one handy table.\n-// So you probably just want to nip down to the end.\n-macro_rules! language_item_table {\n-    (\n-        $( $variant:ident, $name:expr, $method:ident, $target:path; )*\n-    ) => {\n-\n-enum_from_u32! {\n-    /// A representation of all the valid language items in Rust.\n-    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-    pub enum LangItem {\n-        $($variant,)*\n-    }\n-}\n-\n-impl LangItem {\n-    /// Returns the `name` in `#[lang = \"$name\"]`.\n-    /// For example, `LangItem::EqTraitLangItem`,\n-    /// that is `#[lang = \"eq\"]` would result in `\"eq\"`.\n-    fn name(self) -> &'static str {\n-        match self {\n-            $( $variant => $name, )*\n-        }\n-    }\n-}\n-\n-#[derive(HashStable)]\n-pub struct LanguageItems {\n-    /// Mappings from lang items to their possibly found `DefId`s.\n-    /// The index corresponds to the order in `LangItem`.\n-    pub items: Vec<Option<DefId>>,\n-    /// Lang items that were not found during collection.\n-    pub missing: Vec<LangItem>,\n-}\n-\n-impl LanguageItems {\n-    /// Construct an empty collection of lang items and no missing ones.\n-    pub fn new() -> Self {\n-        fn init_none(_: LangItem) -> Option<DefId> { None }\n-\n-        Self {\n-            items: vec![$(init_none($variant)),*],\n-            missing: Vec::new(),\n-        }\n-    }\n-\n-    /// Returns the mappings to the possibly found `DefId`s for each lang item.\n-    pub fn items(&self) -> &[Option<DefId>] {\n-        &*self.items\n-    }\n-\n-    /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n-    /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n-    /// returns an error message as a string.\n-    pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n-        self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n-    }\n-\n-    /// Returns the kind of closure that `id`, which is one of the `Fn*` traits, corresponds to.\n-    /// If `id` is not one of the `Fn*` traits, `None` is returned.\n-    pub fn fn_trait_kind(&self, id: DefId) -> Option<ty::ClosureKind> {\n-        match Some(id) {\n-            x if x == self.fn_trait() => Some(ty::ClosureKind::Fn),\n-            x if x == self.fn_mut_trait() => Some(ty::ClosureKind::FnMut),\n-            x if x == self.fn_once_trait() => Some(ty::ClosureKind::FnOnce),\n-            _ => None\n-        }\n-    }\n-\n-    $(\n-        /// Returns the corresponding `DefId` for the lang item\n-        #[doc = $name]\n-        /// if it exists.\n-        #[allow(dead_code)]\n-        pub fn $method(&self) -> Option<DefId> {\n-            self.items[$variant as usize]\n-        }\n-    )*\n-}\n-\n-struct LanguageItemCollector<'tcx> {\n-    items: LanguageItems,\n-    tcx: TyCtxt<'tcx>,\n-    /// A mapping from the name of the lang item to its order and the form it must be of.\n-    item_refs: FxHashMap<&'static str, (usize, Target)>,\n-}\n-\n-impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if let Some((value, span)) = extract(&item.attrs) {\n-            let actual_target = Target::from_item(item);\n-            match self.item_refs.get(&*value.as_str()).cloned() {\n-                // Known lang item with attribute on correct target.\n-                Some((item_index, expected_target)) if actual_target == expected_target => {\n-                    let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                    self.collect_item(item_index, def_id);\n-                },\n-                // Known lang item with attribute on incorrect target.\n-                Some((_, expected_target)) => {\n-                    struct_span_err!(\n-                        self.tcx.sess, span, E0718,\n-                        \"`{}` language item must be applied to a {}\",\n-                        value, expected_target,\n-                    ).span_label(\n-                        span,\n-                        format!(\n-                            \"attribute should be applied to a {}, not a {}\",\n-                            expected_target, actual_target,\n-                        ),\n-                    ).emit();\n-                },\n-                // Unknown lang item.\n-                _ => {\n-                    struct_span_err!(\n-                        self.tcx.sess, span, E0522,\n-                        \"definition of an unknown language item: `{}`\",\n-                        value\n-                    ).span_label(\n-                        span,\n-                        format!(\"definition of unknown language item `{}`\", value)\n-                    ).emit();\n-                },\n-            }\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n-        // At present, lang items are always items, not trait items.\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n-        // At present, lang items are always items, not impl items.\n-    }\n-}\n-\n-impl LanguageItemCollector<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> LanguageItemCollector<'tcx> {\n-        let mut item_refs = FxHashMap::default();\n-\n-        $( item_refs.insert($name, ($variant as usize, $target)); )*\n-\n-        LanguageItemCollector {\n-            tcx,\n-            items: LanguageItems::new(),\n-            item_refs,\n-        }\n-    }\n-\n-    fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n-        // Check for duplicates.\n-        if let Some(original_def_id) = self.items.items[item_index] {\n-            if original_def_id != item_def_id {\n-                let name = LangItem::from_u32(item_index as u32).unwrap().name();\n-                let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n-                    Some(span) => struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0152,\n-                        \"found duplicate lang item `{}`\",\n-                        name\n-                    ),\n-                    None => {\n-                        match self.tcx.extern_crate(item_def_id) {\n-                            Some(ExternCrate {dependency_of, ..}) => {\n-                                self.tcx.sess.struct_err(&format!(\n-                                \"duplicate lang item in crate `{}` (which `{}` depends on): `{}`.\",\n-                                self.tcx.crate_name(item_def_id.krate),\n-                                self.tcx.crate_name(*dependency_of),\n-                                name))\n-                            },\n-                            _ => {\n-                                self.tcx.sess.struct_err(&format!(\n-                                \"duplicate lang item in crate `{}`: `{}`.\",\n-                                self.tcx.crate_name(item_def_id.krate),\n-                                name))\n-                            }\n-                        }\n-                    },\n-                };\n-                if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n-                    err.span_note(span, \"the lang item is first defined here\");\n-                } else {\n-                    match self.tcx.extern_crate(original_def_id) {\n-                        Some(ExternCrate {dependency_of, ..}) => {\n-                            err.note(&format!(\n-                            \"the lang item is first defined in crate `{}` (which `{}` depends on)\",\n-                                      self.tcx.crate_name(original_def_id.krate),\n-                                      self.tcx.crate_name(*dependency_of)));\n-                        },\n-                        _ => {\n-                            err.note(&format!(\"the lang item is first defined in crate `{}`.\",\n-                                      self.tcx.crate_name(original_def_id.krate)));\n-                        }\n-                    }\n-                }\n-                err.emit();\n-            }\n-        }\n-\n-        // Matched.\n-        self.items.items[item_index] = Some(item_def_id);\n-    }\n-}\n-\n-/// Extracts the first `lang = \"$name\"` out of a list of attributes.\n-/// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n-/// are also extracted out when found.\n-pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n-    attrs.iter().find_map(|attr| Some(match attr {\n-        _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n-        _ if attr.check_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n-        _ if attr.check_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n-        _ => return None,\n-    }))\n-}\n-\n-/// Traverses and collects all the lang items in all crates.\n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n-    // Initialize the collector.\n-    let mut collector = LanguageItemCollector::new(tcx);\n-\n-    // Collect lang items in other crates.\n-    for &cnum in tcx.crates().iter() {\n-        for &(def_id, item_index) in tcx.defined_lang_items(cnum).iter() {\n-            collector.collect_item(item_index, def_id);\n-        }\n-    }\n-\n-    // Collect lang items in this crate.\n-    tcx.hir().krate().visit_all_item_likes(&mut collector);\n-\n-    // Extract out the found lang items.\n-    let LanguageItemCollector { mut items, .. } = collector;\n-\n-    // Find all required but not-yet-defined lang items.\n-    weak_lang_items::check_crate(tcx, &mut items);\n-\n-    items\n-}\n-\n-// End of the macro\n-    }\n-}\n-\n-language_item_table! {\n-//  Variant name,                Name,                 Method name,             Target;\n-    BoolImplItem,                \"bool\",               bool_impl,               Target::Impl;\n-    CharImplItem,                \"char\",               char_impl,               Target::Impl;\n-    StrImplItem,                 \"str\",                str_impl,                Target::Impl;\n-    SliceImplItem,               \"slice\",              slice_impl,              Target::Impl;\n-    SliceU8ImplItem,             \"slice_u8\",           slice_u8_impl,           Target::Impl;\n-    StrAllocImplItem,            \"str_alloc\",          str_alloc_impl,          Target::Impl;\n-    SliceAllocImplItem,          \"slice_alloc\",        slice_alloc_impl,        Target::Impl;\n-    SliceU8AllocImplItem,        \"slice_u8_alloc\",     slice_u8_alloc_impl,     Target::Impl;\n-    ConstPtrImplItem,            \"const_ptr\",          const_ptr_impl,          Target::Impl;\n-    MutPtrImplItem,              \"mut_ptr\",            mut_ptr_impl,            Target::Impl;\n-    I8ImplItem,                  \"i8\",                 i8_impl,                 Target::Impl;\n-    I16ImplItem,                 \"i16\",                i16_impl,                Target::Impl;\n-    I32ImplItem,                 \"i32\",                i32_impl,                Target::Impl;\n-    I64ImplItem,                 \"i64\",                i64_impl,                Target::Impl;\n-    I128ImplItem,                \"i128\",               i128_impl,               Target::Impl;\n-    IsizeImplItem,               \"isize\",              isize_impl,              Target::Impl;\n-    U8ImplItem,                  \"u8\",                 u8_impl,                 Target::Impl;\n-    U16ImplItem,                 \"u16\",                u16_impl,                Target::Impl;\n-    U32ImplItem,                 \"u32\",                u32_impl,                Target::Impl;\n-    U64ImplItem,                 \"u64\",                u64_impl,                Target::Impl;\n-    U128ImplItem,                \"u128\",               u128_impl,               Target::Impl;\n-    UsizeImplItem,               \"usize\",              usize_impl,              Target::Impl;\n-    F32ImplItem,                 \"f32\",                f32_impl,                Target::Impl;\n-    F64ImplItem,                 \"f64\",                f64_impl,                Target::Impl;\n-    F32RuntimeImplItem,          \"f32_runtime\",        f32_runtime_impl,        Target::Impl;\n-    F64RuntimeImplItem,          \"f64_runtime\",        f64_runtime_impl,        Target::Impl;\n-\n-    SizedTraitLangItem,          \"sized\",              sized_trait,             Target::Trait;\n-    UnsizeTraitLangItem,         \"unsize\",             unsize_trait,            Target::Trait;\n-    // trait injected by #[derive(PartialEq)], (i.e. \"Partial EQ\").\n-    StructuralPeqTraitLangItem,  \"structural_peq\",     structural_peq_trait,    Target::Trait;\n-    // trait injected by #[derive(Eq)], (i.e. \"Total EQ\"; no, I will not apologize).\n-    StructuralTeqTraitLangItem,  \"structural_teq\",     structural_teq_trait,    Target::Trait;\n-    CopyTraitLangItem,           \"copy\",               copy_trait,              Target::Trait;\n-    CloneTraitLangItem,          \"clone\",              clone_trait,             Target::Trait;\n-    SyncTraitLangItem,           \"sync\",               sync_trait,              Target::Trait;\n-    FreezeTraitLangItem,         \"freeze\",             freeze_trait,            Target::Trait;\n-\n-    DropTraitLangItem,           \"drop\",               drop_trait,              Target::Trait;\n-\n-    CoerceUnsizedTraitLangItem,  \"coerce_unsized\",     coerce_unsized_trait,    Target::Trait;\n-    DispatchFromDynTraitLangItem,\"dispatch_from_dyn\",  dispatch_from_dyn_trait, Target::Trait;\n-\n-    AddTraitLangItem,            \"add\",                add_trait,               Target::Trait;\n-    SubTraitLangItem,            \"sub\",                sub_trait,               Target::Trait;\n-    MulTraitLangItem,            \"mul\",                mul_trait,               Target::Trait;\n-    DivTraitLangItem,            \"div\",                div_trait,               Target::Trait;\n-    RemTraitLangItem,            \"rem\",                rem_trait,               Target::Trait;\n-    NegTraitLangItem,            \"neg\",                neg_trait,               Target::Trait;\n-    NotTraitLangItem,            \"not\",                not_trait,               Target::Trait;\n-    BitXorTraitLangItem,         \"bitxor\",             bitxor_trait,            Target::Trait;\n-    BitAndTraitLangItem,         \"bitand\",             bitand_trait,            Target::Trait;\n-    BitOrTraitLangItem,          \"bitor\",              bitor_trait,             Target::Trait;\n-    ShlTraitLangItem,            \"shl\",                shl_trait,               Target::Trait;\n-    ShrTraitLangItem,            \"shr\",                shr_trait,               Target::Trait;\n-    AddAssignTraitLangItem,      \"add_assign\",         add_assign_trait,        Target::Trait;\n-    SubAssignTraitLangItem,      \"sub_assign\",         sub_assign_trait,        Target::Trait;\n-    MulAssignTraitLangItem,      \"mul_assign\",         mul_assign_trait,        Target::Trait;\n-    DivAssignTraitLangItem,      \"div_assign\",         div_assign_trait,        Target::Trait;\n-    RemAssignTraitLangItem,      \"rem_assign\",         rem_assign_trait,        Target::Trait;\n-    BitXorAssignTraitLangItem,   \"bitxor_assign\",      bitxor_assign_trait,     Target::Trait;\n-    BitAndAssignTraitLangItem,   \"bitand_assign\",      bitand_assign_trait,     Target::Trait;\n-    BitOrAssignTraitLangItem,    \"bitor_assign\",       bitor_assign_trait,      Target::Trait;\n-    ShlAssignTraitLangItem,      \"shl_assign\",         shl_assign_trait,        Target::Trait;\n-    ShrAssignTraitLangItem,      \"shr_assign\",         shr_assign_trait,        Target::Trait;\n-    IndexTraitLangItem,          \"index\",              index_trait,             Target::Trait;\n-    IndexMutTraitLangItem,       \"index_mut\",          index_mut_trait,         Target::Trait;\n-\n-    UnsafeCellTypeLangItem,      \"unsafe_cell\",        unsafe_cell_type,        Target::Struct;\n-    VaListTypeLangItem,          \"va_list\",            va_list,                 Target::Struct;\n-\n-    DerefTraitLangItem,          \"deref\",              deref_trait,             Target::Trait;\n-    DerefMutTraitLangItem,       \"deref_mut\",          deref_mut_trait,         Target::Trait;\n-    ReceiverTraitLangItem,       \"receiver\",           receiver_trait,          Target::Trait;\n-\n-    FnTraitLangItem,             \"fn\",                 fn_trait,                Target::Trait;\n-    FnMutTraitLangItem,          \"fn_mut\",             fn_mut_trait,            Target::Trait;\n-    FnOnceTraitLangItem,         \"fn_once\",            fn_once_trait,           Target::Trait;\n-\n-    FutureTraitLangItem,         \"future_trait\",       future_trait,            Target::Trait;\n-    GeneratorStateLangItem,      \"generator_state\",    gen_state,               Target::Enum;\n-    GeneratorTraitLangItem,      \"generator\",          gen_trait,               Target::Trait;\n-    UnpinTraitLangItem,          \"unpin\",              unpin_trait,             Target::Trait;\n-    PinTypeLangItem,             \"pin\",                pin_type,                Target::Struct;\n-\n-    // Don't be fooled by the naming here: this lang item denotes `PartialEq`, not `Eq`.\n-    EqTraitLangItem,             \"eq\",                 eq_trait,                Target::Trait;\n-    PartialOrdTraitLangItem,     \"partial_ord\",        partial_ord_trait,       Target::Trait;\n-\n-    // A number of panic-related lang items. The `panic` item corresponds to\n-    // divide-by-zero and various panic cases with `match`. The\n-    // `panic_bounds_check` item is for indexing arrays.\n-    //\n-    // The `begin_unwind` lang item has a predefined symbol name and is sort of\n-    // a \"weak lang item\" in the sense that a crate is not required to have it\n-    // defined to use it, but a final product is required to define it\n-    // somewhere. Additionally, there are restrictions on crates that use a weak\n-    // lang item, but do not have it defined.\n-    PanicFnLangItem,             \"panic\",              panic_fn,                Target::Fn;\n-    PanicBoundsCheckFnLangItem,  \"panic_bounds_check\", panic_bounds_check_fn,   Target::Fn;\n-    PanicInfoLangItem,           \"panic_info\",         panic_info,              Target::Struct;\n-    PanicLocationLangItem,       \"panic_location\",     panic_location,          Target::Struct;\n-    PanicImplLangItem,           \"panic_impl\",         panic_impl,              Target::Fn;\n-    // Libstd panic entry point. Necessary for const eval to be able to catch it\n-    BeginPanicFnLangItem,        \"begin_panic\",        begin_panic_fn,          Target::Fn;\n-\n-    ExchangeMallocFnLangItem,    \"exchange_malloc\",    exchange_malloc_fn,      Target::Fn;\n-    BoxFreeFnLangItem,           \"box_free\",           box_free_fn,             Target::Fn;\n-    DropInPlaceFnLangItem,       \"drop_in_place\",      drop_in_place_fn,        Target::Fn;\n-    OomLangItem,                 \"oom\",                oom,                     Target::Fn;\n-    AllocLayoutLangItem,         \"alloc_layout\",       alloc_layout,            Target::Struct;\n-\n-    StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n-\n-    EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n-    EhUnwindResumeLangItem,      \"eh_unwind_resume\",   eh_unwind_resume,        Target::Fn;\n-    EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n-\n-    OwnedBoxLangItem,            \"owned_box\",          owned_box,               Target::Struct;\n-\n-    PhantomDataItem,             \"phantom_data\",       phantom_data,            Target::Struct;\n-\n-    ManuallyDropItem,            \"manually_drop\",      manually_drop,           Target::Struct;\n-\n-    MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n-\n-    // Align offset for stride != 1; must not panic.\n-    AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n-\n-    TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n-\n-    Arc,                         \"arc\",                arc,                     Target::Struct;\n-    Rc,                          \"rc\",                 rc,                      Target::Struct;\n-}\n+pub use rustc_hir::weak_lang_items::link_name;\n+pub use rustc_hir::{LangItem, LanguageItems};\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n@@ -417,4 +30,36 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         })\n     }\n+\n+    pub fn fn_trait_kind_from_lang_item(&self, id: DefId) -> Option<ty::ClosureKind> {\n+        let items = self.lang_items();\n+        match Some(id) {\n+            x if x == items.fn_trait() => Some(ty::ClosureKind::Fn),\n+            x if x == items.fn_mut_trait() => Some(ty::ClosureKind::FnMut),\n+            x if x == items.fn_once_trait() => Some(ty::ClosureKind::FnOnce),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n+        self.lang_items().is_weak_lang_item(item_def_id)\n+    }\n+}\n+\n+/// Returns `true` if the specified `lang_item` doesn't actually need to be\n+/// present for this compilation.\n+///\n+/// Not all lang items are always required for each compilation, particularly in\n+/// the case of panic=abort. In these situations some lang items are injected by\n+/// crates and don't actually need to be defined in libstd.\n+pub fn whitelisted(tcx: TyCtxt<'_>, lang_item: LangItem) -> bool {\n+    // If we're not compiling with unwinding, we won't actually need these\n+    // symbols. Other panic runtimes ensure that the relevant symbols are\n+    // available to link things together, but they're never exercised.\n+    if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n+        return lang_item == LangItem::EhPersonalityLangItem\n+            || lang_item == LangItem::EhUnwindResumeLangItem;\n+    }\n+\n+    false\n }"}, {"sha": "b20f2cf3a85c133f53bec53c9ea3b041aa21ff43", "filename": "src/librustc/middle/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -33,4 +33,3 @@ pub mod recursion_limit;\n pub mod region;\n pub mod resolve_lifetime;\n pub mod stability;\n-pub mod weak_lang_items;"}, {"sha": "be530da5910df588d180edc9e28f2f630e40aa6d", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -6,26 +6,60 @@\n // just peeks and looks for that attribute.\n \n use crate::session::Session;\n+use core::num::IntErrorKind;\n+use rustc::bug;\n use rustc_span::symbol::{sym, Symbol};\n use syntax::ast;\n \n use rustc_data_structures::sync::Once;\n \n pub fn update_limits(sess: &Session, krate: &ast::Crate) {\n-    update_limit(krate, &sess.recursion_limit, sym::recursion_limit, 128);\n-    update_limit(krate, &sess.type_length_limit, sym::type_length_limit, 1048576);\n+    update_limit(sess, krate, &sess.recursion_limit, sym::recursion_limit, 128);\n+    update_limit(sess, krate, &sess.type_length_limit, sym::type_length_limit, 1048576);\n }\n \n-fn update_limit(krate: &ast::Crate, limit: &Once<usize>, name: Symbol, default: usize) {\n+fn update_limit(\n+    sess: &Session,\n+    krate: &ast::Crate,\n+    limit: &Once<usize>,\n+    name: Symbol,\n+    default: usize,\n+) {\n     for attr in &krate.attrs {\n         if !attr.check_name(name) {\n             continue;\n         }\n \n         if let Some(s) = attr.value_str() {\n-            if let Some(n) = s.as_str().parse().ok() {\n-                limit.set(n);\n-                return;\n+            match s.as_str().parse() {\n+                Ok(n) => {\n+                    limit.set(n);\n+                    return;\n+                }\n+                Err(e) => {\n+                    let mut err = sess.struct_span_err(\n+                        attr.span,\n+                        \"`recursion_limit` must be a non-negative integer\",\n+                    );\n+\n+                    let value_span = attr\n+                        .meta()\n+                        .and_then(|meta| meta.name_value_literal().cloned())\n+                        .map(|lit| lit.span)\n+                        .unwrap_or(attr.span);\n+\n+                    let error_str = match e.kind() {\n+                        IntErrorKind::Overflow => \"`recursion_limit` is too large\",\n+                        IntErrorKind::Empty => \"`recursion_limit` must be a non-negative integer\",\n+                        IntErrorKind::InvalidDigit => \"not a valid integer\",\n+                        IntErrorKind::Underflow => bug!(\"`recursion_limit` should never underflow\"),\n+                        IntErrorKind::Zero => bug!(\"zero is a valid `recursion_limit`\"),\n+                        kind => bug!(\"unimplemented IntErrorKind variant: {:?}\", kind),\n+                    };\n+\n+                    err.span_label(value_span, error_str);\n+                    err.emit();\n+                }\n             }\n         }\n     }"}, {"sha": "7b5faa2423aea80b0f2c0c398dfb85a77e3af50e", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -106,10 +106,10 @@ pub fn report_unstable(\n     };\n \n     let msp: MultiSpan = span.into();\n-    let cm = &sess.parse_sess.source_map();\n+    let sm = &sess.parse_sess.source_map();\n     let span_key = msp.primary_span().and_then(|sp: Span| {\n         if !sp.is_dummy() {\n-            let file = cm.lookup_char_pos(sp.lo()).file;\n+            let file = sm.lookup_char_pos(sp.lo()).file;\n             if file.name.is_macros() { None } else { Some(span) }\n         } else {\n             None\n@@ -222,11 +222,13 @@ fn late_report_deprecation(\n         return;\n     }\n \n-    let mut diag = tcx.struct_span_lint_hir(lint, hir_id, span, message);\n-    if let hir::Node::Expr(_) = tcx.hir().get(hir_id) {\n-        deprecation_suggestion(&mut diag, suggestion, span);\n-    }\n-    diag.emit();\n+    tcx.struct_span_lint_hir(lint, hir_id, span, |lint| {\n+        let mut diag = lint.build(message);\n+        if let hir::Node::Expr(_) = tcx.hir().get(hir_id) {\n+            deprecation_suggestion(&mut diag, suggestion, span);\n+        }\n+        diag.emit()\n+    });\n     if hir_id == hir::DUMMY_HIR_ID {\n         span_bug!(span, \"emitted a {} lint with dummy HIR id: {:?}\", lint.name, def_id);\n     }\n@@ -387,8 +389,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Additionally, this function will also check if the item is deprecated. If so, and `id` is\n     /// not `None`, a deprecated lint attached to `id` will be emitted.\n     pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n-        let soft_handler =\n-            |lint, span, msg: &_| self.lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, msg);\n+        let soft_handler = |lint, span, msg: &_| {\n+            self.struct_span_lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, |lint| {\n+                lint.build(msg).emit()\n+            })\n+        };\n         match self.eval_stability(def_id, id, span) {\n             EvalResult::Allow => {}\n             EvalResult::Deny { feature, reason, issue, is_soft } => {"}, {"sha": "5571f8f2313d56f0d8e0dae37ed41527bfa52847", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=e7a344fb745a0a663e21be947b2619df05df6d31", "patch": "@@ -1,167 +0,0 @@\n-//! Validity checking for weak lang items\n-\n-use crate::middle::lang_items;\n-use crate::session::config;\n-\n-use crate::hir::map::Map;\n-use crate::ty::TyCtxt;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::Span;\n-use rustc_target::spec::PanicStrategy;\n-use syntax::ast;\n-\n-macro_rules! weak_lang_items {\n-    ($($name:ident, $item:ident, $sym:ident;)*) => (\n-\n-struct Context<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    items: &'a mut lang_items::LanguageItems,\n-}\n-\n-/// Checks the crate for usage of weak lang items, returning a vector of all the\n-/// language items required by this crate, but not defined yet.\n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>,\n-                             items: &mut lang_items::LanguageItems) {\n-    // These are never called by user code, they're generated by the compiler.\n-    // They will never implicitly be added to the `missing` array unless we do\n-    // so here.\n-    if items.eh_personality().is_none() {\n-        items.missing.push(lang_items::EhPersonalityLangItem);\n-    }\n-    if tcx.sess.target.target.options.custom_unwind_resume &\n-       items.eh_unwind_resume().is_none() {\n-        items.missing.push(lang_items::EhUnwindResumeLangItem);\n-    }\n-\n-    {\n-        let mut cx = Context { tcx, items };\n-        tcx.hir().krate().visit_all_item_likes(&mut cx.as_deep_visitor());\n-    }\n-    verify(tcx, items);\n-}\n-\n-pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n-    lang_items::extract(attrs).and_then(|(name, _)| {\n-        $(if name == sym::$name {\n-            Some(sym::$sym)\n-        } else)* {\n-            None\n-        }\n-    })\n-}\n-\n-/// Returns `true` if the specified `lang_item` doesn't actually need to be\n-/// present for this compilation.\n-///\n-/// Not all lang items are always required for each compilation, particularly in\n-/// the case of panic=abort. In these situations some lang items are injected by\n-/// crates and don't actually need to be defined in libstd.\n-pub fn whitelisted(tcx: TyCtxt<'_>, lang_item: lang_items::LangItem) -> bool {\n-    // If we're not compiling with unwinding, we won't actually need these\n-    // symbols. Other panic runtimes ensure that the relevant symbols are\n-    // available to link things together, but they're never exercised.\n-    if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n-        return lang_item == lang_items::EhPersonalityLangItem ||\n-            lang_item == lang_items::EhUnwindResumeLangItem\n-    }\n-\n-    false\n-}\n-\n-fn verify<'tcx>(tcx: TyCtxt<'tcx>,\n-                    items: &lang_items::LanguageItems) {\n-    // We only need to check for the presence of weak lang items if we're\n-    // emitting something that's not an rlib.\n-    let needs_check = tcx.sess.crate_types.borrow().iter().any(|kind| {\n-        match *kind {\n-            config::CrateType::Dylib |\n-            config::CrateType::ProcMacro |\n-            config::CrateType::Cdylib |\n-            config::CrateType::Executable |\n-            config::CrateType::Staticlib => true,\n-            config::CrateType::Rlib => false,\n-        }\n-    });\n-    if !needs_check {\n-        return\n-    }\n-\n-    let mut missing = FxHashSet::default();\n-    for &cnum in tcx.crates().iter() {\n-        for &item in tcx.missing_lang_items(cnum).iter() {\n-            missing.insert(item);\n-        }\n-    }\n-\n-    $(\n-        if missing.contains(&lang_items::$item) &&\n-           !whitelisted(tcx, lang_items::$item) &&\n-           items.$name().is_none() {\n-            if lang_items::$item == lang_items::PanicImplLangItem {\n-                tcx.sess.err(&format!(\"`#[panic_handler]` function required, \\\n-                                       but not found\"));\n-            } else if lang_items::$item == lang_items::OomLangItem {\n-                tcx.sess.err(&format!(\"`#[alloc_error_handler]` function required, \\\n-                                       but not found\"));\n-            } else {\n-                tcx.sess.err(&format!(\"language item required, but not found: `{}`\",\n-                                      stringify!($name)));\n-            }\n-        }\n-    )*\n-}\n-\n-impl<'a, 'tcx> Context<'a, 'tcx> {\n-    fn register(&mut self, name: Symbol, span: Span) {\n-        $(if name == sym::$name {\n-            if self.items.$name().is_none() {\n-                self.items.missing.push(lang_items::$item);\n-            }\n-        } else)* {\n-            struct_span_err!(\n-                self.tcx.sess, span, E0264,\n-                \"unknown external lang item: `{}`\",\n-                name\n-            )\n-            .emit();\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n-    type Map = Map<'v>;\n-\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, Map<'v>> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n-        if let Some((lang_item, _)) = lang_items::extract(&i.attrs) {\n-            self.register(lang_item, i.span);\n-        }\n-        intravisit::walk_foreign_item(self, i)\n-    }\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n-        let lang_items = self.lang_items();\n-        let did = Some(item_def_id);\n-\n-        $(lang_items.$name() == did)||*\n-    }\n-}\n-\n-) }\n-\n-weak_lang_items! {\n-    panic_impl,         PanicImplLangItem,          rust_begin_unwind;\n-    eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n-    eh_unwind_resume,   EhUnwindResumeLangItem,     rust_eh_unwind_resume;\n-    oom,                OomLangItem,                rust_oom;\n-}"}, {"sha": "052603f6e5e60092f641ec6a348f658eea943e3e", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -598,7 +598,7 @@ impl AllocationDefinedness {\n     pub fn all_bytes_undef(&self) -> bool {\n         // The `ranges` are run-length encoded and of alternating definedness.\n         // So if `ranges.len() > 1` then the second block is a range of defined.\n-        self.initial == false && self.ranges.len() == 1\n+        !self.initial && self.ranges.len() == 1\n     }\n }\n "}, {"sha": "a23ff6bd66d4b8bef638e664a5da9d731a89d780", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 82, "deletions": 108, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -2,16 +2,15 @@ use super::{CheckInAllocMsg, Pointer, RawConst, ScalarMaybeUndef};\n \n use crate::hir::map::definitions::DefPathData;\n use crate::mir;\n+use crate::mir::interpret::ConstValue;\n use crate::ty::layout::{Align, LayoutError, Size};\n use crate::ty::query::TyCtxtAt;\n use crate::ty::{self, layout, Ty};\n \n use backtrace::Backtrace;\n-use hir::GeneratorKind;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_macros::HashStable;\n-use rustc_span::symbol::Symbol;\n use rustc_span::{Pos, Span};\n use rustc_target::spec::abi::Abi;\n use std::{any::Any, env, fmt};\n@@ -42,7 +41,7 @@ CloneTypeFoldableImpls! {\n }\n \n pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n-pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n+pub type ConstEvalResult<'tcx> = Result<ConstValue<'tcx>, ErrorHandled>;\n \n #[derive(Debug)]\n pub struct ConstEvalErr<'tcx> {\n@@ -83,18 +82,15 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         &self,\n         tcx: TyCtxtAt<'tcx>,\n         message: &str,\n-    ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n-        self.struct_generic(tcx, message, None)\n+        emit: impl FnOnce(DiagnosticBuilder<'_>),\n+    ) -> Result<(), ErrorHandled> {\n+        self.struct_generic(tcx, message, emit, None)\n     }\n \n     pub fn report_as_error(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n-        let err = self.struct_error(tcx, message);\n-        match err {\n-            Ok(mut err) => {\n-                err.emit();\n-                ErrorHandled::Reported\n-            }\n-            Err(err) => err,\n+        match self.struct_error(tcx, message, |mut e| e.emit()) {\n+            Ok(_) => ErrorHandled::Reported,\n+            Err(x) => x,\n         }\n     }\n \n@@ -105,9 +101,11 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         lint_root: hir::HirId,\n         span: Option<Span>,\n     ) -> ErrorHandled {\n-        let lint = self.struct_generic(tcx, message, Some(lint_root));\n-        match lint {\n-            Ok(mut lint) => {\n+        match self.struct_generic(\n+            tcx,\n+            message,\n+            |mut lint: DiagnosticBuilder<'_>| {\n+                // Apply the span.\n                 if let Some(span) = span {\n                     let primary_spans = lint.span.primary_spans().to_vec();\n                     // point at the actual error as the primary span\n@@ -121,59 +119,95 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                     }\n                 }\n                 lint.emit();\n-                ErrorHandled::Reported\n-            }\n+            },\n+            Some(lint_root),\n+        ) {\n+            Ok(_) => ErrorHandled::Reported,\n             Err(err) => err,\n         }\n     }\n \n+    /// Create a diagnostic for this const eval error.\n+    ///\n+    /// Sets the message passed in via `message` and adds span labels with detailed error\n+    /// information before handing control back to `emit` to do any final processing.\n+    /// It's the caller's responsibility to call emit(), stash(), etc. within the `emit`\n+    /// function to dispose of the diagnostic properly.\n+    ///\n+    /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n+    /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n     fn struct_generic(\n         &self,\n         tcx: TyCtxtAt<'tcx>,\n         message: &str,\n+        emit: impl FnOnce(DiagnosticBuilder<'_>),\n         lint_root: Option<hir::HirId>,\n-    ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n+    ) -> Result<(), ErrorHandled> {\n         let must_error = match self.error {\n-            InterpError::MachineStop(_) => bug!(\"CTFE does not stop\"),\n             err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n                 return Err(ErrorHandled::TooGeneric);\n             }\n             err_inval!(TypeckError) => return Err(ErrorHandled::Reported),\n+            // We must *always* hard error on these, even if the caller wants just a lint.\n             err_inval!(Layout(LayoutError::SizeOverflow(_))) => true,\n             _ => false,\n         };\n         trace!(\"reporting const eval failure at {:?}\", self.span);\n-        let mut err = if let (Some(lint_root), false) = (lint_root, must_error) {\n-            let hir_id = self\n-                .stacktrace\n-                .iter()\n-                .rev()\n-                .filter_map(|frame| frame.lint_root)\n-                .next()\n-                .unwrap_or(lint_root);\n-            tcx.struct_span_lint_hir(\n-                rustc_session::lint::builtin::CONST_ERR,\n-                hir_id,\n-                tcx.span,\n-                message,\n-            )\n-        } else if must_error {\n-            struct_error(tcx, &self.error.to_string())\n-        } else {\n-            struct_error(tcx, message)\n+\n+        let err_msg = match &self.error {\n+            InterpError::MachineStop(msg) => {\n+                // A custom error (`ConstEvalErrKind` in `librustc_mir/interp/const_eval/error.rs`).\n+                // Should be turned into a string by now.\n+                msg.downcast_ref::<String>().expect(\"invalid MachineStop payload\").clone()\n+            }\n+            err => err.to_string(),\n         };\n-        if !must_error {\n-            err.span_label(self.span, self.error.to_string());\n-        }\n-        // Skip the last, which is just the environment of the constant.  The stacktrace\n-        // is sometimes empty because we create \"fake\" eval contexts in CTFE to do work\n-        // on constant values.\n-        if self.stacktrace.len() > 0 {\n-            for frame_info in &self.stacktrace[..self.stacktrace.len() - 1] {\n-                err.span_label(frame_info.call_site, frame_info.to_string());\n+\n+        let finish = |mut err: DiagnosticBuilder<'_>, span_msg: Option<String>| {\n+            if let Some(span_msg) = span_msg {\n+                err.span_label(self.span, span_msg);\n+            }\n+            // Add spans for the stacktrace.\n+            // Skip the last, which is just the environment of the constant.  The stacktrace\n+            // is sometimes empty because we create \"fake\" eval contexts in CTFE to do work\n+            // on constant values.\n+            if self.stacktrace.len() > 0 {\n+                for frame_info in &self.stacktrace[..self.stacktrace.len() - 1] {\n+                    err.span_label(frame_info.call_site, frame_info.to_string());\n+                }\n+            }\n+            // Let the caller finish the job.\n+            emit(err)\n+        };\n+\n+        if must_error {\n+            // The `message` makes little sense here, this is a more serious error than the\n+            // caller thinks anyway.\n+            // See <https://github.com/rust-lang/rust/pull/63152>.\n+            finish(struct_error(tcx, &err_msg), None);\n+        } else {\n+            // Regular case.\n+            if let Some(lint_root) = lint_root {\n+                // Report as lint.\n+                let hir_id = self\n+                    .stacktrace\n+                    .iter()\n+                    .rev()\n+                    .filter_map(|frame| frame.lint_root)\n+                    .next()\n+                    .unwrap_or(lint_root);\n+                tcx.struct_span_lint_hir(\n+                    rustc_session::lint::builtin::CONST_ERR,\n+                    hir_id,\n+                    tcx.span,\n+                    |lint| finish(lint.build(message), Some(err_msg)),\n+                );\n+            } else {\n+                // Report as hard error.\n+                finish(struct_error(tcx, message), Some(err_msg));\n             }\n         }\n-        Ok(err)\n+        Ok(())\n     }\n }\n \n@@ -242,63 +276,6 @@ impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n-pub enum PanicInfo<O> {\n-    Panic { msg: Symbol, line: u32, col: u32, file: Symbol },\n-    BoundsCheck { len: O, index: O },\n-    Overflow(mir::BinOp),\n-    OverflowNeg,\n-    DivisionByZero,\n-    RemainderByZero,\n-    ResumedAfterReturn(GeneratorKind),\n-    ResumedAfterPanic(GeneratorKind),\n-}\n-\n-/// Type for MIR `Assert` terminator error messages.\n-pub type AssertMessage<'tcx> = PanicInfo<mir::Operand<'tcx>>;\n-\n-impl<O> PanicInfo<O> {\n-    /// Getting a description does not require `O` to be printable, and does not\n-    /// require allocation.\n-    /// The caller is expected to handle `Panic` and `BoundsCheck` separately.\n-    pub fn description(&self) -> &'static str {\n-        use PanicInfo::*;\n-        match self {\n-            Overflow(mir::BinOp::Add) => \"attempt to add with overflow\",\n-            Overflow(mir::BinOp::Sub) => \"attempt to subtract with overflow\",\n-            Overflow(mir::BinOp::Mul) => \"attempt to multiply with overflow\",\n-            Overflow(mir::BinOp::Div) => \"attempt to divide with overflow\",\n-            Overflow(mir::BinOp::Rem) => \"attempt to calculate the remainder with overflow\",\n-            OverflowNeg => \"attempt to negate with overflow\",\n-            Overflow(mir::BinOp::Shr) => \"attempt to shift right with overflow\",\n-            Overflow(mir::BinOp::Shl) => \"attempt to shift left with overflow\",\n-            Overflow(op) => bug!(\"{:?} cannot overflow\", op),\n-            DivisionByZero => \"attempt to divide by zero\",\n-            RemainderByZero => \"attempt to calculate the remainder with a divisor of zero\",\n-            ResumedAfterReturn(GeneratorKind::Gen) => \"generator resumed after completion\",\n-            ResumedAfterReturn(GeneratorKind::Async(_)) => \"`async fn` resumed after completion\",\n-            ResumedAfterPanic(GeneratorKind::Gen) => \"generator resumed after panicking\",\n-            ResumedAfterPanic(GeneratorKind::Async(_)) => \"`async fn` resumed after panicking\",\n-            Panic { .. } | BoundsCheck { .. } => bug!(\"Unexpected PanicInfo\"),\n-        }\n-    }\n-}\n-\n-impl<O: fmt::Debug> fmt::Debug for PanicInfo<O> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use PanicInfo::*;\n-        match self {\n-            Panic { ref msg, line, col, ref file } => {\n-                write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col)\n-            }\n-            BoundsCheck { ref len, ref index } => {\n-                write!(f, \"index out of bounds: the len is {:?} but the index is {:?}\", len, index)\n-            }\n-            _ => write!(f, \"{}\", self.description()),\n-        }\n-    }\n-}\n-\n /// Error information for when the program we executed turned out not to actually be a valid\n /// program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp\n /// where we work on generic code or execution does not have all information available.\n@@ -599,8 +576,6 @@ impl fmt::Debug for ResourceExhaustionInfo {\n }\n \n pub enum InterpError<'tcx> {\n-    /// The program panicked.\n-    Panic(PanicInfo<u64>),\n     /// The program caused undefined behavior.\n     UndefinedBehavior(UndefinedBehaviorInfo),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n@@ -633,8 +608,7 @@ impl fmt::Debug for InterpError<'_> {\n             InvalidProgram(ref msg) => write!(f, \"{:?}\", msg),\n             UndefinedBehavior(ref msg) => write!(f, \"{:?}\", msg),\n             ResourceExhaustion(ref msg) => write!(f, \"{:?}\", msg),\n-            Panic(ref msg) => write!(f, \"{:?}\", msg),\n-            MachineStop(_) => write!(f, \"machine caused execution to stop\"),\n+            MachineStop(_) => bug!(\"unhandled MachineStop\"),\n         }\n     }\n }"}, {"sha": "c62f9a049a050f6d09e943bd378df23645a7b3fd", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -37,15 +37,6 @@ macro_rules! err_ub_format {\n     ($($tt:tt)*) => { err_ub!(Ub(format!($($tt)*))) };\n }\n \n-#[macro_export]\n-macro_rules! err_panic {\n-    ($($tt:tt)*) => {\n-        $crate::mir::interpret::InterpError::Panic(\n-            $crate::mir::interpret::PanicInfo::$($tt)*\n-        )\n-    };\n-}\n-\n #[macro_export]\n macro_rules! err_exhaust {\n     ($($tt:tt)*) => {\n@@ -80,11 +71,6 @@ macro_rules! throw_ub_format {\n     ($($tt:tt)*) => { throw_ub!(Ub(format!($($tt)*))) };\n }\n \n-#[macro_export]\n-macro_rules! throw_panic {\n-    ($($tt:tt)*) => { return Err(err_panic!($($tt)*).into()) };\n-}\n-\n #[macro_export]\n macro_rules! throw_exhaust {\n     ($($tt:tt)*) => { return Err(err_exhaust!($($tt)*).into()) };\n@@ -104,9 +90,9 @@ mod queries;\n mod value;\n \n pub use self::error::{\n-    struct_error, AssertMessage, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled,\n-    FrameInfo, InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, PanicInfo,\n-    ResourceExhaustionInfo, UndefinedBehaviorInfo, UnsupportedOpInfo,\n+    struct_error, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled, FrameInfo,\n+    InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, ResourceExhaustionInfo,\n+    UndefinedBehaviorInfo, UnsupportedOpInfo,\n };\n \n pub use self::value::{get_slice_bytes, ConstValue, RawConst, Scalar, ScalarMaybeUndef};\n@@ -162,6 +148,10 @@ pub struct LitToConstInput<'tcx> {\n /// Error type for `tcx.lit_to_const`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, HashStable)]\n pub enum LitToConstError {\n+    /// The literal's inferred type did not match the expected `ty` in the input.\n+    /// This is used for graceful error handling (`delay_span_bug`) in\n+    /// type checking (`AstConv::ast_const_to_const`).\n+    TypeError,\n     UnparseableFloat,\n     Reported,\n }"}, {"sha": "2c146b5d7b42647b3ca95de088976a9331e16ebc", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -7,7 +7,7 @@ use std::fmt;\n \n use crate::ty::{\n     layout::{HasDataLayout, Size},\n-    Ty,\n+    ParamEnv, Ty, TyCtxt,\n };\n \n use super::{sign_extend, truncate, AllocId, Allocation, InterpResult, Pointer, PointerArithmetic};\n@@ -66,6 +66,32 @@ impl<'tcx> ConstValue<'tcx> {\n             ConstValue::Scalar(val) => Some(val),\n         }\n     }\n+\n+    pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n+        self.try_to_scalar()?.to_bits(size).ok()\n+    }\n+\n+    pub fn try_to_bits_for_ty(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Option<u128> {\n+        let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n+        self.try_to_bits(size)\n+    }\n+\n+    pub fn from_bool(b: bool) -> Self {\n+        ConstValue::Scalar(Scalar::from_bool(b))\n+    }\n+\n+    pub fn from_u64(i: u64) -> Self {\n+        ConstValue::Scalar(Scalar::from_u64(i))\n+    }\n+\n+    pub fn from_machine_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n+        ConstValue::Scalar(Scalar::from_machine_usize(i, cx))\n+    }\n }\n \n /// A `Scalar` represents an immediate, primitive value existing outside of a\n@@ -287,6 +313,11 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Scalar::Raw { data: i as u128, size: 8 }\n     }\n \n+    #[inline]\n+    pub fn from_machine_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n+        Self::from_uint(i, cx.data_layout().pointer_size)\n+    }\n+\n     #[inline]\n     pub fn try_from_int(i: impl Into<i128>, size: Size) -> Option<Self> {\n         let i = i.into();\n@@ -306,6 +337,11 @@ impl<'tcx, Tag> Scalar<Tag> {\n             .unwrap_or_else(|| bug!(\"Signed value {:#x} does not fit in {} bits\", i, size.bits()))\n     }\n \n+    #[inline]\n+    pub fn from_machine_isize(i: i64, cx: &impl HasDataLayout) -> Self {\n+        Self::from_int(i, cx.data_layout().pointer_size)\n+    }\n+\n     #[inline]\n     pub fn from_f32(f: Single) -> Self {\n         // We trust apfloat to give us properly truncated data."}, {"sha": "9b94f92acd4760caa4b6a75fa12ed8b9d580e0d0", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 67, "deletions": 16, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -2,7 +2,7 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/index.html\n \n-use crate::mir::interpret::{GlobalAlloc, PanicInfo, Scalar};\n+use crate::mir::interpret::{GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -36,7 +36,6 @@ pub use syntax::ast::Mutability;\n use syntax::ast::Name;\n \n pub use self::cache::{BodyAndCache, ReadOnlyBodyAndCache};\n-pub use self::interpret::AssertMessage;\n pub use self::query::*;\n pub use crate::read_only;\n \n@@ -1154,6 +1153,21 @@ pub enum TerminatorKind<'tcx> {\n     },\n }\n \n+/// Information about an assertion failure.\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n+pub enum AssertKind<O> {\n+    BoundsCheck { len: O, index: O },\n+    Overflow(BinOp),\n+    OverflowNeg,\n+    DivisionByZero,\n+    RemainderByZero,\n+    ResumedAfterReturn(GeneratorKind),\n+    ResumedAfterPanic(GeneratorKind),\n+}\n+\n+/// Type for MIR `Assert` terminator error messages.\n+pub type AssertMessage<'tcx> = AssertKind<Operand<'tcx>>;\n+\n pub type Successors<'a> =\n     iter::Chain<option::IntoIter<&'a BasicBlock>, slice::Iter<'a, BasicBlock>>;\n pub type SuccessorsMut<'a> =\n@@ -1383,6 +1397,45 @@ impl<'tcx> BasicBlockData<'tcx> {\n     }\n }\n \n+impl<O> AssertKind<O> {\n+    /// Getting a description does not require `O` to be printable, and does not\n+    /// require allocation.\n+    /// The caller is expected to handle `BoundsCheck` separately.\n+    pub fn description(&self) -> &'static str {\n+        use AssertKind::*;\n+        match self {\n+            Overflow(BinOp::Add) => \"attempt to add with overflow\",\n+            Overflow(BinOp::Sub) => \"attempt to subtract with overflow\",\n+            Overflow(BinOp::Mul) => \"attempt to multiply with overflow\",\n+            Overflow(BinOp::Div) => \"attempt to divide with overflow\",\n+            Overflow(BinOp::Rem) => \"attempt to calculate the remainder with overflow\",\n+            OverflowNeg => \"attempt to negate with overflow\",\n+            Overflow(BinOp::Shr) => \"attempt to shift right with overflow\",\n+            Overflow(BinOp::Shl) => \"attempt to shift left with overflow\",\n+            Overflow(op) => bug!(\"{:?} cannot overflow\", op),\n+            DivisionByZero => \"attempt to divide by zero\",\n+            RemainderByZero => \"attempt to calculate the remainder with a divisor of zero\",\n+            ResumedAfterReturn(GeneratorKind::Gen) => \"generator resumed after completion\",\n+            ResumedAfterReturn(GeneratorKind::Async(_)) => \"`async fn` resumed after completion\",\n+            ResumedAfterPanic(GeneratorKind::Gen) => \"generator resumed after panicking\",\n+            ResumedAfterPanic(GeneratorKind::Async(_)) => \"`async fn` resumed after panicking\",\n+            BoundsCheck { .. } => bug!(\"Unexpected AssertKind\"),\n+        }\n+    }\n+}\n+\n+impl<O: fmt::Debug> fmt::Debug for AssertKind<O> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use AssertKind::*;\n+        match self {\n+            BoundsCheck { ref len, ref index } => {\n+                write!(f, \"index out of bounds: the len is {:?} but the index is {:?}\", len, index)\n+            }\n+            _ => write!(f, \"{}\", self.description()),\n+        }\n+    }\n+}\n+\n impl<'tcx> Debug for TerminatorKind<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         self.fmt_head(fmt)?;\n@@ -1415,21 +1468,21 @@ impl<'tcx> TerminatorKind<'tcx> {\n     /// successors, which may be rendered differently between the text and the graphviz format.\n     pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> fmt::Result {\n         use self::TerminatorKind::*;\n-        match *self {\n+        match self {\n             Goto { .. } => write!(fmt, \"goto\"),\n-            SwitchInt { discr: ref place, .. } => write!(fmt, \"switchInt({:?})\", place),\n+            SwitchInt { discr, .. } => write!(fmt, \"switchInt({:?})\", discr),\n             Return => write!(fmt, \"return\"),\n             GeneratorDrop => write!(fmt, \"generator_drop\"),\n             Resume => write!(fmt, \"resume\"),\n             Abort => write!(fmt, \"abort\"),\n-            Yield { ref value, .. } => write!(fmt, \"_1 = suspend({:?})\", value),\n+            Yield { value, resume_arg, .. } => write!(fmt, \"{:?} = yield({:?})\", resume_arg, value),\n             Unreachable => write!(fmt, \"unreachable\"),\n-            Drop { ref location, .. } => write!(fmt, \"drop({:?})\", location),\n-            DropAndReplace { ref location, ref value, .. } => {\n+            Drop { location, .. } => write!(fmt, \"drop({:?})\", location),\n+            DropAndReplace { location, value, .. } => {\n                 write!(fmt, \"replace({:?} <- {:?})\", location, value)\n             }\n-            Call { ref func, ref args, ref destination, .. } => {\n-                if let Some((ref destination, _)) = *destination {\n+            Call { func, args, destination, .. } => {\n+                if let Some((destination, _)) = destination {\n                     write!(fmt, \"{:?} = \", destination)?;\n                 }\n                 write!(fmt, \"{:?}(\", func)?;\n@@ -1441,7 +1494,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 }\n                 write!(fmt, \")\")\n             }\n-            Assert { ref cond, expected, ref msg, .. } => {\n+            Assert { cond, expected, msg, .. } => {\n                 write!(fmt, \"assert(\")?;\n                 if !expected {\n                     write!(fmt, \"!\")?;\n@@ -2666,13 +2719,12 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 }\n             }\n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                use PanicInfo::*;\n+                use AssertKind::*;\n                 let msg = match msg {\n                     BoundsCheck { ref len, ref index } => {\n                         BoundsCheck { len: len.fold_with(folder), index: index.fold_with(folder) }\n                     }\n-                    Panic { .. }\n-                    | Overflow(_)\n+                    Overflow(_)\n                     | OverflowNeg\n                     | DivisionByZero\n                     | RemainderByZero\n@@ -2716,13 +2768,12 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             }\n             Assert { ref cond, ref msg, .. } => {\n                 if cond.visit_with(visitor) {\n-                    use PanicInfo::*;\n+                    use AssertKind::*;\n                     match msg {\n                         BoundsCheck { ref len, ref index } => {\n                             len.visit_with(visitor) || index.visit_with(visitor)\n                         }\n-                        Panic { .. }\n-                        | Overflow(_)\n+                        Overflow(_)\n                         | OverflowNeg\n                         | DivisionByZero\n                         | RemainderByZero"}, {"sha": "9a3ddfb0e82c9f583cf75c3357eec00379651a1b", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -362,7 +362,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn codegen_dep_node(&self, tcx: TyCtxt<'tcx>) -> DepNode {\n-        DepNode::new(tcx, DepConstructor::CompileCodegenUnit(self.name()))\n+        DepConstructor::CompileCodegenUnit(tcx, self.name())\n     }\n }\n "}, {"sha": "824cdfe55bfb65ec4d24e0dbce4eebf4b8d7757a", "filename": "src/librustc/mir/query.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fquery.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,8 +1,10 @@\n //! Values computed by queries that use MIR.\n \n use crate::ty::{self, Ty};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::IndexVec;\n use rustc_span::{Span, Symbol};\n@@ -59,8 +61,12 @@ pub struct GeneratorLayout<'tcx> {\n     pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct BorrowCheckResult<'tcx> {\n+    /// All the opaque types that are restricted to concrete types\n+    /// by this function. Unlike the value in `TypeckTables`, this has\n+    /// unerased regions.\n+    pub concrete_opaque_types: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n     pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n }"}, {"sha": "409c981801b34aa329bd69ad28009b4b4dbfddb8", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -519,12 +519,12 @@ macro_rules! make_mir_visitor {\n                         resume_arg,\n                         drop: _,\n                     } => {\n+                        self.visit_operand(value, source_location);\n                         self.visit_place(\n                             resume_arg,\n                             PlaceContext::MutatingUse(MutatingUseContext::Store),\n                             source_location,\n                         );\n-                        self.visit_operand(value, source_location);\n                     }\n \n                 }\n@@ -533,13 +533,13 @@ macro_rules! make_mir_visitor {\n             fn super_assert_message(&mut self,\n                                     msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n-                use crate::mir::interpret::PanicInfo::*;\n+                use crate::mir::AssertKind::*;\n                 match msg {\n                     BoundsCheck { len, index } => {\n                         self.visit_operand(len, location);\n                         self.visit_operand(index, location);\n                     }\n-                    Panic { .. } | Overflow(_) | OverflowNeg | DivisionByZero | RemainderByZero |\n+                    Overflow(_) | OverflowNeg | DivisionByZero | RemainderByZero |\n                     ResumedAfterReturn(_) | ResumedAfterPanic(_) => {\n                         // Nothing to visit\n                     }"}, {"sha": "02c51a2ebb0e9a6befb7a345695ef9513c7b6bdf", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -125,7 +125,9 @@ rustc_queries! {\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n-        query mir_built(_: DefId) -> &'tcx Steal<mir::BodyAndCache<'tcx>> {}\n+        query mir_built(_: DefId) -> &'tcx Steal<mir::BodyAndCache<'tcx>> {\n+            desc { \"building MIR for\" }\n+        }\n \n         /// Fetch the MIR for a given `DefId` up till the point where it is\n         /// ready for const evaluation.\n@@ -277,6 +279,14 @@ rustc_queries! {\n             desc { |tcx| \"checking if item is const fn: `{}`\", tcx.def_path_str(key) }\n         }\n \n+        /// Returns `true` if this is a const `impl`. **Do not call this function manually.**\n+        ///\n+        /// This query caches the base data for the `is_const_impl` helper function, which also\n+        /// takes into account stability attributes (e.g., `#[rustc_const_unstable]`).\n+        query is_const_impl_raw(key: DefId) -> bool {\n+            desc { |tcx| \"checking if item is const impl: `{}`\", tcx.def_path_str(key) }\n+        }\n+\n         query asyncness(key: DefId) -> hir::IsAsync {\n             desc { |tcx| \"checking if the function is async: `{}`\", tcx.def_path_str(key) }\n         }\n@@ -323,7 +333,7 @@ rustc_queries! {\n         query associated_item(_: DefId) -> ty::AssocItem {}\n \n         /// Collects the associated items defined on a trait or impl.\n-        query associated_items(key: DefId) -> ty::AssocItemsIterator<'tcx> {\n+        query associated_items(key: DefId) -> &'tcx ty::AssociatedItems {\n             desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n         }\n \n@@ -345,6 +355,7 @@ rustc_queries! {\n     TypeChecking {\n         /// The result of unsafety-checking this `DefId`.\n         query unsafety_check_result(key: DefId) -> mir::UnsafetyCheckResult {\n+            desc { |tcx| \"unsafety-checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }\n \n@@ -414,14 +425,8 @@ rustc_queries! {\n         }\n \n         query typeck_tables_of(key: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n+            desc { |tcx| \"type-checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n-            load_cached(tcx, id) {\n-                let typeck_tables: Option<ty::TypeckTables<'tcx>> = tcx\n-                    .queries.on_disk_cache\n-                    .try_load_query_result(tcx, id);\n-\n-                typeck_tables.map(|tables| &*tcx.arena.alloc(tables))\n-            }\n         }\n         query diagnostic_only_typeck_tables_of(key: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n             cache_on_disk_if { key.is_local() }\n@@ -452,8 +457,13 @@ rustc_queries! {\n     BorrowChecking {\n         /// Borrow-checks the function body. If this is a closure, returns\n         /// additional requirements that the closure's creator must verify.\n-        query mir_borrowck(key: DefId) -> mir::BorrowCheckResult<'tcx> {\n-            cache_on_disk_if(tcx, _) { key.is_local() && tcx.is_closure(key) }\n+        query mir_borrowck(key: DefId) -> &'tcx mir::BorrowCheckResult<'tcx> {\n+            desc { |tcx| \"borrow-checking `{}`\", tcx.def_path_str(key) }\n+            cache_on_disk_if(tcx, opt_result) {\n+                key.is_local()\n+                    && (tcx.is_closure(key)\n+                        || opt_result.map_or(false, |r| !r.concrete_opaque_types.is_empty()))\n+            }\n         }\n     }\n \n@@ -517,7 +527,7 @@ rustc_queries! {\n         /// Extracts a field of a (variant of a) const.\n         query const_field(\n             key: ty::ParamEnvAnd<'tcx, (&'tcx ty::Const<'tcx>, mir::Field)>\n-        ) -> &'tcx ty::Const<'tcx> {\n+        ) -> ConstValue<'tcx> {\n             no_force\n             desc { \"extract field of const\" }\n         }\n@@ -531,7 +541,7 @@ rustc_queries! {\n             desc { \"destructure constant\" }\n         }\n \n-        query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> &'tcx ty::Const<'tcx> {\n+        query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n             no_force\n             desc { \"get a &core::panic::Location referring to a span\" }\n         }\n@@ -647,10 +657,11 @@ rustc_queries! {\n         query trait_impls_of(key: DefId) -> &'tcx ty::trait_def::TraitImpls {\n             desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(key) }\n         }\n-        query specialization_graph_of(_: DefId) -> &'tcx specialization_graph::Graph {\n+        query specialization_graph_of(key: DefId) -> &'tcx specialization_graph::Graph {\n+            desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { true }\n         }\n-        query is_object_safe(key: DefId) -> bool {\n+        query object_safety_violations(key: DefId) -> Vec<traits::ObjectSafetyViolation> {\n             desc { |tcx| \"determine object safety of trait `{}`\", tcx.def_path_str(key) }\n         }\n \n@@ -668,26 +679,29 @@ rustc_queries! {\n             no_force\n             desc { \"computing whether `{}` is `Copy`\", env.value }\n         }\n+        /// Query backing `TyS::is_sized`.\n         query is_sized_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n             no_force\n             desc { \"computing whether `{}` is `Sized`\", env.value }\n         }\n+        /// Query backing `TyS::is_freeze`.\n         query is_freeze_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n             no_force\n             desc { \"computing whether `{}` is freeze\", env.value }\n         }\n-\n-        // The cycle error here should be reported as an error by `check_representable`.\n-        // We consider the type as not needing drop in the meanwhile to avoid\n-        // further errors (done in impl Value for NeedsDrop).\n-        // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n-        // in case we accidentally otherwise don't emit an error.\n-        query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n-            cycle_delay_bug\n+        /// Query backing `TyS::needs_drop`.\n+        query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n             no_force\n             desc { \"computing whether `{}` needs drop\", env.value }\n         }\n \n+        /// A list of types where the ADT requires drop if and only if any of\n+        /// those types require drop. If the ADT is known to always need drop\n+        /// then `Err(AlwaysRequiresDrop)` is returned.\n+        query adt_drop_tys(_: DefId) -> Result<&'tcx ty::List<Ty<'tcx>>, AlwaysRequiresDrop> {\n+            cache_on_disk_if { true }\n+        }\n+\n         query layout_raw(\n             env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n         ) -> Result<&'tcx ty::layout::LayoutDetails, ty::layout::LayoutError<'tcx>> {"}, {"sha": "08c3a77bf3aca5ff78fd5654d97770d3d68848c9", "filename": "src/librustc/traits/misc.rs", "status": "removed", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Flibrustc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Flibrustc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmisc.rs?ref=e7a344fb745a0a663e21be947b2619df05df6d31", "patch": "@@ -1,202 +0,0 @@\n-//! Miscellaneous type-system utilities that are too small to deserve their own modules.\n-\n-use crate::middle::lang_items;\n-use crate::traits::{self, ObligationCause};\n-use crate::ty::util::NeedsDrop;\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n-\n-use rustc_hir as hir;\n-use rustc_span::DUMMY_SP;\n-\n-#[derive(Clone)]\n-pub enum CopyImplementationError<'tcx> {\n-    InfrigingFields(Vec<&'tcx ty::FieldDef>),\n-    NotAnAdt,\n-    HasDestructor,\n-}\n-\n-pub fn can_type_implement_copy(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    self_type: Ty<'tcx>,\n-) -> Result<(), CopyImplementationError<'tcx>> {\n-    // FIXME: (@jroesch) float this code up\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let (adt, substs) = match self_type.kind {\n-            // These types used to have a builtin impl.\n-            // Now libcore provides that impl.\n-            ty::Uint(_)\n-            | ty::Int(_)\n-            | ty::Bool\n-            | ty::Float(_)\n-            | ty::Char\n-            | ty::RawPtr(..)\n-            | ty::Never\n-            | ty::Ref(_, _, hir::Mutability::Not) => return Ok(()),\n-\n-            ty::Adt(adt, substs) => (adt, substs),\n-\n-            _ => return Err(CopyImplementationError::NotAnAdt),\n-        };\n-\n-        let mut infringing = Vec::new();\n-        for variant in &adt.variants {\n-            for field in &variant.fields {\n-                let ty = field.ty(tcx, substs);\n-                if ty.references_error() {\n-                    continue;\n-                }\n-                let span = tcx.def_span(field.did);\n-                let cause = ObligationCause { span, ..ObligationCause::dummy() };\n-                let ctx = traits::FulfillmentContext::new();\n-                match traits::fully_normalize(&infcx, ctx, cause, param_env, &ty) {\n-                    Ok(ty) => {\n-                        if !infcx.type_is_copy_modulo_regions(param_env, ty, span) {\n-                            infringing.push(field);\n-                        }\n-                    }\n-                    Err(errors) => {\n-                        infcx.report_fulfillment_errors(&errors, None, false);\n-                    }\n-                };\n-            }\n-        }\n-        if !infringing.is_empty() {\n-            return Err(CopyImplementationError::InfrigingFields(infringing));\n-        }\n-        if adt.has_dtor(tcx) {\n-            return Err(CopyImplementationError::HasDestructor);\n-        }\n-\n-        Ok(())\n-    })\n-}\n-\n-fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::CopyTraitLangItem)\n-}\n-\n-fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::SizedTraitLangItem)\n-}\n-\n-fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::FreezeTraitLangItem)\n-}\n-\n-fn is_item_raw<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    item: lang_items::LangItem,\n-) -> bool {\n-    let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(item, None);\n-    tcx.infer_ctxt().enter(|infcx| {\n-        traits::type_known_to_meet_bound_modulo_regions(\n-            &infcx,\n-            param_env,\n-            ty,\n-            trait_def_id,\n-            DUMMY_SP,\n-        )\n-    })\n-}\n-\n-fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n-    let (param_env, ty) = query.into_parts();\n-\n-    let needs_drop = |ty: Ty<'tcx>| -> bool { tcx.needs_drop_raw(param_env.and(ty)).0 };\n-\n-    assert!(!ty.needs_infer());\n-\n-    NeedsDrop(match ty.kind {\n-        // Fast-path for primitive types\n-        ty::Infer(ty::FreshIntTy(_))\n-        | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Bool\n-        | ty::Int(_)\n-        | ty::Uint(_)\n-        | ty::Float(_)\n-        | ty::Never\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::Char\n-        | ty::GeneratorWitness(..)\n-        | ty::RawPtr(_)\n-        | ty::Ref(..)\n-        | ty::Str => false,\n-\n-        // Foreign types can never have destructors\n-        ty::Foreign(..) => false,\n-\n-        // `ManuallyDrop` doesn't have a destructor regardless of field types.\n-        ty::Adt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n-\n-        // Issue #22536: We first query `is_copy_modulo_regions`.  It sees a\n-        // normalized version of the type, and therefore will definitely\n-        // know whether the type implements Copy (and thus needs no\n-        // cleanup/drop/zeroing) ...\n-        _ if ty.is_copy_modulo_regions(tcx, param_env, DUMMY_SP) => false,\n-\n-        // ... (issue #22536 continued) but as an optimization, still use\n-        // prior logic of asking for the structural \"may drop\".\n-\n-        // FIXME(#22815): Note that this is a conservative heuristic;\n-        // it may report that the type \"may drop\" when actual type does\n-        // not actually have a destructor associated with it. But since\n-        // the type absolutely did not have the `Copy` bound attached\n-        // (see above), it is sound to treat it as having a destructor.\n-\n-        // User destructors are the only way to have concrete drop types.\n-        ty::Adt(def, _) if def.has_dtor(tcx) => true,\n-\n-        // Can refer to a type which may drop.\n-        // FIXME(eddyb) check this against a ParamEnv.\n-        ty::Dynamic(..)\n-        | ty::Projection(..)\n-        | ty::Param(_)\n-        | ty::Bound(..)\n-        | ty::Placeholder(..)\n-        | ty::Opaque(..)\n-        | ty::Infer(_)\n-        | ty::Error => true,\n-\n-        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-\n-        // Zero-length arrays never contain anything to drop.\n-        ty::Array(_, len) if len.try_eval_usize(tcx, param_env) == Some(0) => false,\n-\n-        // Structural recursion.\n-        ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),\n-\n-        ty::Closure(def_id, ref substs) => {\n-            substs.as_closure().upvar_tys(def_id, tcx).any(needs_drop)\n-        }\n-\n-        // Pessimistically assume that all generators will require destructors\n-        // as we don't know if a destructor is a noop or not until after the MIR\n-        // state transformation pass\n-        ty::Generator(..) => true,\n-\n-        ty::Tuple(..) => ty.tuple_fields().any(needs_drop),\n-\n-        // unions don't have destructors because of the child types,\n-        // only if they manually implement `Drop` (handled above).\n-        ty::Adt(def, _) if def.is_union() => false,\n-\n-        ty::Adt(def, substs) => def\n-            .variants\n-            .iter()\n-            .any(|variant| variant.fields.iter().any(|field| needs_drop(field.ty(tcx, substs)))),\n-    })\n-}\n-\n-pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    *providers = ty::query::Providers {\n-        is_copy_raw,\n-        is_sized_raw,\n-        is_freeze_raw,\n-        needs_drop_raw,\n-        ..*providers\n-    };\n-}"}, {"sha": "de2ec53e51e788a93d0734309c5b006d6cbb8d55", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 816, "deletions": 595, "changes": 1411, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -2,649 +2,870 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n \n-#[allow(dead_code)]\n-pub mod auto_trait;\n-mod chalk_fulfill;\n-pub mod codegen;\n-mod coherence;\n-mod engine;\n-pub mod error_reporting;\n-mod fulfill;\n-pub mod misc;\n-mod object_safety;\n-mod on_unimplemented;\n-mod project;\n pub mod query;\n-mod select;\n-mod specialize;\n+pub mod select;\n+pub mod specialization_graph;\n mod structural_impls;\n-mod structural_match;\n-mod types;\n-mod util;\n-pub mod wf;\n-\n-use crate::infer::outlives::env::OutlivesEnvironment;\n-use crate::infer::{InferCtxt, SuppressRegionErrors};\n-use crate::middle::region;\n-use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::subst::{InternalSubsts, SubstsRef};\n-use crate::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, WithConstness};\n-use crate::util::common::ErrorReported;\n+\n+use crate::infer::canonical::Canonical;\n+use crate::mir::interpret::ErrorHandled;\n+use crate::ty::fold::{TypeFolder, TypeVisitor};\n+use crate::ty::subst::SubstsRef;\n+use crate::ty::{self, AdtKind, List, Ty, TyCtxt};\n+\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::{Span, DUMMY_SP};\n+use smallvec::SmallVec;\n+use syntax::ast;\n \n+use std::borrow::Cow;\n use std::fmt::Debug;\n+use std::rc::Rc;\n+\n+pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, SelectionCache};\n+\n+pub type ChalkCanonicalGoal<'tcx> = Canonical<'tcx, InEnvironment<'tcx, ty::Predicate<'tcx>>>;\n+\n+pub use self::ObligationCauseCode::*;\n+pub use self::SelectionError::*;\n+pub use self::Vtable::*;\n+\n+/// Depending on the stage of compilation, we want projection to be\n+/// more or less conservative.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, HashStable)]\n+pub enum Reveal {\n+    /// At type-checking time, we refuse to project any associated\n+    /// type that is marked `default`. Non-`default` (\"final\") types\n+    /// are always projected. This is necessary in general for\n+    /// soundness of specialization. However, we *could* allow\n+    /// projections in fully-monomorphic cases. We choose not to,\n+    /// because we prefer for `default type` to force the type\n+    /// definition to be treated abstractly by any consumers of the\n+    /// impl. Concretely, that means that the following example will\n+    /// fail to compile:\n+    ///\n+    /// ```\n+    /// trait Assoc {\n+    ///     type Output;\n+    /// }\n+    ///\n+    /// impl<T> Assoc for T {\n+    ///     default type Output = bool;\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let <() as Assoc>::Output = true;\n+    /// }\n+    /// ```\n+    UserFacing,\n+\n+    /// At codegen time, all monomorphic projections will succeed.\n+    /// Also, `impl Trait` is normalized to the concrete type,\n+    /// which has to be already collected by type-checking.\n+    ///\n+    /// NOTE: as `impl Trait`'s concrete type should *never*\n+    /// be observable directly by the user, `Reveal::All`\n+    /// should not be used by checks which may expose\n+    /// type equality or type contents to the user.\n+    /// There are some exceptions, e.g., around OIBITS and\n+    /// transmute-checking, which expose some details, but\n+    /// not the whole concrete type of the `impl Trait`.\n+    All,\n+}\n+\n+/// The reason why we incurred this obligation; used for error reporting.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct ObligationCause<'tcx> {\n+    pub span: Span,\n+\n+    /// The ID of the fn body that triggered this obligation. This is\n+    /// used for region obligations to determine the precise\n+    /// environment in which the region obligation should be evaluated\n+    /// (in particular, closures can add new assumptions). See the\n+    /// field `region_obligations` of the `FulfillmentContext` for more\n+    /// information.\n+    pub body_id: hir::HirId,\n \n-pub use self::FulfillmentErrorCode::*;\n-\n-pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n-pub use self::coherence::{OrphanCheckErr, OverlapResult};\n-pub use self::engine::{TraitEngine, TraitEngineExt};\n-pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n-pub use self::object_safety::astconv_object_safety_violations;\n-pub use self::object_safety::is_vtable_safe_method;\n-pub use self::object_safety::object_safety_violations;\n-pub use self::object_safety::MethodViolationCode;\n-pub use self::object_safety::ObjectSafetyViolation;\n-pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n-pub use self::project::MismatchedProjectionTypes;\n-pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n-pub use self::project::{Normalized, ProjectionCache, ProjectionCacheSnapshot};\n-pub use self::select::{IntercrateAmbiguityCause, SelectionContext};\n-pub use self::specialize::find_associated_item;\n-pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n-pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n-pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n-pub use self::structural_match::search_for_structural_match_violation;\n-pub use self::structural_match::type_marked_structural;\n-pub use self::structural_match::NonStructuralMatchTy;\n-pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n-pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n-pub use self::util::{\n-    get_vtable_index_of_object_method, impl_is_default, impl_item_is_final,\n-    predicate_for_trait_def, upcast_choices,\n-};\n-pub use self::util::{\n-    supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n-};\n-\n-pub use self::chalk_fulfill::{\n-    CanonicalGoal as ChalkCanonicalGoal, FulfillmentContext as ChalkFulfillmentContext,\n-};\n-\n-pub use self::types::*;\n-\n-/// Whether to enable bug compatibility with issue #43355.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum IntercrateMode {\n-    Issue43355,\n-    Fixed,\n-}\n-\n-/// Whether to skip the leak check, as part of a future compatibility warning step.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum SkipLeakCheck {\n-    Yes,\n-    No,\n-}\n-\n-impl SkipLeakCheck {\n-    fn is_yes(self) -> bool {\n-        self == SkipLeakCheck::Yes\n+    pub code: ObligationCauseCode<'tcx>,\n+}\n+\n+impl<'tcx> ObligationCause<'tcx> {\n+    #[inline]\n+    pub fn new(\n+        span: Span,\n+        body_id: hir::HirId,\n+        code: ObligationCauseCode<'tcx>,\n+    ) -> ObligationCause<'tcx> {\n+        ObligationCause { span, body_id, code }\n+    }\n+\n+    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n+        ObligationCause { span, body_id, code: MiscObligation }\n+    }\n+\n+    pub fn dummy() -> ObligationCause<'tcx> {\n+        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: MiscObligation }\n+    }\n+\n+    pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n+        match self.code {\n+            ObligationCauseCode::CompareImplMethodObligation { .. }\n+            | ObligationCauseCode::MainFunctionType\n+            | ObligationCauseCode::StartFunctionType => tcx.sess.source_map().def_span(self.span),\n+            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                arm_span,\n+                ..\n+            }) => arm_span,\n+            _ => self.span,\n+        }\n     }\n }\n \n-/// The \"default\" for skip-leak-check corresponds to the current\n-/// behavior (do not skip the leak check) -- not the behavior we are\n-/// transitioning into.\n-impl Default for SkipLeakCheck {\n-    fn default() -> Self {\n-        SkipLeakCheck::No\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum ObligationCauseCode<'tcx> {\n+    /// Not well classified or should be obvious from the span.\n+    MiscObligation,\n+\n+    /// A slice or array is WF only if `T: Sized`.\n+    SliceOrArrayElem,\n+\n+    /// A tuple is WF only if its middle elements are `Sized`.\n+    TupleElem,\n+\n+    /// This is the trait reference from the given projection.\n+    ProjectionWf(ty::ProjectionTy<'tcx>),\n+\n+    /// In an impl of trait `X` for type `Y`, type `Y` must\n+    /// also implement all supertraits of `X`.\n+    ItemObligation(DefId),\n+\n+    /// Like `ItemObligation`, but with extra detail on the source of the obligation.\n+    BindingObligation(DefId, Span),\n+\n+    /// A type like `&'a T` is WF only if `T: 'a`.\n+    ReferenceOutlivesReferent(Ty<'tcx>),\n+\n+    /// A type like `Box<Foo<'a> + 'b>` is WF only if `'b: 'a`.\n+    ObjectTypeBound(Ty<'tcx>, ty::Region<'tcx>),\n+\n+    /// Obligation incurred due to an object cast.\n+    ObjectCastObligation(/* Object type */ Ty<'tcx>),\n+\n+    /// Obligation incurred due to a coercion.\n+    Coercion {\n+        source: Ty<'tcx>,\n+        target: Ty<'tcx>,\n+    },\n+\n+    /// Various cases where expressions must be `Sized` / `Copy` / etc.\n+    /// `L = X` implies that `L` is `Sized`.\n+    AssignmentLhsSized,\n+    /// `(x1, .., xn)` must be `Sized`.\n+    TupleInitializerSized,\n+    /// `S { ... }` must be `Sized`.\n+    StructInitializerSized,\n+    /// Type of each variable must be `Sized`.\n+    VariableType(hir::HirId),\n+    /// Argument type must be `Sized`.\n+    SizedArgumentType,\n+    /// Return type must be `Sized`.\n+    SizedReturnType,\n+    /// Yield type must be `Sized`.\n+    SizedYieldType,\n+    /// `[T, ..n]` implies that `T` must be `Copy`.\n+    /// If `true`, suggest `const_in_array_repeat_expressions` feature flag.\n+    RepeatVec(bool),\n+\n+    /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n+    FieldSized {\n+        adt_kind: AdtKind,\n+        last: bool,\n+    },\n+\n+    /// Constant expressions must be sized.\n+    ConstSized,\n+\n+    /// `static` items must have `Sync` type.\n+    SharedStatic,\n+\n+    BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n+\n+    ImplDerivedObligation(DerivedObligationCause<'tcx>),\n+\n+    /// Error derived when matching traits/impls; see ObligationCause for more details\n+    CompareImplMethodObligation {\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    },\n+\n+    /// Error derived when matching traits/impls; see ObligationCause for more details\n+    CompareImplTypeObligation {\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    },\n+\n+    /// Checking that this expression can be assigned where it needs to be\n+    // FIXME(eddyb) #11161 is the original Expr required?\n+    ExprAssignable,\n+\n+    /// Computing common supertype in the arms of a match expression\n+    MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n+\n+    /// Type error arising from type checking a pattern against an expected type.\n+    Pattern {\n+        /// The span of the scrutinee or type expression which caused the `root_ty` type.\n+        span: Option<Span>,\n+        /// The root expected type induced by a scrutinee or type expression.\n+        root_ty: Ty<'tcx>,\n+        /// Whether the `Span` came from an expression or a type expression.\n+        origin_expr: bool,\n+    },\n+\n+    /// Constants in patterns must have `Structural` type.\n+    ConstPatternStructural,\n+\n+    /// Computing common supertype in an if expression\n+    IfExpression(Box<IfExpressionCause>),\n+\n+    /// Computing common supertype of an if expression with no else counter-part\n+    IfExpressionWithNoElse,\n+\n+    /// `main` has wrong type\n+    MainFunctionType,\n+\n+    /// `start` has wrong type\n+    StartFunctionType,\n+\n+    /// Intrinsic has wrong type\n+    IntrinsicType,\n+\n+    /// Method receiver\n+    MethodReceiver,\n+\n+    /// `return` with no expression\n+    ReturnNoExpression,\n+\n+    /// `return` with an expression\n+    ReturnValue(hir::HirId),\n+\n+    /// Return type of this function\n+    ReturnType,\n+\n+    /// Block implicit return\n+    BlockTailExpression(hir::HirId),\n+\n+    /// #[feature(trivial_bounds)] is not enabled\n+    TrivialBound,\n+\n+    AssocTypeBound(Box<AssocTypeBoundData>),\n+}\n+\n+impl ObligationCauseCode<'_> {\n+    // Return the base obligation, ignoring derived obligations.\n+    pub fn peel_derives(&self) -> &Self {\n+        let mut base_cause = self;\n+        while let BuiltinDerivedObligation(cause) | ImplDerivedObligation(cause) = base_cause {\n+            base_cause = &cause.parent_code;\n+        }\n+        base_cause\n     }\n }\n \n-/// The mode that trait queries run in.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum TraitQueryMode {\n-    // Standard/un-canonicalized queries get accurate\n-    // spans etc. passed in and hence can do reasonable\n-    // error reporting on their own.\n-    Standard,\n-    // Canonicalized queries get dummy spans and hence\n-    // must generally propagate errors to\n-    // pre-canonicalization callsites.\n-    Canonical,\n-}\n-\n-/// An `Obligation` represents some trait reference (e.g., `int: Eq`) for\n-/// which the vtable must be found. The process of finding a vtable is\n-/// called \"resolving\" the `Obligation`. This process consists of\n-/// either identifying an `impl` (e.g., `impl Eq for int`) that\n-/// provides the required vtable, or else finding a bound that is in\n-/// scope. The eventual result is usually a `Selection` (defined below).\n-#[derive(Clone, PartialEq, Eq, Hash)]\n-pub struct Obligation<'tcx, T> {\n-    /// The reason we have to prove this thing.\n-    pub cause: ObligationCause<'tcx>,\n-\n-    /// The environment in which we should prove this thing.\n-    pub param_env: ty::ParamEnv<'tcx>,\n-\n-    /// The thing we are trying to prove.\n-    pub predicate: T,\n-\n-    /// If we started proving this as a result of trying to prove\n-    /// something else, track the total depth to ensure termination.\n-    /// If this goes over a certain threshold, we abort compilation --\n-    /// in such cases, we can not say whether or not the predicate\n-    /// holds for certain. Stupid halting problem; such a drag.\n-    pub recursion_depth: usize,\n-}\n-\n-pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n-pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n-\n-// `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct AssocTypeBoundData {\n+    pub impl_span: Option<Span>,\n+    pub original: Span,\n+    pub bounds: Vec<Span>,\n+}\n+\n+// `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(PredicateObligation<'_>, 112);\n-\n-pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n-pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n-pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n-\n-pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n-\n-pub struct FulfillmentError<'tcx> {\n-    pub obligation: PredicateObligation<'tcx>,\n-    pub code: FulfillmentErrorCode<'tcx>,\n-    /// Diagnostics only: we opportunistically change the `code.span` when we encounter an\n-    /// obligation error caused by a call argument. When this is the case, we also signal that in\n-    /// this field to ensure accuracy of suggestions.\n-    pub points_at_arg_span: bool,\n-}\n-\n-#[derive(Clone)]\n-pub enum FulfillmentErrorCode<'tcx> {\n-    CodeSelectionError(SelectionError<'tcx>),\n-    CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n-    CodeSubtypeError(ExpectedFound<Ty<'tcx>>, TypeError<'tcx>), // always comes from a SubtypePredicate\n-    CodeAmbiguity,\n-}\n-\n-/// Creates predicate obligations from the generic bounds.\n-pub fn predicates_for_generics<'tcx>(\n-    cause: ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n-) -> PredicateObligations<'tcx> {\n-    util::predicates_for_generics(cause, 0, param_env, generic_bounds)\n-}\n-\n-/// Determines whether the type `ty` is known to meet `bound` and\n-/// returns true if so. Returns false if `ty` either does not meet\n-/// `bound` or is not known to meet bound (note that this is\n-/// conservative towards *no impl*, which is the opposite of the\n-/// `evaluate` methods).\n-pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-    def_id: DefId,\n-    span: Span,\n-) -> bool {\n-    debug!(\n-        \"type_known_to_meet_bound_modulo_regions(ty={:?}, bound={:?})\",\n-        ty,\n-        infcx.tcx.def_path_str(def_id)\n-    );\n-\n-    let trait_ref = ty::TraitRef { def_id, substs: infcx.tcx.mk_substs_trait(ty, &[]) };\n-    let obligation = Obligation {\n-        param_env,\n-        cause: ObligationCause::misc(span, hir::DUMMY_HIR_ID),\n-        recursion_depth: 0,\n-        predicate: trait_ref.without_const().to_predicate(),\n-    };\n-\n-    let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n-    debug!(\n-        \"type_known_to_meet_ty={:?} bound={} => {:?}\",\n-        ty,\n-        infcx.tcx.def_path_str(def_id),\n-        result\n-    );\n-\n-    if result && (ty.has_infer_types() || ty.has_closure_types()) {\n-        // Because of inference \"guessing\", selection can sometimes claim\n-        // to succeed while the success requires a guess. To ensure\n-        // this function's result remains infallible, we must confirm\n-        // that guess. While imperfect, I believe this is sound.\n-\n-        // The handling of regions in this area of the code is terrible,\n-        // see issue #29149. We should be able to improve on this with\n-        // NLL.\n-        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n-\n-        // We can use a dummy node-id here because we won't pay any mind\n-        // to region obligations that arise (there shouldn't really be any\n-        // anyhow).\n-        let cause = ObligationCause::misc(span, hir::DUMMY_HIR_ID);\n-\n-        fulfill_cx.register_bound(infcx, param_env, ty, def_id, cause);\n-\n-        // Note: we only assume something is `Copy` if we can\n-        // *definitively* show that it implements `Copy`. Otherwise,\n-        // assume it is move; linear is always ok.\n-        match fulfill_cx.select_all_or_error(infcx) {\n-            Ok(()) => {\n-                debug!(\n-                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n-                    ty,\n-                    infcx.tcx.def_path_str(def_id)\n-                );\n-                true\n-            }\n-            Err(e) => {\n-                debug!(\n-                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} errors={:?}\",\n-                    ty,\n-                    infcx.tcx.def_path_str(def_id),\n-                    e\n-                );\n-                false\n-            }\n+static_assert_size!(ObligationCauseCode<'_>, 32);\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct MatchExpressionArmCause<'tcx> {\n+    pub arm_span: Span,\n+    pub source: hir::MatchSource,\n+    pub prior_arms: Vec<Span>,\n+    pub last_ty: Ty<'tcx>,\n+    pub scrut_hir_id: hir::HirId,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct IfExpressionCause {\n+    pub then: Span,\n+    pub outer: Option<Span>,\n+    pub semicolon: Option<Span>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DerivedObligationCause<'tcx> {\n+    /// The trait reference of the parent obligation that led to the\n+    /// current obligation. Note that only trait obligations lead to\n+    /// derived obligations, so we just store the trait reference here\n+    /// directly.\n+    pub parent_trait_ref: ty::PolyTraitRef<'tcx>,\n+\n+    /// The parent trait had this cause.\n+    pub parent_code: Rc<ObligationCauseCode<'tcx>>,\n+}\n+\n+/// The following types:\n+/// * `WhereClause`,\n+/// * `WellFormed`,\n+/// * `FromEnv`,\n+/// * `DomainGoal`,\n+/// * `Goal`,\n+/// * `Clause`,\n+/// * `Environment`,\n+/// * `InEnvironment`,\n+/// are used for representing the trait system in the form of\n+/// logic programming clauses. They are part of the interface\n+/// for the chalk SLG solver.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum WhereClause<'tcx> {\n+    Implemented(ty::TraitPredicate<'tcx>),\n+    ProjectionEq(ty::ProjectionPredicate<'tcx>),\n+    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n+    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum WellFormed<'tcx> {\n+    Trait(ty::TraitPredicate<'tcx>),\n+    Ty(Ty<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum FromEnv<'tcx> {\n+    Trait(ty::TraitPredicate<'tcx>),\n+    Ty(Ty<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum DomainGoal<'tcx> {\n+    Holds(WhereClause<'tcx>),\n+    WellFormed(WellFormed<'tcx>),\n+    FromEnv(FromEnv<'tcx>),\n+    Normalize(ty::ProjectionPredicate<'tcx>),\n+}\n+\n+pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n+pub enum QuantifierKind {\n+    Universal,\n+    Existential,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum GoalKind<'tcx> {\n+    Implies(Clauses<'tcx>, Goal<'tcx>),\n+    And(Goal<'tcx>, Goal<'tcx>),\n+    Not(Goal<'tcx>),\n+    DomainGoal(DomainGoal<'tcx>),\n+    Quantified(QuantifierKind, ty::Binder<Goal<'tcx>>),\n+    Subtype(Ty<'tcx>, Ty<'tcx>),\n+    CannotProve,\n+}\n+\n+pub type Goal<'tcx> = &'tcx GoalKind<'tcx>;\n+\n+pub type Goals<'tcx> = &'tcx List<Goal<'tcx>>;\n+\n+impl<'tcx> DomainGoal<'tcx> {\n+    pub fn into_goal(self) -> GoalKind<'tcx> {\n+        GoalKind::DomainGoal(self)\n+    }\n+\n+    pub fn into_program_clause(self) -> ProgramClause<'tcx> {\n+        ProgramClause {\n+            goal: self,\n+            hypotheses: ty::List::empty(),\n+            category: ProgramClauseCategory::Other,\n         }\n-    } else {\n-        result\n     }\n }\n \n-fn do_normalize_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    region_context: DefId,\n-    cause: ObligationCause<'tcx>,\n-    elaborated_env: ty::ParamEnv<'tcx>,\n-    predicates: Vec<ty::Predicate<'tcx>>,\n-) -> Result<Vec<ty::Predicate<'tcx>>, ErrorReported> {\n-    debug!(\n-        \"do_normalize_predicates(predicates={:?}, region_context={:?}, cause={:?})\",\n-        predicates, region_context, cause,\n-    );\n-    let span = cause.span;\n-    tcx.infer_ctxt().enter(|infcx| {\n-        // FIXME. We should really... do something with these region\n-        // obligations. But this call just continues the older\n-        // behavior (i.e., doesn't cause any new bugs), and it would\n-        // take some further refactoring to actually solve them. In\n-        // particular, we would have to handle implied bounds\n-        // properly, and that code is currently largely confined to\n-        // regionck (though I made some efforts to extract it\n-        // out). -nmatsakis\n-        //\n-        // @arielby: In any case, these obligations are checked\n-        // by wfcheck anyway, so I'm not sure we have to check\n-        // them here too, and we will remove this function when\n-        // we move over to lazy normalization *anyway*.\n-        let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n-        let predicates =\n-            match fully_normalize(&infcx, fulfill_cx, cause, elaborated_env, &predicates) {\n-                Ok(predicates) => predicates,\n-                Err(errors) => {\n-                    infcx.report_fulfillment_errors(&errors, None, false);\n-                    return Err(ErrorReported);\n-                }\n-            };\n-\n-        debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n-\n-        let region_scope_tree = region::ScopeTree::default();\n-\n-        // We can use the `elaborated_env` here; the region code only\n-        // cares about declarations like `'a: 'b`.\n-        let outlives_env = OutlivesEnvironment::new(elaborated_env);\n-\n-        infcx.resolve_regions_and_report_errors(\n-            region_context,\n-            &region_scope_tree,\n-            &outlives_env,\n-            SuppressRegionErrors::default(),\n-        );\n-\n-        let predicates = match infcx.fully_resolve(&predicates) {\n-            Ok(predicates) => predicates,\n-            Err(fixup_err) => {\n-                // If we encounter a fixup error, it means that some type\n-                // variable wound up unconstrained. I actually don't know\n-                // if this can happen, and I certainly don't expect it to\n-                // happen often, but if it did happen it probably\n-                // represents a legitimate failure due to some kind of\n-                // unconstrained variable, and it seems better not to ICE,\n-                // all things considered.\n-                tcx.sess.span_err(span, &fixup_err.to_string());\n-                return Err(ErrorReported);\n-            }\n-        };\n-        if predicates.has_local_value() {\n-            // FIXME: shouldn't we, you know, actually report an error here? or an ICE?\n-            Err(ErrorReported)\n-        } else {\n-            Ok(predicates)\n-        }\n-    })\n-}\n-\n-// FIXME: this is gonna need to be removed ...\n-/// Normalizes the parameter environment, reporting errors if they occur.\n-pub fn normalize_param_env_or_error<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    region_context: DefId,\n-    unnormalized_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-) -> ty::ParamEnv<'tcx> {\n-    // I'm not wild about reporting errors here; I'd prefer to\n-    // have the errors get reported at a defined place (e.g.,\n-    // during typeck). Instead I have all parameter\n-    // environments, in effect, going through this function\n-    // and hence potentially reporting errors. This ensures of\n-    // course that we never forget to normalize (the\n-    // alternative seemed like it would involve a lot of\n-    // manual invocations of this fn -- and then we'd have to\n-    // deal with the errors at each of those sites).\n-    //\n-    // In any case, in practice, typeck constructs all the\n-    // parameter environments once for every fn as it goes,\n-    // and errors will get reported then; so after typeck we\n-    // can be sure that no errors should occur.\n-\n-    debug!(\n-        \"normalize_param_env_or_error(region_context={:?}, unnormalized_env={:?}, cause={:?})\",\n-        region_context, unnormalized_env, cause\n-    );\n-\n-    let mut predicates: Vec<_> =\n-        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec()).collect();\n-\n-    debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n-\n-    let elaborated_env = ty::ParamEnv::new(\n-        tcx.intern_predicates(&predicates),\n-        unnormalized_env.reveal,\n-        unnormalized_env.def_id,\n-    );\n-\n-    // HACK: we are trying to normalize the param-env inside *itself*. The problem is that\n-    // normalization expects its param-env to be already normalized, which means we have\n-    // a circularity.\n-    //\n-    // The way we handle this is by normalizing the param-env inside an unnormalized version\n-    // of the param-env, which means that if the param-env contains unnormalized projections,\n-    // we'll have some normalization failures. This is unfortunate.\n-    //\n-    // Lazy normalization would basically handle this by treating just the\n-    // normalizing-a-trait-ref-requires-itself cycles as evaluation failures.\n-    //\n-    // Inferred outlives bounds can create a lot of `TypeOutlives` predicates for associated\n-    // types, so to make the situation less bad, we normalize all the predicates *but*\n-    // the `TypeOutlives` predicates first inside the unnormalized parameter environment, and\n-    // then we normalize the `TypeOutlives` bounds inside the normalized parameter environment.\n-    //\n-    // This works fairly well because trait matching  does not actually care about param-env\n-    // TypeOutlives predicates - these are normally used by regionck.\n-    let outlives_predicates: Vec<_> = predicates\n-        .drain_filter(|predicate| match predicate {\n-            ty::Predicate::TypeOutlives(..) => true,\n-            _ => false,\n-        })\n-        .collect();\n-\n-    debug!(\n-        \"normalize_param_env_or_error: predicates=(non-outlives={:?}, outlives={:?})\",\n-        predicates, outlives_predicates\n-    );\n-    let non_outlives_predicates = match do_normalize_predicates(\n-        tcx,\n-        region_context,\n-        cause.clone(),\n-        elaborated_env,\n-        predicates,\n-    ) {\n-        Ok(predicates) => predicates,\n-        // An unnormalized env is better than nothing.\n-        Err(ErrorReported) => {\n-            debug!(\"normalize_param_env_or_error: errored resolving non-outlives predicates\");\n-            return elaborated_env;\n+impl<'tcx> GoalKind<'tcx> {\n+    pub fn from_poly_domain_goal(\n+        domain_goal: PolyDomainGoal<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> GoalKind<'tcx> {\n+        match domain_goal.no_bound_vars() {\n+            Some(p) => p.into_goal(),\n+            None => GoalKind::Quantified(\n+                QuantifierKind::Universal,\n+                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal())),\n+            ),\n         }\n-    };\n-\n-    debug!(\"normalize_param_env_or_error: non-outlives predicates={:?}\", non_outlives_predicates);\n-\n-    // Not sure whether it is better to include the unnormalized TypeOutlives predicates\n-    // here. I believe they should not matter, because we are ignoring TypeOutlives param-env\n-    // predicates here anyway. Keeping them here anyway because it seems safer.\n-    let outlives_env: Vec<_> =\n-        non_outlives_predicates.iter().chain(&outlives_predicates).cloned().collect();\n-    let outlives_env =\n-        ty::ParamEnv::new(tcx.intern_predicates(&outlives_env), unnormalized_env.reveal, None);\n-    let outlives_predicates = match do_normalize_predicates(\n-        tcx,\n-        region_context,\n-        cause,\n-        outlives_env,\n-        outlives_predicates,\n-    ) {\n-        Ok(predicates) => predicates,\n-        // An unnormalized env is better than nothing.\n-        Err(ErrorReported) => {\n-            debug!(\"normalize_param_env_or_error: errored resolving outlives predicates\");\n-            return elaborated_env;\n+    }\n+}\n+\n+/// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n+/// Harrop Formulas\".\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub enum Clause<'tcx> {\n+    Implies(ProgramClause<'tcx>),\n+    ForAll(ty::Binder<ProgramClause<'tcx>>),\n+}\n+\n+impl Clause<'tcx> {\n+    pub fn category(self) -> ProgramClauseCategory {\n+        match self {\n+            Clause::Implies(clause) => clause.category,\n+            Clause::ForAll(clause) => clause.skip_binder().category,\n         }\n-    };\n-    debug!(\"normalize_param_env_or_error: outlives predicates={:?}\", outlives_predicates);\n-\n-    let mut predicates = non_outlives_predicates;\n-    predicates.extend(outlives_predicates);\n-    debug!(\"normalize_param_env_or_error: final predicates={:?}\", predicates);\n-    ty::ParamEnv::new(\n-        tcx.intern_predicates(&predicates),\n-        unnormalized_env.reveal,\n-        unnormalized_env.def_id,\n-    )\n-}\n-\n-pub fn fully_normalize<'a, 'tcx, T>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n-    mut fulfill_cx: FulfillmentContext<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    value: &T,\n-) -> Result<T, Vec<FulfillmentError<'tcx>>>\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    debug!(\"fully_normalize_with_fulfillcx(value={:?})\", value);\n-    let selcx = &mut SelectionContext::new(infcx);\n-    let Normalized { value: normalized_value, obligations } =\n-        project::normalize(selcx, param_env, cause, value);\n-    debug!(\n-        \"fully_normalize: normalized_value={:?} obligations={:?}\",\n-        normalized_value, obligations\n-    );\n-    for obligation in obligations {\n-        fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n     }\n+}\n+\n+/// Multiple clauses.\n+pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n+\n+/// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n+/// that the domain goal `D` is true if `G1...Gn` are provable. This\n+/// is equivalent to the implication `G1..Gn => D`; we usually write\n+/// it with the reverse implication operator `:-` to emphasize the way\n+/// that programs are actually solved (via backchaining, which starts\n+/// with the goal to solve and proceeds from there).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct ProgramClause<'tcx> {\n+    /// This goal will be considered true ...\n+    pub goal: DomainGoal<'tcx>,\n+\n+    /// ... if we can prove these hypotheses (there may be no hypotheses at all):\n+    pub hypotheses: Goals<'tcx>,\n+\n+    /// Useful for filtering clauses.\n+    pub category: ProgramClauseCategory,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n+pub enum ProgramClauseCategory {\n+    ImpliedBound,\n+    WellFormed,\n+    Other,\n+}\n \n-    debug!(\"fully_normalize: select_all_or_error start\");\n-    fulfill_cx.select_all_or_error(infcx)?;\n-    debug!(\"fully_normalize: select_all_or_error complete\");\n-    let resolved_value = infcx.resolve_vars_if_possible(&normalized_value);\n-    debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n-    Ok(resolved_value)\n-}\n-\n-/// Normalizes the predicates and checks whether they hold in an empty\n-/// environment. If this returns false, then either normalize\n-/// encountered an error or one of the predicates did not hold. Used\n-/// when creating vtables to check for unsatisfiable methods.\n-pub fn normalize_and_test_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    predicates: Vec<ty::Predicate<'tcx>>,\n-) -> bool {\n-    debug!(\"normalize_and_test_predicates(predicates={:?})\", predicates);\n-\n-    let result = tcx.infer_ctxt().enter(|infcx| {\n-        let param_env = ty::ParamEnv::reveal_all();\n-        let mut selcx = SelectionContext::new(&infcx);\n-        let mut fulfill_cx = FulfillmentContext::new();\n-        let cause = ObligationCause::dummy();\n-        let Normalized { value: predicates, obligations } =\n-            normalize(&mut selcx, param_env, cause.clone(), &predicates);\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+/// A set of clauses that we assume to be true.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct Environment<'tcx> {\n+    pub clauses: Clauses<'tcx>,\n+}\n+\n+impl Environment<'tcx> {\n+    pub fn with<G>(self, goal: G) -> InEnvironment<'tcx, G> {\n+        InEnvironment { environment: self, goal }\n+    }\n+}\n+\n+/// Something (usually a goal), along with an environment.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct InEnvironment<'tcx, G> {\n+    pub environment: Environment<'tcx>,\n+    pub goal: G,\n+}\n+\n+#[derive(Clone, Debug, TypeFoldable)]\n+pub enum SelectionError<'tcx> {\n+    Unimplemented,\n+    OutputTypeParameterMismatch(\n+        ty::PolyTraitRef<'tcx>,\n+        ty::PolyTraitRef<'tcx>,\n+        ty::error::TypeError<'tcx>,\n+    ),\n+    TraitNotObjectSafe(DefId),\n+    ConstEvalFailure(ErrorHandled),\n+    Overflow,\n+}\n+\n+/// When performing resolution, it is typically the case that there\n+/// can be one of three outcomes:\n+///\n+/// - `Ok(Some(r))`: success occurred with result `r`\n+/// - `Ok(None)`: could not definitely determine anything, usually due\n+///   to inconclusive type inference.\n+/// - `Err(e)`: error `e` occurred\n+pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n+\n+/// Given the successful resolution of an obligation, the `Vtable`\n+/// indicates where the vtable comes from. Note that while we call this\n+/// a \"vtable\", it does not necessarily indicate dynamic dispatch at\n+/// runtime. `Vtable` instances just tell the compiler where to find\n+/// methods, but in generic code those methods are typically statically\n+/// dispatched -- only when an object is constructed is a `Vtable`\n+/// instance reified into an actual vtable.\n+///\n+/// For example, the vtable may be tied to a specific impl (case A),\n+/// or it may be relative to some bound that is in scope (case B).\n+///\n+/// ```\n+/// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n+/// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n+/// impl Clone for int { ... }             // Impl_3\n+///\n+/// fn foo<T:Clone>(concrete: Option<Box<int>>,\n+///                 param: T,\n+///                 mixed: Option<T>) {\n+///\n+///    // Case A: Vtable points at a specific impl. Only possible when\n+///    // type is concretely known. If the impl itself has bounded\n+///    // type parameters, Vtable will carry resolutions for those as well:\n+///    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n+///\n+///    // Case B: Vtable must be provided by caller. This applies when\n+///    // type is a type parameter.\n+///    param.clone();    // VtableParam\n+///\n+///    // Case C: A mix of cases A and B.\n+///    mixed.clone();    // Vtable(Impl_1, [VtableParam])\n+/// }\n+/// ```\n+///\n+/// ### The type parameter `N`\n+///\n+/// See explanation on `VtableImplData`.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub enum Vtable<'tcx, N> {\n+    /// Vtable identifying a particular impl.\n+    VtableImpl(VtableImplData<'tcx, N>),\n+\n+    /// Vtable for auto trait implementations.\n+    /// This carries the information and nested obligations with regards\n+    /// to an auto implementation for a trait `Trait`. The nested obligations\n+    /// ensure the trait implementation holds for all the constituent types.\n+    VtableAutoImpl(VtableAutoImplData<N>),\n+\n+    /// Successful resolution to an obligation provided by the caller\n+    /// for some type parameter. The `Vec<N>` represents the\n+    /// obligations incurred from normalizing the where-clause (if\n+    /// any).\n+    VtableParam(Vec<N>),\n+\n+    /// Virtual calls through an object.\n+    VtableObject(VtableObjectData<'tcx, N>),\n+\n+    /// Successful resolution for a builtin trait.\n+    VtableBuiltin(VtableBuiltinData<N>),\n+\n+    /// Vtable automatically generated for a closure. The `DefId` is the ID\n+    /// of the closure expression. This is a `VtableImpl` in spirit, but the\n+    /// impl is generated by the compiler and does not appear in the source.\n+    VtableClosure(VtableClosureData<'tcx, N>),\n+\n+    /// Same as above, but for a function pointer type with the given signature.\n+    VtableFnPointer(VtableFnPointerData<'tcx, N>),\n+\n+    /// Vtable automatically generated for a generator.\n+    VtableGenerator(VtableGeneratorData<'tcx, N>),\n+\n+    /// Vtable for a trait alias.\n+    VtableTraitAlias(VtableTraitAliasData<'tcx, N>),\n+}\n+\n+impl<'tcx, N> Vtable<'tcx, N> {\n+    pub fn nested_obligations(self) -> Vec<N> {\n+        match self {\n+            VtableImpl(i) => i.nested,\n+            VtableParam(n) => n,\n+            VtableBuiltin(i) => i.nested,\n+            VtableAutoImpl(d) => d.nested,\n+            VtableClosure(c) => c.nested,\n+            VtableGenerator(c) => c.nested,\n+            VtableObject(d) => d.nested,\n+            VtableFnPointer(d) => d.nested,\n+            VtableTraitAlias(d) => d.nested,\n         }\n-        for predicate in predicates {\n-            let obligation = Obligation::new(cause.clone(), param_env, predicate);\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+    }\n+\n+    pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M>\n+    where\n+        F: FnMut(N) -> M,\n+    {\n+        match self {\n+            VtableImpl(i) => VtableImpl(VtableImplData {\n+                impl_def_id: i.impl_def_id,\n+                substs: i.substs,\n+                nested: i.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n+            VtableBuiltin(i) => {\n+                VtableBuiltin(VtableBuiltinData { nested: i.nested.into_iter().map(f).collect() })\n+            }\n+            VtableObject(o) => VtableObject(VtableObjectData {\n+                upcast_trait_ref: o.upcast_trait_ref,\n+                vtable_base: o.vtable_base,\n+                nested: o.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableAutoImpl(d) => VtableAutoImpl(VtableAutoImplData {\n+                trait_def_id: d.trait_def_id,\n+                nested: d.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableClosure(c) => VtableClosure(VtableClosureData {\n+                closure_def_id: c.closure_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n+                generator_def_id: c.generator_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n+                fn_ty: p.fn_ty,\n+                nested: p.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableTraitAlias(d) => VtableTraitAlias(VtableTraitAliasData {\n+                alias_def_id: d.alias_def_id,\n+                substs: d.substs,\n+                nested: d.nested.into_iter().map(f).collect(),\n+            }),\n         }\n+    }\n+}\n \n-        fulfill_cx.select_all_or_error(&infcx).is_ok()\n-    });\n-    debug!(\"normalize_and_test_predicates(predicates={:?}) = {:?}\", predicates, result);\n-    result\n+/// Identifies a particular impl in the source, along with a set of\n+/// substitutions from the impl's type/lifetime parameters. The\n+/// `nested` vector corresponds to the nested obligations attached to\n+/// the impl's type parameters.\n+///\n+/// The type parameter `N` indicates the type used for \"nested\n+/// obligations\" that are required by the impl. During type-check, this\n+/// is `Obligation`, as one might expect. During codegen, however, this\n+/// is `()`, because codegen only requires a shallow resolution of an\n+/// impl, and nested obligations are satisfied later.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableImplData<'tcx, N> {\n+    pub impl_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    pub nested: Vec<N>,\n }\n \n-fn substitute_normalize_and_test_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: (DefId, SubstsRef<'tcx>),\n-) -> bool {\n-    debug!(\"substitute_normalize_and_test_predicates(key={:?})\", key);\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableGeneratorData<'tcx, N> {\n+    pub generator_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    /// Nested obligations. This can be non-empty if the generator\n+    /// signature contains associated types.\n+    pub nested: Vec<N>,\n+}\n \n-    let predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n-    let result = normalize_and_test_predicates(tcx, predicates);\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableClosureData<'tcx, N> {\n+    pub closure_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    /// Nested obligations. This can be non-empty if the closure\n+    /// signature contains associated types.\n+    pub nested: Vec<N>,\n+}\n \n-    debug!(\"substitute_normalize_and_test_predicates(key={:?}) = {:?}\", key, result);\n-    result\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableAutoImplData<N> {\n+    pub trait_def_id: DefId,\n+    pub nested: Vec<N>,\n }\n \n-/// Given a trait `trait_ref`, iterates the vtable entries\n-/// that come from `trait_ref`, including its supertraits.\n-#[inline] // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n-fn vtable_methods<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n-    debug!(\"vtable_methods({:?})\", trait_ref);\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableBuiltinData<N> {\n+    pub nested: Vec<N>,\n+}\n \n-    tcx.arena.alloc_from_iter(supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n-        let trait_methods = tcx\n-            .associated_items(trait_ref.def_id())\n-            .filter(|item| item.kind == ty::AssocKind::Method);\n+/// A vtable for some object-safe trait `Foo` automatically derived\n+/// for the object type `Foo`.\n+#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableObjectData<'tcx, N> {\n+    /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n+    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n \n-        // Now list each method's DefId and InternalSubsts (for within its trait).\n-        // If the method can never be called from this object, produce None.\n-        trait_methods.map(move |trait_method| {\n-            debug!(\"vtable_methods: trait_method={:?}\", trait_method);\n-            let def_id = trait_method.def_id;\n+    /// The vtable is formed by concatenating together the method lists of\n+    /// the base object trait and all supertraits; this is the start of\n+    /// `upcast_trait_ref`'s methods in that vtable.\n+    pub vtable_base: usize,\n \n-            // Some methods cannot be called on an object; skip those.\n-            if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n-                debug!(\"vtable_methods: not vtable safe\");\n-                return None;\n-            }\n+    pub nested: Vec<N>,\n+}\n \n-            // The method may have some early-bound lifetimes; add regions for those.\n-            let substs = trait_ref.map_bound(|trait_ref| {\n-                InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n-                    GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n-                        trait_ref.substs[param.index as usize]\n-                    }\n-                })\n-            });\n-\n-            // The trait type may have higher-ranked lifetimes in it;\n-            // erase them if they appear, so that we get the type\n-            // at some particular call site.\n-            let substs =\n-                tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &substs);\n-\n-            // It's possible that the method relies on where-clauses that\n-            // do not hold for this particular set of type parameters.\n-            // Note that this method could then never be called, so we\n-            // do not want to try and codegen it, in that case (see #23435).\n-            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n-                debug!(\"vtable_methods: predicates do not hold\");\n-                return None;\n-            }\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableFnPointerData<'tcx, N> {\n+    pub fn_ty: Ty<'tcx>,\n+    pub nested: Vec<N>,\n+}\n \n-            Some((def_id, substs))\n-        })\n-    }))\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableTraitAliasData<'tcx, N> {\n+    pub alias_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    pub nested: Vec<N>,\n }\n \n-impl<'tcx, O> Obligation<'tcx, O> {\n-    pub fn new(\n-        cause: ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        predicate: O,\n-    ) -> Obligation<'tcx, O> {\n-        Obligation { cause, param_env, recursion_depth: 0, predicate }\n-    }\n+pub trait ExClauseFold<'tcx>\n+where\n+    Self: chalk_engine::context::Context + Clone,\n+{\n+    fn fold_ex_clause_with<F: TypeFolder<'tcx>>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        folder: &mut F,\n+    ) -> chalk_engine::ExClause<Self>;\n+\n+    fn visit_ex_clause_with<V: TypeVisitor<'tcx>>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        visitor: &mut V,\n+    ) -> bool;\n+}\n \n-    fn with_depth(\n-        cause: ObligationCause<'tcx>,\n-        recursion_depth: usize,\n-        param_env: ty::ParamEnv<'tcx>,\n-        predicate: O,\n-    ) -> Obligation<'tcx, O> {\n-        Obligation { cause, param_env, recursion_depth, predicate }\n-    }\n+pub trait ChalkContextLift<'tcx>\n+where\n+    Self: chalk_engine::context::Context + Clone,\n+{\n+    type LiftedExClause: Debug + 'tcx;\n+    type LiftedDelayedLiteral: Debug + 'tcx;\n+    type LiftedLiteral: Debug + 'tcx;\n+\n+    fn lift_ex_clause_to_tcx(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<Self::LiftedExClause>;\n+\n+    fn lift_delayed_literal_to_tcx(\n+        ex_clause: &chalk_engine::DelayedLiteral<Self>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<Self::LiftedDelayedLiteral>;\n+\n+    fn lift_literal_to_tcx(\n+        ex_clause: &chalk_engine::Literal<Self>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<Self::LiftedLiteral>;\n+}\n \n-    pub fn misc(\n-        span: Span,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: O,\n-    ) -> Obligation<'tcx, O> {\n-        Obligation::new(ObligationCause::misc(span, body_id), param_env, trait_ref)\n-    }\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n+pub enum ObjectSafetyViolation {\n+    /// `Self: Sized` declared on the trait.\n+    SizedSelf(SmallVec<[Span; 1]>),\n+\n+    /// Supertrait reference references `Self` an in illegal location\n+    /// (e.g., `trait Foo : Bar<Self>`).\n+    SupertraitSelf(SmallVec<[Span; 1]>),\n+\n+    /// Method has something illegal.\n+    Method(ast::Name, MethodViolationCode, Span),\n \n-    pub fn with<P>(&self, value: P) -> Obligation<'tcx, P> {\n-        Obligation {\n-            cause: self.cause.clone(),\n-            param_env: self.param_env,\n-            recursion_depth: self.recursion_depth,\n-            predicate: value,\n+    /// Associated const.\n+    AssocConst(ast::Name, Span),\n+}\n+\n+impl ObjectSafetyViolation {\n+    pub fn error_msg(&self) -> Cow<'static, str> {\n+        match *self {\n+            ObjectSafetyViolation::SizedSelf(_) => \"it requires `Self: Sized`\".into(),\n+            ObjectSafetyViolation::SupertraitSelf(ref spans) => {\n+                if spans.iter().any(|sp| *sp != DUMMY_SP) {\n+                    \"it uses `Self` as a type parameter in this\".into()\n+                } else {\n+                    \"it cannot use `Self` as a type parameter in a supertrait or `where`-clause\"\n+                        .into()\n+                }\n+            }\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod(_), _) => {\n+                format!(\"associated function `{}` has no `self` parameter\", name).into()\n+            }\n+            ObjectSafetyViolation::Method(\n+                name,\n+                MethodViolationCode::ReferencesSelfInput(_),\n+                DUMMY_SP,\n+            ) => format!(\"method `{}` references the `Self` type in its parameters\", name).into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::ReferencesSelfInput(_), _) => {\n+                format!(\"method `{}` references the `Self` type in this parameter\", name).into()\n+            }\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::ReferencesSelfOutput, _) => {\n+                format!(\"method `{}` references the `Self` type in its return type\", name).into()\n+            }\n+            ObjectSafetyViolation::Method(\n+                name,\n+                MethodViolationCode::WhereClauseReferencesSelf,\n+                _,\n+            ) => {\n+                format!(\"method `{}` references the `Self` type in its `where` clause\", name).into()\n+            }\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::Generic, _) => {\n+                format!(\"method `{}` has generic type parameters\", name).into()\n+            }\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::UndispatchableReceiver, _) => {\n+                format!(\"method `{}`'s `self` parameter cannot be dispatched on\", name).into()\n+            }\n+            ObjectSafetyViolation::AssocConst(name, DUMMY_SP) => {\n+                format!(\"it contains associated `const` `{}`\", name).into()\n+            }\n+            ObjectSafetyViolation::AssocConst(..) => \"it contains this associated `const`\".into(),\n         }\n     }\n-}\n \n-impl<'tcx> FulfillmentError<'tcx> {\n-    fn new(\n-        obligation: PredicateObligation<'tcx>,\n-        code: FulfillmentErrorCode<'tcx>,\n-    ) -> FulfillmentError<'tcx> {\n-        FulfillmentError { obligation: obligation, code: code, points_at_arg_span: false }\n+    pub fn solution(&self) -> Option<(String, Option<(String, Span)>)> {\n+        Some(match *self {\n+            ObjectSafetyViolation::SizedSelf(_) | ObjectSafetyViolation::SupertraitSelf(_) => {\n+                return None;\n+            }\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod(sugg), _) => (\n+                format!(\n+                    \"consider turning `{}` into a method by giving it a `&self` argument or \\\n+                     constraining it so it does not apply to trait objects\",\n+                    name\n+                ),\n+                sugg.map(|(sugg, sp)| (sugg.to_string(), sp)),\n+            ),\n+            ObjectSafetyViolation::Method(\n+                name,\n+                MethodViolationCode::UndispatchableReceiver,\n+                span,\n+            ) => (\n+                format!(\"consider changing method `{}`'s `self` parameter to be `&self`\", name)\n+                    .into(),\n+                Some((\"&Self\".to_string(), span)),\n+            ),\n+            ObjectSafetyViolation::AssocConst(name, _)\n+            | ObjectSafetyViolation::Method(name, ..) => {\n+                (format!(\"consider moving `{}` to another trait\", name), None)\n+            }\n+        })\n     }\n-}\n \n-impl<'tcx> TraitObligation<'tcx> {\n-    fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n-        self.predicate.map_bound(|p| p.self_ty())\n+    pub fn spans(&self) -> SmallVec<[Span; 1]> {\n+        // When `span` comes from a separate crate, it'll be `DUMMY_SP`. Treat it as `None` so\n+        // diagnostics use a `note` instead of a `span_label`.\n+        match self {\n+            ObjectSafetyViolation::SupertraitSelf(spans)\n+            | ObjectSafetyViolation::SizedSelf(spans) => spans.clone(),\n+            ObjectSafetyViolation::AssocConst(_, span)\n+            | ObjectSafetyViolation::Method(_, _, span)\n+                if *span != DUMMY_SP =>\n+            {\n+                smallvec![*span]\n+            }\n+            _ => smallvec![],\n+        }\n     }\n }\n \n-pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    misc::provide(providers);\n-    *providers = ty::query::Providers {\n-        is_object_safe: object_safety::is_object_safe_provider,\n-        specialization_graph_of: specialize::specialization_graph_provider,\n-        specializes: specialize::specializes,\n-        codegen_fulfill_obligation: codegen::codegen_fulfill_obligation,\n-        vtable_methods,\n-        substitute_normalize_and_test_predicates,\n-        ..*providers\n-    };\n+/// Reasons a method might not be object-safe.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n+pub enum MethodViolationCode {\n+    /// e.g., `fn foo()`\n+    StaticMethod(Option<(&'static str, Span)>),\n+\n+    /// e.g., `fn foo(&self, x: Self)`\n+    ReferencesSelfInput(usize),\n+\n+    /// e.g., `fn foo(&self) -> Self`\n+    ReferencesSelfOutput,\n+\n+    /// e.g., `fn foo(&self) where Self: Clone`\n+    WhereClauseReferencesSelf,\n+\n+    /// e.g., `fn foo<A>()`\n+    Generic,\n+\n+    /// the method's receiver (`self` argument) can't be dispatched on\n+    UndispatchableReceiver,\n }"}, {"sha": "c90551826202efd4300a90cde649cae91c71d8b0", "filename": "src/librustc/traits/query.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "previous_filename": "src/librustc/traits/types/query.rs"}, {"sha": "ac3d0049c0c7c42908e6cff2df5b90e46ea13c50", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 234, "deletions": 3791, "changes": 4025, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "ee813bf606e9728b7ad8e834f405db1fa19613a6", "filename": "src/librustc/traits/specialization_graph.rs", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -81,8 +81,8 @@ impl<'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'tcx>) -> ty::AssocItemsIterator<'tcx> {\n-        tcx.associated_items(self.def_id())\n+    pub fn items(&self, tcx: TyCtxt<'tcx>) -> impl 'tcx + Iterator<Item = &'tcx ty::AssocItem> {\n+        tcx.associated_items(self.def_id()).in_definition_order()\n     }\n \n     /// Finds an associated item defined in this node.\n@@ -98,8 +98,10 @@ impl<'tcx> Node {\n     ) -> Option<ty::AssocItem> {\n         use crate::ty::AssocKind::*;\n \n-        tcx.associated_items(self.def_id()).find(move |impl_item| {\n-            match (trait_item_kind, impl_item.kind) {\n+        tcx.associated_items(self.def_id())\n+            .filter_by_name_unhygienic(trait_item_name.name)\n+            .find(move |impl_item| {\n+                match (trait_item_kind, impl_item.kind) {\n                 | (Const, Const)\n                 | (Method, Method)\n                 | (Type, Type)\n@@ -112,7 +114,8 @@ impl<'tcx> Node {\n                 | (OpaqueTy, _)\n                 => false,\n             }\n-        })\n+            })\n+            .copied()\n     }\n \n     pub fn def_id(&self) -> DefId {", "previous_filename": "src/librustc/traits/types/specialization_graph.rs"}, {"sha": "48ed29f2bb33841cc974147d5b81218453a2cb16", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 674, "deletions": 33, "changes": 707, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,71 +1,712 @@\n use crate::traits;\n-use crate::traits::project::Normalized;\n-use crate::ty;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::{self, Lift, Ty, TyCtxt};\n+use rustc_span::symbol::Symbol;\n+use smallvec::SmallVec;\n \n+use std::collections::{BTreeMap, BTreeSet};\n use std::fmt;\n+use std::rc::Rc;\n \n // Structural impls for the structs in `traits`.\n \n-impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"Normalized({:?}, {:?})\", self.value, self.obligations)\n+        match *self {\n+            super::VtableImpl(ref v) => write!(f, \"{:?}\", v),\n+\n+            super::VtableAutoImpl(ref t) => write!(f, \"{:?}\", t),\n+\n+            super::VtableClosure(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableGenerator(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableFnPointer(ref d) => write!(f, \"VtableFnPointer({:?})\", d),\n+\n+            super::VtableObject(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableParam(ref n) => write!(f, \"VtableParam({:?})\", n),\n+\n+            super::VtableBuiltin(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableTraitAlias(ref d) => write!(f, \"{:?}\", d),\n+        }\n     }\n }\n \n-impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if ty::tls::with(|tcx| tcx.sess.verbose()) {\n-            write!(\n-                f,\n-                \"Obligation(predicate={:?}, cause={:?}, param_env={:?}, depth={})\",\n-                self.predicate, self.cause, self.param_env, self.recursion_depth\n-            )\n-        } else {\n-            write!(f, \"Obligation(predicate={:?}, depth={})\", self.predicate, self.recursion_depth)\n-        }\n+        write!(\n+            f,\n+            \"VtableImplData(impl_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.impl_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.generator_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.closure_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n+impl<N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"VtableBuiltinData(nested={:?})\", self.nested)\n+    }\n+}\n+\n+impl<N: fmt::Debug> fmt::Debug for traits::VtableAutoImplData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableAutoImplData(trait_def_id={:?}, nested={:?})\",\n+            self.trait_def_id, self.nested\n+        )\n     }\n }\n \n-impl<'tcx> fmt::Debug for traits::FulfillmentError<'tcx> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"FulfillmentError({:?},{:?})\", self.obligation, self.code)\n+        write!(\n+            f,\n+            \"VtableObjectData(upcast={:?}, vtable_base={}, nested={:?})\",\n+            self.upcast_trait_ref, self.vtable_base, self.nested\n+        )\n     }\n }\n \n-impl<'tcx> fmt::Debug for traits::FulfillmentErrorCode<'tcx> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"VtableFnPointerData(fn_ty={:?}, nested={:?})\", self.fn_ty, self.nested)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableTraitAliasData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.alias_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::WhereClause::*;\n+\n+        // Bypass `ty::print` because it does not print out anonymous regions.\n+        // FIXME(eddyb) implement a custom `PrettyPrinter`, or move this to `ty::print`.\n+        fn write_region_name<'tcx>(\n+            r: ty::Region<'tcx>,\n+            fmt: &mut fmt::Formatter<'_>,\n+        ) -> fmt::Result {\n+            match r {\n+                ty::ReLateBound(index, br) => match br {\n+                    ty::BoundRegion::BrNamed(_, name) => write!(fmt, \"{}\", name),\n+                    ty::BoundRegion::BrAnon(var) => {\n+                        if *index == ty::INNERMOST {\n+                            write!(fmt, \"'^{}\", var)\n+                        } else {\n+                            write!(fmt, \"'^{}_{}\", index.index(), var)\n+                        }\n+                    }\n+                    _ => write!(fmt, \"'_\"),\n+                },\n+\n+                _ => write!(fmt, \"{}\", r),\n+            }\n+        }\n+\n+        match self {\n+            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n+            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n+            RegionOutlives(predicate) => {\n+                write!(fmt, \"RegionOutlives({}: \", predicate.0)?;\n+                write_region_name(predicate.1, fmt)?;\n+                write!(fmt, \")\")\n+            }\n+            TypeOutlives(predicate) => {\n+                write!(fmt, \"TypeOutlives({}: \", predicate.0)?;\n+                write_region_name(predicate.1, fmt)?;\n+                write!(fmt, \")\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::WellFormed::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::FromEnv::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::DomainGoal::*;\n+\n+        match self {\n+            Holds(wc) => write!(fmt, \"{}\", wc),\n+            WellFormed(wf) => write!(fmt, \"{}\", wf),\n+            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n+            Normalize(projection) => {\n+                write!(fmt, \"Normalize({} -> {})\", projection.projection_ty, projection.ty)\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Display for traits::QuantifierKind {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::QuantifierKind::*;\n+\n+        match self {\n+            Universal => write!(fmt, \"forall\"),\n+            Existential => write!(fmt, \"exists\"),\n+        }\n+    }\n+}\n+\n+/// Collect names for regions / types bound by a quantified goal / clause.\n+/// This collector does not try to do anything clever like in `ty::print`, it's just used\n+/// for debug output in tests anyway.\n+struct BoundNamesCollector {\n+    // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway.\n+    regions: BTreeSet<Symbol>,\n+\n+    // Sort by `BoundVar` index, so usually this should be equivalent to the order given\n+    // by the list of type parameters.\n+    types: BTreeMap<u32, Symbol>,\n+\n+    binder_index: ty::DebruijnIndex,\n+}\n+\n+impl BoundNamesCollector {\n+    fn new() -> Self {\n+        BoundNamesCollector {\n+            regions: BTreeSet::new(),\n+            types: BTreeMap::new(),\n+            binder_index: ty::INNERMOST,\n+        }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.regions.is_empty() && self.types.is_empty()\n+    }\n+\n+    fn write_names(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut start = true;\n+        for r in &self.regions {\n+            if !start {\n+                write!(fmt, \", \")?;\n+            }\n+            start = false;\n+            write!(fmt, \"{}\", r)?;\n+        }\n+        for (_, t) in &self.types {\n+            if !start {\n+                write!(fmt, \", \")?;\n+            }\n+            start = false;\n+            write!(fmt, \"{}\", t)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        match t.kind {\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n+                self.types.insert(\n+                    bound_ty.var.as_u32(),\n+                    match bound_ty.kind {\n+                        ty::BoundTyKind::Param(name) => name,\n+                        ty::BoundTyKind::Anon => {\n+                            Symbol::intern(&format!(\"^{}\", bound_ty.var.as_u32()))\n+                        }\n+                    },\n+                );\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        match r {\n+            ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n+                ty::BoundRegion::BrNamed(_, name) => {\n+                    self.regions.insert(*name);\n+                }\n+\n+                ty::BoundRegion::BrAnon(var) => {\n+                    self.regions.insert(Symbol::intern(&format!(\"'^{}\", var)));\n+                }\n+\n+                _ => (),\n+            },\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::GoalKind::*;\n+\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                write!(fmt, \"if (\")?;\n+                for (index, hyp) in hypotheses.iter().enumerate() {\n+                    if index > 0 {\n+                        write!(fmt, \", \")?;\n+                    }\n+                    write!(fmt, \"{}\", hyp)?;\n+                }\n+                write!(fmt, \") {{ {} }}\", goal)\n+            }\n+            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n+            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n+            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n+            Quantified(qkind, goal) => {\n+                let mut collector = BoundNamesCollector::new();\n+                goal.skip_binder().visit_with(&mut collector);\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \"{}<\", qkind)?;\n+                    collector.write_names(fmt)?;\n+                    write!(fmt, \"> {{ \")?;\n+                }\n+\n+                write!(fmt, \"{}\", goal.skip_binder())?;\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \" }}\")?;\n+                }\n+\n+                Ok(())\n+            }\n+            Subtype(a, b) => write!(fmt, \"{} <: {}\", a, b),\n+            CannotProve => write!(fmt, \"CannotProve\"),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let traits::ProgramClause { goal, hypotheses, .. } = self;\n+        write!(fmt, \"{}\", goal)?;\n+        if !hypotheses.is_empty() {\n+            write!(fmt, \" :- \")?;\n+            for (index, condition) in hypotheses.iter().enumerate() {\n+                if index > 0 {\n+                    write!(fmt, \", \")?;\n+                }\n+                write!(fmt, \"{}\", condition)?;\n+            }\n+        }\n+        write!(fmt, \".\")\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::Clause::*;\n+\n+        match self {\n+            Implies(clause) => write!(fmt, \"{}\", clause),\n+            ForAll(clause) => {\n+                let mut collector = BoundNamesCollector::new();\n+                clause.skip_binder().visit_with(&mut collector);\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \"forall<\")?;\n+                    collector.write_names(fmt)?;\n+                    write!(fmt, \"> {{ \")?;\n+                }\n+\n+                write!(fmt, \"{}\", clause.skip_binder())?;\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \" }}\")?;\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Lift implementations\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n+    type Lifted = traits::SelectionError<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n-            super::CodeProjectionError(ref e) => write!(f, \"{:?}\", e),\n-            super::CodeSubtypeError(ref a, ref b) => {\n-                write!(f, \"CodeSubtypeError({:?}, {:?})\", a, b)\n+            super::Unimplemented => Some(super::Unimplemented),\n+            super::OutputTypeParameterMismatch(a, b, ref err) => {\n+                tcx.lift(&(a, b)).and_then(|(a, b)| {\n+                    tcx.lift(err).map(|err| super::OutputTypeParameterMismatch(a, b, err))\n+                })\n             }\n-            super::CodeAmbiguity => write!(f, \"Ambiguity\"),\n+            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n+            super::ConstEvalFailure(err) => Some(super::ConstEvalFailure(err)),\n+            super::Overflow => Some(super::Overflow),\n         }\n     }\n }\n \n-impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"MismatchedProjectionTypes({:?})\", self.err)\n+impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n+    type Lifted = traits::ObligationCauseCode<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            super::ReturnNoExpression => Some(super::ReturnNoExpression),\n+            super::MiscObligation => Some(super::MiscObligation),\n+            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n+            super::TupleElem => Some(super::TupleElem),\n+            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n+            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n+            super::BindingObligation(def_id, span) => Some(super::BindingObligation(def_id, span)),\n+            super::ReferenceOutlivesReferent(ty) => {\n+                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n+            }\n+            super::ObjectTypeBound(ty, r) => tcx\n+                .lift(&ty)\n+                .and_then(|ty| tcx.lift(&r).and_then(|r| Some(super::ObjectTypeBound(ty, r)))),\n+            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n+            super::Coercion { source, target } => {\n+                Some(super::Coercion { source: tcx.lift(&source)?, target: tcx.lift(&target)? })\n+            }\n+            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n+            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n+            super::StructInitializerSized => Some(super::StructInitializerSized),\n+            super::VariableType(id) => Some(super::VariableType(id)),\n+            super::ReturnValue(id) => Some(super::ReturnValue(id)),\n+            super::ReturnType => Some(super::ReturnType),\n+            super::SizedArgumentType => Some(super::SizedArgumentType),\n+            super::SizedReturnType => Some(super::SizedReturnType),\n+            super::SizedYieldType => Some(super::SizedYieldType),\n+            super::RepeatVec(suggest_flag) => Some(super::RepeatVec(suggest_flag)),\n+            super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n+            super::ConstSized => Some(super::ConstSized),\n+            super::ConstPatternStructural => Some(super::ConstPatternStructural),\n+            super::SharedStatic => Some(super::SharedStatic),\n+            super::BuiltinDerivedObligation(ref cause) => {\n+                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n+            }\n+            super::ImplDerivedObligation(ref cause) => {\n+                tcx.lift(cause).map(super::ImplDerivedObligation)\n+            }\n+            super::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => Some(super::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            }),\n+            super::CompareImplTypeObligation { item_name, impl_item_def_id, trait_item_def_id } => {\n+                Some(super::CompareImplTypeObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                })\n+            }\n+            super::ExprAssignable => Some(super::ExprAssignable),\n+            super::MatchExpressionArm(box super::MatchExpressionArmCause {\n+                arm_span,\n+                source,\n+                ref prior_arms,\n+                last_ty,\n+                scrut_hir_id,\n+            }) => tcx.lift(&last_ty).map(|last_ty| {\n+                super::MatchExpressionArm(box super::MatchExpressionArmCause {\n+                    arm_span,\n+                    source,\n+                    prior_arms: prior_arms.clone(),\n+                    last_ty,\n+                    scrut_hir_id,\n+                })\n+            }),\n+            super::Pattern { span, root_ty, origin_expr } => {\n+                tcx.lift(&root_ty).map(|root_ty| super::Pattern { span, root_ty, origin_expr })\n+            }\n+            super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n+                Some(super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }))\n+            }\n+            super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n+            super::MainFunctionType => Some(super::MainFunctionType),\n+            super::StartFunctionType => Some(super::StartFunctionType),\n+            super::IntrinsicType => Some(super::IntrinsicType),\n+            super::MethodReceiver => Some(super::MethodReceiver),\n+            super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n+            super::TrivialBound => Some(super::TrivialBound),\n+            super::AssocTypeBound(ref data) => Some(super::AssocTypeBound(data.clone())),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n+    type Lifted = traits::DerivedObligationCause<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n+            tcx.lift(&*self.parent_code).map(|code| traits::DerivedObligationCause {\n+                parent_trait_ref: trait_ref,\n+                parent_code: Rc::new(code),\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n+    type Lifted = traits::ObligationCause<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.code).map(|code| traits::ObligationCause {\n+            span: self.span,\n+            body_id: self.body_id,\n+            code,\n+        })\n+    }\n+}\n+\n+// For codegen only.\n+impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n+    type Lifted = traits::Vtable<'tcx, ()>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self.clone() {\n+            traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested }) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested })\n+                })\n+            }\n+            traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n+            traits::VtableGenerator(traits::VtableGeneratorData {\n+                generator_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::VtableGenerator(traits::VtableGeneratorData {\n+                    generator_def_id: generator_def_id,\n+                    substs: substs,\n+                    nested: nested,\n+                })\n+            }),\n+            traits::VtableClosure(traits::VtableClosureData { closure_def_id, substs, nested }) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    traits::VtableClosure(traits::VtableClosureData {\n+                        closure_def_id,\n+                        substs,\n+                        nested,\n+                    })\n+                })\n+            }\n+            traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n+                tcx.lift(&fn_ty).map(|fn_ty| {\n+                    traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n+                })\n+            }\n+            traits::VtableParam(n) => Some(traits::VtableParam(n)),\n+            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n+            traits::VtableObject(traits::VtableObjectData {\n+                upcast_trait_ref,\n+                vtable_base,\n+                nested,\n+            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n+                traits::VtableObject(traits::VtableObjectData {\n+                    upcast_trait_ref: trait_ref,\n+                    vtable_base,\n+                    nested,\n+                })\n+            }),\n+            traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+                alias_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+                    alias_def_id,\n+                    substs,\n+                    nested,\n+                })\n+            }),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n+    type Lifted = traits::Environment<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.clauses).map(|clauses| traits::Environment { clauses })\n+    }\n+}\n+\n+impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n+    type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.environment).and_then(|environment| {\n+            tcx.lift(&self.goal).map(|goal| traits::InEnvironment { environment, goal })\n+        })\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ChalkContextLift<'tcx>,\n+{\n+    type Lifted = C::LiftedExClause;\n+\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ChalkContextLift>::lift_ex_clause_to_tcx(self, tcx)\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::DelayedLiteral<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ChalkContextLift<'tcx>,\n+{\n+    type Lifted = C::LiftedDelayedLiteral;\n+\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ChalkContextLift>::lift_delayed_literal_to_tcx(self, tcx)\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::Literal<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ChalkContextLift<'tcx>,\n+{\n+    type Lifted = C::LiftedLiteral;\n+\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ChalkContextLift>::lift_literal_to_tcx(self, tcx)\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n \n-impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O> {\n+CloneTypeFoldableAndLiftImpls! {\n+    traits::QuantifierKind,\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::Obligation {\n-            cause: self.cause.clone(),\n-            recursion_depth: self.recursion_depth,\n-            predicate: self.predicate.fold_with(folder),\n-            param_env: self.param_env.fold_with(folder),\n-        }\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n+        folder.tcx().intern_goals(&v)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.predicate.visit_with(visitor)\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = (**self).fold_with(folder);\n+        folder.tcx().mk_goal(v)\n     }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        (**self).visit_with(visitor)\n+    }\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    traits::ProgramClauseCategory,\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::Clauses<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n+        folder.tcx().intern_clauses(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: traits::ExClauseFold<'tcx>,\n+    C::Substitution: Clone,\n+    C::RegionConstraint: Clone,\n+{\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        <C as traits::ExClauseFold>::fold_ex_clause_with(self, folder)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        <C as traits::ExClauseFold>::visit_ex_clause_with(self, visitor)\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::DelayedLiteral<C> {\n+        (chalk_engine::DelayedLiteral::CannotProve)(a),\n+        (chalk_engine::DelayedLiteral::Negative)(a),\n+        (chalk_engine::DelayedLiteral::Positive)(a, b),\n+    } where\n+        C: chalk_engine::context::Context<CanonicalConstrainedSubst: TypeFoldable<'tcx>> + Clone,\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::Literal<C> {\n+        (chalk_engine::Literal::Negative)(a),\n+        (chalk_engine::Literal::Positive)(a),\n+    } where\n+        C: chalk_engine::context::Context<GoalInEnvironment: Clone + TypeFoldable<'tcx>> + Clone,\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    chalk_engine::TableIndex,\n }"}, {"sha": "571fb505779ca2408d2303a525fbc4d848df145d", "filename": "src/librustc/traits/types/mod.rs", "status": "removed", "additions": 0, "deletions": 736, "changes": 736, "blob_url": "https://github.com/rust-lang/rust/blob/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs?ref=e7a344fb745a0a663e21be947b2619df05df6d31", "patch": "@@ -1,736 +0,0 @@\n-//! Trait Resolution. See the [rustc guide] for more information on how this works.\n-//!\n-//! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n-\n-pub mod query;\n-pub mod select;\n-pub mod specialization_graph;\n-mod structural_impls;\n-\n-use crate::mir::interpret::ErrorHandled;\n-use crate::ty::fold::{TypeFolder, TypeVisitor};\n-use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, AdtKind, List, Ty, TyCtxt};\n-\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_span::{Span, DUMMY_SP};\n-use syntax::ast;\n-\n-use std::fmt::Debug;\n-use std::rc::Rc;\n-\n-pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, SelectionCache};\n-\n-pub use self::ObligationCauseCode::*;\n-pub use self::SelectionError::*;\n-pub use self::Vtable::*;\n-\n-/// Depending on the stage of compilation, we want projection to be\n-/// more or less conservative.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, HashStable)]\n-pub enum Reveal {\n-    /// At type-checking time, we refuse to project any associated\n-    /// type that is marked `default`. Non-`default` (\"final\") types\n-    /// are always projected. This is necessary in general for\n-    /// soundness of specialization. However, we *could* allow\n-    /// projections in fully-monomorphic cases. We choose not to,\n-    /// because we prefer for `default type` to force the type\n-    /// definition to be treated abstractly by any consumers of the\n-    /// impl. Concretely, that means that the following example will\n-    /// fail to compile:\n-    ///\n-    /// ```\n-    /// trait Assoc {\n-    ///     type Output;\n-    /// }\n-    ///\n-    /// impl<T> Assoc for T {\n-    ///     default type Output = bool;\n-    /// }\n-    ///\n-    /// fn main() {\n-    ///     let <() as Assoc>::Output = true;\n-    /// }\n-    /// ```\n-    UserFacing,\n-\n-    /// At codegen time, all monomorphic projections will succeed.\n-    /// Also, `impl Trait` is normalized to the concrete type,\n-    /// which has to be already collected by type-checking.\n-    ///\n-    /// NOTE: as `impl Trait`'s concrete type should *never*\n-    /// be observable directly by the user, `Reveal::All`\n-    /// should not be used by checks which may expose\n-    /// type equality or type contents to the user.\n-    /// There are some exceptions, e.g., around OIBITS and\n-    /// transmute-checking, which expose some details, but\n-    /// not the whole concrete type of the `impl Trait`.\n-    All,\n-}\n-\n-/// The reason why we incurred this obligation; used for error reporting.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct ObligationCause<'tcx> {\n-    pub span: Span,\n-\n-    /// The ID of the fn body that triggered this obligation. This is\n-    /// used for region obligations to determine the precise\n-    /// environment in which the region obligation should be evaluated\n-    /// (in particular, closures can add new assumptions). See the\n-    /// field `region_obligations` of the `FulfillmentContext` for more\n-    /// information.\n-    pub body_id: hir::HirId,\n-\n-    pub code: ObligationCauseCode<'tcx>,\n-}\n-\n-impl<'tcx> ObligationCause<'tcx> {\n-    #[inline]\n-    pub fn new(\n-        span: Span,\n-        body_id: hir::HirId,\n-        code: ObligationCauseCode<'tcx>,\n-    ) -> ObligationCause<'tcx> {\n-        ObligationCause { span, body_id, code }\n-    }\n-\n-    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n-        ObligationCause { span, body_id, code: MiscObligation }\n-    }\n-\n-    pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: MiscObligation }\n-    }\n-\n-    pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n-        match self.code {\n-            ObligationCauseCode::CompareImplMethodObligation { .. }\n-            | ObligationCauseCode::MainFunctionType\n-            | ObligationCauseCode::StartFunctionType => tcx.sess.source_map().def_span(self.span),\n-            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                arm_span,\n-                ..\n-            }) => arm_span,\n-            _ => self.span,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum ObligationCauseCode<'tcx> {\n-    /// Not well classified or should be obvious from the span.\n-    MiscObligation,\n-\n-    /// A slice or array is WF only if `T: Sized`.\n-    SliceOrArrayElem,\n-\n-    /// A tuple is WF only if its middle elements are `Sized`.\n-    TupleElem,\n-\n-    /// This is the trait reference from the given projection.\n-    ProjectionWf(ty::ProjectionTy<'tcx>),\n-\n-    /// In an impl of trait `X` for type `Y`, type `Y` must\n-    /// also implement all supertraits of `X`.\n-    ItemObligation(DefId),\n-\n-    /// Like `ItemObligation`, but with extra detail on the source of the obligation.\n-    BindingObligation(DefId, Span),\n-\n-    /// A type like `&'a T` is WF only if `T: 'a`.\n-    ReferenceOutlivesReferent(Ty<'tcx>),\n-\n-    /// A type like `Box<Foo<'a> + 'b>` is WF only if `'b: 'a`.\n-    ObjectTypeBound(Ty<'tcx>, ty::Region<'tcx>),\n-\n-    /// Obligation incurred due to an object cast.\n-    ObjectCastObligation(/* Object type */ Ty<'tcx>),\n-\n-    /// Obligation incurred due to a coercion.\n-    Coercion {\n-        source: Ty<'tcx>,\n-        target: Ty<'tcx>,\n-    },\n-\n-    /// Various cases where expressions must be `Sized` / `Copy` / etc.\n-    /// `L = X` implies that `L` is `Sized`.\n-    AssignmentLhsSized,\n-    /// `(x1, .., xn)` must be `Sized`.\n-    TupleInitializerSized,\n-    /// `S { ... }` must be `Sized`.\n-    StructInitializerSized,\n-    /// Type of each variable must be `Sized`.\n-    VariableType(hir::HirId),\n-    /// Argument type must be `Sized`.\n-    SizedArgumentType,\n-    /// Return type must be `Sized`.\n-    SizedReturnType,\n-    /// Yield type must be `Sized`.\n-    SizedYieldType,\n-    /// `[T, ..n]` implies that `T` must be `Copy`.\n-    /// If `true`, suggest `const_in_array_repeat_expressions` feature flag.\n-    RepeatVec(bool),\n-\n-    /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n-    FieldSized {\n-        adt_kind: AdtKind,\n-        last: bool,\n-    },\n-\n-    /// Constant expressions must be sized.\n-    ConstSized,\n-\n-    /// `static` items must have `Sync` type.\n-    SharedStatic,\n-\n-    BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n-\n-    ImplDerivedObligation(DerivedObligationCause<'tcx>),\n-\n-    /// Error derived when matching traits/impls; see ObligationCause for more details\n-    CompareImplMethodObligation {\n-        item_name: ast::Name,\n-        impl_item_def_id: DefId,\n-        trait_item_def_id: DefId,\n-    },\n-\n-    /// Error derived when matching traits/impls; see ObligationCause for more details\n-    CompareImplTypeObligation {\n-        item_name: ast::Name,\n-        impl_item_def_id: DefId,\n-        trait_item_def_id: DefId,\n-    },\n-\n-    /// Checking that this expression can be assigned where it needs to be\n-    // FIXME(eddyb) #11161 is the original Expr required?\n-    ExprAssignable,\n-\n-    /// Computing common supertype in the arms of a match expression\n-    MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n-\n-    /// Type error arising from type checking a pattern against an expected type.\n-    Pattern {\n-        /// The span of the scrutinee or type expression which caused the `root_ty` type.\n-        span: Option<Span>,\n-        /// The root expected type induced by a scrutinee or type expression.\n-        root_ty: Ty<'tcx>,\n-        /// Whether the `Span` came from an expression or a type expression.\n-        origin_expr: bool,\n-    },\n-\n-    /// Constants in patterns must have `Structural` type.\n-    ConstPatternStructural,\n-\n-    /// Computing common supertype in an if expression\n-    IfExpression(Box<IfExpressionCause>),\n-\n-    /// Computing common supertype of an if expression with no else counter-part\n-    IfExpressionWithNoElse,\n-\n-    /// `main` has wrong type\n-    MainFunctionType,\n-\n-    /// `start` has wrong type\n-    StartFunctionType,\n-\n-    /// Intrinsic has wrong type\n-    IntrinsicType,\n-\n-    /// Method receiver\n-    MethodReceiver,\n-\n-    /// `return` with no expression\n-    ReturnNoExpression,\n-\n-    /// `return` with an expression\n-    ReturnValue(hir::HirId),\n-\n-    /// Return type of this function\n-    ReturnType,\n-\n-    /// Block implicit return\n-    BlockTailExpression(hir::HirId),\n-\n-    /// #[feature(trivial_bounds)] is not enabled\n-    TrivialBound,\n-\n-    AssocTypeBound(Box<AssocTypeBoundData>),\n-}\n-\n-impl ObligationCauseCode<'_> {\n-    // Return the base obligation, ignoring derived obligations.\n-    pub fn peel_derives(&self) -> &Self {\n-        let mut base_cause = self;\n-        while let BuiltinDerivedObligation(cause) | ImplDerivedObligation(cause) = base_cause {\n-            base_cause = &cause.parent_code;\n-        }\n-        base_cause\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct AssocTypeBoundData {\n-    pub impl_span: Option<Span>,\n-    pub original: Span,\n-    pub bounds: Vec<Span>,\n-}\n-\n-// `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(ObligationCauseCode<'_>, 32);\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct MatchExpressionArmCause<'tcx> {\n-    pub arm_span: Span,\n-    pub source: hir::MatchSource,\n-    pub prior_arms: Vec<Span>,\n-    pub last_ty: Ty<'tcx>,\n-    pub scrut_hir_id: hir::HirId,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct IfExpressionCause {\n-    pub then: Span,\n-    pub outer: Option<Span>,\n-    pub semicolon: Option<Span>,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct DerivedObligationCause<'tcx> {\n-    /// The trait reference of the parent obligation that led to the\n-    /// current obligation. Note that only trait obligations lead to\n-    /// derived obligations, so we just store the trait reference here\n-    /// directly.\n-    pub parent_trait_ref: ty::PolyTraitRef<'tcx>,\n-\n-    /// The parent trait had this cause.\n-    pub parent_code: Rc<ObligationCauseCode<'tcx>>,\n-}\n-\n-/// The following types:\n-/// * `WhereClause`,\n-/// * `WellFormed`,\n-/// * `FromEnv`,\n-/// * `DomainGoal`,\n-/// * `Goal`,\n-/// * `Clause`,\n-/// * `Environment`,\n-/// * `InEnvironment`,\n-/// are used for representing the trait system in the form of\n-/// logic programming clauses. They are part of the interface\n-/// for the chalk SLG solver.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum WhereClause<'tcx> {\n-    Implemented(ty::TraitPredicate<'tcx>),\n-    ProjectionEq(ty::ProjectionPredicate<'tcx>),\n-    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n-    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum WellFormed<'tcx> {\n-    Trait(ty::TraitPredicate<'tcx>),\n-    Ty(Ty<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum FromEnv<'tcx> {\n-    Trait(ty::TraitPredicate<'tcx>),\n-    Ty(Ty<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum DomainGoal<'tcx> {\n-    Holds(WhereClause<'tcx>),\n-    WellFormed(WellFormed<'tcx>),\n-    FromEnv(FromEnv<'tcx>),\n-    Normalize(ty::ProjectionPredicate<'tcx>),\n-}\n-\n-pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n-pub enum QuantifierKind {\n-    Universal,\n-    Existential,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum GoalKind<'tcx> {\n-    Implies(Clauses<'tcx>, Goal<'tcx>),\n-    And(Goal<'tcx>, Goal<'tcx>),\n-    Not(Goal<'tcx>),\n-    DomainGoal(DomainGoal<'tcx>),\n-    Quantified(QuantifierKind, ty::Binder<Goal<'tcx>>),\n-    Subtype(Ty<'tcx>, Ty<'tcx>),\n-    CannotProve,\n-}\n-\n-pub type Goal<'tcx> = &'tcx GoalKind<'tcx>;\n-\n-pub type Goals<'tcx> = &'tcx List<Goal<'tcx>>;\n-\n-impl<'tcx> DomainGoal<'tcx> {\n-    pub fn into_goal(self) -> GoalKind<'tcx> {\n-        GoalKind::DomainGoal(self)\n-    }\n-\n-    pub fn into_program_clause(self) -> ProgramClause<'tcx> {\n-        ProgramClause {\n-            goal: self,\n-            hypotheses: ty::List::empty(),\n-            category: ProgramClauseCategory::Other,\n-        }\n-    }\n-}\n-\n-impl<'tcx> GoalKind<'tcx> {\n-    pub fn from_poly_domain_goal(\n-        domain_goal: PolyDomainGoal<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> GoalKind<'tcx> {\n-        match domain_goal.no_bound_vars() {\n-            Some(p) => p.into_goal(),\n-            None => GoalKind::Quantified(\n-                QuantifierKind::Universal,\n-                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal())),\n-            ),\n-        }\n-    }\n-}\n-\n-/// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n-/// Harrop Formulas\".\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub enum Clause<'tcx> {\n-    Implies(ProgramClause<'tcx>),\n-    ForAll(ty::Binder<ProgramClause<'tcx>>),\n-}\n-\n-impl Clause<'tcx> {\n-    pub fn category(self) -> ProgramClauseCategory {\n-        match self {\n-            Clause::Implies(clause) => clause.category,\n-            Clause::ForAll(clause) => clause.skip_binder().category,\n-        }\n-    }\n-}\n-\n-/// Multiple clauses.\n-pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n-\n-/// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n-/// that the domain goal `D` is true if `G1...Gn` are provable. This\n-/// is equivalent to the implication `G1..Gn => D`; we usually write\n-/// it with the reverse implication operator `:-` to emphasize the way\n-/// that programs are actually solved (via backchaining, which starts\n-/// with the goal to solve and proceeds from there).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct ProgramClause<'tcx> {\n-    /// This goal will be considered true ...\n-    pub goal: DomainGoal<'tcx>,\n-\n-    /// ... if we can prove these hypotheses (there may be no hypotheses at all):\n-    pub hypotheses: Goals<'tcx>,\n-\n-    /// Useful for filtering clauses.\n-    pub category: ProgramClauseCategory,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n-pub enum ProgramClauseCategory {\n-    ImpliedBound,\n-    WellFormed,\n-    Other,\n-}\n-\n-/// A set of clauses that we assume to be true.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct Environment<'tcx> {\n-    pub clauses: Clauses<'tcx>,\n-}\n-\n-impl Environment<'tcx> {\n-    pub fn with<G>(self, goal: G) -> InEnvironment<'tcx, G> {\n-        InEnvironment { environment: self, goal }\n-    }\n-}\n-\n-/// Something (usually a goal), along with an environment.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct InEnvironment<'tcx, G> {\n-    pub environment: Environment<'tcx>,\n-    pub goal: G,\n-}\n-\n-#[derive(Clone, Debug, TypeFoldable)]\n-pub enum SelectionError<'tcx> {\n-    Unimplemented,\n-    OutputTypeParameterMismatch(\n-        ty::PolyTraitRef<'tcx>,\n-        ty::PolyTraitRef<'tcx>,\n-        ty::error::TypeError<'tcx>,\n-    ),\n-    TraitNotObjectSafe(DefId),\n-    ConstEvalFailure(ErrorHandled),\n-    Overflow,\n-}\n-\n-/// When performing resolution, it is typically the case that there\n-/// can be one of three outcomes:\n-///\n-/// - `Ok(Some(r))`: success occurred with result `r`\n-/// - `Ok(None)`: could not definitely determine anything, usually due\n-///   to inconclusive type inference.\n-/// - `Err(e)`: error `e` occurred\n-pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n-\n-/// Given the successful resolution of an obligation, the `Vtable`\n-/// indicates where the vtable comes from. Note that while we call this\n-/// a \"vtable\", it does not necessarily indicate dynamic dispatch at\n-/// runtime. `Vtable` instances just tell the compiler where to find\n-/// methods, but in generic code those methods are typically statically\n-/// dispatched -- only when an object is constructed is a `Vtable`\n-/// instance reified into an actual vtable.\n-///\n-/// For example, the vtable may be tied to a specific impl (case A),\n-/// or it may be relative to some bound that is in scope (case B).\n-///\n-/// ```\n-/// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n-/// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n-/// impl Clone for int { ... }             // Impl_3\n-///\n-/// fn foo<T:Clone>(concrete: Option<Box<int>>,\n-///                 param: T,\n-///                 mixed: Option<T>) {\n-///\n-///    // Case A: Vtable points at a specific impl. Only possible when\n-///    // type is concretely known. If the impl itself has bounded\n-///    // type parameters, Vtable will carry resolutions for those as well:\n-///    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n-///\n-///    // Case B: Vtable must be provided by caller. This applies when\n-///    // type is a type parameter.\n-///    param.clone();    // VtableParam\n-///\n-///    // Case C: A mix of cases A and B.\n-///    mixed.clone();    // Vtable(Impl_1, [VtableParam])\n-/// }\n-/// ```\n-///\n-/// ### The type parameter `N`\n-///\n-/// See explanation on `VtableImplData`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub enum Vtable<'tcx, N> {\n-    /// Vtable identifying a particular impl.\n-    VtableImpl(VtableImplData<'tcx, N>),\n-\n-    /// Vtable for auto trait implementations.\n-    /// This carries the information and nested obligations with regards\n-    /// to an auto implementation for a trait `Trait`. The nested obligations\n-    /// ensure the trait implementation holds for all the constituent types.\n-    VtableAutoImpl(VtableAutoImplData<N>),\n-\n-    /// Successful resolution to an obligation provided by the caller\n-    /// for some type parameter. The `Vec<N>` represents the\n-    /// obligations incurred from normalizing the where-clause (if\n-    /// any).\n-    VtableParam(Vec<N>),\n-\n-    /// Virtual calls through an object.\n-    VtableObject(VtableObjectData<'tcx, N>),\n-\n-    /// Successful resolution for a builtin trait.\n-    VtableBuiltin(VtableBuiltinData<N>),\n-\n-    /// Vtable automatically generated for a closure. The `DefId` is the ID\n-    /// of the closure expression. This is a `VtableImpl` in spirit, but the\n-    /// impl is generated by the compiler and does not appear in the source.\n-    VtableClosure(VtableClosureData<'tcx, N>),\n-\n-    /// Same as above, but for a function pointer type with the given signature.\n-    VtableFnPointer(VtableFnPointerData<'tcx, N>),\n-\n-    /// Vtable automatically generated for a generator.\n-    VtableGenerator(VtableGeneratorData<'tcx, N>),\n-\n-    /// Vtable for a trait alias.\n-    VtableTraitAlias(VtableTraitAliasData<'tcx, N>),\n-}\n-\n-impl<'tcx, N> Vtable<'tcx, N> {\n-    pub fn nested_obligations(self) -> Vec<N> {\n-        match self {\n-            VtableImpl(i) => i.nested,\n-            VtableParam(n) => n,\n-            VtableBuiltin(i) => i.nested,\n-            VtableAutoImpl(d) => d.nested,\n-            VtableClosure(c) => c.nested,\n-            VtableGenerator(c) => c.nested,\n-            VtableObject(d) => d.nested,\n-            VtableFnPointer(d) => d.nested,\n-            VtableTraitAlias(d) => d.nested,\n-        }\n-    }\n-\n-    pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M>\n-    where\n-        F: FnMut(N) -> M,\n-    {\n-        match self {\n-            VtableImpl(i) => VtableImpl(VtableImplData {\n-                impl_def_id: i.impl_def_id,\n-                substs: i.substs,\n-                nested: i.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n-            VtableBuiltin(i) => {\n-                VtableBuiltin(VtableBuiltinData { nested: i.nested.into_iter().map(f).collect() })\n-            }\n-            VtableObject(o) => VtableObject(VtableObjectData {\n-                upcast_trait_ref: o.upcast_trait_ref,\n-                vtable_base: o.vtable_base,\n-                nested: o.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableAutoImpl(d) => VtableAutoImpl(VtableAutoImplData {\n-                trait_def_id: d.trait_def_id,\n-                nested: d.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableClosure(c) => VtableClosure(VtableClosureData {\n-                closure_def_id: c.closure_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n-                generator_def_id: c.generator_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n-                fn_ty: p.fn_ty,\n-                nested: p.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableTraitAlias(d) => VtableTraitAlias(VtableTraitAliasData {\n-                alias_def_id: d.alias_def_id,\n-                substs: d.substs,\n-                nested: d.nested.into_iter().map(f).collect(),\n-            }),\n-        }\n-    }\n-}\n-\n-/// Identifies a particular impl in the source, along with a set of\n-/// substitutions from the impl's type/lifetime parameters. The\n-/// `nested` vector corresponds to the nested obligations attached to\n-/// the impl's type parameters.\n-///\n-/// The type parameter `N` indicates the type used for \"nested\n-/// obligations\" that are required by the impl. During type-check, this\n-/// is `Obligation`, as one might expect. During codegen, however, this\n-/// is `()`, because codegen only requires a shallow resolution of an\n-/// impl, and nested obligations are satisfied later.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableImplData<'tcx, N> {\n-    pub impl_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableGeneratorData<'tcx, N> {\n-    pub generator_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the generator\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableClosureData<'tcx, N> {\n-    pub closure_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the closure\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableAutoImplData<N> {\n-    pub trait_def_id: DefId,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableBuiltinData<N> {\n-    pub nested: Vec<N>,\n-}\n-\n-/// A vtable for some object-safe trait `Foo` automatically derived\n-/// for the object type `Foo`.\n-#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableObjectData<'tcx, N> {\n-    /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n-    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-\n-    /// The vtable is formed by concatenating together the method lists of\n-    /// the base object trait and all supertraits; this is the start of\n-    /// `upcast_trait_ref`'s methods in that vtable.\n-    pub vtable_base: usize,\n-\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableFnPointerData<'tcx, N> {\n-    pub fn_ty: Ty<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableTraitAliasData<'tcx, N> {\n-    pub alias_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n-pub trait ExClauseFold<'tcx>\n-where\n-    Self: chalk_engine::context::Context + Clone,\n-{\n-    fn fold_ex_clause_with<F: TypeFolder<'tcx>>(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        folder: &mut F,\n-    ) -> chalk_engine::ExClause<Self>;\n-\n-    fn visit_ex_clause_with<V: TypeVisitor<'tcx>>(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        visitor: &mut V,\n-    ) -> bool;\n-}\n-\n-pub trait ChalkContextLift<'tcx>\n-where\n-    Self: chalk_engine::context::Context + Clone,\n-{\n-    type LiftedExClause: Debug + 'tcx;\n-    type LiftedDelayedLiteral: Debug + 'tcx;\n-    type LiftedLiteral: Debug + 'tcx;\n-\n-    fn lift_ex_clause_to_tcx(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedExClause>;\n-\n-    fn lift_delayed_literal_to_tcx(\n-        ex_clause: &chalk_engine::DelayedLiteral<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedDelayedLiteral>;\n-\n-    fn lift_literal_to_tcx(\n-        ex_clause: &chalk_engine::Literal<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedLiteral>;\n-}"}, {"sha": "ac3d0049c0c7c42908e6cff2df5b90e46ea13c50", "filename": "src/librustc/traits/types/select.rs", "status": "removed", "additions": 0, "deletions": 290, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs?ref=e7a344fb745a0a663e21be947b2619df05df6d31", "patch": "@@ -1,290 +0,0 @@\n-//! Candidate selection. See the [rustc guide] for more information on how this works.\n-//!\n-//! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html#selection\n-\n-use self::EvaluationResult::*;\n-\n-use super::{SelectionError, SelectionResult};\n-\n-use crate::dep_graph::DepNodeIndex;\n-use crate::ty::{self, TyCtxt};\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lock;\n-use rustc_hir::def_id::DefId;\n-\n-#[derive(Clone, Default)]\n-pub struct SelectionCache<'tcx> {\n-    pub hashmap: Lock<\n-        FxHashMap<\n-            ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n-            WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>,\n-        >,\n-    >,\n-}\n-\n-impl<'tcx> SelectionCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n-\n-/// The selection process begins by considering all impls, where\n-/// clauses, and so forth that might resolve an obligation. Sometimes\n-/// we'll be able to say definitively that (e.g.) an impl does not\n-/// apply to the obligation: perhaps it is defined for `usize` but the\n-/// obligation is for `int`. In that case, we drop the impl out of the\n-/// list. But the other cases are considered *candidates*.\n-///\n-/// For selection to succeed, there must be exactly one matching\n-/// candidate. If the obligation is fully known, this is guaranteed\n-/// by coherence. However, if the obligation contains type parameters\n-/// or variables, there may be multiple such impls.\n-///\n-/// It is not a real problem if multiple matching impls exist because\n-/// of type variables - it just means the obligation isn't sufficiently\n-/// elaborated. In that case we report an ambiguity, and the caller can\n-/// try again after more type information has been gathered or report a\n-/// \"type annotations needed\" error.\n-///\n-/// However, with type parameters, this can be a real problem - type\n-/// parameters don't unify with regular types, but they *can* unify\n-/// with variables from blanket impls, and (unless we know its bounds\n-/// will always be satisfied) picking the blanket impl will be wrong\n-/// for at least *some* substitutions. To make this concrete, if we have\n-///\n-///    trait AsDebug { type Out : fmt::Debug; fn debug(self) -> Self::Out; }\n-///    impl<T: fmt::Debug> AsDebug for T {\n-///        type Out = T;\n-///        fn debug(self) -> fmt::Debug { self }\n-///    }\n-///    fn foo<T: AsDebug>(t: T) { println!(\"{:?}\", <T as AsDebug>::debug(t)); }\n-///\n-/// we can't just use the impl to resolve the `<T as AsDebug>` obligation\n-/// -- a type from another crate (that doesn't implement `fmt::Debug`) could\n-/// implement `AsDebug`.\n-///\n-/// Because where-clauses match the type exactly, multiple clauses can\n-/// only match if there are unresolved variables, and we can mostly just\n-/// report this ambiguity in that case. This is still a problem - we can't\n-/// *do anything* with ambiguities that involve only regions. This is issue\n-/// #21974.\n-///\n-/// If a single where-clause matches and there are no inference\n-/// variables left, then it definitely matches and we can just select\n-/// it.\n-///\n-/// In fact, we even select the where-clause when the obligation contains\n-/// inference variables. The can lead to inference making \"leaps of logic\",\n-/// for example in this situation:\n-///\n-///    pub trait Foo<T> { fn foo(&self) -> T; }\n-///    impl<T> Foo<()> for T { fn foo(&self) { } }\n-///    impl Foo<bool> for bool { fn foo(&self) -> bool { *self } }\n-///\n-///    pub fn foo<T>(t: T) where T: Foo<bool> {\n-///       println!(\"{:?}\", <T as Foo<_>>::foo(&t));\n-///    }\n-///    fn main() { foo(false); }\n-///\n-/// Here the obligation `<T as Foo<$0>>` can be matched by both the blanket\n-/// impl and the where-clause. We select the where-clause and unify `$0=bool`,\n-/// so the program prints \"false\". However, if the where-clause is omitted,\n-/// the blanket impl is selected, we unify `$0=()`, and the program prints\n-/// \"()\".\n-///\n-/// Exactly the same issues apply to projection and object candidates, except\n-/// that we can have both a projection candidate and a where-clause candidate\n-/// for the same obligation. In that case either would do (except that\n-/// different \"leaps of logic\" would occur if inference variables are\n-/// present), and we just pick the where-clause. This is, for example,\n-/// required for associated types to work in default impls, as the bounds\n-/// are visible both as projection bounds and as where-clauses from the\n-/// parameter environment.\n-#[derive(PartialEq, Eq, Debug, Clone, TypeFoldable)]\n-pub enum SelectionCandidate<'tcx> {\n-    BuiltinCandidate {\n-        /// `false` if there are no *further* obligations.\n-        has_nested: bool,\n-    },\n-    ParamCandidate(ty::PolyTraitRef<'tcx>),\n-    ImplCandidate(DefId),\n-    AutoImplCandidate(DefId),\n-\n-    /// This is a trait matching with a projected type as `Self`, and\n-    /// we found an applicable bound in the trait definition.\n-    ProjectionCandidate,\n-\n-    /// Implementation of a `Fn`-family trait by one of the anonymous types\n-    /// generated for a `||` expression.\n-    ClosureCandidate,\n-\n-    /// Implementation of a `Generator` trait by one of the anonymous types\n-    /// generated for a generator.\n-    GeneratorCandidate,\n-\n-    /// Implementation of a `Fn`-family trait by one of the anonymous\n-    /// types generated for a fn pointer type (e.g., `fn(int) -> int`)\n-    FnPointerCandidate,\n-\n-    TraitAliasCandidate(DefId),\n-\n-    ObjectCandidate,\n-\n-    BuiltinObjectCandidate,\n-\n-    BuiltinUnsizeCandidate,\n-}\n-\n-/// The result of trait evaluation. The order is important\n-/// here as the evaluation of a list is the maximum of the\n-/// evaluations.\n-///\n-/// The evaluation results are ordered:\n-///     - `EvaluatedToOk` implies `EvaluatedToOkModuloRegions`\n-///       implies `EvaluatedToAmbig` implies `EvaluatedToUnknown`\n-///     - `EvaluatedToErr` implies `EvaluatedToRecur`\n-///     - the \"union\" of evaluation results is equal to their maximum -\n-///     all the \"potential success\" candidates can potentially succeed,\n-///     so they are noops when unioned with a definite error, and within\n-///     the categories it's easy to see that the unions are correct.\n-#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq, HashStable)]\n-pub enum EvaluationResult {\n-    /// Evaluation successful.\n-    EvaluatedToOk,\n-    /// Evaluation successful, but there were unevaluated region obligations.\n-    EvaluatedToOkModuloRegions,\n-    /// Evaluation is known to be ambiguous -- it *might* hold for some\n-    /// assignment of inference variables, but it might not.\n-    ///\n-    /// While this has the same meaning as `EvaluatedToUnknown` -- we can't\n-    /// know whether this obligation holds or not -- it is the result we\n-    /// would get with an empty stack, and therefore is cacheable.\n-    EvaluatedToAmbig,\n-    /// Evaluation failed because of recursion involving inference\n-    /// variables. We are somewhat imprecise there, so we don't actually\n-    /// know the real result.\n-    ///\n-    /// This can't be trivially cached for the same reason as `EvaluatedToRecur`.\n-    EvaluatedToUnknown,\n-    /// Evaluation failed because we encountered an obligation we are already\n-    /// trying to prove on this branch.\n-    ///\n-    /// We know this branch can't be a part of a minimal proof-tree for\n-    /// the \"root\" of our cycle, because then we could cut out the recursion\n-    /// and maintain a valid proof tree. However, this does not mean\n-    /// that all the obligations on this branch do not hold -- it's possible\n-    /// that we entered this branch \"speculatively\", and that there\n-    /// might be some other way to prove this obligation that does not\n-    /// go through this cycle -- so we can't cache this as a failure.\n-    ///\n-    /// For example, suppose we have this:\n-    ///\n-    /// ```rust,ignore (pseudo-Rust)\n-    /// pub trait Trait { fn xyz(); }\n-    /// // This impl is \"useless\", but we can still have\n-    /// // an `impl Trait for SomeUnsizedType` somewhere.\n-    /// impl<T: Trait + Sized> Trait for T { fn xyz() {} }\n-    ///\n-    /// pub fn foo<T: Trait + ?Sized>() {\n-    ///     <T as Trait>::xyz();\n-    /// }\n-    /// ```\n-    ///\n-    /// When checking `foo`, we have to prove `T: Trait`. This basically\n-    /// translates into this:\n-    ///\n-    /// ```plain,ignore\n-    /// (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n-    /// ```\n-    ///\n-    /// When we try to prove it, we first go the first option, which\n-    /// recurses. This shows us that the impl is \"useless\" -- it won't\n-    /// tell us that `T: Trait` unless it already implemented `Trait`\n-    /// by some other means. However, that does not prevent `T: Trait`\n-    /// does not hold, because of the bound (which can indeed be satisfied\n-    /// by `SomeUnsizedType` from another crate).\n-    //\n-    // FIXME: when an `EvaluatedToRecur` goes past its parent root, we\n-    // ought to convert it to an `EvaluatedToErr`, because we know\n-    // there definitely isn't a proof tree for that obligation. Not\n-    // doing so is still sound -- there isn't any proof tree, so the\n-    // branch still can't be a part of a minimal one -- but does not re-enable caching.\n-    EvaluatedToRecur,\n-    /// Evaluation failed.\n-    EvaluatedToErr,\n-}\n-\n-impl EvaluationResult {\n-    /// Returns `true` if this evaluation result is known to apply, even\n-    /// considering outlives constraints.\n-    pub fn must_apply_considering_regions(self) -> bool {\n-        self == EvaluatedToOk\n-    }\n-\n-    /// Returns `true` if this evaluation result is known to apply, ignoring\n-    /// outlives constraints.\n-    pub fn must_apply_modulo_regions(self) -> bool {\n-        self <= EvaluatedToOkModuloRegions\n-    }\n-\n-    pub fn may_apply(self) -> bool {\n-        match self {\n-            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToUnknown => {\n-                true\n-            }\n-\n-            EvaluatedToErr | EvaluatedToRecur => false,\n-        }\n-    }\n-\n-    pub fn is_stack_dependent(self) -> bool {\n-        match self {\n-            EvaluatedToUnknown | EvaluatedToRecur => true,\n-\n-            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToErr => false,\n-        }\n-    }\n-}\n-\n-/// Indicates that trait evaluation caused overflow.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable)]\n-pub struct OverflowError;\n-\n-impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n-    fn from(OverflowError: OverflowError) -> SelectionError<'tcx> {\n-        SelectionError::Overflow\n-    }\n-}\n-\n-#[derive(Clone, Default)]\n-pub struct EvaluationCache<'tcx> {\n-    pub hashmap: Lock<\n-        FxHashMap<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, WithDepNode<EvaluationResult>>,\n-    >,\n-}\n-\n-impl<'tcx> EvaluationCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n-\n-#[derive(Clone, Eq, PartialEq)]\n-pub struct WithDepNode<T> {\n-    dep_node: DepNodeIndex,\n-    cached_value: T,\n-}\n-\n-impl<T: Clone> WithDepNode<T> {\n-    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n-        WithDepNode { dep_node, cached_value }\n-    }\n-\n-    pub fn get(&self, tcx: TyCtxt<'_>) -> T {\n-        tcx.dep_graph.read_index(self.dep_node);\n-        self.cached_value.clone()\n-    }\n-}"}, {"sha": "48ed29f2bb33841cc974147d5b81218453a2cb16", "filename": "src/librustc/traits/types/structural_impls.rs", "status": "removed", "additions": 0, "deletions": 712, "changes": 712, "blob_url": "https://github.com/rust-lang/rust/blob/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Flibrustc%2Ftraits%2Ftypes%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a344fb745a0a663e21be947b2619df05df6d31/src%2Flibrustc%2Ftraits%2Ftypes%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fstructural_impls.rs?ref=e7a344fb745a0a663e21be947b2619df05df6d31", "patch": "@@ -1,712 +0,0 @@\n-use crate::traits;\n-use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::{self, Lift, Ty, TyCtxt};\n-use rustc_span::symbol::Symbol;\n-use smallvec::SmallVec;\n-\n-use std::collections::{BTreeMap, BTreeSet};\n-use std::fmt;\n-use std::rc::Rc;\n-\n-// Structural impls for the structs in `traits`.\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            super::VtableImpl(ref v) => write!(f, \"{:?}\", v),\n-\n-            super::VtableAutoImpl(ref t) => write!(f, \"{:?}\", t),\n-\n-            super::VtableClosure(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::VtableGenerator(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::VtableFnPointer(ref d) => write!(f, \"VtableFnPointer({:?})\", d),\n-\n-            super::VtableObject(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::VtableParam(ref n) => write!(f, \"VtableParam({:?})\", n),\n-\n-            super::VtableBuiltin(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::VtableTraitAlias(ref d) => write!(f, \"{:?}\", d),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableImplData(impl_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.impl_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.generator_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.closure_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"VtableBuiltinData(nested={:?})\", self.nested)\n-    }\n-}\n-\n-impl<N: fmt::Debug> fmt::Debug for traits::VtableAutoImplData<N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableAutoImplData(trait_def_id={:?}, nested={:?})\",\n-            self.trait_def_id, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableObjectData(upcast={:?}, vtable_base={}, nested={:?})\",\n-            self.upcast_trait_ref, self.vtable_base, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"VtableFnPointerData(fn_ty={:?}, nested={:?})\", self.fn_ty, self.nested)\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableTraitAliasData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.alias_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::WhereClause::*;\n-\n-        // Bypass `ty::print` because it does not print out anonymous regions.\n-        // FIXME(eddyb) implement a custom `PrettyPrinter`, or move this to `ty::print`.\n-        fn write_region_name<'tcx>(\n-            r: ty::Region<'tcx>,\n-            fmt: &mut fmt::Formatter<'_>,\n-        ) -> fmt::Result {\n-            match r {\n-                ty::ReLateBound(index, br) => match br {\n-                    ty::BoundRegion::BrNamed(_, name) => write!(fmt, \"{}\", name),\n-                    ty::BoundRegion::BrAnon(var) => {\n-                        if *index == ty::INNERMOST {\n-                            write!(fmt, \"'^{}\", var)\n-                        } else {\n-                            write!(fmt, \"'^{}_{}\", index.index(), var)\n-                        }\n-                    }\n-                    _ => write!(fmt, \"'_\"),\n-                },\n-\n-                _ => write!(fmt, \"{}\", r),\n-            }\n-        }\n-\n-        match self {\n-            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n-            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n-            RegionOutlives(predicate) => {\n-                write!(fmt, \"RegionOutlives({}: \", predicate.0)?;\n-                write_region_name(predicate.1, fmt)?;\n-                write!(fmt, \")\")\n-            }\n-            TypeOutlives(predicate) => {\n-                write!(fmt, \"TypeOutlives({}: \", predicate.0)?;\n-                write_region_name(predicate.1, fmt)?;\n-                write!(fmt, \")\")\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::WellFormed::*;\n-\n-        match self {\n-            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n-            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::FromEnv::*;\n-\n-        match self {\n-            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n-            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::DomainGoal::*;\n-\n-        match self {\n-            Holds(wc) => write!(fmt, \"{}\", wc),\n-            WellFormed(wf) => write!(fmt, \"{}\", wf),\n-            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n-            Normalize(projection) => {\n-                write!(fmt, \"Normalize({} -> {})\", projection.projection_ty, projection.ty)\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Display for traits::QuantifierKind {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::QuantifierKind::*;\n-\n-        match self {\n-            Universal => write!(fmt, \"forall\"),\n-            Existential => write!(fmt, \"exists\"),\n-        }\n-    }\n-}\n-\n-/// Collect names for regions / types bound by a quantified goal / clause.\n-/// This collector does not try to do anything clever like in `ty::print`, it's just used\n-/// for debug output in tests anyway.\n-struct BoundNamesCollector {\n-    // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway.\n-    regions: BTreeSet<Symbol>,\n-\n-    // Sort by `BoundVar` index, so usually this should be equivalent to the order given\n-    // by the list of type parameters.\n-    types: BTreeMap<u32, Symbol>,\n-\n-    binder_index: ty::DebruijnIndex,\n-}\n-\n-impl BoundNamesCollector {\n-    fn new() -> Self {\n-        BoundNamesCollector {\n-            regions: BTreeSet::new(),\n-            types: BTreeMap::new(),\n-            binder_index: ty::INNERMOST,\n-        }\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.regions.is_empty() && self.types.is_empty()\n-    }\n-\n-    fn write_names(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut start = true;\n-        for r in &self.regions {\n-            if !start {\n-                write!(fmt, \", \")?;\n-            }\n-            start = false;\n-            write!(fmt, \"{}\", r)?;\n-        }\n-        for (_, t) in &self.types {\n-            if !start {\n-                write!(fmt, \", \")?;\n-            }\n-            start = false;\n-            write!(fmt, \"{}\", t)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n-        self.binder_index.shift_in(1);\n-        let result = t.super_visit_with(self);\n-        self.binder_index.shift_out(1);\n-        result\n-    }\n-\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-        match t.kind {\n-            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n-                self.types.insert(\n-                    bound_ty.var.as_u32(),\n-                    match bound_ty.kind {\n-                        ty::BoundTyKind::Param(name) => name,\n-                        ty::BoundTyKind::Anon => {\n-                            Symbol::intern(&format!(\"^{}\", bound_ty.var.as_u32()))\n-                        }\n-                    },\n-                );\n-            }\n-\n-            _ => (),\n-        };\n-\n-        t.super_visit_with(self)\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        match r {\n-            ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n-                ty::BoundRegion::BrNamed(_, name) => {\n-                    self.regions.insert(*name);\n-                }\n-\n-                ty::BoundRegion::BrAnon(var) => {\n-                    self.regions.insert(Symbol::intern(&format!(\"'^{}\", var)));\n-                }\n-\n-                _ => (),\n-            },\n-\n-            _ => (),\n-        };\n-\n-        r.super_visit_with(self)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::GoalKind::*;\n-\n-        match self {\n-            Implies(hypotheses, goal) => {\n-                write!(fmt, \"if (\")?;\n-                for (index, hyp) in hypotheses.iter().enumerate() {\n-                    if index > 0 {\n-                        write!(fmt, \", \")?;\n-                    }\n-                    write!(fmt, \"{}\", hyp)?;\n-                }\n-                write!(fmt, \") {{ {} }}\", goal)\n-            }\n-            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n-            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n-            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n-            Quantified(qkind, goal) => {\n-                let mut collector = BoundNamesCollector::new();\n-                goal.skip_binder().visit_with(&mut collector);\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \"{}<\", qkind)?;\n-                    collector.write_names(fmt)?;\n-                    write!(fmt, \"> {{ \")?;\n-                }\n-\n-                write!(fmt, \"{}\", goal.skip_binder())?;\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \" }}\")?;\n-                }\n-\n-                Ok(())\n-            }\n-            Subtype(a, b) => write!(fmt, \"{} <: {}\", a, b),\n-            CannotProve => write!(fmt, \"CannotProve\"),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let traits::ProgramClause { goal, hypotheses, .. } = self;\n-        write!(fmt, \"{}\", goal)?;\n-        if !hypotheses.is_empty() {\n-            write!(fmt, \" :- \")?;\n-            for (index, condition) in hypotheses.iter().enumerate() {\n-                if index > 0 {\n-                    write!(fmt, \", \")?;\n-                }\n-                write!(fmt, \"{}\", condition)?;\n-            }\n-        }\n-        write!(fmt, \".\")\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::Clause::*;\n-\n-        match self {\n-            Implies(clause) => write!(fmt, \"{}\", clause),\n-            ForAll(clause) => {\n-                let mut collector = BoundNamesCollector::new();\n-                clause.skip_binder().visit_with(&mut collector);\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \"forall<\")?;\n-                    collector.write_names(fmt)?;\n-                    write!(fmt, \"> {{ \")?;\n-                }\n-\n-                write!(fmt, \"{}\", clause.skip_binder())?;\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \" }}\")?;\n-                }\n-\n-                Ok(())\n-            }\n-        }\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Lift implementations\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n-    type Lifted = traits::SelectionError<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::Unimplemented => Some(super::Unimplemented),\n-            super::OutputTypeParameterMismatch(a, b, ref err) => {\n-                tcx.lift(&(a, b)).and_then(|(a, b)| {\n-                    tcx.lift(err).map(|err| super::OutputTypeParameterMismatch(a, b, err))\n-                })\n-            }\n-            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n-            super::ConstEvalFailure(err) => Some(super::ConstEvalFailure(err)),\n-            super::Overflow => Some(super::Overflow),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n-    type Lifted = traits::ObligationCauseCode<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::ReturnNoExpression => Some(super::ReturnNoExpression),\n-            super::MiscObligation => Some(super::MiscObligation),\n-            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n-            super::TupleElem => Some(super::TupleElem),\n-            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n-            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n-            super::BindingObligation(def_id, span) => Some(super::BindingObligation(def_id, span)),\n-            super::ReferenceOutlivesReferent(ty) => {\n-                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n-            }\n-            super::ObjectTypeBound(ty, r) => tcx\n-                .lift(&ty)\n-                .and_then(|ty| tcx.lift(&r).and_then(|r| Some(super::ObjectTypeBound(ty, r)))),\n-            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n-            super::Coercion { source, target } => {\n-                Some(super::Coercion { source: tcx.lift(&source)?, target: tcx.lift(&target)? })\n-            }\n-            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n-            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n-            super::StructInitializerSized => Some(super::StructInitializerSized),\n-            super::VariableType(id) => Some(super::VariableType(id)),\n-            super::ReturnValue(id) => Some(super::ReturnValue(id)),\n-            super::ReturnType => Some(super::ReturnType),\n-            super::SizedArgumentType => Some(super::SizedArgumentType),\n-            super::SizedReturnType => Some(super::SizedReturnType),\n-            super::SizedYieldType => Some(super::SizedYieldType),\n-            super::RepeatVec(suggest_flag) => Some(super::RepeatVec(suggest_flag)),\n-            super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n-            super::ConstSized => Some(super::ConstSized),\n-            super::ConstPatternStructural => Some(super::ConstPatternStructural),\n-            super::SharedStatic => Some(super::SharedStatic),\n-            super::BuiltinDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n-            }\n-            super::ImplDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::ImplDerivedObligation)\n-            }\n-            super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            } => Some(super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            }),\n-            super::CompareImplTypeObligation { item_name, impl_item_def_id, trait_item_def_id } => {\n-                Some(super::CompareImplTypeObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                })\n-            }\n-            super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm(box super::MatchExpressionArmCause {\n-                arm_span,\n-                source,\n-                ref prior_arms,\n-                last_ty,\n-                scrut_hir_id,\n-            }) => tcx.lift(&last_ty).map(|last_ty| {\n-                super::MatchExpressionArm(box super::MatchExpressionArmCause {\n-                    arm_span,\n-                    source,\n-                    prior_arms: prior_arms.clone(),\n-                    last_ty,\n-                    scrut_hir_id,\n-                })\n-            }),\n-            super::Pattern { span, root_ty, origin_expr } => {\n-                tcx.lift(&root_ty).map(|root_ty| super::Pattern { span, root_ty, origin_expr })\n-            }\n-            super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n-                Some(super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }))\n-            }\n-            super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n-            super::MainFunctionType => Some(super::MainFunctionType),\n-            super::StartFunctionType => Some(super::StartFunctionType),\n-            super::IntrinsicType => Some(super::IntrinsicType),\n-            super::MethodReceiver => Some(super::MethodReceiver),\n-            super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n-            super::TrivialBound => Some(super::TrivialBound),\n-            super::AssocTypeBound(ref data) => Some(super::AssocTypeBound(data.clone())),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n-    type Lifted = traits::DerivedObligationCause<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n-            tcx.lift(&*self.parent_code).map(|code| traits::DerivedObligationCause {\n-                parent_trait_ref: trait_ref,\n-                parent_code: Rc::new(code),\n-            })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n-    type Lifted = traits::ObligationCause<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.code).map(|code| traits::ObligationCause {\n-            span: self.span,\n-            body_id: self.body_id,\n-            code,\n-        })\n-    }\n-}\n-\n-// For codegen only.\n-impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n-    type Lifted = traits::Vtable<'tcx, ()>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self.clone() {\n-            traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested })\n-                })\n-            }\n-            traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n-            traits::VtableGenerator(traits::VtableGeneratorData {\n-                generator_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::VtableGenerator(traits::VtableGeneratorData {\n-                    generator_def_id: generator_def_id,\n-                    substs: substs,\n-                    nested: nested,\n-                })\n-            }),\n-            traits::VtableClosure(traits::VtableClosureData { closure_def_id, substs, nested }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableClosure(traits::VtableClosureData {\n-                        closure_def_id,\n-                        substs,\n-                        nested,\n-                    })\n-                })\n-            }\n-            traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n-                tcx.lift(&fn_ty).map(|fn_ty| {\n-                    traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n-                })\n-            }\n-            traits::VtableParam(n) => Some(traits::VtableParam(n)),\n-            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n-            traits::VtableObject(traits::VtableObjectData {\n-                upcast_trait_ref,\n-                vtable_base,\n-                nested,\n-            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n-                traits::VtableObject(traits::VtableObjectData {\n-                    upcast_trait_ref: trait_ref,\n-                    vtable_base,\n-                    nested,\n-                })\n-            }),\n-            traits::VtableTraitAlias(traits::VtableTraitAliasData {\n-                alias_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::VtableTraitAlias(traits::VtableTraitAliasData {\n-                    alias_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n-    type Lifted = traits::Environment<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.clauses).map(|clauses| traits::Environment { clauses })\n-    }\n-}\n-\n-impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n-    type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.environment).and_then(|environment| {\n-            tcx.lift(&self.goal).map(|goal| traits::InEnvironment { environment, goal })\n-        })\n-    }\n-}\n-\n-impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ChalkContextLift<'tcx>,\n-{\n-    type Lifted = C::LiftedExClause;\n-\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ChalkContextLift>::lift_ex_clause_to_tcx(self, tcx)\n-    }\n-}\n-\n-impl<'tcx, C> Lift<'tcx> for chalk_engine::DelayedLiteral<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ChalkContextLift<'tcx>,\n-{\n-    type Lifted = C::LiftedDelayedLiteral;\n-\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ChalkContextLift>::lift_delayed_literal_to_tcx(self, tcx)\n-    }\n-}\n-\n-impl<'tcx, C> Lift<'tcx> for chalk_engine::Literal<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ChalkContextLift<'tcx>,\n-{\n-    type Lifted = C::LiftedLiteral;\n-\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ChalkContextLift>::lift_literal_to_tcx(self, tcx)\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// TypeFoldable implementations.\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    traits::QuantifierKind,\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_goals(&v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = (**self).fold_with(folder);\n-        folder.tcx().mk_goal(v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        (**self).visit_with(visitor)\n-    }\n-}\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    traits::ProgramClauseCategory,\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::Clauses<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_clauses(&v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::ExClause<C>\n-where\n-    C: traits::ExClauseFold<'tcx>,\n-    C::Substitution: Clone,\n-    C::RegionConstraint: Clone,\n-{\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        <C as traits::ExClauseFold>::fold_ex_clause_with(self, folder)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        <C as traits::ExClauseFold>::visit_ex_clause_with(self, visitor)\n-    }\n-}\n-\n-EnumTypeFoldableImpl! {\n-    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::DelayedLiteral<C> {\n-        (chalk_engine::DelayedLiteral::CannotProve)(a),\n-        (chalk_engine::DelayedLiteral::Negative)(a),\n-        (chalk_engine::DelayedLiteral::Positive)(a, b),\n-    } where\n-        C: chalk_engine::context::Context<CanonicalConstrainedSubst: TypeFoldable<'tcx>> + Clone,\n-}\n-\n-EnumTypeFoldableImpl! {\n-    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::Literal<C> {\n-        (chalk_engine::Literal::Negative)(a),\n-        (chalk_engine::Literal::Positive)(a),\n-    } where\n-        C: chalk_engine::context::Context<GoalInEnvironment: Clone + TypeFoldable<'tcx>> + Clone,\n-}\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    chalk_engine::TableIndex,\n-}"}, {"sha": "851bffc2065c972d89c26a14242faa1a608eb7be", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -122,6 +122,7 @@ impl<'tcx> OverloadedDeref<'tcx> {\n         };\n         let method_def_id = tcx\n             .associated_items(trait_def_id.unwrap())\n+            .in_definition_order()\n             .find(|m| m.kind == ty::AssocKind::Method)\n             .unwrap()\n             .def_id;"}, {"sha": "c305999a64ba7ffd60b89984a7bb049b27283f4c", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -301,6 +301,7 @@ where\n macro_rules! __impl_decoder_methods {\n     ($($name:ident -> $ty:ty;)*) => {\n         $(\n+            #[inline]\n             fn $name(&mut self) -> Result<$ty, Self::Error> {\n                 self.opaque.$name()\n             }"}, {"sha": "c027d6f61b01f2d32e5520773a04331189b27e39", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -2,7 +2,7 @@\n \n use crate::arena::Arena;\n use crate::dep_graph::DepGraph;\n-use crate::dep_graph::{self, DepConstructor, DepNode};\n+use crate::dep_graph::{self, DepConstructor};\n use crate::hir::exports::Export;\n use crate::hir::map as hir_map;\n use crate::hir::map::DefPathHash;\n@@ -41,6 +41,7 @@ use crate::ty::{ExistentialPredicate, InferTy, ParamTy, PolyFnSig, Predicate, Pr\n use crate::ty::{InferConst, ParamConst};\n use crate::ty::{List, TyKind, TyS};\n use crate::util::common::ErrorReported;\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::SelfProfilerRef;\n@@ -49,7 +50,6 @@ use rustc_data_structures::stable_hasher::{\n     hash_stable_hashmap, HashStable, StableHasher, StableVec,\n };\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n-use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, DefIndex, LOCAL_CRATE};\n@@ -1161,6 +1161,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         for (k, v) in resolutions.trait_map {\n             let hir_id = hir.node_to_hir_id(k);\n             let map = trait_map.entry(hir_id.owner).or_default();\n+            let v = v\n+                .into_iter()\n+                .map(|tc| tc.map_import_ids(|id| hir.definitions().node_to_hir_id(id)))\n+                .collect();\n             map.insert(hir_id.local_id, StableVec::new(v));\n         }\n \n@@ -1343,7 +1347,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // We cannot use the query versions of crates() and crate_hash(), since\n         // those would need the DepNodes that we are allocating here.\n         for cnum in self.cstore.crates_untracked() {\n-            let dep_node = DepNode::new(self, DepConstructor::CrateMetadata(cnum));\n+            let dep_node = DepConstructor::CrateMetadata(self, cnum);\n             let crate_hash = self.cstore.crate_hash_untracked(cnum);\n             self.dep_graph.with_task(\n                 dep_node,\n@@ -1522,7 +1526,7 @@ impl<'tcx> GlobalCtxt<'tcx> {\n         ty::tls::with_related_context(tcx, |icx| {\n             let new_icx = ty::tls::ImplicitCtxt {\n                 tcx,\n-                query: icx.query.clone(),\n+                query: icx.query,\n                 diagnostics: icx.diagnostics,\n                 layout_depth: icx.layout_depth,\n                 task_deps: icx.task_deps,\n@@ -1608,7 +1612,7 @@ pub mod tls {\n \n     use crate::dep_graph::TaskDeps;\n     use crate::ty::query;\n-    use rustc_data_structures::sync::{self, Lock, Lrc};\n+    use rustc_data_structures::sync::{self, Lock};\n     use rustc_data_structures::thin_vec::ThinVec;\n     use rustc_data_structures::OnDrop;\n     use rustc_errors::Diagnostic;\n@@ -1633,7 +1637,7 @@ pub mod tls {\n \n         /// The current query job, if any. This is updated by `JobOwner::start` in\n         /// `ty::query::plumbing` when executing a query.\n-        pub query: Option<Lrc<query::QueryJob<'tcx>>>,\n+        pub query: Option<query::QueryJobId>,\n \n         /// Where to store diagnostics for the current query job, if any.\n         /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n@@ -1684,6 +1688,7 @@ pub mod tls {\n \n     /// Gets the pointer to the current `ImplicitCtxt`.\n     #[cfg(not(parallel_compiler))]\n+    #[inline]\n     fn get_tlv() -> usize {\n         TLV.with(|tlv| tlv.get())\n     }\n@@ -2551,16 +2556,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         iter.intern_with(|xs| self.intern_goals(xs))\n     }\n \n-    pub fn lint_hir(\n-        self,\n-        lint: &'static Lint,\n-        hir_id: HirId,\n-        span: impl Into<MultiSpan>,\n-        msg: &str,\n-    ) {\n-        self.struct_span_lint_hir(lint, hir_id, span.into(), msg).emit()\n-    }\n-\n     /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n     /// It stops at `bound` and just returns it if reached.\n     pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n@@ -2604,20 +2599,20 @@ impl<'tcx> TyCtxt<'tcx> {\n         lint: &'static Lint,\n         hir_id: HirId,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'tcx> {\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n         let (level, src) = self.lint_level_at_node(lint, hir_id);\n-        struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n+        struct_lint_level(self.sess, lint, level, src, Some(span.into()), decorate);\n     }\n \n     pub fn struct_lint_node(\n         self,\n         lint: &'static Lint,\n         id: HirId,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'tcx> {\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n         let (level, src) = self.lint_level_at_node(lint, id);\n-        struct_lint_level(self.sess, lint, level, src, None, msg)\n+        struct_lint_level(self.sess, lint, level, src, None, decorate);\n     }\n \n     pub fn in_scope_traits(self, id: HirId) -> Option<&'tcx StableVec<TraitCandidate>> {\n@@ -2726,10 +2721,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.crate_name\n     };\n-    providers.get_lang_items = |tcx, id| {\n-        assert_eq!(id, LOCAL_CRATE);\n-        tcx.arena.alloc(middle::lang_items::collect(tcx))\n-    };\n     providers.maybe_unused_trait_import = |tcx, id| tcx.maybe_unused_trait_imports.contains(&id);\n     providers.maybe_unused_extern_crates = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "6c5458e6e58a6f05c4899df2d847520d83342525", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -483,8 +483,9 @@ impl Trait for X {\n                 if ty.is_closure() || ty.is_generator() {\n                     db.note(\n                         \"closures cannot capture themselves or take themselves as argument;\\n\\\n-                             this error may be the result of a recent compiler bug-fix,\\n\\\n-                             see https://github.com/rust-lang/rust/issues/46062 for more details\",\n+                         this error may be the result of a recent compiler bug-fix,\\n\\\n+                         see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\\n\\\n+                         for more information\",\n                     );\n                 }\n             }"}, {"sha": "4546eadc6e6e13c11be294577d9a357782d0bf12", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -138,7 +138,7 @@ impl FlagComputation {\n             }\n \n             &ty::Opaque(_, substs) => {\n-                self.add_flags(TypeFlags::HAS_PROJECTION);\n+                self.add_flags(TypeFlags::HAS_PROJECTION | TypeFlags::HAS_TY_OPAQUE);\n                 self.add_substs(substs);\n             }\n "}, {"sha": "3212bc7241783df6a4f3e506b4d2ea495295b3c9", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -32,6 +32,7 @@\n //! looking for, and does not need to visit anything else.\n \n use crate::ty::{self, flags::FlagComputation, Binder, Ty, TyCtxt, TypeFlags};\n+use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n \n use rustc_data_structures::fx::FxHashSet;\n@@ -77,6 +78,9 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n     }\n+    fn has_opaque_types(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n+    }\n     fn references_error(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_ERR)\n     }\n@@ -119,6 +123,10 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n     }\n \n+    fn has_erased_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_RE_ERASED)\n+    }\n+\n     /// True if there are any un-erased free regions.\n     fn has_erasable_regions(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n@@ -150,7 +158,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     }\n }\n \n-impl TypeFoldable<'tcx> for syntax::ast::Constness {\n+impl TypeFoldable<'tcx> for hir::Constness {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n         *self\n     }"}, {"sha": "0ec30bc583cf89971a3e1b3a2f9d8e0e8df62483", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 21, "deletions": 123, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,12 +1,11 @@\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::middle::lang_items::DropInPlaceFnLangItem;\n-use crate::traits;\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::{self, SubstsRef, Ty, TyCtxt, TypeFoldable};\n+use rustc_data_structures::AtomicRef;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_macros::HashStable;\n-use rustc_target::spec::abi::Abi;\n \n use std::fmt;\n \n@@ -263,45 +262,7 @@ impl<'tcx> Instance<'tcx> {\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> Option<Instance<'tcx>> {\n-        debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n-        let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n-            debug!(\" => associated item, attempting to find impl in param_env {:#?}\", param_env);\n-            let item = tcx.associated_item(def_id);\n-            resolve_associated_item(tcx, &item, param_env, trait_def_id, substs)\n-        } else {\n-            let ty = tcx.type_of(def_id);\n-            let item_type = tcx.subst_and_normalize_erasing_regions(substs, param_env, &ty);\n-\n-            let def = match item_type.kind {\n-                ty::FnDef(..)\n-                    if {\n-                        let f = item_type.fn_sig(tcx);\n-                        f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic\n-                    } =>\n-                {\n-                    debug!(\" => intrinsic\");\n-                    ty::InstanceDef::Intrinsic(def_id)\n-                }\n-                _ => {\n-                    if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n-                        let ty = substs.type_at(0);\n-                        if ty.needs_drop(tcx, ty::ParamEnv::reveal_all()) {\n-                            debug!(\" => nontrivial drop glue\");\n-                            ty::InstanceDef::DropGlue(def_id, Some(ty))\n-                        } else {\n-                            debug!(\" => trivial drop glue\");\n-                            ty::InstanceDef::DropGlue(def_id, None)\n-                        }\n-                    } else {\n-                        debug!(\" => free item\");\n-                        ty::InstanceDef::Item(def_id)\n-                    }\n-                }\n-            };\n-            Some(Instance { def: def, substs: substs })\n-        };\n-        debug!(\"resolve(def_id={:?}, substs={:?}) = {:?}\", def_id, substs, result);\n-        result\n+        (*RESOLVE_INSTANCE)(tcx, param_env, def_id, substs)\n     }\n \n     pub fn resolve_for_fn_ptr(\n@@ -376,6 +337,7 @@ impl<'tcx> Instance<'tcx> {\n         let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n         let call_once = tcx\n             .associated_items(fn_once)\n+            .in_definition_order()\n             .find(|it| it.kind == ty::AssocKind::Method)\n             .unwrap()\n             .def_id;\n@@ -397,88 +359,6 @@ impl<'tcx> Instance<'tcx> {\n     }\n }\n \n-fn resolve_associated_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_item: &ty::AssocItem,\n-    param_env: ty::ParamEnv<'tcx>,\n-    trait_id: DefId,\n-    rcvr_substs: SubstsRef<'tcx>,\n-) -> Option<Instance<'tcx>> {\n-    let def_id = trait_item.def_id;\n-    debug!(\n-        \"resolve_associated_item(trait_item={:?}, \\\n-            param_env={:?}, \\\n-            trait_id={:?}, \\\n-            rcvr_substs={:?})\",\n-        def_id, param_env, trait_id, rcvr_substs\n-    );\n-\n-    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = tcx.codegen_fulfill_obligation((param_env, ty::Binder::bind(trait_ref)));\n-\n-    // Now that we know which impl is being used, we can dispatch to\n-    // the actual function:\n-    match vtbl {\n-        traits::VtableImpl(impl_data) => {\n-            let (def_id, substs) =\n-                traits::find_associated_item(tcx, param_env, trait_item, rcvr_substs, &impl_data);\n-\n-            let resolved_item = tcx.associated_item(def_id);\n-\n-            // Since this is a trait item, we need to see if the item is either a trait default item\n-            // or a specialization because we can't resolve those unless we can `Reveal::All`.\n-            // NOTE: This should be kept in sync with the similar code in\n-            // `rustc::traits::project::assemble_candidates_from_impls()`.\n-            let eligible = if !resolved_item.defaultness.is_default() {\n-                true\n-            } else if param_env.reveal == traits::Reveal::All {\n-                !trait_ref.needs_subst()\n-            } else {\n-                false\n-            };\n-\n-            if !eligible {\n-                return None;\n-            }\n-\n-            let substs = tcx.erase_regions(&substs);\n-            Some(ty::Instance::new(def_id, substs))\n-        }\n-        traits::VtableGenerator(generator_data) => Some(Instance {\n-            def: ty::InstanceDef::Item(generator_data.generator_def_id),\n-            substs: generator_data.substs,\n-        }),\n-        traits::VtableClosure(closure_data) => {\n-            let trait_closure_kind = tcx.lang_items().fn_trait_kind(trait_id).unwrap();\n-            Some(Instance::resolve_closure(\n-                tcx,\n-                closure_data.closure_def_id,\n-                closure_data.substs,\n-                trait_closure_kind,\n-            ))\n-        }\n-        traits::VtableFnPointer(ref data) => Some(Instance {\n-            def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n-            substs: rcvr_substs,\n-        }),\n-        traits::VtableObject(ref data) => {\n-            let index = traits::get_vtable_index_of_object_method(tcx, data, def_id);\n-            Some(Instance { def: ty::InstanceDef::Virtual(def_id, index), substs: rcvr_substs })\n-        }\n-        traits::VtableBuiltin(..) => {\n-            if tcx.lang_items().clone_trait().is_some() {\n-                Some(Instance {\n-                    def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n-                    substs: rcvr_substs,\n-                })\n-            } else {\n-                None\n-            }\n-        }\n-        traits::VtableAutoImpl(..) | traits::VtableParam(..) | traits::VtableTraitAlias(..) => None,\n-    }\n-}\n-\n fn needs_fn_once_adapter_shim(\n     actual_closure_kind: ty::ClosureKind,\n     trait_closure_kind: ty::ClosureKind,\n@@ -511,3 +391,21 @@ fn needs_fn_once_adapter_shim(\n         (ty::ClosureKind::FnMut, _) | (ty::ClosureKind::FnOnce, _) => Err(()),\n     }\n }\n+\n+fn resolve_instance_default(\n+    _tcx: TyCtxt<'tcx>,\n+    _param_env: ty::ParamEnv<'tcx>,\n+    _def_id: DefId,\n+    _substs: SubstsRef<'tcx>,\n+) -> Option<Instance<'tcx>> {\n+    unimplemented!()\n+}\n+\n+pub static RESOLVE_INSTANCE: AtomicRef<\n+    for<'tcx> fn(\n+        TyCtxt<'tcx>,\n+        ty::ParamEnv<'tcx>,\n+        DefId,\n+        SubstsRef<'tcx>,\n+    ) -> Option<Instance<'tcx>>,\n+> = AtomicRef::new(&(resolve_instance_default as _));"}, {"sha": "e8bf2eb9a12c98413c9e01131e095336492fb7af", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -356,12 +356,14 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n             offsets[i as usize] = offset;\n \n-            if let Some(mut niche) = field.largest_niche.clone() {\n-                let available = niche.available(dl);\n-                if available > largest_niche_available {\n-                    largest_niche_available = available;\n-                    niche.offset += offset;\n-                    largest_niche = Some(niche);\n+            if !repr.hide_niche() {\n+                if let Some(mut niche) = field.largest_niche.clone() {\n+                    let available = niche.available(dl);\n+                    if available > largest_niche_available {\n+                        largest_niche_available = available;\n+                        niche.offset += offset;\n+                        largest_niche = Some(niche);\n+                    }\n                 }\n             }\n \n@@ -838,7 +840,11 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             }\n \n                             // Update `largest_niche` if we have introduced a larger niche.\n-                            let niche = Niche::from_scalar(dl, Size::ZERO, scalar.clone());\n+                            let niche = if def.repr.hide_niche() {\n+                                None\n+                            } else {\n+                                Niche::from_scalar(dl, Size::ZERO, scalar.clone())\n+                            };\n                             if let Some(niche) = niche {\n                                 match &st.largest_niche {\n                                     Some(largest_niche) => {\n@@ -863,6 +869,11 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     return Ok(tcx.intern_layout(st));\n                 }\n \n+                // At this point, we have handled all unions and\n+                // structs. (We have also handled univariant enums\n+                // that allow representation optimization.)\n+                assert!(def.is_enum());\n+\n                 // The current code for niche-filling relies on variant indices\n                 // instead of actual discriminants, so dataful enums with\n                 // explicit discriminants (RFC #2363) would misbehave."}, {"sha": "d17ef3a6c9a8cce5ff7238ee985ac5c5c808e5a1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 132, "deletions": 38, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -30,20 +30,21 @@ use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{self, par_iter, Lrc, ParallelIterator};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc_hir::{GlobMap, Node, TraitMap};\n+use rustc_hir::{Constness, GlobMap, Node, TraitMap};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_serialize::{self, Encodable, Encoder};\n use rustc_span::hygiene::ExpnId;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::Align;\n-use syntax::ast::{self, Constness, Ident, Name};\n+use syntax::ast::{self, Ident, Name};\n use syntax::node_id::{NodeId, NodeMap, NodeSet};\n \n use std::cell::RefCell;\n@@ -83,6 +84,7 @@ pub use self::context::{\n     CtxtInterners, GeneratorInteriorTypeCause, GlobalCtxt, Lift, TypeckTables,\n };\n \n+pub use self::instance::RESOLVE_INSTANCE;\n pub use self::instance::{Instance, InstanceDef};\n \n pub use self::trait_def::TraitDef;\n@@ -126,7 +128,7 @@ pub struct ResolverOutputs {\n     pub definitions: hir_map::Definitions,\n     pub cstore: Box<CrateStoreDyn>,\n     pub extern_crate_map: NodeMap<CrateNum>,\n-    pub trait_map: TraitMap,\n+    pub trait_map: TraitMap<NodeId>,\n     pub maybe_unused_trait_imports: NodeSet,\n     pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n     pub export_map: ExportMap<NodeId>,\n@@ -215,6 +217,13 @@ impl AssocKind {\n             ty::AssocKind::Const => \"associated constant\",\n         }\n     }\n+\n+    pub fn namespace(&self) -> Namespace {\n+        match *self {\n+            ty::AssocKind::OpaqueTy | ty::AssocKind::Type => Namespace::TypeNS,\n+            ty::AssocKind::Const | ty::AssocKind::Method => Namespace::ValueNS,\n+        }\n+    }\n }\n \n impl AssocItem {\n@@ -256,6 +265,81 @@ impl AssocItem {\n     }\n }\n \n+/// A list of `ty::AssocItem`s in definition order that allows for efficient lookup by name.\n+///\n+/// When doing lookup by name, we try to postpone hygienic comparison for as long as possible since\n+/// it is relatively expensive. Instead, items are indexed by `Symbol` and hygienic comparison is\n+/// done only on items with the same name.\n+#[derive(Debug, Clone, PartialEq, HashStable)]\n+pub struct AssociatedItems {\n+    items: SortedIndexMultiMap<u32, Symbol, ty::AssocItem>,\n+}\n+\n+impl AssociatedItems {\n+    /// Constructs an `AssociatedItems` map from a series of `ty::AssocItem`s in definition order.\n+    pub fn new(items_in_def_order: impl IntoIterator<Item = ty::AssocItem>) -> Self {\n+        let items = items_in_def_order.into_iter().map(|item| (item.ident.name, item)).collect();\n+        AssociatedItems { items }\n+    }\n+\n+    /// Returns a slice of associated items in the order they were defined.\n+    ///\n+    /// New code should avoid relying on definition order. If you need a particular associated item\n+    /// for a known trait, make that trait a lang item instead of indexing this array.\n+    pub fn in_definition_order(&self) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n+        self.items.iter().map(|(_, v)| v)\n+    }\n+\n+    /// Returns an iterator over all associated items with the given name, ignoring hygiene.\n+    pub fn filter_by_name_unhygienic(\n+        &self,\n+        name: Symbol,\n+    ) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n+        self.items.get_by_key(&name)\n+    }\n+\n+    /// Returns an iterator over all associated items with the given name.\n+    ///\n+    /// Multiple items may have the same name if they are in different `Namespace`s. For example,\n+    /// an associated type can have the same name as a method. Use one of the `find_by_name_and_*`\n+    /// methods below if you know which item you are looking for.\n+    pub fn filter_by_name(\n+        &'a self,\n+        tcx: TyCtxt<'a>,\n+        ident: Ident,\n+        parent_def_id: DefId,\n+    ) -> impl 'a + Iterator<Item = &'a ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(move |item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+\n+    /// Returns the associated item with the given name and `AssocKind`, if one exists.\n+    pub fn find_by_name_and_kind(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        ident: Ident,\n+        kind: AssocKind,\n+        parent_def_id: DefId,\n+    ) -> Option<&ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(|item| item.kind == kind)\n+            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+\n+    /// Returns the associated item with the given name in the given `Namespace`, if one exists.\n+    pub fn find_by_name_and_namespace(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_def_id: DefId,\n+    ) -> Option<&ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(|item| item.kind.namespace() == ns)\n+            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n@@ -473,10 +557,15 @@ bitflags! {\n         /// if a global bound is safe to evaluate.\n         const HAS_RE_LATE_BOUND  = 1 << 11;\n \n-        const HAS_TY_PLACEHOLDER = 1 << 12;\n+        /// Does this have any `ReErased` regions?\n+        const HAS_RE_ERASED  = 1 << 12;\n+\n+        const HAS_TY_PLACEHOLDER = 1 << 13;\n \n-        const HAS_CT_INFER       = 1 << 13;\n-        const HAS_CT_PLACEHOLDER = 1 << 14;\n+        const HAS_CT_INFER       = 1 << 14;\n+        const HAS_CT_PLACEHOLDER = 1 << 15;\n+        /// Does this have any [Opaque] types.\n+        const HAS_TY_OPAQUE      = 1 << 16;\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n@@ -496,9 +585,11 @@ bitflags! {\n                                   TypeFlags::HAS_FREE_LOCAL_NAMES.bits |\n                                   TypeFlags::KEEP_IN_LOCAL_TCX.bits |\n                                   TypeFlags::HAS_RE_LATE_BOUND.bits |\n+                                  TypeFlags::HAS_RE_ERASED.bits |\n                                   TypeFlags::HAS_TY_PLACEHOLDER.bits |\n                                   TypeFlags::HAS_CT_INFER.bits |\n-                                  TypeFlags::HAS_CT_PLACEHOLDER.bits;\n+                                  TypeFlags::HAS_CT_PLACEHOLDER.bits |\n+                                  TypeFlags::HAS_TY_OPAQUE.bits;\n     }\n }\n \n@@ -1356,7 +1447,7 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&TraitRef<'tcx>> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n         ty::Predicate::Trait(\n-            ty::Binder::dummy(ty::TraitPredicate { trait_ref: self.value.clone() }),\n+            ty::Binder::dummy(ty::TraitPredicate { trait_ref: *self.value }),\n             self.constness,\n         )\n     }\n@@ -1796,19 +1887,22 @@ bitflags! {\n         const IS_STRUCT           = 1 << 2;\n         /// Indicates whether the ADT is a struct and has a constructor.\n         const HAS_CTOR            = 1 << 3;\n-        /// Indicates whether the type is a `PhantomData`.\n+        /// Indicates whether the type is `PhantomData`.\n         const IS_PHANTOM_DATA     = 1 << 4;\n         /// Indicates whether the type has a `#[fundamental]` attribute.\n         const IS_FUNDAMENTAL      = 1 << 5;\n-        /// Indicates whether the type is a `Box`.\n+        /// Indicates whether the type is `Box`.\n         const IS_BOX              = 1 << 6;\n+        /// Indicates whether the type is `ManuallyDrop`.\n+        const IS_MANUALLY_DROP    = 1 << 7;\n+        // FIXME(matthewjasper) replace these with diagnostic items\n         /// Indicates whether the type is an `Arc`.\n-        const IS_ARC              = 1 << 7;\n+        const IS_ARC              = 1 << 8;\n         /// Indicates whether the type is an `Rc`.\n-        const IS_RC               = 1 << 8;\n+        const IS_RC               = 1 << 9;\n         /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n         /// (i.e., this flag is never set unless this ADT is an enum).\n-        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 9;\n+        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 10;\n     }\n }\n \n@@ -2041,7 +2135,8 @@ bitflags! {\n         const IS_TRANSPARENT     = 1 << 2;\n         // Internal only for now. If true, don't reorder fields.\n         const IS_LINEAR          = 1 << 3;\n-\n+        // If true, don't expose any niche to type's context.\n+        const HIDE_NICHE         = 1 << 4;\n         // Any of these flags being set prevent field reordering optimisation.\n         const IS_UNOPTIMISABLE   = ReprFlags::IS_C.bits |\n                                    ReprFlags::IS_SIMD.bits |\n@@ -2078,6 +2173,7 @@ impl ReprOptions {\n                         ReprFlags::empty()\n                     }\n                     attr::ReprTransparent => ReprFlags::IS_TRANSPARENT,\n+                    attr::ReprNoNiche => ReprFlags::HIDE_NICHE,\n                     attr::ReprSimd => ReprFlags::IS_SIMD,\n                     attr::ReprInt(i) => {\n                         size = Some(i);\n@@ -2118,6 +2214,10 @@ impl ReprOptions {\n     pub fn linear(&self) -> bool {\n         self.flags.contains(ReprFlags::IS_LINEAR)\n     }\n+    #[inline]\n+    pub fn hide_niche(&self) -> bool {\n+        self.flags.contains(ReprFlags::HIDE_NICHE)\n+    }\n \n     pub fn discr_type(&self) -> attr::IntType {\n         self.int.unwrap_or(attr::SignedInt(ast::IntTy::Isize))\n@@ -2184,6 +2284,9 @@ impl<'tcx> AdtDef {\n         if Some(did) == tcx.lang_items().owned_box() {\n             flags |= AdtFlags::IS_BOX;\n         }\n+        if Some(did) == tcx.lang_items().manually_drop() {\n+            flags |= AdtFlags::IS_MANUALLY_DROP;\n+        }\n         if Some(did) == tcx.lang_items().arc() {\n             flags |= AdtFlags::IS_ARC;\n         }\n@@ -2284,6 +2387,12 @@ impl<'tcx> AdtDef {\n         self.flags.contains(AdtFlags::IS_BOX)\n     }\n \n+    /// Returns `true` if this is `ManuallyDrop<T>`.\n+    #[inline]\n+    pub fn is_manually_drop(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_MANUALLY_DROP)\n+    }\n+\n     /// Returns `true` if this type has a destructor.\n     pub fn has_dtor(&self, tcx: TyCtxt<'tcx>) -> bool {\n         self.destructor(tcx).is_some()\n@@ -2362,10 +2471,10 @@ impl<'tcx> AdtDef {\n         let repr_type = self.repr.discr_type();\n         match tcx.const_eval_poly(expr_did) {\n             Ok(val) => {\n-                // FIXME: Find the right type and use it instead of `val.ty` here\n-                if let Some(b) = val.try_eval_bits(tcx, param_env, val.ty) {\n+                let ty = repr_type.to_ty(tcx);\n+                if let Some(b) = val.try_to_bits_for_ty(tcx, param_env, ty) {\n                     trace!(\"discriminants: {} ({:?})\", b, repr_type);\n-                    Some(Discr { val: b, ty: val.ty })\n+                    Some(Discr { val: b, ty })\n                 } else {\n                     info!(\"invalid enum discriminant: {:#?}\", val);\n                     crate::mir::interpret::struct_error(\n@@ -2705,14 +2814,14 @@ impl<'tcx> TyCtxt<'tcx> {\n             .for_each(|&body_id| f(self.hir().body_owner_def_id(body_id)));\n     }\n \n-    pub fn provided_trait_methods(self, id: DefId) -> Vec<AssocItem> {\n+    pub fn provided_trait_methods(self, id: DefId) -> impl 'tcx + Iterator<Item = &'tcx AssocItem> {\n         self.associated_items(id)\n+            .in_definition_order()\n             .filter(|item| item.kind == AssocKind::Method && item.defaultness.has_value())\n-            .collect()\n     }\n \n     pub fn trait_relevant_for_never(self, did: DefId) -> bool {\n-        self.associated_items(did).any(|item| item.relevant_for_never())\n+        self.associated_items(did).in_definition_order().any(|item| item.relevant_for_never())\n     }\n \n     pub fn opt_item_name(self, def_id: DefId) -> Option<Ident> {\n@@ -2972,24 +3081,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n         (ident, scope)\n     }\n-}\n-\n-#[derive(Copy, Clone, HashStable)]\n-pub struct AssocItemsIterator<'tcx> {\n-    pub items: &'tcx [AssocItem],\n-}\n \n-impl<'tcx> Iterator for AssocItemsIterator<'tcx> {\n-    type Item = AssocItem;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<AssocItem> {\n-        if let Some((first, rest)) = self.items.split_first() {\n-            self.items = rest;\n-            Some(*first)\n-        } else {\n-            None\n-        }\n+    pub fn is_object_safe(self, key: DefId) -> bool {\n+        self.object_safety_violations(key).is_empty()\n     }\n }\n "}, {"sha": "0726bf30d3b3485c18c6e3e50e5510606c43d578", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -64,8 +64,7 @@ thread_local! {\n /// calling the same query.\n pub fn with_no_queries<F: FnOnce() -> R, R>(f: F) -> R {\n     NO_QUERIES.with(|no_queries| {\n-        let old = no_queries.get();\n-        no_queries.set(true);\n+        let old = no_queries.replace(true);\n         let result = f();\n         no_queries.set(old);\n         result\n@@ -78,8 +77,7 @@ pub fn with_no_queries<F: FnOnce() -> R, R>(f: F) -> R {\n /// so this variable disables that check.\n pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n     FORCE_IMPL_FILENAME_LINE.with(|force| {\n-        let old = force.get();\n-        force.set(true);\n+        let old = force.replace(true);\n         let result = f();\n         force.set(old);\n         result\n@@ -89,8 +87,7 @@ pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n /// Adds the `crate::` prefix to paths where appropriate.\n pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n     SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n-        let old = flag.get();\n-        flag.set(true);\n+        let old = flag.replace(true);\n         let result = f();\n         flag.set(old);\n         result\n@@ -724,7 +721,7 @@ pub trait PrettyPrinter<'tcx>:\n             let mut resugared = false;\n \n             // Special-case `Fn(...) -> ...` and resugar it.\n-            let fn_trait_kind = self.tcx().lang_items().fn_trait_kind(principal.def_id);\n+            let fn_trait_kind = self.tcx().fn_trait_kind_from_lang_item(principal.def_id);\n             if !self.tcx().sess.verbose() && fn_trait_kind.is_some() {\n                 if let ty::Tuple(ref args) = principal.substs.type_at(0).kind {\n                     let mut projections = predicates.projection_bounds();\n@@ -1818,7 +1815,7 @@ define_print_and_forward_display! {\n     ty::Predicate<'tcx> {\n         match *self {\n             ty::Predicate::Trait(ref data, constness) => {\n-                if let ast::Constness::Const = constness {\n+                if let hir::Constness::Const = constness {\n                     p!(write(\"const \"));\n                 }\n                 p!(print(data))"}, {"sha": "efc2804bd4d5985fa45b1fc95a19c05b18dc6501", "filename": "src/librustc/ty/query/caches.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -0,0 +1,112 @@\n+use crate::dep_graph::DepNodeIndex;\n+use crate::ty::query::config::QueryAccessors;\n+use crate::ty::query::plumbing::{QueryLookup, QueryState, QueryStateShard};\n+use crate::ty::TyCtxt;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sharded::Sharded;\n+use std::default::Default;\n+use std::hash::Hash;\n+\n+pub(crate) trait CacheSelector<K, V> {\n+    type Cache: QueryCache<K, V>;\n+}\n+\n+pub(crate) trait QueryCache<K, V>: Default {\n+    type Sharded: Default;\n+\n+    /// Checks if the query is already computed and in the cache.\n+    /// It returns the shard index and a lock guard to the shard,\n+    /// which will be used if the query is not in the cache and we need\n+    /// to compute it.\n+    fn lookup<'tcx, R, GetCache, OnHit, OnMiss, Q>(\n+        &self,\n+        state: &'tcx QueryState<'tcx, Q>,\n+        get_cache: GetCache,\n+        key: K,\n+        // `on_hit` can be called while holding a lock to the query state shard.\n+        on_hit: OnHit,\n+        on_miss: OnMiss,\n+    ) -> R\n+    where\n+        Q: QueryAccessors<'tcx>,\n+        GetCache: for<'a> Fn(&'a mut QueryStateShard<'tcx, Q>) -> &'a mut Self::Sharded,\n+        OnHit: FnOnce(&V, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(K, QueryLookup<'tcx, Q>) -> R;\n+\n+    fn complete(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        lock_sharded_storage: &mut Self::Sharded,\n+        key: K,\n+        value: V,\n+        index: DepNodeIndex,\n+    );\n+\n+    fn iter<R, L>(\n+        &self,\n+        shards: &Sharded<L>,\n+        get_shard: impl Fn(&mut L) -> &mut Self::Sharded,\n+        f: impl for<'a> FnOnce(Box<dyn Iterator<Item = (&'a K, &'a V, DepNodeIndex)> + 'a>) -> R,\n+    ) -> R;\n+}\n+\n+pub struct DefaultCacheSelector;\n+\n+impl<K: Eq + Hash, V: Clone> CacheSelector<K, V> for DefaultCacheSelector {\n+    type Cache = DefaultCache;\n+}\n+\n+#[derive(Default)]\n+pub struct DefaultCache;\n+\n+impl<K: Eq + Hash, V: Clone> QueryCache<K, V> for DefaultCache {\n+    type Sharded = FxHashMap<K, (V, DepNodeIndex)>;\n+\n+    #[inline(always)]\n+    fn lookup<'tcx, R, GetCache, OnHit, OnMiss, Q>(\n+        &self,\n+        state: &'tcx QueryState<'tcx, Q>,\n+        get_cache: GetCache,\n+        key: K,\n+        on_hit: OnHit,\n+        on_miss: OnMiss,\n+    ) -> R\n+    where\n+        Q: QueryAccessors<'tcx>,\n+        GetCache: for<'a> Fn(&'a mut QueryStateShard<'tcx, Q>) -> &'a mut Self::Sharded,\n+        OnHit: FnOnce(&V, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(K, QueryLookup<'tcx, Q>) -> R,\n+    {\n+        let mut lookup = state.get_lookup(&key);\n+        let lock = &mut *lookup.lock;\n+\n+        let result = get_cache(lock).raw_entry().from_key_hashed_nocheck(lookup.key_hash, &key);\n+\n+        if let Some((_, value)) = result { on_hit(&value.0, value.1) } else { on_miss(key, lookup) }\n+    }\n+\n+    #[inline]\n+    fn complete(\n+        &self,\n+        _: TyCtxt<'tcx>,\n+        lock_sharded_storage: &mut Self::Sharded,\n+        key: K,\n+        value: V,\n+        index: DepNodeIndex,\n+    ) {\n+        lock_sharded_storage.insert(key, (value, index));\n+    }\n+\n+    fn iter<R, L>(\n+        &self,\n+        shards: &Sharded<L>,\n+        get_shard: impl Fn(&mut L) -> &mut Self::Sharded,\n+        f: impl for<'a> FnOnce(Box<dyn Iterator<Item = (&'a K, &'a V, DepNodeIndex)> + 'a>) -> R,\n+    ) -> R {\n+        let mut shards = shards.lock_shards();\n+        let mut shards: Vec<_> = shards.iter_mut().map(|shard| get_shard(shard)).collect();\n+        let results = shards.iter_mut().flat_map(|shard| shard.iter()).map(|(k, v)| (k, &v.0, v.1));\n+        f(Box::new(results))\n+    }\n+}"}, {"sha": "e0e1ca374d9aef8deacadeabbbf29974773ecbd6", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,15 +1,15 @@\n use crate::dep_graph::SerializedDepNodeIndex;\n use crate::dep_graph::{DepKind, DepNode};\n+use crate::ty::query::caches::QueryCache;\n use crate::ty::query::plumbing::CycleError;\n use crate::ty::query::queries;\n-use crate::ty::query::{Query, QueryCache};\n+use crate::ty::query::{Query, QueryState};\n use crate::ty::TyCtxt;\n use rustc_data_structures::profiling::ProfileCategory;\n use rustc_hir::def_id::{CrateNum, DefId};\n \n use crate::ich::StableHashingContext;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::sharded::Sharded;\n use std::borrow::Cow;\n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -30,10 +30,12 @@ pub(crate) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n     const ANON: bool;\n     const EVAL_ALWAYS: bool;\n \n+    type Cache: QueryCache<Self::Key, Self::Value>;\n+\n     fn query(key: Self::Key) -> Query<'tcx>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_cache<'a>(tcx: TyCtxt<'tcx>) -> &'a Sharded<QueryCache<'tcx, Self>>;\n+    fn query_state<'a>(tcx: TyCtxt<'tcx>) -> &'a QueryState<'tcx, Self>;\n \n     fn to_dep_node(tcx: TyCtxt<'tcx>, key: &Self::Key) -> DepNode;\n \n@@ -61,7 +63,10 @@ pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n     }\n }\n \n-impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M {\n+impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M\n+where\n+    <M as QueryAccessors<'tcx>>::Cache: QueryCache<DefId, <M as QueryConfig<'tcx>>::Value>,\n+{\n     default fn describe(tcx: TyCtxt<'_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()"}, {"sha": "3394fed8402224ff98f0d7929c67065d93aedd25", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 203, "deletions": 102, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,20 +1,23 @@\n+use crate::dep_graph::DepKind;\n use crate::ty::context::TyCtxt;\n use crate::ty::query::plumbing::CycleError;\n use crate::ty::query::Query;\n use crate::ty::tls;\n \n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_span::Span;\n \n-#[cfg(not(parallel_compiler))]\n-use std::ptr;\n+use std::convert::TryFrom;\n+use std::marker::PhantomData;\n+use std::num::NonZeroU32;\n \n #[cfg(parallel_compiler)]\n use {\n     parking_lot::{Condvar, Mutex},\n     rustc_data_structures::fx::FxHashSet,\n     rustc_data_structures::stable_hasher::{HashStable, StableHasher},\n     rustc_data_structures::sync::Lock,\n+    rustc_data_structures::sync::Lrc,\n     rustc_data_structures::{jobserver, OnDrop},\n     rustc_rayon_core as rayon_core,\n     rustc_span::DUMMY_SP,\n@@ -30,61 +33,130 @@ pub struct QueryInfo<'tcx> {\n     pub query: Query<'tcx>,\n }\n \n-/// Representss an object representing an active query job.\n-pub struct QueryJob<'tcx> {\n+type QueryMap<'tcx> = FxHashMap<QueryJobId, QueryJobInfo<'tcx>>;\n+\n+/// A value uniquely identifiying an active query job within a shard in the query cache.\n+#[derive(Copy, Clone, Eq, PartialEq, Hash)]\n+pub struct QueryShardJobId(pub NonZeroU32);\n+\n+/// A value uniquely identifiying an active query job.\n+#[derive(Copy, Clone, Eq, PartialEq, Hash)]\n+pub struct QueryJobId {\n+    /// Which job within a shard is this\n+    pub job: QueryShardJobId,\n+\n+    /// In which shard is this job\n+    pub shard: u16,\n+\n+    /// What kind of query this job is\n+    pub kind: DepKind,\n+}\n+\n+impl QueryJobId {\n+    pub fn new(job: QueryShardJobId, shard: usize, kind: DepKind) -> Self {\n+        QueryJobId { job, shard: u16::try_from(shard).unwrap(), kind }\n+    }\n+\n+    fn query<'tcx>(self, map: &QueryMap<'tcx>) -> Query<'tcx> {\n+        map.get(&self).unwrap().info.query.clone()\n+    }\n+\n+    #[cfg(parallel_compiler)]\n+    fn span(self, map: &QueryMap<'_>) -> Span {\n+        map.get(&self).unwrap().job.span\n+    }\n+\n+    #[cfg(parallel_compiler)]\n+    fn parent(self, map: &QueryMap<'_>) -> Option<QueryJobId> {\n+        map.get(&self).unwrap().job.parent\n+    }\n+\n+    #[cfg(parallel_compiler)]\n+    fn latch<'a, 'tcx>(self, map: &'a QueryMap<'tcx>) -> Option<&'a QueryLatch<'tcx>> {\n+        map.get(&self).unwrap().job.latch.as_ref()\n+    }\n+}\n+\n+pub struct QueryJobInfo<'tcx> {\n     pub info: QueryInfo<'tcx>,\n+    pub job: QueryJob<'tcx>,\n+}\n+\n+/// Represents an active query job.\n+#[derive(Clone)]\n+pub struct QueryJob<'tcx> {\n+    pub id: QueryShardJobId,\n+\n+    /// The span corresponding to the reason for which this query was required.\n+    pub span: Span,\n \n     /// The parent query job which created this job and is implicitly waiting on it.\n-    pub parent: Option<Lrc<QueryJob<'tcx>>>,\n+    pub parent: Option<QueryJobId>,\n \n     /// The latch that is used to wait on this job.\n     #[cfg(parallel_compiler)]\n-    latch: QueryLatch<'tcx>,\n+    latch: Option<QueryLatch<'tcx>>,\n+\n+    dummy: PhantomData<QueryLatch<'tcx>>,\n }\n \n impl<'tcx> QueryJob<'tcx> {\n     /// Creates a new query job.\n-    pub fn new(info: QueryInfo<'tcx>, parent: Option<Lrc<QueryJob<'tcx>>>) -> Self {\n+    pub fn new(id: QueryShardJobId, span: Span, parent: Option<QueryJobId>) -> Self {\n         QueryJob {\n-            info,\n+            id,\n+            span,\n             parent,\n             #[cfg(parallel_compiler)]\n-            latch: QueryLatch::new(),\n+            latch: None,\n+            dummy: PhantomData,\n         }\n     }\n \n-    /// Awaits for the query job to complete.\n     #[cfg(parallel_compiler)]\n-    pub(super) fn r#await(&self, tcx: TyCtxt<'tcx>, span: Span) -> Result<(), CycleError<'tcx>> {\n-        tls::with_related_context(tcx, move |icx| {\n-            let waiter = Lrc::new(QueryWaiter {\n-                query: icx.query.clone(),\n-                span,\n-                cycle: Lock::new(None),\n-                condvar: Condvar::new(),\n-            });\n-            self.latch.r#await(&waiter);\n-            // FIXME: Get rid of this lock. We have ownership of the QueryWaiter\n-            // although another thread may still have a Lrc reference so we cannot\n-            // use Lrc::get_mut\n-            let mut cycle = waiter.cycle.lock();\n-            match cycle.take() {\n-                None => Ok(()),\n-                Some(cycle) => Err(cycle),\n-            }\n-        })\n+    pub(super) fn latch(&mut self, _id: QueryJobId) -> QueryLatch<'tcx> {\n+        if self.latch.is_none() {\n+            self.latch = Some(QueryLatch::new());\n+        }\n+        self.latch.as_ref().unwrap().clone()\n     }\n \n     #[cfg(not(parallel_compiler))]\n+    pub(super) fn latch(&mut self, id: QueryJobId) -> QueryLatch<'tcx> {\n+        QueryLatch { id, dummy: PhantomData }\n+    }\n+\n+    /// Signals to waiters that the query is complete.\n+    ///\n+    /// This does nothing for single threaded rustc,\n+    /// as there are no concurrent jobs which could be waiting on us\n+    pub fn signal_complete(self) {\n+        #[cfg(parallel_compiler)]\n+        self.latch.map(|latch| latch.set());\n+    }\n+}\n+\n+#[cfg(not(parallel_compiler))]\n+#[derive(Clone)]\n+pub(super) struct QueryLatch<'tcx> {\n+    id: QueryJobId,\n+    dummy: PhantomData<&'tcx ()>,\n+}\n+\n+#[cfg(not(parallel_compiler))]\n+impl<'tcx> QueryLatch<'tcx> {\n     pub(super) fn find_cycle_in_stack(&self, tcx: TyCtxt<'tcx>, span: Span) -> CycleError<'tcx> {\n+        let query_map = tcx.queries.try_collect_active_jobs().unwrap();\n+\n         // Get the current executing query (waiter) and find the waitee amongst its parents\n-        let mut current_job = tls::with_related_context(tcx, |icx| icx.query.clone());\n+        let mut current_job = tls::with_related_context(tcx, |icx| icx.query);\n         let mut cycle = Vec::new();\n \n         while let Some(job) = current_job {\n-            cycle.push(job.info.clone());\n+            let info = query_map.get(&job).unwrap();\n+            cycle.push(info.info.clone());\n \n-            if ptr::eq(&*job, self) {\n+            if job == self.id {\n                 cycle.reverse();\n \n                 // This is the end of the cycle\n@@ -93,35 +165,24 @@ impl<'tcx> QueryJob<'tcx> {\n                 // Replace it with the span which caused the cycle to form\n                 cycle[0].span = span;\n                 // Find out why the cycle itself was used\n-                let usage =\n-                    job.parent.as_ref().map(|parent| (job.info.span, parent.info.query.clone()));\n+                let usage = info\n+                    .job\n+                    .parent\n+                    .as_ref()\n+                    .map(|parent| (info.info.span, parent.query(&query_map)));\n                 return CycleError { usage, cycle };\n             }\n \n-            current_job = job.parent.clone();\n+            current_job = info.job.parent;\n         }\n \n         panic!(\"did not find a cycle\")\n     }\n-\n-    /// Signals to waiters that the query is complete.\n-    ///\n-    /// This does nothing for single threaded rustc,\n-    /// as there are no concurrent jobs which could be waiting on us\n-    pub fn signal_complete(&self) {\n-        #[cfg(parallel_compiler)]\n-        self.latch.set();\n-    }\n-\n-    #[cfg(parallel_compiler)]\n-    fn as_ptr(&self) -> *const QueryJob<'tcx> {\n-        self as *const _\n-    }\n }\n \n #[cfg(parallel_compiler)]\n struct QueryWaiter<'tcx> {\n-    query: Option<Lrc<QueryJob<'tcx>>>,\n+    query: Option<QueryJobId>,\n     condvar: Condvar,\n     span: Span,\n     cycle: Lock<Option<CycleError<'tcx>>>,\n@@ -142,18 +203,43 @@ struct QueryLatchInfo<'tcx> {\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryLatch<'tcx> {\n-    info: Mutex<QueryLatchInfo<'tcx>>,\n+#[derive(Clone)]\n+pub(super) struct QueryLatch<'tcx> {\n+    info: Lrc<Mutex<QueryLatchInfo<'tcx>>>,\n }\n \n #[cfg(parallel_compiler)]\n impl<'tcx> QueryLatch<'tcx> {\n     fn new() -> Self {\n-        QueryLatch { info: Mutex::new(QueryLatchInfo { complete: false, waiters: Vec::new() }) }\n+        QueryLatch {\n+            info: Lrc::new(Mutex::new(QueryLatchInfo { complete: false, waiters: Vec::new() })),\n+        }\n+    }\n+\n+    /// Awaits for the query job to complete.\n+    #[cfg(parallel_compiler)]\n+    pub(super) fn wait_on(&self, tcx: TyCtxt<'tcx>, span: Span) -> Result<(), CycleError<'tcx>> {\n+        tls::with_related_context(tcx, move |icx| {\n+            let waiter = Lrc::new(QueryWaiter {\n+                query: icx.query,\n+                span,\n+                cycle: Lock::new(None),\n+                condvar: Condvar::new(),\n+            });\n+            self.wait_on_inner(&waiter);\n+            // FIXME: Get rid of this lock. We have ownership of the QueryWaiter\n+            // although another thread may still have a Lrc reference so we cannot\n+            // use Lrc::get_mut\n+            let mut cycle = waiter.cycle.lock();\n+            match cycle.take() {\n+                None => Ok(()),\n+                Some(cycle) => Err(cycle),\n+            }\n+        })\n     }\n \n     /// Awaits the caller on this latch by blocking the current thread.\n-    fn r#await(&self, waiter: &Lrc<QueryWaiter<'tcx>>) {\n+    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter<'tcx>>) {\n         let mut info = self.info.lock();\n         if !info.complete {\n             // We push the waiter on to the `waiters` list. It can be accessed inside\n@@ -197,7 +283,7 @@ impl<'tcx> QueryLatch<'tcx> {\n \n /// A resumable waiter of a query. The usize is the index into waiters in the query's latch\n #[cfg(parallel_compiler)]\n-type Waiter<'tcx> = (Lrc<QueryJob<'tcx>>, usize);\n+type Waiter = (QueryJobId, usize);\n \n /// Visits all the non-resumable and resumable waiters of a query.\n /// Only waiters in a query are visited.\n@@ -209,26 +295,33 @@ type Waiter<'tcx> = (Lrc<QueryJob<'tcx>>, usize);\n /// required information to resume the waiter.\n /// If all `visit` calls returns None, this function also returns None.\n #[cfg(parallel_compiler)]\n-fn visit_waiters<'tcx, F>(query: Lrc<QueryJob<'tcx>>, mut visit: F) -> Option<Option<Waiter<'tcx>>>\n+fn visit_waiters<'tcx, F>(\n+    query_map: &QueryMap<'tcx>,\n+    query: QueryJobId,\n+    mut visit: F,\n+) -> Option<Option<Waiter>>\n where\n-    F: FnMut(Span, Lrc<QueryJob<'tcx>>) -> Option<Option<Waiter<'tcx>>>,\n+    F: FnMut(Span, QueryJobId) -> Option<Option<Waiter>>,\n {\n     // Visit the parent query which is a non-resumable waiter since it's on the same stack\n-    if let Some(ref parent) = query.parent {\n-        if let Some(cycle) = visit(query.info.span, parent.clone()) {\n+    if let Some(parent) = query.parent(query_map) {\n+        if let Some(cycle) = visit(query.span(query_map), parent) {\n             return Some(cycle);\n         }\n     }\n \n     // Visit the explicit waiters which use condvars and are resumable\n-    for (i, waiter) in query.latch.info.lock().waiters.iter().enumerate() {\n-        if let Some(ref waiter_query) = waiter.query {\n-            if visit(waiter.span, waiter_query.clone()).is_some() {\n-                // Return a value which indicates that this waiter can be resumed\n-                return Some(Some((query.clone(), i)));\n+    if let Some(latch) = query.latch(query_map) {\n+        for (i, waiter) in latch.info.lock().waiters.iter().enumerate() {\n+            if let Some(waiter_query) = waiter.query {\n+                if visit(waiter.span, waiter_query).is_some() {\n+                    // Return a value which indicates that this waiter can be resumed\n+                    return Some(Some((query, i)));\n+                }\n             }\n         }\n     }\n+\n     None\n }\n \n@@ -238,13 +331,14 @@ where\n /// the cycle.\n #[cfg(parallel_compiler)]\n fn cycle_check<'tcx>(\n-    query: Lrc<QueryJob<'tcx>>,\n+    query_map: &QueryMap<'tcx>,\n+    query: QueryJobId,\n     span: Span,\n-    stack: &mut Vec<(Span, Lrc<QueryJob<'tcx>>)>,\n-    visited: &mut FxHashSet<*const QueryJob<'tcx>>,\n-) -> Option<Option<Waiter<'tcx>>> {\n-    if !visited.insert(query.as_ptr()) {\n-        return if let Some(p) = stack.iter().position(|q| q.1.as_ptr() == query.as_ptr()) {\n+    stack: &mut Vec<(Span, QueryJobId)>,\n+    visited: &mut FxHashSet<QueryJobId>,\n+) -> Option<Option<Waiter>> {\n+    if !visited.insert(query) {\n+        return if let Some(p) = stack.iter().position(|q| q.1 == query) {\n             // We detected a query cycle, fix up the initial span and return Some\n \n             // Remove previous stack entries\n@@ -258,10 +352,12 @@ fn cycle_check<'tcx>(\n     }\n \n     // Query marked as visited is added it to the stack\n-    stack.push((span, query.clone()));\n+    stack.push((span, query));\n \n     // Visit all the waiters\n-    let r = visit_waiters(query, |span, successor| cycle_check(successor, span, stack, visited));\n+    let r = visit_waiters(query_map, query, |span, successor| {\n+        cycle_check(query_map, successor, span, stack, visited)\n+    });\n \n     // Remove the entry in our stack if we didn't find a cycle\n     if r.is_none() {\n@@ -276,26 +372,30 @@ fn cycle_check<'tcx>(\n /// This is achieved with a depth first search.\n #[cfg(parallel_compiler)]\n fn connected_to_root<'tcx>(\n-    query: Lrc<QueryJob<'tcx>>,\n-    visited: &mut FxHashSet<*const QueryJob<'tcx>>,\n+    query_map: &QueryMap<'tcx>,\n+    query: QueryJobId,\n+    visited: &mut FxHashSet<QueryJobId>,\n ) -> bool {\n     // We already visited this or we're deliberately ignoring it\n-    if !visited.insert(query.as_ptr()) {\n+    if !visited.insert(query) {\n         return false;\n     }\n \n     // This query is connected to the root (it has no query parent), return true\n-    if query.parent.is_none() {\n+    if query.parent(query_map).is_none() {\n         return true;\n     }\n \n-    visit_waiters(query, |_, successor| connected_to_root(successor, visited).then_some(None))\n-        .is_some()\n+    visit_waiters(query_map, query, |_, successor| {\n+        connected_to_root(query_map, successor, visited).then_some(None)\n+    })\n+    .is_some()\n }\n \n // Deterministically pick an query from a list\n #[cfg(parallel_compiler)]\n-fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n+fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, QueryJobId)>(\n+    query_map: &QueryMap<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     queries: &'a [T],\n     f: F,\n@@ -308,7 +408,7 @@ fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n         .min_by_key(|v| {\n             let (span, query) = f(v);\n             let mut stable_hasher = StableHasher::new();\n-            query.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n+            query.query(query_map).hash_stable(&mut hcx, &mut stable_hasher);\n             // Prefer entry points which have valid spans for nicer error messages\n             // We add an integer to the tuple ensuring that entry points\n             // with valid spans are picked first\n@@ -325,14 +425,17 @@ fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n /// the function returns false.\n #[cfg(parallel_compiler)]\n fn remove_cycle<'tcx>(\n-    jobs: &mut Vec<Lrc<QueryJob<'tcx>>>,\n+    query_map: &QueryMap<'tcx>,\n+    jobs: &mut Vec<QueryJobId>,\n     wakelist: &mut Vec<Lrc<QueryWaiter<'tcx>>>,\n     tcx: TyCtxt<'tcx>,\n ) -> bool {\n     let mut visited = FxHashSet::default();\n     let mut stack = Vec::new();\n     // Look for a cycle starting with the last query in `jobs`\n-    if let Some(waiter) = cycle_check(jobs.pop().unwrap(), DUMMY_SP, &mut stack, &mut visited) {\n+    if let Some(waiter) =\n+        cycle_check(query_map, jobs.pop().unwrap(), DUMMY_SP, &mut stack, &mut visited)\n+    {\n         // The stack is a vector of pairs of spans and queries; reverse it so that\n         // the earlier entries require later entries\n         let (mut spans, queries): (Vec<_>, Vec<_>) = stack.into_iter().rev().unzip();\n@@ -345,27 +448,25 @@ fn remove_cycle<'tcx>(\n \n         // Remove the queries in our cycle from the list of jobs to look at\n         for r in &stack {\n-            if let Some(pos) = jobs.iter().position(|j| j.as_ptr() == r.1.as_ptr()) {\n-                jobs.remove(pos);\n-            }\n+            jobs.remove_item(&r.1);\n         }\n \n         // Find the queries in the cycle which are\n         // connected to queries outside the cycle\n         let entry_points = stack\n             .iter()\n-            .filter_map(|(span, query)| {\n-                if query.parent.is_none() {\n+            .filter_map(|&(span, query)| {\n+                if query.parent(query_map).is_none() {\n                     // This query is connected to the root (it has no query parent)\n-                    Some((*span, query.clone(), None))\n+                    Some((span, query, None))\n                 } else {\n                     let mut waiters = Vec::new();\n                     // Find all the direct waiters who lead to the root\n-                    visit_waiters(query.clone(), |span, waiter| {\n+                    visit_waiters(query_map, query, |span, waiter| {\n                         // Mark all the other queries in the cycle as already visited\n-                        let mut visited = FxHashSet::from_iter(stack.iter().map(|q| q.1.as_ptr()));\n+                        let mut visited = FxHashSet::from_iter(stack.iter().map(|q| q.1));\n \n-                        if connected_to_root(waiter.clone(), &mut visited) {\n+                        if connected_to_root(query_map, waiter, &mut visited) {\n                             waiters.push((span, waiter));\n                         }\n \n@@ -375,31 +476,30 @@ fn remove_cycle<'tcx>(\n                         None\n                     } else {\n                         // Deterministically pick one of the waiters to show to the user\n-                        let waiter = pick_query(tcx, &waiters, |s| s.clone()).clone();\n-                        Some((*span, query.clone(), Some(waiter)))\n+                        let waiter = *pick_query(query_map, tcx, &waiters, |s| *s);\n+                        Some((span, query, Some(waiter)))\n                     }\n                 }\n             })\n-            .collect::<Vec<(Span, Lrc<QueryJob<'tcx>>, Option<(Span, Lrc<QueryJob<'tcx>>)>)>>();\n+            .collect::<Vec<(Span, QueryJobId, Option<(Span, QueryJobId)>)>>();\n \n         // Deterministically pick an entry point\n-        let (_, entry_point, usage) = pick_query(tcx, &entry_points, |e| (e.0, e.1.clone()));\n+        let (_, entry_point, usage) = pick_query(query_map, tcx, &entry_points, |e| (e.0, e.1));\n \n         // Shift the stack so that our entry point is first\n-        let entry_point_pos =\n-            stack.iter().position(|(_, query)| query.as_ptr() == entry_point.as_ptr());\n+        let entry_point_pos = stack.iter().position(|(_, query)| query == entry_point);\n         if let Some(pos) = entry_point_pos {\n             stack.rotate_left(pos);\n         }\n \n-        let usage = usage.as_ref().map(|(span, query)| (*span, query.info.query.clone()));\n+        let usage = usage.as_ref().map(|(span, query)| (*span, query.query(query_map)));\n \n         // Create the cycle error\n         let error = CycleError {\n             usage,\n             cycle: stack\n                 .iter()\n-                .map(|&(s, ref q)| QueryInfo { span: s, query: q.info.query.clone() })\n+                .map(|&(s, ref q)| QueryInfo { span: s, query: q.query(query_map) })\n                 .collect(),\n         };\n \n@@ -408,7 +508,7 @@ fn remove_cycle<'tcx>(\n         let (waitee_query, waiter_idx) = waiter.unwrap();\n \n         // Extract the waiter we want to resume\n-        let waiter = waitee_query.latch.extract_waiter(waiter_idx);\n+        let waiter = waitee_query.latch(query_map).unwrap().extract_waiter(waiter_idx);\n \n         // Set the cycle error so it will be picked up when resumed\n         *waiter.cycle.lock() = Some(error);\n@@ -460,12 +560,13 @@ fn deadlock(tcx: TyCtxt<'_>, registry: &rayon_core::Registry) {\n     });\n \n     let mut wakelist = Vec::new();\n-    let mut jobs: Vec<_> = tcx.queries.collect_active_jobs();\n+    let query_map = tcx.queries.try_collect_active_jobs().unwrap();\n+    let mut jobs: Vec<QueryJobId> = query_map.keys().cloned().collect();\n \n     let mut found_cycle = false;\n \n     while jobs.len() > 0 {\n-        if remove_cycle(&mut jobs, &mut wakelist, tcx) {\n+        if remove_cycle(&query_map, &mut jobs, &mut wakelist, tcx) {\n             found_cycle = true;\n         }\n     }"}, {"sha": "09fb307a1ceb416cb6aec8b5030a7a676002bee1", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -4,6 +4,7 @@ use crate::infer::canonical::Canonical;\n use crate::mir;\n use crate::traits;\n use crate::ty::fast_reject::SimplifiedType;\n+use crate::ty::query::caches::DefaultCacheSelector;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n@@ -12,7 +13,9 @@ use rustc_span::{Span, DUMMY_SP};\n \n /// The `Key` trait controls what types can legally be used as the key\n /// for a query.\n-pub(super) trait Key {\n+pub trait Key {\n+    type CacheSelector;\n+\n     /// Given an instance of this key, what crate is it referring to?\n     /// This is used to find the provider.\n     fn query_crate(&self) -> CrateNum;\n@@ -23,6 +26,8 @@ pub(super) trait Key {\n }\n \n impl<'tcx> Key for ty::InstanceDef<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -33,6 +38,8 @@ impl<'tcx> Key for ty::InstanceDef<'tcx> {\n }\n \n impl<'tcx> Key for ty::Instance<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -43,6 +50,8 @@ impl<'tcx> Key for ty::Instance<'tcx> {\n }\n \n impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.instance.query_crate()\n     }\n@@ -53,6 +62,8 @@ impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n }\n \n impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -63,6 +74,8 @@ impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n }\n \n impl Key for CrateNum {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         *self\n     }\n@@ -72,6 +85,8 @@ impl Key for CrateNum {\n }\n \n impl Key for DefIndex {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -81,6 +96,8 @@ impl Key for DefIndex {\n }\n \n impl Key for DefId {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.krate\n     }\n@@ -90,6 +107,8 @@ impl Key for DefId {\n }\n \n impl Key for (DefId, DefId) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n@@ -99,6 +118,8 @@ impl Key for (DefId, DefId) {\n }\n \n impl Key for (CrateNum, DefId) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.0\n     }\n@@ -108,6 +129,8 @@ impl Key for (CrateNum, DefId) {\n }\n \n impl Key for (DefId, SimplifiedType) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n@@ -117,6 +140,8 @@ impl Key for (DefId, SimplifiedType) {\n }\n \n impl<'tcx> Key for SubstsRef<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -126,6 +151,8 @@ impl<'tcx> Key for SubstsRef<'tcx> {\n }\n \n impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n@@ -135,6 +162,8 @@ impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n }\n \n impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.1.def_id().krate\n     }\n@@ -144,6 +173,8 @@ impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n }\n \n impl<'tcx> Key for (&'tcx ty::Const<'tcx>, mir::Field) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -153,6 +184,8 @@ impl<'tcx> Key for (&'tcx ty::Const<'tcx>, mir::Field) {\n }\n \n impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.def_id().krate\n     }\n@@ -162,6 +195,8 @@ impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n }\n \n impl<'tcx> Key for &'tcx ty::Const<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -171,6 +206,8 @@ impl<'tcx> Key for &'tcx ty::Const<'tcx> {\n }\n \n impl<'tcx> Key for Ty<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -180,6 +217,8 @@ impl<'tcx> Key for Ty<'tcx> {\n }\n \n impl<'tcx> Key for ty::ParamEnv<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -189,6 +228,8 @@ impl<'tcx> Key for ty::ParamEnv<'tcx> {\n }\n \n impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.value.query_crate()\n     }\n@@ -198,6 +239,8 @@ impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n }\n \n impl<'tcx> Key for traits::Environment<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -207,6 +250,8 @@ impl<'tcx> Key for traits::Environment<'tcx> {\n }\n \n impl Key for Symbol {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -218,6 +263,8 @@ impl Key for Symbol {\n /// Canonical query goals correspond to abstract trait operations that\n /// are not tied to any crate in particular.\n impl<'tcx, T> Key for Canonical<'tcx, T> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -228,6 +275,8 @@ impl<'tcx, T> Key for Canonical<'tcx, T> {\n }\n \n impl Key for (Symbol, u32, u32) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }"}, {"sha": "381a7b1f03ff73388bdd0cb5b7be41acac3cfdf8", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{self, DepNode};\n+use crate::dep_graph::{self, DepConstructor, DepNode};\n use crate::hir::exports::Export;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintLevelMap;\n@@ -14,26 +14,26 @@ use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLife\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;\n use crate::mir::interpret::GlobalId;\n-use crate::mir::interpret::{ConstEvalRawResult, ConstEvalResult};\n+use crate::mir::interpret::{ConstEvalRawResult, ConstEvalResult, ConstValue};\n use crate::mir::interpret::{LitToConstError, LitToConstInput};\n use crate::mir::mono::CodegenUnit;\n use crate::session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use crate::session::CrateDisambiguator;\n-use crate::traits::query::dropck_outlives::{DropckOutlivesResult, DtorckConstraint};\n-use crate::traits::query::method_autoderef::MethodAutoderefStepsResult;\n-use crate::traits::query::normalize::NormalizationResult;\n-use crate::traits::query::outlives_bounds::OutlivesBound;\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n     CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal, NoSolution,\n };\n+use crate::traits::query::{\n+    DropckOutlivesResult, DtorckConstraint, MethodAutoderefStepsResult, NormalizationResult,\n+    OutlivesBound,\n+};\n use crate::traits::specialization_graph;\n use crate::traits::Clauses;\n use crate::traits::{self, Vtable};\n use crate::ty::steal::Steal;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::util::NeedsDrop;\n+use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use crate::util::common::ErrorReported;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -52,8 +52,8 @@ use rustc_target::spec::PanicStrategy;\n use rustc_attr as attr;\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n-use std::any::type_name;\n use std::borrow::Cow;\n+use std::convert::TryFrom;\n use std::ops::Deref;\n use std::sync::Arc;\n use syntax::ast;\n@@ -63,17 +63,24 @@ mod plumbing;\n use self::plumbing::*;\n pub use self::plumbing::{force_from_dep_node, CycleError};\n \n+mod stats;\n+pub use self::stats::print_stats;\n+\n mod job;\n #[cfg(parallel_compiler)]\n pub use self::job::handle_deadlock;\n-pub use self::job::{QueryInfo, QueryJob};\n+use self::job::QueryJobInfo;\n+pub use self::job::{QueryInfo, QueryJob, QueryJobId};\n \n mod keys;\n use self::keys::Key;\n \n mod values;\n use self::values::Value;\n \n+mod caches;\n+use self::caches::CacheSelector;\n+\n mod config;\n use self::config::QueryAccessors;\n pub use self::config::QueryConfig;"}, {"sha": "0fb5f66feca9e0fa1011946556dd875cca08482a", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 21, "deletions": 39, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -22,7 +22,7 @@ use rustc_span::hygiene::{ExpnId, SyntaxContext};\n use rustc_span::source_map::{SourceMap, StableSourceFileId};\n use rustc_span::{BytePos, SourceFile, Span, DUMMY_SP};\n use std::mem;\n-use syntax::ast::{Ident, NodeId};\n+use syntax::ast::Ident;\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n@@ -680,16 +680,6 @@ impl<'a, 'tcx> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-// `NodeId`s are not stable across compilation sessions, so we store them in their\n-// `HirId` representation. This allows use to map them to the current `NodeId`.\n-impl<'a, 'tcx> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n-        let hir_id = hir::HirId::decode(self)?;\n-        Ok(self.tcx().hir().hir_to_node_id(hir_id))\n-    }\n-}\n-\n impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n         Fingerprint::decode_opaque(&mut self.opaque)\n@@ -928,19 +918,6 @@ where\n     }\n }\n \n-// `NodeId`s are not stable across compilation sessions, so we store them in their\n-// `HirId` representation. This allows use to map them to the current `NodeId`.\n-impl<'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-{\n-    #[inline]\n-    fn specialized_encode(&mut self, node_id: &NodeId) -> Result<(), Self::Error> {\n-        let hir_id = self.tcx.hir().node_to_hir_id(*node_id);\n-        hir_id.encode(self)\n-    }\n-}\n-\n impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for CacheEncoder<'a, 'tcx, opaque::Encoder> {\n     fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n         f.encode_opaque(&mut self.encoder)\n@@ -966,6 +943,7 @@ where\n \n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n+        #[inline]\n         $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {\n             self.encoder.$name(value)\n         })*\n@@ -1053,23 +1031,27 @@ where\n     Q: super::config::QueryDescription<'tcx, Value: Encodable>,\n     E: 'a + TyEncoder,\n {\n-    let desc = &format!(\"encode_query_results_for_{}\", ::std::any::type_name::<Q>());\n-    let _timer = tcx.sess.prof.extra_verbose_generic_activity(desc);\n+    let _timer = tcx\n+        .sess\n+        .prof\n+        .extra_verbose_generic_activity(\"encode_query_results_for\", ::std::any::type_name::<Q>());\n \n-    let shards = Q::query_cache(tcx).lock_shards();\n-    assert!(shards.iter().all(|shard| shard.active.is_empty()));\n-    for (key, entry) in shards.iter().flat_map(|shard| shard.results.iter()) {\n-        if Q::cache_on_disk(tcx, key.clone(), Some(&entry.value)) {\n-            let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n+    let state = Q::query_state(tcx);\n+    assert!(state.all_inactive());\n \n-            // Record position of the cache entry.\n-            query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n+    state.iter_results(|results| {\n+        for (key, value, dep_node) in results {\n+            if Q::cache_on_disk(tcx, key.clone(), Some(&value)) {\n+                let dep_node = SerializedDepNodeIndex::new(dep_node.index());\n \n-            // Encode the type check tables with the `SerializedDepNodeIndex`\n-            // as tag.\n-            encoder.encode_tagged(dep_node, &entry.value)?;\n-        }\n-    }\n+                // Record position of the cache entry.\n+                query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n \n-    Ok(())\n+                // Encode the type check tables with the `SerializedDepNodeIndex`\n+                // as tag.\n+                encoder.encode_tagged(dep_node, &value)?;\n+            }\n+        }\n+        Ok(())\n+    })\n }"}, {"sha": "a61256b9fcbbc82652c873c20ef15ebd62c17d2e", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 332, "deletions": 275, "changes": 607, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -3,180 +3,212 @@\n //! manage the caches, and so forth.\n \n use crate::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n-use crate::ty::query::config::{QueryConfig, QueryDescription};\n-use crate::ty::query::job::{QueryInfo, QueryJob};\n+use crate::ty::query::caches::QueryCache;\n+use crate::ty::query::config::{QueryAccessors, QueryDescription};\n+use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryShardJobId};\n use crate::ty::query::Query;\n use crate::ty::tls;\n use crate::ty::{self, TyCtxt};\n \n #[cfg(not(parallel_compiler))]\n use rustc_data_structures::cold_path;\n use rustc_data_structures::fx::{FxHashMap, FxHasher};\n-#[cfg(parallel_compiler)]\n-use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::sharded::Sharded;\n-use rustc_data_structures::sync::{Lock, Lrc};\n+use rustc_data_structures::sync::{Lock, LockGuard};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, FatalError, Handler, Level};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::Span;\n use std::collections::hash_map::Entry;\n use std::hash::{Hash, Hasher};\n use std::mem;\n+use std::num::NonZeroU32;\n use std::ptr;\n+#[cfg(debug_assertions)]\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n-pub struct QueryCache<'tcx, D: QueryConfig<'tcx> + ?Sized> {\n-    pub(super) results: FxHashMap<D::Key, QueryValue<D::Value>>,\n+pub(crate) struct QueryStateShard<'tcx, D: QueryAccessors<'tcx> + ?Sized> {\n+    pub(super) cache: <<D as QueryAccessors<'tcx>>::Cache as QueryCache<D::Key, D::Value>>::Sharded,\n     pub(super) active: FxHashMap<D::Key, QueryResult<'tcx>>,\n-    #[cfg(debug_assertions)]\n-    pub(super) cache_hits: usize,\n+\n+    /// Used to generate unique ids for active jobs.\n+    pub(super) jobs: u32,\n+}\n+\n+impl<'tcx, Q: QueryAccessors<'tcx>> QueryStateShard<'tcx, Q> {\n+    fn get_cache(\n+        &mut self,\n+    ) -> &mut <<Q as QueryAccessors<'tcx>>::Cache as QueryCache<Q::Key, Q::Value>>::Sharded {\n+        &mut self.cache\n+    }\n+}\n+\n+impl<'tcx, Q: QueryAccessors<'tcx>> Default for QueryStateShard<'tcx, Q> {\n+    fn default() -> QueryStateShard<'tcx, Q> {\n+        QueryStateShard { cache: Default::default(), active: Default::default(), jobs: 0 }\n+    }\n }\n \n-pub(super) struct QueryValue<T> {\n-    pub(super) value: T,\n-    pub(super) index: DepNodeIndex,\n+pub(crate) struct QueryState<'tcx, D: QueryAccessors<'tcx> + ?Sized> {\n+    pub(super) cache: D::Cache,\n+    pub(super) shards: Sharded<QueryStateShard<'tcx, D>>,\n+    #[cfg(debug_assertions)]\n+    pub(super) cache_hits: AtomicUsize,\n }\n \n-impl<T> QueryValue<T> {\n-    pub(super) fn new(value: T, dep_node_index: DepNodeIndex) -> QueryValue<T> {\n-        QueryValue { value, index: dep_node_index }\n+impl<'tcx, Q: QueryAccessors<'tcx>> QueryState<'tcx, Q> {\n+    pub(super) fn get_lookup<K: Hash>(&'tcx self, key: &K) -> QueryLookup<'tcx, Q> {\n+        // We compute the key's hash once and then use it for both the\n+        // shard lookup and the hashmap lookup. This relies on the fact\n+        // that both of them use `FxHasher`.\n+        let mut hasher = FxHasher::default();\n+        key.hash(&mut hasher);\n+        let key_hash = hasher.finish();\n+\n+        let shard = self.shards.get_shard_index_by_hash(key_hash);\n+        let lock = self.shards.get_shard_by_index(shard).lock();\n+        QueryLookup { key_hash, shard, lock }\n     }\n }\n \n /// Indicates the state of a query for a given key in a query map.\n pub(super) enum QueryResult<'tcx> {\n     /// An already executing query. The query job can be used to await for its completion.\n-    Started(Lrc<QueryJob<'tcx>>),\n+    Started(QueryJob<'tcx>),\n \n-    /// The query panicked. Queries trying to wait on this will raise a fatal error or\n+    /// The query panicked. Queries trying to wait on this will raise a fatal error which will\n     /// silently panic.\n     Poisoned,\n }\n \n-impl<'tcx, M: QueryConfig<'tcx>> Default for QueryCache<'tcx, M> {\n-    fn default() -> QueryCache<'tcx, M> {\n-        QueryCache {\n-            results: FxHashMap::default(),\n-            active: FxHashMap::default(),\n+impl<'tcx, M: QueryAccessors<'tcx>> QueryState<'tcx, M> {\n+    pub fn iter_results<R>(\n+        &self,\n+        f: impl for<'a> FnOnce(\n+            Box<dyn Iterator<Item = (&'a M::Key, &'a M::Value, DepNodeIndex)> + 'a>,\n+        ) -> R,\n+    ) -> R {\n+        self.cache.iter(&self.shards, |shard| &mut shard.cache, f)\n+    }\n+    pub fn all_inactive(&self) -> bool {\n+        let shards = self.shards.lock_shards();\n+        shards.iter().all(|shard| shard.active.is_empty())\n+    }\n+}\n+\n+impl<'tcx, M: QueryAccessors<'tcx>> Default for QueryState<'tcx, M> {\n+    fn default() -> QueryState<'tcx, M> {\n+        QueryState {\n+            cache: M::Cache::default(),\n+            shards: Default::default(),\n             #[cfg(debug_assertions)]\n-            cache_hits: 0,\n+            cache_hits: AtomicUsize::new(0),\n         }\n     }\n }\n \n+/// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n+pub(crate) struct QueryLookup<'tcx, Q: QueryAccessors<'tcx>> {\n+    pub(super) key_hash: u64,\n+    pub(super) shard: usize,\n+    pub(super) lock: LockGuard<'tcx, QueryStateShard<'tcx, Q>>,\n+}\n+\n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-pub(super) struct JobOwner<'a, 'tcx, Q: QueryDescription<'tcx>> {\n-    cache: &'a Sharded<QueryCache<'tcx, Q>>,\n+pub(super) struct JobOwner<'tcx, Q: QueryDescription<'tcx>> {\n+    tcx: TyCtxt<'tcx>,\n     key: Q::Key,\n-    job: Lrc<QueryJob<'tcx>>,\n+    id: QueryJobId,\n }\n \n-impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n+impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n     /// start executing the query, or returns with the result of the query.\n-    /// If the query is executing elsewhere, this will wait for it.\n+    /// This function assumes that `try_get_cached` is already called and returned `lookup`.\n+    /// If the query is executing elsewhere, this will wait for it and return the result.\n     /// If the query panicked, this will silently panic.\n     ///\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    pub(super) fn try_get(tcx: TyCtxt<'tcx>, span: Span, key: &Q::Key) -> TryGetJob<'a, 'tcx, Q> {\n-        // Handling the `query_blocked_prof_timer` is a bit weird because of the\n-        // control flow in this function: Blocking is implemented by\n-        // awaiting a running job and, once that is done, entering the loop below\n-        // again from the top. In that second iteration we will hit the\n-        // cache which provides us with the information we need for\n-        // finishing the \"query-blocked\" event.\n-        //\n-        // We thus allocate `query_blocked_prof_timer` outside the loop,\n-        // initialize it during the first iteration and finish it during the\n-        // second iteration.\n-        #[cfg(parallel_compiler)]\n-        let mut query_blocked_prof_timer: Option<TimingGuard<'_>> = None;\n-\n-        let cache = Q::query_cache(tcx);\n-        loop {\n-            // We compute the key's hash once and then use it for both the\n-            // shard lookup and the hashmap lookup. This relies on the fact\n-            // that both of them use `FxHasher`.\n-            let mut state = FxHasher::default();\n-            key.hash(&mut state);\n-            let key_hash = state.finish();\n-\n-            let mut lock = cache.get_shard_by_hash(key_hash).lock();\n-            if let Some((_, value)) =\n-                lock.results.raw_entry().from_key_hashed_nocheck(key_hash, key)\n-            {\n-                if unlikely!(tcx.prof.enabled()) {\n-                    tcx.prof.query_cache_hit(value.index.into());\n+    pub(super) fn try_start(\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+        key: &Q::Key,\n+        mut lookup: QueryLookup<'tcx, Q>,\n+    ) -> TryGetJob<'tcx, Q> {\n+        let lock = &mut *lookup.lock;\n+\n+        let (latch, mut _query_blocked_prof_timer) = match lock.active.entry((*key).clone()) {\n+            Entry::Occupied(mut entry) => {\n+                match entry.get_mut() {\n+                    QueryResult::Started(job) => {\n+                        // For parallel queries, we'll block and wait until the query running\n+                        // in another thread has completed. Record how long we wait in the\n+                        // self-profiler.\n+                        let _query_blocked_prof_timer = if cfg!(parallel_compiler) {\n+                            Some(tcx.prof.query_blocked())\n+                        } else {\n+                            None\n+                        };\n \n-                    #[cfg(parallel_compiler)]\n-                    {\n-                        if let Some(prof_timer) = query_blocked_prof_timer.take() {\n-                            prof_timer.finish_with_query_invocation_id(value.index.into());\n-                        }\n+                        // Create the id of the job we're waiting for\n+                        let id = QueryJobId::new(job.id, lookup.shard, Q::dep_kind());\n+\n+                        (job.latch(id), _query_blocked_prof_timer)\n                     }\n+                    QueryResult::Poisoned => FatalError.raise(),\n                 }\n+            }\n+            Entry::Vacant(entry) => {\n+                // No job entry for this query. Return a new one to be started later.\n \n-                let result = (value.value.clone(), value.index);\n-                #[cfg(debug_assertions)]\n-                {\n-                    lock.cache_hits += 1;\n-                }\n-                return TryGetJob::JobCompleted(result);\n+                // Generate an id unique within this shard.\n+                let id = lock.jobs.checked_add(1).unwrap();\n+                lock.jobs = id;\n+                let id = QueryShardJobId(NonZeroU32::new(id).unwrap());\n+\n+                let global_id = QueryJobId::new(id, lookup.shard, Q::dep_kind());\n+\n+                let job = tls::with_related_context(tcx, |icx| QueryJob::new(id, span, icx.query));\n+\n+                entry.insert(QueryResult::Started(job));\n+\n+                let owner = JobOwner { tcx, id: global_id, key: (*key).clone() };\n+                return TryGetJob::NotYetStarted(owner);\n             }\n+        };\n+        mem::drop(lookup.lock);\n \n-            let job = match lock.active.entry((*key).clone()) {\n-                Entry::Occupied(entry) => {\n-                    match *entry.get() {\n-                        QueryResult::Started(ref job) => {\n-                            // For parallel queries, we'll block and wait until the query running\n-                            // in another thread has completed. Record how long we wait in the\n-                            // self-profiler.\n-                            #[cfg(parallel_compiler)]\n-                            {\n-                                query_blocked_prof_timer = Some(tcx.prof.query_blocked());\n-                            }\n-\n-                            job.clone()\n-                        }\n-                        QueryResult::Poisoned => FatalError.raise(),\n-                    }\n-                }\n-                Entry::Vacant(entry) => {\n-                    // No job entry for this query. Return a new one to be started later.\n-                    return tls::with_related_context(tcx, |icx| {\n-                        // Create the `parent` variable before `info`. This allows LLVM\n-                        // to elide the move of `info`\n-                        let parent = icx.query.clone();\n-                        let info = QueryInfo { span, query: Q::query(key.clone()) };\n-                        let job = Lrc::new(QueryJob::new(info, parent));\n-                        let owner = JobOwner { cache, job: job.clone(), key: (*key).clone() };\n-                        entry.insert(QueryResult::Started(job));\n-                        TryGetJob::NotYetStarted(owner)\n-                    });\n-                }\n-            };\n-            mem::drop(lock);\n+        // If we are single-threaded we know that we have cycle error,\n+        // so we just return the error.\n+        #[cfg(not(parallel_compiler))]\n+        return TryGetJob::Cycle(cold_path(|| {\n+            Q::handle_cycle_error(tcx, latch.find_cycle_in_stack(tcx, span))\n+        }));\n \n-            // If we are single-threaded we know that we have cycle error,\n-            // so we just return the error.\n-            #[cfg(not(parallel_compiler))]\n-            return TryGetJob::Cycle(cold_path(|| {\n-                Q::handle_cycle_error(tcx, job.find_cycle_in_stack(tcx, span))\n-            }));\n+        // With parallel queries we might just have to wait on some other\n+        // thread.\n+        #[cfg(parallel_compiler)]\n+        {\n+            let result = latch.wait_on(tcx, span);\n \n-            // With parallel queries we might just have to wait on some other\n-            // thread.\n-            #[cfg(parallel_compiler)]\n-            {\n-                let result = job.r#await(tcx, span);\n+            if let Err(cycle) = result {\n+                return TryGetJob::Cycle(Q::handle_cycle_error(tcx, cycle));\n+            }\n \n-                if let Err(cycle) = result {\n-                    return TryGetJob::Cycle(Q::handle_cycle_error(tcx, cycle));\n-                }\n+            let cached = tcx.try_get_cached::<Q, _, _, _>(\n+                (*key).clone(),\n+                |value, index| (value.clone(), index),\n+                |_, _| panic!(\"value must be in cache after waiting\"),\n+            );\n+\n+            if let Some(prof_timer) = _query_blocked_prof_timer.take() {\n+                prof_timer.finish_with_query_invocation_id(cached.1.into());\n             }\n+\n+            return TryGetJob::JobCompleted(cached);\n         }\n     }\n \n@@ -186,18 +218,22 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n     pub(super) fn complete(self, result: &Q::Value, dep_node_index: DepNodeIndex) {\n         // We can move out of `self` here because we `mem::forget` it below\n         let key = unsafe { ptr::read(&self.key) };\n-        let job = unsafe { ptr::read(&self.job) };\n-        let cache = self.cache;\n+        let tcx = self.tcx;\n \n         // Forget ourself so our destructor won't poison the query\n         mem::forget(self);\n \n-        let value = QueryValue::new(result.clone(), dep_node_index);\n-        {\n-            let mut lock = cache.get_shard_by_value(&key).lock();\n-            lock.active.remove(&key);\n-            lock.results.insert(key, value);\n-        }\n+        let job = {\n+            let state = Q::query_state(tcx);\n+            let result = result.clone();\n+            let mut lock = state.shards.get_shard_by_value(&key).lock();\n+            let job = match lock.active.remove(&key).unwrap() {\n+                QueryResult::Started(job) => job,\n+                QueryResult::Poisoned => panic!(),\n+            };\n+            state.cache.complete(tcx, &mut lock.cache, key, result, dep_node_index);\n+            job\n+        };\n \n         job.signal_complete();\n     }\n@@ -213,16 +249,25 @@ where\n     (result, diagnostics.into_inner())\n }\n \n-impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n+impl<'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'tcx, Q> {\n     #[inline(never)]\n     #[cold]\n     fn drop(&mut self) {\n         // Poison the query so jobs waiting on it panic.\n-        let shard = self.cache.get_shard_by_value(&self.key);\n-        shard.lock().active.insert(self.key.clone(), QueryResult::Poisoned);\n+        let state = Q::query_state(self.tcx);\n+        let shard = state.shards.get_shard_by_value(&self.key);\n+        let job = {\n+            let mut shard = shard.lock();\n+            let job = match shard.active.remove(&self.key).unwrap() {\n+                QueryResult::Started(job) => job,\n+                QueryResult::Poisoned => panic!(),\n+            };\n+            shard.active.insert(self.key.clone(), QueryResult::Poisoned);\n+            job\n+        };\n         // Also signal the completion of the job, so waiters\n         // will continue execution.\n-        self.job.signal_complete();\n+        job.signal_complete();\n     }\n }\n \n@@ -233,14 +278,15 @@ pub struct CycleError<'tcx> {\n     pub(super) cycle: Vec<QueryInfo<'tcx>>,\n }\n \n-/// The result of `try_get_lock`.\n-pub(super) enum TryGetJob<'a, 'tcx, D: QueryDescription<'tcx>> {\n+/// The result of `try_start`.\n+pub(super) enum TryGetJob<'tcx, D: QueryDescription<'tcx>> {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n-    NotYetStarted(JobOwner<'a, 'tcx, D>),\n+    NotYetStarted(JobOwner<'tcx, D>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep-node index\n     /// if it succeeded or a cycle error if it failed.\n+    #[cfg(parallel_compiler)]\n     JobCompleted((D::Value, DepNodeIndex)),\n \n     /// Trying to execute the query resulted in a cycle.\n@@ -254,7 +300,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline(always)]\n     pub(super) fn start_query<F, R>(\n         self,\n-        job: Lrc<QueryJob<'tcx>>,\n+        token: QueryJobId,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n         compute: F,\n     ) -> R\n@@ -268,7 +314,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             // Update the `ImplicitCtxt` to point to our new query job.\n             let new_icx = tls::ImplicitCtxt {\n                 tcx: self,\n-                query: Some(job),\n+                query: Some(token),\n                 diagnostics,\n                 layout_depth: current_icx.layout_depth,\n                 task_deps: current_icx.task_deps,\n@@ -335,23 +381,31 @@ impl<'tcx> TyCtxt<'tcx> {\n         // state if it was responsible for triggering the panic.\n         tls::with_context_opt(|icx| {\n             if let Some(icx) = icx {\n-                let mut current_query = icx.query.clone();\n+                let query_map = icx.tcx.queries.try_collect_active_jobs();\n+\n+                let mut current_query = icx.query;\n                 let mut i = 0;\n \n                 while let Some(query) = current_query {\n+                    let query_info =\n+                        if let Some(info) = query_map.as_ref().and_then(|map| map.get(&query)) {\n+                            info\n+                        } else {\n+                            break;\n+                        };\n                     let mut diag = Diagnostic::new(\n                         Level::FailureNote,\n                         &format!(\n                             \"#{} [{}] {}\",\n                             i,\n-                            query.info.query.name(),\n-                            query.info.query.describe(icx.tcx)\n+                            query_info.info.query.name(),\n+                            query_info.info.query.describe(icx.tcx)\n                         ),\n                     );\n-                    diag.span = icx.tcx.sess.source_map().def_span(query.info.span).into();\n+                    diag.span = icx.tcx.sess.source_map().def_span(query_info.info.span).into();\n                     handler.force_print_diagnostic(diag);\n \n-                    current_query = query.parent.clone();\n+                    current_query = query_info.job.parent;\n                     i += 1;\n                 }\n             }\n@@ -360,13 +414,72 @@ impl<'tcx> TyCtxt<'tcx> {\n         eprintln!(\"end of query stack\");\n     }\n \n+    /// Checks if the query is already computed and in the cache.\n+    /// It returns the shard index and a lock guard to the shard,\n+    /// which will be used if the query is not in the cache and we need\n+    /// to compute it.\n+    #[inline(always)]\n+    fn try_get_cached<Q, R, OnHit, OnMiss>(\n+        self,\n+        key: Q::Key,\n+        // `on_hit` can be called while holding a lock to the query cache\n+        on_hit: OnHit,\n+        on_miss: OnMiss,\n+    ) -> R\n+    where\n+        Q: QueryDescription<'tcx> + 'tcx,\n+        OnHit: FnOnce(&Q::Value, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(Q::Key, QueryLookup<'tcx, Q>) -> R,\n+    {\n+        let state = Q::query_state(self);\n+\n+        state.cache.lookup(\n+            state,\n+            QueryStateShard::<Q>::get_cache,\n+            key,\n+            |value, index| {\n+                if unlikely!(self.prof.enabled()) {\n+                    self.prof.query_cache_hit(index.into());\n+                }\n+                #[cfg(debug_assertions)]\n+                {\n+                    state.cache_hits.fetch_add(1, Ordering::Relaxed);\n+                }\n+                on_hit(value, index)\n+            },\n+            on_miss,\n+        )\n+    }\n+\n     #[inline(never)]\n-    pub(super) fn get_query<Q: QueryDescription<'tcx>>(self, span: Span, key: Q::Key) -> Q::Value {\n+    pub(super) fn get_query<Q: QueryDescription<'tcx> + 'tcx>(\n+        self,\n+        span: Span,\n+        key: Q::Key,\n+    ) -> Q::Value {\n         debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\", Q::NAME, key, span);\n \n-        let job = match JobOwner::try_get(self, span, &key) {\n+        self.try_get_cached::<Q, _, _, _>(\n+            key,\n+            |value, index| {\n+                self.dep_graph.read_index(index);\n+                value.clone()\n+            },\n+            |key, lookup| self.try_execute_query::<Q>(span, key, lookup),\n+        )\n+    }\n+\n+    #[inline(always)]\n+    pub(super) fn try_execute_query<Q: QueryDescription<'tcx>>(\n+        self,\n+        span: Span,\n+        key: Q::Key,\n+        lookup: QueryLookup<'tcx, Q>,\n+    ) -> Q::Value {\n+        let job = match JobOwner::try_start(self, span, &key, lookup) {\n             TryGetJob::NotYetStarted(job) => job,\n             TryGetJob::Cycle(result) => return result,\n+            #[cfg(parallel_compiler)]\n             TryGetJob::JobCompleted((v, index)) => {\n                 self.dep_graph.read_index(index);\n                 return v;\n@@ -384,7 +497,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             let prof_timer = self.prof.query_provider();\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-                self.start_query(job.job.clone(), diagnostics, |tcx| {\n+                self.start_query(job.id, diagnostics, |tcx| {\n                     tcx.dep_graph.with_anon_task(Q::dep_kind(), || Q::compute(tcx, key))\n                 })\n             });\n@@ -410,7 +523,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             // The diagnostics for this query will be\n             // promoted to the current session during\n             // `try_mark_green()`, so we can ignore them here.\n-            let loaded = self.start_query(job.job.clone(), None, |tcx| {\n+            let loaded = self.start_query(job.id, None, |tcx| {\n                 let marked = tcx.dep_graph.try_mark_green_and_read(tcx, &dep_node);\n                 marked.map(|(prev_dep_node_index, dep_node_index)| {\n                     (\n@@ -524,7 +637,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn force_query_with_job<Q: QueryDescription<'tcx>>(\n         self,\n         key: Q::Key,\n-        job: JobOwner<'_, 'tcx, Q>,\n+        job: JobOwner<'tcx, Q>,\n         dep_node: DepNode,\n     ) -> (Q::Value, DepNodeIndex) {\n         // If the following assertion triggers, it can have two reasons:\n@@ -544,7 +657,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let prof_timer = self.prof.query_provider();\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-            self.start_query(job.job.clone(), diagnostics, |tcx| {\n+            self.start_query(job.id, diagnostics, |tcx| {\n                 if Q::EVAL_ALWAYS {\n                     tcx.dep_graph.with_eval_always_task(\n                         dep_node,\n@@ -579,7 +692,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// side-effects -- e.g., in order to report errors for erroneous programs.\n     ///\n     /// Note: The optimization is only available during incr. comp.\n-    pub(super) fn ensure_query<Q: QueryDescription<'tcx>>(self, key: Q::Key) -> () {\n+    pub(super) fn ensure_query<Q: QueryDescription<'tcx> + 'tcx>(self, key: Q::Key) -> () {\n         if Q::EVAL_ALWAYS {\n             let _ = self.get_query::<Q>(DUMMY_SP, key);\n             return;\n@@ -607,14 +720,30 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[allow(dead_code)]\n-    fn force_query<Q: QueryDescription<'tcx>>(self, key: Q::Key, span: Span, dep_node: DepNode) {\n+    fn force_query<Q: QueryDescription<'tcx> + 'tcx>(\n+        self,\n+        key: Q::Key,\n+        span: Span,\n+        dep_node: DepNode,\n+    ) {\n         // We may be concurrently trying both execute and force a query.\n         // Ensure that only one of them runs the query.\n-        let job = match JobOwner::try_get(self, span, &key) {\n-            TryGetJob::NotYetStarted(job) => job,\n-            TryGetJob::Cycle(_) | TryGetJob::JobCompleted(_) => return,\n-        };\n-        self.force_query_with_job::<Q>(key, job, dep_node);\n+\n+        self.try_get_cached::<Q, _, _, _>(\n+            key,\n+            |_, _| {\n+                // Cache hit, do nothing\n+            },\n+            |key, lookup| {\n+                let job = match JobOwner::try_start(self, span, &key, lookup) {\n+                    TryGetJob::NotYetStarted(job) => job,\n+                    TryGetJob::Cycle(_) => return,\n+                    #[cfg(parallel_compiler)]\n+                    TryGetJob::JobCompleted(_) => return,\n+                };\n+                self.force_query_with_job::<Q>(key, job, dep_node);\n+            },\n+        );\n     }\n }\n \n@@ -623,53 +752,65 @@ macro_rules! handle_cycle_error {\n         $tcx.report_cycle($error).emit();\n         Value::from_cycle_error($tcx)\n     }};\n-    ([fatal_cycle$(, $modifiers:ident)*][$tcx:expr, $error:expr]) => {{\n+    ([fatal_cycle $($rest:tt)*][$tcx:expr, $error:expr]) => {{\n         $tcx.report_cycle($error).emit();\n         $tcx.sess.abort_if_errors();\n         unreachable!()\n     }};\n-    ([cycle_delay_bug$(, $modifiers:ident)*][$tcx:expr, $error:expr]) => {{\n+    ([cycle_delay_bug $($rest:tt)*][$tcx:expr, $error:expr]) => {{\n         $tcx.report_cycle($error).delay_as_bug();\n         Value::from_cycle_error($tcx)\n     }};\n-    ([$other:ident$(, $modifiers:ident)*][$($args:tt)*]) => {\n-        handle_cycle_error!([$($modifiers),*][$($args)*])\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n+        handle_cycle_error!([$($($modifiers)*)*][$($args)*])\n     };\n }\n \n macro_rules! is_anon {\n     ([]) => {{\n         false\n     }};\n-    ([anon$(, $modifiers:ident)*]) => {{\n+    ([anon $($rest:tt)*]) => {{\n         true\n     }};\n-    ([$other:ident$(, $modifiers:ident)*]) => {\n-        is_anon!([$($modifiers),*])\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*]) => {\n+        is_anon!([$($($modifiers)*)*])\n     };\n }\n \n macro_rules! is_eval_always {\n     ([]) => {{\n         false\n     }};\n-    ([eval_always$(, $modifiers:ident)*]) => {{\n+    ([eval_always $($rest:tt)*]) => {{\n         true\n     }};\n-    ([$other:ident$(, $modifiers:ident)*]) => {\n-        is_eval_always!([$($modifiers),*])\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*]) => {\n+        is_eval_always!([$($($modifiers)*)*])\n+    };\n+}\n+\n+macro_rules! query_storage {\n+    ([][$K:ty, $V:ty]) => {\n+        <<$K as Key>::CacheSelector as CacheSelector<$K, $V>>::Cache\n+    };\n+    ([storage($ty:ty) $($rest:tt)*][$K:ty, $V:ty]) => {\n+        $ty\n+    };\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n+        query_storage!([$($($modifiers)*)*][$($args)*])\n     };\n }\n \n macro_rules! hash_result {\n     ([][$hcx:expr, $result:expr]) => {{\n         dep_graph::hash_result($hcx, &$result)\n     }};\n-    ([no_hash$(, $modifiers:ident)*][$hcx:expr, $result:expr]) => {{\n+    ([no_hash $($rest:tt)*][$hcx:expr, $result:expr]) => {{\n         None\n     }};\n-    ([$other:ident$(, $modifiers:ident)*][$($args:tt)*]) => {\n-        hash_result!([$($modifiers),*][$($args)*])\n+    ([$other:ident $(($($other_args:tt)*))* $(, $($modifiers:tt)*)*][$($args:tt)*]) => {\n+        hash_result!([$($($modifiers)*)*][$($args)*])\n     };\n }\n \n@@ -689,7 +830,6 @@ macro_rules! define_queries_inner {\n         [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n \n         use std::mem;\n-        use rustc_data_structures::sharded::Sharded;\n         use crate::{\n             rustc_data_structures::stable_hasher::HashStable,\n             rustc_data_structures::stable_hasher::StableHasher,\n@@ -716,120 +856,38 @@ macro_rules! define_queries_inner {\n                 }\n             }\n \n-            #[cfg(parallel_compiler)]\n-            pub fn collect_active_jobs(&self) -> Vec<Lrc<QueryJob<$tcx>>> {\n-                let mut jobs = Vec::new();\n+            pub fn try_collect_active_jobs(\n+                &self\n+            ) -> Option<FxHashMap<QueryJobId, QueryJobInfo<'tcx>>> {\n+                let mut jobs = FxHashMap::default();\n \n-                // We use try_lock_shards here since we are only called from the\n-                // deadlock handler, and this shouldn't be locked.\n                 $(\n-                    let shards = self.$name.try_lock_shards().unwrap();\n-                    jobs.extend(shards.iter().flat_map(|shard| shard.active.values().filter_map(|v|\n+                    // We use try_lock_shards here since we are called from the\n+                    // deadlock handler, and this shouldn't be locked.\n+                    let shards = self.$name.shards.try_lock_shards()?;\n+                    let shards = shards.iter().enumerate();\n+                    jobs.extend(shards.flat_map(|(shard_id, shard)| {\n+                        shard.active.iter().filter_map(move |(k, v)| {\n                         if let QueryResult::Started(ref job) = *v {\n-                            Some(job.clone())\n+                                let id = QueryJobId {\n+                                    job: job.id,\n+                                    shard:  u16::try_from(shard_id).unwrap(),\n+                                    kind:\n+                                        <queries::$name<'tcx> as QueryAccessors<'tcx>>::dep_kind(),\n+                                };\n+                                let info = QueryInfo {\n+                                    span: job.span,\n+                                    query: queries::$name::query(k.clone())\n+                                };\n+                                Some((id, QueryJobInfo { info,  job: job.clone() }))\n                         } else {\n                             None\n                         }\n-                    )));\n-                )*\n-\n-                jobs\n-            }\n-\n-            pub fn print_stats(&self) {\n-                let mut queries = Vec::new();\n-\n-                #[derive(Clone)]\n-                struct QueryStats {\n-                    name: &'static str,\n-                    cache_hits: usize,\n-                    key_size: usize,\n-                    key_type: &'static str,\n-                    value_size: usize,\n-                    value_type: &'static str,\n-                    entry_count: usize,\n-                }\n-\n-                fn stats<'tcx, Q: QueryConfig<'tcx>>(\n-                    name: &'static str,\n-                    map: &Sharded<QueryCache<'tcx, Q>>,\n-                ) -> QueryStats {\n-                    let map = map.lock_shards();\n-                    QueryStats {\n-                        name,\n-                        #[cfg(debug_assertions)]\n-                        cache_hits: map.iter().map(|shard| shard.cache_hits).sum(),\n-                        #[cfg(not(debug_assertions))]\n-                        cache_hits: 0,\n-                        key_size: mem::size_of::<Q::Key>(),\n-                        key_type: type_name::<Q::Key>(),\n-                        value_size: mem::size_of::<Q::Value>(),\n-                        value_type: type_name::<Q::Value>(),\n-                        entry_count: map.iter().map(|shard| shard.results.len()).sum(),\n-                    }\n-                }\n-\n-                $(\n-                    queries.push(stats::<queries::$name<'_>>(\n-                        stringify!($name),\n-                        &self.$name,\n-                    ));\n+                        })\n+                    }));\n                 )*\n \n-                if cfg!(debug_assertions) {\n-                    let hits: usize = queries.iter().map(|s| s.cache_hits).sum();\n-                    let results: usize = queries.iter().map(|s| s.entry_count).sum();\n-                    println!(\"\\nQuery cache hit rate: {}\", hits as f64 / (hits + results) as f64);\n-                }\n-\n-                let mut query_key_sizes = queries.clone();\n-                query_key_sizes.sort_by_key(|q| q.key_size);\n-                println!(\"\\nLarge query keys:\");\n-                for q in query_key_sizes.iter().rev()\n-                                        .filter(|q| q.key_size > 8) {\n-                    println!(\n-                        \"   {} - {} x {} - {}\",\n-                        q.name,\n-                        q.key_size,\n-                        q.entry_count,\n-                        q.key_type\n-                    );\n-                }\n-\n-                let mut query_value_sizes = queries.clone();\n-                query_value_sizes.sort_by_key(|q| q.value_size);\n-                println!(\"\\nLarge query values:\");\n-                for q in query_value_sizes.iter().rev()\n-                                          .filter(|q| q.value_size > 8) {\n-                    println!(\n-                        \"   {} - {} x {} - {}\",\n-                        q.name,\n-                        q.value_size,\n-                        q.entry_count,\n-                        q.value_type\n-                    );\n-                }\n-\n-                if cfg!(debug_assertions) {\n-                    let mut query_cache_hits = queries.clone();\n-                    query_cache_hits.sort_by_key(|q| q.cache_hits);\n-                    println!(\"\\nQuery cache hits:\");\n-                    for q in query_cache_hits.iter().rev() {\n-                        println!(\n-                            \"   {} - {} ({}%)\",\n-                            q.name,\n-                            q.cache_hits,\n-                            q.cache_hits as f64 / (q.cache_hits + q.entry_count) as f64\n-                        );\n-                    }\n-                }\n-\n-                let mut query_value_count = queries.clone();\n-                query_value_count.sort_by_key(|q| q.entry_count);\n-                println!(\"\\nQuery value count:\");\n-                for q in query_value_count.iter().rev() {\n-                    println!(\"   {} - {}\", q.name, q.entry_count);\n-                }\n+                Some(jobs)\n             }\n         }\n \n@@ -906,7 +964,6 @@ macro_rules! define_queries_inner {\n         $(impl<$tcx> QueryConfig<$tcx> for queries::$name<$tcx> {\n             type Key = $K;\n             type Value = $V;\n-\n             const NAME: &'static str = stringify!($name);\n             const CATEGORY: ProfileCategory = $category;\n         }\n@@ -915,22 +972,22 @@ macro_rules! define_queries_inner {\n             const ANON: bool = is_anon!([$($modifiers)*]);\n             const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n \n+            type Cache = query_storage!([$($modifiers)*][$K, $V]);\n+\n             #[inline(always)]\n             fn query(key: Self::Key) -> Query<'tcx> {\n                 Query::$name(key)\n             }\n \n             #[inline(always)]\n-            fn query_cache<'a>(tcx: TyCtxt<$tcx>) -> &'a Sharded<QueryCache<$tcx, Self>> {\n+            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<$tcx, Self> {\n                 &tcx.queries.$name\n             }\n \n             #[allow(unused)]\n             #[inline(always)]\n             fn to_dep_node(tcx: TyCtxt<$tcx>, key: &Self::Key) -> DepNode {\n-                use crate::dep_graph::DepConstructor::*;\n-\n-                DepNode::new(tcx, $node(*key))\n+                DepConstructor::$node(tcx, *key)\n             }\n \n             #[inline(always)]\n@@ -1082,7 +1139,7 @@ macro_rules! define_queries_struct {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n             fallback_extern_providers: Box<Providers<$tcx>>,\n \n-            $($(#[$attr])*  $name: Sharded<QueryCache<$tcx, queries::$name<$tcx>>>,)*\n+            $($(#[$attr])*  $name: QueryState<$tcx, queries::$name<$tcx>>,)*\n         }\n     };\n }"}, {"sha": "99ada34d59ebed13c5b4829e107e0be83f973c40", "filename": "src/librustc/ty/query/profiling_support.rs", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,11 +1,10 @@\n use crate::hir::map::definitions::DefPathData;\n use crate::ty::context::TyCtxt;\n-use crate::ty::query::config::QueryConfig;\n-use crate::ty::query::plumbing::QueryCache;\n+use crate::ty::query::config::QueryAccessors;\n+use crate::ty::query::plumbing::QueryState;\n use measureme::{StringComponent, StringId};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfiler;\n-use rustc_data_structures::sharded::Sharded;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use std::fmt::Debug;\n use std::io::Write;\n@@ -161,10 +160,10 @@ where\n pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, Q>(\n     tcx: TyCtxt<'tcx>,\n     query_name: &'static str,\n-    query_cache: &Sharded<QueryCache<'tcx, Q>>,\n+    query_state: &QueryState<'tcx, Q>,\n     string_cache: &mut QueryKeyStringCache,\n ) where\n-    Q: QueryConfig<'tcx>,\n+    Q: QueryAccessors<'tcx>,\n {\n     tcx.prof.with_profiler(|profiler| {\n         let event_id_builder = profiler.event_id_builder();\n@@ -181,20 +180,8 @@ pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, Q>(\n             // need to invoke queries itself, we cannot keep the query caches\n             // locked while doing so. Instead we copy out the\n             // `(query_key, dep_node_index)` pairs and release the lock again.\n-            let query_keys_and_indices = {\n-                let shards = query_cache.lock_shards();\n-                let len = shards.iter().map(|shard| shard.results.len()).sum();\n-\n-                let mut query_keys_and_indices = Vec::with_capacity(len);\n-\n-                for shard in &shards {\n-                    query_keys_and_indices.extend(\n-                        shard.results.iter().map(|(q_key, q_val)| (q_key.clone(), q_val.index)),\n-                    );\n-                }\n-\n-                query_keys_and_indices\n-            };\n+            let query_keys_and_indices: Vec<_> = query_state\n+                .iter_results(|results| results.map(|(k, _, i)| (k.clone(), i)).collect());\n \n             // Now actually allocate the strings. If allocating the strings\n             // generates new entries in the query cache, we'll miss them but\n@@ -218,18 +205,14 @@ pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, Q>(\n             let query_name = profiler.get_or_alloc_cached_string(query_name);\n             let event_id = event_id_builder.from_label(query_name).to_string_id();\n \n-            let shards = query_cache.lock_shards();\n+            query_state.iter_results(|results| {\n+                let query_invocation_ids: Vec<_> = results.map(|v| v.2.into()).collect();\n \n-            for shard in shards.iter() {\n-                let query_invocation_ids = shard\n-                    .results\n-                    .values()\n-                    .map(|v| v.index)\n-                    .map(|dep_node_index| dep_node_index.into());\n-\n-                profiler\n-                    .bulk_map_query_invocation_id_to_single_string(query_invocation_ids, event_id);\n-            }\n+                profiler.bulk_map_query_invocation_id_to_single_string(\n+                    query_invocation_ids.into_iter(),\n+                    event_id,\n+                );\n+            });\n         }\n     });\n }"}, {"sha": "d257320d4eaf652242660491b94603750217d6ed", "filename": "src/librustc/ty/query/stats.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -0,0 +1,139 @@\n+use crate::ty::query::config::QueryAccessors;\n+use crate::ty::query::plumbing::QueryState;\n+use crate::ty::query::queries;\n+use crate::ty::TyCtxt;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+\n+use std::any::type_name;\n+use std::mem;\n+#[cfg(debug_assertions)]\n+use std::sync::atomic::Ordering;\n+\n+trait KeyStats {\n+    fn key_stats(&self, stats: &mut QueryStats);\n+}\n+\n+impl<T> KeyStats for T {\n+    default fn key_stats(&self, _: &mut QueryStats) {}\n+}\n+\n+impl KeyStats for DefId {\n+    fn key_stats(&self, stats: &mut QueryStats) {\n+        if self.krate == LOCAL_CRATE {\n+            stats.local_def_id_keys = Some(stats.local_def_id_keys.unwrap_or(0) + 1);\n+        }\n+    }\n+}\n+\n+#[derive(Clone)]\n+struct QueryStats {\n+    name: &'static str,\n+    cache_hits: usize,\n+    key_size: usize,\n+    key_type: &'static str,\n+    value_size: usize,\n+    value_type: &'static str,\n+    entry_count: usize,\n+    local_def_id_keys: Option<usize>,\n+}\n+\n+fn stats<'tcx, Q: QueryAccessors<'tcx>>(\n+    name: &'static str,\n+    map: &QueryState<'tcx, Q>,\n+) -> QueryStats {\n+    let mut stats = QueryStats {\n+        name,\n+        #[cfg(debug_assertions)]\n+        cache_hits: map.cache_hits.load(Ordering::Relaxed),\n+        #[cfg(not(debug_assertions))]\n+        cache_hits: 0,\n+        key_size: mem::size_of::<Q::Key>(),\n+        key_type: type_name::<Q::Key>(),\n+        value_size: mem::size_of::<Q::Value>(),\n+        value_type: type_name::<Q::Value>(),\n+        entry_count: map.iter_results(|results| results.count()),\n+        local_def_id_keys: None,\n+    };\n+    map.iter_results(|results| {\n+        for (key, _, _) in results {\n+            key.key_stats(&mut stats)\n+        }\n+    });\n+    stats\n+}\n+\n+pub fn print_stats(tcx: TyCtxt<'_>) {\n+    let queries = query_stats(tcx);\n+\n+    if cfg!(debug_assertions) {\n+        let hits: usize = queries.iter().map(|s| s.cache_hits).sum();\n+        let results: usize = queries.iter().map(|s| s.entry_count).sum();\n+        println!(\"\\nQuery cache hit rate: {}\", hits as f64 / (hits + results) as f64);\n+    }\n+\n+    let mut query_key_sizes = queries.clone();\n+    query_key_sizes.sort_by_key(|q| q.key_size);\n+    println!(\"\\nLarge query keys:\");\n+    for q in query_key_sizes.iter().rev().filter(|q| q.key_size > 8) {\n+        println!(\"   {} - {} x {} - {}\", q.name, q.key_size, q.entry_count, q.key_type);\n+    }\n+\n+    let mut query_value_sizes = queries.clone();\n+    query_value_sizes.sort_by_key(|q| q.value_size);\n+    println!(\"\\nLarge query values:\");\n+    for q in query_value_sizes.iter().rev().filter(|q| q.value_size > 8) {\n+        println!(\"   {} - {} x {} - {}\", q.name, q.value_size, q.entry_count, q.value_type);\n+    }\n+\n+    if cfg!(debug_assertions) {\n+        let mut query_cache_hits = queries.clone();\n+        query_cache_hits.sort_by_key(|q| q.cache_hits);\n+        println!(\"\\nQuery cache hits:\");\n+        for q in query_cache_hits.iter().rev() {\n+            println!(\n+                \"   {} - {} ({}%)\",\n+                q.name,\n+                q.cache_hits,\n+                q.cache_hits as f64 / (q.cache_hits + q.entry_count) as f64\n+            );\n+        }\n+    }\n+\n+    let mut query_value_count = queries.clone();\n+    query_value_count.sort_by_key(|q| q.entry_count);\n+    println!(\"\\nQuery value count:\");\n+    for q in query_value_count.iter().rev() {\n+        println!(\"   {} - {}\", q.name, q.entry_count);\n+    }\n+\n+    let mut def_id_density: Vec<_> =\n+        queries.iter().filter(|q| q.local_def_id_keys.is_some()).collect();\n+    def_id_density.sort_by_key(|q| q.local_def_id_keys.unwrap());\n+    println!(\"\\nLocal DefId density:\");\n+    let total = tcx.hir().definitions().def_index_count() as f64;\n+    for q in def_id_density.iter().rev() {\n+        let local = q.local_def_id_keys.unwrap();\n+        println!(\"   {} - {} = ({}%)\", q.name, local, (local as f64 * 100.0) / total);\n+    }\n+}\n+\n+macro_rules! print_stats {\n+    (<$tcx:tt> $($category:tt {\n+        $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*\n+    },)*) => {\n+        fn query_stats(tcx: TyCtxt<'_>) -> Vec<QueryStats> {\n+            let mut queries = Vec::new();\n+\n+            $($(\n+                queries.push(stats::<queries::$name<'_>>(\n+                    stringify!($name),\n+                    &tcx.queries.$name,\n+                ));\n+            )*)*\n+\n+            queries\n+        }\n+    }\n+}\n+\n+rustc_query_append! { [print_stats!][<'tcx>] }"}, {"sha": "b01d15c29b2db7612ec265c9529941a222a5f932", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1,4 +1,3 @@\n-use crate::ty::util::NeedsDrop;\n use crate::ty::{self, AdtSizedConstraint, Ty, TyCtxt};\n \n use rustc_span::symbol::Symbol;\n@@ -26,12 +25,6 @@ impl<'tcx> Value<'tcx> for ty::SymbolName {\n     }\n }\n \n-impl<'tcx> Value<'tcx> for NeedsDrop {\n-    fn from_cycle_error(_: TyCtxt<'tcx>) -> Self {\n-        NeedsDrop(false)\n-    }\n-}\n-\n impl<'tcx> Value<'tcx> for AdtSizedConstraint<'tcx> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n         AdtSizedConstraint(tcx.intern_type_list(&[tcx.types.err]))"}, {"sha": "59dd41e9d56c911db38e293fc8606129823fafdb", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -7,6 +7,7 @@ use crate::mir::ProjectionKind;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::{self, InferConst, Lift, Ty, TyCtxt};\n+use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::CRATE_DEF_INDEX;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -15,7 +16,6 @@ use smallvec::SmallVec;\n use std::fmt;\n use std::rc::Rc;\n use std::sync::Arc;\n-use syntax::ast;\n \n impl fmt::Debug for ty::GenericParamDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -236,7 +236,7 @@ impl fmt::Debug for ty::Predicate<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             ty::Predicate::Trait(ref a, constness) => {\n-                if let ast::Constness::Const = constness {\n+                if let hir::Constness::Const = constness {\n                     write!(f, \"const \")?;\n                 }\n                 a.fmt(f)"}, {"sha": "c3698f402a9d120f520b29d440cbcb05628b79b1", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -1066,10 +1066,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     ) -> ProjectionTy<'tcx> {\n         let item_def_id = tcx\n             .associated_items(trait_ref.def_id)\n-            .find(|item| {\n-                item.kind == ty::AssocKind::Type\n-                    && tcx.hygienic_eq(item_name, item.ident, trait_ref.def_id)\n-            })\n+            .find_by_name_and_kind(tcx, item_name, ty::AssocKind::Type, trait_ref.def_id)\n             .unwrap()\n             .def_id;\n \n@@ -1776,7 +1773,9 @@ impl RegionKind {\n             ty::ReEmpty(_) | ty::ReStatic | ty::ReFree { .. } | ty::ReScope { .. } => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }\n-            ty::ReErased => {}\n+            ty::ReErased => {\n+                flags = flags | TypeFlags::HAS_RE_ERASED;\n+            }\n             ty::ReClosureBound(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }\n@@ -2414,9 +2413,14 @@ pub struct Const<'tcx> {\n static_assert_size!(Const<'_>, 48);\n \n impl<'tcx> Const<'tcx> {\n+    #[inline]\n+    pub fn from_value(tcx: TyCtxt<'tcx>, val: ConstValue<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n+        tcx.mk_const(Self { val: ConstKind::Value(val), ty })\n+    }\n+\n     #[inline]\n     pub fn from_scalar(tcx: TyCtxt<'tcx>, val: Scalar, ty: Ty<'tcx>) -> &'tcx Self {\n-        tcx.mk_const(Self { val: ConstKind::Value(ConstValue::Scalar(val)), ty })\n+        Self::from_value(tcx, ConstValue::Scalar(val), ty)\n     }\n \n     #[inline]\n@@ -2470,7 +2474,9 @@ impl<'tcx> Const<'tcx> {\n \n             // try to resolve e.g. associated constants to their definition on an impl, and then\n             // evaluate the const.\n-            tcx.const_eval_resolve(param_env, did, substs, promoted, None).ok()\n+            tcx.const_eval_resolve(param_env, did, substs, promoted, None)\n+                .ok()\n+                .map(|val| Const::from_value(tcx, val, self.ty))\n         };\n \n         match self.val {"}, {"sha": "eec6893d357d620838a109d226297531e39ce319", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 128, "deletions": 8, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -18,6 +18,8 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_span::Span;\n+use rustc_target::abi::TargetDataLayout;\n+use smallvec::SmallVec;\n use std::{cmp, fmt};\n use syntax::ast;\n \n@@ -355,7 +357,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut dtor_did = None;\n         let ty = self.type_of(adt_did);\n         self.for_each_relevant_impl(drop_trait, ty, |impl_did| {\n-            if let Some(item) = self.associated_items(impl_did).next() {\n+            if let Some(item) = self.associated_items(impl_did).in_definition_order().nth(0) {\n                 if validate(self, impl_did).is_ok() {\n                     dtor_did = Some(item.def_id);\n                 }\n@@ -613,7 +615,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::Opaque(def_id, substs) = t.kind {\n                     self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n-                } else if t.has_projections() {\n+                } else if t.has_opaque_types() {\n                     t.super_fold_with(self)\n                 } else {\n                     t\n@@ -695,7 +697,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n     /// actually carry lifetime requirements.\n     pub fn is_sized(&'tcx self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        tcx_at.is_sized_raw(param_env.and(self))\n+        self.is_trivially_sized(tcx_at.tcx) || tcx_at.is_sized_raw(param_env.and(self))\n     }\n \n     /// Checks whether values of this type `T` implement the `Freeze`\n@@ -711,7 +713,43 @@ impl<'tcx> ty::TyS<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         span: Span,\n     ) -> bool {\n-        tcx.at(span).is_freeze_raw(param_env.and(self))\n+        self.is_trivially_freeze() || tcx.at(span).is_freeze_raw(param_env.and(self))\n+    }\n+\n+    /// Fast path helper for testing if a type is `Freeze`.\n+    ///\n+    /// Returning true means the type is known to be `Freeze`. Returning\n+    /// `false` means nothing -- could be `Freeze`, might not be.\n+    fn is_trivially_freeze(&self) -> bool {\n+        match self.kind {\n+            ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Bool\n+            | ty::Char\n+            | ty::Str\n+            | ty::Never\n+            | ty::Ref(..)\n+            | ty::RawPtr(_)\n+            | ty::FnDef(..)\n+            | ty::Error\n+            | ty::FnPtr(_) => true,\n+            ty::Tuple(_) => self.tuple_fields().all(Self::is_trivially_freeze),\n+            ty::Slice(elem_ty) | ty::Array(elem_ty, _) => elem_ty.is_trivially_freeze(),\n+            ty::Adt(..)\n+            | ty::Bound(..)\n+            | ty::Closure(..)\n+            | ty::Dynamic(..)\n+            | ty::Foreign(_)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(_)\n+            | ty::Infer(_)\n+            | ty::Opaque(..)\n+            | ty::Param(_)\n+            | ty::Placeholder(_)\n+            | ty::Projection(_)\n+            | ty::UnnormalizedProjection(_) => false,\n+        }\n     }\n \n     /// If `ty.needs_drop(...)` returns `true`, then `ty` is definitely\n@@ -724,7 +762,23 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// Note that this method is used to check eligible types in unions.\n     #[inline]\n     pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        tcx.needs_drop_raw(param_env.and(self)).0\n+        // Avoid querying in simple cases.\n+        match needs_drop_components(self, &tcx.data_layout) {\n+            Err(AlwaysRequiresDrop) => true,\n+            Ok(components) => {\n+                let query_ty = match *components {\n+                    [] => return false,\n+                    // If we've got a single component, call the query with that\n+                    // to increase the chance that we hit the query cache.\n+                    [component_ty] => component_ty,\n+                    _ => self,\n+                };\n+                // This doesn't depend on regions, so try to minimize distinct\n+                // query keys used.\n+                let erased = tcx.normalize_erasing_regions(param_env, query_ty);\n+                tcx.needs_drop_raw(param_env.and(erased))\n+            }\n+        }\n     }\n \n     pub fn same_type(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n@@ -923,9 +977,6 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-#[derive(Clone, HashStable)]\n-pub struct NeedsDrop(pub bool);\n-\n pub enum ExplicitSelf<'tcx> {\n     ByValue,\n     ByReference(ty::Region<'tcx>, hir::Mutability),\n@@ -974,3 +1025,72 @@ impl<'tcx> ExplicitSelf<'tcx> {\n         }\n     }\n }\n+\n+/// Returns a list of types such that the given type needs drop if and only if\n+/// *any* of the returned types need drop. Returns `Err(AlwaysRequiresDrop)` if\n+/// this type always needs drop.\n+pub fn needs_drop_components(\n+    ty: Ty<'tcx>,\n+    target_layout: &TargetDataLayout,\n+) -> Result<SmallVec<[Ty<'tcx>; 2]>, AlwaysRequiresDrop> {\n+    match ty.kind {\n+        ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Bool\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Never\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Char\n+        | ty::GeneratorWitness(..)\n+        | ty::RawPtr(_)\n+        | ty::Ref(..)\n+        | ty::Str => Ok(SmallVec::new()),\n+\n+        // Foreign types can never have destructors.\n+        ty::Foreign(..) => Ok(SmallVec::new()),\n+\n+        // Pessimistically assume that all generators will require destructors\n+        // as we don't know if a destructor is a noop or not until after the MIR\n+        // state transformation pass.\n+        ty::Generator(..) | ty::Dynamic(..) | ty::Error => Err(AlwaysRequiresDrop),\n+\n+        ty::Slice(ty) => needs_drop_components(ty, target_layout),\n+        ty::Array(elem_ty, size) => {\n+            match needs_drop_components(elem_ty, target_layout) {\n+                Ok(v) if v.is_empty() => Ok(v),\n+                res => match size.val.try_to_bits(target_layout.pointer_size) {\n+                    // Arrays of size zero don't need drop, even if their element\n+                    // type does.\n+                    Some(0) => Ok(SmallVec::new()),\n+                    Some(_) => res,\n+                    // We don't know which of the cases above we are in, so\n+                    // return the whole type and let the caller decide what to\n+                    // do.\n+                    None => Ok(smallvec![ty]),\n+                },\n+            }\n+        }\n+        // If any field needs drop, then the whole tuple does.\n+        ty::Tuple(..) => ty.tuple_fields().try_fold(SmallVec::new(), move |mut acc, elem| {\n+            acc.extend(needs_drop_components(elem, target_layout)?);\n+            Ok(acc)\n+        }),\n+\n+        // These require checking for `Copy` bounds or `Adt` destructors.\n+        ty::Adt(..)\n+        | ty::Projection(..)\n+        | ty::UnnormalizedProjection(..)\n+        | ty::Param(_)\n+        | ty::Bound(..)\n+        | ty::Placeholder(..)\n+        | ty::Opaque(..)\n+        | ty::Infer(_)\n+        | ty::Closure(..) => Ok(smallvec![ty]),\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, HashStable, RustcEncodable, RustcDecodable)]\n+pub struct AlwaysRequiresDrop;"}, {"sha": "e2dd55b4cbac2655286e6e9b6f9b55b6dbb2e2c9", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -106,7 +106,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ref body,\n                 fn_decl_span,\n             ) => {\n-                if let IsAsync::Async { closure_id, .. } = asyncness {\n+                if let Async::Yes { closure_id, .. } = asyncness {\n                     self.lower_expr_async_closure(\n                         capture_clause,\n                         closure_id,\n@@ -480,8 +480,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n     ) -> hir::ExprKind<'hir> {\n         let output = match ret_ty {\n-            Some(ty) => FunctionRetTy::Ty(ty),\n-            None => FunctionRetTy::Default(span),\n+            Some(ty) => FnRetTy::Ty(ty),\n+            None => FnRetTy::Default(span),\n         };\n         let ast_decl = FnDecl { inputs: vec![], output };\n         let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n@@ -721,7 +721,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         fn_decl_span: Span,\n     ) -> hir::ExprKind<'hir> {\n         let outer_decl =\n-            FnDecl { inputs: decl.inputs.clone(), output: FunctionRetTy::Default(fn_decl_span) };\n+            FnDecl { inputs: decl.inputs.clone(), output: FnRetTy::Default(fn_decl_span) };\n         // We need to lower the declaration outside the new scope, because we\n         // have to conserve the state of being inside a loop condition for the\n         // closure argument types.\n@@ -747,7 +747,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             // `|x: u8| future_from_generator(|| -> X { ... })`.\n             let body_id = this.lower_fn_body(&outer_decl, |this| {\n                 let async_ret_ty =\n-                    if let FunctionRetTy::Ty(ty) = &decl.output { Some(ty.clone()) } else { None };\n+                    if let FnRetTy::Ty(ty) = &decl.output { Some(ty.clone()) } else { None };\n                 let async_body = this.make_async_expr(\n                     capture_clause,\n                     closure_id,"}, {"sha": "b5e4fe90d0dce6f2b6e29d4016c5a10caf436c4c", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 106, "deletions": 95, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -66,13 +66,7 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         if let Some(hir_id) = item_hir_id {\n             self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                 let this = &mut ItemLowerer { lctx: this };\n-                if let ItemKind::Impl { constness, ref of_trait, .. } = item.kind {\n-                    if constness == Constness::Const {\n-                        this.lctx\n-                            .diagnostic()\n-                            .span_err(item.span, \"const trait impls are not yet implemented\");\n-                    }\n-\n+                if let ItemKind::Impl { ref of_trait, .. } = item.kind {\n                     this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n                 } else {\n                     visit::walk_item(this, item);\n@@ -179,7 +173,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ids\n             }\n-            ItemKind::Const(ref ty, ..) => {\n+            ItemKind::Const(_, ref ty, ..) => {\n                 let mut ids = smallvec![i.id];\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n                     let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n@@ -267,28 +261,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n-                let ty = self.lower_ty(\n-                    t,\n-                    if self.sess.features_untracked().impl_trait_in_bindings {\n-                        ImplTraitContext::OpaqueTy(None)\n-                    } else {\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                    },\n-                );\n-                hir::ItemKind::Static(ty, m, self.lower_const_body(span, Some(e)))\n+                let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n+                hir::ItemKind::Static(ty, m, body_id)\n             }\n-            ItemKind::Const(ref t, ref e) => {\n-                let ty = self.lower_ty(\n-                    t,\n-                    if self.sess.features_untracked().impl_trait_in_bindings {\n-                        ImplTraitContext::OpaqueTy(None)\n-                    } else {\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                    },\n-                );\n-                hir::ItemKind::Const(ty, self.lower_const_body(span, Some(e)))\n+            ItemKind::Const(_, ref t, ref e) => {\n+                let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n+                hir::ItemKind::Const(ty, body_id)\n             }\n-            ItemKind::Fn(FnSig { ref decl, header }, ref generics, ref body) => {\n+            ItemKind::Fn(_, FnSig { ref decl, header }, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n                 self.with_new_scopes(|this| {\n                     this.current_item = Some(ident.span);\n@@ -297,7 +277,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     // `impl Future<Output = T>` here because lower_body\n                     // only cares about the input argument patterns in the function\n                     // declaration (decl), not the return types.\n-                    let asyncness = header.asyncness.node;\n+                    let asyncness = header.asyncness;\n                     let body_id =\n                         this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n \n@@ -317,22 +297,28 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n             ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n-            ItemKind::TyAlias(ref ty, ref generics) => match ty.kind.opaque_top_hack() {\n+            ItemKind::TyAlias(_, ref gen, _, Some(ref ty)) => match ty.kind.opaque_top_hack() {\n                 None => {\n                     let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                    let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n+                    let generics = self.lower_generics(gen, ImplTraitContext::disallowed());\n                     hir::ItemKind::TyAlias(ty, generics)\n                 }\n                 Some(bounds) => {\n+                    let ctx = || ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc);\n                     let ty = hir::OpaqueTy {\n-                        generics: self.lower_generics(generics, ImplTraitContext::OpaqueTy(None)),\n-                        bounds: self.lower_param_bounds(bounds, ImplTraitContext::OpaqueTy(None)),\n+                        generics: self.lower_generics(gen, ctx()),\n+                        bounds: self.lower_param_bounds(bounds, ctx()),\n                         impl_trait_fn: None,\n                         origin: hir::OpaqueTyOrigin::TypeAlias,\n                     };\n                     hir::ItemKind::OpaqueTy(ty)\n                 }\n             },\n+            ItemKind::TyAlias(_, ref generics, _, None) => {\n+                let ty = self.arena.alloc(self.ty(span, hir::TyKind::Err));\n+                let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n+                hir::ItemKind::TyAlias(ty, generics)\n+            }\n             ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemKind::Enum(\n                 hir::EnumDef {\n                     variants: self.arena.alloc_from_iter(\n@@ -413,10 +399,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     });\n \n                 hir::ItemKind::Impl {\n-                    unsafety,\n+                    unsafety: self.lower_unsafety(unsafety),\n                     polarity,\n                     defaultness: self.lower_defaultness(defaultness, true /* [1] */),\n-                    constness,\n+                    constness: self.lower_constness(constness),\n                     generics,\n                     of_trait: trait_ref,\n                     self_ty: lowered_ty,\n@@ -430,7 +416,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     .alloc_from_iter(items.iter().map(|item| self.lower_trait_item_ref(item)));\n                 hir::ItemKind::Trait(\n                     is_auto,\n-                    unsafety,\n+                    self.lower_unsafety(unsafety),\n                     self.lower_generics(generics, ImplTraitContext::disallowed()),\n                     bounds,\n                     items,\n@@ -449,6 +435,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         //     not cause an assertion failure inside the `lower_defaultness` function.\n     }\n \n+    fn lower_const_item(\n+        &mut self,\n+        ty: &Ty,\n+        span: Span,\n+        body: Option<&Expr>,\n+    ) -> (&'hir hir::Ty<'hir>, hir::BodyId) {\n+        let itctx = if self.sess.features_untracked().impl_trait_in_bindings {\n+            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc)\n+        } else {\n+            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+        };\n+        let ty = self.lower_ty(ty, itctx);\n+        (ty, self.lower_const_body(span, body))\n+    }\n+\n     fn lower_use_tree(\n         &mut self,\n         tree: &UseTree,\n@@ -653,7 +654,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n             kind: match i.kind {\n-                ForeignItemKind::Fn(ref sig, ref generics, _) => {\n+                ForeignItemKind::Fn(_, ref sig, ref generics, _) => {\n                     let fdec = &sig.decl;\n                     let (generics, (fn_dec, fn_args)) = self.add_in_band_defs(\n                         generics,\n@@ -670,11 +671,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n-                ForeignItemKind::Static(ref t, m) => {\n+                ForeignItemKind::Static(ref t, m, _) => {\n                     let ty = self.lower_ty(t, ImplTraitContext::disallowed());\n                     hir::ForeignItemKind::Static(ty, m)\n                 }\n-                ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n+                ForeignItemKind::Const(_, ref t, _) => {\n+                    // For recovery purposes.\n+                    let ty = self.lower_ty(t, ImplTraitContext::disallowed());\n+                    hir::ForeignItemKind::Static(ty, Mutability::Not)\n+                }\n+                ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n                 ForeignItemKind::Macro(_) => panic!(\"macro shouldn't exist here\"),\n             },\n             vis: self.lower_visibility(&i.vis, None),\n@@ -751,32 +757,27 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let trait_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n         let (generics, kind) = match i.kind {\n-            AssocItemKind::Const(ref ty, ref default) => {\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+            AssocItemKind::Static(ref ty, _, ref default) // Let's pretend this is a `const`.\n+            | AssocItemKind::Const(_, ref ty, ref default) => {\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                (\n-                    generics,\n-                    hir::TraitItemKind::Const(\n-                        ty,\n-                        default.as_ref().map(|x| self.lower_const_body(i.span, Some(x))),\n-                    ),\n-                )\n+                let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n+                (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body))\n             }\n-            AssocItemKind::Fn(ref sig, None) => {\n+            AssocItemKind::Fn(_, ref sig, ref generics, None) => {\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) =\n-                    self.lower_method_sig(&i.generics, sig, trait_item_def_id, false, None);\n+                    self.lower_method_sig(generics, sig, trait_item_def_id, false, None);\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n             }\n-            AssocItemKind::Fn(ref sig, Some(ref body)) => {\n+            AssocItemKind::Fn(_, ref sig, ref generics, Some(ref body)) => {\n                 let body_id = self.lower_fn_body_block(i.span, &sig.decl, Some(body));\n                 let (generics, sig) =\n-                    self.lower_method_sig(&i.generics, sig, trait_item_def_id, false, None);\n+                    self.lower_method_sig(generics, sig, trait_item_def_id, false, None);\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n-            AssocItemKind::TyAlias(ref bounds, ref default) => {\n+            AssocItemKind::TyAlias(_, ref generics, ref bounds, ref default) => {\n                 let ty = default.as_ref().map(|x| self.lower_ty(x, ImplTraitContext::disallowed()));\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+                let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n                 let kind = hir::TraitItemKind::Type(\n                     self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n                     ty,\n@@ -798,21 +799,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_trait_item_ref(&mut self, i: &AssocItem) -> hir::TraitItemRef {\n-        let (kind, has_default) = match i.kind {\n-            AssocItemKind::Const(_, ref default) => (hir::AssocItemKind::Const, default.is_some()),\n-            AssocItemKind::TyAlias(_, ref default) => (hir::AssocItemKind::Type, default.is_some()),\n-            AssocItemKind::Fn(ref sig, ref default) => {\n+        let (kind, has_default) = match &i.kind {\n+            AssocItemKind::Static(_, _, default) // Let's pretend this is a `const` for recovery.\n+            | AssocItemKind::Const(_, _, default) => {\n+                (hir::AssocItemKind::Const, default.is_some())\n+            }\n+            AssocItemKind::TyAlias(_, _, _, default) => (hir::AssocItemKind::Type, default.is_some()),\n+            AssocItemKind::Fn(_, sig, _, default) => {\n                 (hir::AssocItemKind::Method { has_self: sig.decl.has_self() }, default.is_some())\n             }\n             AssocItemKind::Macro(..) => unimplemented!(),\n         };\n-        hir::TraitItemRef {\n-            id: hir::TraitItemId { hir_id: self.lower_node_id(i.id) },\n-            ident: i.ident,\n-            span: i.span,\n-            defaultness: self.lower_defaultness(Defaultness::Default, has_default),\n-            kind,\n-        }\n+        let id = hir::TraitItemId { hir_id: self.lower_node_id(i.id) };\n+        let defaultness = hir::Defaultness::Default { has_value: has_default };\n+        hir::TraitItemRef { id, ident: i.ident, span: i.span, defaultness, kind }\n     }\n \n     /// Construct `ExprKind::Err` for the given `span`.\n@@ -823,36 +823,32 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_impl_item(&mut self, i: &AssocItem) -> hir::ImplItem<'hir> {\n         let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n-        let (generics, kind) = match i.kind {\n-            AssocItemKind::Const(ref ty, ref expr) => {\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+        let (generics, kind) = match &i.kind {\n+            AssocItemKind::Static(ty, _, expr) | AssocItemKind::Const(_, ty, expr) => {\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n                 (\n-                    generics,\n+                    hir::Generics::empty(),\n                     hir::ImplItemKind::Const(ty, self.lower_const_body(i.span, expr.as_deref())),\n                 )\n             }\n-            AssocItemKind::Fn(ref sig, ref body) => {\n+            AssocItemKind::Fn(_, sig, generics, body) => {\n                 self.current_item = Some(i.span);\n-                let body_id = self.lower_maybe_async_body(\n-                    i.span,\n-                    &sig.decl,\n-                    sig.header.asyncness.node,\n-                    body.as_deref(),\n-                );\n+                let asyncness = sig.header.asyncness;\n+                let body_id =\n+                    self.lower_maybe_async_body(i.span, &sig.decl, asyncness, body.as_deref());\n                 let impl_trait_return_allow = !self.is_in_trait_impl;\n                 let (generics, sig) = self.lower_method_sig(\n-                    &i.generics,\n+                    generics,\n                     sig,\n                     impl_item_def_id,\n                     impl_trait_return_allow,\n-                    sig.header.asyncness.node.opt_return_id(),\n+                    asyncness.opt_return_id(),\n                 );\n \n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n-            AssocItemKind::TyAlias(_, ref ty) => {\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+            AssocItemKind::TyAlias(_, generics, _, ty) => {\n+                let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n                 let kind = match ty {\n                     None => {\n                         let ty = self.arena.alloc(self.ty(i.span, hir::TyKind::Err));\n@@ -880,7 +876,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             attrs: self.lower_attrs(&i.attrs),\n             generics,\n             vis: self.lower_visibility(&i.vis, None),\n-            defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n+            defaultness: self.lower_defaultness(i.kind.defaultness(), true /* [1] */),\n             kind,\n             span: i.span,\n         }\n@@ -894,16 +890,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ident: i.ident,\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n-            defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n+            defaultness: self.lower_defaultness(i.kind.defaultness(), true /* [1] */),\n             kind: match &i.kind {\n-                AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n-                AssocItemKind::TyAlias(_, ty) => {\n+                AssocItemKind::Static(..) // Let's pretend this is a `const` for recovery.\n+                | AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n+                AssocItemKind::TyAlias(.., ty) => {\n                     match ty.as_deref().and_then(|ty| ty.kind.opaque_top_hack()) {\n                         None => hir::AssocItemKind::Type,\n                         Some(_) => hir::AssocItemKind::OpaqueTy,\n                     }\n                 }\n-                AssocItemKind::Fn(sig, _) => {\n+                AssocItemKind::Fn(_, sig, ..) => {\n                     hir::AssocItemKind::Method { has_self: sig.decl.has_self() }\n                 }\n                 AssocItemKind::Macro(..) => unimplemented!(),\n@@ -947,7 +944,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_defaultness(&self, d: Defaultness, has_value: bool) -> hir::Defaultness {\n         match d {\n-            Defaultness::Default => hir::Defaultness::Default { has_value: has_value },\n+            Defaultness::Default(_) => hir::Defaultness::Default { has_value },\n             Defaultness::Final => {\n                 assert!(has_value);\n                 hir::Defaultness::Final\n@@ -1031,12 +1028,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         span: Span,\n         decl: &FnDecl,\n-        asyncness: IsAsync,\n+        asyncness: Async,\n         body: Option<&Block>,\n     ) -> hir::BodyId {\n         let closure_id = match asyncness {\n-            IsAsync::Async { closure_id, .. } => closure_id,\n-            IsAsync::NotAsync => return self.lower_fn_body_block(span, decl, body),\n+            Async::Yes { closure_id, .. } => closure_id,\n+            Async::No => return self.lower_fn_body_block(span, decl, body),\n         };\n \n         self.lower_body(|this| {\n@@ -1245,9 +1242,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n         hir::FnHeader {\n-            unsafety: h.unsafety,\n-            asyncness: self.lower_asyncness(h.asyncness.node),\n-            constness: h.constness.node,\n+            unsafety: self.lower_unsafety(h.unsafety),\n+            asyncness: self.lower_asyncness(h.asyncness),\n+            constness: self.lower_constness(h.constness),\n             abi: self.lower_extern(h.ext),\n         }\n     }\n@@ -1274,10 +1271,24 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             .emit();\n     }\n \n-    fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n+    fn lower_asyncness(&mut self, a: Async) -> hir::IsAsync {\n         match a {\n-            IsAsync::Async { .. } => hir::IsAsync::Async,\n-            IsAsync::NotAsync => hir::IsAsync::NotAsync,\n+            Async::Yes { .. } => hir::IsAsync::Async,\n+            Async::No => hir::IsAsync::NotAsync,\n+        }\n+    }\n+\n+    fn lower_constness(&mut self, c: Const) -> hir::Constness {\n+        match c {\n+            Const::Yes(_) => hir::Constness::Const,\n+            Const::No => hir::Constness::NotConst,\n+        }\n+    }\n+\n+    pub(super) fn lower_unsafety(&mut self, u: Unsafe) -> hir::Unsafety {\n+        match u {\n+            Unsafe::Yes(_) => hir::Unsafety::Unsafe,\n+            Unsafe::No => hir::Unsafety::Normal,\n         }\n     }\n "}, {"sha": "8bf9311bfc7987db433f1976f942bb8cee153a9d", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -222,7 +222,7 @@ enum ImplTraitContext<'b, 'a> {\n     /// We optionally store a `DefId` for the parent item here so we can look up necessary\n     /// information later. It is `None` when no information about the context should be stored\n     /// (e.g., for consts and statics).\n-    OpaqueTy(Option<DefId> /* fn def-ID */),\n+    OpaqueTy(Option<DefId> /* fn def-ID */, hir::OpaqueTyOrigin),\n \n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n@@ -248,7 +248,7 @@ impl<'a> ImplTraitContext<'_, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params) => Universal(params),\n-            OpaqueTy(fn_def_id) => OpaqueTy(*fn_def_id),\n+            OpaqueTy(fn_def_id, origin) => OpaqueTy(*fn_def_id, *origin),\n             Disallowed(pos) => Disallowed(*pos),\n         }\n     }\n@@ -462,7 +462,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     ItemKind::Struct(_, ref generics)\n                     | ItemKind::Union(_, ref generics)\n                     | ItemKind::Enum(_, ref generics)\n-                    | ItemKind::TyAlias(_, ref generics)\n+                    | ItemKind::TyAlias(_, ref generics, ..)\n                     | ItemKind::Trait(_, _, ref generics, ..) => {\n                         let def_id = self.lctx.resolver.definitions().local_def_id(item.id);\n                         let count = generics\n@@ -490,7 +490,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 self.lctx.allocate_hir_id_counter(item.id);\n                 let owner = match (&item.kind, ctxt) {\n                     // Ignore patterns in trait methods without bodies.\n-                    (AssocItemKind::Fn(_, None), AssocCtxt::Trait) => None,\n+                    (AssocItemKind::Fn(_, _, _, None), AssocCtxt::Trait) => None,\n                     _ => Some(item.id),\n                 };\n                 self.with_hir_id_owner(owner, |this| visit::walk_assoc_item(this, item, ctxt));\n@@ -530,6 +530,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let module = self.lower_mod(&c.module);\n         let attrs = self.lower_attrs(&c.attrs);\n         let body_ids = body_ids(&self.bodies);\n+        let proc_macros = c.proc_macros.iter().map(|id| self.node_id_to_hir_id[*id]).collect();\n \n         self.resolver.definitions().init_node_id_to_hir_id_mapping(self.node_id_to_hir_id);\n \n@@ -546,6 +547,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             body_ids,\n             trait_impls: self.trait_impls,\n             modules: self.modules,\n+            proc_macros,\n         }\n     }\n \n@@ -1010,7 +1012,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo() -> impl Iterator<Item = impl Debug>\n-                    ImplTraitContext::OpaqueTy(_) => (true, itctx),\n+                    ImplTraitContext::OpaqueTy(..) => (true, itctx),\n \n                     // We are in the argument position, but within a dyn type:\n                     //\n@@ -1019,7 +1021,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo(x: dyn Iterator<Item = impl Debug>)\n-                    ImplTraitContext::Universal(_) if self.is_in_dyn_type => (true, itctx),\n+                    ImplTraitContext::Universal(..) if self.is_in_dyn_type => (true, itctx),\n \n                     // In `type Foo = dyn Iterator<Item: Debug>` we desugar to\n                     // `type Foo = dyn Iterator<Item = impl Debug>` but we have to override the\n@@ -1028,7 +1030,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     //\n                     // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n                     ImplTraitContext::Disallowed(_) if self.is_in_dyn_type => {\n-                        (true, ImplTraitContext::OpaqueTy(None))\n+                        (true, ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc))\n                     }\n \n                     // We are in the parameter position, but not within a dyn type:\n@@ -1196,7 +1198,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             &NodeMap::default(),\n                             ImplTraitContext::disallowed(),\n                         ),\n-                        unsafety: f.unsafety,\n+                        unsafety: this.lower_unsafety(f.unsafety),\n                         abi: this.lower_extern(f.ext),\n                         decl: this.lower_fn_decl(&f.decl, None, false, None),\n                         param_names: this.lower_fn_params_to_names(&f.decl),\n@@ -1269,8 +1271,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n                 match itctx {\n-                    ImplTraitContext::OpaqueTy(fn_def_id) => {\n-                        self.lower_opaque_impl_trait(span, fn_def_id, def_node_id, |this| {\n+                    ImplTraitContext::OpaqueTy(fn_def_id, origin) => {\n+                        self.lower_opaque_impl_trait(span, fn_def_id, origin, def_node_id, |this| {\n                             this.lower_param_bounds(bounds, itctx)\n                         })\n                     }\n@@ -1349,6 +1351,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         span: Span,\n         fn_def_id: Option<DefId>,\n+        origin: hir::OpaqueTyOrigin,\n         opaque_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut Self) -> hir::GenericBounds<'hir>,\n     ) -> hir::TyKind<'hir> {\n@@ -1390,7 +1393,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 },\n                 bounds: hir_bounds,\n                 impl_trait_fn: fn_def_id,\n-                origin: hir::OpaqueTyOrigin::FnReturn,\n+                origin,\n             };\n \n             trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_index);\n@@ -1622,7 +1625,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.lower_ty(\n                 t,\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n-                    ImplTraitContext::OpaqueTy(Some(parent_def_id))\n+                    ImplTraitContext::OpaqueTy(Some(parent_def_id), hir::OpaqueTyOrigin::Misc)\n                 } else {\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                 },\n@@ -1722,15 +1725,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             )\n         } else {\n             match decl.output {\n-                FunctionRetTy::Ty(ref ty) => match in_band_ty_params {\n-                    Some((def_id, _)) if impl_trait_return_allow => hir::FunctionRetTy::Return(\n-                        self.lower_ty(ty, ImplTraitContext::OpaqueTy(Some(def_id))),\n-                    ),\n-                    _ => hir::FunctionRetTy::Return(\n-                        self.lower_ty(ty, ImplTraitContext::disallowed()),\n-                    ),\n-                },\n-                FunctionRetTy::Default(span) => hir::FunctionRetTy::DefaultReturn(span),\n+                FnRetTy::Ty(ref ty) => {\n+                    let context = match in_band_ty_params {\n+                        Some((def_id, _)) if impl_trait_return_allow => {\n+                            ImplTraitContext::OpaqueTy(Some(def_id), hir::OpaqueTyOrigin::FnReturn)\n+                        }\n+                        _ => ImplTraitContext::disallowed(),\n+                    };\n+                    hir::FnRetTy::Return(self.lower_ty(ty, context))\n+                }\n+                FnRetTy::Default(span) => hir::FnRetTy::DefaultReturn(span),\n             }\n         };\n \n@@ -1777,10 +1781,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // `elided_lt_replacement`: replacement for elided lifetimes in the return type\n     fn lower_async_fn_ret_ty(\n         &mut self,\n-        output: &FunctionRetTy,\n+        output: &FnRetTy,\n         fn_def_id: DefId,\n         opaque_ty_node_id: NodeId,\n-    ) -> hir::FunctionRetTy<'hir> {\n+    ) -> hir::FnRetTy<'hir> {\n         debug!(\n             \"lower_async_fn_ret_ty(\\\n              output={:?}, \\\n@@ -1945,20 +1949,27 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // only the lifetime parameters that we must supply.\n         let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args);\n         let opaque_ty = self.ty(opaque_ty_span, opaque_ty_ref);\n-        hir::FunctionRetTy::Return(self.arena.alloc(opaque_ty))\n+        hir::FnRetTy::Return(self.arena.alloc(opaque_ty))\n     }\n \n     /// Transforms `-> T` into `Future<Output = T>`\n     fn lower_async_fn_output_type_to_future_bound(\n         &mut self,\n-        output: &FunctionRetTy,\n+        output: &FnRetTy,\n         fn_def_id: DefId,\n         span: Span,\n     ) -> hir::GenericBound<'hir> {\n         // Compute the `T` in `Future<Output = T>` from the return type.\n         let output_ty = match output {\n-            FunctionRetTy::Ty(ty) => self.lower_ty(ty, ImplTraitContext::OpaqueTy(Some(fn_def_id))),\n-            FunctionRetTy::Default(ret_ty_span) => self.arena.alloc(self.ty_tup(*ret_ty_span, &[])),\n+            FnRetTy::Ty(ty) => {\n+                // Not `OpaqueTyOrigin::AsyncFn`: that's only used for the\n+                // `impl Future` opaque type that `async fn` implicitly\n+                // generates.\n+                let context =\n+                    ImplTraitContext::OpaqueTy(Some(fn_def_id), hir::OpaqueTyOrigin::FnReturn);\n+                self.lower_ty(ty, context)\n+            }\n+            FnRetTy::Default(ret_ty_span) => self.arena.alloc(self.ty_tup(*ret_ty_span, &[])),\n         };\n \n         // \"<Output = T>\"\n@@ -2102,9 +2113,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n \n                 let kind = hir::GenericParamKind::Type {\n-                    default: default\n-                        .as_ref()\n-                        .map(|x| self.lower_ty(x, ImplTraitContext::OpaqueTy(None))),\n+                    default: default.as_ref().map(|x| {\n+                        self.lower_ty(\n+                            x,\n+                            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc),\n+                        )\n+                    }),\n                     synthetic: param\n                         .attrs\n                         .iter()"}, {"sha": "b42b12c4dd8513a1e610f314a1d5b3eea13b58a4", "filename": "src/librustc_ast_lowering/pat.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -128,6 +128,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut slice = None;\n         let mut prev_rest_span = None;\n \n+        // Lowers `$bm $ident @ ..` to `$bm $ident @ _`.\n+        let lower_rest_sub = |this: &mut Self, pat, bm, ident, sub| {\n+            let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n+            let node = this.lower_pat_ident(pat, bm, ident, lower_sub);\n+            this.pat_with_node_id_of(pat, node)\n+        };\n+\n         let mut iter = pats.iter();\n         // Lower all the patterns until the first occurrence of a sub-slice pattern.\n         for pat in iter.by_ref() {\n@@ -142,9 +149,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n                 PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n                     prev_rest_span = Some(sub.span);\n-                    let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n-                    let node = self.lower_pat_ident(pat, bm, ident, lower_sub);\n-                    slice = Some(self.pat_with_node_id_of(pat, node));\n+                    slice = Some(lower_rest_sub(self, pat, bm, ident, sub));\n                     break;\n                 }\n                 // It was not a subslice pattern so lower it normally.\n@@ -157,9 +162,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // There was a previous subslice pattern; make sure we don't allow more.\n             let rest_span = match pat.kind {\n                 PatKind::Rest => Some(pat.span),\n-                PatKind::Ident(.., Some(ref sub)) if sub.is_rest() => {\n-                    // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n-                    after.push(self.pat_wild_with_node_id_of(pat));\n+                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                    // #69103: Lower into `binding @ _` as above to avoid ICEs.\n+                    after.push(lower_rest_sub(self, pat, bm, ident, sub));\n                     Some(sub.span)\n                 }\n                 _ => None,"}, {"sha": "b45a06e1c1d2a490c670a9f65109dc7b6004a269", "filename": "src/librustc_ast_lowering/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_lowering%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_lowering%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpath.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "patch": "@@ -397,8 +397,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 inputs.iter().map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed())),\n             );\n             let output_ty = match output {\n-                FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n-                FunctionRetTy::Default(_) => this.arena.alloc(this.ty_tup(span, &[])),\n+                FnRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n+                FnRetTy::Default(_) => this.arena.alloc(this.ty_tup(span, &[])),\n             };\n             let args = smallvec![GenericArg::Type(this.ty_tup(span, inputs))];\n             let binding = this.output_ty_binding(output_ty.span, output_ty);"}, {"sha": "44fed6dee6628f58d299eb71b16f0862df3b8b6b", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "33ff0bc451b3256174c8fee2d5058dde53161fd1", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "3431c1b8e9d4201eacc0e9bcf7df27cfe2f03bb5", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 109, "deletions": 184, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "4531c7392a9d5e6c30794818ca287b7013bb9622", "filename": "src/librustc_ast_pretty/pprust/tests.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_pretty%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_ast_pretty%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust%2Ftests.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "ac1a191fa230134e5d780f77280bc7a2cf3efdcd", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "00ed05608b50be317036ec2294411468288b8e96", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "63cd03527e15cb1569fe668bea45247cc17297ca", "filename": "src/librustc_builtin_macros/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "5a0b1a6b88542c424b7a95ee4713d5ff144276e4", "filename": "src/librustc_builtin_macros/global_allocator.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "b925cad9fdcdc361132e6ce658a15a18da578a32", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 43, "deletions": 18, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "8407352f57714057fa3e45cbc911156734e461e8", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 89, "deletions": 80, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "4bbab0d257489b7e1a9bd288f5a9d2e22a9a56f1", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "c5e862ffc179fa6e82fb8f616a70490a7039565d", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "d7297ed41769c20dc3ad001cbf23e9884494bb3e", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 46, "deletions": 25, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "d56ddac699b09eebed19433ea07c35b15b3fda6c", "filename": "src/librustc_codegen_llvm/back/profiling.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fback%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fback%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fprofiling.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "a215ef81bc9ebe7bc27c220e1bcfc29e1682061f", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 163, "deletions": 50, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "ab6c55becdb0249acc3c03d8dd15228278cff994", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "09a84aff16811a80f14db9fd288fcbdfadee73ac", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "46f461b98c8de0ee7207a78769002305c64978da", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "cdb9657e1ff3c3b294b1a57068e3ebc59f8ab86b", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "22effb102fd67d18815cbae542448ffd7e6a1b22", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "1f871c7d207a41acc5dd160c9f9086f45b7bddcd", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 23, "deletions": 67, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "3d1e72e1c73d735c1b00faa32e5d855b22f70965", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "b1085ba1703301628340d2fab55127ff5e32cab4", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "808094eca91d5583fb2c0d234ca85527a8e8b415", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 66, "deletions": 3, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "96014cbee5da1cdc0b288b14b756dfcfaa64a4a3", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "0f30c2c020de75a225356a567d6d1be386435ffc", "filename": "src/librustc_codegen_llvm/metadata.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_llvm%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmetadata.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "78aacc56ea42e02927c7748384569eff36b83eee", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "92f795acc543805912c670656eb2e9239289190d", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "e9431d94863ef96a4eb87ff4ec1520cfccfa77cd", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "ea2af6e192e7c1d0c927393717dcab497c453240", "filename": "src/librustc_codegen_ssa/build.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbuild.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "a2bb39b9e401935d222c16bd79d66ba8bce67777", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "7bf222f4701b7ea70a8d1a52b44b929df7a7782b", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "a1b54607b809e02b855482dfb854834ac0160150", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "4248627dccaf23533f896c68a3d96bf55354e03d", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "e5f21013ce3e32a487c0edd88bafab024c6f65c3", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "64ead19b358697501b8a57fd22b59dcba72eec58", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "07c8829e7d88352bb6edf0ce4c9e6075d7e0cb58", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "3688ae51b391819979ff3350cd66c8855a212e06", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "38906bbaef8104f07fcf152e030ec1bc690ad9b8", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "13792a0c890c4bc8e6587b429d353f98cc38ff23", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "67fbe3058cdb981170ce653c9d22c0695f8f753c", "filename": "src/librustc_data_structures/macros.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fmacros.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "e1784f44fd112a01961703c0ee8477e24a32247a", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "6711a49b2b7c1df00a8f6b74c4ebe595d8f8c71a", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "01652465eea2cc7a554134354ab6b29b0fdd7d82", "filename": "src/librustc_data_structures/obligation_forest/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "f2c80510f226945413530eef779359c3b5e0f577", "filename": "src/librustc_data_structures/profiling.rs", "status": "modified", "additions": 90, "deletions": 37, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fprofiling.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "15d1e2dd0b644c08086e60a9c8b82586fda0589d", "filename": "src/librustc_data_structures/sharded.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsharded.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "af0e9f79fe1201cf8c9e554e576f9cf722c791eb", "filename": "src/librustc_data_structures/sip128.rs", "status": "modified", "additions": 79, "deletions": 44, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "8c42b74b85aef4f0c35a45936ae639c785f52d7d", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "b7005ccdc998be72cb0276c20d2de5917e211a7d", "filename": "src/librustc_data_structures/sorted_map/index_map.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fsorted_map%2Findex_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fsorted_map%2Findex_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map%2Findex_map.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "7d91e1fdcef6a3f1db929218752e9a8cfa316416", "filename": "src/librustc_data_structures/sorted_map/tests.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fsorted_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fsorted_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map%2Ftests.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "a98e77cebd88aaa2249c170e5084895caf7aa4fd", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "5b185f9a8b6b9bee7c67054866971f48afa93583", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "f68ea7e0770324bb9fb3fc2c4e4c94769b43f723", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "236a7243998f6a0ee0dd6f11250a9ffd6b41a344", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "ba43b29538d50dcd85b5f42ed14ed637251adb9d", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "7b1bbde614094b4eed97e47003ada1c9a12024f1", "filename": "src/librustc_error_codes/error_codes/E0080.md", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "1adbcc3135632991eead1c4d821af0353a97e168", "filename": "src/librustc_error_codes/error_codes/E0133.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0133.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0133.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0133.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "e437a71897c661239dd069640eb907612fcb167c", "filename": "src/librustc_error_codes/error_codes/E0154.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0154.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0154.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0154.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "b8bdb81fcbf6d13ecbeadb83b703ae4525a9ff9a", "filename": "src/librustc_error_codes/error_codes/E0260.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0260.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0260.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0260.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "2d12fcea4cafca3366336948577b66227abc9c6a", "filename": "src/librustc_error_codes/error_codes/E0275.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0275.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0275.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0275.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "2e2cd5e01fb6a6cface9126163080c8748676708", "filename": "src/librustc_error_codes/error_codes/E0277.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0277.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0277.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0277.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "49d2205f92c2a52dbb255a165c3a9bc8f8894495", "filename": "src/librustc_error_codes/error_codes/E0282.md", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0282.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0282.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0282.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "6885f9a486d3d673b68c83320b590e72d7305fc8", "filename": "src/librustc_error_codes/error_codes/E0283.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0283.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0283.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0283.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "459906047cc87c6629a7aabd567c6660e0d926d4", "filename": "src/librustc_error_codes/error_codes/E0303.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0303.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0303.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0303.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "52707b93acc8674a546fd9e73dc83706027302b1", "filename": "src/librustc_error_codes/error_codes/E0307.md", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "e719ee590aba67a0aabe8e92775f2643084567de", "filename": "src/librustc_error_codes/error_codes/E0309.md", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0309.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0309.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0309.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "8d4311d018b210296a1c4c6308c31ccf90acc389", "filename": "src/librustc_error_codes/error_codes/E0310.md", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0310.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0310.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0310.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "230911c208628fcd79616a094481721f61d54aee", "filename": "src/librustc_error_codes/error_codes/E0317.md", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0317.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0317.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0317.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "bfcdabfe9de7a8b131e74d9eb848deee607521c4", "filename": "src/librustc_error_codes/error_codes/E0321.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0321.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0321.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0321.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "ccef8681dd6018a928af5afbc0e382f9be3ec1df", "filename": "src/librustc_error_codes/error_codes/E0322.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0322.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0322.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0322.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "0bf42d17ebcf4e16874c12a3ef25d52cdbf341ae", "filename": "src/librustc_error_codes/error_codes/E0323.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0323.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0323.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0323.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "1442cb77dd977c67aee759bd84149b9efe678696", "filename": "src/librustc_error_codes/error_codes/E0324.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0324.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0324.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0324.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "656fd1ec82b56d8e31637d92adfde31ff3cbd88b", "filename": "src/librustc_error_codes/error_codes/E0325.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0325.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0325.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0325.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "3d357819c7f91ca9418f3c0b8aec50a688e341f8", "filename": "src/librustc_error_codes/error_codes/E0326.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0326.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0326.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0326.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "ec1fb911f3cc2d30b5565ab7f7183bcf21e4b4ec", "filename": "src/librustc_error_codes/error_codes/E0364.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "e3d417a7d018760770926f50bcba1b2d2d839a3a", "filename": "src/librustc_error_codes/error_codes/E0365.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0365.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0365.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0365.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "cfebeada272148dc1eda060bb879d09b9b6726d7", "filename": "src/librustc_error_codes/error_codes/E0367.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0367.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0367.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0367.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "7b9d93348213120a555931a5139a7c235c393338", "filename": "src/librustc_error_codes/error_codes/E0368.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0368.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0368.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0368.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "ab0f4b40843c1ce0a31a39df492586f03288dcc3", "filename": "src/librustc_error_codes/error_codes/E0369.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0369.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0369.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0369.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "14e954722a2501c34ef182a978eb35f78b8346e8", "filename": "src/librustc_error_codes/error_codes/E0370.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0370.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0370.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0370.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "a44721346e20dc8377bd7a2d612c4e46b3617779", "filename": "src/librustc_error_codes/error_codes/E0371.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0371.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0371.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0371.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "f2356583cce1ce820bf13b780a58548179a4be0c", "filename": "src/librustc_error_codes/error_codes/E0382.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0382.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0382.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0382.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "38ad19bd6aa9a37c7b6030e2524a4975fd8402ed", "filename": "src/librustc_error_codes/error_codes/E0387.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0387.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0387.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0387.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "6ea6054b417799c6f2194148e8d2c3dbad7df011", "filename": "src/librustc_error_codes/error_codes/E0399.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0399.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0399.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0399.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "2f80c34b88971be448bd20a4947c471c95667248", "filename": "src/librustc_error_codes/error_codes/E0455.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0455.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0455.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0455.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "a07e8eb3b3817fc113d600a5f6bc872cc150bca7", "filename": "src/librustc_error_codes/error_codes/E0499.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0499.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0499.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0499.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "f5aa17a809467cb171f6060c0a266aa44f79d261", "filename": "src/librustc_error_codes/error_codes/E0501.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0501.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0501.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0501.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "f15c05d558d85b5b253bb708916fd0bd2f835349", "filename": "src/librustc_error_codes/error_codes/E0502.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "c52525fee543a4377655ced9fc265cc803d58c51", "filename": "src/librustc_error_codes/error_codes/E0503.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0503.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0503.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0503.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "b11e3c0e947eea5540e1806d4a2ec9b0a253c30b", "filename": "src/librustc_error_codes/error_codes/E0505.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0505.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0505.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0505.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "1e3457e96c5f87954db3af7b3f543a04d657cd0a", "filename": "src/librustc_error_codes/error_codes/E0507.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0507.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0507.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0507.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "a769440ca1bd41ada738469afe1dfe4e34758eff", "filename": "src/librustc_error_codes/error_codes/E0525.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0525.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0525.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0525.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "1ca9411b8d4c20f693844277e324bdfe2e3e9e03", "filename": "src/librustc_error_codes/error_codes/E0534.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0534.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0534.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0534.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "0cf3118b02c5c82b00aa14568b955882965bb557", "filename": "src/librustc_error_codes/error_codes/E0535.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0535.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0535.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0535.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "c081a3d9cfa87e5b2b54eccaa862388e4026aebe", "filename": "src/librustc_error_codes/error_codes/E0536.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0536.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0536.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0536.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "123efd4f57df364256145ffdb74e707b9541d139", "filename": "src/librustc_error_codes/error_codes/E0537.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0537.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0537.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0537.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "8180c5db46fba083a11d52abe8ac052d16cdc162", "filename": "src/librustc_error_codes/error_codes/E0601.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0601.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0601.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0601.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "c737bd618c302563013d2da641a10250a953ef5b", "filename": "src/librustc_error_codes/error_codes/E0610.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0610.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0610.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0610.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "e114d3d0f94aec5ee38a3258779d7a38dc409bdd", "filename": "src/librustc_error_codes/error_codes/E0637.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0637.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0637.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0637.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "189459175dca223aa9df260a113fbb69379f29b1", "filename": "src/librustc_error_codes/error_codes/E0660.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0660.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0660.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0660.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "b171ada620516b0cb43fa19298ecd89d8d30f8bb", "filename": "src/librustc_error_codes/error_codes/E0661.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0661.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0661.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0661.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "c15e736610b5e92044efb54d0d06ea310ecf7680", "filename": "src/librustc_error_codes/error_codes/E0662.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0662.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0662.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0662.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "bd450230ec3f26ea2c359cf6a0e05ab7ccb246e1", "filename": "src/librustc_error_codes/error_codes/E0663.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0663.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0663.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0663.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "768ffdf2de93bf471df70a3efcb43cb4365fc3fa", "filename": "src/librustc_error_codes/error_codes/E0664.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0664.md", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_error_codes%2Ferror_codes%2FE0664.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0664.md?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "189b5bd0f9e87e576f7a7f490e972dd8c55b8fe1", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "39f585231eea433c5e737871dae38c0e331001a8", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "1f6e268b5065fc157b9eea0a25088661924086e5", "filename": "src/librustc_errors/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_errors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_errors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fjson.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "1a0fe3435213000aa14b28b55f426860b6b5a245", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "a5614f900b6fb142cae7ca5d85da01ba105ad0b6", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "bd6823cd4e275f586dbe26e39c00aadca1541c51", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "8ed7bbf6e1276eb78dc26df6453c4935cbf075e8", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 92, "deletions": 77, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "f119c956ced04e078bef2d823b97041276eb4f71", "filename": "src/librustc_expand/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "10cdceefdf5798d195f096b67d893478d3d3b913", "filename": "src/librustc_expand/mbe/macro_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "6599e92222c75da0e453862eec407fdfd686e212", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "52e581e30f5378d403fb225ebe8c6ae87215427b", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "4713c8dcd9a3b3e159f3040a8593cc4851848cd4", "filename": "src/librustc_expand/parse/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fparse%2Ftests.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "c323af4336a4ce498a3212077d93327a307b30e2", "filename": "src/librustc_expand/placeholders.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_expand%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fplaceholders.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "0082f4f1a6e8985e647b7797c71120d1e96cee95", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "91658db1a7a3d5b49a4804dc0b8c3b1e8a185460", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "cff6413253202dde7ea183f829048b5dc9033b19", "filename": "src/librustc_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2FCargo.toml?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "6d2f5ba6baf14d74079485a80059f06560f65fae", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 86, "deletions": 29, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "f574449c6b954756e56a4e8f06a06e62c747983f", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "cb5ebba463394c08353fdf1699da288c915f1b88", "filename": "src/librustc_hir/lang_items.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "d958dfc681b00fe0703c2770dbf5ef78807a3033", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "3fde04c294ef25a681699372d689c43340b43dcc", "filename": "src/librustc_hir/print.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fprint.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "e8407b537011bf64655ce230cca5c6161150749c", "filename": "src/librustc_hir/stable_hash_impls.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fstable_hash_impls.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "501976fc3cb39cb020f9bbb49c5c343309abaf8e", "filename": "src/librustc_hir/target.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Ftarget.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "previous_filename": "src/librustc/hir/check_attr.rs"}, {"sha": "79182caae8c80e2c6346950924f5edad3855b88a", "filename": "src/librustc_hir/weak_lang_items.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_hir%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fweak_lang_items.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "ca824fde7efc1156eefba0a1170a6329c3fdaa5a", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "1fa57f1ecf26da6a3346f854fb40ec251df941be", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "53970a4aaf3151a1c040e3eafc1b9770ed519283", "filename": "src/librustc_infer/Cargo.toml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2FCargo.toml?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25"}, {"sha": "156b5a8b0b50bd593e4c581c3b6175b206d1f4ee", "filename": "src/librustc_infer/infer/at.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fat.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "previous_filename": "src/librustc/infer/at.rs"}, {"sha": "ecd7281351def8766ce1b15f381baae547270667", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "renamed", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "previous_filename": "src/librustc/infer/canonical/canonicalizer.rs"}, {"sha": "ba019a8cf0369a67e49b4c8de12559bde2193af3", "filename": "src/librustc_infer/infer/canonical/mod.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "previous_filename": "src/librustc/infer/canonical/mod.rs"}, {"sha": "f4196e576054af9fc2224d71d5abb8db8d040746", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "previous_filename": "src/librustc/infer/canonical/query_response.rs"}, {"sha": "99ddedfe8815ba50941c10fb3da78b4e6822835f", "filename": "src/librustc_infer/infer/canonical/substitute.rs", "status": "renamed", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "previous_filename": "src/librustc/infer/canonical/substitute.rs"}, {"sha": "a10af56a0f0a8d02eebf5386d548bb54f022a5e1", "filename": "src/librustc_infer/infer/combine.rs", "status": "renamed", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "previous_filename": "src/librustc/infer/combine.rs"}, {"sha": "c1eec6832b82663593cedf1f8628979de07ebb57", "filename": "src/librustc_infer/infer/equate.rs", "status": "renamed", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fequate.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "previous_filename": "src/librustc/infer/equate.rs"}, {"sha": "008658dff425ba3c8591ebbad4b4e40eb65b1a78", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "renamed", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "previous_filename": "src/librustc/infer/error_reporting/mod.rs"}, {"sha": "a1e6a0a325ada94a6467dcbb4f7e6b7ffe8d4982", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "renamed", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "previous_filename": "src/librustc/infer/error_reporting/need_type_info.rs"}, {"sha": "1a09729ef6443dde38b1e979c93e79004a01f0c4", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/526280a853f31bbc3120334dfe46e19ea4dbaa25/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=526280a853f31bbc3120334dfe46e19ea4dbaa25", "previous_filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs"}]}