{"sha": "eceec57f72150dd548e05025a05a93381da41385", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZWVjNTdmNzIxNTBkZDU0OGUwNTAyNWEwNWE5MzM4MWRhNDEzODU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-18T17:58:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-18T17:58:45Z"}, "message": "Auto merge of #64583 - tmandry:rollup-b793x81, r=tmandry\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #64207 (Make rustc_mir::dataflow module pub (for clippy))\n - #64348 (PR: documentation spin loop hint)\n - #64532 (Replace `state_for_location` with `DataflowResultsCursor`)\n - #64578 (Fix issue22656 with LLDB 8)\n - #64580 (Update books)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "9832a491c02ecb91f2a7439faa7678c3969c8d5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9832a491c02ecb91f2a7439faa7678c3969c8d5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eceec57f72150dd548e05025a05a93381da41385", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eceec57f72150dd548e05025a05a93381da41385", "html_url": "https://github.com/rust-lang/rust/commit/eceec57f72150dd548e05025a05a93381da41385", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eceec57f72150dd548e05025a05a93381da41385/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dece57302a8e6775b34dd6447eb98552e83bdc9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dece57302a8e6775b34dd6447eb98552e83bdc9d", "html_url": "https://github.com/rust-lang/rust/commit/dece57302a8e6775b34dd6447eb98552e83bdc9d"}, {"sha": "eeda31385df59b17d997d65e73e4ad474f27b96a", "url": "https://api.github.com/repos/rust-lang/rust/commits/eeda31385df59b17d997d65e73e4ad474f27b96a", "html_url": "https://github.com/rust-lang/rust/commit/eeda31385df59b17d997d65e73e4ad474f27b96a"}], "stats": {"total": 140, "additions": 50, "deletions": 90}, "files": [{"sha": "871416b85c1a73717d65d6f4a9ea29e5aef3db0e", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=eceec57f72150dd548e05025a05a93381da41385", "patch": "@@ -1 +1 @@\n-Subproject commit 7ddc46460f09a5cd9bd2a620565bdc20b3315ea9\n+Subproject commit 871416b85c1a73717d65d6f4a9ea29e5aef3db0e"}, {"sha": "67cfbf31df880728dcf7cb35b15b028ec92caf31", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=eceec57f72150dd548e05025a05a93381da41385", "patch": "@@ -1 +1 @@\n-Subproject commit e76be6b2dc84c6a992e186157efe29d625e29b94\n+Subproject commit 67cfbf31df880728dcf7cb35b15b028ec92caf31"}, {"sha": "ee4be6c9151194b0e7a58e32b8be797e188bd933", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eceec57f72150dd548e05025a05a93381da41385/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eceec57f72150dd548e05025a05a93381da41385/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=eceec57f72150dd548e05025a05a93381da41385", "patch": "@@ -49,28 +49,16 @@ pub unsafe fn unreachable_unchecked() -> ! {\n     intrinsics::unreachable()\n }\n \n-/// Signals the processor that it is entering a busy-wait spin-loop.\n+/// Emits a machine instruction hinting to the processor that it is running in busy-wait\n+/// spin-loop (\"spin lock\").\n ///\n-/// Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving\n-/// power or switching hyper-threads.\n-///\n-/// This function is different than [`std::thread::yield_now`] which directly yields to the\n-/// system's scheduler, whereas `spin_loop` only signals the processor that it is entering a\n-/// busy-wait spin-loop without yielding control to the system's scheduler.\n-///\n-/// Using a busy-wait spin-loop with `spin_loop` is ideally used in situations where a\n-/// contended lock is held by another thread executed on a different CPU and where the waiting\n-/// times are relatively small. Because entering busy-wait spin-loop does not trigger the system's\n-/// scheduler, no overhead for switching threads occurs. However, if the thread holding the\n-/// contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice\n-/// before switching to the thread that holds the lock. If the contending lock is held by a thread\n-/// on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to\n-/// use [`std::thread::yield_now`].\n+/// For a discussion of different locking strategies and their trade-offs, see\n+/// [`core::sync::atomic::spin_loop_hint`].\n ///\n /// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n /// do anything at all.\n ///\n-/// [`std::thread::yield_now`]: ../../std/thread/fn.yield_now.html\n+/// [`core::sync::atomic::spin_loop_hint`]: ../sync/atomic/fn.spin_loop_hint.html\n #[inline]\n #[unstable(feature = \"renamed_spin_loop\", issue = \"55002\")]\n pub fn spin_loop() {"}, {"sha": "c9ccef972c2b5faabdabf7f55a79c4378d180a9e", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eceec57f72150dd548e05025a05a93381da41385/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eceec57f72150dd548e05025a05a93381da41385/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=eceec57f72150dd548e05025a05a93381da41385", "patch": "@@ -124,28 +124,31 @@ use crate::fmt;\n \n use crate::hint::spin_loop;\n \n-/// Signals the processor that it is entering a busy-wait spin-loop.\n+/// Signals the processor that it is inside a busy-wait spin-loop (\"spin lock\").\n ///\n /// Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving\n /// power or switching hyper-threads.\n ///\n-/// This function is different than [`std::thread::yield_now`] which directly yields to the\n-/// system's scheduler, whereas `spin_loop_hint` only signals the processor that it is entering a\n-/// busy-wait spin-loop without yielding control to the system's scheduler.\n+/// This function is different from [`std::thread::yield_now`] which directly yields to the\n+/// system's scheduler, whereas `spin_loop_hint` does not interact with the operating system.\n ///\n-/// Using a busy-wait spin-loop with `spin_loop_hint` is ideally used in situations where a\n-/// contended lock is held by another thread executed on a different CPU and where the waiting\n-/// times are relatively small. Because entering busy-wait spin-loop does not trigger the system's\n-/// scheduler, no overhead for switching threads occurs. However, if the thread holding the\n-/// contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice\n-/// before switching to the thread that holds the lock. If the contending lock is held by a thread\n-/// on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to\n-/// use [`std::thread::yield_now`].\n+/// Spin locks can be very efficient for short lock durations because they do not involve context\n+/// switches or interaction with the operating system. For long lock durations they become wasteful\n+/// however because they use CPU cycles for the entire lock duration, and using a\n+/// [`std::sync::Mutex`] is likely the better approach. If actively spinning for a long time is\n+/// required, e.g. because code polls a non-blocking API, calling [`std::thread::yield_now`]\n+/// or [`std::thread::sleep`] may be the best option.\n+///\n+/// **Note**: Spin locks are based on the underlying assumption that another thread will release\n+/// the lock 'soon'. In order for this to work, that other thread must run on a different CPU or\n+/// core (at least potentially). Spin locks do not work efficiently on single CPU / core platforms.\n ///\n /// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n /// do anything at all.\n ///\n /// [`std::thread::yield_now`]: ../../../std/thread/fn.yield_now.html\n+/// [`std::thread::sleep`]: ../../../std/thread/fn.sleep.html\n+/// [`std::sync::Mutex`]: ../../../std/sync/struct.Mutex.html\n #[inline]\n #[stable(feature = \"spin_loop_hint\", since = \"1.24.0\")]\n pub fn spin_loop_hint() {"}, {"sha": "319abbbe7b64347ce01c1187c186fb7a106ef4a5", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/eceec57f72150dd548e05025a05a93381da41385/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eceec57f72150dd548e05025a05a93381da41385/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=eceec57f72150dd548e05025a05a93381da41385", "patch": "@@ -56,7 +56,7 @@ where\n /// string (as well as that of rendering up-front); in exchange, you\n /// don't have to hand over ownership of your value or deal with\n /// borrowing it.\n-pub(crate) struct DebugFormatted(String);\n+pub struct DebugFormatted(String);\n \n impl DebugFormatted {\n     pub fn new(input: &dyn fmt::Debug) -> DebugFormatted {\n@@ -70,7 +70,7 @@ impl fmt::Debug for DebugFormatted {\n     }\n }\n \n-pub(crate) trait Dataflow<'tcx, BD: BitDenotation<'tcx>> {\n+pub trait Dataflow<'tcx, BD: BitDenotation<'tcx>> {\n     /// Sets up and runs the dataflow problem, using `p` to render results if\n     /// implementation so chooses.\n     fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> DebugFormatted {\n@@ -121,7 +121,7 @@ pub struct MoveDataParamEnv<'tcx> {\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n }\n \n-pub(crate) fn do_dataflow<'a, 'tcx, BD, P>(\n+pub fn do_dataflow<'a, 'tcx, BD, P>(\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     def_id: DefId,\n@@ -453,34 +453,10 @@ where\n     {\n         self.flow_state.each_gen_bit(f)\n     }\n-}\n-\n-pub fn state_for_location<'tcx, T: BitDenotation<'tcx>>(loc: Location,\n-                                                        analysis: &T,\n-                                                        result: &DataflowResults<'tcx, T>,\n-                                                        body: &Body<'tcx>)\n-    -> BitSet<T::Idx> {\n-    let mut trans = GenKill::from_elem(HybridBitSet::new_empty(analysis.bits_per_block()));\n \n-    for stmt in 0..loc.statement_index {\n-        let mut stmt_loc = loc;\n-        stmt_loc.statement_index = stmt;\n-        analysis.before_statement_effect(&mut trans, stmt_loc);\n-        analysis.statement_effect(&mut trans, stmt_loc);\n+    pub fn get(&self) -> &BitSet<BD::Idx> {\n+        self.flow_state.as_dense()\n     }\n-\n-    // Apply the pre-statement effect of the statement we're evaluating.\n-    if loc.statement_index == body[loc.block].statements.len() {\n-        analysis.before_terminator_effect(&mut trans, loc);\n-    } else {\n-        analysis.before_statement_effect(&mut trans, loc);\n-    }\n-\n-    // Apply the transfer function for all preceding statements to the fixpoint\n-    // at the start of the block.\n-    let mut state = result.sets().entry_set_for(loc.block.index()).to_owned();\n-    trans.apply(&mut state);\n-    state\n }\n \n pub struct DataflowAnalysis<'a, 'tcx, O>\n@@ -565,7 +541,7 @@ pub struct GenKill<T> {\n     pub(crate) kill_set: T,\n }\n \n-type GenKillSet<T> = GenKill<HybridBitSet<T>>;\n+pub type GenKillSet<T> = GenKill<HybridBitSet<T>>;\n \n impl<T> GenKill<T> {\n     /// Creates a new tuple where `gen_set == kill_set == elem`.\n@@ -580,28 +556,28 @@ impl<T> GenKill<T> {\n }\n \n impl<E:Idx> GenKillSet<E> {\n-    pub(crate) fn clear(&mut self) {\n+    pub fn clear(&mut self) {\n         self.gen_set.clear();\n         self.kill_set.clear();\n     }\n \n-    fn gen(&mut self, e: E) {\n+    pub fn gen(&mut self, e: E) {\n         self.gen_set.insert(e);\n         self.kill_set.remove(e);\n     }\n \n-    fn gen_all(&mut self, i: impl IntoIterator<Item: Borrow<E>>) {\n+    pub fn gen_all(&mut self, i: impl IntoIterator<Item: Borrow<E>>) {\n         for j in i {\n             self.gen(*j.borrow());\n         }\n     }\n \n-    fn kill(&mut self, e: E) {\n+    pub fn kill(&mut self, e: E) {\n         self.gen_set.remove(e);\n         self.kill_set.insert(e);\n     }\n \n-    fn kill_all(&mut self, i: impl IntoIterator<Item: Borrow<E>>) {\n+    pub fn kill_all(&mut self, i: impl IntoIterator<Item: Borrow<E>>) {\n         for j in i {\n             self.kill(*j.borrow());\n         }"}, {"sha": "6a49ed6ed9fa1672339075d093d81685fc58ca4e", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eceec57f72150dd548e05025a05a93381da41385/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eceec57f72150dd548e05025a05a93381da41385/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=eceec57f72150dd548e05025a05a93381da41385", "patch": "@@ -35,7 +35,7 @@ pub mod error_codes;\n \n mod borrow_check;\n mod build;\n-mod dataflow;\n+pub mod dataflow;\n mod hair;\n mod lints;\n mod shim;"}, {"sha": "caf588af851dd3a4fed82162e5e2a090484d3256", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/eceec57f72150dd548e05025a05a93381da41385/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eceec57f72150dd548e05025a05a93381da41385/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=eceec57f72150dd548e05025a05a93381da41385", "patch": "@@ -67,7 +67,7 @@ use crate::transform::{MirPass, MirSource};\n use crate::transform::simplify;\n use crate::transform::no_landing_pads::no_landing_pads;\n use crate::dataflow::{DataflowResults, DataflowResultsConsumer, FlowAtLocation};\n-use crate::dataflow::{do_dataflow, DebugFormatted, state_for_location};\n+use crate::dataflow::{do_dataflow, DebugFormatted, DataflowResultsCursor};\n use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals, RequiresStorage};\n use crate::util::dump_mir;\n use crate::util::liveness;\n@@ -436,9 +436,10 @@ fn locals_live_across_suspend_points(\n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n     let storage_live_analysis = MaybeStorageLive::new(body);\n-    let storage_live =\n+    let storage_live_results =\n         do_dataflow(tcx, body, def_id, &[], &dead_unwinds, storage_live_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n+    let mut storage_live_cursor = DataflowResultsCursor::new(&storage_live_results, body);\n \n     // Find the MIR locals which do not use StorageLive/StorageDead statements.\n     // The storage of these locals are always live.\n@@ -448,17 +449,18 @@ fn locals_live_across_suspend_points(\n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n     let borrowed_locals_analysis = HaveBeenBorrowedLocals::new(body);\n-    let borrowed_locals_result =\n+    let borrowed_locals_results =\n         do_dataflow(tcx, body, def_id, &[], &dead_unwinds, borrowed_locals_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n+    let mut borrowed_locals_cursor = DataflowResultsCursor::new(&borrowed_locals_results, body);\n \n     // Calculate the MIR locals that we actually need to keep storage around\n     // for.\n-    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_result);\n-    let requires_storage =\n+    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_results);\n+    let requires_storage_results =\n         do_dataflow(tcx, body, def_id, &[], &dead_unwinds, requires_storage_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n-    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_result);\n+    let mut requires_storage_cursor = DataflowResultsCursor::new(&requires_storage_results, body);\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n     let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n@@ -484,10 +486,6 @@ fn locals_live_across_suspend_points(\n             };\n \n             if !movable {\n-                let borrowed_locals = state_for_location(loc,\n-                                                         &borrowed_locals_analysis,\n-                                                         &borrowed_locals_result,\n-                                                         body);\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n                 // This is correct for movable generators since borrows cannot live across\n                 // suspension points. However for immovable generators we need to account for\n@@ -498,22 +496,19 @@ fn locals_live_across_suspend_points(\n                 // If a borrow is converted to a raw reference, we must also assume that it lives\n                 // forever. Note that the final liveness is still bounded by the storage liveness\n                 // of the local, which happens using the `intersect` operation below.\n-                liveness.outs[block].union(&borrowed_locals);\n+                borrowed_locals_cursor.seek(loc);\n+                liveness.outs[block].union(borrowed_locals_cursor.get());\n             }\n \n-            let storage_liveness = state_for_location(loc,\n-                                                      &storage_live_analysis,\n-                                                      &storage_live,\n-                                                      body);\n+            storage_live_cursor.seek(loc);\n+            let storage_liveness = storage_live_cursor.get();\n \n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n             storage_liveness_map.insert(block, storage_liveness.clone());\n \n-            let mut storage_required = state_for_location(loc,\n-                                                          &requires_storage_analysis,\n-                                                          &requires_storage,\n-                                                          body);\n+            requires_storage_cursor.seek(loc);\n+            let mut storage_required = requires_storage_cursor.get().clone();\n \n             // Mark locals without storage statements as always requiring storage\n             storage_required.union(&ignored.0);\n@@ -549,8 +544,7 @@ fn locals_live_across_suspend_points(\n         body,\n         &live_locals,\n         &ignored,\n-        requires_storage,\n-        requires_storage_analysis);\n+        requires_storage_results);\n \n     LivenessInfo {\n         live_locals,\n@@ -588,7 +582,6 @@ fn compute_storage_conflicts(\n     stored_locals: &liveness::LiveVarSet,\n     ignored: &StorageIgnored,\n     requires_storage: DataflowResults<'tcx, RequiresStorage<'mir, 'tcx>>,\n-    _requires_storage_analysis: RequiresStorage<'mir, 'tcx>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n     assert_eq!(body.local_decls.len(), ignored.0.domain_size());\n     assert_eq!(body.local_decls.len(), stored_locals.domain_size());"}, {"sha": "e4634d96a6f316027ca2179a3b406426f6d3c5fe", "filename": "src/test/debuginfo/issue-22656.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eceec57f72150dd548e05025a05a93381da41385/src%2Ftest%2Fdebuginfo%2Fissue-22656.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eceec57f72150dd548e05025a05a93381da41385/src%2Ftest%2Fdebuginfo%2Fissue-22656.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue-22656.rs?ref=eceec57f72150dd548e05025a05a93381da41385", "patch": "@@ -15,7 +15,7 @@\n // lldbg-check:[...]$0 = vec![1, 2, 3]\n // lldbr-check:(alloc::vec::Vec<i32>) v = vec![1, 2, 3]\n // lldb-command:print zs\n-// lldbg-check:[...]$1 = StructWithZeroSizedField { x: ZeroSizedStruct, y: 123, z: ZeroSizedStruct, w: 456 }\n+// lldbg-check:[...]$1 = StructWithZeroSizedField { x: ZeroSizedStruct[...], y: 123, z: ZeroSizedStruct[...], w: 456 }\n // lldbr-check:(issue_22656::StructWithZeroSizedField) zs = StructWithZeroSizedField { x: ZeroSizedStruct { }, y: 123, z: ZeroSizedStruct { }, w: 456 }\n // lldbr-command:continue\n "}]}