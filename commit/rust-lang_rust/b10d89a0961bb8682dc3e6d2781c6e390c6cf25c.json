{"sha": "b10d89a0961bb8682dc3e6d2781c6e390c6cf25c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxMGQ4OWEwOTYxYmI4NjgyZGMzZTZkMjc4MWM2ZTM5MGM2Y2YyNWM=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-15T21:43:15Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:02:51Z"}, "message": "Move around code in cleanup for a more logical ordering, and fix comments", "tree": {"sha": "69d5fb1e95bc1052a9c3d5fd8217cb6dc8baceda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69d5fb1e95bc1052a9c3d5fd8217cb6dc8baceda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b10d89a0961bb8682dc3e6d2781c6e390c6cf25c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b10d89a0961bb8682dc3e6d2781c6e390c6cf25c", "html_url": "https://github.com/rust-lang/rust/commit/b10d89a0961bb8682dc3e6d2781c6e390c6cf25c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b10d89a0961bb8682dc3e6d2781c6e390c6cf25c/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7f8b0cd81eb3921890795537ba526d922e21fb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7f8b0cd81eb3921890795537ba526d922e21fb1", "html_url": "https://github.com/rust-lang/rust/commit/c7f8b0cd81eb3921890795537ba526d922e21fb1"}], "stats": {"total": 244, "additions": 60, "deletions": 184}, "files": [{"sha": "67b9dd18288480eb54d9371f2cce0784736b8723", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 60, "deletions": 184, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/b10d89a0961bb8682dc3e6d2781c6e390c6cf25c/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b10d89a0961bb8682dc3e6d2781c6e390c6cf25c/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=b10d89a0961bb8682dc3e6d2781c6e390c6cf25c", "patch": "@@ -11,108 +11,12 @@\n //! ## The Cleanup module\n //!\n //! The cleanup module tracks what values need to be cleaned up as scopes\n-//! are exited, either via panic or just normal control flow. The basic\n-//! idea is that the function context maintains a stack of cleanup scopes\n-//! that are pushed/popped as we traverse the AST tree. There is typically\n-//! at least one cleanup scope per AST node; some AST nodes may introduce\n-//! additional temporary scopes.\n+//! are exited, either via panic or just normal control flow.\n //!\n //! Cleanup items can be scheduled into any of the scopes on the stack.\n-//! Typically, when a scope is popped, we will also generate the code for\n-//! each of its cleanups at that time. This corresponds to a normal exit\n-//! from a block (for example, an expression completing evaluation\n-//! successfully without panic). However, it is also possible to pop a\n-//! block *without* executing its cleanups; this is typically used to\n-//! guard intermediate values that must be cleaned up on panic, but not\n-//! if everything goes right. See the section on custom scopes below for\n-//! more details.\n-//!\n-//! Cleanup scopes come in three kinds:\n-//!\n-//! - **AST scopes:** each AST node in a function body has a corresponding\n-//!   AST scope. We push the AST scope when we start generate code for an AST\n-//!   node and pop it once the AST node has been fully generated.\n-//! - **Loop scopes:** loops have an additional cleanup scope. Cleanups are\n-//!   never scheduled into loop scopes; instead, they are used to record the\n-//!   basic blocks that we should branch to when a `continue` or `break` statement\n-//!   is encountered.\n-//! - **Custom scopes:** custom scopes are typically used to ensure cleanup\n-//!   of intermediate values.\n-//!\n-//! ### When to schedule cleanup\n-//!\n-//! Although the cleanup system is intended to *feel* fairly declarative,\n-//! it's still important to time calls to `schedule_clean()` correctly.\n-//! Basically, you should not schedule cleanup for memory until it has\n-//! been initialized, because if an unwind should occur before the memory\n-//! is fully initialized, then the cleanup will run and try to free or\n-//! drop uninitialized memory. If the initialization itself produces\n-//! byproducts that need to be freed, then you should use temporary custom\n-//! scopes to ensure that those byproducts will get freed on unwind.  For\n-//! example, an expression like `box foo()` will first allocate a box in the\n-//! heap and then call `foo()` -- if `foo()` should panic, this box needs\n-//! to be *shallowly* freed.\n-//!\n-//! ### Long-distance jumps\n-//!\n-//! In addition to popping a scope, which corresponds to normal control\n-//! flow exiting the scope, we may also *jump out* of a scope into some\n-//! earlier scope on the stack. This can occur in response to a `return`,\n-//! `break`, or `continue` statement, but also in response to panic. In\n-//! any of these cases, we will generate a series of cleanup blocks for\n-//! each of the scopes that is exited. So, if the stack contains scopes A\n-//! ... Z, and we break out of a loop whose corresponding cleanup scope is\n-//! X, we would generate cleanup blocks for the cleanups in X, Y, and Z.\n-//! After cleanup is done we would branch to the exit point for scope X.\n-//! But if panic should occur, we would generate cleanups for all the\n-//! scopes from A to Z and then resume the unwind process afterwards.\n-//!\n-//! To avoid generating tons of code, we cache the cleanup blocks that we\n-//! create for breaks, returns, unwinds, and other jumps. Whenever a new\n-//! cleanup is scheduled, though, we must clear these cached blocks. A\n-//! possible improvement would be to keep the cached blocks but simply\n-//! generate a new block which performs the additional cleanup and then\n-//! branches to the existing cached blocks.\n-//!\n-//! ### AST and loop cleanup scopes\n-//!\n-//! AST cleanup scopes are pushed when we begin and end processing an AST\n-//! node. They are used to house cleanups related to rvalue temporary that\n-//! get referenced (e.g., due to an expression like `&Foo()`). Whenever an\n-//! AST scope is popped, we always trans all the cleanups, adding the cleanup\n-//! code after the postdominator of the AST node.\n-//!\n-//! AST nodes that represent breakable loops also push a loop scope; the\n-//! loop scope never has any actual cleanups, it's just used to point to\n-//! the basic blocks where control should flow after a \"continue\" or\n-//! \"break\" statement. Popping a loop scope never generates code.\n-//!\n-//! ### Custom cleanup scopes\n-//!\n-//! Custom cleanup scopes are used for a variety of purposes. The most\n-//! common though is to handle temporary byproducts, where cleanup only\n-//! needs to occur on panic. The general strategy is to push a custom\n-//! cleanup scope, schedule *shallow* cleanups into the custom scope, and\n-//! then pop the custom scope (without transing the cleanups) when\n-//! execution succeeds normally. This way the cleanups are only trans'd on\n-//! unwind, and only up until the point where execution succeeded, at\n-//! which time the complete value should be stored in an lvalue or some\n-//! other place where normal cleanup applies.\n-//!\n-//! To spell it out, here is an example. Imagine an expression `box expr`.\n-//! We would basically:\n-//!\n-//! 1. Push a custom cleanup scope C.\n-//! 2. Allocate the box.\n-//! 3. Schedule a shallow free in the scope C.\n-//! 4. Trans `expr` into the box.\n-//! 5. Pop the scope C.\n-//! 6. Return the box as an rvalue.\n-//!\n-//! This way, if a panic occurs while transing `expr`, the custom\n-//! cleanup scope C is pushed and hence the box will be freed. The trans\n-//! code for `expr` itself is responsible for freeing any other byproducts\n-//! that may be in play.\n+//! Typically, when a scope is finished, we generate the cleanup code. This\n+//! corresponds to a normal exit from a block (for example, an expression\n+//! completing evaluation successfully without panic).\n \n use llvm::{BasicBlockRef, ValueRef};\n use base::{self, Lifetime};\n@@ -131,9 +35,17 @@ pub struct CleanupScope<'tcx> {\n     pub landing_pad: Option<BasicBlockRef>,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct CustomScopeIndex {\n-    index: usize\n+#[derive(Copy, Clone)]\n+pub struct DropValue<'tcx> {\n+    val: ValueRef,\n+    ty: Ty<'tcx>,\n+    skip_dtor: bool,\n+}\n+\n+impl<'tcx> DropValue<'tcx> {\n+    fn trans<'blk>(&self, funclet: Option<&'blk Funclet>, bcx: &BlockAndBuilder<'blk, 'tcx>) {\n+        glue::call_drop_glue(bcx, self.val, self.ty, self.skip_dtor, funclet)\n+    }\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -142,6 +54,44 @@ enum UnwindKind {\n     CleanupPad(ValueRef),\n }\n \n+impl UnwindKind {\n+    /// Generates a branch going from `bcx` to `to_llbb` where `self` is\n+    /// the exit label attached to the start of `bcx`.\n+    ///\n+    /// Transitions from an exit label to other exit labels depend on the type\n+    /// of label. For example with MSVC exceptions unwind exit labels will use\n+    /// the `cleanupret` instruction instead of the `br` instruction.\n+    fn branch(&self, bcx: &BlockAndBuilder, to_llbb: BasicBlockRef) {\n+        match *self {\n+            UnwindKind::CleanupPad(pad) => {\n+                bcx.cleanup_ret(pad, Some(to_llbb));\n+            }\n+            UnwindKind::LandingPad => {\n+                bcx.br(to_llbb);\n+            }\n+        }\n+    }\n+\n+    fn get_funclet(&self, bcx: &BlockAndBuilder) -> Option<Funclet> {\n+        match *self {\n+            UnwindKind::CleanupPad(_) => {\n+                let pad = bcx.cleanup_pad(None, &[]);\n+                Funclet::msvc(pad)\n+            },\n+            UnwindKind::LandingPad => Funclet::gnu(),\n+        }\n+    }\n+}\n+\n+impl PartialEq for UnwindKind {\n+    fn eq(&self, label: &UnwindKind) -> bool {\n+        match (*self, *label) {\n+            (UnwindKind::LandingPad, UnwindKind::LandingPad) |\n+            (UnwindKind::CleanupPad(..), UnwindKind::CleanupPad(..)) => true,\n+            _ => false,\n+        }\n+    }\n+}\n impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     pub fn trans_scope(\n         &self,\n@@ -186,9 +136,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         };\n \n         debug!(\"schedule_drop_adt_contents(val={:?}, ty={:?}) skip_dtor={}\",\n-               Value(val),\n-               ty,\n-               drop.skip_dtor);\n+               Value(val), ty, drop.skip_dtor);\n \n         Some(CleanupScope::new(self, drop))\n     }\n@@ -259,27 +207,9 @@ impl<'tcx> CleanupScope<'tcx> {\n             UnwindKind::LandingPad\n         };\n \n-        // Generate the cleanup block and branch to it.\n-        let cleanup_llbb = CleanupScope::trans_cleanups_to_exit_scope(fcx, val, drop_val);\n-        val.branch(&mut pad_bcx, cleanup_llbb);\n-\n-        return pad_bcx.llbb();\n-    }\n-\n-    /// Used when the caller wishes to jump to an early exit, such as a return,\n-    /// break, continue, or unwind. This function will generate all cleanups\n-    /// between the top of the stack and the exit `label` and return a basic\n-    /// block that the caller can branch to.\n-    fn trans_cleanups_to_exit_scope<'a>(\n-        fcx: &FunctionContext<'a, 'tcx>,\n-        label: UnwindKind,\n-        drop_val: &DropValue<'tcx>\n-    ) -> BasicBlockRef {\n-        debug!(\"trans_cleanups_to_exit_scope label={:?}`\", label);\n-\n         // Generate a block that will resume unwinding to the calling function\n         let bcx = fcx.build_new_block(\"resume\");\n-        match label {\n+        match val {\n             UnwindKind::LandingPad => {\n                 let addr = fcx.landingpad_alloca.get().unwrap();\n                 let lp = bcx.load(addr);\n@@ -299,68 +229,14 @@ impl<'tcx> CleanupScope<'tcx> {\n         let mut cleanup = fcx.build_new_block(\"clean_custom_\");\n \n         // Insert cleanup instructions into the cleanup block\n-        drop_val.trans(label.get_funclet(&cleanup).as_ref(), &cleanup);\n+        drop_val.trans(val.get_funclet(&cleanup).as_ref(), &cleanup);\n \n         // Insert instruction into cleanup block to branch to the exit\n-        label.branch(&mut cleanup, bcx.llbb());\n-\n-        debug!(\"trans_cleanups_to_exit_scope: llbb={:?}\", cleanup.llbb());\n-\n-        cleanup.llbb()\n-    }\n-}\n-\n-impl UnwindKind {\n-    /// Generates a branch going from `bcx` to `to_llbb` where `self` is\n-    /// the exit label attached to the start of `bcx`.\n-    ///\n-    /// Transitions from an exit label to other exit labels depend on the type\n-    /// of label. For example with MSVC exceptions unwind exit labels will use\n-    /// the `cleanupret` instruction instead of the `br` instruction.\n-    fn branch(&self, bcx: &BlockAndBuilder, to_llbb: BasicBlockRef) {\n-        match *self {\n-            UnwindKind::CleanupPad(pad) => {\n-                bcx.cleanup_ret(pad, Some(to_llbb));\n-            }\n-            UnwindKind::LandingPad => {\n-                bcx.br(to_llbb);\n-            }\n-        }\n-    }\n-\n-    fn get_funclet(&self, bcx: &BlockAndBuilder) -> Option<Funclet> {\n-        match *self {\n-            UnwindKind::CleanupPad(_) => {\n-                let pad = bcx.cleanup_pad(None, &[]);\n-                Funclet::msvc(pad)\n-            },\n-            UnwindKind::LandingPad => Funclet::gnu(),\n-        }\n-    }\n-}\n+        val.branch(&mut cleanup, bcx.llbb());\n \n-impl PartialEq for UnwindKind {\n-    fn eq(&self, label: &UnwindKind) -> bool {\n-        match (*self, *label) {\n-            (UnwindKind::LandingPad, UnwindKind::LandingPad) |\n-            (UnwindKind::CleanupPad(..), UnwindKind::CleanupPad(..)) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Cleanup types\n+        // Branch into the cleanup block\n+        val.branch(&mut pad_bcx, cleanup.llbb());\n \n-#[derive(Copy, Clone)]\n-pub struct DropValue<'tcx> {\n-    val: ValueRef,\n-    ty: Ty<'tcx>,\n-    skip_dtor: bool,\n-}\n-\n-impl<'tcx> DropValue<'tcx> {\n-    fn trans<'blk>(&self, funclet: Option<&'blk Funclet>, bcx: &BlockAndBuilder<'blk, 'tcx>) {\n-        glue::call_drop_glue(bcx, self.val, self.ty, self.skip_dtor, funclet)\n+        return pad_bcx.llbb();\n     }\n }"}]}