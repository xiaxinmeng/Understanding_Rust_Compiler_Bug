{"sha": "5aa96024e3679f67925495f5322d6d65c3192fa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYTk2MDI0ZTM2NzlmNjc5MjU0OTVmNTMyMmQ2ZDY1YzMxOTJmYTE=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-14T21:41:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-14T21:41:05Z"}, "message": "Rollup merge of #41249 - GuillaumeGomez:rustdoc-render, r=steveklabnik,frewsxcv\n\nFix invalid associated type rendering in rustdoc\n\nFixes #41036.\n\nr? @rust-lang/docs", "tree": {"sha": "55ccb892cb7f2fc279b2ee84b32391a5c1e1a02c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55ccb892cb7f2fc279b2ee84b32391a5c1e1a02c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5aa96024e3679f67925495f5322d6d65c3192fa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5aa96024e3679f67925495f5322d6d65c3192fa1", "html_url": "https://github.com/rust-lang/rust/commit/5aa96024e3679f67925495f5322d6d65c3192fa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5aa96024e3679f67925495f5322d6d65c3192fa1/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d7467acf69223c6211f8e1a023fa8a73f4bacb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d7467acf69223c6211f8e1a023fa8a73f4bacb9", "html_url": "https://github.com/rust-lang/rust/commit/5d7467acf69223c6211f8e1a023fa8a73f4bacb9"}, {"sha": "dd7dfe56a9e0d095c670a84f9e827fa9689aad97", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd7dfe56a9e0d095c670a84f9e827fa9689aad97", "html_url": "https://github.com/rust-lang/rust/commit/dd7dfe56a9e0d095c670a84f9e827fa9689aad97"}], "stats": {"total": 143, "additions": 101, "deletions": 42}, "files": [{"sha": "3d233463bba3a0fda17570add29d2ec081ff3789", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5aa96024e3679f67925495f5322d6d65c3192fa1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa96024e3679f67925495f5322d6d65c3192fa1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5aa96024e3679f67925495f5322d6d65c3192fa1", "patch": "@@ -2285,7 +2285,7 @@ impl Clean<PathParameters> for hir::PathParameters {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct PathSegment {\n     pub name: String,\n-    pub params: PathParameters\n+    pub params: PathParameters,\n }\n \n impl Clean<PathSegment> for hir::PathSegment {"}, {"sha": "0f47265a1aa6630e3620a8da230aff5141b91e87", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 74, "deletions": 41, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5aa96024e3679f67925495f5322d6d65c3192fa1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa96024e3679f67925495f5322d6d65c3192fa1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5aa96024e3679f67925495f5322d6d65c3192fa1", "patch": "@@ -470,10 +470,22 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n /// rendering function with the necessary arguments for linking to a local path.\n fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n                  print_all: bool, use_absolute: bool, is_not_debug: bool) -> fmt::Result {\n-    let last = path.segments.last().unwrap();\n-    let rel_root = match &*path.segments[0].name {\n-        \"self\" => Some(\"./\".to_string()),\n-        _ => None,\n+    let empty = clean::PathSegment {\n+                    name: String::new(),\n+                    params: clean::PathParameters::Parenthesized {\n+                        inputs: Vec::new(),\n+                        output: None,\n+                    }\n+                };\n+    let last = path.segments.last()\n+                            .unwrap_or(&empty);\n+    let rel_root = if path.segments.is_empty() {\n+        None\n+    } else {\n+        match &*path.segments[0].name {\n+            \"self\" => Some(\"./\".to_string()),\n+            _ => None,\n+        }\n     };\n \n     if print_all {\n@@ -487,10 +499,9 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n                         root.push_str(&seg.name);\n                         root.push_str(\"/\");\n                         if is_not_debug {\n-                            write!(w, \"<a class=\\\"mod\\\"\n-                                           href=\\\"{}index.html\\\">{}</a>::\",\n-                                     root,\n-                                     seg.name)?;\n+                            write!(w, \"<a class=\\\"mod\\\" href=\\\"{}index.html\\\">{}</a>::\",\n+                                   root,\n+                                   seg.name)?;\n                         } else {\n                             write!(w, \"{}::\", seg.name)?;\n                         }\n@@ -516,7 +527,8 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n                 match href(did) {\n                     Some((_, _, fqp)) => format!(\"{}::{}\",\n                                                  fqp[..fqp.len()-1].join(\"::\"),\n-                                                 HRef::new(did, fqp.last().unwrap())),\n+                                                 HRef::new(did, fqp.last()\n+                                                                   .unwrap_or(&String::new()))),\n                     None => format!(\"{}\", HRef::new(did, &last.name)),\n                 }\n             } else {\n@@ -528,7 +540,8 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n                 match href(did) {\n                     Some((_, _, fqp)) => format!(\"{:?}::{:?}\",\n                                                  fqp[..fqp.len()-1].join(\"::\"),\n-                                                 HRef::new(did, fqp.last().unwrap())),\n+                                                 HRef::new(did, fqp.last()\n+                                                                   .unwrap_or(&String::new()))),\n                     None => format!(\"{:?}\", HRef::new(did, &last.name)),\n                 }\n             } else {\n@@ -801,45 +814,65 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n             }\n             Ok(())\n         }\n-        // It's pretty unsightly to look at `<A as B>::C` in output, and\n-        // we've got hyperlinking on our side, so try to avoid longer\n-        // notation as much as possible by making `C` a hyperlink to trait\n-        // `B` to disambiguate.\n-        //\n-        // FIXME: this is still a lossy conversion and there should probably\n-        //        be a better way of representing this in general? Most of\n-        //        the ugliness comes from inlining across crates where\n-        //        everything comes in as a fully resolved QPath (hard to\n-        //        look at).\n-        clean::QPath {\n-            ref name,\n-            ref self_type,\n-            trait_: box clean::ResolvedPath { did, ref typarams, .. },\n-        } => {\n-            if f.alternate() {\n-                write!(f, \"{:#}::\", self_type)?;\n-            } else {\n-                write!(f, \"{}::\", self_type)?;\n-            }\n-            let path = clean::Path::singleton(name.clone());\n-            resolved_path(f, did, &path, true, use_absolute, is_not_debug)?;\n-\n-            // FIXME: `typarams` are not rendered, and this seems bad?\n-            drop(typarams);\n-            Ok(())\n-        }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n+            let should_show_cast = match *trait_ {\n+                box clean::ResolvedPath { .. } => {\n+                    let path = clean::Path::singleton(name.clone());\n+                    !path.segments.is_empty() && &format!(\"{:#}\", trait_) != \"()\" &&\n+                    &format!(\"{:#}\", self_type) != \"Self\"\n+                }\n+                _ => true,\n+            };\n             if f.alternate() {\n                 if is_not_debug {\n-                    write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+                    if should_show_cast {\n+                        write!(f, \"<{:#} as {:#}>::\", self_type, trait_)?\n+                    } else {\n+                        write!(f, \"{:#}::\", self_type)?\n+                    }\n                 } else {\n-                    write!(f, \"<{:#?} as {:#?}>::{}\", self_type, trait_, name)\n+                    if should_show_cast {\n+                        write!(f, \"<{:#?} as {:#?}>::\", self_type, trait_)?\n+                    } else {\n+                        write!(f, \"{:#?}::\", self_type)?\n+                    }\n                 }\n             } else {\n                 if is_not_debug {\n-                    write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n+                    if should_show_cast {\n+                        write!(f, \"&lt;{} as {}&gt;::\", self_type, trait_)?\n+                    } else {\n+                        write!(f, \"{}::\", self_type)?\n+                    }\n                 } else {\n-                    write!(f, \"<{:?} as {:?}>::{}\", self_type, trait_, name)\n+                    if should_show_cast {\n+                        write!(f, \"<{:?} as {:?}>::\", self_type, trait_)?\n+                    } else {\n+                        write!(f, \"{:?}::\", self_type)?\n+                    }\n+                }\n+            };\n+            match *trait_ {\n+                // It's pretty unsightly to look at `<A as B>::C` in output, and\n+                // we've got hyperlinking on our side, so try to avoid longer\n+                // notation as much as possible by making `C` a hyperlink to trait\n+                // `B` to disambiguate.\n+                //\n+                // FIXME: this is still a lossy conversion and there should probably\n+                //        be a better way of representing this in general? Most of\n+                //        the ugliness comes from inlining across crates where\n+                //        everything comes in as a fully resolved QPath (hard to\n+                //        look at).\n+                box clean::ResolvedPath { did, ref typarams, .. } => {\n+                    let path = clean::Path::singleton(name.clone());\n+                    resolved_path(f, did, &path, true, use_absolute, is_not_debug)?;\n+\n+                    // FIXME: `typarams` are not rendered, and this seems bad?\n+                    drop(typarams);\n+                    Ok(())\n+                }\n+                _ => {\n+                    write!(f, \"{}\", name)\n                 }\n             }\n         }"}, {"sha": "24f31b5b1040b6567f0d70d0915335167cc46073", "filename": "src/test/rustdoc/assoc-item-cast.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5aa96024e3679f67925495f5322d6d65c3192fa1/src%2Ftest%2Frustdoc%2Fassoc-item-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa96024e3679f67925495f5322d6d65c3192fa1/src%2Ftest%2Frustdoc%2Fassoc-item-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-item-cast.rs?ref=5aa96024e3679f67925495f5322d6d65c3192fa1", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+// ignore-tidy-linelength\n+\n+pub trait Expression {\n+    type SqlType;\n+}\n+\n+pub trait AsExpression<T> {\n+    type Expression: Expression<SqlType = T>;\n+    fn as_expression(self) -> Self::Expression;\n+}\n+\n+// @has foo/type.AsExprOf.html\n+// @has - '//*[@class=\"rust typedef\"]' 'type AsExprOf<Item, Type> = <Item as AsExpression<Type>>::Expression;'\n+pub type AsExprOf<Item, Type> = <Item as AsExpression<Type>>::Expression;"}]}