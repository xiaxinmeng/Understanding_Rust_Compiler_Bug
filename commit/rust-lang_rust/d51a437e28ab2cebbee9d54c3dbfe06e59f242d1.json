{"sha": "d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MWE0MzdlMjhhYjJjZWJiZWU5ZDU0YzNkYmZlMDZlNTlmMjQyZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-23T05:51:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-23T05:51:16Z"}, "message": "Auto merge of #59058 - petrochenkov:assocrecov3, r=estebank\n\n syntax: Better recovery for `$ty::AssocItem` and `ty!()::AssocItem`\n\nThis PR improves on https://github.com/rust-lang/rust/pull/46788 covering a few missing cases.\n\nFixes https://github.com/rust-lang/rust/issues/52307\nFixes https://github.com/rust-lang/rust/issues/53776\nr? @estebank", "tree": {"sha": "5e24ccb9a40e480b117cc5d27295fae5460ffdcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e24ccb9a40e480b117cc5d27295fae5460ffdcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "html_url": "https://github.com/rust-lang/rust/commit/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f21dee2c6179276321a88a63300dce74ff707e92", "url": "https://api.github.com/repos/rust-lang/rust/commits/f21dee2c6179276321a88a63300dce74ff707e92", "html_url": "https://github.com/rust-lang/rust/commit/f21dee2c6179276321a88a63300dce74ff707e92"}, {"sha": "1ab8ca353237470c2587985279d074c1524e90e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ab8ca353237470c2587985279d074c1524e90e1", "html_url": "https://github.com/rust-lang/rust/commit/1ab8ca353237470c2587985279d074c1524e90e1"}], "stats": {"total": 309, "additions": 217, "deletions": 92}, "files": [{"sha": "6ff06aa4b31d39c00530764e3a5586fd6b5ef3f7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 82, "deletions": 88, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "patch": "@@ -118,23 +118,22 @@ enum BlockMode {\n /// `token::Interpolated` tokens.\n macro_rules! maybe_whole_expr {\n     ($p:expr) => {\n-        if let token::Interpolated(nt) = $p.token.clone() {\n-            match *nt {\n-                token::NtExpr(ref e) | token::NtLiteral(ref e) => {\n+        if let token::Interpolated(nt) = &$p.token {\n+            match &**nt {\n+                token::NtExpr(e) | token::NtLiteral(e) => {\n+                    let e = e.clone();\n                     $p.bump();\n-                    return Ok((*e).clone());\n+                    return Ok(e);\n                 }\n-                token::NtPath(ref path) => {\n+                token::NtPath(path) => {\n+                    let path = path.clone();\n                     $p.bump();\n-                    let span = $p.span;\n-                    let kind = ExprKind::Path(None, (*path).clone());\n-                    return Ok($p.mk_expr(span, kind, ThinVec::new()));\n+                    return Ok($p.mk_expr($p.span, ExprKind::Path(None, path), ThinVec::new()));\n                 }\n-                token::NtBlock(ref block) => {\n+                token::NtBlock(block) => {\n+                    let block = block.clone();\n                     $p.bump();\n-                    let span = $p.span;\n-                    let kind = ExprKind::Block((*block).clone(), None);\n-                    return Ok($p.mk_expr(span, kind, ThinVec::new()));\n+                    return Ok($p.mk_expr($p.span, ExprKind::Block(block, None), ThinVec::new()));\n                 }\n                 _ => {},\n             };\n@@ -145,15 +144,31 @@ macro_rules! maybe_whole_expr {\n /// As maybe_whole_expr, but for things other than expressions\n macro_rules! maybe_whole {\n     ($p:expr, $constructor:ident, |$x:ident| $e:expr) => {\n-        if let token::Interpolated(nt) = $p.token.clone() {\n-            if let token::$constructor($x) = (*nt).clone() {\n+        if let token::Interpolated(nt) = &$p.token {\n+            if let token::$constructor(x) = &**nt {\n+                let $x = x.clone();\n                 $p.bump();\n                 return Ok($e);\n             }\n         }\n     };\n }\n \n+/// If the next tokens are ill-formed `$ty::` recover them as `<$ty>::`.\n+macro_rules! maybe_recover_from_interpolated_ty_qpath {\n+    ($self: expr, $allow_qpath_recovery: expr) => {\n+        if $allow_qpath_recovery && $self.look_ahead(1, |t| t == &token::ModSep) {\n+            if let token::Interpolated(nt) = &$self.token {\n+                if let token::NtTy(ty) = &**nt {\n+                    let ty = ty.clone();\n+                    $self.bump();\n+                    return $self.maybe_recover_from_bad_qpath_stage_2($self.prev_span, ty);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn maybe_append(mut lhs: Vec<Attribute>, mut rhs: Option<Vec<Attribute>>) -> Vec<Attribute> {\n     if let Some(ref mut rhs) = rhs {\n         lhs.append(rhs);\n@@ -172,48 +187,38 @@ enum PrevTokenKind {\n     Other,\n }\n \n-trait RecoverQPath: Sized {\n+trait RecoverQPath: Sized + 'static {\n     const PATH_STYLE: PathStyle = PathStyle::Expr;\n     fn to_ty(&self) -> Option<P<Ty>>;\n-    fn to_recovered(&self, qself: Option<QSelf>, path: ast::Path) -> Self;\n-    fn to_string(&self) -> String;\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self;\n }\n \n impl RecoverQPath for Ty {\n     const PATH_STYLE: PathStyle = PathStyle::Type;\n     fn to_ty(&self) -> Option<P<Ty>> {\n         Some(P(self.clone()))\n     }\n-    fn to_recovered(&self, qself: Option<QSelf>, path: ast::Path) -> Self {\n-        Self { span: path.span, node: TyKind::Path(qself, path), id: self.id }\n-    }\n-    fn to_string(&self) -> String {\n-        pprust::ty_to_string(self)\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n+        Self { span: path.span, node: TyKind::Path(qself, path), id: ast::DUMMY_NODE_ID }\n     }\n }\n \n impl RecoverQPath for Pat {\n     fn to_ty(&self) -> Option<P<Ty>> {\n         self.to_ty()\n     }\n-    fn to_recovered(&self, qself: Option<QSelf>, path: ast::Path) -> Self {\n-        Self { span: path.span, node: PatKind::Path(qself, path), id: self.id }\n-    }\n-    fn to_string(&self) -> String {\n-        pprust::pat_to_string(self)\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n+        Self { span: path.span, node: PatKind::Path(qself, path), id: ast::DUMMY_NODE_ID }\n     }\n }\n \n impl RecoverQPath for Expr {\n     fn to_ty(&self) -> Option<P<Ty>> {\n         self.to_ty()\n     }\n-    fn to_recovered(&self, qself: Option<QSelf>, path: ast::Path) -> Self {\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n         Self { span: path.span, node: ExprKind::Path(qself, path),\n-               id: self.id, attrs: self.attrs.clone() }\n-    }\n-    fn to_string(&self) -> String {\n-        pprust::expr_to_string(self)\n+               attrs: ThinVec::new(), id: ast::DUMMY_NODE_ID }\n     }\n }\n \n@@ -1649,6 +1654,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_ty_common(&mut self, allow_plus: bool, allow_qpath_recovery: bool,\n                        allow_c_variadic: bool) -> PResult<'a, P<Ty>> {\n+        maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n         maybe_whole!(self, NtTy, |x| x);\n \n         let lo = self.span;\n@@ -1800,14 +1806,12 @@ impl<'a> Parser<'a> {\n         };\n \n         let span = lo.to(self.prev_span);\n-        let ty = Ty { node, span, id: ast::DUMMY_NODE_ID };\n+        let ty = P(Ty { node, span, id: ast::DUMMY_NODE_ID });\n \n         // Try to recover from use of `+` with incorrect priority.\n         self.maybe_report_ambiguous_plus(allow_plus, impl_dyn_multi, &ty);\n         self.maybe_recover_from_bad_type_plus(allow_plus, &ty)?;\n-        let ty = self.maybe_recover_from_bad_qpath(ty, allow_qpath_recovery)?;\n-\n-        Ok(P(ty))\n+        self.maybe_recover_from_bad_qpath(ty, allow_qpath_recovery)\n     }\n \n     fn parse_remaining_bounds(&mut self, generic_params: Vec<GenericParam>, path: ast::Path,\n@@ -1878,36 +1882,40 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n-    // Try to recover from associated item paths like `[T]::AssocItem`/`(T, U)::AssocItem`.\n-    fn maybe_recover_from_bad_qpath<T: RecoverQPath>(&mut self, base: T, allow_recovery: bool)\n-                                                     -> PResult<'a, T> {\n+    /// Try to recover from associated item paths like `[T]::AssocItem`/`(T, U)::AssocItem`.\n+    /// Attempt to convert the base expression/pattern/type into a type, parse the `::AssocItem`\n+    /// tail, and combine them into a `<Ty>::AssocItem` expression/pattern/type.\n+    fn maybe_recover_from_bad_qpath<T: RecoverQPath>(&mut self, base: P<T>, allow_recovery: bool)\n+                                                     -> PResult<'a, P<T>> {\n         // Do not add `::` to expected tokens.\n-        if !allow_recovery || self.token != token::ModSep {\n-            return Ok(base);\n+        if allow_recovery && self.token == token::ModSep {\n+            if let Some(ty) = base.to_ty() {\n+                return self.maybe_recover_from_bad_qpath_stage_2(ty.span, ty);\n+            }\n         }\n-        let ty = match base.to_ty() {\n-            Some(ty) => ty,\n-            None => return Ok(base),\n-        };\n+        Ok(base)\n+    }\n \n-        self.bump(); // `::`\n-        let mut segments = Vec::new();\n-        self.parse_path_segments(&mut segments, T::PATH_STYLE, true)?;\n+    /// Given an already parsed `Ty` parse the `::AssocItem` tail and\n+    /// combine them into a `<Ty>::AssocItem` expression/pattern/type.\n+    fn maybe_recover_from_bad_qpath_stage_2<T: RecoverQPath>(&mut self, ty_span: Span, ty: P<Ty>)\n+                                                             -> PResult<'a, P<T>> {\n+        self.expect(&token::ModSep)?;\n \n-        let span = ty.span.to(self.prev_span);\n-        let path_span = span.to(span); // use an empty path since `position` == 0\n-        let recovered = base.to_recovered(\n-            Some(QSelf { ty, path_span, position: 0 }),\n-            ast::Path { segments, span },\n-        );\n+        let mut path = ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP };\n+        self.parse_path_segments(&mut path.segments, T::PATH_STYLE, true)?;\n+        path.span = ty_span.to(self.prev_span);\n \n+        let ty_str = self.sess.source_map().span_to_snippet(ty_span)\n+            .unwrap_or_else(|_| pprust::ty_to_string(&ty));\n         self.diagnostic()\n-            .struct_span_err(span, \"missing angle brackets in associated item path\")\n+            .struct_span_err(path.span, \"missing angle brackets in associated item path\")\n             .span_suggestion( // this is a best-effort recovery\n-                span, \"try\", recovered.to_string(), Applicability::MaybeIncorrect\n+                path.span, \"try\", format!(\"<{}>::{}\", ty_str, path), Applicability::MaybeIncorrect\n             ).emit();\n \n-        Ok(recovered)\n+        let path_span = ty_span.shrink_to_hi(); // use an empty path since `position` == 0\n+        Ok(P(T::recovered(Some(QSelf { ty, path_span, position: 0 }), path)))\n     }\n \n     fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n@@ -2572,15 +2580,6 @@ impl<'a> Parser<'a> {\n         ExprKind::AssignOp(binop, lhs, rhs)\n     }\n \n-    pub fn mk_mac_expr(&mut self, span: Span, m: Mac_, attrs: ThinVec<Attribute>) -> P<Expr> {\n-        P(Expr {\n-            id: ast::DUMMY_NODE_ID,\n-            node: ExprKind::Mac(source_map::Spanned {node: m, span: span}),\n-            span,\n-            attrs,\n-        })\n-    }\n-\n     fn expect_delimited_token_tree(&mut self) -> PResult<'a, (MacDelimiter, TokenStream)> {\n         let delim = match self.token {\n             token::OpenDelim(delim) => delim,\n@@ -2610,6 +2609,7 @@ impl<'a> Parser<'a> {\n     /// N.B., this does not parse outer attributes, and is private because it only works\n     /// correctly if called from `parse_dot_or_call_expr()`.\n     fn parse_bottom_expr(&mut self) -> PResult<'a, P<Expr>> {\n+        maybe_recover_from_interpolated_ty_qpath!(self, true);\n         maybe_whole_expr!(self);\n \n         // Outer attributes are already parsed and will be\n@@ -2824,29 +2824,23 @@ impl<'a> Parser<'a> {\n                     db.note(\"variable declaration using `let` is a statement\");\n                     return Err(db);\n                 } else if self.token.is_path_start() {\n-                    let pth = self.parse_path(PathStyle::Expr)?;\n+                    let path = self.parse_path(PathStyle::Expr)?;\n \n                     // `!`, as an operator, is prefix, so we know this isn't that\n                     if self.eat(&token::Not) {\n                         // MACRO INVOCATION expression\n                         let (delim, tts) = self.expect_delimited_token_tree()?;\n-                        let hi = self.prev_span;\n-                        let node = Mac_ { path: pth, tts, delim };\n-                        return Ok(self.mk_mac_expr(lo.to(hi), node, attrs))\n-                    }\n-                    if self.check(&token::OpenDelim(token::Brace)) {\n+                        hi = self.prev_span;\n+                        ex = ExprKind::Mac(respan(lo.to(hi), Mac_ { path, tts, delim }));\n+                    } else if self.check(&token::OpenDelim(token::Brace)) &&\n+                              !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL) {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n-                        let prohibited = self.restrictions.contains(\n-                            Restrictions::NO_STRUCT_LITERAL\n-                        );\n-                        if !prohibited {\n-                            return self.parse_struct_expr(lo, pth, attrs);\n-                        }\n+                        return self.parse_struct_expr(lo, path, attrs);\n+                    } else {\n+                        hi = path.span;\n+                        ex = ExprKind::Path(None, path);\n                     }\n-\n-                    hi = pth.span;\n-                    ex = ExprKind::Path(None, pth);\n                 } else {\n                     if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n                         // Don't complain about bare semicolons after unclosed braces\n@@ -2881,10 +2875,8 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let expr = Expr { node: ex, span: lo.to(hi), id: ast::DUMMY_NODE_ID, attrs };\n-        let expr = self.maybe_recover_from_bad_qpath(expr, true)?;\n-\n-        return Ok(P(expr));\n+        let expr = self.mk_expr(lo.to(hi), ex, attrs);\n+        self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n     fn parse_struct_expr(&mut self, lo: Span, pth: ast::Path, mut attrs: ThinVec<Attribute>)\n@@ -4584,6 +4576,7 @@ impl<'a> Parser<'a> {\n         allow_range_pat: bool,\n         expected: Option<&'static str>,\n     ) -> PResult<'a, P<Pat>> {\n+        maybe_recover_from_interpolated_ty_qpath!(self, true);\n         maybe_whole!(self, NtPat, |x| x);\n \n         let lo = self.span;\n@@ -4759,7 +4752,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let pat = Pat { node: pat, span: lo.to(self.prev_span), id: ast::DUMMY_NODE_ID };\n+        let pat = P(Pat { node: pat, span: lo.to(self.prev_span), id: ast::DUMMY_NODE_ID });\n         let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n \n         if !allow_range_pat {\n@@ -4785,7 +4778,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        Ok(P(pat))\n+        Ok(pat)\n     }\n \n     /// Parses `ident` or `ident @ pat`.\n@@ -5249,7 +5242,8 @@ impl<'a> Parser<'a> {\n                     self.warn_missing_semicolon();\n                     StmtKind::Mac(P((mac, style, attrs.into())))\n                 } else {\n-                    let e = self.mk_mac_expr(lo.to(hi), mac.node, ThinVec::new());\n+                    let e = self.mk_expr(mac.span, ExprKind::Mac(mac), ThinVec::new());\n+                    let e = self.maybe_recover_from_bad_qpath(e, true)?;\n                     let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n                     let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n                     StmtKind::Expr(e)"}, {"sha": "1d584757f2faf5ecd3f5ffc1a9ffae9fe8a1655a", "filename": "src/test/ui/did_you_mean/bad-assoc-expr.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.rs?ref=d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "patch": "@@ -18,3 +18,19 @@ fn main() {\n     10 + (u8)::clone(&0);\n     //~^ ERROR missing angle brackets in associated item path\n }\n+\n+macro_rules! expr {\n+    ($ty: ty) => ($ty::clone(&0))\n+    //~^ ERROR missing angle brackets in associated item path\n+}\n+macro_rules! ty {\n+    () => (u8)\n+}\n+\n+fn check_macros() {\n+    expr!(u8);\n+    let _ = ty!()::clone(&0);\n+    //~^ ERROR missing angle brackets in associated item path\n+    ty!()::clone(&0);\n+    //~^ ERROR missing angle brackets in associated item path\n+}"}, {"sha": "2024564b911f635c9b8936e3ba7e5940b3e03ce0", "filename": "src/test/ui/did_you_mean/bad-assoc-expr.stderr", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.stderr?ref=d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "patch": "@@ -34,5 +34,26 @@ error: missing angle brackets in associated item path\n LL |     10 + (u8)::clone(&0);\n    |          ^^^^^^^^^^^ help: try: `<(u8)>::clone`\n \n-error: aborting due to 6 previous errors\n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-expr.rs:32:13\n+   |\n+LL |     let _ = ty!()::clone(&0);\n+   |             ^^^^^^^^^^^^ help: try: `<ty!()>::clone`\n+\n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-expr.rs:34:5\n+   |\n+LL |     ty!()::clone(&0);\n+   |     ^^^^^^^^^^^^ help: try: `<ty!()>::clone`\n+\n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-expr.rs:23:19\n+   |\n+LL |     ($ty: ty) => ($ty::clone(&0))\n+   |                   ^^^^^^^^^^ help: try: `<$ty>::clone`\n+...\n+LL |     expr!(u8);\n+   |     ---------- in this macro invocation\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "7e7ba59dca8169f73af3637f5467bb2c94bd53ca", "filename": "src/test/ui/did_you_mean/bad-assoc-pat.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.rs?ref=d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "patch": "@@ -16,3 +16,21 @@ fn main() {\n         //~| ERROR no associated item named `AssocItem` found for type `(u8,)` in the current scope\n     }\n }\n+\n+macro_rules! pat {\n+    ($ty: ty) => ($ty::AssocItem)\n+    //~^ ERROR missing angle brackets in associated item path\n+    //~| ERROR no associated item named `AssocItem` found for type `u8` in the current scope\n+}\n+macro_rules! ty {\n+    () => (u8)\n+}\n+\n+fn check_macros() {\n+    match 0u8 {\n+        pat!(u8) => {}\n+        ty!()::AssocItem => {}\n+        //~^ ERROR missing angle brackets in associated item path\n+        //~| ERROR no associated item named `AssocItem` found for type `u8` in the current scope\n+    }\n+}"}, {"sha": "e620e7b43565f8d3896c37c5db3c41e6f33b12f8", "filename": "src/test/ui/did_you_mean/bad-assoc-pat.stderr", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.stderr?ref=d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "patch": "@@ -22,6 +22,21 @@ error: missing angle brackets in associated item path\n LL |         &(u8,)::AssocItem => {}\n    |          ^^^^^^^^^^^^^^^^ help: try: `<(u8,)>::AssocItem`\n \n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-pat.rs:32:9\n+   |\n+LL |         ty!()::AssocItem => {}\n+   |         ^^^^^^^^^^^^^^^^ help: try: `<ty!()>::AssocItem`\n+\n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-pat.rs:21:19\n+   |\n+LL |     ($ty: ty) => ($ty::AssocItem)\n+   |                   ^^^^^^^^^^^^^^ help: try: `<$ty>::AssocItem`\n+...\n+LL |         pat!(u8) => {}\n+   |         -------- in this macro invocation\n+\n error[E0599]: no associated item named `AssocItem` found for type `[u8]` in the current scope\n   --> $DIR/bad-assoc-pat.rs:3:15\n    |\n@@ -54,6 +69,25 @@ LL |         &(u8,)::AssocItem => {}\n    |          |\n    |          associated item not found in `(u8,)`\n \n-error: aborting due to 8 previous errors\n+error[E0599]: no associated item named `AssocItem` found for type `u8` in the current scope\n+  --> $DIR/bad-assoc-pat.rs:21:24\n+   |\n+LL |     ($ty: ty) => ($ty::AssocItem)\n+   |                   -----^^^^^^^^^\n+   |                   |\n+   |                   associated item not found in `u8`\n+...\n+LL |         pat!(u8) => {}\n+   |         -------- in this macro invocation\n+\n+error[E0599]: no associated item named `AssocItem` found for type `u8` in the current scope\n+  --> $DIR/bad-assoc-pat.rs:32:16\n+   |\n+LL |         ty!()::AssocItem => {}\n+   |         -------^^^^^^^^^\n+   |         |\n+   |         associated item not found in `u8`\n+\n+error: aborting due to 12 previous errors\n \n For more information about this error, try `rustc --explain E0599`."}, {"sha": "85e36f887be087d94c293a9f6831617fe4d672b6", "filename": "src/test/ui/did_you_mean/bad-assoc-ty.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.rs?ref=d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "patch": "@@ -33,4 +33,16 @@ type G = 'static + (Send)::AssocTy;\n type H = Fn(u8) -> (u8)::Output;\n //~^ ERROR ambiguous associated type\n \n+macro_rules! ty {\n+    ($ty: ty) => ($ty::AssocTy);\n+    //~^ ERROR missing angle brackets in associated item path\n+    //~| ERROR ambiguous associated type\n+    () => (u8);\n+}\n+\n+type J = ty!(u8);\n+type I = ty!()::AssocTy;\n+//~^ ERROR missing angle brackets in associated item path\n+//~| ERROR ambiguous associated type\n+\n fn main() {}"}, {"sha": "7e7f18f2d6e43bd489ad7109930393f121b78eb1", "filename": "src/test/ui/did_you_mean/bad-assoc-ty.stderr", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr?ref=d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "patch": "@@ -38,7 +38,22 @@ error: missing angle brackets in associated item path\n   --> $DIR/bad-assoc-ty.rs:27:10\n    |\n LL | type G = 'static + (Send)::AssocTy;\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `<'static + Send>::AssocTy`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `<'static + (Send)>::AssocTy`\n+\n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-ty.rs:44:10\n+   |\n+LL | type I = ty!()::AssocTy;\n+   |          ^^^^^^^^^^^^^^ help: try: `<ty!()>::AssocTy`\n+\n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-ty.rs:37:19\n+   |\n+LL |     ($ty: ty) => ($ty::AssocTy);\n+   |                   ^^^^^^^^^^^^ help: try: `<$ty>::AssocTy`\n+...\n+LL | type J = ty!(u8);\n+   |          ------- in this macro invocation\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:1:10\n@@ -88,7 +103,22 @@ error[E0223]: ambiguous associated type\n LL | type H = Fn(u8) -> (u8)::Output;\n    |          ^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<(dyn std::ops::Fn(u8) -> u8 + 'static) as Trait>::Output`\n \n-error: aborting due to 15 previous errors\n+error[E0223]: ambiguous associated type\n+  --> $DIR/bad-assoc-ty.rs:37:19\n+   |\n+LL |     ($ty: ty) => ($ty::AssocTy);\n+   |                   ^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+...\n+LL | type J = ty!(u8);\n+   |          ------- in this macro invocation\n+\n+error[E0223]: ambiguous associated type\n+  --> $DIR/bad-assoc-ty.rs:44:10\n+   |\n+LL | type I = ty!()::AssocTy;\n+   |          ^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+\n+error: aborting due to 19 previous errors\n \n Some errors occurred: E0121, E0223.\n For more information about an error, try `rustc --explain E0121`."}]}