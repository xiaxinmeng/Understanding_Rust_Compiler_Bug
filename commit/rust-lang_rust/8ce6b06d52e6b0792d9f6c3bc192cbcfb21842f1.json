{"sha": "8ce6b06d52e6b0792d9f6c3bc192cbcfb21842f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZTZiMDZkNTJlNmIwNzkyZDlmNmMzYmMxOTJjYmNmYjIxODQyZjE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-25T17:21:26Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-25T17:33:12Z"}, "message": "Remove specialize float/bool read/write methods from memory\n\nNotice that the write methods were previously unused, so if this makes us handle some things incorrectly, they probably were already broken", "tree": {"sha": "2290c931947ebf46d624b77598d7f0c296655f0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2290c931947ebf46d624b77598d7f0c296655f0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ce6b06d52e6b0792d9f6c3bc192cbcfb21842f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ce6b06d52e6b0792d9f6c3bc192cbcfb21842f1", "html_url": "https://github.com/rust-lang/rust/commit/8ce6b06d52e6b0792d9f6c3bc192cbcfb21842f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ce6b06d52e6b0792d9f6c3bc192cbcfb21842f1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac80212f7e973ccd57ed41137e2ec38db6fbde1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac80212f7e973ccd57ed41137e2ec38db6fbde1f", "html_url": "https://github.com/rust-lang/rust/commit/ac80212f7e973ccd57ed41137e2ec38db6fbde1f"}], "stats": {"total": 104, "additions": 12, "deletions": 92}, "files": [{"sha": "2d86c14a86ae2a4bde6774700fb70fdd66098c24", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ce6b06d52e6b0792d9f6c3bc192cbcfb21842f1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce6b06d52e6b0792d9f6c3bc192cbcfb21842f1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8ce6b06d52e6b0792d9f6c3bc192cbcfb21842f1", "patch": "@@ -1610,7 +1610,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n             Value::ByVal(primval) => {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n-                // TODO: This fn gets called with sizes like 6, which cannot be a primitive type\n+                // TODO: This fn gets called with sizes like 0 and 6, which cannot be a primitive type\n                 // and hence is not supported by write_primval.\n                 // (E.g. in the arrays.rs testcase.)  That seems to only happen for Undef though,\n                 // so we special-case that here.\n@@ -1808,7 +1808,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         let ptr = ptr.to_ptr()?;\n         let val = match ty.sty {\n-            ty::TyBool => PrimVal::from_bool(self.memory.read_bool(ptr)?),\n+            ty::TyBool => {\n+                let val = self.memory.read_primval(ptr, 1, false)?;\n+                let val = match val {\n+                    PrimVal::Bytes(0) => false,\n+                    PrimVal::Bytes(1) => true,\n+                    _ => return err!(InvalidBool),\n+                };\n+                PrimVal::from_bool(val)\n+            }\n             ty::TyChar => {\n                 let c = self.memory.read_primval(ptr, 4, false)?.to_bytes()? as u32;\n                 match ::std::char::from_u32(c) {\n@@ -1843,8 +1851,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 self.memory.read_primval(ptr, size, false)?\n             }\n \n-            ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr)?),\n-            ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr)?),\n+            ty::TyFloat(FloatTy::F32) => PrimVal::Bytes(self.memory.read_primval(ptr, 4, false)?.to_bytes()?),\n+            ty::TyFloat(FloatTy::F64) => PrimVal::Bytes(self.memory.read_primval(ptr, 8, false)?.to_bytes()?),\n \n             ty::TyFnPtr(_) => self.memory.read_ptr_sized_unsigned(ptr)?,\n             ty::TyRef(_, ref tam) |"}, {"sha": "8e2b5e9c430974151b31911c12cf5eae9eab817f", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8ce6b06d52e6b0792d9f6c3bc192cbcfb21842f1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce6b06d52e6b0792d9f6c3bc192cbcfb21842f1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=8ce6b06d52e6b0792d9f6c3bc192cbcfb21842f1", "patch": "@@ -1207,7 +1207,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     pub fn write_primval(&mut self, ptr: MemoryPointer, val: PrimVal, size: u64, signed: bool) -> EvalResult<'tcx> {\n-        trace!(\"Writing {:?}, size {}\", val, size);\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n \n@@ -1265,22 +1264,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         self.write_primval(ptr, val, ptr_size, false)\n     }\n \n-    pub fn read_bool(&self, ptr: MemoryPointer) -> EvalResult<'tcx, bool> {\n-        let bytes = self.get_bytes(ptr, 1, self.layout.i1_align.abi())?;\n-        match bytes[0] {\n-            0 => Ok(false),\n-            1 => Ok(true),\n-            _ => err!(InvalidBool),\n-        }\n-    }\n-\n-    pub fn write_bool(&mut self, ptr: MemoryPointer, b: bool) -> EvalResult<'tcx> {\n-        let align = self.layout.i1_align.abi();\n-        self.get_bytes_mut(ptr, 1, align).map(\n-            |bytes| bytes[0] = b as u8,\n-        )\n-    }\n-\n     fn int_align(&self, size: u64) -> EvalResult<'tcx, u64> {\n         // We assume pointer-sized integers have the same alignment as pointers.\n         // We also assume singed and unsigned integers of the same size have the same alignment.\n@@ -1293,38 +1276,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             _ => bug!(\"bad integer size: {}\", size),\n         }\n     }\n-\n-    pub fn write_f32(&mut self, ptr: MemoryPointer, f: f32) -> EvalResult<'tcx> {\n-        let endianess = self.endianess();\n-        let align = self.layout.f32_align.abi();\n-        let b = self.get_bytes_mut(ptr, 4, align)?;\n-        write_target_f32(endianess, b, f).unwrap();\n-        Ok(())\n-    }\n-\n-    pub fn write_f64(&mut self, ptr: MemoryPointer, f: f64) -> EvalResult<'tcx> {\n-        let endianess = self.endianess();\n-        let align = self.layout.f64_align.abi();\n-        let b = self.get_bytes_mut(ptr, 8, align)?;\n-        write_target_f64(endianess, b, f).unwrap();\n-        Ok(())\n-    }\n-\n-    pub fn read_f32(&self, ptr: MemoryPointer) -> EvalResult<'tcx, f32> {\n-        self.get_bytes(ptr, 4, self.layout.f32_align.abi()).map(\n-            |b| {\n-                read_target_f32(self.endianess(), b).unwrap()\n-            },\n-        )\n-    }\n-\n-    pub fn read_f64(&self, ptr: MemoryPointer) -> EvalResult<'tcx, f64> {\n-        self.get_bytes(ptr, 8, self.layout.f64_align.abi()).map(\n-            |b| {\n-                read_target_f64(self.endianess(), b).unwrap()\n-            },\n-        )\n-    }\n }\n \n /// Relocations\n@@ -1496,45 +1447,6 @@ fn read_target_int(endianess: layout::Endian, mut source: &[u8]) -> Result<i128,\n     }\n }\n \n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Methods to access floats in the target endianess\n-////////////////////////////////////////////////////////////////////////////////\n-\n-fn write_target_f32(\n-    endianess: layout::Endian,\n-    mut target: &mut [u8],\n-    data: f32,\n-) -> Result<(), io::Error> {\n-    match endianess {\n-        layout::Endian::Little => target.write_f32::<LittleEndian>(data),\n-        layout::Endian::Big => target.write_f32::<BigEndian>(data),\n-    }\n-}\n-fn write_target_f64(\n-    endianess: layout::Endian,\n-    mut target: &mut [u8],\n-    data: f64,\n-) -> Result<(), io::Error> {\n-    match endianess {\n-        layout::Endian::Little => target.write_f64::<LittleEndian>(data),\n-        layout::Endian::Big => target.write_f64::<BigEndian>(data),\n-    }\n-}\n-\n-fn read_target_f32(endianess: layout::Endian, mut source: &[u8]) -> Result<f32, io::Error> {\n-    match endianess {\n-        layout::Endian::Little => source.read_f32::<LittleEndian>(),\n-        layout::Endian::Big => source.read_f32::<BigEndian>(),\n-    }\n-}\n-fn read_target_f64(endianess: layout::Endian, mut source: &[u8]) -> Result<f64, io::Error> {\n-    match endianess {\n-        layout::Endian::Little => source.read_f64::<LittleEndian>(),\n-        layout::Endian::Big => source.read_f64::<BigEndian>(),\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Undefined byte tracking\n ////////////////////////////////////////////////////////////////////////////////"}]}