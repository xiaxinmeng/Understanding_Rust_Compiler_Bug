{"sha": "36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZWNiYzk0ZWI2YmU5MGJjMzhiMmQwZmRkNGJmYWMzZjM0ZDk5MjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-07T16:48:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-07T16:48:57Z"}, "message": "Auto merge of #80632 - Nadrieril:fix-80501, r=varkor\n\nIdentify unreachable subpatterns more reliably\n\nIn https://github.com/rust-lang/rust/pull/80104 I used `Span`s to identify unreachable sub-patterns in the presence of or-patterns during exhaustiveness checking. In https://github.com/rust-lang/rust/issues/80501 it was revealed that `Span`s are complicated and that this was not a good idea.\nInstead, this PR identifies subpatterns logically: as a path in the tree of subpatterns of a given pattern. I made a struct that captures a set of such subpatterns. This is a bit complex, but thankfully self-contained; the rest of the code does not need to know anything about it.\nFixes https://github.com/rust-lang/rust/issues/80501. I think I managed to keep the perf neutral.\n\nr? `@varkor`", "tree": {"sha": "d74ad00cf16e17da1e827a9de6757ec9fdc13718", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d74ad00cf16e17da1e827a9de6757ec9fdc13718"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "html_url": "https://github.com/rust-lang/rust/commit/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a5f3a980c0d2afd55f2162300339471378e341f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a5f3a980c0d2afd55f2162300339471378e341f", "html_url": "https://github.com/rust-lang/rust/commit/5a5f3a980c0d2afd55f2162300339471378e341f"}, {"sha": "ae6fcab733007b4d59b5b2aac1825bf1f275b0b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae6fcab733007b4d59b5b2aac1825bf1f275b0b2", "html_url": "https://github.com/rust-lang/rust/commit/ae6fcab733007b4d59b5b2aac1825bf1f275b0b2"}], "stats": {"total": 695, "additions": 472, "deletions": 223}, "files": [{"sha": "6ec602ff59b9ce2ad8e32fbe7b81933572b70e53", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "patch": "@@ -1,6 +1,6 @@\n-use super::usefulness::Usefulness::*;\n use super::usefulness::{\n-    compute_match_usefulness, expand_pattern, MatchArm, MatchCheckCtxt, UsefulnessReport,\n+    compute_match_usefulness, expand_pattern, MatchArm, MatchCheckCtxt, Reachability,\n+    UsefulnessReport,\n };\n use super::{PatCtxt, PatKind, PatternError};\n \n@@ -398,10 +398,11 @@ fn report_arm_reachability<'p, 'tcx>(\n     report: &UsefulnessReport<'p, 'tcx>,\n     source: hir::MatchSource,\n ) {\n+    use Reachability::*;\n     let mut catchall = None;\n     for (arm_index, (arm, is_useful)) in report.arm_usefulness.iter().enumerate() {\n         match is_useful {\n-            NotUseful => {\n+            Unreachable => {\n                 match source {\n                     hir::MatchSource::WhileDesugar => bug!(),\n \n@@ -430,17 +431,16 @@ fn report_arm_reachability<'p, 'tcx>(\n                     hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n                 }\n             }\n-            Useful(unreachables) if unreachables.is_empty() => {}\n+            Reachable(unreachables) if unreachables.is_empty() => {}\n             // The arm is reachable, but contains unreachable subpatterns (from or-patterns).\n-            Useful(unreachables) => {\n-                let mut unreachables: Vec<_> = unreachables.iter().collect();\n+            Reachable(unreachables) => {\n+                let mut unreachables = unreachables.clone();\n                 // Emit lints in the order in which they occur in the file.\n                 unreachables.sort_unstable();\n                 for span in unreachables {\n                     unreachable_pattern(cx.tcx, span, arm.hir_id, None);\n                 }\n             }\n-            UsefulWithWitness(_) => bug!(),\n         }\n         if !arm.has_guard && catchall.is_none() && pat_is_catchall(arm.pat) {\n             catchall = Some(arm.pat.span);"}, {"sha": "3a67eeff92c315f85f8f411573c5b200911a603b", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "patch": "@@ -723,8 +723,6 @@ impl<'tcx> Constructor<'tcx> {\n     where\n         'tcx: 'a,\n     {\n-        debug!(\"Constructor::split({:#?})\", self);\n-\n         match self {\n             Wildcard => {\n                 let mut split_wildcard = SplitWildcard::new(pcx);"}, {"sha": "f3f21b903ea089deff284ac0e4f73ba573c78c6d", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 371, "deletions": 202, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "patch": "@@ -288,6 +288,7 @@ use super::{Pat, PatKind};\n use super::{PatternFoldable, PatternFolder};\n \n use rustc_data_structures::captures::Captures;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::OnceCell;\n \n use rustc_arena::TypedArena;\n@@ -344,6 +345,12 @@ pub(super) struct PatCtxt<'a, 'p, 'tcx> {\n     pub(super) is_top_level: bool,\n }\n \n+impl<'a, 'p, 'tcx> fmt::Debug for PatCtxt<'a, 'p, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"PatCtxt\").field(\"ty\", &self.ty).finish()\n+    }\n+}\n+\n crate fn expand_pattern<'tcx>(pat: Pat<'tcx>) -> Pat<'tcx> {\n     LiteralExpander.fold_pattern(&pat)\n }\n@@ -379,11 +386,32 @@ impl<'tcx> Pat<'tcx> {\n     pub(super) fn is_wildcard(&self) -> bool {\n         matches!(*self.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n     }\n+\n+    fn is_or_pat(&self) -> bool {\n+        matches!(*self.kind, PatKind::Or { .. })\n+    }\n+\n+    /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n+    fn expand_or_pat(&self) -> Vec<&Self> {\n+        fn expand<'p, 'tcx>(pat: &'p Pat<'tcx>, vec: &mut Vec<&'p Pat<'tcx>>) {\n+            if let PatKind::Or { pats } = pat.kind.as_ref() {\n+                for pat in pats {\n+                    expand(pat, vec);\n+                }\n+            } else {\n+                vec.push(pat)\n+            }\n+        }\n+\n+        let mut pats = Vec::new();\n+        expand(self, &mut pats);\n+        pats\n+    }\n }\n \n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n /// works well.\n-#[derive(Debug, Clone)]\n+#[derive(Clone)]\n struct PatStack<'p, 'tcx> {\n     pats: SmallVec<[&'p Pat<'tcx>; 2]>,\n     /// Cache for the constructor of the head\n@@ -419,23 +447,14 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         self.pats.iter().copied()\n     }\n \n-    // If the first pattern is an or-pattern, expand this pattern. Otherwise, return `None`.\n-    fn expand_or_pat(&self) -> Option<Vec<Self>> {\n-        if self.is_empty() {\n-            None\n-        } else if let PatKind::Or { pats } = &*self.head().kind {\n-            Some(\n-                pats.iter()\n-                    .map(|pat| {\n-                        let mut new_patstack = PatStack::from_pattern(pat);\n-                        new_patstack.pats.extend_from_slice(&self.pats[1..]);\n-                        new_patstack\n-                    })\n-                    .collect(),\n-            )\n-        } else {\n-            None\n-        }\n+    // Recursively expand the first pattern into its subpatterns. Only useful if the pattern is an\n+    // or-pattern. Panics if `self` is empty.\n+    fn expand_or_pat<'a>(&'a self) -> impl Iterator<Item = PatStack<'p, 'tcx>> + Captures<'a> {\n+        self.head().expand_or_pat().into_iter().map(move |pat| {\n+            let mut new_patstack = PatStack::from_pattern(pat);\n+            new_patstack.pats.extend_from_slice(&self.pats[1..]);\n+            new_patstack\n+        })\n     }\n \n     /// This computes `S(self.head_ctor(), self)`. See top of the file for explanations.\n@@ -475,6 +494,17 @@ impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n     }\n }\n \n+/// Pretty-printing for matrix row.\n+impl<'p, 'tcx> fmt::Debug for PatStack<'p, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"+\")?;\n+        for pat in self.iter() {\n+            write!(f, \" {} +\", pat)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n /// A 2D matrix.\n #[derive(Clone, PartialEq)]\n pub(super) struct Matrix<'p, 'tcx> {\n@@ -491,13 +521,12 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         self.patterns.get(0).map(|r| r.len())\n     }\n \n-    /// Pushes a new row to the matrix. If the row starts with an or-pattern, this expands it.\n+    /// Pushes a new row to the matrix. If the row starts with an or-pattern, this recursively\n+    /// expands it.\n     fn push(&mut self, row: PatStack<'p, 'tcx>) {\n-        if let Some(rows) = row.expand_or_pat() {\n-            for row in rows {\n-                // We recursively expand the or-patterns of the new rows.\n-                // This is necessary as we might have `0 | (1 | 2)` or e.g., `x @ 0 | x @ (1 | 2)`.\n-                self.push(row)\n+        if !row.is_empty() && row.head().is_or_pat() {\n+            for row in row.expand_or_pat() {\n+                self.patterns.push(row);\n             }\n         } else {\n             self.patterns.push(row);\n@@ -543,35 +572,26 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n /// Pretty-printer for matrices of patterns, example:\n ///\n /// ```text\n-/// +++++++++++++++++++++++++++++\n /// + _     + []                +\n-/// +++++++++++++++++++++++++++++\n /// + true  + [First]           +\n-/// +++++++++++++++++++++++++++++\n /// + true  + [Second(true)]    +\n-/// +++++++++++++++++++++++++++++\n /// + false + [_]               +\n-/// +++++++++++++++++++++++++++++\n /// + _     + [_, _, tail @ ..] +\n-/// +++++++++++++++++++++++++++++\n /// ```\n impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"\\n\")?;\n \n         let Matrix { patterns: m, .. } = self;\n         let pretty_printed_matrix: Vec<Vec<String>> =\n-            m.iter().map(|row| row.iter().map(|pat| format!(\"{:?}\", pat)).collect()).collect();\n+            m.iter().map(|row| row.iter().map(|pat| format!(\"{}\", pat)).collect()).collect();\n \n-        let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n+        let column_count = m.iter().map(|row| row.len()).next().unwrap_or(0);\n         assert!(m.iter().all(|row| row.len() == column_count));\n         let column_widths: Vec<usize> = (0..column_count)\n             .map(|col| pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0))\n             .collect();\n \n-        let total_width = column_widths.iter().cloned().sum::<usize>() + column_count * 3 + 1;\n-        let br = \"+\".repeat(total_width);\n-        write!(f, \"{}\\n\", br)?;\n         for row in pretty_printed_matrix {\n             write!(f, \"+\")?;\n             for (column, pat_str) in row.into_iter().enumerate() {\n@@ -580,7 +600,6 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n                 write!(f, \" +\")?;\n             }\n             write!(f, \"\\n\")?;\n-            write!(f, \"{}\\n\", br)?;\n         }\n         Ok(())\n     }\n@@ -600,191 +619,327 @@ impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n     }\n }\n \n-/// Represents a set of `Span`s closed under the containment relation. That is, if a `Span` is\n-/// contained in the set then all `Span`s contained in it are also implicitly contained in the set.\n-/// In particular this means that when intersecting two sets, taking the intersection of some span\n-/// and one of its subspans returns the subspan, whereas a simple `HashSet` would have returned an\n-/// empty intersection.\n-/// It is assumed that two spans don't overlap without one being contained in the other; in other\n-/// words, that the inclusion structure forms a tree and not a DAG.\n-/// Intersection is not very efficient. It compares everything pairwise. If needed it could be made\n-/// faster by sorting the `Span`s and merging cleverly.\n-#[derive(Debug, Clone, Default)]\n-pub(crate) struct SpanSet {\n-    /// The minimal set of `Span`s required to represent the whole set. If A and B are `Span`s in\n-    /// the `SpanSet`, and A is a descendant of B, then only B will be in `root_spans`.\n-    /// Invariant: the spans are disjoint.\n-    root_spans: Vec<Span>,\n+/// Given a pattern or a pattern-stack, this struct captures a set of its subpatterns. We use that\n+/// to track reachable sub-patterns arising from or-patterns. In the absence of or-patterns this\n+/// will always be either `Empty` (the whole pattern is unreachable) or `Full` (the whole pattern\n+/// is reachable). When there are or-patterns, some subpatterns may be reachable while others\n+/// aren't. In this case the whole pattern still counts as reachable, but we will lint the\n+/// unreachable subpatterns.\n+///\n+/// This supports a limited set of operations, so not all possible sets of subpatterns can be\n+/// represented. That's ok, we only want the ones that make sense for our usage.\n+///\n+/// What we're doing is illustrated by this:\n+/// ```\n+/// match (true, 0) {\n+///     (true, 0) => {}\n+///     (_, 1) => {}\n+///     (true | false, 0 | 1) => {}\n+/// }\n+/// ```\n+/// When we try the alternatives of the `true | false` or-pattern, the last `0` is reachable in the\n+/// `false` alternative but not the `true`. So overall it is reachable. By contrast, the last `1`\n+/// is not reachable in either alternative, so we want to signal this to the user.\n+/// Therefore we take the union of sets of reachable patterns coming from different alternatives in\n+/// order to figure out which subpatterns are overall reachable.\n+///\n+/// Invariant: we try to construct the smallest representation we can. In particular if\n+/// `self.is_empty()` we ensure that `self` is `Empty`, and same with `Full`. This is not important\n+/// for correctness currently.\n+#[derive(Debug, Clone)]\n+enum SubPatSet<'p, 'tcx> {\n+    /// The empty set. This means the pattern is unreachable.\n+    Empty,\n+    /// The set containing the full pattern.\n+    Full,\n+    /// If the pattern is a pattern with a constructor or a pattern-stack, we store a set for each\n+    /// of its subpatterns. Missing entries in the map are implicitly full, because that's the\n+    /// common case.\n+    Seq { subpats: FxHashMap<usize, SubPatSet<'p, 'tcx>> },\n+    /// If the pattern is an or-pattern, we store a set for each of its alternatives. Missing\n+    /// entries in the map are implicitly empty. Note: we always flatten nested or-patterns.\n+    Alt {\n+        subpats: FxHashMap<usize, SubPatSet<'p, 'tcx>>,\n+        /// Counts the total number of alternatives in the pattern\n+        alt_count: usize,\n+        /// We keep the pattern around to retrieve spans.\n+        pat: &'p Pat<'tcx>,\n+    },\n }\n \n-impl SpanSet {\n-    /// Creates an empty set.\n-    fn new() -> Self {\n-        Self::default()\n-    }\n-\n-    /// Tests whether the set is empty.\n-    pub(crate) fn is_empty(&self) -> bool {\n-        self.root_spans.is_empty()\n+impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n+    fn full() -> Self {\n+        SubPatSet::Full\n     }\n-\n-    /// Iterate over the disjoint list of spans at the roots of this set.\n-    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = Span> + Captures<'a> {\n-        self.root_spans.iter().copied()\n+    fn empty() -> Self {\n+        SubPatSet::Empty\n     }\n \n-    /// Tests whether the set contains a given Span.\n-    fn contains(&self, span: Span) -> bool {\n-        self.iter().any(|root_span| root_span.contains(span))\n+    fn is_empty(&self) -> bool {\n+        match self {\n+            SubPatSet::Empty => true,\n+            SubPatSet::Full => false,\n+            // If any subpattern in a sequence is unreachable, the whole pattern is unreachable.\n+            SubPatSet::Seq { subpats } => subpats.values().any(|set| set.is_empty()),\n+            // An or-pattern is reachable if any of its alternatives is.\n+            SubPatSet::Alt { subpats, .. } => subpats.values().all(|set| set.is_empty()),\n+        }\n     }\n \n-    /// Add a span to the set if we know the span has no intersection in this set.\n-    fn push_nonintersecting(&mut self, new_span: Span) {\n-        self.root_spans.push(new_span);\n+    fn is_full(&self) -> bool {\n+        match self {\n+            SubPatSet::Empty => false,\n+            SubPatSet::Full => true,\n+            // The whole pattern is reachable only when all its alternatives are.\n+            SubPatSet::Seq { subpats } => subpats.values().all(|sub_set| sub_set.is_full()),\n+            // The whole or-pattern is reachable only when all its alternatives are.\n+            SubPatSet::Alt { subpats, alt_count, .. } => {\n+                subpats.len() == *alt_count && subpats.values().all(|set| set.is_full())\n+            }\n+        }\n     }\n \n-    fn intersection_mut(&mut self, other: &Self) {\n-        if self.is_empty() || other.is_empty() {\n-            *self = Self::new();\n+    /// Union `self` with `other`, mutating `self`.\n+    fn union(&mut self, other: Self) {\n+        use SubPatSet::*;\n+        // Union with full stays full; union with empty changes nothing.\n+        if self.is_full() || other.is_empty() {\n+            return;\n+        } else if self.is_empty() {\n+            *self = other;\n+            return;\n+        } else if other.is_full() {\n+            *self = Full;\n             return;\n         }\n-        // Those that were in `self` but not contained in `other`\n-        let mut leftover = SpanSet::new();\n-        // We keep the elements in `self` that are also in `other`.\n-        self.root_spans.retain(|span| {\n-            let retain = other.contains(*span);\n-            if !retain {\n-                leftover.root_spans.push(*span);\n+\n+        match (&mut *self, other) {\n+            (Seq { subpats: s_set }, Seq { subpats: mut o_set }) => {\n+                s_set.retain(|i, s_sub_set| {\n+                    // Missing entries count as full.\n+                    let o_sub_set = o_set.remove(&i).unwrap_or(Full);\n+                    s_sub_set.union(o_sub_set);\n+                    // We drop full entries.\n+                    !s_sub_set.is_full()\n+                });\n+                // Everything left in `o_set` is missing from `s_set`, i.e. counts as full. Since\n+                // unioning with full returns full, we can drop those entries.\n             }\n-            retain\n-        });\n-        // We keep the elements in `other` that are also in the original `self`. You might think\n-        // this is not needed because `self` already contains the intersection. But those aren't\n-        // just sets of things. If `self = [a]`, `other = [b]` and `a` contains `b`, then `b`\n-        // belongs in the intersection but we didn't catch it in the filtering above. We look at\n-        // `leftover` instead of the full original `self` to avoid duplicates.\n-        for span in other.iter() {\n-            if leftover.contains(span) {\n-                self.root_spans.push(span);\n+            (Alt { subpats: s_set, .. }, Alt { subpats: mut o_set, .. }) => {\n+                s_set.retain(|i, s_sub_set| {\n+                    // Missing entries count as empty.\n+                    let o_sub_set = o_set.remove(&i).unwrap_or(Empty);\n+                    s_sub_set.union(o_sub_set);\n+                    // We drop empty entries.\n+                    !s_sub_set.is_empty()\n+                });\n+                // Everything left in `o_set` is missing from `s_set`, i.e. counts as empty. Since\n+                // unioning with empty changes nothing, we can take those entries as is.\n+                s_set.extend(o_set);\n+            }\n+            _ => bug!(),\n+        }\n+\n+        if self.is_full() {\n+            *self = Full;\n+        }\n+    }\n+\n+    /// Returns a list of the spans of the unreachable subpatterns. If `self` is empty (i.e. the\n+    /// whole pattern is unreachable) we return `None`.\n+    fn list_unreachable_spans(&self) -> Option<Vec<Span>> {\n+        /// Panics if `set.is_empty()`.\n+        fn fill_spans(set: &SubPatSet<'_, '_>, spans: &mut Vec<Span>) {\n+            match set {\n+                SubPatSet::Empty => bug!(),\n+                SubPatSet::Full => {}\n+                SubPatSet::Seq { subpats } => {\n+                    for (_, sub_set) in subpats {\n+                        fill_spans(sub_set, spans);\n+                    }\n+                }\n+                SubPatSet::Alt { subpats, pat, alt_count, .. } => {\n+                    let expanded = pat.expand_or_pat();\n+                    for i in 0..*alt_count {\n+                        let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Empty);\n+                        if sub_set.is_empty() {\n+                            // Found a unreachable subpattern.\n+                            spans.push(expanded[i].span);\n+                        } else {\n+                            fill_spans(sub_set, spans);\n+                        }\n+                    }\n+                }\n             }\n         }\n+\n+        if self.is_empty() {\n+            return None;\n+        }\n+        if self.is_full() {\n+            // No subpatterns are unreachable.\n+            return Some(Vec::new());\n+        }\n+        let mut spans = Vec::new();\n+        fill_spans(self, &mut spans);\n+        Some(spans)\n+    }\n+\n+    /// When `self` refers to a patstack that was obtained from specialization, after running\n+    /// `unspecialize` it will refer to the original patstack before specialization.\n+    fn unspecialize(self, arity: usize) -> Self {\n+        use SubPatSet::*;\n+        match self {\n+            Full => Full,\n+            Empty => Empty,\n+            Seq { subpats } => {\n+                // We gather the first `arity` subpatterns together and shift the remaining ones.\n+                let mut new_subpats = FxHashMap::default();\n+                let mut new_subpats_first_col = FxHashMap::default();\n+                for (i, sub_set) in subpats {\n+                    if i < arity {\n+                        // The first `arity` indices are now part of the pattern in the first\n+                        // column.\n+                        new_subpats_first_col.insert(i, sub_set);\n+                    } else {\n+                        // Indices after `arity` are simply shifted\n+                        new_subpats.insert(i - arity + 1, sub_set);\n+                    }\n+                }\n+                // If `new_subpats_first_col` has no entries it counts as full, so we can omit it.\n+                if !new_subpats_first_col.is_empty() {\n+                    new_subpats.insert(0, Seq { subpats: new_subpats_first_col });\n+                }\n+                Seq { subpats: new_subpats }\n+            }\n+            Alt { .. } => bug!(), // `self` is a patstack\n+        }\n+    }\n+\n+    /// When `self` refers to a patstack that was obtained from splitting an or-pattern, after\n+    /// running `unspecialize` it will refer to the original patstack before splitting.\n+    ///\n+    /// For example:\n+    /// ```\n+    /// match Some(true) {\n+    ///     Some(true) => {}\n+    ///     None | Some(true | false) => {}\n+    /// }\n+    /// ```\n+    /// Here `None` would return the full set and `Some(true | false)` would return the set\n+    /// containing `false`. After `unsplit_or_pat`, we want the set to contain `None` and `false`.\n+    /// This is what this function does.\n+    fn unsplit_or_pat(mut self, alt_id: usize, alt_count: usize, pat: &'p Pat<'tcx>) -> Self {\n+        use SubPatSet::*;\n+        if self.is_empty() {\n+            return Empty;\n+        }\n+\n+        // Subpatterns coming from inside the or-pattern alternative itself, e.g. in `None | Some(0\n+        // | 1)`.\n+        let set_first_col = match &mut self {\n+            Full => Full,\n+            Seq { subpats } => subpats.remove(&0).unwrap_or(Full),\n+            Empty => unreachable!(),\n+            Alt { .. } => bug!(), // `self` is a patstack\n+        };\n+        let mut subpats_first_col = FxHashMap::default();\n+        subpats_first_col.insert(alt_id, set_first_col);\n+        let set_first_col = Alt { subpats: subpats_first_col, pat, alt_count };\n+\n+        let mut subpats = match self {\n+            Full => FxHashMap::default(),\n+            Seq { subpats } => subpats,\n+            Empty => unreachable!(),\n+            Alt { .. } => bug!(), // `self` is a patstack\n+        };\n+        subpats.insert(0, set_first_col);\n+        Seq { subpats }\n     }\n }\n \n+/// This carries the results of computing usefulness, as described at the top of the file. When\n+/// checking usefulness of a match branch, we use the `NoWitnesses` variant, which also keeps track\n+/// of potential unreachable sub-patterns (in the presence of or-patterns). When checking\n+/// exhaustiveness of a whole match, we use the `WithWitnesses` variant, which carries a list of\n+/// witnesses of non-exhaustiveness when there are any.\n+/// Which variant to use is dictated by `WitnessPreference`.\n #[derive(Clone, Debug)]\n-crate enum Usefulness<'tcx> {\n-    /// Pontentially carries a set of sub-branches that have been found to be unreachable. Used\n-    /// only in the presence of or-patterns, otherwise it stays empty.\n-    Useful(SpanSet),\n-    /// Carries a list of witnesses of non-exhaustiveness.\n-    UsefulWithWitness(Vec<Witness<'tcx>>),\n-    NotUseful,\n+enum Usefulness<'p, 'tcx> {\n+    /// Carries a set of subpatterns that have been found to be reachable. If empty, this indicates\n+    /// the whole pattern is unreachable. If not, this indicates that the pattern is reachable but\n+    /// that some sub-patterns may be unreachable (due to or-patterns). In the absence of\n+    /// or-patterns this will always be either `Empty` (the whole pattern is unreachable) or `Full`\n+    /// (the whole pattern is reachable).\n+    NoWitnesses(SubPatSet<'p, 'tcx>),\n+    /// Carries a list of witnesses of non-exhaustiveness. If empty, indicates that the whole\n+    /// pattern is unreachable.\n+    WithWitnesses(Vec<Witness<'tcx>>),\n }\n \n-impl<'tcx> Usefulness<'tcx> {\n+impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n     fn new_useful(preference: WitnessPreference) -> Self {\n         match preference {\n-            ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n-            LeaveOutWitness => Useful(Default::default()),\n+            ConstructWitness => WithWitnesses(vec![Witness(vec![])]),\n+            LeaveOutWitness => NoWitnesses(SubPatSet::full()),\n+        }\n+    }\n+    fn new_not_useful(preference: WitnessPreference) -> Self {\n+        match preference {\n+            ConstructWitness => WithWitnesses(vec![]),\n+            LeaveOutWitness => NoWitnesses(SubPatSet::empty()),\n+        }\n+    }\n+\n+    /// Combine usefulnesses from two branches. This is an associative operation.\n+    fn extend(&mut self, other: Self) {\n+        match (&mut *self, other) {\n+            (WithWitnesses(_), WithWitnesses(o)) if o.is_empty() => {}\n+            (WithWitnesses(s), WithWitnesses(o)) if s.is_empty() => *self = WithWitnesses(o),\n+            (WithWitnesses(s), WithWitnesses(o)) => s.extend(o),\n+            (NoWitnesses(s), NoWitnesses(o)) => s.union(o),\n+            _ => unreachable!(),\n         }\n     }\n \n     /// When trying several branches and each returns a `Usefulness`, we need to combine the\n     /// results together.\n-    fn merge(usefulnesses: impl Iterator<Item = Self>) -> Self {\n-        // If we have detected some unreachable sub-branches, we only want to keep them when they\n-        // were unreachable in _all_ branches. Eg. in the following, the last `true` is unreachable\n-        // in the second branch of the first or-pattern, but not otherwise. Therefore we don't want\n-        // to lint that it is unreachable.\n-        // ```\n-        // match (true, true) {\n-        //     (true, true) => {}\n-        //     (false | true, false | true) => {}\n-        // }\n-        // ```\n-        // Here however we _do_ want to lint that the last `false` is unreachable. So we don't want\n-        // to intersect the spans that come directly from the or-pattern, since each branch of the\n-        // or-pattern brings a new disjoint pattern.\n-        // ```\n-        // match None {\n-        //     Some(false) => {}\n-        //     None | Some(true | false) => {}\n-        // }\n-        // ```\n-\n-        // Is `None` when no branch was useful. Will often be `Some(Spanset::new())` because the\n-        // sets are only non-empty in the presence of or-patterns.\n-        let mut unreachables: Option<SpanSet> = None;\n-        // Witnesses of usefulness, if any.\n-        let mut witnesses = Vec::new();\n-\n+    fn merge(pref: WitnessPreference, usefulnesses: impl Iterator<Item = Self>) -> Self {\n+        let mut ret = Self::new_not_useful(pref);\n         for u in usefulnesses {\n-            match u {\n-                Useful(spans) if spans.is_empty() => {\n-                    // Once we reach the empty set, more intersections won't change the result.\n-                    return Useful(SpanSet::new());\n-                }\n-                Useful(spans) => {\n-                    if let Some(unreachables) = &mut unreachables {\n-                        if !unreachables.is_empty() {\n-                            unreachables.intersection_mut(&spans);\n-                        }\n-                        if unreachables.is_empty() {\n-                            return Useful(SpanSet::new());\n-                        }\n-                    } else {\n-                        unreachables = Some(spans);\n-                    }\n-                }\n-                NotUseful => {}\n-                UsefulWithWitness(wits) => {\n-                    witnesses.extend(wits);\n+            ret.extend(u);\n+            if let NoWitnesses(subpats) = &ret {\n+                if subpats.is_full() {\n+                    // Once we reach the full set, more unions won't change the result.\n+                    return ret;\n                 }\n             }\n         }\n-\n-        if !witnesses.is_empty() {\n-            UsefulWithWitness(witnesses)\n-        } else if let Some(unreachables) = unreachables {\n-            Useful(unreachables)\n-        } else {\n-            NotUseful\n-        }\n+        ret\n     }\n \n     /// After calculating the usefulness for a branch of an or-pattern, call this to make this\n     /// usefulness mergeable with those from the other branches.\n-    fn unsplit_or_pat(self, this_span: Span, or_pat_spans: &[Span]) -> Self {\n+    fn unsplit_or_pat(self, alt_id: usize, alt_count: usize, pat: &'p Pat<'tcx>) -> Self {\n         match self {\n-            Useful(mut spans) => {\n-                // We register the spans of the other branches of this or-pattern as being\n-                // unreachable from this one. This ensures that intersecting together the sets of\n-                // spans returns what we want.\n-                // Until we optimize `SpanSet` however, intersecting this entails a number of\n-                // comparisons quadratic in the number of branches.\n-                for &span in or_pat_spans {\n-                    if span != this_span {\n-                        spans.push_nonintersecting(span);\n-                    }\n-                }\n-                Useful(spans)\n-            }\n-            x => x,\n+            NoWitnesses(subpats) => NoWitnesses(subpats.unsplit_or_pat(alt_id, alt_count, pat)),\n+            WithWitnesses(_) => bug!(),\n         }\n     }\n \n     /// After calculating usefulness after a specialization, call this to recontruct a usefulness\n     /// that makes sense for the matrix pre-specialization. This new usefulness can then be merged\n     /// with the results of specializing with the other constructors.\n-    fn apply_constructor<'p>(\n+    fn apply_constructor(\n         self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         matrix: &Matrix<'p, 'tcx>, // used to compute missing ctors\n         ctor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Self {\n         match self {\n-            UsefulWithWitness(witnesses) => {\n+            WithWitnesses(witnesses) if witnesses.is_empty() => WithWitnesses(witnesses),\n+            WithWitnesses(witnesses) => {\n                 let new_witnesses = if matches!(ctor, Constructor::Missing) {\n                     let mut split_wildcard = SplitWildcard::new(pcx);\n                     split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n@@ -814,9 +969,9 @@ impl<'tcx> Usefulness<'tcx> {\n                         .map(|witness| witness.apply_constructor(pcx, &ctor, ctor_wild_subpatterns))\n                         .collect()\n                 };\n-                UsefulWithWitness(new_witnesses)\n+                WithWitnesses(new_witnesses)\n             }\n-            x => x,\n+            NoWitnesses(subpats) => NoWitnesses(subpats.unspecialize(ctor_wild_subpatterns.len())),\n         }\n     }\n }\n@@ -924,6 +1079,7 @@ impl<'tcx> Witness<'tcx> {\n /// `is_under_guard` is used to inform if the pattern has a guard. If it\n /// has one it must not be inserted into the matrix. This shouldn't be\n /// relied on for soundness.\n+#[instrument(skip(cx, matrix, witness_preference, hir_id, is_under_guard, is_top_level))]\n fn is_useful<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n@@ -932,39 +1088,40 @@ fn is_useful<'p, 'tcx>(\n     hir_id: HirId,\n     is_under_guard: bool,\n     is_top_level: bool,\n-) -> Usefulness<'tcx> {\n+) -> Usefulness<'p, 'tcx> {\n+    debug!(\"matrix,v={:?}{:?}\", matrix, v);\n     let Matrix { patterns: rows, .. } = matrix;\n-    debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n \n     // The base case. We are pattern-matching on () and the return value is\n     // based on whether our matrix has a row or not.\n     // NOTE: This could potentially be optimized by checking rows.is_empty()\n     // first and then, if v is non-empty, the return value is based on whether\n     // the type of the tuple we're checking is inhabited or not.\n     if v.is_empty() {\n-        return if rows.is_empty() {\n+        let ret = if rows.is_empty() {\n             Usefulness::new_useful(witness_preference)\n         } else {\n-            NotUseful\n+            Usefulness::new_not_useful(witness_preference)\n         };\n-    };\n+        debug!(?ret);\n+        return ret;\n+    }\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n     let ty = matrix.heads().next().map_or(v.head().ty, |r| r.ty);\n     let pcx = PatCtxt { cx, ty, span: v.head().span, is_top_level };\n \n-    debug!(\"is_useful_expand_first_col: ty={:#?}, expanding {:#?}\", pcx.ty, v.head());\n-\n     // If the first pattern is an or-pattern, expand it.\n-    let ret = if let Some(vs) = v.expand_or_pat() {\n-        let subspans: Vec<_> = vs.iter().map(|v| v.head().span).collect();\n-        // We expand the or pattern, trying each of its branches in turn and keeping careful track\n-        // of possible unreachable sub-branches.\n+    let ret = if v.head().is_or_pat() {\n+        debug!(\"expanding or-pattern\");\n+        let v_head = v.head();\n+        let vs: Vec<_> = v.expand_or_pat().collect();\n+        let alt_count = vs.len();\n+        // We try each or-pattern branch in turn.\n         let mut matrix = matrix.clone();\n-        let usefulnesses = vs.into_iter().map(|v| {\n-            let v_span = v.head().span;\n+        let usefulnesses = vs.into_iter().enumerate().map(|(i, v)| {\n             let usefulness =\n                 is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             // If pattern has a guard don't add it to the matrix.\n@@ -973,9 +1130,9 @@ fn is_useful<'p, 'tcx>(\n                 // branches like `Some(_) | Some(0)`.\n                 matrix.push(v);\n             }\n-            usefulness.unsplit_or_pat(v_span, &subspans)\n+            usefulness.unsplit_or_pat(i, alt_count, v_head)\n         });\n-        Usefulness::merge(usefulnesses)\n+        Usefulness::merge(witness_preference, usefulnesses)\n     } else {\n         let v_ctor = v.head_ctor(cx);\n         if let Constructor::IntRange(ctor_range) = &v_ctor {\n@@ -993,6 +1150,7 @@ fn is_useful<'p, 'tcx>(\n         // witness the usefulness of `v`.\n         let start_matrix = &matrix;\n         let usefulnesses = split_ctors.into_iter().map(|ctor| {\n+            debug!(\"specialize({:?})\", ctor);\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n             let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n             let spec_matrix =\n@@ -1002,9 +1160,9 @@ fn is_useful<'p, 'tcx>(\n                 is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             usefulness.apply_constructor(pcx, start_matrix, &ctor, &ctor_wild_subpatterns)\n         });\n-        Usefulness::merge(usefulnesses)\n+        Usefulness::merge(witness_preference, usefulnesses)\n     };\n-    debug!(\"is_useful::returns({:#?}, {:#?}) = {:?}\", matrix, v, ret);\n+    debug!(?ret);\n     ret\n }\n \n@@ -1017,10 +1175,21 @@ crate struct MatchArm<'p, 'tcx> {\n     crate has_guard: bool,\n }\n \n+/// Indicates whether or not a given arm is reachable.\n+#[derive(Clone, Debug)]\n+crate enum Reachability {\n+    /// The arm is reachable. This additionally carries a set of or-pattern branches that have been\n+    /// found to be unreachable despite the overall arm being reachable. Used only in the presence\n+    /// of or-patterns, otherwise it stays empty.\n+    Reachable(Vec<Span>),\n+    /// The arm is unreachable.\n+    Unreachable,\n+}\n+\n /// The output of checking a match for exhaustiveness and arm reachability.\n crate struct UsefulnessReport<'p, 'tcx> {\n     /// For each arm of the input, whether that arm is reachable after the arms above it.\n-    crate arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Usefulness<'tcx>)>,\n+    crate arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Reachability)>,\n     /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n     /// exhaustiveness.\n     crate non_exhaustiveness_witnesses: Vec<super::Pat<'tcx>>,\n@@ -1048,23 +1217,23 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n             if !arm.has_guard {\n                 matrix.push(v);\n             }\n-            (arm, usefulness)\n+            let reachability = match usefulness {\n+                NoWitnesses(subpats) if subpats.is_empty() => Reachability::Unreachable,\n+                NoWitnesses(subpats) => {\n+                    Reachability::Reachable(subpats.list_unreachable_spans().unwrap())\n+                }\n+                WithWitnesses(..) => bug!(),\n+            };\n+            (arm, reachability)\n         })\n         .collect();\n \n     let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(scrut_ty));\n     let v = PatStack::from_pattern(wild_pattern);\n     let usefulness = is_useful(cx, &matrix, &v, ConstructWitness, scrut_hir_id, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {\n-        NotUseful => vec![], // Wildcard pattern isn't useful, so the match is exhaustive.\n-        UsefulWithWitness(pats) => {\n-            if pats.is_empty() {\n-                bug!(\"Exhaustiveness check returned no witnesses\")\n-            } else {\n-                pats.into_iter().map(|w| w.single_pattern()).collect()\n-            }\n-        }\n-        Useful(_) => bug!(),\n+        WithWitnesses(pats) => pats.into_iter().map(|w| w.single_pattern()).collect(),\n+        NoWitnesses(_) => bug!(),\n     };\n     UsefulnessReport { arm_usefulness, non_exhaustiveness_witnesses }\n }"}, {"sha": "bdb7a1ec92b7f3ce42e3640d36b897d59db603fc", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs?ref=36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "patch": "@@ -48,6 +48,25 @@ fn main() {\n         (1 | 1,) => {} //~ ERROR unreachable\n         _ => {}\n     }\n+    match 0 {\n+        (0 | 1) | 1 => {} //~ ERROR unreachable\n+        _ => {}\n+    }\n+    match 0 {\n+        // We get two errors because recursive or-pattern expansion means we don't notice the two\n+        // errors span a whole pattern. This could be better but doesn't matter much\n+        0 | (0 | 0) => {}\n+        //~^ ERROR unreachable\n+        //~| ERROR unreachable\n+        _ => {}\n+    }\n+    match None {\n+        // There is only one error that correctly points to the whole subpattern\n+        Some(0) |\n+            Some( //~ ERROR unreachable\n+                0 | 0) => {}\n+        _ => {}\n+    }\n     match [0; 2] {\n         [0\n             | 0 //~ ERROR unreachable\n@@ -84,8 +103,8 @@ fn main() {\n     }\n     macro_rules! t_or_f {\n         () => {\n-            (true // FIXME: should be unreachable\n-                        | false)\n+            (true //~ ERROR unreachable\n+            | false)\n         };\n     }\n     match (true, None) {"}, {"sha": "51991fc6039674c364009ade50068b34c7a3381c", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.stderr", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr?ref=36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "patch": "@@ -77,58 +77,94 @@ LL |         (1 | 1,) => {}\n    |              ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:53:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:52:19\n+   |\n+LL |         (0 | 1) | 1 => {}\n+   |                   ^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:58:14\n+   |\n+LL |         0 | (0 | 0) => {}\n+   |              ^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:58:18\n+   |\n+LL |         0 | (0 | 0) => {}\n+   |                  ^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:66:13\n+   |\n+LL | /             Some(\n+LL | |                 0 | 0) => {}\n+   | |______________________^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:72:15\n    |\n LL |             | 0\n    |               ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:55:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:74:15\n    |\n LL |             | 0] => {}\n    |               ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:63:10\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:82:10\n    |\n LL |         [1\n    |          ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:75:10\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:94:10\n    |\n LL |         [true\n    |          ^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:82:36\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:101:36\n    |\n LL |         (true | false, None | Some(true\n    |                                    ^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:98:14\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:106:14\n+   |\n+LL |             (true\n+   |              ^^^^\n+...\n+LL |         (true | false, None | Some(t_or_f!())) => {}\n+   |                                    --------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:117:14\n    |\n LL |         Some(0\n    |              ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:117:19\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:136:19\n    |\n LL |                 | false) => {}\n    |                   ^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:125:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:144:15\n    |\n LL |             | true) => {}\n    |               ^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:131:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:150:15\n    |\n LL |             | true,\n    |               ^^^^\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 26 previous errors\n "}, {"sha": "aac7d7d5385a4177851250643fb5d45bad2443d2", "filename": "src/test/ui/pattern/usefulness/issue-80501-or-pat-and-macro.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-80501-or-pat-and-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-80501-or-pat-and-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-80501-or-pat-and-macro.rs?ref=36ecbc94eb6be90bc38b2d0fdd4bfac3f34d9923", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+#![deny(unreachable_patterns)]\n+pub enum TypeCtor {\n+    Slice,\n+    Array,\n+}\n+\n+pub struct ApplicationTy(TypeCtor);\n+\n+macro_rules! ty_app {\n+    ($ctor:pat) => {\n+        ApplicationTy($ctor)\n+    };\n+}\n+\n+fn _foo(ty: ApplicationTy) {\n+    match ty {\n+        ty_app!(TypeCtor::Array) | ty_app!(TypeCtor::Slice) => {}\n+    }\n+\n+    // same as above, with the macro expanded\n+    match ty {\n+        ApplicationTy(TypeCtor::Array) | ApplicationTy(TypeCtor::Slice) => {}\n+    }\n+}\n+\n+fn main() {}"}]}