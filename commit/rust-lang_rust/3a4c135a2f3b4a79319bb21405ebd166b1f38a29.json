{"sha": "3a4c135a2f3b4a79319bb21405ebd166b1f38a29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNGMxMzVhMmYzYjRhNzkzMTliYjIxNDA1ZWJkMTY2YjFmMzhhMjk=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-31T18:48:08Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-01-24T20:28:28Z"}, "message": "Improve the debugging experience", "tree": {"sha": "53299f3f61205e524e66563cc95346184a542663", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53299f3f61205e524e66563cc95346184a542663"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a4c135a2f3b4a79319bb21405ebd166b1f38a29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a4c135a2f3b4a79319bb21405ebd166b1f38a29", "html_url": "https://github.com/rust-lang/rust/commit/3a4c135a2f3b4a79319bb21405ebd166b1f38a29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a4c135a2f3b4a79319bb21405ebd166b1f38a29/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c1a1c622776da5741f178658c611ccf0f75755f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c1a1c622776da5741f178658c611ccf0f75755f", "html_url": "https://github.com/rust-lang/rust/commit/3c1a1c622776da5741f178658c611ccf0f75755f"}], "stats": {"total": 55, "additions": 30, "deletions": 25}, "files": [{"sha": "223767afde14e884813971584cebe5d3d766eb43", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a4c135a2f3b4a79319bb21405ebd166b1f38a29/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a4c135a2f3b4a79319bb21405ebd166b1f38a29/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=3a4c135a2f3b4a79319bb21405ebd166b1f38a29", "patch": "@@ -724,8 +724,6 @@ impl<'tcx> Constructor<'tcx> {\n     where\n         'tcx: 'a,\n     {\n-        debug!(\"Constructor::split({:#?})\", self);\n-\n         match self {\n             Wildcard => {\n                 let mut split_wildcard = SplitWildcard::new(pcx);"}, {"sha": "d1c9c3ea6bfbad8a1d4a77eac968a64f9bf41d99", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3a4c135a2f3b4a79319bb21405ebd166b1f38a29/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a4c135a2f3b4a79319bb21405ebd166b1f38a29/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=3a4c135a2f3b4a79319bb21405ebd166b1f38a29", "patch": "@@ -344,6 +344,12 @@ pub(super) struct PatCtxt<'a, 'p, 'tcx> {\n     pub(super) is_top_level: bool,\n }\n \n+impl<'a, 'p, 'tcx> fmt::Debug for PatCtxt<'a, 'p, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"PatCtxt\").field(\"ty\", &self.ty).finish()\n+    }\n+}\n+\n crate fn expand_pattern<'tcx>(pat: Pat<'tcx>) -> Pat<'tcx> {\n     LiteralExpander.fold_pattern(&pat)\n }\n@@ -383,7 +389,7 @@ impl<'tcx> Pat<'tcx> {\n \n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n /// works well.\n-#[derive(Debug, Clone)]\n+#[derive(Clone)]\n struct PatStack<'p, 'tcx> {\n     pats: SmallVec<[&'p Pat<'tcx>; 2]>,\n     /// Cache for the constructor of the head\n@@ -475,6 +481,17 @@ impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n     }\n }\n \n+/// Pretty-printing for matrix row.\n+impl<'p, 'tcx> fmt::Debug for PatStack<'p, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"+\")?;\n+        for pat in self.iter() {\n+            write!(f, \" {} +\", pat)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n /// A 2D matrix.\n #[derive(Clone, PartialEq)]\n pub(super) struct Matrix<'p, 'tcx> {\n@@ -543,35 +560,26 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n /// Pretty-printer for matrices of patterns, example:\n ///\n /// ```text\n-/// +++++++++++++++++++++++++++++\n /// + _     + []                +\n-/// +++++++++++++++++++++++++++++\n /// + true  + [First]           +\n-/// +++++++++++++++++++++++++++++\n /// + true  + [Second(true)]    +\n-/// +++++++++++++++++++++++++++++\n /// + false + [_]               +\n-/// +++++++++++++++++++++++++++++\n /// + _     + [_, _, tail @ ..] +\n-/// +++++++++++++++++++++++++++++\n /// ```\n impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"\\n\")?;\n \n         let Matrix { patterns: m, .. } = self;\n         let pretty_printed_matrix: Vec<Vec<String>> =\n-            m.iter().map(|row| row.iter().map(|pat| format!(\"{:?}\", pat)).collect()).collect();\n+            m.iter().map(|row| row.iter().map(|pat| format!(\"{}\", pat)).collect()).collect();\n \n-        let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n+        let column_count = m.iter().map(|row| row.len()).next().unwrap_or(0);\n         assert!(m.iter().all(|row| row.len() == column_count));\n         let column_widths: Vec<usize> = (0..column_count)\n             .map(|col| pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0))\n             .collect();\n \n-        let total_width = column_widths.iter().cloned().sum::<usize>() + column_count * 3 + 1;\n-        let br = \"+\".repeat(total_width);\n-        write!(f, \"{}\\n\", br)?;\n         for row in pretty_printed_matrix {\n             write!(f, \"+\")?;\n             for (column, pat_str) in row.into_iter().enumerate() {\n@@ -580,7 +588,6 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n                 write!(f, \" +\")?;\n             }\n             write!(f, \"\\n\")?;\n-            write!(f, \"{}\\n\", br)?;\n         }\n         Ok(())\n     }\n@@ -924,6 +931,7 @@ impl<'tcx> Witness<'tcx> {\n /// `is_under_guard` is used to inform if the pattern has a guard. If it\n /// has one it must not be inserted into the matrix. This shouldn't be\n /// relied on for soundness.\n+#[instrument(skip(cx, matrix, witness_preference, hir_id, is_under_guard, is_top_level))]\n fn is_useful<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n@@ -933,32 +941,30 @@ fn is_useful<'p, 'tcx>(\n     is_under_guard: bool,\n     is_top_level: bool,\n ) -> Usefulness<'tcx> {\n+    debug!(\"matrix,v={:?}{:?}\", matrix, v);\n     let Matrix { patterns: rows, .. } = matrix;\n-    debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n \n     // The base case. We are pattern-matching on () and the return value is\n     // based on whether our matrix has a row or not.\n     // NOTE: This could potentially be optimized by checking rows.is_empty()\n     // first and then, if v is non-empty, the return value is based on whether\n     // the type of the tuple we're checking is inhabited or not.\n     if v.is_empty() {\n-        return if rows.is_empty() {\n-            Usefulness::new_useful(witness_preference)\n-        } else {\n-            NotUseful\n-        };\n-    };\n+        let ret =\n+            if rows.is_empty() { Usefulness::new_useful(witness_preference) } else { NotUseful };\n+        debug!(?ret);\n+        return ret;\n+    }\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n     let ty = matrix.heads().next().map_or(v.head().ty, |r| r.ty);\n     let pcx = PatCtxt { cx, ty, span: v.head().span, is_top_level };\n \n-    debug!(\"is_useful_expand_first_col: ty={:#?}, expanding {:#?}\", pcx.ty, v.head());\n-\n     // If the first pattern is an or-pattern, expand it.\n     let ret = if let Some(vs) = v.expand_or_pat() {\n+        debug!(\"expanding or-pattern\");\n         let subspans: Vec<_> = vs.iter().map(|v| v.head().span).collect();\n         // We expand the or pattern, trying each of its branches in turn and keeping careful track\n         // of possible unreachable sub-branches.\n@@ -993,6 +999,7 @@ fn is_useful<'p, 'tcx>(\n         // witness the usefulness of `v`.\n         let start_matrix = &matrix;\n         let usefulnesses = split_ctors.into_iter().map(|ctor| {\n+            debug!(\"specialize({:?})\", ctor);\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n             let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n             let spec_matrix =\n@@ -1004,7 +1011,7 @@ fn is_useful<'p, 'tcx>(\n         });\n         Usefulness::merge(usefulnesses)\n     };\n-    debug!(\"is_useful::returns({:#?}, {:#?}) = {:?}\", matrix, v, ret);\n+    debug!(?ret);\n     ret\n }\n "}]}