{"sha": "76ade3e8ac42cd7a7b7c3c5ef54818ab68e3ebdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YWRlM2U4YWM0MmNkN2E3YjdjM2M1ZWY1NDgxOGFiNjhlM2ViZGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-08T07:55:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-08T07:55:53Z"}, "message": "Auto merge of #66066 - ecstatic-morse:remove-promotion-from-qualify-consts, r=eddyb\n\nRemove promotion candidate gathering and checking from `qualify_consts.rs`\n\nThis makes promotion candidate gathering and checking the exclusive domain of `promote_consts`, but the `QualifyAndPromoteConsts` pass is still responsible for both const-checking and creating promoted MIR fragments.\n\nThis should not be merged until the beta branches on Nov. 5.\n\nr? @eddyb", "tree": {"sha": "62c30deec4467d64469587725e5043ec9a1e02e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62c30deec4467d64469587725e5043ec9a1e02e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76ade3e8ac42cd7a7b7c3c5ef54818ab68e3ebdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76ade3e8ac42cd7a7b7c3c5ef54818ab68e3ebdc", "html_url": "https://github.com/rust-lang/rust/commit/76ade3e8ac42cd7a7b7c3c5ef54818ab68e3ebdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76ade3e8ac42cd7a7b7c3c5ef54818ab68e3ebdc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c34472b77084c9f76f872871aeab121daf81fb99", "url": "https://api.github.com/repos/rust-lang/rust/commits/c34472b77084c9f76f872871aeab121daf81fb99", "html_url": "https://github.com/rust-lang/rust/commit/c34472b77084c9f76f872871aeab121daf81fb99"}, {"sha": "ec5ba54ed2f0db8dae06f0f89b183bbfd0306238", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec5ba54ed2f0db8dae06f0f89b183bbfd0306238", "html_url": "https://github.com/rust-lang/rust/commit/ec5ba54ed2f0db8dae06f0f89b183bbfd0306238"}], "stats": {"total": 518, "additions": 79, "deletions": 439}, "files": [{"sha": "6a7058f19301782b4ce58d7d94a59c8b01456053", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 62, "deletions": 439, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/76ade3e8ac42cd7a7b7c3c5ef54818ab68e3ebdc/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ade3e8ac42cd7a7b7c3c5ef54818ab68e3ebdc/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=76ade3e8ac42cd7a7b7c3c5ef54818ab68e3ebdc", "patch": "@@ -6,7 +6,6 @@\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_target::spec::abi::Abi;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -20,7 +19,6 @@ use rustc::mir::traversal::ReversePostorder;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::middle::lang_items;\n use rustc::session::config::nightly_options;\n-use syntax::ast::LitKind;\n use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -71,7 +69,7 @@ impl fmt::Display for Mode {\n     }\n }\n \n-const QUALIF_COUNT: usize = 4;\n+const QUALIF_COUNT: usize = 2;\n \n // FIXME(eddyb) once we can use const generics, replace this array with\n // something like `IndexVec` but for fixed-size arrays (`IndexArray`?).\n@@ -80,20 +78,20 @@ struct PerQualif<T>([T; QUALIF_COUNT]);\n \n impl<T: Clone> PerQualif<T> {\n     fn new(x: T) -> Self {\n-        PerQualif([x.clone(), x.clone(), x.clone(), x])\n+        PerQualif([x.clone(), x])\n     }\n }\n \n impl<T> PerQualif<T> {\n     fn as_mut(&mut self) -> PerQualif<&mut T> {\n-        let [x0, x1, x2, x3] = &mut self.0;\n-        PerQualif([x0, x1, x2, x3])\n+        let [x0, x1] = &mut self.0;\n+        PerQualif([x0, x1])\n     }\n \n     fn zip<U>(self, other: PerQualif<U>) -> PerQualif<(T, U)> {\n-        let [x0, x1, x2, x3] = self.0;\n-        let [y0, y1, y2, y3] = other.0;\n-        PerQualif([(x0, y0), (x1, y1), (x2, y2), (x3, y3)])\n+        let [x0, x1] = self.0;\n+        let [y0, y1] = other.0;\n+        PerQualif([(x0, y0), (x1, y1)])\n     }\n }\n \n@@ -429,195 +427,6 @@ impl Qualif for NeedsDrop {\n     }\n }\n \n-/// Not promotable at all - non-`const fn` calls, `asm!`,\n-/// pointer comparisons, ptr-to-int casts, etc.\n-/// Inside a const context all constness rules apply, so promotion simply has to follow the regular\n-/// constant rules (modulo interior mutability or `Drop` rules which are handled `HasMutInterior`\n-/// and `NeedsDrop` respectively). Basically this duplicates the checks that the const-checking\n-/// visitor enforces by emitting errors when working in const context.\n-struct IsNotPromotable;\n-\n-impl Qualif for IsNotPromotable {\n-    const IDX: usize = 2;\n-\n-    fn in_static(cx: &ConstCx<'_, 'tcx>, static_: &Static<'tcx>) -> bool {\n-        match static_.kind {\n-            StaticKind::Promoted(_, _) => unreachable!(),\n-            StaticKind::Static => {\n-                // Only allow statics (not consts) to refer to other statics.\n-                // FIXME(eddyb) does this matter at all for promotion?\n-                let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n-\n-                !allowed ||\n-                    cx.tcx.get_attrs(static_.def_id).iter().any(\n-                        |attr| attr.check_name(sym::thread_local)\n-                    )\n-            }\n-        }\n-    }\n-\n-    fn in_projection(\n-        cx: &ConstCx<'_, 'tcx>,\n-        place: PlaceRef<'_, 'tcx>,\n-    ) -> bool {\n-        if let [proj_base @ .., elem] = place.projection {\n-            match elem {\n-                ProjectionElem::Deref |\n-                ProjectionElem::Downcast(..) => return true,\n-\n-                ProjectionElem::ConstantIndex {..} |\n-                ProjectionElem::Subslice {..} |\n-                ProjectionElem::Index(_) => {}\n-\n-                ProjectionElem::Field(..) => {\n-                    if cx.mode == Mode::NonConstFn {\n-                        let base_ty = Place::ty_from(place.base, proj_base, cx.body, cx.tcx).ty;\n-                        if let Some(def) = base_ty.ty_adt_def() {\n-                            // No promotion of union field accesses.\n-                            if def.is_union() {\n-                                return true;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            Self::in_projection_structurally(cx, place)\n-        } else {\n-            bug!(\"This should be called if projection is not empty\");\n-        }\n-    }\n-\n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n-        match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if cx.mode == Mode::NonConstFn => {\n-                let operand_ty = operand.ty(cx.body, cx.tcx);\n-                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n-                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                match (cast_in, cast_out) {\n-                    (CastTy::Ptr(_), CastTy::Int(_)) |\n-                    (CastTy::FnPtr, CastTy::Int(_)) => {\n-                        // in normal functions, mark such casts as not promotable\n-                        return true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            Rvalue::BinaryOp(op, ref lhs, _) if cx.mode == Mode::NonConstFn => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(cx.body, cx.tcx).kind {\n-                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n-                            op == BinOp::Le || op == BinOp::Lt ||\n-                            op == BinOp::Ge || op == BinOp::Gt ||\n-                            op == BinOp::Offset);\n-\n-                    // raw pointer operations are not allowed inside promoteds\n-                    return true;\n-                }\n-            }\n-\n-            Rvalue::NullaryOp(NullOp::Box, _) => return true,\n-\n-            _ => {}\n-        }\n-\n-        Self::in_rvalue_structurally(cx, rvalue)\n-    }\n-\n-    fn in_call(\n-        cx: &ConstCx<'_, 'tcx>,\n-        callee: &Operand<'tcx>,\n-        args: &[Operand<'tcx>],\n-        _return_ty: Ty<'tcx>,\n-    ) -> bool {\n-        let fn_ty = callee.ty(cx.body, cx.tcx);\n-        match fn_ty.kind {\n-            ty::FnDef(def_id, _) => {\n-                match cx.tcx.fn_sig(def_id).abi() {\n-                    Abi::RustIntrinsic |\n-                    Abi::PlatformIntrinsic => {\n-                        assert!(!cx.tcx.is_const_fn(def_id));\n-                        match &*cx.tcx.item_name(def_id).as_str() {\n-                            | \"size_of\"\n-                            | \"min_align_of\"\n-                            | \"needs_drop\"\n-                            | \"type_id\"\n-                            | \"bswap\"\n-                            | \"bitreverse\"\n-                            | \"ctpop\"\n-                            | \"cttz\"\n-                            | \"cttz_nonzero\"\n-                            | \"ctlz\"\n-                            | \"ctlz_nonzero\"\n-                            | \"wrapping_add\"\n-                            | \"wrapping_sub\"\n-                            | \"wrapping_mul\"\n-                            | \"unchecked_shl\"\n-                            | \"unchecked_shr\"\n-                            | \"rotate_left\"\n-                            | \"rotate_right\"\n-                            | \"add_with_overflow\"\n-                            | \"sub_with_overflow\"\n-                            | \"mul_with_overflow\"\n-                            | \"saturating_add\"\n-                            | \"saturating_sub\"\n-                            | \"transmute\"\n-                            | \"simd_insert\"\n-                            | \"simd_extract\"\n-                            | \"ptr_offset_from\"\n-                            => return true,\n-\n-                            _ => {}\n-                        }\n-                    }\n-                    _ => {\n-                        let is_const_fn =\n-                            cx.tcx.is_const_fn(def_id) ||\n-                            cx.tcx.is_unstable_const_fn(def_id).is_some() ||\n-                            cx.is_const_panic_fn(def_id);\n-                        if !is_const_fn {\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n-            _ => return true,\n-        }\n-\n-        Self::in_operand(cx, callee) || args.iter().any(|arg| Self::in_operand(cx, arg))\n-    }\n-}\n-\n-/// Refers to temporaries which cannot be promoted *implicitly*.\n-/// Explicit promotion happens e.g. for constant arguments declared via `rustc_args_required_const`.\n-/// Implicit promotion has almost the same rules, except that disallows `const fn` except for\n-/// those marked `#[rustc_promotable]`. This is to avoid changing a legitimate run-time operation\n-/// into a failing compile-time operation e.g. due to addresses being compared inside the function.\n-struct IsNotImplicitlyPromotable;\n-\n-impl Qualif for IsNotImplicitlyPromotable {\n-    const IDX: usize = 3;\n-\n-    fn in_call(\n-        cx: &ConstCx<'_, 'tcx>,\n-        callee: &Operand<'tcx>,\n-        args: &[Operand<'tcx>],\n-        _return_ty: Ty<'tcx>,\n-    ) -> bool {\n-        if cx.mode == Mode::NonConstFn {\n-            if let ty::FnDef(def_id, _) = callee.ty(cx.body, cx.tcx).kind {\n-                // Never promote runtime `const fn` calls of\n-                // functions without `#[rustc_promotable]`.\n-                if !cx.tcx.is_promotable_const_fn(def_id) {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        Self::in_operand(cx, callee) || args.iter().any(|arg| Self::in_operand(cx, arg))\n-    }\n-}\n-\n // Ensure the `IDX` values are sequential (`0..QUALIF_COUNT`).\n macro_rules! static_assert_seq_qualifs {\n     ($i:expr => $first:ident $(, $rest:ident)*) => {\n@@ -632,35 +441,28 @@ macro_rules! static_assert_seq_qualifs {\n     };\n }\n static_assert_seq_qualifs!(\n-    0 => HasMutInterior, NeedsDrop, IsNotPromotable, IsNotImplicitlyPromotable\n+    0 => HasMutInterior, NeedsDrop\n );\n \n impl ConstCx<'_, 'tcx> {\n     fn qualifs_in_any_value_of_ty(&self, ty: Ty<'tcx>) -> PerQualif<bool> {\n         let mut qualifs = PerQualif::default();\n         qualifs[HasMutInterior] = HasMutInterior::in_any_value_of_ty(self, ty).unwrap_or(false);\n         qualifs[NeedsDrop] = NeedsDrop::in_any_value_of_ty(self, ty).unwrap_or(false);\n-        qualifs[IsNotPromotable] = IsNotPromotable::in_any_value_of_ty(self, ty).unwrap_or(false);\n-        qualifs[IsNotImplicitlyPromotable] =\n-            IsNotImplicitlyPromotable::in_any_value_of_ty(self, ty).unwrap_or(false);\n         qualifs\n     }\n \n     fn qualifs_in_local(&self, local: Local) -> PerQualif<bool> {\n         let mut qualifs = PerQualif::default();\n         qualifs[HasMutInterior] = HasMutInterior::in_local(self, local);\n         qualifs[NeedsDrop] = NeedsDrop::in_local(self, local);\n-        qualifs[IsNotPromotable] = IsNotPromotable::in_local(self, local);\n-        qualifs[IsNotImplicitlyPromotable] = IsNotImplicitlyPromotable::in_local(self, local);\n         qualifs\n     }\n \n     fn qualifs_in_value(&self, source: ValueSource<'_, 'tcx>) -> PerQualif<bool> {\n         let mut qualifs = PerQualif::default();\n         qualifs[HasMutInterior] = HasMutInterior::in_value(self, source);\n         qualifs[NeedsDrop] = NeedsDrop::in_value(self, source);\n-        qualifs[IsNotPromotable] = IsNotPromotable::in_value(self, source);\n-        qualifs[IsNotImplicitlyPromotable] = IsNotImplicitlyPromotable::in_value(self, source);\n         qualifs\n     }\n }\n@@ -678,7 +480,6 @@ struct Checker<'a, 'tcx> {\n     rpo: ReversePostorder<'a, 'tcx>,\n \n     temp_promotion_state: IndexVec<Local, TempState>,\n-    promotion_candidates: Vec<Candidate>,\n     unchecked_promotion_candidates: Vec<Candidate>,\n \n     /// If `true`, do not emit errors to the user, merely collect them in `errors`.\n@@ -732,14 +533,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            if !temps[local].is_promotable() {\n-                cx.per_local[IsNotPromotable].insert(local);\n-            }\n-            if let LocalKind::Var = body.local_kind(local) {\n-                // Sanity check to prevent implicit and explicit promotion of\n-                // named locals\n-                assert!(cx.per_local[IsNotPromotable].contains(local));\n-            }\n         }\n \n         Checker {\n@@ -748,7 +541,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             def_id,\n             rpo,\n             temp_promotion_state: temps,\n-            promotion_candidates: vec![],\n             unchecked_promotion_candidates,\n             errors: vec![],\n             suppress_errors: false,\n@@ -794,16 +586,15 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         let mut qualifs = self.qualifs_in_value(source);\n \n         match source {\n-            ValueSource::Rvalue(&Rvalue::Ref(_, kind, ref place)) => {\n+            ValueSource::Rvalue(&Rvalue::Ref(_, kind, _)) => {\n                 // Getting `true` from `HasMutInterior::in_rvalue` means\n                 // the borrowed place is disallowed from being borrowed,\n                 // due to either a mutable borrow (with some exceptions),\n                 // or an shared borrow of a value with interior mutability.\n-                // Then `HasMutInterior` is replaced with `IsNotPromotable`,\n+                // Then `HasMutInterior` is cleared\n                 // to avoid duplicate errors (e.g. from reborrowing).\n                 if qualifs[HasMutInterior] {\n                     qualifs[HasMutInterior] = false;\n-                    qualifs[IsNotPromotable] = true;\n \n                     debug!(\"suppress_errors: {}\", self.suppress_errors);\n                     if self.mode.requires_const_checking() && !self.suppress_errors {\n@@ -833,57 +624,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {\n-                    // Don't promote BorrowKind::Shallow borrows, as they don't\n-                    // reach codegen.\n-                    // FIXME(eddyb) the two other kinds of borrow (`Shallow` and `Unique`)\n-                    // aren't promoted here but *could* be promoted as part of a larger\n-                    // value because `IsNotPromotable` isn't being set for them,\n-                    // need to figure out what is the intended behavior.\n-\n-                    // We might have a candidate for promotion.\n-                    let candidate = Candidate::Ref(location);\n-                    // Start by traversing to the \"base\", with non-deref projections removed.\n-                    let deref_proj =\n-                        place.projection.iter().rev().find(|&elem| *elem == ProjectionElem::Deref);\n-\n-                    debug!(\n-                        \"qualify_consts: promotion candidate: place={:?} {:?}\",\n-                        place.base, deref_proj\n-                    );\n-                    // We can only promote interior borrows of promotable temps (non-temps\n-                    // don't get promoted anyway).\n-                    // (If we bailed out of the loop due to a `Deref` above, we will definitely\n-                    // not enter the conditional here.)\n-                    if let (PlaceBase::Local(local), None) = (&place.base, deref_proj) {\n-                        if self.body.local_kind(*local) == LocalKind::Temp {\n-                            debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n-                            // The borrowed place doesn't have `HasMutInterior`\n-                            // (from `in_rvalue`), so we can safely ignore\n-                            // `HasMutInterior` from the local's qualifications.\n-                            // This allows borrowing fields which don't have\n-                            // `HasMutInterior`, from a type that does, e.g.:\n-                            // `let _: &'static _ = &(Cell::new(1), 2).1;`\n-                            let mut local_qualifs = self.qualifs_in_local(*local);\n-                            // Any qualifications, except HasMutInterior (see above), disqualify\n-                            // from promotion.\n-                            // This is, in particular, the \"implicit promotion\" version of\n-                            // the check making sure that we don't run drop glue during const-eval.\n-                            local_qualifs[HasMutInterior] = false;\n-                            if !local_qualifs.0.iter().any(|&qualif| qualif) {\n-                                debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n-                                self.promotion_candidates.push(candidate);\n-                            }\n-                        }\n-                    }\n-                }\n-            },\n-            ValueSource::Rvalue(&Rvalue::Repeat(ref operand, _)) => {\n-                debug!(\"assign: self.cx.mode={:?} self.def_id={:?} location={:?} operand={:?}\",\n-                       self.cx.mode, self.def_id, location, operand);\n-                if self.should_promote_repeat_expression(operand) &&\n-                        self.tcx.features().const_in_array_repeat_expressions {\n-                    self.promotion_candidates.push(Candidate::Repeat(location));\n                 }\n             },\n             _ => {},\n@@ -939,18 +679,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 per_local.insert(index);\n             }\n         }\n-\n-        // Ensure the `IsNotPromotable` qualification is preserved.\n-        // NOTE(eddyb) this is actually unnecessary right now, as\n-        // we never replace the local's qualif, but we might in\n-        // the future, and so it serves to catch changes that unset\n-        // important bits (in which case, asserting `contains` could\n-        // be replaced with calling `insert` to re-set the bit).\n-        if kind == LocalKind::Temp {\n-            if !self.temp_promotion_state[index].is_promotable() {\n-                assert!(self.cx.per_local[IsNotPromotable].contains(index));\n-            }\n-        }\n     }\n \n     /// Check a whole const, static initializer or const fn.\n@@ -1047,24 +775,25 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         // Collect all the temps we need to promote.\n         let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n \n-        // HACK(eddyb) don't try to validate promotion candidates if any\n-        // parts of the control-flow graph were skipped due to an error.\n-        let promotion_candidates = if has_controlflow_error {\n-            let unleash_miri = self\n-                .tcx\n-                .sess\n-                .opts\n-                .debugging_opts\n-                .unleash_the_miri_inside_of_you;\n-            if !unleash_miri {\n-                self.tcx.sess.delay_span_bug(\n-                    body.span,\n-                    \"check_const: expected control-flow error(s)\",\n-                );\n-            }\n-            self.promotion_candidates.clone()\n+        // HACK: if parts of the control-flow graph were skipped due to an error, don't try to\n+        // promote anything, since that can cause errors in a `const` if e.g. rvalue static\n+        // promotion is attempted within a loop body.\n+        let unleash_miri = self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n+        let promotion_candidates = if has_controlflow_error && !unleash_miri {\n+            self.tcx.sess.delay_span_bug(\n+                body.span,\n+                \"check_const: expected control-flow error(s)\",\n+            );\n+\n+            vec![]\n         } else {\n-            self.valid_promotion_candidates()\n+            promote_consts::validate_candidates(\n+                self.tcx,\n+                self.body,\n+                self.def_id,\n+                &self.temp_promotion_state,\n+                &self.unchecked_promotion_candidates,\n+            )\n         };\n \n         debug!(\"qualify_const: promotion_candidates={:?}\", promotion_candidates);\n@@ -1086,68 +815,9 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             }\n         }\n \n-        let mut qualifs = self.qualifs_in_local(RETURN_PLACE);\n-\n-        // Account for errors in consts by using the\n-        // conservative type qualification instead.\n-        if qualifs[IsNotPromotable] {\n-            qualifs = self.qualifs_in_any_value_of_ty(body.return_ty());\n-        }\n-\n+        let qualifs = self.qualifs_in_local(RETURN_PLACE);\n         (qualifs.encode_to_bits(), self.tcx.arena.alloc(promoted_temps))\n     }\n-\n-    /// Get the subset of `unchecked_promotion_candidates` that are eligible\n-    /// for promotion.\n-    // FIXME(eddyb) replace the old candidate gathering with this.\n-    fn valid_promotion_candidates(&self) -> Vec<Candidate> {\n-        // Sanity-check the promotion candidates.\n-        let candidates = promote_consts::validate_candidates(\n-            self.tcx,\n-            self.body,\n-            self.def_id,\n-            &self.temp_promotion_state,\n-            &self.unchecked_promotion_candidates,\n-        );\n-\n-        if candidates != self.promotion_candidates {\n-            let report = |msg, candidate| {\n-                let span = match candidate {\n-                    Candidate::Ref(loc) |\n-                    Candidate::Repeat(loc) => self.body.source_info(loc).span,\n-                    Candidate::Argument { bb, .. } => {\n-                        self.body[bb].terminator().source_info.span\n-                    }\n-                };\n-                self.tcx.sess.span_err(span, &format!(\"{}: {:?}\", msg, candidate));\n-            };\n-\n-            for &c in &self.promotion_candidates {\n-                if !candidates.contains(&c) {\n-                    report(\"invalidated old candidate\", c);\n-                }\n-            }\n-\n-            for &c in &candidates {\n-                if !self.promotion_candidates.contains(&c) {\n-                    report(\"extra new candidate\", c);\n-                }\n-            }\n-\n-            bug!(\"promotion candidate validation mismatches (see above)\");\n-        }\n-\n-        candidates\n-    }\n-\n-    /// Returns `true` if the operand of a repeat expression is promotable.\n-    fn should_promote_repeat_expression(&self, operand: &Operand<'tcx>) -> bool {\n-        let not_promotable = IsNotImplicitlyPromotable::in_operand(self, operand) ||\n-                             IsNotPromotable::in_operand(self, operand);\n-        debug!(\"should_promote_repeat_expression: operand={:?} not_promotable={:?}\",\n-               operand, not_promotable);\n-        !not_promotable\n-    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n@@ -1459,11 +1129,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             }\n \n             let fn_ty = func.ty(self.body, self.tcx);\n-            let mut callee_def_id = None;\n-            let mut is_shuffle = false;\n             match fn_ty.kind {\n                 ty::FnDef(def_id, _) => {\n-                    callee_def_id = Some(def_id);\n                     match self.tcx.fn_sig(def_id).abi() {\n                         Abi::RustIntrinsic |\n                         Abi::PlatformIntrinsic => {\n@@ -1487,10 +1154,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     }\n                                 }\n \n-                                name if name.starts_with(\"simd_shuffle\") => {\n-                                    is_shuffle = true;\n-                                }\n-\n                                 // no need to check feature gates, intrinsics are only callable\n                                 // from the libstd or with forever unstable feature gates\n                                 _ => {}\n@@ -1578,36 +1241,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 }\n             }\n \n-            // No need to do anything in constants and statics, as everything is \"constant\" anyway\n-            // so promotion would be useless.\n-            if self.mode != Mode::Static && self.mode != Mode::Const {\n-                let constant_args = callee_def_id.and_then(|id| {\n-                    args_required_const(self.tcx, id)\n-                }).unwrap_or_default();\n-                for (i, arg) in args.iter().enumerate() {\n-                    if !(is_shuffle && i == 2 || constant_args.contains(&i)) {\n-                        continue;\n-                    }\n-\n-                    let candidate = Candidate::Argument { bb: location.block, index: i };\n-                    // Since the argument is required to be constant,\n-                    // we care about constness, not promotability.\n-                    // If we checked for promotability, we'd miss out on\n-                    // the results of function calls (which are never promoted\n-                    // in runtime code).\n-                    // This is not a problem, because the argument explicitly\n-                    // requests constness, in contrast to regular promotion\n-                    // which happens even without the user requesting it.\n-                    //\n-                    // `promote_consts` is responsible for emitting the error if\n-                    // the argument is not promotable.\n-                    if !IsNotPromotable::in_operand(self, arg) {\n-                        debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n-                        self.promotion_candidates.push(candidate);\n-                    }\n-                }\n-            }\n-\n             // Check callee and argument operands.\n             self.visit_operand(func, location);\n             for arg in args {\n@@ -1711,7 +1344,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n \n // FIXME(eddyb) this is only left around for the validation logic\n // in `promote_consts`, see the comment in `validate_operand`.\n-pub(super) const QUALIF_ERROR_BIT: u8 = 1 << IsNotPromotable::IDX;\n+pub(super) const QUALIF_ERROR_BIT: u8 = 1 << 2;\n \n fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n@@ -1759,39 +1392,42 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants<'tcx> {\n \n         debug!(\"run_pass: mode={:?}\", mode);\n         if let Mode::NonConstFn | Mode::ConstFn = mode {\n-            // This is ugly because Checker holds onto mir,\n-            // which can't be mutated until its scope ends.\n-            let (temps, candidates) = {\n-                let mut checker = Checker::new(tcx, def_id, body, mode);\n-                if let Mode::ConstFn = mode {\n-                    let use_min_const_fn_checks =\n-                        !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n-                        tcx.is_min_const_fn(def_id);\n-                    if use_min_const_fn_checks {\n-                        // Enforce `min_const_fn` for stable `const fn`s.\n-                        use super::qualify_min_const_fn::is_min_const_fn;\n-                        if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n-                            error_min_const_fn_violation(tcx, span, err);\n-                            return;\n-                        }\n-\n-                        // `check_const` should not produce any errors, but better safe than sorry\n-                        // FIXME(#53819)\n-                        // NOTE(eddyb) `check_const` is actually needed for promotion inside\n-                        // `min_const_fn` functions.\n+            let mut checker = Checker::new(tcx, def_id, body, mode);\n+            if let Mode::ConstFn = mode {\n+                let use_min_const_fn_checks =\n+                    !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n+                    tcx.is_min_const_fn(def_id);\n+                if use_min_const_fn_checks {\n+                    // Enforce `min_const_fn` for stable `const fn`s.\n+                    use super::qualify_min_const_fn::is_min_const_fn;\n+                    if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n+                        error_min_const_fn_violation(tcx, span, err);\n+                        return;\n                     }\n \n-                    // Enforce a constant-like CFG for `const fn`.\n-                    checker.check_const();\n-                } else {\n-                    while let Some((bb, data)) = checker.rpo.next() {\n-                        checker.visit_basic_block_data(bb, data);\n-                    }\n+                    // `check_const` should not produce any errors, but better safe than sorry\n+                    // FIXME(#53819)\n+                    // NOTE(eddyb) `check_const` is actually needed for promotion inside\n+                    // `min_const_fn` functions.\n                 }\n \n-                let promotion_candidates = checker.valid_promotion_candidates();\n-                (checker.temp_promotion_state, promotion_candidates)\n-            };\n+                // Enforce a constant-like CFG for `const fn`.\n+                checker.check_const();\n+            } else {\n+                while let Some((bb, data)) = checker.rpo.next() {\n+                    checker.visit_basic_block_data(bb, data);\n+                }\n+            }\n+\n+            // Promote only the promotable candidates.\n+            let temps = checker.temp_promotion_state;\n+            let candidates = promote_consts::validate_candidates(\n+                tcx,\n+                body,\n+                def_id,\n+                &temps,\n+                &checker.unchecked_promotion_candidates,\n+            );\n \n             // Do the actual promotion, now that we know what's viable.\n             self.promoted.set(\n@@ -1912,19 +1548,6 @@ fn check_static_is_sync(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, hir_id: HirId)\n     });\n }\n \n-fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<FxHashSet<usize>> {\n-    let attrs = tcx.get_attrs(def_id);\n-    let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n-    let mut ret = FxHashSet::default();\n-    for meta in attr.meta_item_list()? {\n-        match meta.literal()?.kind {\n-            LitKind::Int(a, _) => { ret.insert(a as usize); }\n-            _ => return None,\n-        }\n-    }\n-    Some(ret)\n-}\n-\n fn validator_mismatch(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,"}, {"sha": "f4661e9e425baf657ba265ee78794bbd3dccd0c1", "filename": "src/test/ui/consts/const_let_promote.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/76ade3e8ac42cd7a7b7c3c5ef54818ab68e3ebdc/src%2Ftest%2Fui%2Fconsts%2Fconst_let_promote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ade3e8ac42cd7a7b7c3c5ef54818ab68e3ebdc/src%2Ftest%2Fui%2Fconsts%2Fconst_let_promote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_promote.rs?ref=76ade3e8ac42cd7a7b7c3c5ef54818ab68e3ebdc", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+use std::cell::Cell;\n+\n+const X: Option<Cell<i32>> = None;\n+\n+const Y: Option<Cell<i32>> = {\n+    let x = None;\n+    x\n+};\n+\n+// Ensure that binding the final value of a `const` to a variable does not affect promotion.\n+#[allow(unused)]\n+fn main() {\n+    let x: &'static _ = &X;\n+    let y: &'static _ = &Y;\n+}"}]}