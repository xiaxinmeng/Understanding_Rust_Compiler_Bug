{"sha": "a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZDI0MjRjYzMwNGU5N2Y1NTNjNmQ4ZWVmMTdhMjRkYzJmMTJjMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-10T04:31:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-10T04:31:55Z"}, "message": "Auto merge of #33443 - jseyfried:resolve_ast, r=nrc\n\nPerform name resolution before and during ast->hir lowering\n\nThis PR performs name resolution before and during ast->hir lowering instead of in phase 3.\nr? @nrc", "tree": {"sha": "1660cb8661456bbfb7b9b52c2d98a046e30d6a4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1660cb8661456bbfb7b9b52c2d98a046e30d6a4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "html_url": "https://github.com/rust-lang/rust/commit/a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72ed7e78942e8d68f87cc7299625fb236f442ef1", "url": "https://api.github.com/repos/rust-lang/rust/commits/72ed7e78942e8d68f87cc7299625fb236f442ef1", "html_url": "https://github.com/rust-lang/rust/commit/72ed7e78942e8d68f87cc7299625fb236f442ef1"}, {"sha": "805666a4d283b60f9f4b979b53b3d498cd876f2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/805666a4d283b60f9f4b979b53b3d498cd876f2e", "html_url": "https://github.com/rust-lang/rust/commit/805666a4d283b60f9f4b979b53b3d498cd876f2e"}], "stats": {"total": 1261, "additions": 706, "deletions": 555}, "files": [{"sha": "0026412013c8eb881a8966d47e034fcf879ec09b", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 91, "deletions": 70, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -43,7 +43,8 @@\n use hir;\n use hir::map::Definitions;\n use hir::map::definitions::DefPathData;\n-use hir::def_id::DefIndex;\n+use hir::def_id::{DefIndex, DefId};\n+use hir::def::Def;\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -63,19 +64,40 @@ pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n     id_assigner: &'a NodeIdAssigner,\n-    // We must keep the set of definitions up to date as we add nodes that\n-    // weren't in the AST.\n-    definitions: Option<&'a RefCell<Definitions>>,\n     // As we walk the AST we must keep track of the current 'parent' def id (in\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n     parent_def: Cell<Option<DefIndex>>,\n+    resolver: RefCell<&'a mut Resolver>,\n+}\n+\n+pub trait Resolver {\n+    // Resolve a global hir path generated by the lowerer when expanding `for`, `if let`, etc.\n+    fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def;\n+\n+    // Record the resolution of a path or binding generated by the lowerer when expanding.\n+    fn record_resolution(&mut self, id: NodeId, def: Def);\n+\n+    // We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n+    // This should only return `None` during testing.\n+    fn definitions(&mut self) -> Option<&mut Definitions>;\n+}\n+\n+pub struct DummyResolver;\n+impl Resolver for DummyResolver {\n+    fn resolve_generated_global_path(&mut self, _path: &hir::Path, _is_value: bool) -> Def {\n+        Def::Err\n+    }\n+    fn record_resolution(&mut self, _id: NodeId, _def: Def) {}\n+    fn definitions(&mut self) -> Option<&mut Definitions> {\n+        None\n+    }\n }\n \n impl<'a, 'hir> LoweringContext<'a> {\n     pub fn new(id_assigner: &'a NodeIdAssigner,\n                c: Option<&Crate>,\n-               defs: &'a RefCell<Definitions>)\n+               resolver: &'a mut Resolver)\n                -> LoweringContext<'a> {\n         let crate_root = c.and_then(|c| {\n             if std_inject::no_core(c) {\n@@ -90,19 +112,8 @@ impl<'a, 'hir> LoweringContext<'a> {\n         LoweringContext {\n             crate_root: crate_root,\n             id_assigner: id_assigner,\n-            definitions: Some(defs),\n-            parent_def: Cell::new(None),\n-        }\n-    }\n-\n-    // Only use this when you want a LoweringContext for testing and won't look\n-    // up def ids for anything created during lowering.\n-    pub fn testing_context(id_assigner: &'a NodeIdAssigner) -> LoweringContext<'a> {\n-        LoweringContext {\n-            crate_root: None,\n-            id_assigner: id_assigner,\n-            definitions: None,\n             parent_def: Cell::new(None),\n+            resolver: RefCell::new(resolver),\n         }\n     }\n \n@@ -120,23 +131,17 @@ impl<'a, 'hir> LoweringContext<'a> {\n     }\n \n     fn with_parent_def<T, F: FnOnce() -> T>(&self, parent_id: NodeId, f: F) -> T {\n-        if self.definitions.is_none() {\n-            // This should only be used for testing.\n-            return f();\n-        }\n-\n         let old_def = self.parent_def.get();\n-        self.parent_def.set(Some(self.get_def(parent_id)));\n+        self.parent_def.set(match self.resolver.borrow_mut().definitions() {\n+            Some(defs) => Some(defs.opt_def_index(parent_id).unwrap()),\n+            None => old_def,\n+        });\n+\n         let result = f();\n-        self.parent_def.set(old_def);\n \n+        self.parent_def.set(old_def);\n         result\n     }\n-\n-    fn get_def(&self, id: NodeId) -> DefIndex {\n-        let defs = self.definitions.unwrap().borrow();\n-        defs.opt_def_index(id).unwrap()\n-    }\n }\n \n pub fn lower_ident(_lctx: &LoweringContext, ident: Ident) -> hir::Ident {\n@@ -999,7 +1004,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 };\n \n                 // let placer = <placer_expr> ;\n-                let s1 = {\n+                let (s1, placer_binding) = {\n                     let placer_expr = signal_block_expr(lctx,\n                                                         hir_vec![],\n                                                         placer_expr,\n@@ -1010,15 +1015,15 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 };\n \n                 // let mut place = Placer::make_place(placer);\n-                let s2 = {\n-                    let placer = expr_ident(lctx, e.span, placer_ident, None);\n+                let (s2, place_binding) = {\n+                    let placer = expr_ident(lctx, e.span, placer_ident, None, placer_binding);\n                     let call = make_call(lctx, &make_place, hir_vec![placer]);\n                     mk_stmt_let_mut(lctx, place_ident, call)\n                 };\n \n                 // let p_ptr = Place::pointer(&mut place);\n-                let s3 = {\n-                    let agent = expr_ident(lctx, e.span, place_ident, None);\n+                let (s3, p_ptr_binding) = {\n+                    let agent = expr_ident(lctx, e.span, place_ident, None, place_binding);\n                     let args = hir_vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n                     let call = make_call(lctx, &place_pointer, args);\n                     mk_stmt_let(lctx, p_ptr_ident, call)\n@@ -1044,14 +1049,14 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     InPlace::finalize(place)\n                 // })\n                 let expr = {\n-                    let ptr = expr_ident(lctx, e.span, p_ptr_ident, None);\n+                    let ptr = expr_ident(lctx, e.span, p_ptr_ident, None, p_ptr_binding);\n                     let call_move_val_init =\n                         hir::StmtSemi(\n                             make_call(lctx, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n                             lctx.next_id());\n                     let call_move_val_init = respan(e.span, call_move_val_init);\n \n-                    let place = expr_ident(lctx, e.span, place_ident, None);\n+                    let place = expr_ident(lctx, e.span, place_ident, None, place_binding);\n                     let call = make_call(lctx, &inplace_finalize, hir_vec![place]);\n                     signal_block_expr(lctx,\n                                       hir_vec![call_move_val_init],\n@@ -1438,7 +1443,8 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 let loop_expr = hir::ExprLoop(loop_block,\n                                               opt_ident.map(|ident| lower_ident(lctx, ident)));\n                 // add attributes to the outer returned expr node\n-                return expr(lctx, e.span, loop_expr, e.attrs.clone());\n+                let attrs = e.attrs.clone();\n+                return P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: attrs });\n             }\n \n             // Desugar ExprForLoop\n@@ -1488,14 +1494,18 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     arm(hir_vec![pat_none(lctx, e.span)], break_expr)\n                 };\n \n+                // `mut iter`\n+                let iter_pat =\n+                    pat_ident_binding_mode(lctx, e.span, iter, hir::BindByValue(hir::MutMutable));\n+\n                 // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                 let match_expr = {\n                     let next_path = {\n                         let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n \n                         path_global(e.span, strs)\n                     };\n-                    let iter = expr_ident(lctx, e.span, iter, None);\n+                    let iter = expr_ident(lctx, e.span, iter, None, iter_pat.id);\n                     let ref_mut_iter = expr_mut_addr_of(lctx, e.span, iter, None);\n                     let next_path = expr_path(lctx, next_path, None);\n                     let next_expr = expr_call(lctx,\n@@ -1515,16 +1525,11 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 let loop_block = block_expr(lctx, match_expr);\n                 let loop_expr = hir::ExprLoop(loop_block,\n                                               opt_ident.map(|ident| lower_ident(lctx, ident)));\n-                let loop_expr = expr(lctx, e.span, loop_expr, None);\n+                let loop_expr =\n+                    P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: None });\n \n                 // `mut iter => { ... }`\n-                let iter_arm = {\n-                    let iter_pat = pat_ident_binding_mode(lctx,\n-                                                          e.span,\n-                                                          iter,\n-                                                          hir::BindByValue(hir::MutMutable));\n-                    arm(hir_vec![iter_pat], loop_expr)\n-                };\n+                let iter_arm = arm(hir_vec![iter_pat], loop_expr);\n \n                 // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                 let into_iter_expr = {\n@@ -1548,13 +1553,10 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 // `{ let _result = ...; _result }`\n                 // underscore prevents an unused_variables lint if the head diverges\n                 let result_ident = lctx.str_to_ident(\"_result\");\n-                let let_stmt = stmt_let(lctx,\n-                                        e.span,\n-                                        false,\n-                                        result_ident,\n-                                        match_expr,\n-                                        None);\n-                let result = expr_ident(lctx, e.span, result_ident, None);\n+                let (let_stmt, let_stmt_binding) =\n+                    stmt_let(lctx, e.span, false, result_ident, match_expr, None);\n+\n+                let result = expr_ident(lctx, e.span, result_ident, None, let_stmt_binding);\n                 let block = block_all(lctx, e.span, hir_vec![let_stmt], Some(result));\n                 // add the attributes to the outer returned expr node\n                 return expr_block(lctx, block, e.attrs.clone());\n@@ -1581,7 +1583,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 let ok_arm = {\n                     let val_ident = lctx.str_to_ident(\"val\");\n                     let val_pat = pat_ident(lctx, e.span, val_ident);\n-                    let val_expr = expr_ident(lctx, e.span, val_ident, None);\n+                    let val_expr = expr_ident(lctx, e.span, val_ident, None, val_pat.id);\n                     let ok_pat = pat_ok(lctx, e.span, val_pat);\n \n                     arm(hir_vec![ok_pat], val_expr)\n@@ -1590,11 +1592,12 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 // Err(err) => return Err(From::from(err))\n                 let err_arm = {\n                     let err_ident = lctx.str_to_ident(\"err\");\n+                    let err_local = pat_ident(lctx, e.span, err_ident);\n                     let from_expr = {\n                         let path = std_path(lctx, &[\"convert\", \"From\", \"from\"]);\n                         let path = path_global(e.span, path);\n                         let from = expr_path(lctx, path, None);\n-                        let err_expr = expr_ident(lctx, e.span, err_ident, None);\n+                        let err_expr = expr_ident(lctx, e.span, err_ident, None, err_local.id);\n \n                         expr_call(lctx, e.span, from, hir_vec![err_expr], None)\n                     };\n@@ -1604,8 +1607,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let err_ctor = expr_path(lctx, path, None);\n                         expr_call(lctx, e.span, err_ctor, hir_vec![from_expr], None)\n                     };\n-                    let err_pat = pat_err(lctx, e.span,\n-                                          pat_ident(lctx, e.span, err_ident));\n+                    let err_pat = pat_err(lctx, e.span, err_local);\n                     let ret_expr = expr(lctx, e.span,\n                                         hir::Expr_::ExprRet(Some(err_expr)), None);\n \n@@ -1745,8 +1747,15 @@ fn expr_call(lctx: &LoweringContext,\n }\n \n fn expr_ident(lctx: &LoweringContext, span: Span, id: hir::Ident,\n-              attrs: ThinAttributes) -> P<hir::Expr> {\n-    expr_path(lctx, path_ident(span, id), attrs)\n+              attrs: ThinAttributes, binding: NodeId) -> P<hir::Expr> {\n+    let expr = expr(lctx, span, hir::ExprPath(None, path_ident(span, id)), attrs);\n+\n+    let mut resolver = lctx.resolver.borrow_mut();\n+    let def = resolver.definitions().map(|defs| Def::Local(defs.local_def_id(binding), binding))\n+                                    .unwrap_or(Def::Err);\n+    resolver.record_resolution(expr.id, def);\n+\n+    expr\n }\n \n fn expr_mut_addr_of(lctx: &LoweringContext, span: Span, e: P<hir::Expr>,\n@@ -1756,7 +1765,10 @@ fn expr_mut_addr_of(lctx: &LoweringContext, span: Span, e: P<hir::Expr>,\n \n fn expr_path(lctx: &LoweringContext, path: hir::Path,\n              attrs: ThinAttributes) -> P<hir::Expr> {\n-    expr(lctx, path.span, hir::ExprPath(None, path), attrs)\n+    let def = lctx.resolver.borrow_mut().resolve_generated_global_path(&path, true);\n+    let expr = expr(lctx, path.span, hir::ExprPath(None, path), attrs);\n+    lctx.resolver.borrow_mut().record_resolution(expr.id, def);\n+    expr\n }\n \n fn expr_match(lctx: &LoweringContext,\n@@ -1785,7 +1797,11 @@ fn expr_struct(lctx: &LoweringContext,\n                fields: hir::HirVec<hir::Field>,\n                e: Option<P<hir::Expr>>,\n                attrs: ThinAttributes) -> P<hir::Expr> {\n-    expr(lctx, sp, hir::ExprStruct(path, fields, e), attrs)\n+    let def = lctx.resolver.borrow_mut().resolve_generated_global_path(&path, false);\n+    let expr = expr(lctx, sp, hir::ExprStruct(path, fields, e), attrs);\n+    lctx.resolver.borrow_mut().record_resolution(expr.id, def);\n+    expr\n+\n }\n \n fn expr(lctx: &LoweringContext, span: Span, node: hir::Expr_,\n@@ -1804,12 +1820,13 @@ fn stmt_let(lctx: &LoweringContext,\n             ident: hir::Ident,\n             ex: P<hir::Expr>,\n             attrs: ThinAttributes)\n-            -> hir::Stmt {\n+            -> (hir::Stmt, NodeId) {\n     let pat = if mutbl {\n         pat_ident_binding_mode(lctx, sp, ident, hir::BindByValue(hir::MutMutable))\n     } else {\n         pat_ident(lctx, sp, ident)\n     };\n+    let pat_id = pat.id;\n     let local = P(hir::Local {\n         pat: pat,\n         ty: None,\n@@ -1819,7 +1836,7 @@ fn stmt_let(lctx: &LoweringContext,\n         attrs: attrs,\n     });\n     let decl = respan(sp, hir::DeclLocal(local));\n-    respan(sp, hir::StmtDecl(P(decl), lctx.next_id()))\n+    (respan(sp, hir::StmtDecl(P(decl), lctx.next_id())), pat_id)\n }\n \n fn block_expr(lctx: &LoweringContext, expr: P<hir::Expr>) -> P<hir::Block> {\n@@ -1869,12 +1886,15 @@ fn pat_enum(lctx: &LoweringContext,\n             path: hir::Path,\n             subpats: hir::HirVec<P<hir::Pat>>)\n             -> P<hir::Pat> {\n+    let def = lctx.resolver.borrow_mut().resolve_generated_global_path(&path, true);\n     let pt = if subpats.is_empty() {\n         hir::PatKind::Path(path)\n     } else {\n         hir::PatKind::TupleStruct(path, Some(subpats))\n     };\n-    pat(lctx, span, pt)\n+    let pat = pat(lctx, span, pt);\n+    lctx.resolver.borrow_mut().record_resolution(pat.id, def);\n+    pat\n }\n \n fn pat_ident(lctx: &LoweringContext, span: Span, ident: hir::Ident) -> P<hir::Pat> {\n@@ -1895,12 +1915,13 @@ fn pat_ident_binding_mode(lctx: &LoweringContext,\n \n     let pat = pat(lctx, span, pat_ident);\n \n-    if let Some(defs) = lctx.definitions {\n-        let mut defs = defs.borrow_mut();\n-        defs.create_def_with_parent(lctx.parent_def.get(),\n-                                    pat.id,\n-                                    DefPathData::Binding(ident.name));\n-    }\n+    let mut resolver = lctx.resolver.borrow_mut();\n+    let def = resolver.definitions().map(|defs| {\n+        let def_path_data = DefPathData::Binding(ident.name);\n+        let def_index = defs.create_def_with_parent(lctx.parent_def.get(), pat.id, def_path_data);\n+        Def::Local(DefId::local(def_index), pat.id)\n+    }).unwrap_or(Def::Err);\n+    resolver.record_resolution(pat.id, def);\n \n     pat\n }"}, {"sha": "358301ab4042a2f3a085287cc6268da8916de59a", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -195,6 +195,10 @@ impl Definitions {\n         self.opt_def_index(node).map(DefId::local)\n     }\n \n+    pub fn local_def_id(&self, node: ast::NodeId) -> DefId {\n+        self.opt_local_def_id(node).unwrap()\n+    }\n+\n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n             assert!(def_id.index.as_usize() < self.data.len());"}, {"sha": "97c438838190825221fe6864fd30344629a9612e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -1639,6 +1639,7 @@ pub type FreevarMap = NodeMap<Vec<Freevar>>;\n \n pub type CaptureModeMap = NodeMap<CaptureClause>;\n \n+#[derive(Clone)]\n pub struct TraitCandidate {\n     pub def_id: DefId,\n     pub import_id: Option<NodeId>,"}, {"sha": "700ed62f216d309eeefbd407e40a10bee6c7ebbd", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -108,6 +108,7 @@ pub type Disr = ConstInt;\n \n /// The complete set of all analyses described in this module. This is\n /// produced by the driver and fed to trans and later passes.\n+#[derive(Clone)]\n pub struct CrateAnalysis<'a> {\n     pub export_map: ExportMap,\n     pub access_levels: middle::privacy::AccessLevels,"}, {"sha": "e72204e5e22de2fa36a89400a3610d691a050392", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 71, "deletions": 38, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -10,7 +10,8 @@\n \n use rustc::dep_graph::DepGraph;\n use rustc::hir;\n-use rustc::hir::map as hir_map;\n+use rustc::hir::{map as hir_map, FreevarMap, TraitMap};\n+use rustc::hir::def::DefMap;\n use rustc_mir as mir;\n use rustc::mir::mir_map::MirMap;\n use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n@@ -60,6 +61,14 @@ use syntax::visit;\n use syntax;\n use syntax_ext;\n \n+#[derive(Clone)]\n+pub struct Resolutions {\n+    pub def_map: RefCell<DefMap>,\n+    pub freevars: FreevarMap,\n+    pub trait_map: TraitMap,\n+    pub maybe_unused_trait_imports: NodeSet,\n+}\n+\n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n                      cfg: ast::CrateConfig,\n@@ -139,15 +148,17 @@ pub fn compile_input(sess: &Session,\n \n         time(sess.time_passes(),\n              \"external crate/lib resolution\",\n-             || LocalCrateReader::new(sess, &cstore, &defs, &expanded_crate, &id)\n+             || LocalCrateReader::new(sess, &cstore, defs, &expanded_crate, &id)\n                     .read_crates(&dep_graph));\n \n-        // Lower ast -> hir.\n-        let lcx = LoweringContext::new(sess, Some(&expanded_crate), defs);\n-        let hir_forest = &mut time(sess.time_passes(),\n-                                   \"lowering ast -> hir\",\n-                                   || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate),\n-                                                           dep_graph));\n+        time(sess.time_passes(),\n+             \"early lint checks\",\n+             || lint::check_ast_crate(sess, &expanded_crate));\n+\n+        let (analysis, resolutions, mut hir_forest) = {\n+            let defs = &mut *defs.borrow_mut();\n+            lower_and_resolve(sess, &id, defs, &expanded_crate, dep_graph, control.make_glob_map)\n+        };\n \n         // Discard MTWT tables that aren't required past lowering to HIR.\n         if !keep_mtwt_tables(sess) {\n@@ -157,6 +168,7 @@ pub fn compile_input(sess: &Session,\n         let arenas = ty::CtxtArenas::new();\n \n         // Construct the HIR map\n+        let hir_forest = &mut hir_forest;\n         let hir_map = time(sess.time_passes(),\n                            \"indexing hir\",\n                            move || hir_map::map_crate(hir_forest, defs));\n@@ -175,6 +187,8 @@ pub fn compile_input(sess: &Session,\n                                                                          &arenas,\n                                                                          &cstore,\n                                                                          &hir_map,\n+                                                                         &analysis,\n+                                                                         &resolutions,\n                                                                          &expanded_crate,\n                                                                          &hir_map.krate(),\n                                                                          &id),\n@@ -185,10 +199,6 @@ pub fn compile_input(sess: &Session,\n             hir::check_attr::check_crate(sess, &expanded_crate);\n         });\n \n-        time(sess.time_passes(),\n-             \"early lint checks\",\n-             || lint::check_ast_crate(sess, &expanded_crate));\n-\n         let opt_crate = if keep_ast(sess) {\n             Some(&expanded_crate)\n         } else {\n@@ -198,9 +208,10 @@ pub fn compile_input(sess: &Session,\n \n         phase_3_run_analysis_passes(sess,\n                                     hir_map,\n+                                    analysis,\n+                                    resolutions,\n                                     &arenas,\n                                     &id,\n-                                    control.make_glob_map,\n                                     |tcx, mir_map, analysis, result| {\n             {\n                 // Eventually, we will want to track plugins.\n@@ -353,6 +364,7 @@ pub struct CompileState<'a, 'b, 'ast: 'a, 'tcx: 'b> where 'ast: 'tcx {\n     pub expanded_crate: Option<&'a ast::Crate>,\n     pub hir_crate: Option<&'a hir::Crate>,\n     pub ast_map: Option<&'a hir_map::Map<'ast>>,\n+    pub resolutions: Option<&'a Resolutions>,\n     pub mir_map: Option<&'b MirMap<'tcx>>,\n     pub analysis: Option<&'a ty::CrateAnalysis<'a>>,\n     pub tcx: Option<&'b TyCtxt<'tcx>>,\n@@ -377,6 +389,7 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n             expanded_crate: None,\n             hir_crate: None,\n             ast_map: None,\n+            resolutions: None,\n             analysis: None,\n             mir_map: None,\n             tcx: None,\n@@ -423,6 +436,8 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n                               arenas: &'ast ty::CtxtArenas<'ast>,\n                               cstore: &'a CStore,\n                               hir_map: &'a hir_map::Map<'ast>,\n+                              analysis: &'a ty::CrateAnalysis,\n+                              resolutions: &'a Resolutions,\n                               krate: &'a ast::Crate,\n                               hir_crate: &'a hir::Crate,\n                               crate_name: &'a str)\n@@ -432,6 +447,8 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n             arenas: Some(arenas),\n             cstore: Some(cstore),\n             ast_map: Some(hir_map),\n+            analysis: Some(analysis),\n+            resolutions: Some(resolutions),\n             expanded_crate: Some(krate),\n             hir_crate: Some(hir_crate),\n             out_file: out_file.as_ref().map(|s| &**s),\n@@ -756,14 +773,48 @@ pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     krate\n }\n \n+pub fn lower_and_resolve<'a>(sess: &Session,\n+                             id: &'a str,\n+                             defs: &mut hir_map::Definitions,\n+                             krate: &ast::Crate,\n+                             dep_graph: DepGraph,\n+                             make_glob_map: resolve::MakeGlobMap)\n+                             -> (ty::CrateAnalysis<'a>, Resolutions, hir_map::Forest) {\n+    resolve::with_resolver(sess, defs, make_glob_map, |mut resolver| {\n+        time(sess.time_passes(), \"name resolution\", || {\n+            resolve::resolve_crate(&mut resolver, krate);\n+        });\n+\n+        // Lower ast -> hir.\n+        let hir_forest = time(sess.time_passes(), \"lowering ast -> hir\", || {\n+            let lcx = LoweringContext::new(sess, Some(krate), &mut resolver);\n+            hir_map::Forest::new(lower_crate(&lcx, krate), dep_graph)\n+        });\n+\n+        (ty::CrateAnalysis {\n+            export_map: resolver.export_map,\n+            access_levels: AccessLevels::default(),\n+            reachable: NodeSet(),\n+            name: &id,\n+            glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n+        }, Resolutions {\n+            def_map: RefCell::new(resolver.def_map),\n+            freevars: resolver.freevars,\n+            trait_map: resolver.trait_map,\n+            maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n+        }, hir_forest)\n+    })\n+}\n+\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                hir_map: hir_map::Map<'tcx>,\n+                                               mut analysis: ty::CrateAnalysis,\n+                                               resolutions: Resolutions,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: &str,\n-                                               make_glob_map: resolve::MakeGlobMap,\n                                                f: F)\n                                                -> Result<R, usize>\n     where F: FnOnce(&TyCtxt<'tcx>, Option<MirMap<'tcx>>, ty::CrateAnalysis, CompileResult) -> R\n@@ -788,30 +839,11 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         })\n     })?;\n \n-    let resolve::CrateMap {\n-        def_map,\n-        freevars,\n-        maybe_unused_trait_imports,\n-        export_map,\n-        trait_map,\n-        glob_map,\n-    } = time(sess.time_passes(),\n-             \"name resolution\",\n-             || resolve::resolve_crate(sess, &hir_map, make_glob_map));\n-\n-    let mut analysis = ty::CrateAnalysis {\n-        export_map: export_map,\n-        access_levels: AccessLevels::default(),\n-        reachable: NodeSet(),\n-        name: name,\n-        glob_map: glob_map,\n-    };\n-\n     let named_region_map = time(time_passes,\n                                 \"lifetime resolution\",\n                                 || middle::resolve_lifetime::krate(sess,\n                                                                    &hir_map,\n-                                                                   &def_map.borrow()))?;\n+                                                                   &resolutions.def_map.borrow()))?;\n \n     time(time_passes,\n          \"looking for entry point\",\n@@ -831,17 +863,18 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     time(time_passes,\n               \"static item recursion checking\",\n-              || static_recursion::check_crate(sess, &def_map.borrow(), &hir_map))?;\n+              || static_recursion::check_crate(sess, &resolutions.def_map.borrow(), &hir_map))?;\n \n     let index = stability::Index::new(&hir_map);\n \n+    let trait_map = resolutions.trait_map;\n     TyCtxt::create_and_enter(sess,\n                              arenas,\n-                             def_map,\n+                             resolutions.def_map,\n                              named_region_map,\n                              hir_map,\n-                             freevars,\n-                             maybe_unused_trait_imports,\n+                             resolutions.freevars,\n+                             resolutions.maybe_unused_trait_imports,\n                              region_map,\n                              lang_items,\n                              index,"}, {"sha": "4da36be94e009bdfa1fa2efd5eb0032a364cbca0", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -469,6 +469,8 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 control.after_write_deps.callback = box move |state| {\n                     pretty::print_after_write_deps(state.session,\n                                                    state.ast_map.unwrap(),\n+                                                   state.analysis.unwrap(),\n+                                                   state.resolutions.unwrap(),\n                                                    state.input,\n                                                    &state.expanded_crate.take().unwrap(),\n                                                    state.crate_name.unwrap(),"}, {"sha": "8d8984000c7e48ccfbf8d5feff57141643f66b7e", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -15,7 +15,8 @@ pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n use self::NodesMatchingUII::*;\n \n-use {driver, abort_on_err};\n+use abort_on_err;\n+use driver::{self, Resolutions};\n \n use rustc::dep_graph::DepGraph;\n use rustc::ty::{self, TyCtxt};\n@@ -25,7 +26,6 @@ use rustc::session::Session;\n use rustc::session::config::Input;\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n-use rustc_resolve as resolve;\n \n use rustc_mir::pretty::write_mir_pretty;\n use rustc_mir::graphviz::write_mir_graphviz;\n@@ -202,6 +202,8 @@ impl PpSourceMode {\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n                                                sess: &'tcx Session,\n                                                ast_map: &hir_map::Map<'tcx>,\n+                                               analysis: &ty::CrateAnalysis,\n+                                               resolutions: &Resolutions,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                id: &str,\n                                                payload: B,\n@@ -228,9 +230,10 @@ impl PpSourceMode {\n             PpmTyped => {\n                 abort_on_err(driver::phase_3_run_analysis_passes(sess,\n                                                                  ast_map.clone(),\n+                                                                 analysis.clone(),\n+                                                                 resolutions.clone(),\n                                                                  arenas,\n                                                                  id,\n-                                                                 resolve::MakeGlobMap::No,\n                                                                  |tcx, _, _, _| {\n                     let annotation = TypedAnnotation {\n                         tcx: tcx,\n@@ -811,6 +814,8 @@ pub fn print_after_parsing(sess: &Session,\n \n pub fn print_after_write_deps<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                               ast_map: &hir_map::Map<'tcx>,\n+                                              analysis: &ty::CrateAnalysis,\n+                                              resolutions: &Resolutions,\n                                               input: &Input,\n                                               krate: &ast::Crate,\n                                               crate_name: &str,\n@@ -822,7 +827,8 @@ pub fn print_after_write_deps<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let _ignore = dep_graph.in_ignore();\n \n     if ppm.needs_analysis() {\n-        print_with_analysis(sess, ast_map, crate_name, arenas, ppm, opt_uii, ofile);\n+        print_with_analysis(sess, ast_map, analysis, resolutions,\n+                            crate_name, arenas, ppm, opt_uii, ofile);\n         return;\n     }\n \n@@ -853,6 +859,8 @@ pub fn print_after_write_deps<'tcx, 'a: 'tcx>(sess: &'a Session,\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(sess,\n                                        ast_map,\n+                                       analysis,\n+                                       resolutions,\n                                        arenas,\n                                        crate_name,\n                                        box out,\n@@ -874,6 +882,8 @@ pub fn print_after_write_deps<'tcx, 'a: 'tcx>(sess: &'a Session,\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(sess,\n                                        ast_map,\n+                                       analysis,\n+                                       resolutions,\n                                        arenas,\n                                        crate_name,\n                                        (out,uii),\n@@ -914,6 +924,8 @@ pub fn print_after_write_deps<'tcx, 'a: 'tcx>(sess: &'a Session,\n // Instead, we call that function ourselves.\n fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                        ast_map: &hir_map::Map<'tcx>,\n+                                       analysis: &ty::CrateAnalysis,\n+                                       resolutions: &Resolutions,\n                                        crate_name: &str,\n                                        arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                        ppm: PpMode,\n@@ -931,9 +943,10 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n \n     abort_on_err(driver::phase_3_run_analysis_passes(sess,\n                                                      ast_map.clone(),\n+                                                     analysis.clone(),\n+                                                     resolutions.clone(),\n                                                      arenas,\n                                                      crate_name,\n-                                                     resolve::MakeGlobMap::No,\n                                                      |tcx, mir_map, _, _| {\n         match ppm {\n             PpmMir | PpmMirCFG => {"}, {"sha": "869bbb723ef41f0ca42d9eb259f1c0cf862fc393", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -13,7 +13,7 @@\n use driver;\n use rustc::dep_graph::DepGraph;\n use rustc_lint;\n-use rustc_resolve as resolve;\n+use rustc_resolve::MakeGlobMap;\n use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::region::{self, CodeExtent};\n@@ -40,7 +40,6 @@ use syntax::errors::{Level, RenderSpan};\n use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n \n-use rustc::hir::lowering::{lower_crate, LoweringContext};\n use rustc::hir;\n \n struct Env<'a, 'tcx: 'a> {\n@@ -123,26 +122,28 @@ fn test_env<F>(source_string: &str,\n     let krate = driver::assign_node_ids(&sess, krate);\n     let defs = &RefCell::new(hir_map::collect_definitions(&krate));\n     LocalCrateReader::new(&sess, &cstore, defs, &krate, \"test_crate\").read_crates(&dep_graph);\n-    let lcx = LoweringContext::new(&sess, Some(&krate), defs);\n     let _ignore = dep_graph.in_ignore();\n-    let mut hir_forest = &mut hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph.clone());\n+\n+    let (_, resolutions, mut hir_forest) = {\n+        let (defs, dep_graph) = (&mut *defs.borrow_mut(), dep_graph.clone());\n+        driver::lower_and_resolve(&sess, \"test-crate\", defs, &krate, dep_graph, MakeGlobMap::No)\n+    };\n+\n     let arenas = ty::CtxtArenas::new();\n-    let ast_map = hir_map::map_crate(hir_forest, defs);\n+    let ast_map = hir_map::map_crate(&mut hir_forest, defs);\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(&sess, &ast_map);\n-    let resolve::CrateMap { def_map, freevars, maybe_unused_trait_imports, .. } =\n-        resolve::resolve_crate(&sess, &ast_map, resolve::MakeGlobMap::No);\n-    let named_region_map = resolve_lifetime::krate(&sess, &ast_map, &def_map.borrow());\n+    let named_region_map = resolve_lifetime::krate(&sess, &ast_map, &resolutions.def_map.borrow());\n     let region_map = region::resolve_crate(&sess, &ast_map);\n     let index = stability::Index::new(&ast_map);\n     TyCtxt::create_and_enter(&sess,\n                                &arenas,\n-                               def_map,\n+                               resolutions.def_map,\n                                named_region_map.unwrap(),\n                                ast_map,\n-                               freevars,\n-                               maybe_unused_trait_imports,\n+                               resolutions.freevars,\n+                               resolutions.maybe_unused_trait_imports,\n                                region_map,\n                                lang_items,\n                                index,"}, {"sha": "56f6a3f7b14cb1605418a7a1beb36a6346a0f34e", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -57,7 +57,7 @@ use rustc_serialize::{Encodable, EncoderHelpers};\n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::ast::NodeId;\n #[cfg(test)] use rustc::hir::print as pprust;\n-#[cfg(test)] use rustc::hir::lowering::{lower_item, LoweringContext};\n+#[cfg(test)] use rustc::hir::lowering::{lower_item, LoweringContext, DummyResolver};\n \n struct DecodeContext<'a, 'b, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n@@ -1325,6 +1325,14 @@ fn mk_ctxt() -> parse::ParseSess {\n     parse::ParseSess::new()\n }\n \n+#[cfg(test)]\n+fn with_testing_context<T, F: FnOnce(LoweringContext) -> T>(f: F) -> T {\n+    let assigner = FakeNodeIdAssigner;\n+    let mut resolver = DummyResolver;\n+    let lcx = LoweringContext::new(&assigner, None, &mut resolver);\n+    f(lcx)\n+}\n+\n #[cfg(test)]\n fn roundtrip(in_item: hir::Item) {\n     let mut wr = Cursor::new(Vec::new());\n@@ -1338,34 +1346,34 @@ fn roundtrip(in_item: hir::Item) {\n #[test]\n fn test_basic() {\n     let cx = mk_ctxt();\n-    let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::testing_context(&fnia);\n-    roundtrip(lower_item(&lcx, &quote_item!(&cx,\n-        fn foo() {}\n-    ).unwrap()));\n+    with_testing_context(|lcx| {\n+        roundtrip(lower_item(&lcx, &quote_item!(&cx,\n+            fn foo() {}\n+        ).unwrap()));\n+    });\n }\n \n #[test]\n fn test_smalltalk() {\n     let cx = mk_ctxt();\n-    let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::testing_context(&fnia);\n-    roundtrip(lower_item(&lcx, &quote_item!(&cx,\n-        fn foo() -> isize { 3 + 4 } // first smalltalk program ever executed.\n-    ).unwrap()));\n+    with_testing_context(|lcx| {\n+        roundtrip(lower_item(&lcx, &quote_item!(&cx,\n+            fn foo() -> isize { 3 + 4 } // first smalltalk program ever executed.\n+        ).unwrap()));\n+    });\n }\n \n #[test]\n fn test_more() {\n     let cx = mk_ctxt();\n-    let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::testing_context(&fnia);\n-    roundtrip(lower_item(&lcx, &quote_item!(&cx,\n-        fn foo(x: usize, y: usize) -> usize {\n-            let z = x + y;\n-            return z;\n-        }\n-    ).unwrap()));\n+    with_testing_context(|lcx| {\n+        roundtrip(lower_item(&lcx, &quote_item!(&cx,\n+            fn foo(x: usize, y: usize) -> usize {\n+                let z = x + y;\n+                return z;\n+            }\n+        ).unwrap()));\n+    });\n }\n \n #[test]\n@@ -1377,21 +1385,22 @@ fn test_simplification() {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap();\n-    let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::testing_context(&fnia);\n-    let hir_item = lower_item(&lcx, &item);\n-    let item_in = InlinedItemRef::Item(&hir_item);\n-    let item_out = simplify_ast(item_in);\n-    let item_exp = InlinedItem::Item(P(lower_item(&lcx, &quote_item!(&cx,\n-        fn new_int_alist<B>() -> alist<isize, B> {\n-            return alist {eq_fn: eq_int, data: Vec::new()};\n+    let cx = mk_ctxt();\n+    with_testing_context(|lcx| {\n+        let hir_item = lower_item(&lcx, &item);\n+        let item_in = InlinedItemRef::Item(&hir_item);\n+        let item_out = simplify_ast(item_in);\n+        let item_exp = InlinedItem::Item(P(lower_item(&lcx, &quote_item!(&cx,\n+            fn new_int_alist<B>() -> alist<isize, B> {\n+                return alist {eq_fn: eq_int, data: Vec::new()};\n+            }\n+        ).unwrap())));\n+        match (item_out, item_exp) {\n+            (InlinedItem::Item(item_out), InlinedItem::Item(item_exp)) => {\n+                 assert!(pprust::item_to_string(&item_out) ==\n+                         pprust::item_to_string(&item_exp));\n+            }\n+            _ => bug!()\n         }\n-    ).unwrap())));\n-    match (item_out, item_exp) {\n-      (InlinedItem::Item(item_out), InlinedItem::Item(item_exp)) => {\n-        assert!(pprust::item_to_string(&item_out) ==\n-                pprust::item_to_string(&item_exp));\n-      }\n-      _ => bug!()\n-    }\n+    });\n }"}, {"sha": "f56b22f924891bf0dca827a52e473e273b91b82e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 75, "deletions": 81, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -29,18 +29,15 @@ use rustc::ty::{self, VariantKind};\n \n use syntax::ast::{Name, NodeId};\n use syntax::attr::AttrMetaMethods;\n-use syntax::parse::token::keywords;\n+use syntax::parse::token::{self, keywords};\n use syntax::codemap::{Span, DUMMY_SP};\n \n-use rustc::hir;\n-use rustc::hir::{Block, DeclItem};\n-use rustc::hir::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n-use rustc::hir::{Item, ItemConst, ItemEnum, ItemExternCrate, ItemFn};\n-use rustc::hir::{ItemForeignMod, ItemImpl, ItemMod, ItemStatic, ItemDefaultImpl};\n-use rustc::hir::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n-use rustc::hir::{PathListIdent, PathListMod, StmtDecl};\n-use rustc::hir::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use rustc::hir::intravisit::{self, Visitor};\n+use syntax::ast::{Block, Crate, DeclKind};\n+use syntax::ast::{ForeignItem, ForeignItemKind, Item, ItemKind};\n+use syntax::ast::{Mutability, PathListItemKind};\n+use syntax::ast::{SelfKind, Stmt, StmtKind, TraitItemKind};\n+use syntax::ast::{Variant, ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::visit::{self, Visitor};\n \n trait ToNameBinding<'a> {\n     fn to_name_binding(self) -> NameBinding<'a>;\n@@ -58,14 +55,14 @@ impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n     }\n }\n \n-impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n+impl<'b> Resolver<'b> {\n     /// Constructs the reduced graph for the entire crate.\n-    pub fn build_reduced_graph(&mut self, krate: &hir::Crate) {\n+    pub fn build_reduced_graph(&mut self, krate: &Crate) {\n         let mut visitor = BuildReducedGraphVisitor {\n             parent: self.graph_root,\n             resolver: self,\n         };\n-        intravisit::walk_crate(&mut visitor, krate);\n+        visit::walk_crate(&mut visitor, krate);\n     }\n \n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined.\n@@ -85,9 +82,9 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n     }\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n-        fn is_item(statement: &hir::Stmt) -> bool {\n-            if let StmtDecl(ref declaration, _) = statement.node {\n-                if let DeclItem(_) = declaration.node {\n+        fn is_item(statement: &Stmt) -> bool {\n+            if let StmtKind::Decl(ref declaration, _) = statement.node {\n+                if let DeclKind::Item(_) = declaration.node {\n                     return true;\n                 }\n             }\n@@ -98,7 +95,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         block.stmts.iter().any(is_item)\n     }\n \n-    fn sanity_check_import(&self, view_path: &hir::ViewPath, id: NodeId) {\n+    fn sanity_check_import(&self, view_path: &ViewPath, id: NodeId) {\n         let path = match view_path.node {\n             ViewPathSimple(_, ref path) |\n             ViewPathGlob (ref path) |\n@@ -131,13 +128,13 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, parent_ref: &mut Module<'b>) {\n         let parent = *parent_ref;\n-        let name = item.name;\n+        let name = item.ident.name;\n         let sp = item.span;\n         self.current_module = parent;\n         let vis = self.resolve_visibility(&item.vis);\n \n         match item.node {\n-            ItemUse(ref view_path) => {\n+            ItemKind::Use(ref view_path) => {\n                 // Extract and intern the module part of the path. For\n                 // globs and lists, the path is found directly in the AST;\n                 // for simple paths we have to munge the path a little.\n@@ -175,21 +172,20 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                           ResolutionError::SelfImportsOnlyAllowedWithin);\n                         }\n \n-                        let subclass = ImportDirectiveSubclass::single(binding, source_name);\n+                        let subclass = ImportDirectiveSubclass::single(binding.name, source_name);\n                         let span = view_path.span;\n                         parent.add_import_directive(module_path, subclass, span, item.id, vis);\n                         self.unresolved_imports += 1;\n                     }\n                     ViewPathList(_, ref source_items) => {\n                         // Make sure there's at most one `mod` import in the list.\n-                        let mod_spans = source_items.iter()\n-                                                    .filter_map(|item| {\n-                                                        match item.node {\n-                                                            PathListMod { .. } => Some(item.span),\n-                                                            _ => None,\n-                                                        }\n-                                                    })\n-                                                    .collect::<Vec<Span>>();\n+                        let mod_spans = source_items.iter().filter_map(|item| {\n+                            match item.node {\n+                                PathListItemKind::Mod { .. } => Some(item.span),\n+                                _ => None,\n+                            }\n+                        }).collect::<Vec<Span>>();\n+\n                         if mod_spans.len() > 1 {\n                             let mut e = resolve_struct_error(self,\n                                           mod_spans[0],\n@@ -202,9 +198,9 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n                         for source_item in source_items {\n                             let (module_path, name, rename) = match source_item.node {\n-                                PathListIdent { name, rename, .. } =>\n-                                    (module_path.clone(), name, rename.unwrap_or(name)),\n-                                PathListMod { rename, .. } => {\n+                                PathListItemKind::Ident { name, rename, .. } =>\n+                                    (module_path.clone(), name.name, rename.unwrap_or(name).name),\n+                                PathListItemKind::Mod { rename, .. } => {\n                                     let name = match module_path.last() {\n                                         Some(name) => *name,\n                                         None => {\n@@ -218,7 +214,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                         }\n                                     };\n                                     let module_path = module_path.split_last().unwrap().1;\n-                                    let rename = rename.unwrap_or(name);\n+                                    let rename = rename.map(|i| i.name).unwrap_or(name);\n                                     (module_path.to_vec(), name, rename)\n                                 }\n                             };\n@@ -237,7 +233,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 }\n             }\n \n-            ItemExternCrate(_) => {\n+            ItemKind::ExternCrate(_) => {\n                 // n.b. we don't need to look at the path option here, because cstore already\n                 // did\n                 if let Some(crate_id) = self.session.cstore.extern_mod_stmt_cnum(item.id) {\n@@ -254,76 +250,77 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 }\n             }\n \n-            ItemMod(..) => {\n+            ItemKind::Mod(..) => {\n                 let parent_link = ModuleParentLink(parent, name);\n-                let def = Def::Mod(self.ast_map.local_def_id(item.id));\n+                let def = Def::Mod(self.definitions.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false);\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n                 self.module_map.insert(item.id, module);\n                 *parent_ref = module;\n             }\n \n-            ItemForeignMod(..) => {}\n+            ItemKind::ForeignMod(..) => {}\n \n             // These items live in the value namespace.\n-            ItemStatic(_, m, _) => {\n-                let mutbl = m == hir::MutMutable;\n-                let def = Def::Static(self.ast_map.local_def_id(item.id), mutbl);\n+            ItemKind::Static(_, m, _) => {\n+                let mutbl = m == Mutability::Mutable;\n+                let def = Def::Static(self.definitions.local_def_id(item.id), mutbl);\n                 self.define(parent, name, ValueNS, (def, sp, vis));\n             }\n-            ItemConst(_, _) => {\n-                let def = Def::Const(self.ast_map.local_def_id(item.id));\n+            ItemKind::Const(_, _) => {\n+                let def = Def::Const(self.definitions.local_def_id(item.id));\n                 self.define(parent, name, ValueNS, (def, sp, vis));\n             }\n-            ItemFn(_, _, _, _, _, _) => {\n-                let def = Def::Fn(self.ast_map.local_def_id(item.id));\n+            ItemKind::Fn(_, _, _, _, _, _) => {\n+                let def = Def::Fn(self.definitions.local_def_id(item.id));\n                 self.define(parent, name, ValueNS, (def, sp, vis));\n             }\n \n             // These items live in the type namespace.\n-            ItemTy(..) => {\n-                let def = Def::TyAlias(self.ast_map.local_def_id(item.id));\n+            ItemKind::Ty(..) => {\n+                let def = Def::TyAlias(self.definitions.local_def_id(item.id));\n                 self.define(parent, name, TypeNS, (def, sp, vis));\n             }\n \n-            ItemEnum(ref enum_definition, _) => {\n+            ItemKind::Enum(ref enum_definition, _) => {\n                 let parent_link = ModuleParentLink(parent, name);\n-                let def = Def::Enum(self.ast_map.local_def_id(item.id));\n+                let def = Def::Enum(self.definitions.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false);\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n \n                 for variant in &(*enum_definition).variants {\n-                    let item_def_id = self.ast_map.local_def_id(item.id);\n+                    let item_def_id = self.definitions.local_def_id(item.id);\n                     self.build_reduced_graph_for_variant(variant, item_def_id, module, vis);\n                 }\n             }\n \n             // These items live in both the type and value namespaces.\n-            ItemStruct(ref struct_def, _) => {\n+            ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n-                let def = Def::Struct(self.ast_map.local_def_id(item.id));\n+                let def = Def::Struct(self.definitions.local_def_id(item.id));\n                 self.define(parent, name, TypeNS, (def, sp, vis));\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n                 if !struct_def.is_struct() {\n-                    let def = Def::Struct(self.ast_map.local_def_id(struct_def.id()));\n+                    let def = Def::Struct(self.definitions.local_def_id(struct_def.id()));\n                     self.define(parent, name, ValueNS, (def, sp, vis));\n                 }\n \n                 // Record the def ID and fields of this struct.\n-                let field_names = struct_def.fields().iter().map(|field| {\n+                let field_names = struct_def.fields().iter().enumerate().map(|(index, field)| {\n                     self.resolve_visibility(&field.vis);\n-                    field.name\n+                    field.ident.map(|ident| ident.name)\n+                               .unwrap_or_else(|| token::intern(&index.to_string()))\n                 }).collect();\n-                let item_def_id = self.ast_map.local_def_id(item.id);\n+                let item_def_id = self.definitions.local_def_id(item.id);\n                 self.structs.insert(item_def_id, field_names);\n             }\n \n-            ItemDefaultImpl(_, _) | ItemImpl(..) => {}\n+            ItemKind::DefaultImpl(_, _) | ItemKind::Impl(..) => {}\n \n-            ItemTrait(_, _, _, ref items) => {\n-                let def_id = self.ast_map.local_def_id(item.id);\n+            ItemKind::Trait(_, _, _, ref items) => {\n+                let def_id = self.definitions.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n                 let parent_link = ModuleParentLink(parent, name);\n@@ -333,22 +330,23 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n                 // Add the names of all the items to the trait info.\n                 for item in items {\n-                    let item_def_id = self.ast_map.local_def_id(item.id);\n+                    let item_def_id = self.definitions.local_def_id(item.id);\n                     let mut is_static_method = false;\n                     let (def, ns) = match item.node {\n-                        hir::ConstTraitItem(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n-                        hir::MethodTraitItem(ref sig, _) => {\n-                            is_static_method = sig.explicit_self.node == hir::SelfStatic;\n+                        TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n+                        TraitItemKind::Method(ref sig, _) => {\n+                            is_static_method = sig.explicit_self.node == SelfKind::Static;\n                             (Def::Method(item_def_id), ValueNS)\n                         }\n-                        hir::TypeTraitItem(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n+                        TraitItemKind::Type(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n                     };\n \n-                    self.define(module_parent, item.name, ns, (def, item.span, vis));\n+                    self.define(module_parent, item.ident.name, ns, (def, item.span, vis));\n \n-                    self.trait_item_map.insert((item.name, def_id), is_static_method);\n+                    self.trait_item_map.insert((item.ident.name, def_id), is_static_method);\n                 }\n             }\n+            ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n         }\n     }\n \n@@ -359,16 +357,16 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                        item_id: DefId,\n                                        parent: Module<'b>,\n                                        vis: ty::Visibility) {\n-        let name = variant.node.name;\n+        let name = variant.node.name.name;\n         if variant.node.data.is_struct() {\n             // Not adding fields for variants as they are not accessed with a self receiver\n-            let variant_def_id = self.ast_map.local_def_id(variant.node.data.id());\n+            let variant_def_id = self.definitions.local_def_id(variant.node.data.id());\n             self.structs.insert(variant_def_id, Vec::new());\n         }\n \n         // Variants are always treated as importable to allow them to be glob used.\n         // All variants are defined in both type and value namespaces as future-proofing.\n-        let def = Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id()));\n+        let def = Def::Variant(item_id, self.definitions.local_def_id(variant.node.data.id()));\n         self.define(parent, name, ValueNS, (def, variant.span, vis));\n         self.define(parent, name, TypeNS, (def, variant.span, vis));\n     }\n@@ -377,14 +375,14 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n     fn build_reduced_graph_for_foreign_item(&mut self,\n                                             foreign_item: &ForeignItem,\n                                             parent: Module<'b>) {\n-        let name = foreign_item.name;\n+        let name = foreign_item.ident.name;\n \n         let def = match foreign_item.node {\n-            ForeignItemFn(..) => {\n-                Def::Fn(self.ast_map.local_def_id(foreign_item.id))\n+            ForeignItemKind::Fn(..) => {\n+                Def::Fn(self.definitions.local_def_id(foreign_item.id))\n             }\n-            ForeignItemStatic(_, m) => {\n-                Def::Static(self.ast_map.local_def_id(foreign_item.id), m)\n+            ForeignItemKind::Static(_, m) => {\n+                Def::Static(self.definitions.local_def_id(foreign_item.id), m)\n             }\n         };\n         self.current_module = parent;\n@@ -526,20 +524,16 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n     }\n }\n \n-struct BuildReducedGraphVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>,\n+struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n+    resolver: &'a mut Resolver<'b>,\n     parent: Module<'b>,\n }\n \n-impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.resolver.ast_map.expect_item(item.id))\n-    }\n-\n+impl<'a, 'b, 'v> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &Item) {\n         let old_parent = self.parent;\n         self.resolver.build_reduced_graph_for_item(item, &mut self.parent);\n-        intravisit::walk_item(self, item);\n+        visit::walk_item(self, item);\n         self.parent = old_parent;\n     }\n \n@@ -550,7 +544,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     fn visit_block(&mut self, block: &Block) {\n         let old_parent = self.parent;\n         self.resolver.build_reduced_graph_for_block(block, &mut self.parent);\n-        intravisit::walk_block(self, block);\n+        visit::walk_block(self, block);\n         self.parent = old_parent;\n     }\n }"}, {"sha": "64347d7b84d3c4fb5ead87a6a58c6d4fbf84fc92", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -25,33 +25,31 @@ use Resolver;\n use Namespace::{TypeNS, ValueNS};\n \n use rustc::lint;\n-use syntax::ast;\n+use syntax::ast::{self, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::visit::{self, Visitor};\n use syntax::codemap::{Span, DUMMY_SP};\n \n-use rustc::hir;\n-use rustc::hir::{ViewPathGlob, ViewPathList, ViewPathSimple};\n-use rustc::hir::intravisit::Visitor;\n \n-struct UnusedImportCheckVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>,\n+struct UnusedImportCheckVisitor<'a, 'b: 'a> {\n+    resolver: &'a mut Resolver<'b>,\n }\n \n // Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n-impl<'a, 'b, 'tcx:'b> Deref for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n-    type Target = Resolver<'b, 'tcx>;\n+impl<'a, 'b> Deref for UnusedImportCheckVisitor<'a, 'b> {\n+    type Target = Resolver<'b>;\n \n-    fn deref<'c>(&'c self) -> &'c Resolver<'b, 'tcx> {\n+    fn deref<'c>(&'c self) -> &'c Resolver<'b> {\n         &*self.resolver\n     }\n }\n \n-impl<'a, 'b, 'tcx:'b> DerefMut for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n-    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b, 'tcx> {\n+impl<'a, 'b> DerefMut for UnusedImportCheckVisitor<'a, 'b> {\n+    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b> {\n         &mut *self.resolver\n     }\n }\n \n-impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     // We have information about whether `use` (import) directives are actually\n     // used now. If an import is not used at all, we signal a lint error.\n     fn check_import(&mut self, id: ast::NodeId, span: Span) {\n@@ -73,18 +71,19 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+impl<'a, 'b, 'v> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        visit::walk_item(self, item);\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n-        if item.vis == hir::Public || item.span.source_equal(&DUMMY_SP) {\n+        if item.vis == ast::Visibility::Public || item.span.source_equal(&DUMMY_SP) {\n             return;\n         }\n \n         match item.node {\n-            hir::ItemExternCrate(_) => {\n+            ast::ItemKind::ExternCrate(_) => {\n                 if let Some(crate_num) = self.session.cstore.extern_mod_stmt_cnum(item.id) {\n                     if !self.used_crates.contains(&crate_num) {\n                         self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n@@ -94,7 +93,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemUse(ref p) => {\n+            ast::ItemKind::Use(ref p) => {\n                 match p.node {\n                     ViewPathSimple(_, _) => {\n                         self.check_import(item.id, p.span)\n@@ -115,7 +114,7 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n     }\n }\n \n-pub fn check_crate(resolver: &mut Resolver, krate: &hir::Crate) {\n+pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n     let mut visitor = UnusedImportCheckVisitor { resolver: resolver };\n-    krate.visit_all_items(&mut visitor);\n+    visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "7ab77ff2616911e0a9aff3ce9851aa5e8c97defe", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 303, "deletions": 273, "changes": 576, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -43,42 +43,31 @@ use self::AssocItemResolveResult::*;\n use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n \n-use rustc::dep_graph::DepNode;\n-use rustc::hir::map as hir_map;\n+use rustc::hir::map::Definitions;\n+use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::pat_util::pat_bindings;\n use rustc::ty;\n use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n+use syntax::ext::mtwt;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n use syntax::codemap::{self, Span, Pos};\n use syntax::errors::DiagnosticBuilder;\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n-use rustc::hir::intravisit::{self, FnKind, Visitor};\n-use rustc::hir;\n-use rustc::hir::{Arm, BindByRef, BindByValue, BindingMode, Block};\n-use rustc::hir::Crate;\n-use rustc::hir::{Expr, ExprAgain, ExprBreak, ExprField};\n-use rustc::hir::{ExprLoop, ExprWhile, ExprMethodCall};\n-use rustc::hir::{ExprPath, ExprStruct, FnDecl};\n-use rustc::hir::{ForeignItemFn, ForeignItemStatic, Generics};\n-use rustc::hir::{ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n-use rustc::hir::{ItemFn, ItemForeignMod, ItemImpl, ItemMod, ItemStatic, ItemDefaultImpl};\n-use rustc::hir::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n-use rustc::hir::Local;\n-use rustc::hir::{Pat, PatKind, Path, PrimTy};\n-use rustc::hir::{PathSegment, PathParameters};\n-use rustc::hir::HirVec;\n-use rustc::hir::{TraitRef, Ty, TyBool, TyChar, TyFloat, TyInt};\n-use rustc::hir::{TyRptr, TyStr, TyUint, TyPath};\n+use syntax::visit::{self, FnKind, Visitor};\n+use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n+use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n+use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n+use syntax::ast::{Local, Pat, PatKind, Path};\n+use syntax::ast::{PathSegment, PathParameters, TraitItemKind, TraitRef, Ty, TyKind};\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n@@ -143,7 +132,7 @@ enum ResolutionError<'a> {\n     /// error E0416: identifier is bound more than once in the same pattern\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n     /// error E0417: static variables cannot be referenced in a pattern\n-    StaticVariableReference(DefId, Option<Name>),\n+    StaticVariableReference(&'a NameBinding<'a>),\n     /// error E0418: is not an enum variant, struct or const\n     NotAnEnumVariantStructOrConst(&'a str),\n     /// error E0419: unresolved enum variant, struct or const\n@@ -195,16 +184,16 @@ enum UnresolvedNameContext<'a> {\n     Other,\n }\n \n-fn resolve_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n-                                       span: syntax::codemap::Span,\n-                                       resolution_error: ResolutionError<'b>) {\n+fn resolve_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n+                                 span: syntax::codemap::Span,\n+                                 resolution_error: ResolutionError<'c>) {\n     resolve_struct_error(resolver, span, resolution_error).emit();\n }\n \n-fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n-                                              span: syntax::codemap::Span,\n-                                              resolution_error: ResolutionError<'b>)\n-                                              -> DiagnosticBuilder<'a> {\n+fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n+                                        span: syntax::codemap::Span,\n+                                        resolution_error: ResolutionError<'c>)\n+                                        -> DiagnosticBuilder<'a> {\n     if !resolver.emit_errors {\n         return resolver.session.diagnostic().struct_dummy();\n     }\n@@ -341,22 +330,15 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                              \"identifier `{}` is bound more than once in the same pattern\",\n                              identifier)\n         }\n-        ResolutionError::StaticVariableReference(did, name) => {\n+        ResolutionError::StaticVariableReference(binding) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0417,\n                                            \"static variables cannot be referenced in a \\\n                                             pattern, use a `const` instead\");\n-            if let Some(sp) = resolver.ast_map.span_if_local(did) {\n-                err.span_note(sp, \"static variable defined here\");\n-            }\n-            if let Some(name) = name {\n-                if let Some(binding) = resolver.current_module\n-                                               .resolve_name_in_lexical_scope(name, ValueNS) {\n-                    if binding.is_import() {\n-                        err.span_note(binding.span, \"static variable imported here\");\n-                    }\n-                }\n+            if binding.span != codemap::DUMMY_SP {\n+                let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n+                err.span_note(binding.span, &format!(\"static variable {} here\", participle));\n             }\n             err\n         }\n@@ -422,13 +404,13 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                 UnresolvedNameContext::Other => { } // no help available\n                 UnresolvedNameContext::PathIsMod(parent) => {\n                     err.help(&match parent.map(|parent| &parent.node) {\n-                        Some(&ExprField(_, ident)) => {\n+                        Some(&ExprKind::Field(_, ident)) => {\n                             format!(\"To reference an item from the `{module}` module, \\\n                                      use `{module}::{ident}`\",\n                                     module = path,\n                                     ident = ident.node)\n                         }\n-                        Some(&ExprMethodCall(ident, _, _)) => {\n+                        Some(&ExprKind::MethodCall(ident, _, _)) => {\n                             format!(\"To call a function from the `{module}` module, \\\n                                      use `{module}::{ident}(..)`\",\n                                     module = path,\n@@ -526,10 +508,7 @@ pub enum Namespace {\n     ValueNS,\n }\n \n-impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.ast_map.expect_item(item.id))\n-    }\n+impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n     fn visit_item(&mut self, item: &Item) {\n         self.resolve_item(item);\n     }\n@@ -551,18 +530,18 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     fn visit_generics(&mut self, generics: &Generics) {\n         self.resolve_generics(generics);\n     }\n-    fn visit_poly_trait_ref(&mut self, tref: &hir::PolyTraitRef, m: &hir::TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, tref: &ast::PolyTraitRef, m: &ast::TraitBoundModifier) {\n         match self.resolve_trait_reference(tref.trait_ref.ref_id, &tref.trait_ref.path, 0) {\n             Ok(def) => self.record_def(tref.trait_ref.ref_id, def),\n             Err(_) => {\n                 // error already reported\n                 self.record_def(tref.trait_ref.ref_id, err_path_resolution())\n             }\n         }\n-        intravisit::walk_poly_trait_ref(self, tref, m);\n+        visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_variant(&mut self,\n-                     variant: &hir::Variant,\n+                     variant: &ast::Variant,\n                      generics: &Generics,\n                      item_id: ast::NodeId) {\n         if let Some(ref dis_expr) = variant.node.disr_expr {\n@@ -572,22 +551,22 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n             });\n         }\n \n-        // `intravisit::walk_variant` without the discriminant expression.\n+        // `visit::walk_variant` without the discriminant expression.\n         self.visit_variant_data(&variant.node.data,\n                                 variant.node.name,\n                                 generics,\n                                 item_id,\n                                 variant.span);\n     }\n-    fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         let type_parameters = match foreign_item.node {\n-            ForeignItemFn(_, ref generics) => {\n+            ForeignItemKind::Fn(_, ref generics) => {\n                 HasTypeParameters(generics, FnSpace, ItemRibKind)\n             }\n-            ForeignItemStatic(..) => NoTypeParameters,\n+            ForeignItemKind::Static(..) => NoTypeParameters,\n         };\n         self.with_type_parameter_rib(type_parameters, |this| {\n-            intravisit::walk_foreign_item(this, foreign_item);\n+            visit::walk_foreign_item(this, foreign_item);\n         });\n     }\n     fn visit_fn(&mut self,\n@@ -597,16 +576,16 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                 _: Span,\n                 node_id: NodeId) {\n         let rib_kind = match function_kind {\n-            FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n+            FnKind::ItemFn(_, generics, _, _, _, _) => {\n                 self.visit_generics(generics);\n                 ItemRibKind\n             }\n-            FnKind::Method(_, sig, _, _) => {\n+            FnKind::Method(_, sig, _) => {\n                 self.visit_generics(&sig.generics);\n                 self.visit_explicit_self(&sig.explicit_self);\n                 MethodRibKind\n             }\n-            FnKind::Closure(_) => ClosureRibKind(node_id),\n+            FnKind::Closure => ClosureRibKind(node_id),\n         };\n         self.resolve_function(rib_kind, declaration, block);\n     }\n@@ -646,17 +625,17 @@ enum FallbackSuggestion {\n }\n \n #[derive(Copy, Clone)]\n-enum TypeParameters<'tcx, 'a> {\n+enum TypeParameters<'a, 'b> {\n     NoTypeParameters,\n     HasTypeParameters(// Type parameters.\n-                      &'a Generics,\n+                      &'b Generics,\n \n                       // Identifies the things that these parameters\n                       // were declared on (type, fn, etc)\n                       ParamSpace,\n \n                       // The kind of the rib used for type parameters.\n-                      RibKind<'tcx>),\n+                      RibKind<'a>),\n }\n \n // The rib kind controls the translation of local\n@@ -757,10 +736,6 @@ impl<'a> LexicalScopeBinding<'a> {\n         }\n     }\n \n-    fn def(self) -> Def {\n-        self.local_def().def\n-    }\n-\n     fn module(self) -> Option<Module<'a>> {\n         match self {\n             LexicalScopeBinding::Item(binding) => binding.module(),\n@@ -975,10 +950,10 @@ impl PrimitiveTypeTable {\n }\n \n /// The main resolver class.\n-pub struct Resolver<'a, 'tcx: 'a> {\n+pub struct Resolver<'a> {\n     session: &'a Session,\n \n-    ast_map: &'a hir_map::Map<'tcx>,\n+    definitions: &'a mut Definitions,\n \n     graph_root: Module<'a>,\n \n@@ -1011,11 +986,11 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     // The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n-    def_map: RefCell<DefMap>,\n-    freevars: FreevarMap,\n+    pub def_map: DefMap,\n+    pub freevars: FreevarMap,\n     freevars_seen: NodeMap<NodeMap<usize>>,\n-    export_map: ExportMap,\n-    trait_map: TraitMap,\n+    pub export_map: ExportMap,\n+    pub trait_map: TraitMap,\n \n     // A map from nodes to modules, both normal (`mod`) modules and anonymous modules.\n     // Anonymous modules are pseudo-modules that are implicitly created around items\n@@ -1038,14 +1013,14 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     // so as to avoid printing duplicate errors\n     emit_errors: bool,\n \n-    make_glob_map: bool,\n+    pub make_glob_map: bool,\n     // Maps imports to the names of items actually imported (this actually maps\n     // all imports, but only glob imports are actually interesting).\n-    glob_map: GlobMap,\n+    pub glob_map: GlobMap,\n \n     used_imports: HashSet<(NodeId, Namespace)>,\n     used_crates: HashSet<CrateNum>,\n-    maybe_unused_trait_imports: NodeSet,\n+    pub maybe_unused_trait_imports: NodeSet,\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n \n@@ -1083,9 +1058,9 @@ impl<'a> ResolverArenas<'a> {\n     }\n }\n \n-impl<'a, 'tcx> ty::NodeIdTree for Resolver<'a, 'tcx> {\n+impl<'a> ty::NodeIdTree for Resolver<'a> {\n     fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n-        let ancestor = self.ast_map.local_def_id(ancestor);\n+        let ancestor = self.definitions.local_def_id(ancestor);\n         let mut module = *self.module_map.get(&node).unwrap();\n         while module.def_id() != Some(ancestor) {\n             let module_parent = match self.get_nearest_normal_module_parent(module) {\n@@ -1098,13 +1073,54 @@ impl<'a, 'tcx> ty::NodeIdTree for Resolver<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Resolver<'a, 'tcx> {\n+impl<'a> hir::lowering::Resolver for Resolver<'a> {\n+    fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def {\n+        let namespace = if is_value { ValueNS } else { TypeNS };\n+        match self.resolve_crate_relative_path(path.span, &path.segments, namespace) {\n+            Ok(binding) => binding.def().unwrap(),\n+            Err(true) => Def::Err,\n+            Err(false) => {\n+                let path_name = &format!(\"{}\", path);\n+                let error =\n+                    ResolutionError::UnresolvedName(path_name, \"\", UnresolvedNameContext::Other);\n+                resolve_error(self, path.span, error);\n+                Def::Err\n+            }\n+        }\n+    }\n+\n+    fn record_resolution(&mut self, id: NodeId, def: Def) {\n+        self.def_map.insert(id, PathResolution { base_def: def, depth: 0 });\n+    }\n+\n+    fn definitions(&mut self) -> Option<&mut Definitions> {\n+        Some(self.definitions)\n+    }\n+}\n+\n+trait Named {\n+    fn name(&self) -> Name;\n+}\n+\n+impl Named for ast::PathSegment {\n+    fn name(&self) -> Name {\n+        self.identifier.name\n+    }\n+}\n+\n+impl Named for hir::PathSegment {\n+    fn name(&self) -> Name {\n+        self.identifier.name\n+    }\n+}\n+\n+impl<'a> Resolver<'a> {\n     fn new(session: &'a Session,\n-           ast_map: &'a hir_map::Map<'tcx>,\n+           definitions: &'a mut Definitions,\n            make_glob_map: MakeGlobMap,\n            arenas: &'a ResolverArenas<'a>)\n-           -> Resolver<'a, 'tcx> {\n-        let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n+           -> Resolver<'a> {\n+        let root_def_id = definitions.local_def_id(CRATE_NODE_ID);\n         let graph_root =\n             ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, arenas);\n         let graph_root = arenas.alloc_module(graph_root);\n@@ -1114,7 +1130,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         Resolver {\n             session: session,\n \n-            ast_map: ast_map,\n+            definitions: definitions,\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1135,7 +1151,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             primitive_type_table: PrimitiveTypeTable::new(),\n \n-            def_map: RefCell::new(NodeMap()),\n+            def_map: NodeMap(),\n             freevars: NodeMap(),\n             freevars_seen: NodeMap(),\n             export_map: NodeMap(),\n@@ -1337,7 +1353,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        let ident = hir::Ident::from_name(module_path[0]);\n+                        let ident = ast::Ident::with_empty_ctxt(module_path[0]);\n                         match self.resolve_ident_in_lexical_scope(ident, TypeNS, true)\n                                   .and_then(LexicalScopeBinding::module) {\n                             None => return Failed(None),\n@@ -1379,11 +1395,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     fn resolve_ident_in_lexical_scope(&mut self,\n-                                      ident: hir::Ident,\n+                                      ident: ast::Ident,\n                                       ns: Namespace,\n                                       record_used: bool)\n                                       -> Option<LexicalScopeBinding<'a>> {\n-        let name = match ns { ValueNS => ident.name, TypeNS => ident.unhygienic_name };\n+        let name = match ns { ValueNS => mtwt::resolve(ident), TypeNS => ident.name };\n \n         // Walk backwards up the ribs in scope.\n         for i in (0 .. self.get_ribs(ns).len()).rev() {\n@@ -1396,7 +1412,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             if let ModuleRibKind(module) = self.get_ribs(ns)[i].kind {\n-                let name = ident.unhygienic_name;\n+                let name = ident.name;\n                 let item = self.resolve_name_in_module(module, name, ns, true, record_used);\n                 if let Success(binding) = item {\n                     // The ident resolves to an item.\n@@ -1565,77 +1581,76 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         None\n     }\n \n-    fn resolve_crate(&mut self, krate: &hir::Crate) {\n+    fn resolve_crate(&mut self, krate: &Crate) {\n         debug!(\"(resolving crate) starting\");\n         self.current_module = self.graph_root;\n-        intravisit::walk_crate(self, krate);\n+        visit::walk_crate(self, krate);\n     }\n \n     fn resolve_item(&mut self, item: &Item) {\n-        let name = item.name;\n+        let name = item.ident.name;\n \n         debug!(\"(resolving item) resolving {}\", name);\n \n         match item.node {\n-            ItemEnum(_, ref generics) |\n-            ItemTy(_, ref generics) |\n-            ItemStruct(_, ref generics) => {\n+            ItemKind::Enum(_, ref generics) |\n+            ItemKind::Ty(_, ref generics) |\n+            ItemKind::Struct(_, ref generics) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics, TypeSpace, ItemRibKind),\n-                                             |this| intravisit::walk_item(this, item));\n+                                             |this| visit::walk_item(this, item));\n             }\n-            ItemFn(_, _, _, _, ref generics, _) => {\n+            ItemKind::Fn(_, _, _, _, ref generics, _) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics, FnSpace, ItemRibKind),\n-                                             |this| intravisit::walk_item(this, item));\n+                                             |this| visit::walk_item(this, item));\n             }\n \n-            ItemDefaultImpl(_, ref trait_ref) => {\n+            ItemKind::DefaultImpl(_, ref trait_ref) => {\n                 self.with_optional_trait_ref(Some(trait_ref), |_, _| {});\n             }\n-            ItemImpl(_, _, ref generics, ref opt_trait_ref, ref self_type, ref impl_items) => {\n+            ItemKind::Impl(_, _, ref generics, ref opt_trait_ref, ref self_type, ref impl_items) =>\n                 self.resolve_implementation(generics,\n                                             opt_trait_ref,\n                                             &self_type,\n                                             item.id,\n-                                            impl_items);\n-            }\n+                                            impl_items),\n \n-            ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n+            ItemKind::Trait(_, ref generics, ref bounds, ref trait_items) => {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                                TypeSpace,\n                                                                ItemRibKind),\n                                              |this| {\n-                    let local_def_id = this.ast_map.local_def_id(item.id);\n+                    let local_def_id = this.definitions.local_def_id(item.id);\n                     this.with_self_rib(Def::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_ty_param_bound, bounds);\n \n                         for trait_item in trait_items {\n                             match trait_item.node {\n-                                hir::ConstTraitItem(_, ref default) => {\n+                                TraitItemKind::Const(_, ref default) => {\n                                     // Only impose the restrictions of\n                                     // ConstRibKind if there's an actual constant\n                                     // expression in a provided default.\n                                     if default.is_some() {\n                                         this.with_constant_rib(|this| {\n-                                            intravisit::walk_trait_item(this, trait_item)\n+                                            visit::walk_trait_item(this, trait_item)\n                                         });\n                                     } else {\n-                                        intravisit::walk_trait_item(this, trait_item)\n+                                        visit::walk_trait_item(this, trait_item)\n                                     }\n                                 }\n-                                hir::MethodTraitItem(ref sig, _) => {\n+                                TraitItemKind::Method(ref sig, _) => {\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n                                                           FnSpace,\n                                                           MethodRibKind);\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n-                                        intravisit::walk_trait_item(this, trait_item)\n+                                        visit::walk_trait_item(this, trait_item)\n                                     });\n                                 }\n-                                hir::TypeTraitItem(..) => {\n+                                TraitItemKind::Type(..) => {\n                                     this.with_type_parameter_rib(NoTypeParameters, |this| {\n-                                        intravisit::walk_trait_item(this, trait_item)\n+                                        visit::walk_trait_item(this, trait_item)\n                                     });\n                                 }\n                             };\n@@ -1644,21 +1659,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 });\n             }\n \n-            ItemMod(_) | ItemForeignMod(_) => {\n+            ItemKind::Mod(_) | ItemKind::ForeignMod(_) => {\n                 self.with_scope(item.id, |this| {\n-                    intravisit::walk_item(this, item);\n+                    visit::walk_item(this, item);\n                 });\n             }\n \n-            ItemConst(..) | ItemStatic(..) => {\n+            ItemKind::Const(..) | ItemKind::Static(..) => {\n                 self.with_constant_rib(|this| {\n-                    intravisit::walk_item(this, item);\n+                    visit::walk_item(this, item);\n                 });\n             }\n \n-            ItemUse(ref view_path) => {\n+            ItemKind::Use(ref view_path) => {\n                 match view_path.node {\n-                    hir::ViewPathList(ref prefix, ref items) => {\n+                    ast::ViewPathList(ref prefix, ref items) => {\n                         // Resolve prefix of an import with empty braces (issue #28388)\n                         if items.is_empty() && !prefix.segments.is_empty() {\n                             match self.resolve_crate_relative_path(prefix.span,\n@@ -1683,9 +1698,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n \n-            ItemExternCrate(_) => {\n+            ItemKind::ExternCrate(_) => {\n                 // do nothing, these are just around to be encoded\n             }\n+\n+            ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n         }\n     }\n \n@@ -1697,7 +1714,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = HashSet::new();\n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n-                    let name = type_parameter.name;\n+                    let name = type_parameter.ident.name;\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n                     if seen_bindings.contains(&name) {\n@@ -1708,7 +1725,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     seen_bindings.insert(name);\n \n                     // plain insert (no renaming)\n-                    let def_id = self.ast_map.local_def_id(type_parameter.id);\n+                    let def_id = self.definitions.local_def_id(type_parameter.id);\n                     let def = Def::TyParam(space, index as u32, def_id, name);\n                     function_type_rib.bindings.insert(name, def);\n                 }\n@@ -1761,7 +1778,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             debug!(\"(resolving function) recorded argument\");\n         }\n-        intravisit::walk_fn_ret_ty(self, &declaration.output);\n+        visit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body.\n         self.visit_block(block);\n@@ -1838,9 +1855,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn resolve_generics(&mut self, generics: &Generics) {\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n-                &hir::WherePredicate::BoundPredicate(_) |\n-                &hir::WherePredicate::RegionPredicate(_) => {}\n-                &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n+                &ast::WherePredicate::BoundPredicate(_) |\n+                &ast::WherePredicate::RegionPredicate(_) => {}\n+                &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n                     self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS).and_then(|path_res| {\n                         if let PathResolution { base_def: Def::TyParam(..), .. } = path_res {\n                             Ok(self.record_def(eq_pred.id, path_res))\n@@ -1856,7 +1873,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n         }\n-        intravisit::walk_generics(self, generics);\n+        visit::walk_generics(self, generics);\n     }\n \n     fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n@@ -1885,7 +1902,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 self.record_def(trait_ref.ref_id, err_path_resolution());\n             }\n-            intravisit::walk_trait_ref(self, trait_ref);\n+            visit::walk_trait_ref(self, trait_ref);\n         }\n         let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n         let result = f(self, new_id);\n@@ -1929,20 +1946,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         for impl_item in impl_items {\n                             this.resolve_visibility(&impl_item.vis);\n                             match impl_item.node {\n-                                hir::ImplItemKind::Const(..) => {\n+                                ImplItemKind::Const(..) => {\n                                     // If this is a trait impl, ensure the const\n                                     // exists in trait\n-                                    this.check_trait_item(impl_item.name,\n+                                    this.check_trait_item(impl_item.ident.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n                                     this.with_constant_rib(|this| {\n-                                        intravisit::walk_impl_item(this, impl_item);\n+                                        visit::walk_impl_item(this, impl_item);\n                                     });\n                                 }\n-                                hir::ImplItemKind::Method(ref sig, _) => {\n+                                ImplItemKind::Method(ref sig, _) => {\n                                     // If this is a trait impl, ensure the method\n                                     // exists in trait\n-                                    this.check_trait_item(impl_item.name,\n+                                    this.check_trait_item(impl_item.ident.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::MethodNotMemberOfTrait(n, s));\n \n@@ -1953,18 +1970,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                           FnSpace,\n                                                           MethodRibKind);\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n-                                        intravisit::walk_impl_item(this, impl_item);\n+                                        visit::walk_impl_item(this, impl_item);\n                                     });\n                                 }\n-                                hir::ImplItemKind::Type(ref ty) => {\n+                                ImplItemKind::Type(ref ty) => {\n                                     // If this is a trait impl, ensure the type\n                                     // exists in trait\n-                                    this.check_trait_item(impl_item.name,\n+                                    this.check_trait_item(impl_item.ident.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::TypeNotMemberOfTrait(n, s));\n \n                                     this.visit_ty(ty);\n                                 }\n+                                ImplItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n                             }\n                         }\n                     });\n@@ -2002,16 +2020,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     // that expands into an or-pattern where one 'x' was from the\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n-        let mut result = HashMap::new();\n-        pat_bindings(&self.def_map, pat, |binding_mode, _id, sp, path1| {\n-            let name = path1.node;\n-            result.insert(name,\n-                          BindingInfo {\n-                              span: sp,\n-                              binding_mode: binding_mode,\n-                          });\n+        let mut binding_map = HashMap::new();\n+\n+        pat.walk(&mut |pat| {\n+            if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n+                if sub_pat.is_some() || match self.def_map.get(&pat.id) {\n+                    Some(&PathResolution { base_def: Def::Local(..), .. }) => true,\n+                    _ => false,\n+                } {\n+                    let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n+                    binding_map.insert(mtwt::resolve(ident.node), binding_info);\n+                }\n+            }\n+            true\n         });\n-        return result;\n+\n+        binding_map\n     }\n \n     // check that all of the arms in an or-pattern have exactly the\n@@ -2086,7 +2110,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Descend into the block.\n-        intravisit::walk_block(self, block);\n+        visit::walk_block(self, block);\n \n         // Move back up.\n         self.current_module = orig_module;\n@@ -2099,15 +2123,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_type(&mut self, ty: &Ty) {\n         match ty.node {\n-            TyPath(ref maybe_qself, ref path) => {\n+            TyKind::Path(ref maybe_qself, ref path) => {\n                 let resolution = match self.resolve_possibly_assoc_item(ty.id,\n                                                                         maybe_qself.as_ref(),\n                                                                         path,\n                                                                         TypeNS) {\n                     // `<T>::a::b::c` is resolved by typeck alone.\n                     TypecheckRequired => {\n                         // Resolve embedded types.\n-                        intravisit::walk_ty(self, ty);\n+                        visit::walk_ty(self, ty);\n                         return;\n                     }\n                     ResolveAttempt(resolution) => resolution,\n@@ -2176,7 +2200,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             _ => {}\n         }\n         // Resolve embedded types.\n-        intravisit::walk_ty(self, ty);\n+        visit::walk_ty(self, ty);\n     }\n \n     fn resolve_pattern(&mut self,\n@@ -2186,7 +2210,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                        // pattern that binds them\n                        bindings_list: &mut HashMap<Name, NodeId>) {\n         let pat_id = pattern.id;\n-        pattern.walk(|pattern| {\n+        pattern.walk(&mut |pattern| {\n             match pattern.node {\n                 PatKind::Ident(binding_mode, ref path1, ref at_rhs) => {\n                     // The meaning of PatKind::Ident with no type parameters\n@@ -2200,7 +2224,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let const_ok = mode == RefutableMode && at_rhs.is_none();\n \n                     let ident = path1.node;\n-                    let renamed = ident.name;\n+                    let renamed = mtwt::resolve(ident);\n \n                     match self.resolve_bare_identifier_pattern(ident, pattern.span) {\n                         FoundStructOrEnumVariant(def) if const_ok => {\n@@ -2246,7 +2270,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `{}`\", renamed);\n \n-                            let def_id = self.ast_map.local_def_id(pattern.id);\n+                            let def_id = self.definitions.local_def_id(pattern.id);\n                             let def = Def::Local(def_id, pattern.id);\n \n                             // Record the definition so that later passes\n@@ -2319,11 +2343,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             Def::Variant(..) | Def::Const(..) => {\n                                 self.record_def(pattern.id, path_res);\n                             }\n-                            Def::Static(did, _) => {\n-                                resolve_error(&self,\n-                                              path.span,\n-                                              ResolutionError::StaticVariableReference(\n-                                                  did, None));\n+                            Def::Static(..) => {\n+                                let segments = &path.segments;\n+                                let binding = if path.global {\n+                                    self.resolve_crate_relative_path(path.span, segments, ValueNS)\n+                                } else {\n+                                    self.resolve_module_relative_path(path.span, segments, ValueNS)\n+                                }.unwrap();\n+\n+                                let error = ResolutionError::StaticVariableReference(binding);\n+                                resolve_error(self, path.span, error);\n                                 self.record_def(pattern.id, err_path_resolution());\n                             }\n                             _ => {\n@@ -2365,7 +2394,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         );\n                         self.record_def(pattern.id, err_path_resolution());\n                     }\n-                    intravisit::walk_path(self, path);\n+                    visit::walk_path(self, path);\n                 }\n \n                 PatKind::QPath(ref qself, ref path) => {\n@@ -2385,7 +2414,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                  .name;\n                             let traits = self.get_traits_containing_item(const_name);\n                             self.trait_map.insert(pattern.id, traits);\n-                            intravisit::walk_pat(self, pattern);\n+                            visit::walk_pat(self, pattern);\n                             return true;\n                         }\n                         ResolveAttempt(resolution) => resolution,\n@@ -2419,7 +2448,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                                       .as_str()));\n                         self.record_def(pattern.id, err_path_resolution());\n                     }\n-                    intravisit::walk_pat(self, pattern);\n+                    visit::walk_pat(self, pattern);\n                 }\n \n                 PatKind::Struct(ref path, _, _) => {\n@@ -2438,11 +2467,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.record_def(pattern.id, err_path_resolution());\n                         }\n                     }\n-                    intravisit::walk_path(self, path);\n+                    visit::walk_path(self, path);\n                 }\n \n                 PatKind::Lit(_) | PatKind::Range(..) => {\n-                    intravisit::walk_pat(self, pattern);\n+                    visit::walk_pat(self, pattern);\n                 }\n \n                 _ => {\n@@ -2453,19 +2482,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         });\n     }\n \n-    fn resolve_bare_identifier_pattern(&mut self, ident: hir::Ident, span: Span)\n+    fn resolve_bare_identifier_pattern(&mut self, ident: ast::Ident, span: Span)\n                                        -> BareIdentifierPatternResolution {\n-        match self.resolve_ident_in_lexical_scope(ident, ValueNS, true)\n-                  .map(LexicalScopeBinding::def) {\n-            Some(def @ Def::Variant(..)) | Some(def @ Def::Struct(..)) => {\n-                FoundStructOrEnumVariant(def)\n-            }\n-            Some(def @ Def::Const(..)) | Some(def @ Def::AssociatedConst(..)) => {\n-                FoundConst(def, ident.unhygienic_name)\n-            }\n-            Some(Def::Static(did, _)) => {\n-                resolve_error(self, span, ResolutionError::StaticVariableReference(\n-                    did, Some(ident.unhygienic_name)));\n+        let binding = match self.resolve_ident_in_lexical_scope(ident, ValueNS, true) {\n+            Some(LexicalScopeBinding::Item(binding)) => binding,\n+            _ => return BareIdentifierPatternUnresolved,\n+        };\n+        let def = binding.def().unwrap();\n+\n+        match def {\n+            Def::Variant(..) | Def::Struct(..) => FoundStructOrEnumVariant(def),\n+            Def::Const(..) | Def::AssociatedConst(..) => FoundConst(def, ident.name),\n+            Def::Static(..) => {\n+                let error = ResolutionError::StaticVariableReference(binding);\n+                resolve_error(self, span, error);\n                 BareIdentifierPatternUnresolved\n             }\n             _ => BareIdentifierPatternUnresolved,\n@@ -2475,7 +2505,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Handles paths that may refer to associated items\n     fn resolve_possibly_assoc_item(&mut self,\n                                    id: NodeId,\n-                                   maybe_qself: Option<&hir::QSelf>,\n+                                   maybe_qself: Option<&ast::QSelf>,\n                                    path: &Path,\n                                    namespace: Namespace)\n                                    -> AssocItemResolveResult {\n@@ -2536,7 +2566,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 None | Some(LocalDef{def: Def::Mod(..), ..}) if namespace == TypeNS =>\n                     this.primitive_type_table\n                         .primitive_types\n-                        .get(&last_ident.unhygienic_name)\n+                        .get(&last_ident.name)\n                         .map_or(def, |prim_ty| Some(LocalDef::from_def(Def::PrimTy(*prim_ty)))),\n                 _ => def\n             }\n@@ -2577,11 +2607,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     // Resolve a single identifier\n     fn resolve_identifier(&mut self,\n-                          identifier: hir::Ident,\n+                          identifier: ast::Ident,\n                           namespace: Namespace,\n                           record_used: bool)\n                           -> Option<LocalDef> {\n-        if identifier.unhygienic_name == keywords::Invalid.name() {\n+        if identifier.name == keywords::Invalid.name() {\n             return Some(LocalDef::from_def(Def::Err));\n         }\n \n@@ -2609,7 +2639,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                         ClosureRibKind(function_id) => {\n                             let prev_def = def;\n-                            let node_def_id = self.ast_map.local_def_id(node_id);\n+                            let node_def_id = self.definitions.local_def_id(node_id);\n \n                             let seen = self.freevars_seen\n                                            .entry(function_id)\n@@ -2681,7 +2711,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     // resolve a \"module-relative\" path, e.g. a::b::c\n     fn resolve_module_relative_path(&mut self,\n                                     span: Span,\n-                                    segments: &[hir::PathSegment],\n+                                    segments: &[ast::PathSegment],\n                                     namespace: Namespace)\n                                     -> Result<&'a NameBinding<'a>,\n                                               bool /* true if an error was reported */> {\n@@ -2723,19 +2753,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Invariant: This must be called only during main resolution, not during\n     /// import resolution.\n-    fn resolve_crate_relative_path(&mut self,\n-                                   span: Span,\n-                                   segments: &[hir::PathSegment],\n-                                   namespace: Namespace)\n-                                   -> Result<&'a NameBinding<'a>,\n-                                             bool /* true if an error was reported */> {\n-        let module_path = segments.split_last()\n-                                  .unwrap()\n-                                  .1\n-                                  .iter()\n-                                  .map(|ps| ps.identifier.name)\n-                                  .collect::<Vec<_>>();\n-\n+    fn resolve_crate_relative_path<T>(&mut self, span: Span, segments: &[T], namespace: Namespace)\n+                                      -> Result<&'a NameBinding<'a>,\n+                                                bool /* true if an error was reported */>\n+        where T: Named,\n+    {\n+        let module_path = segments.split_last().unwrap().1.iter().map(T::name).collect::<Vec<_>>();\n         let root_module = self.graph_root;\n \n         let containing_module;\n@@ -2764,7 +2787,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        let name = segments.last().unwrap().identifier.name;\n+        let name = segments.last().unwrap().name();\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         result.success().map(|binding| {\n             self.check_privacy(name, binding, span);\n@@ -2784,8 +2807,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn find_fallback_in_self_type(&mut self, name: Name) -> FallbackSuggestion {\n         fn extract_node_id(t: &Ty) -> Option<NodeId> {\n             match t.node {\n-                TyPath(None, _) => Some(t.id),\n-                TyRptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n+                TyKind::Path(None, _) => Some(t.id),\n+                TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n                 // This doesn't handle the remaining `Ty` variants as they are not\n                 // that commonly the self_type, it might be interesting to provide\n                 // support for those in future.\n@@ -2795,7 +2818,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n             // Look for a field with the same name in the current self_type.\n-            match self.def_map.borrow().get(&node_id).map(|d| d.full_def()) {\n+            match self.def_map.get(&node_id).map(|d| d.full_def()) {\n                 Some(Def::Enum(did)) |\n                 Some(Def::TyAlias(did)) |\n                 Some(Def::Struct(did)) |\n@@ -2843,6 +2866,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         } SuggestionType::NotFound\n     }\n \n+    fn resolve_labeled_block(&mut self, label: Option<ast::Ident>, id: NodeId, block: &Block) {\n+        if let Some(label) = label {\n+            let (label, def) = (mtwt::resolve(label), Def::Label(id));\n+            self.with_label_rib(|this| {\n+                this.label_ribs.last_mut().unwrap().bindings.insert(label, def);\n+                this.visit_block(block);\n+            });\n+        } else {\n+            self.visit_block(block);\n+        }\n+    }\n+\n     fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n@@ -2851,7 +2886,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Next, resolve the node.\n         match expr.node {\n-            ExprPath(ref maybe_qself, ref path) => {\n+            ExprKind::Path(ref maybe_qself, ref path) => {\n                 let resolution = match self.resolve_possibly_assoc_item(expr.id,\n                                                                         maybe_qself.as_ref(),\n                                                                         path,\n@@ -2861,7 +2896,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let method_name = path.segments.last().unwrap().identifier.name;\n                         let traits = self.get_traits_containing_item(method_name);\n                         self.trait_map.insert(expr.id, traits);\n-                        intravisit::walk_expr(self, expr);\n+                        visit::walk_expr(self, expr);\n                         return;\n                     }\n                     ResolveAttempt(resolution) => resolution,\n@@ -3003,10 +3038,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n \n-                intravisit::walk_expr(self, expr);\n+                visit::walk_expr(self, expr);\n             }\n \n-            ExprStruct(ref path, _, _) => {\n+            ExprKind::Struct(ref path, _, _) => {\n                 // Resolve the path to the structure it goes to. We don't\n                 // check to ensure that the path is actually a structure; that\n                 // is checked later during typeck.\n@@ -3025,24 +3060,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n \n-                intravisit::walk_expr(self, expr);\n+                visit::walk_expr(self, expr);\n             }\n \n-            ExprLoop(_, Some(label)) | ExprWhile(_, _, Some(label)) => {\n+            ExprKind::Loop(_, Some(label)) | ExprKind::While(_, _, Some(label)) => {\n                 self.with_label_rib(|this| {\n                     let def = Def::Label(expr.id);\n \n                     {\n                         let rib = this.label_ribs.last_mut().unwrap();\n-                        rib.bindings.insert(label.name, def);\n+                        rib.bindings.insert(mtwt::resolve(label), def);\n                     }\n \n-                    intravisit::walk_expr(this, expr);\n+                    visit::walk_expr(this, expr);\n                 })\n             }\n \n-            ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n-                match self.search_label(label.node.name) {\n+            ExprKind::Break(Some(label)) | ExprKind::Again(Some(label)) => {\n+                match self.search_label(mtwt::resolve(label.node)) {\n                     None => {\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n@@ -3062,10 +3097,42 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n             }\n-            ExprField(ref subexpression, _) => {\n+\n+            ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n+                self.visit_expr(subexpression);\n+\n+                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.resolve_pattern(pattern, RefutableMode, &mut HashMap::new());\n+                self.visit_block(if_block);\n+                self.value_ribs.pop();\n+\n+                optional_else.as_ref().map(|expr| self.visit_expr(expr));\n+            }\n+\n+            ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n+                self.visit_expr(subexpression);\n+                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.resolve_pattern(pattern, RefutableMode, &mut HashMap::new());\n+\n+                self.resolve_labeled_block(label, expr.id, block);\n+\n+                self.value_ribs.pop();\n+            }\n+\n+            ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n+                self.visit_expr(subexpression);\n+                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.resolve_pattern(pattern, LocalIrrefutableMode, &mut HashMap::new());\n+\n+                self.resolve_labeled_block(label, expr.id, block);\n+\n+                self.value_ribs.pop();\n+            }\n+\n+            ExprKind::Field(ref subexpression, _) => {\n                 self.resolve_expr(subexpression, Some(expr));\n             }\n-            ExprMethodCall(_, ref types, ref arguments) => {\n+            ExprKind::MethodCall(_, ref types, ref arguments) => {\n                 let mut arguments = arguments.iter();\n                 self.resolve_expr(arguments.next().unwrap(), Some(expr));\n                 for argument in arguments {\n@@ -3077,25 +3144,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             _ => {\n-                intravisit::walk_expr(self, expr);\n+                visit::walk_expr(self, expr);\n             }\n         }\n     }\n \n     fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n         match expr.node {\n-            ExprField(_, name) => {\n+            ExprKind::Field(_, name) => {\n                 // FIXME(#6890): Even though you can't treat a method like a\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.get_traits_containing_item(name.node);\n+                let traits = self.get_traits_containing_item(name.node.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n-            ExprMethodCall(name, _, _) => {\n+            ExprKind::MethodCall(name, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\",\n                        expr.id);\n-                let traits = self.get_traits_containing_item(name.node);\n+                let traits = self.get_traits_containing_item(name.node.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -3205,7 +3272,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Some(def) = name_binding.def() {\n                     if name == lookup_name && ns == namespace && filter_fn(def) {\n                         // create the path\n-                        let ident = hir::Ident::from_name(name);\n+                        let ident = ast::Ident::with_empty_ctxt(name);\n                         let params = PathParameters::none();\n                         let segment = PathSegment {\n                             identifier: ident,\n@@ -3214,7 +3281,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let span = name_binding.span;\n                         let mut segms = path_segments.clone();\n                         segms.push(segment);\n-                        let segms = HirVec::from_vec(segms);\n                         let path = Path {\n                             span: span,\n                             global: true,\n@@ -3240,7 +3306,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         NoParentLink => path_segments.clone(),\n                         ModuleParentLink(_, name) => {\n                             let mut paths = path_segments.clone();\n-                            let ident = hir::Ident::from_name(name);\n+                            let ident = ast::Ident::with_empty_ctxt(name);\n                             let params = PathParameters::none();\n                             let segm = PathSegment {\n                                 identifier: ident,\n@@ -3269,12 +3335,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn record_def(&mut self, node_id: NodeId, resolution: PathResolution) {\n         debug!(\"(recording def) recording {:?} for {}\", resolution, node_id);\n-        if let Some(prev_res) = self.def_map.borrow_mut().insert(node_id, resolution) {\n-            let span = self.ast_map.opt_span(node_id).unwrap_or(codemap::DUMMY_SP);\n-            span_bug!(span,\n-                      \"path resolved multiple times ({:?} before, {:?} now)\",\n-                      prev_res,\n-                      resolution);\n+        if let Some(prev_res) = self.def_map.insert(node_id, resolution) {\n+            panic!(\"path resolved multiple times ({:?} before, {:?} now)\", prev_res, resolution);\n         }\n     }\n \n@@ -3283,24 +3345,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     pat_binding_mode: BindingMode,\n                                     descr: &str) {\n         match pat_binding_mode {\n-            BindByValue(_) => {}\n-            BindByRef(..) => {\n+            BindingMode::ByValue(_) => {}\n+            BindingMode::ByRef(..) => {\n                 resolve_error(self,\n                               pat.span,\n                               ResolutionError::CannotUseRefBindingModeWith(descr));\n             }\n         }\n     }\n \n-    fn resolve_visibility(&mut self, vis: &hir::Visibility) -> ty::Visibility {\n+    fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n         let (path, id) = match *vis {\n-            hir::Public => return ty::Visibility::Public,\n-            hir::Visibility::Crate => return ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n-            hir::Visibility::Restricted { ref path, id } => (path, id),\n-            hir::Inherited => {\n+            ast::Visibility::Public => return ty::Visibility::Public,\n+            ast::Visibility::Crate(_) => return ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n+            ast::Visibility::Restricted { ref path, id } => (path, id),\n+            ast::Visibility::Inherited => {\n                 let current_module =\n                     self.get_nearest_normal_module_parent_or_self(self.current_module);\n-                let id = self.ast_map.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n+                let id =\n+                    self.definitions.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n                 return ty::Visibility::Restricted(id);\n             }\n         };\n@@ -3310,8 +3373,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success(module) => {\n                 let def = module.def.unwrap();\n                 let path_resolution = PathResolution { base_def: def, depth: 0 };\n-                self.def_map.borrow_mut().insert(id, path_resolution);\n-                ty::Visibility::Restricted(self.ast_map.as_local_node_id(def.def_id()).unwrap())\n+                self.def_map.insert(id, path_resolution);\n+                ty::Visibility::Restricted(self.definitions.as_local_node_id(def.def_id()).unwrap())\n             }\n             Failed(Some((span, msg))) => {\n                 self.session.span_err(span, &format!(\"failed to resolve module path. {}\", msg));\n@@ -3331,7 +3394,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn is_accessible(&self, vis: ty::Visibility) -> bool {\n         let current_module = self.get_nearest_normal_module_parent_or_self(self.current_module);\n-        let node_id = self.ast_map.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n+        let node_id = self.definitions.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n         vis.is_accessible_from(node_id, self)\n     }\n \n@@ -3525,72 +3588,39 @@ fn err_path_resolution() -> PathResolution {\n }\n \n \n-pub struct CrateMap {\n-    pub def_map: RefCell<DefMap>,\n-    pub freevars: FreevarMap,\n-    pub maybe_unused_trait_imports: NodeSet,\n-    pub export_map: ExportMap,\n-    pub trait_map: TraitMap,\n-    pub glob_map: Option<GlobMap>,\n-}\n-\n #[derive(PartialEq,Copy, Clone)]\n pub enum MakeGlobMap {\n     Yes,\n     No,\n }\n \n /// Entry point to crate resolution.\n-pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n-                               ast_map: &'a hir_map::Map<'tcx>,\n-                               make_glob_map: MakeGlobMap)\n-                               -> CrateMap {\n+pub fn resolve_crate<'a, 'b>(resolver: &'b mut Resolver<'a>, krate: &'b Crate) {\n     // Currently, we ignore the name resolution data structures for\n     // the purposes of dependency tracking. Instead we will run name\n     // resolution and include its output in the hash of each item,\n     // much like we do for macro expansion. In other words, the hash\n     // reflects not just its contents but the results of name\n     // resolution on those contents. Hopefully we'll push this back at\n     // some point.\n-    let _task = ast_map.dep_graph.in_task(DepNode::Resolve);\n-\n-    let krate = ast_map.krate();\n-    let arenas = Resolver::arenas();\n-    let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, &arenas);\n \n+    resolver.build_reduced_graph(krate);\n+    resolve_imports::resolve_imports(resolver);\n     resolver.resolve_crate(krate);\n \n-    check_unused::check_crate(&mut resolver, krate);\n+    check_unused::check_crate(resolver, krate);\n     resolver.report_privacy_errors();\n-\n-    CrateMap {\n-        def_map: resolver.def_map,\n-        freevars: resolver.freevars,\n-        maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n-        export_map: resolver.export_map,\n-        trait_map: resolver.trait_map,\n-        glob_map: if resolver.make_glob_map {\n-            Some(resolver.glob_map)\n-        } else {\n-            None\n-        },\n-    }\n }\n \n-/// Builds a name resolution walker.\n-fn create_resolver<'a, 'tcx>(session: &'a Session,\n-                             ast_map: &'a hir_map::Map<'tcx>,\n-                             krate: &'a Crate,\n-                             make_glob_map: MakeGlobMap,\n-                             arenas: &'a ResolverArenas<'a>)\n-                             -> Resolver<'a, 'tcx> {\n-    let mut resolver = Resolver::new(session, ast_map, make_glob_map, arenas);\n-\n-    resolver.build_reduced_graph(krate);\n-\n-    resolve_imports::resolve_imports(&mut resolver);\n-\n-    resolver\n+pub fn with_resolver<'a, T, F>(session: &'a Session,\n+                               definitions: &'a mut Definitions,\n+                               make_glob_map: MakeGlobMap,\n+                               f: F) -> T\n+    where F: for<'b> FnOnce(Resolver<'b>) -> T,\n+{\n+    let arenas = Resolver::arenas();\n+    let resolver = Resolver::new(session, definitions, make_glob_map, &arenas);\n+    f(resolver)\n }\n \n __build_diagnostic_array! { librustc_resolve, DIAGNOSTICS }"}, {"sha": "9bd16117f9a8e25ccbcb14abc123b7bc383d89c2", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -344,11 +344,11 @@ struct ImportResolvingError<'a> {\n     help: String,\n }\n \n-struct ImportResolver<'a, 'b: 'a, 'tcx: 'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>,\n+struct ImportResolver<'a, 'b: 'a> {\n+    resolver: &'a mut Resolver<'b>,\n }\n \n-impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n+impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     // Import resolution\n     //\n     // This is a fixed-point algorithm. We resolve imports until our efforts\n@@ -608,7 +608,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             None => value_result.success().and_then(NameBinding::def).unwrap(),\n         };\n         let path_resolution = PathResolution { base_def: def, depth: 0 };\n-        self.resolver.def_map.borrow_mut().insert(directive.id, path_resolution);\n+        self.resolver.def_map.insert(directive.id, path_resolution);\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n@@ -653,11 +653,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         // Record the destination of this import\n         if let Some(did) = target_module.def_id() {\n-            self.resolver.def_map.borrow_mut().insert(directive.id,\n-                                                      PathResolution {\n-                                                          base_def: Def::Mod(did),\n-                                                          depth: 0,\n-                                                      });\n+            let resolution = PathResolution { base_def: Def::Mod(did), depth: 0 };\n+            self.resolver.def_map.insert(directive.id, resolution);\n         }\n \n         debug!(\"(resolving glob import) successfully resolved import\");\n@@ -703,7 +700,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         if reexports.len() > 0 {\n             if let Some(def_id) = module.def_id() {\n-                let node_id = self.resolver.ast_map.as_local_node_id(def_id).unwrap();\n+                let node_id = self.resolver.definitions.as_local_node_id(def_id).unwrap();\n                 self.resolver.export_map.insert(node_id, reexports);\n             }\n         }"}, {"sha": "e5fc84037ce57378deb951ab3e50bf361fcbcb91", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -20,7 +20,6 @@ use rustc::hir::map as hir_map;\n use rustc::lint;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n-use rustc::hir::lowering::{lower_crate, LoweringContext};\n use rustc_metadata::cstore::CStore;\n use rustc_metadata::creader::LocalCrateReader;\n \n@@ -156,18 +155,22 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let defs = &RefCell::new(hir_map::collect_definitions(&krate));\n     LocalCrateReader::new(&sess, &cstore, &defs, &krate, &name).read_crates(&dep_graph);\n-    let lcx = LoweringContext::new(&sess, Some(&krate), defs);\n \n-    // Lower ast -> hir.\n-    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph);\n+    // Lower ast -> hir and resolve.\n+    let (analysis, resolutions, mut hir_forest) = {\n+        let defs = &mut *defs.borrow_mut();\n+        driver::lower_and_resolve(&sess, &name, defs, &krate, dep_graph, resolve::MakeGlobMap::No)\n+    };\n+\n     let arenas = ty::CtxtArenas::new();\n     let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n \n     abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n                                                      hir_map,\n+                                                     analysis,\n+                                                     resolutions,\n                                                      &arenas,\n                                                      &name,\n-                                                     resolve::MakeGlobMap::No,\n                                                      |tcx, _, analysis, result| {\n         // Return if the driver hit an err (in `result`)\n         if let Err(_) = result {"}, {"sha": "fc548924e296426f05a7d31216903604c7aaee19", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -28,7 +28,7 @@ use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n use rustc::session::config::{get_unstable_features_setting, OutputType};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n-use rustc::hir::lowering::{lower_crate, LoweringContext};\n+use rustc::hir::lowering::{lower_crate, LoweringContext, DummyResolver};\n use rustc_back::dynamic_lib::DynamicLibrary;\n use rustc_back::tempdir::TempDir;\n use rustc_driver::{driver, Compilation};\n@@ -97,7 +97,8 @@ pub fn run(input: &str,\n     let dep_graph = DepGraph::new(false);\n     let defs = &RefCell::new(hir_map::collect_definitions(&krate));\n \n-    let lcx = LoweringContext::new(&sess, Some(&krate), defs);\n+    let mut dummy_resolver = DummyResolver;\n+    let lcx = LoweringContext::new(&sess, Some(&krate), &mut dummy_resolver);\n     let krate = lower_crate(&lcx, &krate);\n \n     let opts = scrape_test_config(&krate);"}, {"sha": "d1ad330c58ce88f4830d1d71e4657797f3172e8d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -551,6 +551,44 @@ impl fmt::Debug for Pat {\n     }\n }\n \n+impl Pat {\n+    pub fn walk<F>(&self, it: &mut F) -> bool\n+        where F: FnMut(&Pat) -> bool\n+    {\n+        if !it(self) {\n+            return false;\n+        }\n+\n+        match self.node {\n+            PatKind::Ident(_, _, Some(ref p)) => p.walk(it),\n+            PatKind::Struct(_, ref fields, _) => {\n+                fields.iter().all(|field| field.node.pat.walk(it))\n+            }\n+            PatKind::TupleStruct(_, Some(ref s)) | PatKind::Tup(ref s) => {\n+                s.iter().all(|p| p.walk(it))\n+            }\n+            PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n+                s.walk(it)\n+            }\n+            PatKind::Vec(ref before, ref slice, ref after) => {\n+                before.iter().all(|p| p.walk(it)) &&\n+                slice.iter().all(|p| p.walk(it)) &&\n+                after.iter().all(|p| p.walk(it))\n+            }\n+            PatKind::Wild |\n+            PatKind::Lit(_) |\n+            PatKind::Range(_, _) |\n+            PatKind::Ident(_, _, _) |\n+            PatKind::TupleStruct(..) |\n+            PatKind::Path(..) |\n+            PatKind::QPath(_, _) |\n+            PatKind::Mac(_) => {\n+                true\n+            }\n+        }\n+    }\n+}\n+\n /// A single field in a struct pattern\n ///\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`"}, {"sha": "31604e2fdd3a7175e87e497b543b0a33e168dcc8", "filename": "src/test/compile-fail/issue-23716.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -16,7 +16,6 @@ fn bar(foo: i32) {}\n \n mod submod {\n     pub static answer: i32 = 42;\n-    //~^ NOTE static variable defined here\n }\n \n use self::submod::answer;"}, {"sha": "98412c08df5206746d84aca139c09e0df1efa52d", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -34,7 +34,6 @@ use rustc::ty;\n use rustc::session::config::{self, basic_options, build_configuration, Input, Options};\n use rustc::session::build_session;\n use rustc_driver::{driver, abort_on_err};\n-use rustc::hir::lowering::{lower_crate, LoweringContext};\n use rustc_resolve::MakeGlobMap;\n use rustc_metadata::creader::LocalCrateReader;\n use rustc_metadata::cstore::CStore;\n@@ -243,14 +242,16 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let krate = driver::assign_node_ids(&sess, krate);\n         let defs = RefCell::new(ast_map::collect_definitions(&krate));\n         LocalCrateReader::new(&sess, &cstore, &defs, &krate, &id).read_crates(&dep_graph);\n-        let lcx = LoweringContext::new(&sess, Some(&krate), &defs);\n-        let mut hir_forest = ast_map::Forest::new(lower_crate(&lcx, &krate), dep_graph);\n+        let (analysis, resolutions, mut hir_forest) = {\n+            let defs = &mut *defs.borrow_mut();\n+            driver::lower_and_resolve(&sess, &id, defs, &krate, dep_graph, MakeGlobMap::No)\n+        };\n         let arenas = ty::CtxtArenas::new();\n         let ast_map = ast_map::map_crate(&mut hir_forest, &defs);\n \n         abort_on_err(driver::phase_3_run_analysis_passes(\n-            &sess, ast_map, &arenas, &id,\n-            MakeGlobMap::No, |tcx, mir_map, analysis, _| {\n+            &sess, ast_map, analysis, resolutions, &arenas, &id,\n+            |tcx, mir_map, analysis, _| {\n \n             let trans = driver::phase_4_translate_to_llvm(tcx, mir_map.unwrap(), analysis);\n "}, {"sha": "0717af98b30b43c87600cdecba73241d1056b4a4", "filename": "src/test/run-make/pretty-expanded-hygiene/input.pp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.pp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.pp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.pp.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -14,3 +14,5 @@\n \n \n fn bar /* 62#0 */() { let x /* 59#2 */ = 1; y /* 61#4 */ + x /* 59#5 */ }\n+\n+fn y /* 61#0 */() { }"}, {"sha": "422fbdb08848834616c6ad6736dc65acb391d7d1", "filename": "src/test/run-make/pretty-expanded-hygiene/input.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d2424cc304e97f553c6d8eef17a24dc2f12c01/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.rs?ref=a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "patch": "@@ -20,3 +20,5 @@ fn bar() {\n     let x = 1;\n     foo!(x)\n }\n+\n+fn y() {}"}]}