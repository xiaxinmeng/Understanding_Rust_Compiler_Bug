{"sha": "552080181c58beef03493a110b4a38b20b6b5da5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MjA4MDE4MWM1OGJlZWYwMzQ5M2ExMTBiNGEzOGIyMGI2YjVkYTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-27T23:11:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-27T23:11:21Z"}, "message": "Auto merge of #23796 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "3dbfd8c87647f67e1d17c726e72b153609d7eea8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dbfd8c87647f67e1d17c726e72b153609d7eea8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/552080181c58beef03493a110b4a38b20b6b5da5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/552080181c58beef03493a110b4a38b20b6b5da5", "html_url": "https://github.com/rust-lang/rust/commit/552080181c58beef03493a110b4a38b20b6b5da5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/552080181c58beef03493a110b4a38b20b6b5da5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c9de8140b8abdd2d0a83db93746c58e8bc0da2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c9de8140b8abdd2d0a83db93746c58e8bc0da2c", "html_url": "https://github.com/rust-lang/rust/commit/0c9de8140b8abdd2d0a83db93746c58e8bc0da2c"}, {"sha": "d3a4f362cba36a4bf0bb8f8a951ae9d6858ae73e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3a4f362cba36a4bf0bb8f8a951ae9d6858ae73e", "html_url": "https://github.com/rust-lang/rust/commit/d3a4f362cba36a4bf0bb8f8a951ae9d6858ae73e"}], "stats": {"total": 16394, "additions": 7967, "deletions": 8427}, "files": [{"sha": "f0aacc1460b3fa7b372b6919e632ece9921aea36", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -12,9 +12,7 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(int_uint)]\n #![feature(old_io)]\n-#![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(unboxed_closures)]\n #![feature(std_misc)]"}, {"sha": "4b2a3e0283dc2a54347045890d03e7bffeb29a5e", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -15,13 +15,13 @@ use std::io::prelude::*;\n use std::path::Path;\n \n pub struct ExpectedError {\n-    pub line: uint,\n+    pub line: usize,\n     pub kind: String,\n     pub msg: String,\n }\n \n #[derive(PartialEq, Debug)]\n-enum WhichLine { ThisLine, FollowPrevious(uint), AdjustBackward(uint) }\n+enum WhichLine { ThisLine, FollowPrevious(usize), AdjustBackward(usize) }\n \n /// Looks for either \"//~| KIND MESSAGE\" or \"//~^^... KIND MESSAGE\"\n /// The former is a \"follow\" that inherits its target from the preceding line;\n@@ -58,8 +58,8 @@ pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n     }).collect()\n }\n \n-fn parse_expected(last_nonfollow_error: Option<uint>,\n-                  line_num: uint,\n+fn parse_expected(last_nonfollow_error: Option<usize>,\n+                  line_num: usize,\n                   line: &str) -> Option<(WhichLine, ExpectedError)> {\n     let start = match line.find(\"//~\") { Some(i) => i, None => return None };\n     let (follow, adjusts) = if line.char_at(start + 3) == '|' {"}, {"sha": "9612c0e06a34d7b311fb08db18b5181e7ac2fe7f", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -357,7 +357,7 @@ pub fn parse_name_value_directive(line: &str, directive: &str)\n     }\n }\n \n-pub fn gdb_version_to_int(version_string: &str) -> int {\n+pub fn gdb_version_to_int(version_string: &str) -> isize {\n     let error_string = format!(\n         \"Encountered GDB version string with unexpected format: {}\",\n         version_string);\n@@ -369,17 +369,17 @@ pub fn gdb_version_to_int(version_string: &str) -> int {\n         panic!(\"{}\", error_string);\n     }\n \n-    let major: int = components[0].parse().ok().expect(&error_string);\n-    let minor: int = components[1].parse().ok().expect(&error_string);\n+    let major: isize = components[0].parse().ok().expect(&error_string);\n+    let minor: isize = components[1].parse().ok().expect(&error_string);\n \n     return major * 1000 + minor;\n }\n \n-pub fn lldb_version_to_int(version_string: &str) -> int {\n+pub fn lldb_version_to_int(version_string: &str) -> isize {\n     let error_string = format!(\n         \"Encountered LLDB version string with unexpected format: {}\",\n         version_string);\n     let error_string = error_string;\n-    let major: int = version_string.parse().ok().expect(&error_string);\n+    let major: isize = version_string.parse().ok().expect(&error_string);\n     return major;\n }"}, {"sha": "b30efaa6c29d80c73bfef4c4c75c32e7cf393fb0", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -8,27 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(deprecated)] // for old path, for dynamic_lib\n-\n use std::dynamic_lib::DynamicLibrary;\n use std::io::prelude::*;\n-use std::old_path::Path;\n+use std::path::PathBuf;\n use std::process::{ExitStatus, Command, Child, Output, Stdio};\n \n fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     // Need to be sure to put both the lib_path and the aux path in the dylib\n     // search path for the child.\n     let mut path = DynamicLibrary::search_path();\n     match aux_path {\n-        Some(p) => path.insert(0, Path::new(p)),\n+        Some(p) => path.insert(0, PathBuf::from(p)),\n         None => {}\n     }\n-    path.insert(0, Path::new(lib_path));\n+    path.insert(0, PathBuf::from(lib_path));\n \n     // Add the new dylib search path var\n     let var = DynamicLibrary::envvar();\n     let newpath = DynamicLibrary::create_path(&path);\n-    let newpath = String::from_utf8(newpath).unwrap();\n+    let newpath = newpath.to_str().unwrap().to_string();\n     cmd.env(var, &newpath);\n }\n "}, {"sha": "23267c3e93472cb0b4f3faf59fd675594635e13d", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -758,7 +758,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n struct DebuggerCommands {\n     commands: Vec<String>,\n     check_lines: Vec<String>,\n-    breakpoint_lines: Vec<uint>,\n+    breakpoint_lines: Vec<usize>,\n }\n \n fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n@@ -1036,7 +1036,7 @@ fn is_compiler_error_or_warning(line: &str) -> bool {\n          scan_string(line, \"warning\", &mut i));\n }\n \n-fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n+fn scan_until_char(haystack: &str, needle: char, idx: &mut usize) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n@@ -1048,7 +1048,7 @@ fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     return true;\n }\n \n-fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n+fn scan_char(haystack: &str, needle: char, idx: &mut usize) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n@@ -1060,7 +1060,7 @@ fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     return true;\n }\n \n-fn scan_integer(haystack: &str, idx: &mut uint) -> bool {\n+fn scan_integer(haystack: &str, idx: &mut usize) -> bool {\n     let mut i = *idx;\n     while i < haystack.len() {\n         let ch = haystack.char_at(i);\n@@ -1076,7 +1076,7 @@ fn scan_integer(haystack: &str, idx: &mut uint) -> bool {\n     return true;\n }\n \n-fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n+fn scan_string(haystack: &str, needle: &str, idx: &mut usize) -> bool {\n     let mut haystack_i = *idx;\n     let mut needle_i = 0;\n     while needle_i < needle.len() {\n@@ -1725,7 +1725,7 @@ fn disassemble_extract(config: &Config, _props: &TestProps,\n }\n \n \n-fn count_extracted_lines(p: &Path) -> uint {\n+fn count_extracted_lines(p: &Path) -> usize {\n     let mut x = Vec::new();\n     File::open(&p.with_extension(\"ll\")).unwrap().read_to_end(&mut x).unwrap();\n     let x = str::from_utf8(&x).unwrap();"}, {"sha": "a8b26cb3ef76835a5fb498ca76a347eabcfee5e8", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -13,33 +13,34 @@ use common::Config;\n \n /// Conversion table from triple OS name to Rust SYSNAME\n const OS_TABLE: &'static [(&'static str, &'static str)] = &[\n-    (\"mingw32\", \"windows\"),\n-    (\"win32\", \"windows\"),\n-    (\"windows\", \"windows\"),\n-    (\"darwin\", \"macos\"),\n     (\"android\", \"android\"),\n-    (\"linux\", \"linux\"),\n-    (\"freebsd\", \"freebsd\"),\n-    (\"dragonfly\", \"dragonfly\"),\n     (\"bitrig\", \"bitrig\"),\n+    (\"darwin\", \"macos\"),\n+    (\"dragonfly\", \"dragonfly\"),\n+    (\"freebsd\", \"freebsd\"),\n+    (\"ios\", \"ios\"),\n+    (\"linux\", \"linux\"),\n+    (\"mingw32\", \"windows\"),\n     (\"openbsd\", \"openbsd\"),\n+    (\"win32\", \"windows\"),\n+    (\"windows\", \"windows\"),\n ];\n \n const ARCH_TABLE: &'static [(&'static str, &'static str)] = &[\n-    (\"i386\", \"x86\"),\n-    (\"i686\", \"x86\"),\n+    (\"aarch64\", \"aarch64\"),\n     (\"amd64\", \"x86_64\"),\n-    (\"x86_64\", \"x86_64\"),\n-    (\"sparc\", \"sparc\"),\n-    (\"powerpc\", \"powerpc\"),\n-    (\"arm64\", \"aarch64\"),\n     (\"arm\", \"arm\"),\n-    (\"aarch64\", \"aarch64\"),\n+    (\"arm64\", \"aarch64\"),\n+    (\"hexagon\", \"hexagon\"),\n+    (\"i386\", \"x86\"),\n+    (\"i686\", \"x86\"),\n     (\"mips\", \"mips\"),\n-    (\"xcore\", \"xcore\"),\n     (\"msp430\", \"msp430\"),\n-    (\"hexagon\", \"hexagon\"),\n+    (\"powerpc\", \"powerpc\"),\n     (\"s390x\", \"systemz\"),\n+    (\"sparc\", \"sparc\"),\n+    (\"x86_64\", \"x86_64\"),\n+    (\"xcore\", \"xcore\"),\n ];\n \n pub fn get_os(triple: &str) -> &'static str {"}, {"sha": "4da7d6db444fa3e71ac4c2b2b64a9549bbb07b08", "filename": "src/doc/reference.md", "status": "modified", "additions": 32, "deletions": 248, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -645,18 +645,7 @@ fn bar() {\n \n A number of minor features of Rust are not central enough to have their own\n syntax, and yet are not implementable as functions. Instead, they are given\n-names, and invoked through a consistent syntax: `name!(...)`. Examples include:\n-\n-* `format!` : format data into a string\n-* `env!` : look up an environment variable's value at compile time\n-* `file!`: return the path to the file being compiled\n-* `stringify!` : pretty-print the Rust expression given as an argument\n-* `include!` : include the Rust expression in the given file\n-* `include_str!` : include the contents of the given file as a string\n-* `include_bytes!` : include the contents of the given file as a binary blob\n-* `error!`, `warn!`, `info!`, `debug!` : provide diagnostic information.\n-\n-All of the above extensions are expressions with values.\n+names, and invoked through a consistent syntax: `some_extension!(...)`.\n \n Users of `rustc` can define new syntax extensions in two ways:\n \n@@ -744,38 +733,6 @@ Rust syntax is restricted in two ways:\n    pairs when they occur at the beginning of, or immediately after, a `$(...)*`;\n    requiring a distinctive token in front can solve the problem.\n \n-## Syntax extensions useful in macros\n-\n-* `stringify!` : turn the identifier argument into a string literal\n-* `concat!` : concatenates a comma-separated list of literals\n-\n-## Syntax extensions for macro debugging\n-\n-* `log_syntax!` : print out the arguments at compile time\n-* `trace_macros!` : supply `true` or `false` to enable or disable macro expansion logging\n-\n-## Quasiquoting\n-\n-The following syntax extensions are used for quasiquoting Rust syntax trees,\n-usually in [procedural macros](book/plugins.html#syntax-extensions):\n-\n-* `quote_expr!`\n-* `quote_item!`\n-* `quote_pat!`\n-* `quote_stmt!`\n-* `quote_tokens!`\n-* `quote_matcher!`\n-* `quote_ty!`\n-* `quote_attr!`\n-\n-Keep in mind that when `$name : ident` appears in the input to\n-`quote_tokens!`, the result contains unquoted `name` followed by two tokens.\n-However, input of the same form passed to `quote_matcher!` becomes a\n-quasiquoted MBE-matcher of a nonterminal. No unquotation happens. Otherwise\n-the result of `quote_matcher!` is identical to that of `quote_tokens!`.\n-\n-Documentation is very limited at the moment.\n-\n # Crates and source files\n \n Rust is a *compiled* language. Its semantics obey a *phase distinction*\n@@ -980,7 +937,7 @@ extern crate pcre;\n \n extern crate std; // equivalent to: extern crate std as std;\n \n-extern crate \"std\" as ruststd; // linking to 'std' under another name\n+extern crate std as ruststd; // linking to 'std' under another name\n ```\n \n ##### Use declarations\n@@ -1521,22 +1478,6 @@ statics:\n Constants should in general be preferred over statics, unless large amounts of\n data are being stored, or single-address and mutability properties are required.\n \n-```\n-use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n-\n-// Note that ATOMIC_USIZE_INIT is a *const*, but it may be used to initialize a\n-// static. This static can be modified, so it is not placed in read-only memory.\n-static COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n-\n-// This table is a candidate to be placed in read-only memory.\n-static TABLE: &'static [usize] = &[1, 2, 3, /* ... */];\n-\n-for slot in TABLE.iter() {\n-    println!(\"{}\", slot);\n-}\n-COUNTER.fetch_add(1, Ordering::SeqCst);\n-```\n-\n #### Mutable statics\n \n If a static item is declared with the `mut` keyword, then it is allowed to\n@@ -2376,18 +2317,6 @@ impl<T: PartialEq> PartialEq for Foo<T> {\n }\n ```\n \n-Supported traits for `derive` are:\n-\n-* Comparison traits: `PartialEq`, `Eq`, `PartialOrd`, `Ord`.\n-* Serialization: `Encodable`, `Decodable`. These require `serialize`.\n-* `Clone`, to create `T` from `&T` via a copy.\n-* `Default`, to create an empty instance of a data type.\n-* `FromPrimitive`, to create an instance from a numeric primitive.\n-* `Hash`, to iterate over the bytes in a data type.\n-* `Rand`, to create a random instance of a data type.\n-* `Debug`, to format a value using the `{:?}` formatter.\n-* `Copy`, for \"Plain Old Data\" types which can be copied by simply moving bits.\n-\n ### Compiler Features\n \n Certain aspects of Rust may be implemented in the compiler, but they're not\n@@ -2408,9 +2337,13 @@ considered off, and using the features will result in a compiler error.\n \n The currently implemented features of the reference compiler are:\n \n-* `advanced_slice_patterns` - see the [match expressions](#match-expressions)\n+* `advanced_slice_patterns` - See the [match expressions](#match-expressions)\n                               section for discussion; the exact semantics of\n-                              slice patterns are subject to change.\n+                              slice patterns are subject to change, so some types\n+\t\t\t      are still unstable.\n+\n+* `slice_patterns` - OK, actually, slice patterns are just scary and\n+                     completely unstable.\n \n * `asm` - The `asm!` macro provides a means for inline assembly. This is often\n           useful, but the exact syntax for this feature along with its\n@@ -2440,9 +2373,6 @@ The currently implemented features of the reference compiler are:\n * `intrinsics` - Allows use of the \"rust-intrinsics\" ABI. Compiler intrinsics\n                  are inherently unstable and no promise about them is made.\n \n-* `int_uint` - Allows the use of the `int` and `uint` types, which are deprecated.\n-               Use `isize` and `usize` instead.\n-\n * `lang_items` - Allows use of the `#[lang]` attribute. Like `intrinsics`,\n                  lang items are inherently unstable and no promise about them\n                  is made.\n@@ -2759,7 +2689,7 @@ The following are examples of structure expressions:\n ```\n # struct Point { x: f64, y: f64 }\n # struct TuplePoint(f64, f64);\n-# mod game { pub struct User<'a> { pub name: &'a str, pub age: u32, pub score: uint } }\n+# mod game { pub struct User<'a> { pub name: &'a str, pub age: u32, pub score: usize } }\n # struct Cookie; fn some_fn<T>(t: T) {}\n Point {x: 10.0, y: 20.0};\n TuplePoint(10.0, 20.0);\n@@ -3329,7 +3259,7 @@ array, like `[.., 42, ..]`. If preceded by a variable name, it will bind the\n corresponding slice to the variable. Example:\n \n ```\n-# #![feature(advanced_slice_patterns)]\n+# #![feature(advanced_slice_patterns, slice_patterns)]\n fn is_symmetric(list: &[u32]) -> bool {\n     match list {\n         [] | [_]                   => true,\n@@ -3402,7 +3332,7 @@ subpattern`. For example:\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n \n-enum List { Nil, Cons(uint, Box<List>) }\n+enum List { Nil, Cons(u32, Box<List>) }\n \n fn is_sorted(list: &List) -> bool {\n     match *list {\n@@ -3886,75 +3816,27 @@ impl Printable for String {\n `self` refers to the value of type `String` that is the receiver for a call to\n the method `make_string`.\n \n-## Type kinds\n-\n-Types in Rust are categorized into kinds, based on various properties of the\n-components of the type. The kinds are:\n-\n-* `Send`\n-  : Types of this kind can be safely sent between threads.\n-    This kind includes scalars, boxes, procs, and\n-    structural types containing only other owned types.\n-    All `Send` types are `'static`.\n-* `Copy`\n-  : Types of this kind consist of \"Plain Old Data\"\n-    which can be copied by simply moving bits.\n-    All values of this kind can be implicitly copied.\n-    This kind includes scalars and immutable references,\n-    as well as structural types containing other `Copy` types.\n-* `'static`\n-  : Types of this kind do not contain any references (except for\n-    references with the `static` lifetime, which are allowed).\n-    This can be a useful guarantee for code\n-    that breaks borrowing assumptions\n-    using [`unsafe` operations](#unsafe-functions).\n-* `Drop`\n-  : This is not strictly a kind,\n-    but its presence interacts with kinds:\n-    the `Drop` trait provides a single method `drop`\n-    that takes no parameters,\n-    and is run when values of the type are dropped.\n-    Such a method is called a \"destructor\",\n-    and are always executed in \"top-down\" order:\n-    a value is completely destroyed\n-    before any of the values it owns run their destructors.\n-    Only `Send` types can implement `Drop`.\n-\n-* _Default_\n-  : Types with destructors, closure environments,\n-    and various other _non-first-class_ types,\n-    are not copyable at all.\n-    Such types can usually only be accessed through pointers,\n-    or in some cases, moved between mutable locations.\n-\n-Kinds can be supplied as _bounds_ on type parameters, like traits, in which\n-case the parameter is constrained to types satisfying that kind.\n-\n-By default, type parameters do not carry any assumed kind-bounds at all. When\n-instantiating a type parameter, the kind bounds on the parameter are checked to\n-be the same or narrower than the kind of the type that it is instantiated with.\n-\n-Sending operations are not part of the Rust language, but are implemented in\n-the library. Generic functions that send values bound the kind of these values\n-to sendable.\n-\n-# Memory and concurrency models\n-\n-Rust has a memory model centered around concurrently-executing _threads_. Thus\n-its memory model and its concurrency model are best discussed simultaneously,\n-as parts of each only make sense when considered from the perspective of the\n-other.\n-\n-When reading about the memory model, keep in mind that it is partitioned in\n-order to support threads; and when reading about threads, keep in mind that their\n-isolation and communication mechanisms are only possible due to the ownership\n-and lifetime semantics of the memory model.\n-\n-## Memory model\n-\n-A Rust program's memory consists of a static set of *items*, a set of\n-[threads](#threads) each with its own *stack*, and a *heap*. Immutable portions of\n-the heap may be shared between threads, mutable portions may not.\n+# The `Copy` trait\n+\n+Rust has a special trait, `Copy`, which when implemented changes the semantics\n+of a value. Values whose type implements `Copy` are copied rather than moved\n+upon assignment.\n+\n+# The `Sized` trait\n+\n+`Sized` is a special trait which indicates that the size of this type is known\n+at compile-time.\n+\n+# The `Drop` trait\n+\n+The `Drop` trait provides a destructor, to be run whenever a value of this type\n+is to be destroyed.\n+\n+# Memory model\n+\n+A Rust program's memory consists of a static set of *items* and a *heap*.\n+Immutable portions of the heap may be shared between threads, mutable portions\n+may not.\n \n Allocations in the stack consist of *slots*, and allocations in the heap\n consist of *boxes*.\n@@ -3965,36 +3847,18 @@ The _items_ of a program are those functions, modules and types that have their\n value calculated at compile-time and stored uniquely in the memory image of the\n rust process. Items are neither dynamically allocated nor freed.\n \n-A thread's _stack_ consists of activation frames automatically allocated on entry\n-to each function as the thread executes. A stack allocation is reclaimed when\n-control leaves the frame containing it.\n-\n The _heap_ is a general term that describes boxes.  The lifetime of an\n allocation in the heap depends on the lifetime of the box values pointing to\n it. Since box values may themselves be passed in and out of frames, or stored\n in the heap, heap allocations may outlive the frame they are allocated within.\n \n ### Memory ownership\n \n-A thread owns all memory it can *safely* reach through local variables, as well\n-as boxes and references.\n-\n-When a thread sends a value that has the `Send` trait to another thread, it loses\n-ownership of the value sent and can no longer refer to it. This is statically\n-guaranteed by the combined use of \"move semantics\", and the compiler-checked\n-_meaning_ of the `Send` trait: it is only instantiated for (transitively)\n-sendable kinds of data constructor and pointers, never including references.\n-\n When a stack frame is exited, its local allocations are all released, and its\n references to boxes are dropped.\n \n-When a thread finishes, its stack is necessarily empty and it therefore has no\n-references to any boxes; the remainder of its heap is immediately freed.\n-\n ### Memory slots\n \n-A thread's stack contains slots.\n-\n A _slot_ is a component of a stack frame, either a function parameter, a\n [temporary](#lvalues,-rvalues-and-temporaries), or a local variable.\n \n@@ -4024,86 +3888,6 @@ state. Subsequent statements within a function may or may not initialize the\n local variables. Local variables can be used only after they have been\n initialized; this is enforced by the compiler.\n \n-### Boxes\n-\n-A _box_ is a reference to a heap allocation holding another value, which is\n-constructed by the prefix operator `box`. When the standard library is in use,\n-the type of a box is `std::owned::Box<T>`.\n-\n-An example of a box type and value:\n-\n-```\n-let x: Box<i32> = Box::new(10);\n-```\n-\n-Box values exist in 1:1 correspondence with their heap allocation, copying a\n-box value makes a shallow copy of the pointer. Rust will consider a shallow\n-copy of a box to move ownership of the value. After a value has been moved,\n-the source location cannot be used unless it is reinitialized.\n-\n-```\n-let x: Box<i32> = Box::new(10);\n-let y = x;\n-// attempting to use `x` will result in an error here\n-```\n-\n-## Threads\n-\n-Rust's primary concurrency mechanism is called a **thread**.\n-\n-### Communication between threads\n-\n-Rust threads are isolated and generally unable to interfere with one another's\n-memory directly, except through [`unsafe` code](#unsafe-functions).  All\n-contact between threads is mediated by safe forms of ownership transfer, and data\n-races on memory are prohibited by the type system.\n-\n-When you wish to send data between threads, the values are restricted to the\n-[`Send` type-kind](#type-kinds). Restricting communication interfaces to this\n-kind ensures that no references move between threads. Thus access to an entire\n-data structure can be mediated through its owning \"root\" value; no further\n-locking or copying is required to avoid data races within the substructure of\n-such a value.\n-\n-### Thread\n-\n-The _lifecycle_ of a threads consists of a finite set of states and events that\n-cause transitions between the states. The lifecycle states of a thread are:\n-\n-* running\n-* blocked\n-* panicked\n-* dead\n-\n-A thread begins its lifecycle &mdash; once it has been spawned &mdash; in the\n-*running* state. In this state it executes the statements of its entry\n-function, and any functions called by the entry function.\n-\n-A thread may transition from the *running* state to the *blocked* state any time\n-it makes a blocking communication call. When the call can be completed &mdash;\n-when a message arrives at a sender, or a buffer opens to receive a message\n-&mdash; then the blocked thread will unblock and transition back to *running*.\n-\n-A thread may transition to the *panicked* state at any time, due being killed by\n-some external event or internally, from the evaluation of a `panic!()` macro.\n-Once *panicking*, a thread unwinds its stack and transitions to the *dead* state.\n-Unwinding the stack of a thread is done by the thread itself, on its own control\n-stack. If a value with a destructor is freed during unwinding, the code for the\n-destructor is run, also on the thread's control stack. Running the destructor\n-code causes a temporary transition to a *running* state, and allows the\n-destructor code to cause any subsequent state transitions. The original thread\n-of unwinding and panicking thereby may suspend temporarily, and may involve\n-(recursive) unwinding of the stack of a failed destructor. Nonetheless, the\n-outermost unwinding activity will continue until the stack is unwound and the\n-thread transitions to the *dead* state. There is no way to \"recover\" from thread\n-panics. Once a thread has temporarily suspended its unwinding in the *panicking*\n-state, a panic occurring from within this destructor results in *hard* panic.\n-A hard panic currently results in the process aborting.\n-\n-A thread in the *dead* state cannot transition to other states; it exists only to\n-have its termination status inspected by other threads, and/or to await\n-reclamation when the last reference to it drops.\n-\n # Runtime services, linkage and debugging\n \n The Rust _runtime_ is a relatively compact collection of Rust code that"}, {"sha": "4a866d6224d5d134b01120deaac0b4ef4abb74d6", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -11,8 +11,7 @@ navigate through the menu on the left.\n <h2 class=\"section-header\"><a href=\"basic.html\">Basics</a></h2>\n \n This section is a linear introduction to the basic syntax and semantics of\n-Rust. It has individual sections on each part of Rust's syntax, and culminates\n-in a small project: a guessing game.\n+Rust. It has individual sections on each part of Rust's syntax.\n \n After reading \"Basics,\" you will have a good foundation to learn more about\n Rust, and can write very simple programs.\n@@ -29,7 +28,12 @@ and will be able to understand most Rust code and write more complex programs.\n \n In a similar fashion to \"Intermediate,\" this section is full of individual,\n deep-dive chapters, which stand alone and can be read in any order. These\n-chapters focus on the most complex features, as well as some things that\n-are only available in upcoming versions of Rust.\n+chapters focus on the most complex features,\n \n-After reading \"Advanced,\" you'll be a Rust expert!\n+<h2 class=\"section-header\"><a href=\"unstable.html\">Unstable</a></h2>\n+\n+In a similar fashion to \"Intermediate,\" this section is full of individual,\n+deep-dive chapters, which stand alone and can be read in any order.\n+\n+This chapter contains things that are only available on the nightly channel of\n+Rust."}, {"sha": "140086e32d080e6f819d43326782a7244c56fe83", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -36,6 +36,12 @@\n     * [FFI](ffi.md)\n     * [Unsafe Code](unsafe.md)\n     * [Advanced Macros](advanced-macros.md)\n+* [Unstable Rust](unstable.md)\n     * [Compiler Plugins](plugins.md)\n+    * [Inline Assembly](inline-assembly.md)\n+    * [No stdlib](no-stdlib.md)\n+    * [Intrinsics](intrinsics.md)\n+    * [Lang items](lang-items.md)\n+    * [Link args](link-args.md)\n * [Conclusion](conclusion.md)\n * [Glossary](glossary.md)"}, {"sha": "fef458caaaf3343a1aa2e198888d005bc2ba8221", "filename": "src/doc/trpl/advanced-macros.md", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -206,8 +206,6 @@ the [Bitwise Cyclic Tag](http://esolangs.org/wiki/Bitwise_Cyclic_Tag) automaton\n within Rust's macro system.\n \n ```rust\n-#![feature(trace_macros)]\n-\n macro_rules! bct {\n     // cmd 0:  d ... => ...\n     (0, $($ps:tt),* ; $_d:tt)\n@@ -229,13 +227,6 @@ macro_rules! bct {\n     ( $($ps:tt),* ; )\n         => (());\n }\n-\n-fn main() {\n-    trace_macros!(true);\n-# /* just check the definition\n-    bct!(0, 0, 1, 1, 1 ; 1, 0, 1);\n-# */\n-}\n ```\n \n Exercise: use macros to reduce duplication in the above definition of the"}, {"sha": "fb56e4a676784908f085797f168f37920dac32d9", "filename": "src/doc/trpl/arrays-vectors-and-slices.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -99,7 +99,5 @@ You can also take a slice of a vector, `String`, or `&str`, because they are\n backed by arrays. Slices have type `&[T]`, which we'll talk about when we cover\n generics.\n \n-We have now learned all of the most basic Rust concepts. We're ready to start\n-building ourselves a guessing game, we just need to know one last thing: how to\n-get input from the keyboard. You can't have a guessing game without the ability\n-to guess!\n+We have now learned all of the most basic Rust concepts. Next, we learn how to\n+get input from the keyboard."}, {"sha": "c267830e6e0d0c5e0fc700713abb67ad205ef7d4", "filename": "src/doc/trpl/basic.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fbasic.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fbasic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbasic.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -1,8 +1,7 @@\n % Basics\n \n This section is a linear introduction to the basic syntax and semantics of\n-Rust. It has individual sections on each part of Rust's syntax, and cumulates\n-in a small project: a guessing game.\n+Rust. It has individual sections on each part of Rust's syntax.\n \n After reading \"Basics,\" you will have a good foundation to learn more about\n Rust, and can write very simple programs."}, {"sha": "e44d2edd667a1ea822cde1798278bbc8b1fe3b55", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -361,5 +361,4 @@ and brittle `if`/`else`s.\n \n [arity]: ./glossary.html#arity\n [match]: ./match.html\n-[game]: ./guessing-game.html#comparing-guesses\n [generics]: ./generics.html"}, {"sha": "43b49c09ae4ac7ace50eaee3c728c9d0059a7a77", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -352,7 +352,7 @@ Here\u2019s an example of documenting a macro:\n /// # }\n /// ```\n ///\n-/// ```should_fail\n+/// ```should_panic\n /// # #[macro_use] extern crate foo;\n /// # fn main() {\n /// panic_unless!(true == false, \u201cI\u2019m broken.\u201d);"}, {"sha": "23f6e17b860b23a13da61e5e95db73eca0bf370b", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -366,31 +366,6 @@ A few examples of how this model can be used are:\n \n On OSX, frameworks behave with the same semantics as a dynamic library.\n \n-## The `link_args` attribute\n-\n-There is one other way to tell rustc how to customize linking, and that is via\n-the `link_args` attribute. This attribute is applied to `extern` blocks and\n-specifies raw flags which need to get passed to the linker when producing an\n-artifact. An example usage would be:\n-\n-``` no_run\n-#![feature(link_args)]\n-\n-#[link_args = \"-foo -bar -baz\"]\n-extern {}\n-# fn main() {}\n-```\n-\n-Note that this feature is currently hidden behind the `feature(link_args)` gate\n-because this is not a sanctioned way of performing linking. Right now rustc\n-shells out to the system linker, so it makes sense to provide extra command line\n-arguments, but this will not always be the case. In the future rustc may use\n-LLVM directly to link native libraries in which case `link_args` will have no\n-meaning.\n-\n-It is highly recommended to *not* use this attribute, and rather use the more\n-formal `#[link(...)]` attribute on `extern` blocks instead.\n-\n # Unsafe blocks\n \n Some operations, like dereferencing unsafe pointers or calling functions that have been marked\n@@ -401,7 +376,7 @@ Unsafe functions, on the other hand, advertise it to the world. An unsafe functi\n this:\n \n ```\n-unsafe fn kaboom(ptr: *const int) -> int { *ptr }\n+unsafe fn kaboom(ptr: *const i32) -> i32 { *ptr }\n ```\n \n This function can only be called from an `unsafe` block or another `unsafe` function.\n@@ -423,7 +398,7 @@ extern {\n \n fn main() {\n     println!(\"You have readline version {} installed.\",\n-             rl_readline_version as int);\n+             rl_readline_version as i32);\n }\n ```\n "}, {"sha": "1a4592f980fa720c5a5cbbac5548b86d39cf741b", "filename": "src/doc/trpl/inline-assembly.md", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finline-assembly.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -0,0 +1,141 @@\n+% Inline Assembly\n+\n+For extremely low-level manipulations and performance reasons, one\n+might wish to control the CPU directly. Rust supports using inline\n+assembly to do this via the `asm!` macro. The syntax roughly matches\n+that of GCC & Clang:\n+\n+```ignore\n+asm!(assembly template\n+   : output operands\n+   : input operands\n+   : clobbers\n+   : options\n+   );\n+```\n+\n+Any use of `asm` is feature gated (requires `#![feature(asm)]` on the\n+crate to allow) and of course requires an `unsafe` block.\n+\n+> **Note**: the examples here are given in x86/x86-64 assembly, but\n+> all platforms are supported.\n+\n+## Assembly template\n+\n+The `assembly template` is the only required parameter and must be a\n+literal string (i.e. `\"\"`)\n+\n+```\n+#![feature(asm)]\n+\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn foo() {\n+    unsafe {\n+        asm!(\"NOP\");\n+    }\n+}\n+\n+// other platforms\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+fn foo() { /* ... */ }\n+\n+fn main() {\n+    // ...\n+    foo();\n+    // ...\n+}\n+```\n+\n+(The `feature(asm)` and `#[cfg]`s are omitted from now on.)\n+\n+Output operands, input operands, clobbers and options are all optional\n+but you must add the right number of `:` if you skip them:\n+\n+```\n+# #![feature(asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() { unsafe {\n+asm!(\"xor %eax, %eax\"\n+    :\n+    :\n+    : \"eax\"\n+   );\n+# } }\n+```\n+\n+Whitespace also doesn't matter:\n+\n+```\n+# #![feature(asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() { unsafe {\n+asm!(\"xor %eax, %eax\" ::: \"eax\");\n+# } }\n+```\n+\n+## Operands\n+\n+Input and output operands follow the same format: `:\n+\"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n+expressions must be mutable lvalues:\n+\n+```\n+# #![feature(asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn add(a: i32, b: i32) -> i32 {\n+    let mut c = 0;\n+    unsafe {\n+        asm!(\"add $2, $0\"\n+             : \"=r\"(c)\n+             : \"0\"(a), \"r\"(b)\n+             );\n+    }\n+    c\n+}\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn add(a: i32, b: i32) -> i32 { a + b }\n+\n+fn main() {\n+    assert_eq!(add(3, 14159), 14162)\n+}\n+```\n+\n+## Clobbers\n+\n+Some instructions modify registers which might otherwise have held\n+different values so we use the clobbers list to indicate to the\n+compiler not to assume any values loaded into those registers will\n+stay valid.\n+\n+```\n+# #![feature(asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() { unsafe {\n+// Put the value 0x200 in eax\n+asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n+# } }\n+```\n+\n+Input and output registers need not be listed since that information\n+is already communicated by the given constraints. Otherwise, any other\n+registers used either implicitly or explicitly should be listed.\n+\n+If the assembly changes the condition code register `cc` should be\n+specified as one of the clobbers. Similarly, if the assembly modifies\n+memory, `memory` should also be specified.\n+\n+## Options\n+\n+The last section, `options` is specific to Rust. The format is comma\n+separated literal strings (i.e. `:\"foo\", \"bar\", \"baz\"`). It's used to\n+specify some extra info about the inline assembly:\n+\n+Current valid options are:\n+\n+1. *volatile* - specifying this is analogous to\n+   `__asm__ __volatile__ (...)` in gcc/clang.\n+2. *alignstack* - certain instructions expect the stack to be\n+   aligned a certain way (i.e. SSE) and specifying this indicates to\n+   the compiler to insert its usual stack alignment code\n+3. *intel* - use intel syntax instead of the default AT&T.\n+"}, {"sha": "25f7c54493188d93e76d85b7d2407722f355571f", "filename": "src/doc/trpl/intrinsics.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fintrinsics.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fintrinsics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fintrinsics.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -0,0 +1,25 @@\n+% Intrinsics\n+\n+> **Note**: intrinsics will forever have an unstable interface, it is\n+> recommended to use the stable interfaces of libcore rather than intrinsics\n+> directly.\n+\n+These are imported as if they were FFI functions, with the special\n+`rust-intrinsic` ABI. For example, if one was in a freestanding\n+context, but wished to be able to `transmute` between types, and\n+perform efficient pointer arithmetic, one would import those functions\n+via a declaration like\n+\n+```\n+# #![feature(intrinsics)]\n+# fn main() {}\n+\n+extern \"rust-intrinsic\" {\n+    fn transmute<T, U>(x: T) -> U;\n+\n+    fn offset<T>(dst: *const T, offset: isize) -> *const T;\n+}\n+```\n+\n+As with any other FFI functions, these are always `unsafe` to call.\n+"}, {"sha": "5c27c03e8e0b259a0216abb1245f5e82b8b4fea7", "filename": "src/doc/trpl/lang-items.md", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flang-items.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -0,0 +1,79 @@\n+% Lang items\n+\n+> **Note**: lang items are often provided by crates in the Rust distribution,\n+> and lang items themselves have an unstable interface. It is recommended to use\n+> officially distributed crates instead of defining your own lang items.\n+\n+The `rustc` compiler has certain pluggable operations, that is,\n+functionality that isn't hard-coded into the language, but is\n+implemented in libraries, with a special marker to tell the compiler\n+it exists. The marker is the attribute `#[lang=\"...\"]` and there are\n+various different values of `...`, i.e. various different 'lang\n+items'.\n+\n+For example, `Box` pointers require two lang items, one for allocation\n+and one for deallocation. A freestanding program that uses the `Box`\n+sugar for dynamic allocations via `malloc` and `free`:\n+\n+```\n+#![feature(lang_items, box_syntax, start, no_std, libc)]\n+#![no_std]\n+\n+extern crate libc;\n+\n+extern {\n+    fn abort() -> !;\n+}\n+\n+#[lang = \"owned_box\"]\n+pub struct Box<T>(*mut T);\n+\n+#[lang=\"exchange_malloc\"]\n+unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n+    let p = libc::malloc(size as libc::size_t) as *mut u8;\n+\n+    // malloc failed\n+    if p as usize == 0 {\n+        abort();\n+    }\n+\n+    p\n+}\n+#[lang=\"exchange_free\"]\n+unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n+    libc::free(ptr as *mut libc::c_void)\n+}\n+\n+#[start]\n+fn main(argc: isize, argv: *const *const u8) -> isize {\n+    let x = box 1;\n+\n+    0\n+}\n+\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+```\n+\n+Note the use of `abort`: the `exchange_malloc` lang item is assumed to\n+return a valid pointer, and so needs to do the check internally.\n+\n+Other features provided by lang items include:\n+\n+- overloadable operators via traits: the traits corresponding to the\n+  `==`, `<`, dereferencing (`*`) and `+` (etc.) operators are all\n+  marked with lang items; those specific four are `eq`, `ord`,\n+  `deref`, and `add` respectively.\n+- stack unwinding and general failure; the `eh_personality`, `fail`\n+  and `fail_bounds_checks` lang items.\n+- the traits in `std::marker` used to indicate types of\n+  various kinds; lang items `send`, `sync` and `copy`.\n+- the marker types and variance indicators found in\n+  `std::marker`; lang items `covariant_type`,\n+  `contravariant_lifetime`, etc.\n+\n+Lang items are loaded lazily by the compiler; e.g. if one never uses\n+`Box` then there is no need to define functions for `exchange_malloc`\n+and `exchange_free`. `rustc` will emit an error when an item is needed\n+but not found in the current crate or any that it depends on."}, {"sha": "ee5159afb8e6f41502e00d4857ae9178a84a5ecf", "filename": "src/doc/trpl/link-args.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Flink-args.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Flink-args.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flink-args.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -0,0 +1,25 @@\n+% Link args\n+\n+There is one other way to tell rustc how to customize linking, and that is via\n+the `link_args` attribute. This attribute is applied to `extern` blocks and\n+specifies raw flags which need to get passed to the linker when producing an\n+artifact. An example usage would be:\n+\n+``` no_run\n+#![feature(link_args)]\n+\n+#[link_args = \"-foo -bar -baz\"]\n+extern {}\n+# fn main() {}\n+```\n+\n+Note that this feature is currently hidden behind the `feature(link_args)` gate\n+because this is not a sanctioned way of performing linking. Right now rustc\n+shells out to the system linker, so it makes sense to provide extra command line\n+arguments, but this will not always be the case. In the future rustc may use\n+LLVM directly to link native libraries in which case `link_args` will have no\n+meaning.\n+\n+It is highly recommended to *not* use this attribute, and rather use the more\n+formal `#[link(...)]` attribute on `extern` blocks instead.\n+"}, {"sha": "28f02b1ffe1528239ba2ba798a12dad126dde496", "filename": "src/doc/trpl/looping.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Flooping.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Flooping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flooping.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -123,7 +123,7 @@ We now loop forever with `loop` and use `break` to break out early.\n iteration. This will only print the odd numbers:\n \n ```{rust}\n-for x in 0u32..10 {\n+for x in 0..10 {\n     if x % 2 == 0 { continue; }\n \n     println!(\"{}\", x);"}, {"sha": "85472ff5db76727dde9dad6ec3a7f226305cb0b8", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -46,7 +46,7 @@ This will print `12.566371`.\n \n We've made a struct that represents a circle. We then write an `impl` block,\n and inside it, define a method, `area`. Methods take a  special first\n-parameter, `&self`. There are three variants: `self`, `&self`, and `&mut self`.\n+parameter, of which there are three variants: `self`, `&self`, and `&mut self`.\n You can think of this first parameter as being the `x` in `x.foo()`. The three\n variants correspond to the three kinds of thing `x` could be: `self` if it's\n just a value on the stack, `&self` if it's a reference, and `&mut self` if it's"}, {"sha": "17a463842e71c39fa24c4d9935667a6362b47229", "filename": "src/doc/trpl/more-strings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -129,7 +129,7 @@ need, and it can make your lifetimes more complex.\n To write a function that's generic over types of strings, use `&str`.\n \n ```\n-fn some_string_length(x: &str) -> uint {\n+fn some_string_length(x: &str) -> usize {\n     x.len()\n }\n "}, {"sha": "094c82a08cc9d12ac3eb57ac09deae56043b65ee", "filename": "src/doc/trpl/no-stdlib.md", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fno-stdlib.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -0,0 +1,168 @@\n+% No stdlib\n+\n+By default, `std` is linked to every Rust crate. In some contexts,\n+this is undesirable, and can be avoided with the `#![no_std]`\n+attribute attached to the crate.\n+\n+```ignore\n+// a minimal library\n+#![crate_type=\"lib\"]\n+#![feature(no_std)]\n+#![no_std]\n+# // fn main() {} tricked you, rustdoc!\n+```\n+\n+Obviously there's more to life than just libraries: one can use\n+`#[no_std]` with an executable, controlling the entry point is\n+possible in two ways: the `#[start]` attribute, or overriding the\n+default shim for the C `main` function with your own.\n+\n+The function marked `#[start]` is passed the command line parameters\n+in the same format as C:\n+\n+```\n+#![feature(lang_items, start, no_std, libc)]\n+#![no_std]\n+\n+// Pull in the system libc library for what crt0.o likely requires\n+extern crate libc;\n+\n+// Entry point for this program\n+#[start]\n+fn start(_argc: isize, _argv: *const *const u8) -> isize {\n+    0\n+}\n+\n+// These functions and traits are used by the compiler, but not\n+// for a bare-bones hello world. These are normally\n+// provided by libstd.\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+# // fn main() {} tricked you, rustdoc!\n+```\n+\n+To override the compiler-inserted `main` shim, one has to disable it\n+with `#![no_main]` and then create the appropriate symbol with the\n+correct ABI and the correct name, which requires overriding the\n+compiler's name mangling too:\n+\n+```ignore\n+#![feature(no_std)]\n+#![no_std]\n+#![no_main]\n+#![feature(lang_items, start)]\n+\n+extern crate libc;\n+\n+#[no_mangle] // ensure that this symbol is called `main` in the output\n+pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {\n+    0\n+}\n+\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n+#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+# // fn main() {} tricked you, rustdoc!\n+```\n+\n+\n+The compiler currently makes a few assumptions about symbols which are available\n+in the executable to call. Normally these functions are provided by the standard\n+library, but without it you must define your own.\n+\n+The first of these three functions, `stack_exhausted`, is invoked whenever stack\n+overflow is detected.  This function has a number of restrictions about how it\n+can be called and what it must do, but if the stack limit register is not being\n+maintained then a thread always has an \"infinite stack\" and this function\n+shouldn't get triggered.\n+\n+The second of these three functions, `eh_personality`, is used by the\n+failure mechanisms of the compiler. This is often mapped to GCC's\n+personality function (see the\n+[libstd implementation](../std/rt/unwind/index.html) for more\n+information), but crates which do not trigger a panic can be assured\n+that this function is never called. The final function, `panic_fmt`, is\n+also used by the failure mechanisms of the compiler.\n+\n+## Using libcore\n+\n+> **Note**: the core library's structure is unstable, and it is recommended to\n+> use the standard library instead wherever possible.\n+\n+With the above techniques, we've got a bare-metal executable running some Rust\n+code. There is a good deal of functionality provided by the standard library,\n+however, that is necessary to be productive in Rust. If the standard library is\n+not sufficient, then [libcore](../core/index.html) is designed to be used\n+instead.\n+\n+The core library has very few dependencies and is much more portable than the\n+standard library itself. Additionally, the core library has most of the\n+necessary functionality for writing idiomatic and effective Rust code.\n+\n+As an example, here is a program that will calculate the dot product of two\n+vectors provided from C, using idiomatic Rust practices.\n+\n+```\n+#![feature(lang_items, start, no_std, core, libc)]\n+#![no_std]\n+\n+# extern crate libc;\n+extern crate core;\n+\n+use core::prelude::*;\n+\n+use core::mem;\n+\n+#[no_mangle]\n+pub extern fn dot_product(a: *const u32, a_len: u32,\n+                          b: *const u32, b_len: u32) -> u32 {\n+    use core::raw::Slice;\n+\n+    // Convert the provided arrays into Rust slices.\n+    // The core::raw module guarantees that the Slice\n+    // structure has the same memory layout as a &[T]\n+    // slice.\n+    //\n+    // This is an unsafe operation because the compiler\n+    // cannot tell the pointers are valid.\n+    let (a_slice, b_slice): (&[u32], &[u32]) = unsafe {\n+        mem::transmute((\n+            Slice { data: a, len: a_len as usize },\n+            Slice { data: b, len: b_len as usize },\n+        ))\n+    };\n+\n+    // Iterate over the slices, collecting the result\n+    let mut ret = 0;\n+    for (i, j) in a_slice.iter().zip(b_slice.iter()) {\n+        ret += (*i) * (*j);\n+    }\n+    return ret;\n+}\n+\n+#[lang = \"panic_fmt\"]\n+extern fn panic_fmt(args: &core::fmt::Arguments,\n+                    file: &str,\n+                    line: u32) -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n+# #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }\n+# fn main() {}\n+```\n+\n+Note that there is one extra lang item here which differs from the examples\n+above, `panic_fmt`. This must be defined by consumers of libcore because the\n+core library declares panics, but it does not define it. The `panic_fmt`\n+lang item is this crate's definition of panic, and it must be guaranteed to\n+never return.\n+\n+As can be seen in this example, the core library is intended to provide the\n+power of Rust in all circumstances, regardless of platform requirements. Further\n+libraries, such as liballoc, add functionality to libcore which make other\n+platform-specific assumptions, but continue to be more portable than the\n+standard library itself.\n+"}, {"sha": "4ebf696aa57a0b017cd70a063b00c3c7b7143990", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -177,6 +177,7 @@ match origin {\n If you want to match against a slice or array, you can use `&`:\n \n ```{rust}\n+# #![feature(slice_patterns)]\n fn main() {\n     let v = vec![\"match_this\", \"1\"];\n "}, {"sha": "9eb22a7f6985a51bb6e026aaf73896f1a630135a", "filename": "src/doc/trpl/plugins.md", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -1,29 +1,5 @@\n % Compiler Plugins\n \n-<div class=\"unstable-feature\">\n-\n-<p>\n-<b>Warning:</b> Plugins are an advanced, unstable feature! For many details,\n-the only available documentation is the <a\n-href=\"../syntax/index.html\"><code>libsyntax</code></a> and <a\n-href=\"../rustc/index.html\"><code>librustc</code></a> API docs, or even the source\n-code itself. These internal compiler APIs are also subject to change at any\n-time.\n-</p>\n-\n-<p>\n-For defining new syntax it is often much easier to use Rust's <a\n-href=\"macros.html\">built-in macro system</a>.\n-</p>\n-\n-<p style=\"margin-bottom: 0\">\n-The code in this document uses language features not covered in the Rust\n-Guide.  See the <a href=\"../reference.html\">Reference Manual</a> for more\n-information.\n-</p>\n-\n-</div>\n-\n # Introduction\n \n `rustc` can load compiler plugins, which are user-provided libraries that"}, {"sha": "107d7d979a09cc8c2db3457aabb28e458f04fc5c", "filename": "src/doc/trpl/pointers.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -568,8 +568,8 @@ fn add(x: &i32, y: &i32) -> i32 {\n fn main() {\n     let x = Box::new(5);\n \n-    println!(\"{}\", add(&x, &x));\n-    println!(\"{}\", add(&x, &x));\n+    println!(\"{}\", add(&*x, &*x));\n+    println!(\"{}\", add(&*x, &*x));\n }\n ```\n "}, {"sha": "38af0c94954ca9ba4ee7302ff73235058aaaf31d", "filename": "src/doc/trpl/standard-input.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstandard-input.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -5,7 +5,8 @@ we haven't seen before. Here's a simple program that reads some input,\n and then prints it back out:\n \n ```{rust,ignore}\n-corefn main() {\n+# #![feature(old_io)]\n+fn main() {\n     println!(\"Type something!\");\n \n     let input = std::old_io::stdin().read_line().ok().expect(\"Failed to read line\");"}, {"sha": "6226ea9f3e75a21e067909c49155bad69e03bb4b", "filename": "src/doc/trpl/tracing-macros.md", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Ftracing-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Ftracing-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftracing-macros.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -0,0 +1,91 @@\n+% Tracing Macros\n+\n+The `trace_macros` feature allows you to use a special feature: tracing macro\n+invocations.\n+\n+In the advanced macros chapter, we defined a `bct` macro:\n+\n+```rust\n+macro_rules! bct {\n+    // cmd 0:  d ... => ...\n+    (0, $($ps:tt),* ; $_d:tt)\n+        => (bct!($($ps),*, 0 ; ));\n+    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n+        => (bct!($($ps),*, 0 ; $($ds),*));\n+\n+    // cmd 1p:  1 ... => 1 ... p\n+    (1, $p:tt, $($ps:tt),* ; 1)\n+        => (bct!($($ps),*, 1, $p ; 1, $p));\n+    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n+\n+    // cmd 1p:  0 ... => 0 ...\n+    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; $($ds),*));\n+\n+    // halt on empty data string\n+    ( $($ps:tt),* ; )\n+        => (());\n+}\n+```\n+\n+This is pretty complex! we can see the output\n+\n+```rust,ignore\n+#![feature(trace_macros)]\n+\n+macro_rules! bct {\n+    // cmd 0:  d ... => ...\n+    (0, $($ps:tt),* ; $_d:tt)\n+        => (bct!($($ps),*, 0 ; ));\n+    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n+        => (bct!($($ps),*, 0 ; $($ds),*));\n+\n+    // cmd 1p:  1 ... => 1 ... p\n+    (1, $p:tt, $($ps:tt),* ; 1)\n+        => (bct!($($ps),*, 1, $p ; 1, $p));\n+    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n+\n+    // cmd 1p:  0 ... => 0 ...\n+    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; $($ds),*));\n+\n+    // halt on empty data string\n+    ( $($ps:tt),* ; )\n+        => (());\n+}\n+\n+fn main() {\n+    trace_macros!(true);\n+\n+    bct!(0, 0, 1, 1, 1 ; 1, 0, 1);\n+}\n+```\n+\n+This will print out a wall of text:\n+\n+```text\n+bct! { 0 , 0 , 1 , 1 , 1 ; 1 , 0 , 1 }\n+bct! { 0 , 1 , 1 , 1 , 0 ; 0 , 1 }\n+bct! { 1 , 1 , 1 , 0 , 0 ; 1 }\n+bct! { 1 , 0 , 0 , 1 , 1 ; 1 , 1 }\n+bct! { 0 , 1 , 1 , 1 , 0 ; 1 , 1 , 0 }\n+bct! { 1 , 1 , 1 , 0 , 0 ; 1 , 0 }\n+bct! { 1 , 0 , 0 , 1 , 1 ; 1 , 0 , 1 }\n+bct! { 0 , 1 , 1 , 1 , 0 ; 1 , 0 , 1 , 0 }\n+bct! { 1 , 1 , 1 , 0 , 0 ; 0 , 1 , 0 }\n+bct! { 1 , 0 , 0 , 1 , 1 ; 0 , 1 , 0 }\n+bct! { 0 , 1 , 1 , 1 , 0 ; 0 , 1 , 0 }\n+```\n+\n+And eventually, error:\n+\n+```text\n+18:45 error: recursion limit reached while expanding the macro `bct`\n+    => (bct!($($ps),*, 1, $p ; $($ds),*));\n+        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+```\n+\n+The `trace_macros!` call is what produces this output, showing how we match\n+each time."}, {"sha": "3ca3cfd05886ee8add73eaa419c16f7c3c4c34b5", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 0, "deletions": 536, "changes": 536, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -181,539 +181,3 @@ code:\n   that clean-up is always run, even when the thread panics.\n - ensure that any data stored behind a raw pointer is destroyed at the\n   appropriate time.\n-\n-As an example, we give a reimplementation of owned boxes by wrapping\n-`malloc` and `free`. Rust's move semantics and lifetimes mean this\n-reimplementation is as safe as the `Box` type.\n-\n-```\n-# #![feature(libc)]\n-#![feature(unsafe_destructor)]\n-\n-extern crate libc;\n-use libc::{c_void, size_t, malloc, free};\n-use std::mem;\n-use std::ptr;\n-\n-// Define a wrapper around the handle returned by the foreign code.\n-// Unique<T> has the same semantics as Box<T>\n-//\n-// NB: For simplicity and correctness, we require that T has kind Send\n-// (owned boxes relax this restriction).\n-pub struct Unique<T: Send> {\n-    // It contains a single raw, mutable pointer to the object in question.\n-    ptr: *mut T\n-}\n-\n-// Implement methods for creating and using the values in the box.\n-\n-impl<T: Send> Unique<T> {\n-    pub fn new(value: T) -> Unique<T> {\n-        unsafe {\n-            let ptr = malloc(mem::size_of::<T>() as size_t) as *mut T;\n-            // we *need* valid pointer.\n-            assert!(!ptr.is_null());\n-            // `*ptr` is uninitialized, and `*ptr = value` would\n-            // attempt to destroy it `overwrite` moves a value into\n-            // this memory without attempting to drop the original\n-            // value.\n-            ptr::write(&mut *ptr, value);\n-            Unique{ptr: ptr}\n-        }\n-    }\n-\n-    // the 'r lifetime results in the same semantics as `&*x` with\n-    // Box<T>\n-    pub fn borrow<'r>(&'r self) -> &'r T {\n-        // By construction, self.ptr is valid\n-        unsafe { &*self.ptr }\n-    }\n-\n-    // the 'r lifetime results in the same semantics as `&mut *x` with\n-    // Box<T>\n-    pub fn borrow_mut<'r>(&'r mut self) -> &'r mut T {\n-        unsafe { &mut *self.ptr }\n-    }\n-}\n-\n-// A key ingredient for safety, we associate a destructor with\n-// Unique<T>, making the struct manage the raw pointer: when the\n-// struct goes out of scope, it will automatically free the raw pointer.\n-//\n-// NB: This is an unsafe destructor; rustc will not normally allow\n-// destructors to be associated with parameterized types (due to\n-// historically failing to check them soundly).  Note that the\n-// `#[unsafe_destructor]` feature gate is currently required to use\n-// unsafe destructors.\n-#[unsafe_destructor]\n-impl<T: Send> Drop for Unique<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            // Copy the object out from the pointer onto the stack,\n-            // where it is covered by normal Rust destructor semantics\n-            // and cleans itself up, if necessary\n-            ptr::read(self.ptr);\n-\n-            // clean-up our allocation\n-            free(self.ptr as *mut c_void)\n-        }\n-    }\n-}\n-\n-// A comparison between the built-in `Box` and this reimplementation\n-fn main() {\n-    {\n-        let mut x = Box::new(5);\n-        *x = 10;\n-    } // `x` is freed here\n-\n-    {\n-        let mut y = Unique::new(5);\n-        *y.borrow_mut() = 10;\n-    } // `y` is freed here\n-}\n-```\n-\n-Notably, the only way to construct a `Unique` is via the `new`\n-function, and this function ensures that the internal pointer is valid\n-and hidden in the private field. The two `borrow` methods are safe\n-because the compiler statically guarantees that objects are never used\n-before creation or after destruction (unless you use some `unsafe`\n-code...).\n-\n-# Inline assembly\n-\n-For extremely low-level manipulations and performance reasons, one\n-might wish to control the CPU directly. Rust supports using inline\n-assembly to do this via the `asm!` macro. The syntax roughly matches\n-that of GCC & Clang:\n-\n-```ignore\n-asm!(assembly template\n-   : output operands\n-   : input operands\n-   : clobbers\n-   : options\n-   );\n-```\n-\n-Any use of `asm` is feature gated (requires `#![feature(asm)]` on the\n-crate to allow) and of course requires an `unsafe` block.\n-\n-> **Note**: the examples here are given in x86/x86-64 assembly, but\n-> all platforms are supported.\n-\n-## Assembly template\n-\n-The `assembly template` is the only required parameter and must be a\n-literal string (i.e. `\"\"`)\n-\n-```\n-#![feature(asm)]\n-\n-#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn foo() {\n-    unsafe {\n-        asm!(\"NOP\");\n-    }\n-}\n-\n-// other platforms\n-#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-fn foo() { /* ... */ }\n-\n-fn main() {\n-    // ...\n-    foo();\n-    // ...\n-}\n-```\n-\n-(The `feature(asm)` and `#[cfg]`s are omitted from now on.)\n-\n-Output operands, input operands, clobbers and options are all optional\n-but you must add the right number of `:` if you skip them:\n-\n-```\n-# #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-asm!(\"xor %eax, %eax\"\n-    :\n-    :\n-    : \"eax\"\n-   );\n-# } }\n-```\n-\n-Whitespace also doesn't matter:\n-\n-```\n-# #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-asm!(\"xor %eax, %eax\" ::: \"eax\");\n-# } }\n-```\n-\n-## Operands\n-\n-Input and output operands follow the same format: `:\n-\"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n-expressions must be mutable lvalues:\n-\n-```\n-# #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn add(a: i32, b: i32) -> i32 {\n-    let mut c = 0;\n-    unsafe {\n-        asm!(\"add $2, $0\"\n-             : \"=r\"(c)\n-             : \"0\"(a), \"r\"(b)\n-             );\n-    }\n-    c\n-}\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn add(a: i32, b: i32) -> i32 { a + b }\n-\n-fn main() {\n-    assert_eq!(add(3, 14159), 14162)\n-}\n-```\n-\n-## Clobbers\n-\n-Some instructions modify registers which might otherwise have held\n-different values so we use the clobbers list to indicate to the\n-compiler not to assume any values loaded into those registers will\n-stay valid.\n-\n-```\n-# #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-// Put the value 0x200 in eax\n-asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n-# } }\n-```\n-\n-Input and output registers need not be listed since that information\n-is already communicated by the given constraints. Otherwise, any other\n-registers used either implicitly or explicitly should be listed.\n-\n-If the assembly changes the condition code register `cc` should be\n-specified as one of the clobbers. Similarly, if the assembly modifies\n-memory, `memory` should also be specified.\n-\n-## Options\n-\n-The last section, `options` is specific to Rust. The format is comma\n-separated literal strings (i.e. `:\"foo\", \"bar\", \"baz\"`). It's used to\n-specify some extra info about the inline assembly:\n-\n-Current valid options are:\n-\n-1. *volatile* - specifying this is analogous to\n-   `__asm__ __volatile__ (...)` in gcc/clang.\n-2. *alignstack* - certain instructions expect the stack to be\n-   aligned a certain way (i.e. SSE) and specifying this indicates to\n-   the compiler to insert its usual stack alignment code\n-3. *intel* - use intel syntax instead of the default AT&T.\n-\n-# Avoiding the standard library\n-\n-By default, `std` is linked to every Rust crate. In some contexts,\n-this is undesirable, and can be avoided with the `#![no_std]`\n-attribute attached to the crate.\n-\n-```ignore\n-// a minimal library\n-#![crate_type=\"lib\"]\n-#![feature(no_std)]\n-#![no_std]\n-# // fn main() {} tricked you, rustdoc!\n-```\n-\n-Obviously there's more to life than just libraries: one can use\n-`#[no_std]` with an executable, controlling the entry point is\n-possible in two ways: the `#[start]` attribute, or overriding the\n-default shim for the C `main` function with your own.\n-\n-The function marked `#[start]` is passed the command line parameters\n-in the same format as C:\n-\n-```\n-# #![feature(libc)]\n-#![feature(lang_items, start, no_std)]\n-#![no_std]\n-\n-// Pull in the system libc library for what crt0.o likely requires\n-extern crate libc;\n-\n-// Entry point for this program\n-#[start]\n-fn start(_argc: isize, _argv: *const *const u8) -> isize {\n-    0\n-}\n-\n-// These functions and traits are used by the compiler, but not\n-// for a bare-bones hello world. These are normally\n-// provided by libstd.\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-# // fn main() {} tricked you, rustdoc!\n-```\n-\n-To override the compiler-inserted `main` shim, one has to disable it\n-with `#![no_main]` and then create the appropriate symbol with the\n-correct ABI and the correct name, which requires overriding the\n-compiler's name mangling too:\n-\n-```ignore\n-# #![feature(libc)]\n-#![feature(no_std)]\n-#![no_std]\n-#![no_main]\n-#![feature(lang_items, start)]\n-\n-extern crate libc;\n-\n-#[no_mangle] // ensure that this symbol is called `main` in the output\n-pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {\n-    0\n-}\n-\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-# // fn main() {} tricked you, rustdoc!\n-```\n-\n-\n-The compiler currently makes a few assumptions about symbols which are available\n-in the executable to call. Normally these functions are provided by the standard\n-library, but without it you must define your own.\n-\n-The first of these three functions, `stack_exhausted`, is invoked whenever stack\n-overflow is detected.  This function has a number of restrictions about how it\n-can be called and what it must do, but if the stack limit register is not being\n-maintained then a thread always has an \"infinite stack\" and this function\n-shouldn't get triggered.\n-\n-The second of these three functions, `eh_personality`, is used by the\n-failure mechanisms of the compiler. This is often mapped to GCC's\n-personality function (see the\n-[libstd implementation](../std/rt/unwind/index.html) for more\n-information), but crates which do not trigger a panic can be assured\n-that this function is never called. The final function, `panic_fmt`, is\n-also used by the failure mechanisms of the compiler.\n-\n-## Using libcore\n-\n-> **Note**: the core library's structure is unstable, and it is recommended to\n-> use the standard library instead wherever possible.\n-\n-With the above techniques, we've got a bare-metal executable running some Rust\n-code. There is a good deal of functionality provided by the standard library,\n-however, that is necessary to be productive in Rust. If the standard library is\n-not sufficient, then [libcore](../core/index.html) is designed to be used\n-instead.\n-\n-The core library has very few dependencies and is much more portable than the\n-standard library itself. Additionally, the core library has most of the\n-necessary functionality for writing idiomatic and effective Rust code.\n-\n-As an example, here is a program that will calculate the dot product of two\n-vectors provided from C, using idiomatic Rust practices.\n-\n-```\n-# #![feature(libc, core)]\n-#![feature(lang_items, start, no_std)]\n-#![no_std]\n-\n-# extern crate libc;\n-extern crate core;\n-\n-use core::prelude::*;\n-\n-use core::mem;\n-\n-#[no_mangle]\n-pub extern fn dot_product(a: *const u32, a_len: u32,\n-                          b: *const u32, b_len: u32) -> u32 {\n-    use core::raw::Slice;\n-\n-    // Convert the provided arrays into Rust slices.\n-    // The core::raw module guarantees that the Slice\n-    // structure has the same memory layout as a &[T]\n-    // slice.\n-    //\n-    // This is an unsafe operation because the compiler\n-    // cannot tell the pointers are valid.\n-    let (a_slice, b_slice): (&[u32], &[u32]) = unsafe {\n-        mem::transmute((\n-            Slice { data: a, len: a_len as usize },\n-            Slice { data: b, len: b_len as usize },\n-        ))\n-    };\n-\n-    // Iterate over the slices, collecting the result\n-    let mut ret = 0;\n-    for (i, j) in a_slice.iter().zip(b_slice.iter()) {\n-        ret += (*i) * (*j);\n-    }\n-    return ret;\n-}\n-\n-#[lang = \"panic_fmt\"]\n-extern fn panic_fmt(args: &core::fmt::Arguments,\n-                    file: &str,\n-                    line: u32) -> ! {\n-    loop {}\n-}\n-\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-# #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }\n-# fn main() {}\n-```\n-\n-Note that there is one extra lang item here which differs from the examples\n-above, `panic_fmt`. This must be defined by consumers of libcore because the\n-core library declares panics, but it does not define it. The `panic_fmt`\n-lang item is this crate's definition of panic, and it must be guaranteed to\n-never return.\n-\n-As can be seen in this example, the core library is intended to provide the\n-power of Rust in all circumstances, regardless of platform requirements. Further\n-libraries, such as liballoc, add functionality to libcore which make other\n-platform-specific assumptions, but continue to be more portable than the\n-standard library itself.\n-\n-# Interacting with the compiler internals\n-\n-> **Note**: this section is specific to the `rustc` compiler; these\n-> parts of the language may never be fully specified and so details may\n-> differ wildly between implementations (and even versions of `rustc`\n-> itself).\n->\n-> Furthermore, this is just an overview; the best form of\n-> documentation for specific instances of these features are their\n-> definitions and uses in `std`.\n-\n-The Rust language currently has two orthogonal mechanisms for allowing\n-libraries to interact directly with the compiler and vice versa:\n-\n-- intrinsics, functions built directly into the compiler providing\n-  very basic low-level functionality,\n-- lang-items, special functions, types and traits in libraries marked\n-  with specific `#[lang]` attributes\n-\n-## Intrinsics\n-\n-> **Note**: intrinsics will forever have an unstable interface, it is\n-> recommended to use the stable interfaces of libcore rather than intrinsics\n-> directly.\n-\n-These are imported as if they were FFI functions, with the special\n-`rust-intrinsic` ABI. For example, if one was in a freestanding\n-context, but wished to be able to `transmute` between types, and\n-perform efficient pointer arithmetic, one would import those functions\n-via a declaration like\n-\n-```\n-# #![feature(intrinsics)]\n-# fn main() {}\n-\n-extern \"rust-intrinsic\" {\n-    fn transmute<T, U>(x: T) -> U;\n-\n-    fn offset<T>(dst: *const T, offset: isize) -> *const T;\n-}\n-```\n-\n-As with any other FFI functions, these are always `unsafe` to call.\n-\n-## Lang items\n-\n-> **Note**: lang items are often provided by crates in the Rust distribution,\n-> and lang items themselves have an unstable interface. It is recommended to use\n-> officially distributed crates instead of defining your own lang items.\n-\n-The `rustc` compiler has certain pluggable operations, that is,\n-functionality that isn't hard-coded into the language, but is\n-implemented in libraries, with a special marker to tell the compiler\n-it exists. The marker is the attribute `#[lang=\"...\"]` and there are\n-various different values of `...`, i.e. various different 'lang\n-items'.\n-\n-For example, `Box` pointers require two lang items, one for allocation\n-and one for deallocation. A freestanding program that uses the `Box`\n-sugar for dynamic allocations via `malloc` and `free`:\n-\n-```\n-# #![feature(libc)]\n-#![feature(lang_items, box_syntax, start, no_std)]\n-#![no_std]\n-\n-extern crate libc;\n-\n-extern {\n-    fn abort() -> !;\n-}\n-\n-#[lang = \"owned_box\"]\n-pub struct Box<T>(*mut T);\n-\n-#[lang=\"exchange_malloc\"]\n-unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n-    let p = libc::malloc(size as libc::size_t) as *mut u8;\n-\n-    // malloc failed\n-    if p as usize == 0 {\n-        abort();\n-    }\n-\n-    p\n-}\n-#[lang=\"exchange_free\"]\n-unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n-    libc::free(ptr as *mut libc::c_void)\n-}\n-\n-#[start]\n-fn main(argc: isize, argv: *const *const u8) -> isize {\n-    let x = box 1;\n-\n-    0\n-}\n-\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-```\n-\n-Note the use of `abort`: the `exchange_malloc` lang item is assumed to\n-return a valid pointer, and so needs to do the check internally.\n-\n-Other features provided by lang items include:\n-\n-- overloadable operators via traits: the traits corresponding to the\n-  `==`, `<`, dereferencing (`*`) and `+` (etc.) operators are all\n-  marked with lang items; those specific four are `eq`, `ord`,\n-  `deref`, and `add` respectively.\n-- stack unwinding and general failure; the `eh_personality`, `fail`\n-  and `fail_bounds_checks` lang items.\n-- the traits in `std::marker` used to indicate types of\n-  various kinds; lang items `send`, `sync` and `copy`.\n-- the marker types and variance indicators found in\n-  `std::marker`; lang items `covariant_type`,\n-  `contravariant_lifetime`, etc.\n-\n-Lang items are loaded lazily by the compiler; e.g. if one never uses\n-`Box` then there is no need to define functions for `exchange_malloc`\n-and `exchange_free`. `rustc` will emit an error when an item is needed\n-but not found in the current crate or any that it depends on."}, {"sha": "e8e02cc9d092c2310f7a291b1b48923e197abf53", "filename": "src/doc/trpl/unstable.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Funstable.md", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdoc%2Ftrpl%2Funstable.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funstable.md?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -0,0 +1 @@\n+% Unstable Rust"}, {"sha": "c5c58bb49ac361f34df30451b9badd02450acab9", "filename": "src/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -12,9 +12,9 @@\n #![cfg_attr(rustdoc, feature(rustdoc))]\n \n #[cfg(rustdoc)]\n-extern crate \"rustdoc\" as this;\n+extern crate rustdoc as this;\n \n #[cfg(rustc)]\n-extern crate \"rustc_driver\" as this;\n+extern crate rustc_driver as this;\n \n fn main() { this::main() }"}, {"sha": "338d7e336316474e1d59f2cafea68bf989e46f38", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -33,7 +33,7 @@\n //!\n //! Sharing some immutable data between tasks:\n //!\n-//! ```\n+//! ```no_run\n //! use std::sync::Arc;\n //! use std::thread;\n //!\n@@ -50,7 +50,7 @@\n //!\n //! Sharing mutable data safely between tasks with a `Mutex`:\n //!\n-//! ```\n+//! ```no_run\n //! use std::sync::{Arc, Mutex};\n //! use std::thread;\n //!\n@@ -94,6 +94,9 @@ use heap::deallocate;\n /// With simple pipes, without `Arc`, a copy would have to be made for each\n /// task.\n ///\n+/// When you clone an `Arc<T>`, it will create another pointer to the data and\n+/// increase the reference counter.\n+///\n /// ```\n /// # #![feature(alloc, core)]\n /// use std::sync::Arc;\n@@ -354,7 +357,8 @@ impl<T> Drop for Arc<T> {\n         // more than once (but it is guaranteed to be zeroed after the first if\n         // it's run more than once)\n         let ptr = *self._ptr;\n-        if ptr.is_null() { return }\n+        // if ptr.is_null() { return }\n+        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n \n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n         // with other threads unless we are going to delete the object. This\n@@ -485,7 +489,7 @@ impl<T> Drop for Weak<T> {\n         let ptr = *self._ptr;\n \n         // see comments above for why this check is here\n-        if ptr.is_null() { return }\n+        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n \n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about"}, {"sha": "f9bd0ab2f1e0fdbe1e3cb88fcb61413d1e21b8b6", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -244,13 +244,13 @@ pub trait BoxAny {\n     /// Returns the boxed value if it is of type `T`, or\n     /// `Err(Self)` if it isn't.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>>;\n+    fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>>;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl BoxAny for Box<Any> {\n     #[inline]\n-    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n+    fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n@@ -270,7 +270,7 @@ impl BoxAny for Box<Any> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl BoxAny for Box<Any+Send> {\n     #[inline]\n-    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n+    fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n         <Box<Any>>::downcast(self)\n     }\n }"}, {"sha": "b92dfa9117e6beb5745f97c106a758ebfedef1fe", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -75,7 +75,7 @@\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n #![feature(unboxed_closures)]\n-#![feature(unsafe_no_drop_flag)]\n+#![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(core)]\n #![feature(unique)]\n #![cfg_attr(test, feature(test, alloc, rustc_private))]"}, {"sha": "7cdd48884262182d4c30ee873acc3c082011e863", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -160,7 +160,7 @@ use core::default::Default;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::marker;\n-use core::mem::{min_align_of, size_of, forget};\n+use core::mem::{self, min_align_of, size_of, forget};\n use core::nonzero::NonZero;\n use core::ops::{Deref, Drop};\n use core::option::Option;\n@@ -407,7 +407,7 @@ impl<T> Drop for Rc<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self._ptr;\n-            if !ptr.is_null() {\n+            if !ptr.is_null() && ptr as usize != mem::POST_DROP_USIZE {\n                 self.dec_strong();\n                 if self.strong() == 0 {\n                     ptr::read(&**self); // destroy the contained object\n@@ -431,7 +431,8 @@ impl<T> Clone for Rc<T> {\n \n     /// Makes a clone of the `Rc<T>`.\n     ///\n-    /// This increases the strong reference count.\n+    /// When you clone an `Rc<T>`, it will create another pointer to the data and\n+    /// increase the strong reference counter.\n     ///\n     /// # Examples\n     ///\n@@ -718,7 +719,7 @@ impl<T> Drop for Weak<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self._ptr;\n-            if !ptr.is_null() {\n+            if !ptr.is_null() && ptr as usize != mem::POST_DROP_USIZE {\n                 self.dec_weak();\n                 // the weak count starts at 1, and will only go to zero if all\n                 // the strong pointers have disappeared."}, {"sha": "fcf8c8156944ca443c727d50c6a1aaa2e94ec64a", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -171,18 +171,6 @@ pub struct BitVec {\n impl Index<usize> for BitVec {\n     type Output = bool;\n \n-\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, i: &usize) -> &bool {\n-        if self.get(*i).expect(\"index out of bounds\") {\n-            &TRUE\n-        } else {\n-            &FALSE\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, i: usize) -> &bool {\n         if self.get(i).expect(\"index out of bounds\") {"}, {"sha": "11407b5e496f68dffd9c57b870e18d3fce3e8b46", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -915,20 +915,6 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n-    where K: Borrow<Q>, Q: Ord\n-{\n-    type Output = V;\n-\n-    #[inline]\n-    fn index(&self, key: &Q) -> &V {\n-        self.get(key).expect(\"no entry found for key\")\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n     where K: Borrow<Q>, Q: Ord"}, {"sha": "956d4d143d284cb5be082aad261b6b73c81d6274", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 4, "deletions": 63, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -280,9 +280,11 @@ impl<T> Drop for RawItems<T> {\n #[unsafe_destructor]\n impl<K, V> Drop for Node<K, V> {\n     fn drop(&mut self) {\n-        if self.keys.is_null() {\n+        if self.keys.is_null() ||\n+            (unsafe { self.keys.get() as *const K as usize == mem::POST_DROP_USIZE })\n+        {\n             // Since we have #[unsafe_no_drop_flag], we have to watch\n-            // out for a null value being stored in self.keys. (Using\n+            // out for the sentinel value being stored in self.keys. (Using\n             // null is technically a violation of the `Unique`\n             // requirements, though.)\n             return;\n@@ -1524,36 +1526,6 @@ macro_rules! node_slice_impl {\n             }\n \n             /// Returns a sub-slice with elements starting with `min_key`.\n-            #[cfg(stage0)]\n-            pub fn slice_from(self, min_key: &K) -> $NodeSlice<'a, K, V> {\n-                //  _______________\n-                // |_1_|_3_|_5_|_7_|\n-                // |   |   |   |   |\n-                // 0 0 1 1 2 2 3 3 4  index\n-                // |   |   |   |   |\n-                // \\___|___|___|___/  slice_from(&0); pos = 0\n-                //     \\___|___|___/  slice_from(&2); pos = 1\n-                //     |___|___|___/  slice_from(&3); pos = 1; result.head_is_edge = false\n-                //         \\___|___/  slice_from(&4); pos = 2\n-                //             \\___/  slice_from(&6); pos = 3\n-                //                \\|/ slice_from(&999); pos = 4\n-                let (pos, pos_is_kv) = self.search_linear(min_key);\n-                $NodeSlice {\n-                    has_edges: self.has_edges,\n-                    edges: if !self.has_edges {\n-                        self.edges\n-                    } else {\n-                        self.edges.$index(&(pos ..))\n-                    },\n-                    keys: &self.keys[pos ..],\n-                    vals: self.vals.$index(&(pos ..)),\n-                    head_is_edge: !pos_is_kv,\n-                    tail_is_edge: self.tail_is_edge,\n-                }\n-            }\n-\n-            /// Returns a sub-slice with elements starting with `min_key`.\n-            #[cfg(not(stage0))]\n             pub fn slice_from(self, min_key: &K) -> $NodeSlice<'a, K, V> {\n                 //  _______________\n                 // |_1_|_3_|_5_|_7_|\n@@ -1582,37 +1554,6 @@ macro_rules! node_slice_impl {\n             }\n \n             /// Returns a sub-slice with elements up to and including `max_key`.\n-            #[cfg(stage0)]\n-            pub fn slice_to(self, max_key: &K) -> $NodeSlice<'a, K, V> {\n-                //  _______________\n-                // |_1_|_3_|_5_|_7_|\n-                // |   |   |   |   |\n-                // 0 0 1 1 2 2 3 3 4  index\n-                // |   |   |   |   |\n-                //\\|/  |   |   |   |  slice_to(&0); pos = 0\n-                // \\___/   |   |   |  slice_to(&2); pos = 1\n-                // \\___|___|   |   |  slice_to(&3); pos = 1; result.tail_is_edge = false\n-                // \\___|___/   |   |  slice_to(&4); pos = 2\n-                // \\___|___|___/   |  slice_to(&6); pos = 3\n-                // \\___|___|___|___/  slice_to(&999); pos = 4\n-                let (pos, pos_is_kv) = self.search_linear(max_key);\n-                let pos = pos + if pos_is_kv { 1 } else { 0 };\n-                $NodeSlice {\n-                    has_edges: self.has_edges,\n-                    edges: if !self.has_edges {\n-                        self.edges\n-                    } else {\n-                        self.edges.$index(&(.. (pos + 1)))\n-                    },\n-                    keys: &self.keys[..pos],\n-                    vals: self.vals.$index(&(.. pos)),\n-                    head_is_edge: self.head_is_edge,\n-                    tail_is_edge: !pos_is_kv,\n-                }\n-            }\n-\n-            /// Returns a sub-slice with elements up to and including `max_key`.\n-            #[cfg(not(stage0))]\n             pub fn slice_to(self, max_key: &K) -> $NodeSlice<'a, K, V> {\n                 //  _______________\n                 // |_1_|_3_|_5_|_7_|"}, {"sha": "f774c1505b82ba8a4f2818517bcb446c95852f45", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -25,7 +25,6 @@\n #![doc(test(no_crate_inject))]\n \n #![allow(trivial_casts)]\n-#![allow(trivial_numeric_casts)]\n #![feature(alloc)]\n #![feature(box_syntax)]\n #![feature(box_patterns)]\n@@ -36,10 +35,11 @@\n #![feature(unicode)]\n #![feature(unsafe_destructor)]\n #![feature(unique)]\n-#![feature(unsafe_no_drop_flag)]\n+#![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(step_by)]\n #![feature(str_char)]\n #![feature(convert)]\n+#![feature(slice_patterns)]\n #![cfg_attr(test, feature(rand, rustc_private, test, hash, collections))]\n #![cfg_attr(test, allow(deprecated))] // rand\n "}, {"sha": "83e632e6c9676fef00036319fc5cd7c652c16e0a", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -611,9 +611,11 @@ impl<T> [T] {\n         core_slice::SliceExt::get_mut(self, index)\n     }\n \n-    /// Work with `self` as a mut slice.\n-    /// Primarily intended for getting a &mut [T] from a [T; N].\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    /// Deprecated: use `&mut s[..]` instead.\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n+    #[allow(deprecated)]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n         core_slice::SliceExt::as_mut_slice(self)\n     }"}, {"sha": "7131c1cd881b4ccf95ed043e792566279d95d388", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -903,13 +903,6 @@ impl<'a> Add<&'a str> for String {\n impl ops::Index<ops::Range<usize>> for String {\n     type Output = str;\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::Range<usize>) -> &str {\n-        &self[..][*index]\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::Range<usize>) -> &str {\n         &self[..][index]\n@@ -919,13 +912,6 @@ impl ops::Index<ops::Range<usize>> for String {\n impl ops::Index<ops::RangeTo<usize>> for String {\n     type Output = str;\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n-        &self[..][*index]\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeTo<usize>) -> &str {\n         &self[..][index]\n@@ -935,13 +921,6 @@ impl ops::Index<ops::RangeTo<usize>> for String {\n impl ops::Index<ops::RangeFrom<usize>> for String {\n     type Output = str;\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n-        &self[..][*index]\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n         &self[..][index]\n@@ -951,13 +930,6 @@ impl ops::Index<ops::RangeFrom<usize>> for String {\n impl ops::Index<ops::RangeFull> for String {\n     type Output = str;\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, _index: &ops::RangeFull) -> &str {\n-        unsafe { mem::transmute(&*self.vec) }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, _index: ops::RangeFull) -> &str {\n         unsafe { mem::transmute(&*self.vec) }"}, {"sha": "d323f02c8910bc070878c54ea57ac34f98cd26e9", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 19, "deletions": 106, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -423,24 +423,13 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Returns a mutable slice of the elements of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// fn foo(slice: &mut [i32]) {}\n-    ///\n-    /// let mut vec = vec![1, 2];\n-    /// foo(vec.as_mut_slice());\n-    /// ```\n+    /// Deprecated: use `&mut s[..]` instead.\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        unsafe {\n-            let ptr = *self.ptr;\n-            assume(!ptr.is_null());\n-            slice::from_raw_parts_mut(ptr, self.len)\n-        }\n+        &mut self[..]\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out of\n@@ -1343,15 +1332,6 @@ impl<T: Hash> Hash for Vec<T> {\n impl<T> Index<usize> for Vec<T> {\n     type Output = T;\n \n-\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &usize) -> &T {\n-        // NB built-in indexing via `&[T]`\n-        &(**self)[*index]\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: usize) -> &T {\n         // NB built-in indexing via `&[T]`\n@@ -1361,15 +1341,6 @@ impl<T> Index<usize> for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IndexMut<usize> for Vec<T> {\n-\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &usize) -> &mut T {\n-        // NB built-in indexing via `&mut [T]`\n-        &mut (**self)[*index]\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {\n         // NB built-in indexing via `&mut [T]`\n@@ -1382,13 +1353,6 @@ impl<T> IndexMut<usize> for Vec<T> {\n impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n-        Index::index(&**self, index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::Range<usize>) -> &[T] {\n         Index::index(&**self, index)\n@@ -1398,13 +1362,6 @@ impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n-        Index::index(&**self, index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n         Index::index(&**self, index)\n@@ -1414,13 +1371,6 @@ impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n-        Index::index(&**self, index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n         Index::index(&**self, index)\n@@ -1430,13 +1380,6 @@ impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, _index: &ops::RangeFull) -> &[T] {\n-        self\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, _index: ops::RangeFull) -> &[T] {\n         self\n@@ -1446,13 +1389,6 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n-        IndexMut::index_mut(&mut **self, index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n@@ -1461,13 +1397,6 @@ impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n-        IndexMut::index_mut(&mut **self, index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n@@ -1476,13 +1405,6 @@ impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n-        IndexMut::index_mut(&mut **self, index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n@@ -1491,16 +1413,9 @@ impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, _index: &ops::RangeFull) -> &mut [T] {\n-        self.as_mut_slice()\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n-        self.as_mut_slice()\n+        self\n     }\n }\n \n@@ -1519,7 +1434,13 @@ impl<T> ops::Deref for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::DerefMut for Vec<T> {\n-    fn deref_mut(&mut self) -> &mut [T] { self.as_mut_slice() }\n+    fn deref_mut(&mut self) -> &mut [T] {\n+        unsafe {\n+            let ptr = *self.ptr;\n+            assume(!ptr.is_null());\n+            slice::from_raw_parts_mut(ptr, self.len)\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1656,21 +1577,13 @@ impl<T: Ord> Ord for Vec<T> {\n     }\n }\n \n+#[unstable(feature = \"collections\",\n+           reason = \"will be replaced by slice syntax\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n #[allow(deprecated)]\n impl<T> AsSlice<T> for Vec<T> {\n-    /// Returns a slice into `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// fn foo(slice: &[i32]) {}\n-    ///\n-    /// let vec = vec![1, 2];\n-    /// foo(vec.as_slice());\n-    /// ```\n+    /// Deprecated: use `&mut s[..]` instead.\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice(&self) -> &[T] {\n         self\n     }\n@@ -1694,7 +1607,7 @@ impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         // This is (and should always remain) a no-op if the fields are\n         // zeroed (when moving out, because of #[unsafe_no_drop_flag]).\n-        if self.cap != 0 {\n+        if self.cap != 0 && self.cap != mem::POST_DROP_USIZE {\n             unsafe {\n                 for x in &*self {\n                     ptr::read(x);\n@@ -1977,7 +1890,7 @@ impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n-        // self.ptr == self.end == null if drop has already been called,\n+        // self.ptr == self.end == mem::POST_DROP_USIZE if drop has already been called,\n         // so we can use #[unsafe_no_drop_flag].\n \n         // destroy the remaining elements"}, {"sha": "944908e7b4e3dc69cf2bf6638333a787047e630a", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -553,7 +553,7 @@ impl<T> VecDeque<T> {\n     ///     *num = *num - 2;\n     /// }\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n-    /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut i32>>()[], b);\n+    /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut i32>>()[..], b);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n@@ -1705,13 +1705,6 @@ impl<A: Hash> Hash for VecDeque<A> {\n impl<A> Index<usize> for VecDeque<A> {\n     type Output = A;\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, i: &usize) -> &A {\n-        self.get(*i).expect(\"Out of bounds access\")\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, i: usize) -> &A {\n         self.get(i).expect(\"Out of bounds access\")\n@@ -1720,13 +1713,6 @@ impl<A> Index<usize> for VecDeque<A> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> IndexMut<usize> for VecDeque<A> {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, i: &usize) -> &mut A {\n-        self.get_mut(*i).expect(\"Out of bounds access\")\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, i: usize) -> &mut A {\n         self.get_mut(i).expect(\"Out of bounds access\")"}, {"sha": "8900c7950458220f70c12816a5ea1d9995d15b60", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -836,17 +836,6 @@ impl<V> Extend<(usize, V)> for VecMap<V> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<V> Index<usize> for VecMap<V> {\n-    type Output = V;\n-\n-    #[inline]\n-    fn index<'a>(&'a self, i: &usize) -> &'a V {\n-        self.get(i).expect(\"key not present\")\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<V> Index<usize> for VecMap<V> {\n     type Output = V;\n \n@@ -856,7 +845,6 @@ impl<V> Index<usize> for VecMap<V> {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<'a,V> Index<&'a usize> for VecMap<V> {\n     type Output = V;\n \n@@ -866,16 +854,6 @@ impl<'a,V> Index<&'a usize> for VecMap<V> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> IndexMut<usize> for VecMap<V> {\n-    #[inline]\n-    fn index_mut(&mut self, i: &usize) -> &mut V {\n-        self.get_mut(&i).expect(\"key not present\")\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> IndexMut<usize> for VecMap<V> {\n     #[inline]\n@@ -884,7 +862,6 @@ impl<V> IndexMut<usize> for VecMap<V> {\n     }\n }\n \n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> IndexMut<&'a usize> for VecMap<V> {\n     #[inline]"}, {"sha": "d3bc07b173ac8e963f5541204ab68e3fded38731", "filename": "src/libcore/any.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -55,7 +55,7 @@\n //! }\n //!\n //! // This function wants to log its parameter out prior to doing work with it.\n-//! fn do_work<T: Debug + 'static>(value: &T) {\n+//! fn do_work<T: Any + Debug>(value: &T) {\n //!     log(value);\n //!     // ...do some other work\n //! }\n@@ -76,7 +76,7 @@ use mem::transmute;\n use option::Option::{self, Some, None};\n use raw::TraitObject;\n use intrinsics;\n-use marker::Sized;\n+use marker::{Reflect, Sized};\n \n ///////////////////////////////////////////////////////////////////////////////\n // Any trait\n@@ -88,14 +88,16 @@ use marker::Sized;\n ///\n /// [mod]: ../index.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Any: 'static {\n+pub trait Any: Reflect + 'static {\n     /// Get the `TypeId` of `self`\n     #[unstable(feature = \"core\",\n                reason = \"this method will likely be replaced by an associated static\")]\n     fn get_type_id(&self) -> TypeId;\n }\n \n-impl<T: 'static> Any for T {\n+impl<T> Any for T\n+    where T: Reflect + 'static\n+{\n     fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }\n }\n \n@@ -107,7 +109,7 @@ impl Any {\n     /// Returns true if the boxed type is the same as `T`\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is<T: 'static>(&self) -> bool {\n+    pub fn is<T: Any>(&self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n         let t = TypeId::of::<T>();\n \n@@ -122,7 +124,7 @@ impl Any {\n     /// `None` if it isn't.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn downcast_ref<T: 'static>(&self) -> Option<&T> {\n+    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n@@ -140,7 +142,7 @@ impl Any {\n     /// `None` if it isn't.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn downcast_mut<T: 'static>(&mut self) -> Option<&mut T> {\n+    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n@@ -159,21 +161,21 @@ impl Any+Send {\n     /// Forwards to the method defined on the type `Any`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is<T: 'static>(&self) -> bool {\n+    pub fn is<T: Any>(&self) -> bool {\n         Any::is::<T>(self)\n     }\n \n     /// Forwards to the method defined on the type `Any`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn downcast_ref<T: 'static>(&self) -> Option<&T> {\n+    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n         Any::downcast_ref::<T>(self)\n     }\n \n     /// Forwards to the method defined on the type `Any`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn downcast_mut<T: 'static>(&mut self) -> Option<&mut T> {\n+    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n         Any::downcast_mut::<T>(self)\n     }\n }\n@@ -202,7 +204,7 @@ impl TypeId {\n     /// instantiated with\n     #[unstable(feature = \"core\",\n                reason = \"may grow a `Reflect` bound soon via marker traits\")]\n-    pub fn of<T: ?Sized + 'static>() -> TypeId {\n+    pub fn of<T: ?Sized + Any>() -> TypeId {\n         TypeId {\n             t: unsafe { intrinsics::type_id::<T>() },\n         }"}, {"sha": "91301ee558ca566315559f663a6948d11519f2ba", "filename": "src/libcore/array.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -18,6 +18,7 @@\n \n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n+use convert::{AsRef, AsMut};\n use fmt;\n use hash::{Hash, self};\n use iter::IntoIterator;\n@@ -53,6 +54,24 @@ macro_rules! array_impls {\n                 }\n             }\n \n+            #[unstable(feature = \"array_as_ref\",\n+                       reason = \"should ideally be implemented for all fixed-sized arrays\")]\n+            impl<T> AsRef<[T]> for [T; $N] {\n+                #[inline]\n+                fn as_ref(&self) -> &[T] {\n+                    &self[..]\n+                }\n+            }\n+\n+            #[unstable(feature = \"array_as_ref\",\n+                       reason = \"should ideally be implemented for all fixed-sized arrays\")]\n+            impl<T> AsMut<[T]> for [T; $N] {\n+                #[inline]\n+                fn as_mut(&mut self) -> &mut [T] {\n+                    &mut self[..]\n+                }\n+            }\n+\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Copy> Clone for [T; $N] {\n                 fn clone(&self) -> [T; $N] {"}, {"sha": "91b4b46ac3979ec954968f7cda23b6475bb36d11", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -252,7 +252,8 @@ impl AtomicBool {\n \n     /// Stores a value into the bool if the current value is the same as the expected value.\n     ///\n-    /// If the return value is equal to `old` then the value was updated.\n+    /// The return value is always the previous value. If it is equal to `old`, then the value was\n+    /// updated.\n     ///\n     /// `swap` also takes an `Ordering` argument which describes the memory ordering of this\n     /// operation.\n@@ -489,7 +490,8 @@ impl AtomicIsize {\n \n     /// Stores a value into the isize if the current value is the same as the expected value.\n     ///\n-    /// If the return value is equal to `old` then the value was updated.\n+    /// The return value is always the previous value. If it is equal to `old`, then the value was\n+    /// updated.\n     ///\n     /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n     /// this operation.\n@@ -676,7 +678,8 @@ impl AtomicUsize {\n \n     /// Stores a value into the usize if the current value is the same as the expected value.\n     ///\n-    /// If the return value is equal to `old` then the value was updated.\n+    /// The return value is always the previous value. If it is equal to `old`, then the value was\n+    /// updated.\n     ///\n     /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n     /// this operation.\n@@ -873,7 +876,8 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer if the current value is the same as the expected value.\n     ///\n-    /// If the return value is equal to `old` then the value was updated.\n+    /// The return value is always the previous value. If it is equal to `old`, then the value was\n+    /// updated.\n     ///\n     /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n     /// this operation.\n@@ -1064,7 +1068,7 @@ pub fn fence(order: Ordering) {\n              reason = \"renamed to AtomicIsize\")]\n #[allow(missing_docs)]\n pub struct AtomicInt {\n-    v: UnsafeCell<int>,\n+    v: UnsafeCell<isize>,\n }\n \n #[allow(deprecated)]\n@@ -1075,7 +1079,7 @@ unsafe impl Sync for AtomicInt {}\n              reason = \"renamed to AtomicUsize\")]\n #[allow(missing_docs)]\n pub struct AtomicUint {\n-    v: UnsafeCell<uint>,\n+    v: UnsafeCell<usize>,\n }\n \n #[allow(deprecated)]\n@@ -1097,105 +1101,105 @@ pub const ATOMIC_UINT_INIT: AtomicUint =\n #[allow(missing_docs, deprecated)]\n impl AtomicInt {\n     #[inline]\n-    pub fn new(v: int) -> AtomicInt {\n+    pub fn new(v: isize) -> AtomicInt {\n         AtomicInt {v: UnsafeCell::new(v)}\n     }\n \n     #[inline]\n-    pub fn load(&self, order: Ordering) -> int {\n+    pub fn load(&self, order: Ordering) -> isize {\n         unsafe { atomic_load(self.v.get(), order) }\n     }\n \n     #[inline]\n-    pub fn store(&self, val: int, order: Ordering) {\n+    pub fn store(&self, val: isize, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     #[inline]\n-    pub fn swap(&self, val: int, order: Ordering) -> int {\n+    pub fn swap(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n+    pub fn compare_and_swap(&self, old: isize, new: isize, order: Ordering) -> isize {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_add(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_sub(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_and(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_or(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_xor(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }\n \n #[allow(missing_docs, deprecated)]\n impl AtomicUint {\n     #[inline]\n-    pub fn new(v: uint) -> AtomicUint {\n+    pub fn new(v: usize) -> AtomicUint {\n         AtomicUint { v: UnsafeCell::new(v) }\n     }\n \n     #[inline]\n-    pub fn load(&self, order: Ordering) -> uint {\n+    pub fn load(&self, order: Ordering) -> usize {\n         unsafe { atomic_load(self.v.get(), order) }\n     }\n \n     #[inline]\n-    pub fn store(&self, val: uint, order: Ordering) {\n+    pub fn store(&self, val: usize, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     #[inline]\n-    pub fn swap(&self, val: uint, order: Ordering) -> uint {\n+    pub fn swap(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n+    pub fn compare_and_swap(&self, old: usize, new: usize, order: Ordering) -> usize {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_add(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_sub(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_and(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_or(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_xor(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }"}, {"sha": "21f9b1f5513aaaf7f7c8d5184616c3f3552371b8", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -69,6 +69,14 @@ impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U> {\n     }\n }\n \n+// FIXME (#23442): replace the above impls for &/&mut with the following more general one:\n+// // As lifts over Deref\n+// impl<D: ?Sized + Deref, U: ?Sized> AsRef<U> for D where D::Target: AsRef<U> {\n+//     fn as_ref(&self) -> &U {\n+//         self.deref().as_ref()\n+//     }\n+// }\n+\n // AsMut implies Into\n impl<'a, T: ?Sized, U: ?Sized> Into<&'a mut U> for &'a mut T where T: AsMut<U> {\n     fn into(self) -> &'a mut U {\n@@ -83,6 +91,14 @@ impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U> {\n     }\n }\n \n+// FIXME (#23442): replace the above impl for &mut with the following more general one:\n+// // AsMut lifts over DerefMut\n+// impl<D: ?Sized + Deref, U: ?Sized> AsMut<U> for D where D::Target: AsMut<U> {\n+//     fn as_mut(&mut self) -> &mut U {\n+//         self.deref_mut().as_mut()\n+//     }\n+// }\n+\n // From implies Into\n impl<T, U> Into<U> for T where U: From<T> {\n     fn into(self) -> U {"}, {"sha": "ee2951602c71e39ad6cce9a36c7cc844ce214143", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -125,7 +125,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n     // otherwise as well.\n     let mut buf = [0; 1536];\n     let mut end = 0;\n-    let radix_gen: T = cast(radix as int).unwrap();\n+    let radix_gen: T = cast(radix as isize).unwrap();\n \n     let (num, exp) = match exp_format {\n         ExpNone => (num, 0),\n@@ -235,7 +235,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n             let extra_digit = ascii2value(buf[end - 1]);\n             end -= 1;\n             if extra_digit >= radix / 2 { // -> need to round\n-                let mut i: int = end as int - 1;\n+                let mut i: isize = end as isize - 1;\n                 loop {\n                     // If reached left end of number, have to\n                     // insert additional digit:"}, {"sha": "49da99b97cb206571b768a1e88e94b6ae86a6d1e", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -13,7 +13,6 @@\n // FIXME: #6220 Implement floating point formatting\n \n #![allow(unsigned_negation)]\n-#![allow(trivial_numeric_casts)]\n \n use fmt;\n use iter::IteratorExt;"}, {"sha": "1b3c83ecf15cf24b27c4122d05d72ddc3704c69b", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -44,10 +44,6 @@\n \n use marker::Sized;\n \n-#[cfg(stage0)] pub use self::copy_memory as copy;\n-#[cfg(stage0)] pub use self::set_memory as write_bytes;\n-#[cfg(stage0)] pub use self::copy_nonoverlapping_memory as copy_nonoverlapping;\n-\n extern \"rust-intrinsic\" {\n \n     // NB: These intrinsics take unsafe pointers because they mutate aliased\n@@ -183,21 +179,42 @@ extern \"rust-intrinsic\" {\n     pub fn pref_align_of<T>() -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n-    #[cfg(not(stage0))]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n+    /// Create a value initialized to so that its drop flag,\n+    /// if any, says that it has been dropped.\n+    ///\n+    /// `init_dropped` is unsafe because it returns a datum with all\n+    /// of its bytes set to the drop flag, which generally does not\n+    /// correspond to a valid value.\n+    ///\n+    /// This intrinsic is likely to be deprecated in the future when\n+    /// Rust moves to non-zeroing dynamic drop (and thus removes the\n+    /// embedded drop flags that are being established by this\n+    /// intrinsic).\n+    #[cfg(not(stage0))]\n+    pub fn init_dropped<T>() -> T;\n+\n     /// Create a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,\n-    /// which is unsafe unless T is Copy.\n+    /// which is unsafe unless T is `Copy`.  Also, even if T is\n+    /// `Copy`, an all-zero value may not correspond to any legitimate\n+    /// state for the type in question.\n     pub fn init<T>() -> T;\n \n     /// Create an uninitialized value.\n+    ///\n+    /// `uninit` is unsafe because there is no guarantee of what its\n+    /// contents are. In particular its drop-flag may be set to any\n+    /// state, which means it may claim either dropped or\n+    /// undropped. In the general case one must use `ptr::write` to\n+    /// initialize memory previous set to the result of `uninit`.\n     pub fn uninit<T>() -> T;\n \n     /// Move a value out of scope without running drop glue.\n@@ -287,14 +304,8 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(not(stage0))]\n     pub fn copy_nonoverlapping<T>(dst: *mut T, src: *const T, count: usize);\n \n-    /// dox\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(stage0)]\n-    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n-\n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may overlap.\n     ///\n@@ -315,34 +326,22 @@ extern \"rust-intrinsic\" {\n     /// # #![feature(core)]\n     /// use std::ptr;\n     ///\n-    /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: uint) -> Vec<T> {\n+    /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n     ///     dst.set_len(elts);\n     ///     ptr::copy(dst.as_mut_ptr(), ptr, elts);\n     ///     dst\n     /// }\n     /// ```\n     ///\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy<T>(dst: *mut T, src: *const T, count: usize);\n \n-    /// dox\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n-\n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `c`.\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n \n-    /// dox\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn set_memory<T>(dst: *mut T, val: u8, count: usize);\n-\n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`"}, {"sha": "cf5cb0c2f5e3927cc4d247b0dda4b1099996e723", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -63,7 +63,6 @@\n #![allow(raw_pointer_derive)]\n #![deny(missing_docs)]\n \n-#![feature(int_uint)]\n #![feature(intrinsics, lang_items)]\n #![feature(on_unimplemented)]\n #![feature(simd, unsafe_destructor)]\n@@ -72,6 +71,7 @@\n #![feature(rustc_attrs)]\n #![feature(optin_builtin_traits)]\n #![feature(concat_idents)]\n+#![feature(reflect)]\n \n #[macro_use]\n mod macros;"}, {"sha": "d5a7c1d6b26472ac3fb49cadc6e0c764252593c8", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -218,7 +218,7 @@ macro_rules! writeln {\n /// Match arms:\n ///\n /// ```\n-/// fn foo(x: Option<int>) {\n+/// fn foo(x: Option<i32>) {\n ///     match x {\n ///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n ///         Some(n) if n <  0 => println!(\"Some(Negative)\"),"}, {"sha": "35fde2cb64a310e029b14f626ac7aeb92f3c668b", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -450,3 +450,46 @@ pub struct CovariantType<T>;\n #[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<Cell<T>>`\")]\n #[lang=\"invariant_type\"]\n pub struct InvariantType<T>;\n+\n+/// A marker trait indicates a type that can be reflected over. This\n+/// trait is implemented for all types. Its purpose is to ensure that\n+/// when you write a generic function that will employ reflection,\n+/// that must be reflected (no pun intended) in the generic bounds of\n+/// that function. Here is an example:\n+///\n+/// ```\n+/// #![feature(core)]\n+/// use std::marker::Reflect;\n+/// use std::any::Any;\n+/// fn foo<T:Reflect+'static>(x: &T) {\n+///     let any: &Any = x;\n+///     if any.is::<u32>() { println!(\"u32\"); }\n+/// }\n+/// ```\n+///\n+/// Without the declaration `T:Reflect`, `foo` would not type check\n+/// (note: as a matter of style, it would be preferable to to write\n+/// `T:Any`, because `T:Any` implies `T:Reflect` and `T:'static`, but\n+/// we use `Reflect` here to show how it works). The `Reflect` bound\n+/// thus serves to alert `foo`'s caller to the fact that `foo` may\n+/// behave differently depending on whether `T=u32` or not. In\n+/// particular, thanks to the `Reflect` bound, callers know that a\n+/// function declared like `fn bar<T>(...)` will always act in\n+/// precisely the same way no matter what type `T` is supplied,\n+/// beacuse there are no bounds declared on `T`. (The ability for a\n+/// caller to reason about what a function may do based solely on what\n+/// generic bounds are declared is often called the [\"parametricity\n+/// property\"][1].)\n+///\n+/// [1]: http://en.wikipedia.org/wiki/Parametricity\n+#[rustc_reflect_like]\n+#[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n+pub trait Reflect : MarkerTrait {\n+}\n+\n+#[cfg(stage0)]\n+impl<T> Reflect for T { }\n+\n+#[cfg(not(stage0))]\n+impl Reflect for .. { }\n+"}, {"sha": "434a5d17a9254cd6cf1627cd7d2129f81808621c", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -158,6 +158,32 @@ pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n \n+/// Create a value initialized to an unspecified series of bytes.\n+///\n+/// The byte sequence usually indicates that the value at the memory\n+/// in question has been dropped. Thus, *if* T carries a drop flag,\n+/// any associated destructor will not be run when the value falls out\n+/// of scope.\n+///\n+/// Some code at one time used the `zeroed` function above to\n+/// accomplish this goal.\n+///\n+/// This function is expected to be deprecated with the transition\n+/// to non-zeroing drop.\n+#[inline]\n+#[unstable(feature = \"filling_drop\")]\n+pub unsafe fn dropped<T>() -> T {\n+    #[cfg(stage0)]\n+    #[inline(always)]\n+    unsafe fn dropped_impl<T>() -> T { zeroed() }\n+\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    unsafe fn dropped_impl<T>() -> T { intrinsics::init_dropped() }\n+\n+    dropped_impl()\n+}\n+\n /// Create an uninitialized value.\n ///\n /// Care must be taken when using this function, if the type `T` has a destructor and the value\n@@ -291,6 +317,49 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }\n \n+macro_rules! repeat_u8_as_u32 {\n+    ($name:expr) => { (($name as u32) << 24 |\n+                       ($name as u32) << 16 |\n+                       ($name as u32) <<  8 |\n+                       ($name as u32)) }\n+}\n+macro_rules! repeat_u8_as_u64 {\n+    ($name:expr) => { ((repeat_u8_as_u32!($name) as u64) << 32 |\n+                       (repeat_u8_as_u32!($name) as u64)) }\n+}\n+\n+// NOTE: Keep synchronized with values used in librustc_trans::trans::adt.\n+//\n+// In particular, the POST_DROP_U8 marker must never equal the\n+// DTOR_NEEDED_U8 marker.\n+//\n+// For a while pnkfelix was using 0xc1 here.\n+// But having the sign bit set is a pain, so 0x1d is probably better.\n+//\n+// And of course, 0x00 brings back the old world of zero'ing on drop.\n+#[cfg(not(stage0))] #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_U8: u8 = 0x1d;\n+#[cfg(not(stage0))] #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_U32: u32 = repeat_u8_as_u32!(POST_DROP_U8);\n+#[cfg(not(stage0))]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_U64: u64 = repeat_u8_as_u64!(POST_DROP_U8);\n+\n+#[cfg(target_pointer_width = \"32\")]\n+#[cfg(not(stage0))]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_USIZE: usize = POST_DROP_U32 as usize;\n+#[cfg(target_pointer_width = \"64\")]\n+#[cfg(not(stage0))]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_USIZE: usize = POST_DROP_U64 as usize;\n+\n+#[cfg(stage0)]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_U8: u8 = 0;\n+#[cfg(stage0)]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_U32: u32 = 0;\n+#[cfg(stage0)]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_U64: u64 = 0;\n+#[cfg(stage0)]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_USIZE: usize = 0;\n+\n /// Interprets `src` as `&U`, and then reads `src` without moving the contained value.\n ///\n /// This function will unsafely assume the pointer `src` is valid for `sizeof(U)` bytes by"}, {"sha": "5b660970b8680bd6c3eb58f4de535ad233572839", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -193,12 +193,12 @@ impl Float for f32 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS as uint }\n+    fn mantissa_digits(_: Option<f32>) -> usize { MANTISSA_DIGITS as usize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn digits(_: Option<f32>) -> uint { DIGITS as uint }\n+    fn digits(_: Option<f32>) -> usize { DIGITS as usize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n@@ -208,22 +208,22 @@ impl Float for f32 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_exp(_: Option<f32>) -> int { MIN_EXP as int }\n+    fn min_exp(_: Option<f32>) -> isize { MIN_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_exp(_: Option<f32>) -> int { MAX_EXP as int }\n+    fn max_exp(_: Option<f32>) -> isize { MAX_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP as int }\n+    fn min_10_exp(_: Option<f32>) -> isize { MIN_10_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP as int }\n+    fn max_10_exp(_: Option<f32>) -> isize { MAX_10_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]"}, {"sha": "729b9422d5ca103b27c79c226e43f372f52e6169", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -200,12 +200,12 @@ impl Float for f64 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS as uint }\n+    fn mantissa_digits(_: Option<f64>) -> usize { MANTISSA_DIGITS as usize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn digits(_: Option<f64>) -> uint { DIGITS as uint }\n+    fn digits(_: Option<f64>) -> usize { DIGITS as usize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n@@ -215,22 +215,22 @@ impl Float for f64 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_exp(_: Option<f64>) -> int { MIN_EXP as int }\n+    fn min_exp(_: Option<f64>) -> isize { MIN_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_exp(_: Option<f64>) -> int { MAX_EXP as int }\n+    fn max_exp(_: Option<f64>) -> isize { MAX_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP as int }\n+    fn min_10_exp(_: Option<f64>) -> isize { MIN_10_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP as int }\n+    fn max_10_exp(_: Option<f64>) -> isize { MAX_10_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]"}, {"sha": "5ea60d0d96d29f44943a0c751cf760d7c7deef0c", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -12,6 +12,5 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i16\")]\n-#![allow(trivial_numeric_casts)]\n \n int_module! { i16, 16 }"}, {"sha": "7d9faa998c12e87769a8519d416b7085d802dcbf", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -12,6 +12,5 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i32\")]\n-#![allow(trivial_numeric_casts)]\n \n int_module! { i32, 32 }"}, {"sha": "5a70911387b9b7192ab7a86fae52a90e77ddaa7b", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -12,6 +12,5 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i64\")]\n-#![allow(trivial_numeric_casts)]\n \n int_module! { i64, 64 }"}, {"sha": "1d7d78ffa6c2352a20ad49cbfda99a0b3fc7ce17", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -12,6 +12,5 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i8\")]\n-#![allow(trivial_numeric_casts)]\n \n int_module! { i8, 8 }"}, {"sha": "fe0d6d13c4c06483649bdbf737fe89c68048cf43", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![doc(hidden)]\n-#![allow(trivial_numeric_casts)]\n \n macro_rules! int_module { ($T:ty, $bits:expr) => (\n "}, {"sha": "0fd0d90b12501ea87b257bb523b56a1c6d0f1b47", "filename": "src/libcore/num/isize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fisize.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -16,7 +16,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"isize\")]\n-#![allow(trivial_numeric_casts)]\n \n #[cfg(target_pointer_width = \"32\")]\n int_module! { isize, 32 }"}, {"sha": "745a1213ad5b747a276aa65f7467e753c8c7b3bf", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -14,7 +14,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n-#![allow(trivial_numeric_casts)]\n \n use self::wrapping::{OverflowingOps, WrappingOps};\n \n@@ -52,8 +51,8 @@ pub trait Int\n     + BitAnd<Output=Self>\n     + BitOr<Output=Self>\n     + BitXor<Output=Self>\n-    + Shl<uint, Output=Self>\n-    + Shr<uint, Output=Self>\n+    + Shl<usize, Output=Self>\n+    + Shr<usize, Output=Self>\n     + WrappingOps\n     + OverflowingOps\n {\n@@ -565,7 +564,7 @@ uint_impl! { u64 = u64, 64,\n     intrinsics::u64_mul_with_overflow }\n \n #[cfg(target_pointer_width = \"32\")]\n-uint_impl! { uint = u32, 32,\n+uint_impl! { usize = u32, 32,\n     intrinsics::ctpop32,\n     intrinsics::ctlz32,\n     intrinsics::cttz32,\n@@ -575,7 +574,7 @@ uint_impl! { uint = u32, 32,\n     intrinsics::u32_mul_with_overflow }\n \n #[cfg(target_pointer_width = \"64\")]\n-uint_impl! { uint = u64, 64,\n+uint_impl! { usize = u64, 64,\n     intrinsics::ctpop64,\n     intrinsics::ctlz64,\n     intrinsics::cttz64,\n@@ -680,13 +679,13 @@ int_impl! { i64 = i64, u64, 64,\n     intrinsics::i64_mul_with_overflow }\n \n #[cfg(target_pointer_width = \"32\")]\n-int_impl! { int = i32, u32, 32,\n+int_impl! { isize = i32, u32, 32,\n     intrinsics::i32_add_with_overflow,\n     intrinsics::i32_sub_with_overflow,\n     intrinsics::i32_mul_with_overflow }\n \n #[cfg(target_pointer_width = \"64\")]\n-int_impl! { int = i64, u64, 64,\n+int_impl! { isize = i64, u64, 64,\n     intrinsics::i64_add_with_overflow,\n     intrinsics::i64_sub_with_overflow,\n     intrinsics::i64_mul_with_overflow }\n@@ -752,7 +751,7 @@ signed_int_impl! { i8 }\n signed_int_impl! { i16 }\n signed_int_impl! { i32 }\n signed_int_impl! { i64 }\n-signed_int_impl! { int }\n+signed_int_impl! { isize }\n \n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n@@ -1232,7 +1231,7 @@ impl i64 {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { int = i32, u32, 32,\n+    int_impl! { isize = i32, u32, 32,\n         intrinsics::i32_add_with_overflow,\n         intrinsics::i32_sub_with_overflow,\n         intrinsics::i32_mul_with_overflow }\n@@ -1241,7 +1240,7 @@ impl isize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { int = i64, u64, 64,\n+    int_impl! { isize = i64, u64, 64,\n         intrinsics::i64_add_with_overflow,\n         intrinsics::i64_sub_with_overflow,\n         intrinsics::i64_mul_with_overflow }\n@@ -1746,7 +1745,7 @@ impl u64 {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { uint = u32, 32,\n+    uint_impl! { usize = u32, 32,\n         intrinsics::ctpop32,\n         intrinsics::ctlz32,\n         intrinsics::cttz32,\n@@ -1759,7 +1758,7 @@ impl usize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { uint = u64, 64,\n+    uint_impl! { usize = u64, 64,\n         intrinsics::ctpop64,\n         intrinsics::ctlz64,\n         intrinsics::cttz64,\n@@ -1772,11 +1771,11 @@ impl usize {\n /// A generic trait for converting a value to a number.\n #[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait ToPrimitive {\n-    /// Converts the value of `self` to an `int`.\n+    /// Converts the value of `self` to an `isize`.\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use to_isize\")]\n-    fn to_int(&self) -> Option<int> {\n+    fn to_int(&self) -> Option<isize> {\n         self.to_i64().and_then(|x| x.to_isize())\n     }\n \n@@ -1807,11 +1806,11 @@ pub trait ToPrimitive {\n     /// Converts the value of `self` to an `i64`.\n     fn to_i64(&self) -> Option<i64>;\n \n-    /// Converts the value of `self` to an `uint`.\n+    /// Converts the value of `self` to an `usize`.\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use to_usize\")]\n-    fn to_uint(&self) -> Option<uint> {\n+    fn to_uint(&self) -> Option<usize> {\n         self.to_u64().and_then(|x| x.to_usize())\n     }\n \n@@ -1893,7 +1892,7 @@ macro_rules! impl_to_primitive_int {\n     ($T:ty) => (\n         impl ToPrimitive for $T {\n             #[inline]\n-            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int, *self) }\n+            fn to_int(&self) -> Option<isize> { impl_to_primitive_int_to_int!($T, isize, *self) }\n             #[inline]\n             fn to_isize(&self) -> Option<isize> { impl_to_primitive_int_to_int!($T, isize, *self) }\n             #[inline]\n@@ -1906,7 +1905,7 @@ macro_rules! impl_to_primitive_int {\n             fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64, *self) }\n \n             #[inline]\n-            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint, *self) }\n+            fn to_uint(&self) -> Option<usize> { impl_to_primitive_int_to_uint!($T, usize, *self) }\n             #[inline]\n             fn to_usize(&self) -> Option<usize> { impl_to_primitive_int_to_uint!($T, usize, *self) }\n             #[inline]\n@@ -1967,9 +1966,9 @@ macro_rules! impl_to_primitive_uint {\n     ($T:ty) => (\n         impl ToPrimitive for $T {\n             #[inline]\n-            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int, *self) }\n+            fn to_int(&self) -> Option<isize> { impl_to_primitive_uint_to_int!(isize, *self) }\n             #[inline]\n-            fn to_isize(&self) -> Option<int> { impl_to_primitive_uint_to_int!(isize, *self) }\n+            fn to_isize(&self) -> Option<isize> { impl_to_primitive_uint_to_int!(isize, *self) }\n             #[inline]\n             fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8, *self) }\n             #[inline]\n@@ -1980,9 +1979,11 @@ macro_rules! impl_to_primitive_uint {\n             fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64, *self) }\n \n             #[inline]\n-            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint, *self) }\n+            fn to_uint(&self) -> Option<usize> { impl_to_primitive_uint_to_uint!($T, usize, *self) }\n             #[inline]\n-            fn to_usize(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, usize, *self) }\n+            fn to_usize(&self) -> Option<usize> {\n+                impl_to_primitive_uint_to_uint!($T, usize, *self)\n+            }\n             #[inline]\n             fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8, *self) }\n             #[inline]\n@@ -2026,9 +2027,9 @@ macro_rules! impl_to_primitive_float {\n     ($T:ident) => (\n         impl ToPrimitive for $T {\n             #[inline]\n-            fn to_int(&self) -> Option<int> { Some(*self as int) }\n+            fn to_int(&self) -> Option<isize> { Some(*self as isize) }\n             #[inline]\n-            fn to_isize(&self) -> Option<int> { Some(*self as isize) }\n+            fn to_isize(&self) -> Option<isize> { Some(*self as isize) }\n             #[inline]\n             fn to_i8(&self) -> Option<i8> { Some(*self as i8) }\n             #[inline]\n@@ -2039,9 +2040,9 @@ macro_rules! impl_to_primitive_float {\n             fn to_i64(&self) -> Option<i64> { Some(*self as i64) }\n \n             #[inline]\n-            fn to_uint(&self) -> Option<uint> { Some(*self as uint) }\n+            fn to_uint(&self) -> Option<usize> { Some(*self as usize) }\n             #[inline]\n-            fn to_usize(&self) -> Option<uint> { Some(*self as usize) }\n+            fn to_usize(&self) -> Option<usize> { Some(*self as usize) }\n             #[inline]\n             fn to_u8(&self) -> Option<u8> { Some(*self as u8) }\n             #[inline]\n@@ -2065,12 +2066,12 @@ impl_to_primitive_float! { f64 }\n /// A generic trait for converting a number to a value.\n #[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait FromPrimitive : ::marker::Sized {\n-    /// Convert an `int` to return an optional value of this type. If the\n+    /// Convert an `isize` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use from_isize\")]\n-    fn from_int(n: int) -> Option<Self> {\n+    fn from_int(n: isize) -> Option<Self> {\n         FromPrimitive::from_i64(n as i64)\n     }\n \n@@ -2106,12 +2107,12 @@ pub trait FromPrimitive : ::marker::Sized {\n     /// type cannot be represented by this value, the `None` is returned.\n     fn from_i64(n: i64) -> Option<Self>;\n \n-    /// Convert an `uint` to return an optional value of this type. If the\n+    /// Convert an `usize` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use from_usize\")]\n-    fn from_uint(n: uint) -> Option<Self> {\n+    fn from_uint(n: usize) -> Option<Self> {\n         FromPrimitive::from_u64(n as u64)\n     }\n \n@@ -2165,7 +2166,7 @@ pub trait FromPrimitive : ::marker::Sized {\n /// A utility function that just calls `FromPrimitive::from_int`.\n #[unstable(feature = \"core\", reason = \"likely to be removed\")]\n #[deprecated(since = \"1.0.0\", reason = \"use from_isize\")]\n-pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n+pub fn from_int<A: FromPrimitive>(n: isize) -> Option<A> {\n     FromPrimitive::from_isize(n)\n }\n \n@@ -2202,7 +2203,7 @@ pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n /// A utility function that just calls `FromPrimitive::from_uint`.\n #[unstable(feature = \"core\", reason = \"likely to be removed\")]\n #[deprecated(since = \"1.0.0\", reason = \"use from_uint\")]\n-pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n+pub fn from_uint<A: FromPrimitive>(n: usize) -> Option<A> {\n     FromPrimitive::from_usize(n)\n }\n \n@@ -2252,13 +2253,13 @@ macro_rules! impl_from_primitive {\n     ($T:ty, $to_ty:ident) => (\n         #[allow(deprecated)]\n         impl FromPrimitive for $T {\n-            #[inline] fn from_int(n: int) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_int(n: isize) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_i8(n: i8) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_i16(n: i16) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_i32(n: i32) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_i64(n: i64) -> Option<$T> { n.$to_ty() }\n \n-            #[inline] fn from_uint(n: uint) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_uint(n: usize) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_u8(n: u8) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_u16(n: u16) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_u32(n: u32) -> Option<$T> { n.$to_ty() }\n@@ -2270,12 +2271,12 @@ macro_rules! impl_from_primitive {\n     )\n }\n \n-impl_from_primitive! { int, to_int }\n+impl_from_primitive! { isize, to_int }\n impl_from_primitive! { i8, to_i8 }\n impl_from_primitive! { i16, to_i16 }\n impl_from_primitive! { i32, to_i32 }\n impl_from_primitive! { i64, to_i64 }\n-impl_from_primitive! { uint, to_uint }\n+impl_from_primitive! { usize, to_uint }\n impl_from_primitive! { u8, to_u8 }\n impl_from_primitive! { u16, to_u16 }\n impl_from_primitive! { u32, to_u32 }\n@@ -2327,12 +2328,12 @@ impl_num_cast! { u8,    to_u8 }\n impl_num_cast! { u16,   to_u16 }\n impl_num_cast! { u32,   to_u32 }\n impl_num_cast! { u64,   to_u64 }\n-impl_num_cast! { uint,  to_uint }\n+impl_num_cast! { usize,  to_uint }\n impl_num_cast! { i8,    to_i8 }\n impl_num_cast! { i16,   to_i16 }\n impl_num_cast! { i32,   to_i32 }\n impl_num_cast! { i64,   to_i64 }\n-impl_num_cast! { int,   to_int }\n+impl_num_cast! { isize,   to_int }\n impl_num_cast! { f32,   to_f32 }\n impl_num_cast! { f64,   to_f64 }\n \n@@ -2392,12 +2393,12 @@ pub trait Float\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n                            `std::f64::MANTISSA_DIGITS` as appropriate\")]\n-    fn mantissa_digits(unused_self: Option<Self>) -> uint;\n+    fn mantissa_digits(unused_self: Option<Self>) -> usize;\n     /// Returns the number of base-10 digits of precision that this type supports.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n-    fn digits(unused_self: Option<Self>) -> uint;\n+    fn digits(unused_self: Option<Self>) -> usize;\n     /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n@@ -2407,22 +2408,22 @@ pub trait Float\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n-    fn min_exp(unused_self: Option<Self>) -> int;\n+    fn min_exp(unused_self: Option<Self>) -> isize;\n     /// Returns the maximum binary exponent that this type can represent.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n-    fn max_exp(unused_self: Option<Self>) -> int;\n+    fn max_exp(unused_self: Option<Self>) -> isize;\n     /// Returns the minimum base-10 exponent that this type can represent.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n-    fn min_10_exp(unused_self: Option<Self>) -> int;\n+    fn min_10_exp(unused_self: Option<Self>) -> isize;\n     /// Returns the maximum base-10 exponent that this type can represent.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n-    fn max_10_exp(unused_self: Option<Self>) -> int;\n+    fn max_10_exp(unused_self: Option<Self>) -> isize;\n     /// Returns the smallest finite value that this type can represent.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n@@ -2625,7 +2626,7 @@ macro_rules! from_str_radix_float_impl {\n                 let mut prev_sig = sig;\n                 let mut cs = src.chars().enumerate();\n                 // Exponent prefix and exponent index offset\n-                let mut exp_info = None::<(char, uint)>;\n+                let mut exp_info = None::<(char, usize)>;\n \n                 // Parse the integer part of the significand\n                 for (i, c) in cs.by_ref() {\n@@ -2636,9 +2637,9 @@ macro_rules! from_str_radix_float_impl {\n \n                             // add/subtract current digit depending on sign\n                             if is_positive {\n-                                sig = sig + ((digit as int) as $T);\n+                                sig = sig + ((digit as isize) as $T);\n                             } else {\n-                                sig = sig - ((digit as int) as $T);\n+                                sig = sig - ((digit as isize) as $T);\n                             }\n \n                             // Detect overflow by comparing to last value, except\n@@ -2719,9 +2720,9 @@ macro_rules! from_str_radix_float_impl {\n                         // Parse the exponent as decimal integer\n                         let src = &src[offset..];\n                         let (is_positive, exp) = match src.slice_shift_char() {\n-                            Some(('-', src)) => (false, src.parse::<uint>()),\n-                            Some(('+', src)) => (true,  src.parse::<uint>()),\n-                            Some((_, _))     => (true,  src.parse::<uint>()),\n+                            Some(('-', src)) => (false, src.parse::<usize>()),\n+                            Some(('+', src)) => (true,  src.parse::<usize>()),\n+                            Some((_, _))     => (true,  src.parse::<usize>()),\n                             None             => return Err(PFE { kind: Invalid }),\n                         };\n "}, {"sha": "21635799a77a26a458619bcd3b3431ce2ae0c7ba", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -12,6 +12,5 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u16\")]\n-#![allow(trivial_numeric_casts)]\n \n uint_module! { u16, i16, 16 }"}, {"sha": "7d520770503d4b2507cb483afc8bcf04204ca443", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -12,6 +12,5 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u32\")]\n-#![allow(trivial_numeric_casts)]\n \n uint_module! { u32, i32, 32 }"}, {"sha": "f10822077dc7511e3e44d12596e6e2198e0e941d", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -12,6 +12,5 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u64\")]\n-#![allow(trivial_numeric_casts)]\n \n uint_module! { u64, i64, 64 }"}, {"sha": "3d6922b07b19407b325941dd14888e4fea334214", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -12,6 +12,5 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u8\")]\n-#![allow(trivial_numeric_casts)]\n \n uint_module! { u8, i8, 8 }"}, {"sha": "d0c4885ad00b77ebbfaef418cb230976e6955f21", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![doc(hidden)]\n-#![allow(trivial_numeric_casts)]\n \n macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n "}, {"sha": "602ef4fe45e734e0f1a931a2a50c98ce98e0511a", "filename": "src/libcore/num/usize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fusize.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -16,6 +16,5 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"usize\")]\n-#![allow(trivial_numeric_casts)]\n \n uint_module! { usize, isize, ::isize::BITS }"}, {"sha": "9ecc063403c931f3ad88bdc02a6e24dbaadad5dd", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -64,10 +64,10 @@ macro_rules! wrapping_impl {\n     )*)\n }\n \n-wrapping_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+wrapping_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n #[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n-#[derive(PartialEq,Eq,PartialOrd,Ord,Clone,Copy)]\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Debug, Clone, Copy)]\n pub struct Wrapping<T>(pub T);\n \n impl<T:WrappingOps> Add for Wrapping<T> {\n@@ -132,20 +132,20 @@ impl<T:WrappingOps+BitAnd<Output=T>> BitAnd for Wrapping<T> {\n     }\n }\n \n-impl<T:WrappingOps+Shl<uint,Output=T>> Shl<uint> for Wrapping<T> {\n+impl<T:WrappingOps+Shl<usize,Output=T>> Shl<usize> for Wrapping<T> {\n     type Output = Wrapping<T>;\n \n     #[inline(always)]\n-    fn shl(self, other: uint) -> Wrapping<T> {\n+    fn shl(self, other: usize) -> Wrapping<T> {\n         Wrapping(self.0 << other)\n     }\n }\n \n-impl<T:WrappingOps+Shr<uint,Output=T>> Shr<uint> for Wrapping<T> {\n+impl<T:WrappingOps+Shr<usize,Output=T>> Shr<usize> for Wrapping<T> {\n     type Output = Wrapping<T>;\n \n     #[inline(always)]\n-    fn shr(self, other: uint) -> Wrapping<T> {\n+    fn shr(self, other: usize) -> Wrapping<T> {\n         Wrapping(self.0 >> other)\n     }\n }"}, {"sha": "26deb80d8c51fb02e4f240193a145e5366301c1e", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -917,12 +917,6 @@ pub trait Index<Idx: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn index<'a>(&'a self, index: &Idx) -> &'a Self::Output;\n-\n-    /// The method for the indexing (`Foo[Bar]`) operation\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index<'a>(&'a self, index: Idx) -> &'a Self::Output;\n }\n@@ -966,12 +960,6 @@ pub trait Index<Idx: ?Sized> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n     /// The method for the indexing (`Foo[Bar]`) operation\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn index_mut<'a>(&'a mut self, index: &Idx) -> &'a mut Self::Output;\n-\n-    /// The method for the indexing (`Foo[Bar]`) operation\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index_mut<'a>(&'a mut self, index: Idx) -> &'a mut Self::Output;\n }\n@@ -1149,20 +1137,6 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n #[lang=\"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n-#[cfg(stage0)]\n-pub trait Fn<Args> {\n-    /// The returned type after the call operator is used.\n-    type Output;\n-\n-    /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n-}\n-\n-/// A version of the call operator that takes an immutable receiver.\n-#[lang=\"fn\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_paren_sugar]\n-#[cfg(not(stage0))]\n pub trait Fn<Args> : FnMut<Args> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n@@ -1172,20 +1146,6 @@ pub trait Fn<Args> : FnMut<Args> {\n #[lang=\"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n-#[cfg(stage0)]\n-pub trait FnMut<Args> {\n-    /// The returned type after the call operator is used.\n-    type Output;\n-\n-    /// This is called when the call operator is used.\n-    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-}\n-\n-/// A version of the call operator that takes a mutable receiver.\n-#[lang=\"fn_mut\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_paren_sugar]\n-#[cfg(not(stage0))]\n pub trait FnMut<Args> : FnOnce<Args> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n@@ -1202,25 +1162,3 @@ pub trait FnOnce<Args> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n-\n-#[cfg(stage0)]\n-impl<F: ?Sized, A> FnMut<A> for F\n-    where F : Fn<A>\n-{\n-    type Output = <F as Fn<A>>::Output;\n-\n-    extern \"rust-call\" fn call_mut(&mut self, args: A) -> <F as Fn<A>>::Output {\n-        self.call(args)\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl<F,A> FnOnce<A> for F\n-    where F : FnMut<A>\n-{\n-    type Output = <F as FnMut<A>>::Output;\n-\n-    extern \"rust-call\" fn call_once(mut self, args: A) -> <F as FnMut<A>>::Output {\n-        self.call_mut(args)\n-    }\n-}"}, {"sha": "f5cd4f81b7bfa58c386b28e42736f26227dcd717", "filename": "src/libcore/option.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -151,7 +151,7 @@ use default::Default;\n use iter::{ExactSizeIterator};\n use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator, IntoIterator};\n use mem;\n-use ops::{Deref, FnOnce};\n+use ops::FnOnce;\n use result::Result::{Ok, Err};\n use result::Result;\n #[allow(deprecated)]\n@@ -320,7 +320,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.expect(\"the world is ending\"), \"value\");\n     /// ```\n     ///\n-    /// ```{.should_fail}\n+    /// ```{.should_panic}\n     /// let x: Option<&str> = None;\n     /// x.expect(\"the world is ending\"); // panics with `world is ending`\n     /// ```\n@@ -333,7 +333,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns the inner `T` of a `Some(T)`.\n+    /// Moves the value `v` out of the `Option<T>` if the content of the `Option<T>` is a `Some(v)`.\n     ///\n     /// # Panics\n     ///\n@@ -352,7 +352,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.unwrap(), \"air\");\n     /// ```\n     ///\n-    /// ```{.should_fail}\n+    /// ```{.should_panic}\n     /// let x: Option<&str> = None;\n     /// assert_eq!(x.unwrap(), \"air\"); // fails\n     /// ```\n@@ -480,7 +480,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.ok_or(0), Err(0));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ok_or<E>(self, err: E) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n@@ -502,7 +502,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.ok_or_else(|| 0), Err(0));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n@@ -548,8 +548,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"core\",\n-               reason = \"waiting for iterator conventions\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         IterMut { inner: Item { opt: self.as_mut() } }\n     }\n@@ -721,13 +720,11 @@ impl<T> Option<T> {\n     }\n }\n \n-impl<'a, T: Clone, D: Deref<Target=T>> Option<D> {\n-    /// Maps an Option<D> to an Option<T> by dereffing and cloning the contents of the Option.\n-    /// Useful for converting an Option<&T> to an Option<T>.\n-    #[unstable(feature = \"core\",\n-               reason = \"recently added as part of collections reform\")]\n+impl<'a, T: Clone> Option<&'a T> {\n+    /// Maps an Option<&T> to an Option<T> by cloning the contents of the Option.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn cloned(self) -> Option<T> {\n-        self.map(|t| t.deref().clone())\n+        self.map(|t| t.clone())\n     }\n }\n "}, {"sha": "d6e00df1fd7955ea88f773bef85ad4f7b80afb1b", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -16,7 +16,7 @@\n //! interface for panicking is:\n //!\n //! ```ignore\n-//! fn panic_impl(fmt: fmt::Arguments, &(&'static str, uint)) -> !;\n+//! fn panic_impl(fmt: fmt::Arguments, &(&'static str, usize)) -> !;\n //! ```\n //!\n //! This definition allows for panicking with any general message, but it does not\n@@ -58,8 +58,8 @@ pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> ! {\n     #[allow(improper_ctypes)]\n     extern {\n         #[lang = \"panic_fmt\"]\n-        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: uint) -> !;\n+        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: usize) -> !;\n     }\n     let (file, line) = *file_line;\n-    unsafe { panic_impl(fmt, file, line as uint) }\n+    unsafe { panic_impl(fmt, file, line as usize) }\n }"}, {"sha": "07d018dea929651d983768c8b1f3e940ca99515f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -230,6 +230,21 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     tmp\n }\n \n+/// Variant of read_and_zero that writes the specific drop-flag byte\n+/// (which may be more appropriate than zero).\n+#[inline(always)]\n+#[unstable(feature = \"core\",\n+           reason = \"may play a larger role in std::ptr future extensions\")]\n+pub unsafe fn read_and_drop<T>(dest: *mut T) -> T {\n+    // Copy the data out from `dest`:\n+    let tmp = read(&*dest);\n+\n+    // Now mark `dest` as dropped:\n+    write_bytes(dest, mem::POST_DROP_U8, 1);\n+\n+    tmp\n+}\n+\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///"}, {"sha": "c7e166b49be17e68bc4888a16d017c693e5a31aa", "filename": "src/libcore/result.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -60,22 +60,22 @@\n //! that make working with it more succinct.\n //!\n //! ```\n-//! let good_result: Result<int, int> = Ok(10);\n-//! let bad_result: Result<int, int> = Err(10);\n+//! let good_result: Result<i32, i32> = Ok(10);\n+//! let bad_result: Result<i32, i32> = Err(10);\n //!\n //! // The `is_ok` and `is_err` methods do what they say.\n //! assert!(good_result.is_ok() && !good_result.is_err());\n //! assert!(bad_result.is_err() && !bad_result.is_ok());\n //!\n //! // `map` consumes the `Result` and produces another.\n-//! let good_result: Result<int, int> = good_result.map(|i| i + 1);\n-//! let bad_result: Result<int, int> = bad_result.map(|i| i - 1);\n+//! let good_result: Result<i32, i32> = good_result.map(|i| i + 1);\n+//! let bad_result: Result<i32, i32> = bad_result.map(|i| i - 1);\n //!\n //! // Use `and_then` to continue the computation.\n-//! let good_result: Result<bool, int> = good_result.and_then(|i| Ok(i == 11));\n+//! let good_result: Result<bool, i32> = good_result.and_then(|i| Ok(i == 11));\n //!\n //! // Use `or_else` to handle the error.\n-//! let bad_result: Result<int, int> = bad_result.or_else(|i| Ok(11));\n+//! let bad_result: Result<i32, i32> = bad_result.or_else(|i| Ok(11));\n //!\n //! // Consume the result and return the contents with `unwrap`.\n //! let final_awesome_result = good_result.unwrap();\n@@ -92,7 +92,7 @@\n //! useful value.\n //!\n //! Consider the `write_line` method defined for I/O types\n-//! by the [`Writer`](../io/trait.Writer.html) trait:\n+//! by the [`Writer`](../old_io/trait.Writer.html) trait:\n //!\n //! ```\n //! # #![feature(old_io)]\n@@ -182,8 +182,8 @@\n //!\n //! struct Info {\n //!     name: String,\n-//!     age: int,\n-//!     rating: int\n+//!     age: i32,\n+//!     rating: i32,\n //! }\n //!\n //! fn write_info(info: &Info) -> Result<(), IoError> {\n@@ -208,8 +208,8 @@\n //!\n //! struct Info {\n //!     name: String,\n-//!     age: int,\n-//!     rating: int\n+//!     age: i32,\n+//!     rating: i32,\n //! }\n //!\n //! fn write_info(info: &Info) -> Result<(), IoError> {\n@@ -282,10 +282,10 @@ impl<T, E> Result<T, E> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let x: Result<int, &str> = Ok(-3);\n+    /// let x: Result<i32, &str> = Ok(-3);\n     /// assert_eq!(x.is_ok(), true);\n     ///\n-    /// let x: Result<int, &str> = Err(\"Some error message\");\n+    /// let x: Result<i32, &str> = Err(\"Some error message\");\n     /// assert_eq!(x.is_ok(), false);\n     /// ```\n     #[inline]\n@@ -302,10 +302,10 @@ impl<T, E> Result<T, E> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let x: Result<int, &str> = Ok(-3);\n+    /// let x: Result<i32, &str> = Ok(-3);\n     /// assert_eq!(x.is_err(), false);\n     ///\n-    /// let x: Result<int, &str> = Err(\"Some error message\");\n+    /// let x: Result<i32, &str> = Err(\"Some error message\");\n     /// assert_eq!(x.is_err(), true);\n     /// ```\n     #[inline]\n@@ -392,18 +392,18 @@ impl<T, E> Result<T, E> {\n     /// Convert from `Result<T, E>` to `Result<&mut T, &mut E>`\n     ///\n     /// ```\n-    /// fn mutate(r: &mut Result<int, int>) {\n+    /// fn mutate(r: &mut Result<i32, i32>) {\n     ///     match r.as_mut() {\n     ///         Ok(&mut ref mut v) => *v = 42,\n     ///         Err(&mut ref mut e) => *e = 0,\n     ///     }\n     /// }\n     ///\n-    /// let mut x: Result<int, int> = Ok(2);\n+    /// let mut x: Result<i32, i32> = Ok(2);\n     /// mutate(&mut x);\n     /// assert_eq!(x.unwrap(), 42);\n     ///\n-    /// let mut x: Result<int, int> = Err(13);\n+    /// let mut x: Result<i32, i32> = Err(13);\n     /// mutate(&mut x);\n     /// assert_eq!(x.unwrap_err(), 0);\n     /// ```\n@@ -486,8 +486,8 @@ impl<T, E> Result<T, E> {\n     /// while !buffer.is_empty() {\n     ///     let line: IoResult<String> = buffer.read_line();\n     ///     // Convert the string line to a number using `map` and `from_str`\n-    ///     let val: IoResult<int> = line.map(|line| {\n-    ///         line.trim_right().parse::<int>().unwrap_or(0)\n+    ///     let val: IoResult<i32> = line.map(|line| {\n+    ///         line.trim_right().parse::<i32>().unwrap_or(0)\n     ///     });\n     ///     // Add the value if there were no errors, otherwise add 0\n     ///     sum += val.unwrap_or(0);\n@@ -762,7 +762,7 @@ impl<T, E: fmt::Debug> Result<T, E> {\n     /// assert_eq!(x.unwrap(), 2);\n     /// ```\n     ///\n-    /// ```{.should_fail}\n+    /// ```{.should_panic}\n     /// let x: Result<u32, &str> = Err(\"emergency failure\");\n     /// x.unwrap(); // panics with `emergency failure`\n     /// ```\n@@ -788,7 +788,7 @@ impl<T: fmt::Debug, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// ```{.should_fail}\n+    /// ```{.should_panic}\n     /// let x: Result<u32, &str> = Ok(2);\n     /// x.unwrap_err(); // panics with `2`\n     /// ```"}, {"sha": "12cfdbf530646dc5ce8a5475dc0fafdbae5e0d3f", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 6, "deletions": 185, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -88,6 +88,9 @@ pub trait SliceExt {\n     fn len(&self) -> usize;\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     fn get_mut<'a>(&'a mut self, index: usize) -> Option<&'a mut Self::Item>;\n+    #[unstable(feature = \"core\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n     fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n     fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n@@ -261,20 +264,11 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n+    #[unstable(feature = \"core\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n-        unsafe {\n-            let self2: &mut [T] = mem::transmute_copy(&self);\n-\n-            (ops::IndexMut::index_mut(self, &ops::RangeTo { end: mid } ),\n-             ops::IndexMut::index_mut(self2, &ops::RangeFrom { start: mid } ))\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -507,14 +501,6 @@ impl<T> SliceExt for [T] {\n impl<T> ops::Index<usize> for [T] {\n     type Output = T;\n \n-    #[cfg(stage0)]\n-    fn index(&self, &index: &usize) -> &T {\n-        assert!(index < self.len());\n-\n-        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn index(&self, index: usize) -> &T {\n         assert!(index < self.len());\n \n@@ -524,15 +510,6 @@ impl<T> ops::Index<usize> for [T] {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<usize> for [T] {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, &index: &usize) -> &mut T {\n-        assert!(index < self.len());\n-\n-        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {\n         assert!(index < self.len());\n@@ -545,20 +522,6 @@ impl<T> ops::IndexMut<usize> for [T] {\n impl<T> ops::Index<ops::Range<usize>> for [T] {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n-        assert!(index.start <= index.end);\n-        assert!(index.end <= self.len());\n-        unsafe {\n-            from_raw_parts (\n-                self.as_ptr().offset(index.start as isize),\n-                index.end - index.start\n-            )\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::Range<usize>) -> &[T] {\n         assert!(index.start <= index.end);\n@@ -575,13 +538,6 @@ impl<T> ops::Index<ops::Range<usize>> for [T] {\n impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n-        self.index(&ops::Range{ start: 0, end: index.end })\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n         self.index(ops::Range{ start: 0, end: index.end })\n@@ -591,13 +547,6 @@ impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n-        self.index(&ops::Range{ start: index.start, end: self.len() })\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n         self.index(ops::Range{ start: index.start, end: self.len() })\n@@ -607,13 +556,6 @@ impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n impl<T> ops::Index<RangeFull> for [T] {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, _index: &RangeFull) -> &[T] {\n-        self\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, _index: RangeFull) -> &[T] {\n         self\n@@ -622,20 +564,6 @@ impl<T> ops::Index<RangeFull> for [T] {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n-        assert!(index.start <= index.end);\n-        assert!(index.end <= self.len());\n-        unsafe {\n-            from_raw_parts_mut(\n-                self.as_mut_ptr().offset(index.start as isize),\n-                index.end - index.start\n-            )\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n         assert!(index.start <= index.end);\n@@ -650,28 +578,13 @@ impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n-        self.index_mut(&ops::Range{ start: 0, end: index.end })\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(ops::Range{ start: 0, end: index.end })\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n-        let len = self.len();\n-        self.index_mut(&ops::Range{ start: index.start, end: len })\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         let len = self.len();\n@@ -680,14 +593,6 @@ impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<RangeFull> for [T] {\n-\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, _index: &RangeFull) -> &mut [T] {\n-        self\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n         self\n@@ -875,13 +780,6 @@ unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}\n impl<'a, T> ops::Index<ops::Range<usize>> for Iter<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n-        self.as_slice().index(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::Range<usize>) -> &[T] {\n         self.as_slice().index(index)\n@@ -892,13 +790,6 @@ impl<'a, T> ops::Index<ops::Range<usize>> for Iter<'a, T> {\n impl<'a, T> ops::Index<ops::RangeTo<usize>> for Iter<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n-        self.as_slice().index(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n         self.as_slice().index(index)\n@@ -909,13 +800,6 @@ impl<'a, T> ops::Index<ops::RangeTo<usize>> for Iter<'a, T> {\n impl<'a, T> ops::Index<ops::RangeFrom<usize>> for Iter<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n-        self.as_slice().index(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n         self.as_slice().index(index)\n@@ -926,13 +810,6 @@ impl<'a, T> ops::Index<ops::RangeFrom<usize>> for Iter<'a, T> {\n impl<'a, T> ops::Index<RangeFull> for Iter<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, _index: &RangeFull) -> &[T] {\n-        self.as_slice()\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, _index: RangeFull) -> &[T] {\n         self.as_slice()\n@@ -1000,13 +877,6 @@ unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}\n impl<'a, T> ops::Index<ops::Range<usize>> for IterMut<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n-        self.index(&RangeFull).index(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::Range<usize>) -> &[T] {\n         self.index(RangeFull).index(index)\n@@ -1016,13 +886,6 @@ impl<'a, T> ops::Index<ops::Range<usize>> for IterMut<'a, T> {\n impl<'a, T> ops::Index<ops::RangeTo<usize>> for IterMut<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n-        self.index(&RangeFull).index(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n         self.index(RangeFull).index(index)\n@@ -1032,13 +895,6 @@ impl<'a, T> ops::Index<ops::RangeTo<usize>> for IterMut<'a, T> {\n impl<'a, T> ops::Index<ops::RangeFrom<usize>> for IterMut<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n-        self.index(&RangeFull).index(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n         self.index(RangeFull).index(index)\n@@ -1048,13 +904,6 @@ impl<'a, T> ops::Index<ops::RangeFrom<usize>> for IterMut<'a, T> {\n impl<'a, T> ops::Index<RangeFull> for IterMut<'a, T> {\n     type Output = [T];\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index(&self, _index: &RangeFull) -> &[T] {\n-        make_slice!(T => &[T]: self.ptr, self.end)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index(&self, _index: RangeFull) -> &[T] {\n         make_slice!(T => &[T]: self.ptr, self.end)\n@@ -1063,13 +912,6 @@ impl<'a, T> ops::Index<RangeFull> for IterMut<'a, T> {\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::Range<usize>> for IterMut<'a, T> {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n-        self.index_mut(&RangeFull).index_mut(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n         self.index_mut(RangeFull).index_mut(index)\n@@ -1078,13 +920,6 @@ impl<'a, T> ops::IndexMut<ops::Range<usize>> for IterMut<'a, T> {\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeTo<usize>> for IterMut<'a, T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n-        self.index_mut(&RangeFull).index_mut(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(RangeFull).index_mut(index)\n@@ -1093,13 +928,6 @@ impl<'a, T> ops::IndexMut<ops::RangeTo<usize>> for IterMut<'a, T> {\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeFrom<usize>> for IterMut<'a, T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n-        self.index_mut(&RangeFull).index_mut(index)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         self.index_mut(RangeFull).index_mut(index)\n@@ -1108,13 +936,6 @@ impl<'a, T> ops::IndexMut<ops::RangeFrom<usize>> for IterMut<'a, T> {\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<RangeFull> for IterMut<'a, T> {\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn index_mut(&mut self, _index: &RangeFull) -> &mut [T] {\n-        make_mut_slice!(T => &mut [T]: self.ptr, self.end)\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n         make_mut_slice!(T => &mut [T]: self.ptr, self.end)"}, {"sha": "13075fd5ee991fae5eec064ebe9037e24db5c313", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 89, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -541,33 +541,20 @@ delegate_iter!{exact u8 : Bytes<'a>}\n #[derive(Copy, Clone)]\n struct BytesDeref;\n \n-#[cfg(stage0)]\n-impl<'a> Fn<(&'a u8,)> for BytesDeref {\n-    type Output = u8;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n-        *ptr\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<'a> Fn<(&'a u8,)> for BytesDeref {\n     #[inline]\n     extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n         *ptr\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<'a> FnMut<(&'a u8,)> for BytesDeref {\n     #[inline]\n     extern \"rust-call\" fn call_mut(&mut self, (ptr,): (&'a u8,)) -> u8 {\n         Fn::call(&*self, (ptr,))\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<'a> FnOnce<(&'a u8,)> for BytesDeref {\n     type Output = u8;\n \n@@ -1319,50 +1306,6 @@ mod traits {\n     /// // byte 100 is outside the string\n     /// // &s[3 .. 100];\n     /// ```\n-    #[cfg(stage0)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::Range<usize>> for str {\n-        type Output = str;\n-        #[inline]\n-        fn index(&self, index: &ops::Range<usize>) -> &str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if index.start <= index.end &&\n-               self.is_char_boundary(index.start) &&\n-               self.is_char_boundary(index.end) {\n-                unsafe { self.slice_unchecked(index.start, index.end) }\n-            } else {\n-                super::slice_error_fail(self, index.start, index.end)\n-            }\n-        }\n-    }\n-\n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Panics when `begin` and `end` do not point to valid characters\n-    /// or point beyond the last character of the string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(&s[0 .. 1], \"L\");\n-    ///\n-    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n-    ///\n-    /// // these will panic:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // &s[2 ..3];\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // &s[1 .. 8];\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // &s[3 .. 100];\n-    /// ```\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::Range<usize>> for str {\n         type Output = str;\n@@ -1390,18 +1333,6 @@ mod traits {\n     impl ops::Index<ops::RangeTo<usize>> for str {\n         type Output = str;\n \n-        #[cfg(stage0)]\n-        #[inline]\n-        fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if self.is_char_boundary(index.end) {\n-                unsafe { self.slice_unchecked(0, index.end) }\n-            } else {\n-                super::slice_error_fail(self, 0, index.end)\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]\n         #[inline]\n         fn index(&self, index: ops::RangeTo<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n@@ -1423,18 +1354,6 @@ mod traits {\n     impl ops::Index<ops::RangeFrom<usize>> for str {\n         type Output = str;\n \n-        #[cfg(stage0)]\n-        #[inline]\n-        fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            if self.is_char_boundary(index.start) {\n-                unsafe { self.slice_unchecked(index.start, self.len()) }\n-            } else {\n-                super::slice_error_fail(self, index.start, self.len())\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]\n         #[inline]\n         fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n@@ -1450,13 +1369,6 @@ mod traits {\n     impl ops::Index<ops::RangeFull> for str {\n         type Output = str;\n \n-        #[cfg(stage0)]\n-        #[inline]\n-        fn index(&self, _index: &ops::RangeFull) -> &str {\n-            self\n-        }\n-\n-        #[cfg(not(stage0))]\n         #[inline]\n         fn index(&self, _index: ops::RangeFull) -> &str {\n             self\n@@ -1704,7 +1616,7 @@ impl StrExt for str {\n     #[inline]\n     unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n         mem::transmute(Slice {\n-            data: self.as_ptr().offset(begin as int),\n+            data: self.as_ptr().offset(begin as isize),\n             len: end - begin,\n         })\n     }"}, {"sha": "eeaaa3e217e8f1c80bbb0aca874f3f688c3c42ce", "filename": "src/libcoretest/any.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -37,9 +37,9 @@ fn any_referenced() {\n fn any_owning() {\n     let (a, b, c) = (box 5_usize as Box<Any>, box TEST as Box<Any>, box Test as Box<Any>);\n \n-    assert!(a.is::<uint>());\n-    assert!(!b.is::<uint>());\n-    assert!(!c.is::<uint>());\n+    assert!(a.is::<usize>());\n+    assert!(!b.is::<usize>());\n+    assert!(!c.is::<usize>());\n \n     assert!(!a.is::<&'static str>());\n     assert!(b.is::<&'static str>());\n@@ -54,7 +54,7 @@ fn any_owning() {\n fn any_downcast_ref() {\n     let a = &5_usize as &Any;\n \n-    match a.downcast_ref::<uint>() {\n+    match a.downcast_ref::<usize>() {\n         Some(&5) => {}\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n@@ -71,18 +71,18 @@ fn any_downcast_mut() {\n     let mut b: Box<_> = box 7_usize;\n \n     let a_r = &mut a as &mut Any;\n-    let tmp: &mut uint = &mut *b;\n+    let tmp: &mut usize = &mut *b;\n     let b_r = tmp as &mut Any;\n \n-    match a_r.downcast_mut::<uint>() {\n+    match a_r.downcast_mut::<usize>() {\n         Some(x) => {\n             assert_eq!(*x, 5);\n             *x = 612;\n         }\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n-    match b_r.downcast_mut::<uint>() {\n+    match b_r.downcast_mut::<usize>() {\n         Some(x) => {\n             assert_eq!(*x, 7);\n             *x = 413;\n@@ -100,12 +100,12 @@ fn any_downcast_mut() {\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n-    match a_r.downcast_mut::<uint>() {\n+    match a_r.downcast_mut::<usize>() {\n         Some(&mut 612) => {}\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n-    match b_r.downcast_mut::<uint>() {\n+    match b_r.downcast_mut::<usize>() {\n         Some(&mut 413) => {}\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n@@ -115,8 +115,8 @@ fn any_downcast_mut() {\n fn any_fixed_vec() {\n     let test = [0_usize; 8];\n     let test = &test as &Any;\n-    assert!(test.is::<[uint; 8]>());\n-    assert!(!test.is::<[uint; 10]>());\n+    assert!(test.is::<[usize; 8]>());\n+    assert!(!test.is::<[usize; 10]>());\n }\n \n \n@@ -126,6 +126,6 @@ fn bench_downcast_ref(b: &mut Bencher) {\n         let mut x = 0;\n         let mut y = &mut x as &mut Any;\n         test::black_box(&mut y);\n-        test::black_box(y.downcast_ref::<int>() == Some(&0));\n+        test::black_box(y.downcast_ref::<isize>() == Some(&0));\n     });\n }"}, {"sha": "fff3cc14eadfd45fb4127f3ea800c7a4ad39fae6", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -134,19 +134,19 @@ fn clone_ref_updates_flag() {\n \n #[test]\n fn as_unsafe_cell() {\n-    let c1: Cell<uint> = Cell::new(0);\n+    let c1: Cell<usize> = Cell::new(0);\n     c1.set(1);\n     assert_eq!(1, unsafe { *c1.as_unsafe_cell().get() });\n \n-    let c2: Cell<uint> = Cell::new(0);\n+    let c2: Cell<usize> = Cell::new(0);\n     unsafe { *c2.as_unsafe_cell().get() = 1; }\n     assert_eq!(1, c2.get());\n \n-    let r1: RefCell<uint> = RefCell::new(0);\n+    let r1: RefCell<usize> = RefCell::new(0);\n     *r1.borrow_mut() = 1;\n     assert_eq!(1, unsafe { *r1.as_unsafe_cell().get() });\n \n-    let r2: RefCell<uint> = RefCell::new(0);\n+    let r2: RefCell<usize> = RefCell::new(0);\n     unsafe { *r2.as_unsafe_cell().get() = 1; }\n     assert_eq!(1, *r2.borrow());\n }"}, {"sha": "9ed1508c3eb7877c23b0831682569562ddea5a5f", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -114,7 +114,7 @@ fn test_user_defined_eq() {\n \n     // Our type.\n     struct SketchyNum {\n-        num : int\n+        num : isize\n     }\n \n     // Our implementation of `PartialEq` to support `==` and `!=`."}, {"sha": "15938a5dcb4770bdac1d5b59c2856db5dc580ff5", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -19,7 +19,7 @@ use test::Bencher;\n \n #[test]\n fn test_lt() {\n-    let empty: [int; 0] = [];\n+    let empty: [isize; 0] = [];\n     let xs = [1,2,3];\n     let ys = [1,2,0];\n \n@@ -73,7 +73,7 @@ fn test_multi_iter() {\n #[test]\n fn test_counter_from_iter() {\n     let it = count(0, 5).take(10);\n-    let xs: Vec<int> = FromIterator::from_iter(it);\n+    let xs: Vec<isize> = FromIterator::from_iter(it);\n     assert_eq!(xs, [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n }\n \n@@ -104,7 +104,7 @@ fn test_iterator_chain() {\n fn test_filter_map() {\n     let it = count(0, 1).take(10)\n         .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n-    assert_eq!(it.collect::<Vec<uint>>(), [0*0, 2*2, 4*4, 6*6, 8*8]);\n+    assert_eq!(it.collect::<Vec<usize>>(), [0*0, 2*2, 4*4, 6*6, 8*8]);\n }\n \n #[test]\n@@ -224,8 +224,8 @@ fn test_iterator_take_short() {\n #[test]\n fn test_iterator_scan() {\n     // test the type inference\n-    fn add(old: &mut int, new: &uint) -> Option<f64> {\n-        *old += *new as int;\n+    fn add(old: &mut isize, new: &usize) -> Option<f64> {\n+        *old += *new as isize;\n         Some(*old as f64)\n     }\n     let xs = [0, 1, 2, 3, 4];\n@@ -261,15 +261,15 @@ fn test_inspect() {\n     let ys = xs.iter()\n                .cloned()\n                .inspect(|_| n += 1)\n-               .collect::<Vec<uint>>();\n+               .collect::<Vec<usize>>();\n \n     assert_eq!(n, xs.len());\n     assert_eq!(&xs[..], &ys[..]);\n }\n \n #[test]\n fn test_unfoldr() {\n-    fn count(st: &mut uint) -> Option<uint> {\n+    fn count(st: &mut usize) -> Option<usize> {\n         if *st < 10 {\n             let ret = Some(*st);\n             *st += 1;\n@@ -398,14 +398,14 @@ fn test_iterator_size_hint() {\n #[test]\n fn test_collect() {\n     let a = vec![1, 2, 3, 4, 5];\n-    let b: Vec<int> = a.iter().cloned().collect();\n+    let b: Vec<isize> = a.iter().cloned().collect();\n     assert!(a == b);\n }\n \n #[test]\n fn test_all() {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-    let v: Box<[int]> = Box::new([1, 2, 3, 4, 5]);\n+    let v: Box<[isize]> = Box::new([1, 2, 3, 4, 5]);\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n@@ -415,7 +415,7 @@ fn test_all() {\n #[test]\n fn test_any() {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-    let v: Box<[int]> = Box::new([1, 2, 3, 4, 5]);\n+    let v: Box<[isize]> = Box::new([1, 2, 3, 4, 5]);\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));\n@@ -424,7 +424,7 @@ fn test_any() {\n \n #[test]\n fn test_find() {\n-    let v: &[int] = &[1, 3, 9, 27, 103, 14, 11];\n+    let v: &[isize] = &[1, 3, 9, 27, 103, 14, 11];\n     assert_eq!(*v.iter().find(|&&x| x & 1 == 0).unwrap(), 14);\n     assert_eq!(*v.iter().find(|&&x| x % 3 == 0).unwrap(), 3);\n     assert!(v.iter().find(|&&x| x % 12 == 0).is_none());\n@@ -448,13 +448,13 @@ fn test_count() {\n \n #[test]\n fn test_max_by() {\n-    let xs: &[int] = &[-3, 0, 1, 5, -10];\n+    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n     assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n }\n \n #[test]\n fn test_min_by() {\n-    let xs: &[int] = &[-3, 0, 1, 5, -10];\n+    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n     assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n }\n \n@@ -473,7 +473,7 @@ fn test_rev() {\n     let mut it = xs.iter();\n     it.next();\n     it.next();\n-    assert!(it.rev().cloned().collect::<Vec<int>>() ==\n+    assert!(it.rev().cloned().collect::<Vec<isize>>() ==\n             vec![16, 14, 12, 10, 8, 6]);\n }\n \n@@ -572,8 +572,8 @@ fn test_double_ended_chain() {\n \n #[test]\n fn test_rposition() {\n-    fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-    fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n+    fn f(xy: &(isize, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n+    fn g(xy: &(isize, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n     let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n     assert_eq!(v.iter().rposition(f), Some(3));\n@@ -598,7 +598,7 @@ fn test_rposition_panic() {\n \n \n #[cfg(test)]\n-fn check_randacc_iter<A, T>(a: T, len: uint) where\n+fn check_randacc_iter<A, T>(a: T, len: usize) where\n     A: PartialEq,\n     T: Clone + RandomAccessIterator + Iterator<Item=A>,\n {\n@@ -684,7 +684,7 @@ fn test_random_access_zip() {\n #[test]\n fn test_random_access_take() {\n     let xs = [1, 2, 3, 4, 5];\n-    let empty: &[int] = &[];\n+    let empty: &[isize] = &[];\n     check_randacc_iter(xs.iter().take(3), 3);\n     check_randacc_iter(xs.iter().take(20), xs.len());\n     check_randacc_iter(xs.iter().take(0), 0);\n@@ -694,7 +694,7 @@ fn test_random_access_take() {\n #[test]\n fn test_random_access_skip() {\n     let xs = [1, 2, 3, 4, 5];\n-    let empty: &[int] = &[];\n+    let empty: &[isize] = &[];\n     check_randacc_iter(xs.iter().skip(2), xs.len() - 2);\n     check_randacc_iter(empty.iter().skip(2), 0);\n }\n@@ -726,7 +726,7 @@ fn test_random_access_map() {\n #[test]\n fn test_random_access_cycle() {\n     let xs = [1, 2, 3, 4, 5];\n-    let empty: &[int] = &[];\n+    let empty: &[isize] = &[];\n     check_randacc_iter(xs.iter().cycle().take(27), 27);\n     check_randacc_iter(empty.iter().cycle(), 0);\n }\n@@ -755,42 +755,42 @@ fn test_range() {\n     assert_eq!((200..200).rev().count(), 0);\n \n     assert_eq!((0..100).size_hint(), (100, Some(100)));\n-    // this test is only meaningful when sizeof uint < sizeof u64\n+    // this test is only meaningful when sizeof usize < sizeof u64\n     assert_eq!((usize::MAX - 1..usize::MAX).size_hint(), (1, Some(1)));\n     assert_eq!((-10..-1).size_hint(), (9, Some(9)));\n     assert_eq!((-1..-10).size_hint(), (0, Some(0)));\n }\n \n #[test]\n fn test_range_inclusive() {\n-    assert!(range_inclusive(0, 5).collect::<Vec<int>>() ==\n+    assert!(range_inclusive(0, 5).collect::<Vec<isize>>() ==\n             vec![0, 1, 2, 3, 4, 5]);\n-    assert!(range_inclusive(0, 5).rev().collect::<Vec<int>>() ==\n+    assert!(range_inclusive(0, 5).rev().collect::<Vec<isize>>() ==\n             vec![5, 4, 3, 2, 1, 0]);\n     assert_eq!(range_inclusive(200, -5).count(), 0);\n     assert_eq!(range_inclusive(200, -5).rev().count(), 0);\n-    assert_eq!(range_inclusive(200, 200).collect::<Vec<int>>(), [200]);\n-    assert_eq!(range_inclusive(200, 200).rev().collect::<Vec<int>>(), [200]);\n+    assert_eq!(range_inclusive(200, 200).collect::<Vec<isize>>(), [200]);\n+    assert_eq!(range_inclusive(200, 200).rev().collect::<Vec<isize>>(), [200]);\n }\n \n #[test]\n fn test_range_step() {\n-    assert_eq!((0..20).step_by(5).collect::<Vec<int>>(), [0, 5, 10, 15]);\n-    assert_eq!((20..0).step_by(-5).collect::<Vec<int>>(), [20, 15, 10, 5]);\n-    assert_eq!((20..0).step_by(-6).collect::<Vec<int>>(), [20, 14, 8, 2]);\n+    assert_eq!((0..20).step_by(5).collect::<Vec<isize>>(), [0, 5, 10, 15]);\n+    assert_eq!((20..0).step_by(-5).collect::<Vec<isize>>(), [20, 15, 10, 5]);\n+    assert_eq!((20..0).step_by(-6).collect::<Vec<isize>>(), [20, 14, 8, 2]);\n     assert_eq!((200..255).step_by(50).collect::<Vec<u8>>(), [200, 250]);\n-    assert_eq!((200..-5).step_by(1).collect::<Vec<int>>(), []);\n-    assert_eq!((200..200).step_by(1).collect::<Vec<int>>(), []);\n+    assert_eq!((200..-5).step_by(1).collect::<Vec<isize>>(), []);\n+    assert_eq!((200..200).step_by(1).collect::<Vec<isize>>(), []);\n }\n \n #[test]\n fn test_range_step_inclusive() {\n-    assert_eq!(range_step_inclusive(0, 20, 5).collect::<Vec<int>>(), [0, 5, 10, 15, 20]);\n-    assert_eq!(range_step_inclusive(20, 0, -5).collect::<Vec<int>>(), [20, 15, 10, 5, 0]);\n-    assert_eq!(range_step_inclusive(20, 0, -6).collect::<Vec<int>>(), [20, 14, 8, 2]);\n+    assert_eq!(range_step_inclusive(0, 20, 5).collect::<Vec<isize>>(), [0, 5, 10, 15, 20]);\n+    assert_eq!(range_step_inclusive(20, 0, -5).collect::<Vec<isize>>(), [20, 15, 10, 5, 0]);\n+    assert_eq!(range_step_inclusive(20, 0, -6).collect::<Vec<isize>>(), [20, 14, 8, 2]);\n     assert_eq!(range_step_inclusive(200, 255, 50).collect::<Vec<u8>>(), [200, 250]);\n-    assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>(), []);\n-    assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>(), [200]);\n+    assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<isize>>(), []);\n+    assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<isize>>(), [200]);\n }\n \n #[test]\n@@ -811,7 +811,7 @@ fn test_peekable_is_empty() {\n \n #[test]\n fn test_min_max() {\n-    let v: [int; 0] = [];\n+    let v: [isize; 0] = [];\n     assert_eq!(v.iter().min_max(), NoElements);\n \n     let v = [1];\n@@ -829,7 +829,7 @@ fn test_min_max() {\n \n #[test]\n fn test_min_max_result() {\n-    let r: MinMaxResult<int> = NoElements;\n+    let r: MinMaxResult<isize> = NoElements;\n     assert_eq!(r.into_option(), None);\n \n     let r = OneElement(1);\n@@ -876,7 +876,7 @@ fn test_fuse() {\n \n #[bench]\n fn bench_rposition(b: &mut Bencher) {\n-    let it: Vec<uint> = (0..300).collect();\n+    let it: Vec<usize> = (0..300).collect();\n     b.iter(|| {\n         it.iter().rposition(|&x| x <= 150);\n     });"}, {"sha": "9cc3063dee678eece513b665e98ebc0b9a7af015", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -26,6 +26,7 @@\n #![feature(debug_builders)]\n #![feature(unique)]\n #![feature(step_by)]\n+#![feature(slice_patterns)]\n #![allow(deprecated)] // rand\n \n extern crate core;"}, {"sha": "fae36787c3dadf66df71995ae64b02ea9ad584c7", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -21,15 +21,15 @@ fn size_of_basic() {\n #[test]\n #[cfg(target_pointer_width = \"32\")]\n fn size_of_32() {\n-    assert_eq!(size_of::<uint>(), 4);\n-    assert_eq!(size_of::<*const uint>(), 4);\n+    assert_eq!(size_of::<usize>(), 4);\n+    assert_eq!(size_of::<*const usize>(), 4);\n }\n \n #[test]\n #[cfg(target_pointer_width = \"64\")]\n fn size_of_64() {\n-    assert_eq!(size_of::<uint>(), 8);\n-    assert_eq!(size_of::<*const uint>(), 8);\n+    assert_eq!(size_of::<usize>(), 8);\n+    assert_eq!(size_of::<*const usize>(), 8);\n }\n \n #[test]\n@@ -50,15 +50,15 @@ fn align_of_basic() {\n #[test]\n #[cfg(target_pointer_width = \"32\")]\n fn align_of_32() {\n-    assert_eq!(align_of::<uint>(), 4);\n-    assert_eq!(align_of::<*const uint>(), 4);\n+    assert_eq!(align_of::<usize>(), 4);\n+    assert_eq!(align_of::<*const usize>(), 4);\n }\n \n #[test]\n #[cfg(target_pointer_width = \"64\")]\n fn align_of_64() {\n-    assert_eq!(align_of::<uint>(), 8);\n-    assert_eq!(align_of::<*const uint>(), 8);\n+    assert_eq!(align_of::<usize>(), 8);\n+    assert_eq!(align_of::<*const usize>(), 8);\n }\n \n #[test]\n@@ -93,12 +93,12 @@ fn test_transmute_copy() {\n #[test]\n fn test_transmute() {\n     trait Foo { fn dummy(&self) { } }\n-    impl Foo for int {}\n+    impl Foo for isize {}\n \n     let a = box 100isize as Box<Foo>;\n     unsafe {\n         let x: ::core::raw::TraitObject = transmute(a);\n-        assert!(*(x.data as *const int) == 100);\n+        assert!(*(x.data as *const isize) == 100);\n         let _x: Box<Foo> = transmute(x);\n     }\n \n@@ -112,15 +112,15 @@ fn test_transmute() {\n // Static/dynamic method dispatch\n \n struct Struct {\n-    field: int\n+    field: isize\n }\n \n trait Trait {\n-    fn method(&self) -> int;\n+    fn method(&self) -> isize;\n }\n \n impl Trait for Struct {\n-    fn method(&self) -> int {\n+    fn method(&self) -> isize {\n         self.field\n     }\n }"}, {"sha": "7a367ddeec8d4599ec8543a712306059061edd91", "filename": "src/libcoretest/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnonzero.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -43,7 +43,7 @@ fn test_match_on_nonzero_option() {\n \n #[test]\n fn test_match_option_empty_vec() {\n-    let a: Option<Vec<int>> = Some(vec![]);\n+    let a: Option<Vec<isize>> = Some(vec![]);\n     match a {\n         None => panic!(\"unexpected None while matching on Some(vec![])\"),\n         _ => {}"}, {"sha": "33674a3abd870271fa26c15453367bbfa5ee24df", "filename": "src/libcoretest/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fops.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -14,7 +14,7 @@ use core::ops::{Range, RangeFull, RangeFrom, RangeTo};\n // Overhead of dtors\n \n struct HasDtor {\n-    _x: int\n+    _x: isize\n }\n \n impl Drop for HasDtor {"}, {"sha": "569142c0d7dc9609d0e1f04d7b837c6fb3bf9458", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -17,10 +17,10 @@ use core::clone::Clone;\n fn test_get_ptr() {\n     unsafe {\n         let x: Box<_> = box 0;\n-        let addr_x: *const int = mem::transmute(&*x);\n+        let addr_x: *const isize = mem::transmute(&*x);\n         let opt = Some(x);\n         let y = opt.unwrap();\n-        let addr_y: *const int = mem::transmute(&*y);\n+        let addr_y: *const isize = mem::transmute(&*y);\n         assert_eq!(addr_x, addr_y);\n     }\n }\n@@ -41,7 +41,7 @@ fn test_get_resource() {\n     use core::cell::RefCell;\n \n     struct R {\n-       i: Rc<RefCell<int>>,\n+       i: Rc<RefCell<isize>>,\n     }\n \n     #[unsafe_destructor]\n@@ -53,7 +53,7 @@ fn test_get_resource() {\n         }\n     }\n \n-    fn r(i: Rc<RefCell<int>>) -> R {\n+    fn r(i: Rc<RefCell<isize>>) -> R {\n         R {\n             i: i\n         }\n@@ -89,44 +89,44 @@ fn test_option_too_much_dance() {\n \n #[test]\n fn test_and() {\n-    let x: Option<int> = Some(1);\n+    let x: Option<isize> = Some(1);\n     assert_eq!(x.and(Some(2)), Some(2));\n-    assert_eq!(x.and(None::<int>), None);\n+    assert_eq!(x.and(None::<isize>), None);\n \n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     assert_eq!(x.and(Some(2)), None);\n-    assert_eq!(x.and(None::<int>), None);\n+    assert_eq!(x.and(None::<isize>), None);\n }\n \n #[test]\n fn test_and_then() {\n-    let x: Option<int> = Some(1);\n+    let x: Option<isize> = Some(1);\n     assert_eq!(x.and_then(|x| Some(x + 1)), Some(2));\n-    assert_eq!(x.and_then(|_| None::<int>), None);\n+    assert_eq!(x.and_then(|_| None::<isize>), None);\n \n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     assert_eq!(x.and_then(|x| Some(x + 1)), None);\n-    assert_eq!(x.and_then(|_| None::<int>), None);\n+    assert_eq!(x.and_then(|_| None::<isize>), None);\n }\n \n #[test]\n fn test_or() {\n-    let x: Option<int> = Some(1);\n+    let x: Option<isize> = Some(1);\n     assert_eq!(x.or(Some(2)), Some(1));\n     assert_eq!(x.or(None), Some(1));\n \n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     assert_eq!(x.or(Some(2)), Some(2));\n     assert_eq!(x.or(None), None);\n }\n \n #[test]\n fn test_or_else() {\n-    let x: Option<int> = Some(1);\n+    let x: Option<isize> = Some(1);\n     assert_eq!(x.or_else(|| Some(2)), Some(1));\n     assert_eq!(x.or_else(|| None), Some(1));\n \n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     assert_eq!(x.or_else(|| Some(2)), Some(2));\n     assert_eq!(x.or_else(|| None), None);\n }\n@@ -141,7 +141,7 @@ fn test_unwrap() {\n #[test]\n #[should_panic]\n fn test_unwrap_panic1() {\n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     x.unwrap();\n }\n \n@@ -154,19 +154,19 @@ fn test_unwrap_panic2() {\n \n #[test]\n fn test_unwrap_or() {\n-    let x: Option<int> = Some(1);\n+    let x: Option<isize> = Some(1);\n     assert_eq!(x.unwrap_or(2), 1);\n \n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     assert_eq!(x.unwrap_or(2), 2);\n }\n \n #[test]\n fn test_unwrap_or_else() {\n-    let x: Option<int> = Some(1);\n+    let x: Option<isize> = Some(1);\n     assert_eq!(x.unwrap_or_else(|| 2), 1);\n \n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     assert_eq!(x.unwrap_or_else(|| 2), 2);\n }\n \n@@ -223,13 +223,13 @@ fn test_ord() {\n /* FIXME(#20575)\n #[test]\n fn test_collect() {\n-    let v: Option<Vec<int>> = (0..0).map(|_| Some(0)).collect();\n+    let v: Option<Vec<isize>> = (0..0).map(|_| Some(0)).collect();\n     assert!(v == Some(vec![]));\n \n-    let v: Option<Vec<int>> = (0..3).map(|x| Some(x)).collect();\n+    let v: Option<Vec<isize>> = (0..3).map(|x| Some(x)).collect();\n     assert!(v == Some(vec![0, 1, 2]));\n \n-    let v: Option<Vec<int>> = (0..3).map(|x| {\n+    let v: Option<Vec<isize>> = (0..3).map(|x| {\n         if x > 1 { None } else { Some(x) }\n     }).collect();\n     assert!(v == None);\n@@ -258,9 +258,6 @@ fn test_cloned() {\n     assert_eq!(opt_none.clone(), None);\n     assert_eq!(opt_none.cloned(), None);\n \n-    // Mutable refs work\n-    assert_eq!(opt_mut_ref.cloned(), Some(2u32));\n-\n     // Immutable ref works\n     assert_eq!(opt_ref.clone(), Some(&val1));\n     assert_eq!(opt_ref.cloned(), Some(1u32));"}, {"sha": "bdb56c9f867a0229a0c18dec23c9ae495241f762", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -16,12 +16,12 @@ use std::iter::repeat;\n fn test() {\n     unsafe {\n         struct Pair {\n-            fst: int,\n-            snd: int\n+            fst: isize,\n+            snd: isize\n         };\n         let mut p = Pair {fst: 10, snd: 20};\n         let pptr: *mut Pair = &mut p;\n-        let iptr: *mut int = mem::transmute(pptr);\n+        let iptr: *mut isize = mem::transmute(pptr);\n         assert_eq!(*iptr, 10);\n         *iptr = 30;\n         assert_eq!(*iptr, 30);\n@@ -55,13 +55,13 @@ fn test() {\n \n #[test]\n fn test_is_null() {\n-    let p: *const int = null();\n+    let p: *const isize = null();\n     assert!(p.is_null());\n \n     let q = unsafe { p.offset(1) };\n     assert!(!q.is_null());\n \n-    let mp: *mut int = null_mut();\n+    let mp: *mut isize = null_mut();\n     assert!(mp.is_null());\n \n     let mq = unsafe { mp.offset(1) };\n@@ -71,22 +71,22 @@ fn test_is_null() {\n #[test]\n fn test_as_ref() {\n     unsafe {\n-        let p: *const int = null();\n+        let p: *const isize = null();\n         assert_eq!(p.as_ref(), None);\n \n-        let q: *const int = &2;\n+        let q: *const isize = &2;\n         assert_eq!(q.as_ref().unwrap(), &2);\n \n-        let p: *mut int = null_mut();\n+        let p: *mut isize = null_mut();\n         assert_eq!(p.as_ref(), None);\n \n-        let q: *mut int = &mut 2;\n+        let q: *mut isize = &mut 2;\n         assert_eq!(q.as_ref().unwrap(), &2);\n \n         // Lifetime inference\n         let u = 2isize;\n         {\n-            let p = &u as *const int;\n+            let p = &u as *const isize;\n             assert_eq!(p.as_ref().unwrap(), &2);\n         }\n     }\n@@ -95,16 +95,16 @@ fn test_as_ref() {\n #[test]\n fn test_as_mut() {\n     unsafe {\n-        let p: *mut int = null_mut();\n+        let p: *mut isize = null_mut();\n         assert!(p.as_mut() == None);\n \n-        let q: *mut int = &mut 2;\n+        let q: *mut isize = &mut 2;\n         assert!(q.as_mut().unwrap() == &mut 2);\n \n         // Lifetime inference\n         let mut u = 2isize;\n         {\n-            let p = &mut u as *mut int;\n+            let p = &mut u as *mut isize;\n             assert!(p.as_mut().unwrap() == &mut 2);\n         }\n     }\n@@ -143,7 +143,7 @@ fn test_ptr_subtraction() {\n         let ptr = xs.as_ptr();\n \n         while idx >= 0 {\n-            assert_eq!(*(ptr.offset(idx as int)), idx as int);\n+            assert_eq!(*(ptr.offset(idx as isize)), idx as isize);\n             idx = idx - 1;\n         }\n "}, {"sha": "ac8c2b953ae965d185873e429c84a5f547f93e29", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn op1() -> Result<int, &'static str> { Ok(666) }\n-pub fn op2() -> Result<int, &'static str> { Err(\"sadface\") }\n+pub fn op1() -> Result<isize, &'static str> { Ok(666) }\n+pub fn op2() -> Result<isize, &'static str> { Err(\"sadface\") }\n \n #[test]\n pub fn test_and() {\n@@ -24,13 +24,13 @@ pub fn test_and() {\n \n #[test]\n pub fn test_and_then() {\n-    assert_eq!(op1().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap(), 667);\n-    assert_eq!(op1().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n+    assert_eq!(op1().and_then(|i| Ok::<isize, &'static str>(i + 1)).unwrap(), 667);\n+    assert_eq!(op1().and_then(|_| Err::<isize, &'static str>(\"bad\")).unwrap_err(),\n                \"bad\");\n \n-    assert_eq!(op2().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap_err(),\n+    assert_eq!(op2().and_then(|i| Ok::<isize, &'static str>(i + 1)).unwrap_err(),\n                \"sadface\");\n-    assert_eq!(op2().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n+    assert_eq!(op2().and_then(|_| Err::<isize, &'static str>(\"bad\")).unwrap_err(),\n                \"sadface\");\n }\n \n@@ -45,53 +45,53 @@ pub fn test_or() {\n \n #[test]\n pub fn test_or_else() {\n-    assert_eq!(op1().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 666);\n-    assert_eq!(op1().or_else(|e| Err::<int, &'static str>(e)).unwrap(), 666);\n+    assert_eq!(op1().or_else(|_| Ok::<isize, &'static str>(667)).unwrap(), 666);\n+    assert_eq!(op1().or_else(|e| Err::<isize, &'static str>(e)).unwrap(), 666);\n \n-    assert_eq!(op2().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 667);\n-    assert_eq!(op2().or_else(|e| Err::<int, &'static str>(e)).unwrap_err(),\n+    assert_eq!(op2().or_else(|_| Ok::<isize, &'static str>(667)).unwrap(), 667);\n+    assert_eq!(op2().or_else(|e| Err::<isize, &'static str>(e)).unwrap_err(),\n                \"sadface\");\n }\n \n #[test]\n pub fn test_impl_map() {\n-    assert!(Ok::<int, int>(1).map(|x| x + 1) == Ok(2));\n-    assert!(Err::<int, int>(1).map(|x| x + 1) == Err(1));\n+    assert!(Ok::<isize, isize>(1).map(|x| x + 1) == Ok(2));\n+    assert!(Err::<isize, isize>(1).map(|x| x + 1) == Err(1));\n }\n \n #[test]\n pub fn test_impl_map_err() {\n-    assert!(Ok::<int, int>(1).map_err(|x| x + 1) == Ok(1));\n-    assert!(Err::<int, int>(1).map_err(|x| x + 1) == Err(2));\n+    assert!(Ok::<isize, isize>(1).map_err(|x| x + 1) == Ok(1));\n+    assert!(Err::<isize, isize>(1).map_err(|x| x + 1) == Err(2));\n }\n \n /* FIXME(#20575)\n #[test]\n fn test_collect() {\n-    let v: Result<Vec<int>, ()> = (0..0).map(|_| Ok::<int, ()>(0)).collect();\n+    let v: Result<Vec<isize>, ()> = (0..0).map(|_| Ok::<isize, ()>(0)).collect();\n     assert!(v == Ok(vec![]));\n \n-    let v: Result<Vec<int>, ()> = (0..3).map(|x| Ok::<int, ()>(x)).collect();\n+    let v: Result<Vec<isize>, ()> = (0..3).map(|x| Ok::<isize, ()>(x)).collect();\n     assert!(v == Ok(vec![0, 1, 2]));\n \n-    let v: Result<Vec<int>, int> = (0..3).map(|x| {\n+    let v: Result<Vec<isize>, isize> = (0..3).map(|x| {\n         if x > 1 { Err(x) } else { Ok(x) }\n     }).collect();\n     assert!(v == Err(2));\n \n     // test that it does not take more elements than it needs\n-    let mut functions: [Box<Fn() -> Result<(), int>>; 3] =\n+    let mut functions: [Box<Fn() -> Result<(), isize>>; 3] =\n         [box || Ok(()), box || Err(1), box || panic!()];\n \n-    let v: Result<Vec<()>, int> = functions.iter_mut().map(|f| (*f)()).collect();\n+    let v: Result<Vec<()>, isize> = functions.iter_mut().map(|f| (*f)()).collect();\n     assert!(v == Err(1));\n }\n */\n \n #[test]\n pub fn test_fmt_default() {\n-    let ok: Result<int, &'static str> = Ok(100);\n-    let err: Result<int, &'static str> = Err(\"Err\");\n+    let ok: Result<isize, &'static str> = Ok(100);\n+    let err: Result<isize, &'static str> = Err(\"Err\");\n \n     let s = format!(\"{:?}\", ok);\n     assert_eq!(s, \"Ok(100)\");\n@@ -101,25 +101,25 @@ pub fn test_fmt_default() {\n \n #[test]\n pub fn test_unwrap_or() {\n-    let ok: Result<int, &'static str> = Ok(100);\n-    let ok_err: Result<int, &'static str> = Err(\"Err\");\n+    let ok: Result<isize, &'static str> = Ok(100);\n+    let ok_err: Result<isize, &'static str> = Err(\"Err\");\n \n     assert_eq!(ok.unwrap_or(50), 100);\n     assert_eq!(ok_err.unwrap_or(50), 50);\n }\n \n #[test]\n pub fn test_unwrap_or_else() {\n-    fn handler(msg: &'static str) -> int {\n+    fn handler(msg: &'static str) -> isize {\n         if msg == \"I got this.\" {\n             50\n         } else {\n             panic!(\"BadBad\")\n         }\n     }\n \n-    let ok: Result<int, &'static str> = Ok(100);\n-    let ok_err: Result<int, &'static str> = Err(\"I got this.\");\n+    let ok: Result<isize, &'static str> = Ok(100);\n+    let ok_err: Result<isize, &'static str> = Err(\"I got this.\");\n \n     assert_eq!(ok.unwrap_or_else(handler), 100);\n     assert_eq!(ok_err.unwrap_or_else(handler), 50);\n@@ -128,14 +128,14 @@ pub fn test_unwrap_or_else() {\n #[test]\n #[should_panic]\n pub fn test_unwrap_or_else_panic() {\n-    fn handler(msg: &'static str) -> int {\n+    fn handler(msg: &'static str) -> isize {\n         if msg == \"I got this.\" {\n             50\n         } else {\n             panic!(\"BadBad\")\n         }\n     }\n \n-    let bad_err: Result<int, &'static str> = Err(\"Unrecoverable mess.\");\n-    let _ : int = bad_err.unwrap_or_else(handler);\n+    let bad_err: Result<isize, &'static str> = Err(\"Unrecoverable mess.\");\n+    let _ : isize = bad_err.unwrap_or_else(handler);\n }"}, {"sha": "9a5dde8e45e2f92e91bb0c505f2778ab5967426d", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -92,7 +92,6 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![deny(missing_docs)]\n-#![feature(int_uint)]\n #![feature(staged_api)]\n #![feature(str_words)]\n #![feature(str_char)]\n@@ -311,7 +310,7 @@ impl Matches {\n     }\n \n     /// Returns the number of times an option was matched.\n-    pub fn opt_count(&self, nm: &str) -> uint {\n+    pub fn opt_count(&self, nm: &str) -> usize {\n         self.opt_vals(nm).len()\n     }\n \n@@ -389,7 +388,7 @@ fn is_arg(arg: &str) -> bool {\n     arg.len() > 1 && arg.as_bytes()[0] == b'-'\n }\n \n-fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n+fn find_opt(opts: &[Opt], nm: Name) -> Option<usize> {\n     // Search main options.\n     let pos = opts.iter().position(|opt| opt.name == nm);\n     if pos.is_some() {\n@@ -587,7 +586,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n     let n_opts = opts.len();\n \n-    fn f(_x: uint) -> Vec<Optval> { return Vec::new(); }\n+    fn f(_x: usize) -> Vec<Optval> { return Vec::new(); }\n \n     let mut vals: Vec<_> = (0..n_opts).map(f).collect();\n     let mut free: Vec<String> = Vec::new();\n@@ -873,7 +872,7 @@ enum LengthLimit {\n ///\n /// Panics during iteration if the string contains a non-whitespace\n /// sequence longer than the limit.\n-fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n+fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n     F: FnMut(&str) -> bool\n {\n     // Just for fun, let's write this as a state machine:\n@@ -892,7 +891,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n         lim = fake_i;\n     }\n \n-    let mut machine = |cont: &mut bool, (i, c): (uint, char)| -> bool {\n+    let mut machine = |cont: &mut bool, (i, c): (usize, char)| -> bool {\n         let whitespace = if c.is_whitespace() { Ws }       else { Cr };\n         let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n \n@@ -954,7 +953,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n \n #[test]\n fn test_split_within() {\n-    fn t(s: &str, i: uint, u: &[String]) {\n+    fn t(s: &str, i: usize, u: &[String]) {\n         let mut v = Vec::new();\n         each_split_within(s, i, |s| { v.push(s.to_string()); true });\n         assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));"}, {"sha": "b3a3f266a5ef33449a76658aeba5a9c4d77c6bd9", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -281,7 +281,6 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(int_uint)]\n #![feature(collections)]\n #![feature(into_cow)]\n "}, {"sha": "7174b2d2c29fed2016fef4f8f478e20b5fbb0971", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -76,7 +76,7 @@\n \n #![allow(bad_style, raw_pointer_derive)]\n #![cfg_attr(target_os = \"nacl\", allow(unused_imports))]\n-#[cfg(feature = \"cargo-build\")] extern crate \"std\" as core;\n+#[cfg(feature = \"cargo-build\")] extern crate std as core;\n #[cfg(not(feature = \"cargo-build\"))] extern crate core;\n \n #[cfg(test)] extern crate std;"}, {"sha": "1cfac4d86680dc12f59e941aff3c5296f5d03f14", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -172,7 +172,6 @@\n #![feature(alloc)]\n #![feature(staged_api)]\n #![feature(box_syntax)]\n-#![feature(int_uint)]\n #![feature(core)]\n #![feature(std_misc)]\n \n@@ -246,7 +245,7 @@ pub struct LogLevel(pub u32);\n impl fmt::Display for LogLevel {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let LogLevel(level) = *self;\n-        match LOG_LEVEL_NAMES.get(level as uint - 1) {\n+        match LOG_LEVEL_NAMES.get(level as usize - 1) {\n             Some(ref name) => fmt::Display::fmt(name, fmt),\n             None => fmt::Display::fmt(&level, fmt)\n         }\n@@ -289,7 +288,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // is one.\n     unsafe {\n         let _g = LOCK.lock();\n-        match FILTER as uint {\n+        match FILTER as usize {\n             0 => {}\n             1 => panic!(\"cannot log after main thread has exited\"),\n             n => {\n@@ -383,8 +382,8 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n \n     let _g = LOCK.lock();\n     unsafe {\n-        assert!(DIRECTIVES as uint != 0);\n-        assert!(DIRECTIVES as uint != 1,\n+        assert!(DIRECTIVES as usize != 0);\n+        assert!(DIRECTIVES as usize != 1,\n                 \"cannot log after the main thread has exited\");\n \n         enabled(level, module, (*DIRECTIVES).iter())"}, {"sha": "91abb548d2ee18520b13feabec69cc7a7fb60d89", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -15,9 +15,9 @@ use core::num::Int;\n use core::num::wrapping::WrappingOps;\n use {Rng, SeedableRng, Rand};\n \n-const KEY_WORDS    : uint =  8; // 8 words for the 256-bit key\n-const STATE_WORDS  : uint = 16;\n-const CHACHA_ROUNDS: uint = 20; // Cryptographically secure from 8 upwards as of this writing\n+const KEY_WORDS    : usize =  8; // 8 words for the 256-bit key\n+const STATE_WORDS  : usize = 16;\n+const CHACHA_ROUNDS: usize = 20; // Cryptographically secure from 8 upwards as of this writing\n \n /// A random number generator that uses the ChaCha20 algorithm [1].\n ///\n@@ -32,7 +32,7 @@ const CHACHA_ROUNDS: uint = 20; // Cryptographically secure from 8 upwards as of\n pub struct ChaChaRng {\n     buffer:  [u32; STATE_WORDS], // Internal buffer of output\n     state:   [u32; STATE_WORDS], // Initial state\n-    index:   uint,                 // Index into state\n+    index:   usize,                 // Index into state\n }\n \n static EMPTY: ChaChaRng = ChaChaRng {"}, {"sha": "cb0829f52457e9b7698a95a0f7afbfc53c077207", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -76,7 +76,7 @@ impl<Sup: Rand> IndependentSample<Sup> for RandSample<Sup> {\n /// A value with a particular weight for use with `WeightedChoice`.\n pub struct Weighted<T> {\n     /// The numerical weight of this item\n-    pub weight: uint,\n+    pub weight: usize,\n     /// The actual item which is being weighted\n     pub item: T,\n }\n@@ -88,7 +88,7 @@ pub struct Weighted<T> {\n ///\n /// The `Clone` restriction is a limitation of the `Sample` and\n /// `IndependentSample` traits. Note that `&T` is (cheaply) `Clone` for\n-/// all `T`, as is `uint`, so one can store references or indices into\n+/// all `T`, as is `usize`, so one can store references or indices into\n /// another vector.\n ///\n /// # Examples\n@@ -101,7 +101,7 @@ pub struct Weighted<T> {\n /// let mut items = vec!(Weighted { weight: 2, item: 'a' },\n ///                      Weighted { weight: 4, item: 'b' },\n ///                      Weighted { weight: 1, item: 'c' });\n-/// let wc = WeightedChoice::new(items.as_mut_slice());\n+/// let wc = WeightedChoice::new(&mut items[..]);\n /// let mut rng = rand::thread_rng();\n /// for _ in 0..16 {\n ///      // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n@@ -110,7 +110,7 @@ pub struct Weighted<T> {\n /// ```\n pub struct WeightedChoice<'a, T:'a> {\n     items: &'a mut [Weighted<T>],\n-    weight_range: Range<uint>\n+    weight_range: Range<usize>\n }\n \n impl<'a, T: Clone> WeightedChoice<'a, T> {\n@@ -119,7 +119,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n     /// Panics if:\n     /// - `v` is empty\n     /// - the total weight is 0\n-    /// - the total weight is larger than a `uint` can contain.\n+    /// - the total weight is larger than a `usize` can contain.\n     pub fn new(items: &'a mut [Weighted<T>]) -> WeightedChoice<'a, T> {\n         // strictly speaking, this is subsumed by the total weight == 0 case\n         assert!(!items.is_empty(), \"WeightedChoice::new called with no items\");\n@@ -133,7 +133,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n             running_total = match running_total.checked_add(item.weight) {\n                 Some(n) => n,\n                 None => panic!(\"WeightedChoice::new called with a total weight \\\n-                               larger than a uint can contain\")\n+                               larger than a usize can contain\")\n             };\n \n             item.weight = running_total;\n@@ -238,7 +238,7 @@ fn ziggurat<R: Rng, P, Z>(\n         // this may be slower than it would be otherwise.)\n         // FIXME: investigate/optimise for the above.\n         let bits: u64 = rng.gen();\n-        let i = (bits & 0xff) as uint;\n+        let i = (bits & 0xff) as usize;\n         let f = (bits >> 11) as f64 / SCALE;\n \n         // u is either U(-1, 1) or U(0, 1) depending on if this is a\n@@ -270,7 +270,7 @@ mod tests {\n     use super::{RandSample, WeightedChoice, Weighted, Sample, IndependentSample};\n \n     #[derive(PartialEq, Debug)]\n-    struct ConstRand(uint);\n+    struct ConstRand(usize);\n     impl Rand for ConstRand {\n         fn rand<R: Rng>(_: &mut R) -> ConstRand {\n             ConstRand(0)\n@@ -352,7 +352,7 @@ mod tests {\n \n     #[test] #[should_panic]\n     fn test_weighted_choice_no_items() {\n-        WeightedChoice::<int>::new(&mut []);\n+        WeightedChoice::<isize>::new(&mut []);\n     }\n     #[test] #[should_panic]\n     fn test_weighted_choice_zero_weight() {\n@@ -361,7 +361,7 @@ mod tests {\n     }\n     #[test] #[should_panic]\n     fn test_weighted_choice_weight_overflows() {\n-        let x = (-1) as uint / 2; // x + x + 2 is the overflow\n+        let x = (-1) as usize / 2; // x + x + 2 is the overflow\n         WeightedChoice::new(&mut [Weighted { weight: x, item: 0 },\n                                   Weighted { weight: 1, item: 1 },\n                                   Weighted { weight: x, item: 2 },"}, {"sha": "057d3fda2c06b0fd968b77fd564dbf71af0870ff", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -10,8 +10,6 @@\n \n //! Generating numbers between two others.\n \n-#![allow(trivial_numeric_casts)]\n-\n // this is surprisingly complicated to be both generic & correct\n \n use core::prelude::{PartialOrd};\n@@ -138,12 +136,12 @@ integer_impl! { i8, u8 }\n integer_impl! { i16, u16 }\n integer_impl! { i32, u32 }\n integer_impl! { i64, u64 }\n-integer_impl! { int, uint }\n+integer_impl! { isize, usize }\n integer_impl! { u8, u8 }\n integer_impl! { u16, u16 }\n integer_impl! { u32, u32 }\n integer_impl! { u64, u64 }\n-integer_impl! { uint, uint }\n+integer_impl! { usize, usize }\n \n macro_rules! float_impl {\n     ($ty:ty) => {\n@@ -204,8 +202,8 @@ mod tests {\n                  )*\n             }}\n         }\n-        t!(i8, i16, i32, i64, int,\n-           u8, u16, u32, u64, uint)\n+        t!(i8, i16, i32, i64, isize,\n+           u8, u16, u32, u64, usize)\n     }\n \n     #[test]"}, {"sha": "7ea62b7fd3f413b62d35b1d365872e645d3cc4ee", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -447,7 +447,6 @@ impl Rng for Isaac64Rng {\n \n     #[inline]\n     fn next_u64(&mut self) -> u64 {\n-        #![allow(trivial_numeric_casts)]\n         if self.cnt == 0 {\n             // make some more numbers\n             self.isaac64();"}, {"sha": "97106908cde4f04d39261a12eba9fff9026c78ff", "filename": "src/librand/lib.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -24,7 +24,6 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(int_uint)]\n #![feature(no_std)]\n #![no_std]\n #![unstable(feature = \"rand\")]\n@@ -99,8 +98,8 @@ pub trait Rng : Sized {\n     /// See `Closed01` for the closed interval `[0,1]`, and\n     /// `Open01` for the open interval `(0,1)`.\n     fn next_f32(&mut self) -> f32 {\n-        const MANTISSA_BITS: uint = 24;\n-        const IGNORED_BITS: uint = 8;\n+        const MANTISSA_BITS: usize = 24;\n+        const IGNORED_BITS: usize = 8;\n         const SCALE: f32 = (1u64 << MANTISSA_BITS) as f32;\n \n         // using any more than `MANTISSA_BITS` bits will\n@@ -121,8 +120,8 @@ pub trait Rng : Sized {\n     /// See `Closed01` for the closed interval `[0,1]`, and\n     /// `Open01` for the open interval `(0,1)`.\n     fn next_f64(&mut self) -> f64 {\n-        const MANTISSA_BITS: uint = 53;\n-        const IGNORED_BITS: uint = 11;\n+        const MANTISSA_BITS: usize = 53;\n+        const IGNORED_BITS: usize = 11;\n         const SCALE: f64 = (1u64 << MANTISSA_BITS) as f64;\n \n         (self.next_u64() >> IGNORED_BITS) as f64 / SCALE\n@@ -189,7 +188,7 @@ pub trait Rng : Sized {\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n-    /// let x: uint = rng.gen();\n+    /// let x: usize = rng.gen();\n     /// println!(\"{}\", x);\n     /// println!(\"{:?}\", rng.gen::<(f64, bool)>());\n     /// ```\n@@ -208,7 +207,7 @@ pub trait Rng : Sized {\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n-    /// let x = rng.gen_iter::<uint>().take(10).collect::<Vec<uint>>();\n+    /// let x = rng.gen_iter::<usize>().take(10).collect::<Vec<usize>>();\n     /// println!(\"{:?}\", x);\n     /// println!(\"{:?}\", rng.gen_iter::<(f64, bool)>().take(5)\n     ///                     .collect::<Vec<(f64, bool)>>());\n@@ -236,7 +235,7 @@ pub trait Rng : Sized {\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n-    /// let n: uint = rng.gen_range(0, 10);\n+    /// let n: usize = rng.gen_range(0, 10);\n     /// println!(\"{}\", n);\n     /// let m: f64 = rng.gen_range(-40.0f64, 1.3e5f64);\n     /// println!(\"{}\", m);\n@@ -257,7 +256,7 @@ pub trait Rng : Sized {\n     /// let mut rng = thread_rng();\n     /// println!(\"{}\", rng.gen_weighted_bool(3));\n     /// ```\n-    fn gen_weighted_bool(&mut self, n: uint) -> bool {\n+    fn gen_weighted_bool(&mut self, n: usize) -> bool {\n         n <= 1 || self.gen_range(0, n) == 0\n     }\n "}, {"sha": "ab4939f57d41a62ff357bd543db5d4fa3d2b9097", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -18,14 +18,14 @@ use core::default::Default;\n \n /// How many bytes of entropy the underling RNG is allowed to generate\n /// before it is reseeded.\n-const DEFAULT_GENERATION_THRESHOLD: uint = 32 * 1024;\n+const DEFAULT_GENERATION_THRESHOLD: usize = 32 * 1024;\n \n /// A wrapper around any RNG which reseeds the underlying RNG after it\n /// has generated a certain number of random bytes.\n pub struct ReseedingRng<R, Rsdr> {\n     rng: R,\n-    generation_threshold: uint,\n-    bytes_generated: uint,\n+    generation_threshold: usize,\n+    bytes_generated: usize,\n     /// Controls the behaviour when reseeding the RNG.\n     pub reseeder: Rsdr,\n }\n@@ -38,7 +38,7 @@ impl<R: Rng, Rsdr: Reseeder<R>> ReseedingRng<R, Rsdr> {\n     /// * `rng`: the random number generator to use.\n     /// * `generation_threshold`: the number of bytes of entropy at which to reseed the RNG.\n     /// * `reseeder`: the reseeding object to use.\n-    pub fn new(rng: R, generation_threshold: uint, reseeder: Rsdr) -> ReseedingRng<R,Rsdr> {\n+    pub fn new(rng: R, generation_threshold: usize, reseeder: Rsdr) -> ReseedingRng<R,Rsdr> {\n         ReseedingRng {\n             rng: rng,\n             generation_threshold: generation_threshold,\n@@ -213,7 +213,7 @@ mod test {\n         assert_eq!(string1, string2);\n     }\n \n-    const FILL_BYTES_V_LEN: uint = 13579;\n+    const FILL_BYTES_V_LEN: usize = 13579;\n     #[test]\n     fn test_rng_fill_bytes() {\n         let mut v = repeat(0).take(FILL_BYTES_V_LEN).collect::<Vec<_>>();"}, {"sha": "fd35c9c6be96d215052129a696a5201792089e92", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 139, "deletions": 140, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -27,7 +27,7 @@\n //! where the tag number is ORed with 0xf000. (E.g. tag 0x123 = `f1 23`)\n //!\n //! **Lengths** encode the length of the following data.\n-//! It is a variable-length unsigned int, and one of the following forms:\n+//! It is a variable-length unsigned isize, and one of the following forms:\n //!\n //! - `80` through `fe` for lengths up to 0x7e;\n //! - `40 ff` through `7f ff` for lengths up to 0x3fff;\n@@ -125,7 +125,6 @@\n \n #![feature(io)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n \n@@ -146,16 +145,16 @@ use std::fmt;\n #[derive(Clone, Copy)]\n pub struct Doc<'a> {\n     pub data: &'a [u8],\n-    pub start: uint,\n-    pub end: uint,\n+    pub start: usize,\n+    pub end: usize,\n }\n \n impl<'doc> Doc<'doc> {\n     pub fn new(data: &'doc [u8]) -> Doc<'doc> {\n         Doc { data: data, start: 0, end: data.len() }\n     }\n \n-    pub fn get<'a>(&'a self, tag: uint) -> Doc<'a> {\n+    pub fn get<'a>(&'a self, tag: usize) -> Doc<'a> {\n         reader::get_doc(*self, tag)\n     }\n \n@@ -173,7 +172,7 @@ impl<'doc> Doc<'doc> {\n }\n \n pub struct TaggedDoc<'a> {\n-    tag: uint,\n+    tag: usize,\n     pub doc: Doc<'a>,\n }\n \n@@ -208,8 +207,8 @@ pub enum EbmlEncoderTag {\n     EsOpaque   = 0x17,\n }\n \n-const NUM_TAGS: uint = 0x1000;\n-const NUM_IMPLICIT_TAGS: uint = 0x0e;\n+const NUM_TAGS: usize = 0x1000;\n+const NUM_IMPLICIT_TAGS: usize = 0x0e;\n \n static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n     1, 2, 4, 8, // EsU*\n@@ -222,8 +221,8 @@ static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n \n #[derive(Debug)]\n pub enum Error {\n-    IntTooBig(uint),\n-    InvalidTag(uint),\n+    IntTooBig(usize),\n+    InvalidTag(usize),\n     Expected(String),\n     IoError(std::io::Error),\n     ApplicationError(String)\n@@ -270,50 +269,50 @@ pub mod reader {\n \n     #[derive(Copy)]\n     pub struct Res {\n-        pub val: uint,\n-        pub next: uint\n+        pub val: usize,\n+        pub next: usize\n     }\n \n-    pub fn tag_at(data: &[u8], start: uint) -> DecodeResult<Res> {\n-        let v = data[start] as uint;\n+    pub fn tag_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n+        let v = data[start] as usize;\n         if v < 0xf0 {\n             Ok(Res { val: v, next: start + 1 })\n         } else if v > 0xf0 {\n-            Ok(Res { val: ((v & 0xf) << 8) | data[start + 1] as uint, next: start + 2 })\n+            Ok(Res { val: ((v & 0xf) << 8) | data[start + 1] as usize, next: start + 2 })\n         } else {\n             // every tag starting with byte 0xf0 is an overlong form, which is prohibited.\n             Err(InvalidTag(v))\n         }\n     }\n \n     #[inline(never)]\n-    fn vuint_at_slow(data: &[u8], start: uint) -> DecodeResult<Res> {\n+    fn vuint_at_slow(data: &[u8], start: usize) -> DecodeResult<Res> {\n         let a = data[start];\n         if a & 0x80 != 0 {\n-            return Ok(Res {val: (a & 0x7f) as uint, next: start + 1});\n+            return Ok(Res {val: (a & 0x7f) as usize, next: start + 1});\n         }\n         if a & 0x40 != 0 {\n-            return Ok(Res {val: ((a & 0x3f) as uint) << 8 |\n-                        (data[start + 1] as uint),\n+            return Ok(Res {val: ((a & 0x3f) as usize) << 8 |\n+                        (data[start + 1] as usize),\n                     next: start + 2});\n         }\n         if a & 0x20 != 0 {\n-            return Ok(Res {val: ((a & 0x1f) as uint) << 16 |\n-                        (data[start + 1] as uint) << 8 |\n-                        (data[start + 2] as uint),\n+            return Ok(Res {val: ((a & 0x1f) as usize) << 16 |\n+                        (data[start + 1] as usize) << 8 |\n+                        (data[start + 2] as usize),\n                     next: start + 3});\n         }\n         if a & 0x10 != 0 {\n-            return Ok(Res {val: ((a & 0x0f) as uint) << 24 |\n-                        (data[start + 1] as uint) << 16 |\n-                        (data[start + 2] as uint) << 8 |\n-                        (data[start + 3] as uint),\n+            return Ok(Res {val: ((a & 0x0f) as usize) << 24 |\n+                        (data[start + 1] as usize) << 16 |\n+                        (data[start + 2] as usize) << 8 |\n+                        (data[start + 3] as usize),\n                     next: start + 4});\n         }\n-        Err(IntTooBig(a as uint))\n+        Err(IntTooBig(a as usize))\n     }\n \n-    pub fn vuint_at(data: &[u8], start: uint) -> DecodeResult<Res> {\n+    pub fn vuint_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n         if data.len() - start < 4 {\n             return vuint_at_slow(data, start);\n         }\n@@ -337,7 +336,7 @@ pub mod reader {\n         // most significant bit is set etc. we can replace up to three\n         // \"and+branch\" with a single table lookup which gives us a measured\n         // speedup of around 2x on x86_64.\n-        static SHIFT_MASK_TABLE: [(uint, u32); 16] = [\n+        static SHIFT_MASK_TABLE: [(usize, u32); 16] = [\n             (0, 0x0), (0, 0x0fffffff),\n             (8, 0x1fffff), (8, 0x1fffff),\n             (16, 0x3fff), (16, 0x3fff), (16, 0x3fff), (16, 0x3fff),\n@@ -346,10 +345,10 @@ pub mod reader {\n         ];\n \n         unsafe {\n-            let ptr = data.as_ptr().offset(start as int) as *const u32;\n+            let ptr = data.as_ptr().offset(start as isize) as *const u32;\n             let val = Int::from_be(*ptr);\n \n-            let i = (val >> 28) as uint;\n+            let i = (val >> 28) as usize;\n             let (shift, mask) = SHIFT_MASK_TABLE[i];\n             Ok(Res {\n                 val: ((val >> shift) & mask) as usize,\n@@ -360,13 +359,13 @@ pub mod reader {\n \n     pub fn tag_len_at(data: &[u8], tag: Res) -> DecodeResult<Res> {\n         if tag.val < NUM_IMPLICIT_TAGS && TAG_IMPLICIT_LEN[tag.val] >= 0 {\n-            Ok(Res { val: TAG_IMPLICIT_LEN[tag.val] as uint, next: tag.next })\n+            Ok(Res { val: TAG_IMPLICIT_LEN[tag.val] as usize, next: tag.next })\n         } else {\n             vuint_at(data, tag.next)\n         }\n     }\n \n-    pub fn doc_at<'a>(data: &'a [u8], start: uint) -> DecodeResult<TaggedDoc<'a>> {\n+    pub fn doc_at<'a>(data: &'a [u8], start: usize) -> DecodeResult<TaggedDoc<'a>> {\n         let elt_tag = try!(tag_at(data, start));\n         let elt_size = try!(tag_len_at(data, elt_tag));\n         let end = elt_size.next + elt_size.val;\n@@ -376,7 +375,7 @@ pub mod reader {\n         })\n     }\n \n-    pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: uint) -> Option<Doc<'a>> {\n+    pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: usize) -> Option<Doc<'a>> {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = try_or!(tag_at(d.data, pos), None);\n@@ -390,7 +389,7 @@ pub mod reader {\n         None\n     }\n \n-    pub fn get_doc<'a>(d: Doc<'a>, tg: uint) -> Doc<'a> {\n+    pub fn get_doc<'a>(d: Doc<'a>, tg: usize) -> Doc<'a> {\n         match maybe_get_doc(d, tg) {\n             Some(d) => d,\n             None => {\n@@ -401,7 +400,7 @@ pub mod reader {\n     }\n \n     pub fn docs<F>(d: Doc, mut it: F) -> bool where\n-        F: FnMut(uint, Doc) -> bool,\n+        F: FnMut(usize, Doc) -> bool,\n     {\n         let mut pos = d.start;\n         while pos < d.end {\n@@ -416,7 +415,7 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn tagged_docs<F>(d: Doc, tg: uint, mut it: F) -> bool where\n+    pub fn tagged_docs<F>(d: Doc, tg: usize, mut it: F) -> bool where\n         F: FnMut(Doc) -> bool,\n     {\n         let mut pos = d.start;\n@@ -475,7 +474,7 @@ pub mod reader {\n \n     pub struct Decoder<'a> {\n         parent: Doc<'a>,\n-        pos: uint,\n+        pos: usize,\n     }\n \n     impl<'doc> Decoder<'doc> {\n@@ -501,7 +500,7 @@ pub mod reader {\n                    r_tag,\n                    r_doc.start,\n                    r_doc.end);\n-            if r_tag != (exp_tag as uint) {\n+            if r_tag != (exp_tag as usize) {\n                 return Err(Expected(format!(\"expected EBML doc with tag {:?} but \\\n                                              found tag {:?}\", exp_tag, r_tag)));\n             }\n@@ -528,18 +527,18 @@ pub mod reader {\n             Ok(r)\n         }\n \n-        fn _next_sub(&mut self) -> DecodeResult<uint> {\n+        fn _next_sub(&mut self) -> DecodeResult<usize> {\n             // empty vector/map optimization\n             if self.parent.is_empty() {\n                 return Ok(0);\n             }\n \n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 try!(doc_at(self.parent.data, self.pos));\n-            let r = if r_tag == (EsSub8 as uint) {\n-                doc_as_u8(r_doc) as uint\n-            } else if r_tag == (EsSub32 as uint) {\n-                doc_as_u32(r_doc) as uint\n+            let r = if r_tag == (EsSub8 as usize) {\n+                doc_as_u8(r_doc) as usize\n+            } else if r_tag == (EsSub32 as usize) {\n+                doc_as_u32(r_doc) as usize\n             } else {\n                 return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but \\\n                                              found tag {:?}\", EsSub8, EsSub32, r_tag)));\n@@ -568,8 +567,8 @@ pub mod reader {\n \n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 try!(doc_at(self.parent.data, self.pos));\n-            let r = if first_tag as uint <= r_tag && r_tag <= last_tag as uint {\n-                match r_tag - first_tag as uint {\n+            let r = if first_tag as usize <= r_tag && r_tag <= last_tag as usize {\n+                match r_tag - first_tag as usize {\n                     0 => doc_as_u8(r_doc) as u64,\n                     1 => doc_as_u16(r_doc) as u64,\n                     2 => doc_as_u32(r_doc) as u64,\n@@ -615,26 +614,26 @@ pub mod reader {\n         fn read_u32(&mut self) -> DecodeResult<u32> { Ok(try!(self._next_int(EsU8, EsU32)) as u32) }\n         fn read_u16(&mut self) -> DecodeResult<u16> { Ok(try!(self._next_int(EsU8, EsU16)) as u16) }\n         fn read_u8(&mut self) -> DecodeResult<u8> { Ok(doc_as_u8(try!(self.next_doc(EsU8)))) }\n-        fn read_uint(&mut self) -> DecodeResult<uint> {\n+        fn read_uint(&mut self) -> DecodeResult<usize> {\n             let v = try!(self._next_int(EsU8, EsU64));\n             if v > (::std::usize::MAX as u64) {\n-                Err(IntTooBig(v as uint))\n+                Err(IntTooBig(v as usize))\n             } else {\n-                Ok(v as uint)\n+                Ok(v as usize)\n             }\n         }\n \n         fn read_i64(&mut self) -> DecodeResult<i64> { Ok(try!(self._next_int(EsI8, EsI64)) as i64) }\n         fn read_i32(&mut self) -> DecodeResult<i32> { Ok(try!(self._next_int(EsI8, EsI32)) as i32) }\n         fn read_i16(&mut self) -> DecodeResult<i16> { Ok(try!(self._next_int(EsI8, EsI16)) as i16) }\n         fn read_i8(&mut self) -> DecodeResult<i8> { Ok(doc_as_u8(try!(self.next_doc(EsI8))) as i8) }\n-        fn read_int(&mut self) -> DecodeResult<int> {\n+        fn read_int(&mut self) -> DecodeResult<isize> {\n             let v = try!(self._next_int(EsI8, EsI64)) as i64;\n             if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n                 debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n-                Err(IntTooBig(v as uint))\n+                Err(IntTooBig(v as usize))\n             } else {\n-                Ok(v as int)\n+                Ok(v as isize)\n             }\n         }\n \n@@ -678,7 +677,7 @@ pub mod reader {\n \n         fn read_enum_variant<T, F>(&mut self, _: &[&str],\n                                    mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum_variant()\");\n             let idx = try!(self._next_sub());\n@@ -687,7 +686,7 @@ pub mod reader {\n             f(self, idx)\n         }\n \n-        fn read_enum_variant_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        fn read_enum_variant_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum_variant_arg(idx={})\", idx);\n@@ -696,7 +695,7 @@ pub mod reader {\n \n         fn read_enum_struct_variant<T, F>(&mut self, _: &[&str],\n                                           mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum_struct_variant()\");\n             let idx = try!(self._next_sub());\n@@ -707,7 +706,7 @@ pub mod reader {\n \n         fn read_enum_struct_variant_field<T, F>(&mut self,\n                                                 name: &str,\n-                                                idx: uint,\n+                                                idx: usize,\n                                                 f: F)\n                                                 -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n@@ -716,21 +715,21 @@ pub mod reader {\n             f(self)\n         }\n \n-        fn read_struct<T, F>(&mut self, name: &str, _: uint, f: F) -> DecodeResult<T> where\n+        fn read_struct<T, F>(&mut self, name: &str, _: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_struct(name={})\", name);\n             f(self)\n         }\n \n-        fn read_struct_field<T, F>(&mut self, name: &str, idx: uint, f: F) -> DecodeResult<T> where\n+        fn read_struct_field<T, F>(&mut self, name: &str, idx: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n             f(self)\n         }\n \n-        fn read_tuple<T, F>(&mut self, tuple_len: uint, f: F) -> DecodeResult<T> where\n+        fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_tuple()\");\n@@ -744,22 +743,22 @@ pub mod reader {\n             })\n         }\n \n-        fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_tuple_arg(idx={})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n-        fn read_tuple_struct<T, F>(&mut self, name: &str, len: uint, f: F) -> DecodeResult<T> where\n+        fn read_tuple_struct<T, F>(&mut self, name: &str, len: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_tuple_struct(name={})\", name);\n             self.read_tuple(len, f)\n         }\n \n         fn read_tuple_struct_arg<T, F>(&mut self,\n-                                       idx: uint,\n+                                       idx: usize,\n                                        f: F)\n                                        -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n@@ -786,7 +785,7 @@ pub mod reader {\n         }\n \n         fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+            F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>,\n         {\n             debug!(\"read_seq()\");\n             self.push_doc(EsVec, move |d| {\n@@ -796,15 +795,15 @@ pub mod reader {\n             })\n         }\n \n-        fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_seq_elt(idx={})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n         fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+            F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>,\n         {\n             debug!(\"read_map()\");\n             self.push_doc(EsMap, move |d| {\n@@ -814,14 +813,14 @@ pub mod reader {\n             })\n         }\n \n-        fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_map_elt_key(idx={})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n-        fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_map_elt_val(idx={})\", idx);\n@@ -859,7 +858,7 @@ pub mod writer {\n         relax_limit: u64, // do not move encoded bytes before this position\n     }\n \n-    fn write_tag<W: Write>(w: &mut W, n: uint) -> EncodeResult {\n+    fn write_tag<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n         if n < 0xf0 {\n             w.write_all(&[n as u8])\n         } else if 0x100 <= n && n < NUM_TAGS {\n@@ -870,7 +869,7 @@ pub mod writer {\n         }\n     }\n \n-    fn write_sized_vuint<W: Write>(w: &mut W, n: uint, size: uint) -> EncodeResult {\n+    fn write_sized_vuint<W: Write>(w: &mut W, n: usize, size: usize) -> EncodeResult {\n         match size {\n             1 => w.write_all(&[0x80 | (n as u8)]),\n             2 => w.write_all(&[0x40 | ((n >> 8) as u8), n as u8]),\n@@ -879,16 +878,16 @@ pub mod writer {\n             4 => w.write_all(&[0x10 | ((n >> 24) as u8), (n >> 16) as u8,\n                             (n >> 8) as u8, n as u8]),\n             _ => Err(io::Error::new(io::ErrorKind::Other,\n-                                    \"int too big\", Some(n.to_string())))\n+                                    \"isize too big\", Some(n.to_string())))\n         }\n     }\n \n-    fn write_vuint<W: Write>(w: &mut W, n: uint) -> EncodeResult {\n+    fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n         if n < 0x7f { return write_sized_vuint(w, n, 1); }\n         if n < 0x4000 { return write_sized_vuint(w, n, 2); }\n         if n < 0x200000 { return write_sized_vuint(w, n, 3); }\n         if n < 0x10000000 { return write_sized_vuint(w, n, 4); }\n-        Err(io::Error::new(io::ErrorKind::Other, \"int too big\",\n+        Err(io::Error::new(io::ErrorKind::Other, \"isize too big\",\n                            Some(n.to_string())))\n     }\n \n@@ -910,7 +909,7 @@ pub mod writer {\n             }\n         }\n \n-        pub fn start_tag(&mut self, tag_id: uint) -> EncodeResult {\n+        pub fn start_tag(&mut self, tag_id: usize) -> EncodeResult {\n             debug!(\"Start tag {:?}\", tag_id);\n             assert!(tag_id >= NUM_IMPLICIT_TAGS);\n \n@@ -932,13 +931,13 @@ pub mod writer {\n \n             // relax the size encoding for small tags (bigger tags are costly to move).\n             // we should never try to move the stable positions, however.\n-            const RELAX_MAX_SIZE: uint = 0x100;\n+            const RELAX_MAX_SIZE: usize = 0x100;\n             if size <= RELAX_MAX_SIZE && last_size_pos >= self.relax_limit {\n                 // we can't alter the buffer in place, so have a temporary buffer\n                 let mut buf = [0u8; RELAX_MAX_SIZE];\n                 {\n                     let last_size_pos = last_size_pos as usize;\n-                    let data = &self.writer.get_ref()[last_size_pos+4..cur_pos as uint];\n+                    let data = &self.writer.get_ref()[last_size_pos+4..cur_pos as usize];\n                     bytes::copy_memory(&mut buf, data);\n                 }\n \n@@ -955,98 +954,98 @@ pub mod writer {\n             Ok(())\n         }\n \n-        pub fn wr_tag<F>(&mut self, tag_id: uint, blk: F) -> EncodeResult where\n+        pub fn wr_tag<F>(&mut self, tag_id: usize, blk: F) -> EncodeResult where\n             F: FnOnce() -> EncodeResult,\n         {\n             try!(self.start_tag(tag_id));\n             try!(blk());\n             self.end_tag()\n         }\n \n-        pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) -> EncodeResult {\n+        pub fn wr_tagged_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n             assert!(tag_id >= NUM_IMPLICIT_TAGS);\n             try!(write_tag(self.writer, tag_id));\n             try!(write_vuint(self.writer, b.len()));\n             self.writer.write_all(b)\n         }\n \n-        pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) -> EncodeResult {\n+        pub fn wr_tagged_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n             let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_bytes(tag_id, &bytes)\n         }\n \n-        pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32)  -> EncodeResult{\n+        pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32)  -> EncodeResult{\n             let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_bytes(tag_id, &bytes)\n         }\n \n-        pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) -> EncodeResult {\n+        pub fn wr_tagged_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n             let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_bytes(tag_id, &bytes)\n         }\n \n-        pub fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) -> EncodeResult {\n+        pub fn wr_tagged_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n             self.wr_tagged_bytes(tag_id, &[v])\n         }\n \n-        pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) -> EncodeResult {\n+        pub fn wr_tagged_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n             self.wr_tagged_u64(tag_id, v as u64)\n         }\n \n-        pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) -> EncodeResult {\n+        pub fn wr_tagged_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n             self.wr_tagged_u32(tag_id, v as u32)\n         }\n \n-        pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) -> EncodeResult {\n+        pub fn wr_tagged_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n             self.wr_tagged_u16(tag_id, v as u16)\n         }\n \n-        pub fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) -> EncodeResult {\n+        pub fn wr_tagged_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n             self.wr_tagged_bytes(tag_id, &[v as u8])\n         }\n \n-        pub fn wr_tagged_str(&mut self, tag_id: uint, v: &str) -> EncodeResult {\n+        pub fn wr_tagged_str(&mut self, tag_id: usize, v: &str) -> EncodeResult {\n             self.wr_tagged_bytes(tag_id, v.as_bytes())\n         }\n \n         // for auto-serialization\n-        fn wr_tagged_raw_bytes(&mut self, tag_id: uint, b: &[u8]) -> EncodeResult {\n+        fn wr_tagged_raw_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n             try!(write_tag(self.writer, tag_id));\n             self.writer.write_all(b)\n         }\n \n-        fn wr_tagged_raw_u64(&mut self, tag_id: uint, v: u64) -> EncodeResult {\n+        fn wr_tagged_raw_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n             let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_raw_bytes(tag_id, &bytes)\n         }\n \n-        fn wr_tagged_raw_u32(&mut self, tag_id: uint, v: u32)  -> EncodeResult{\n+        fn wr_tagged_raw_u32(&mut self, tag_id: usize, v: u32)  -> EncodeResult{\n             let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_raw_bytes(tag_id, &bytes)\n         }\n \n-        fn wr_tagged_raw_u16(&mut self, tag_id: uint, v: u16) -> EncodeResult {\n+        fn wr_tagged_raw_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n             let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_raw_bytes(tag_id, &bytes)\n         }\n \n-        fn wr_tagged_raw_u8(&mut self, tag_id: uint, v: u8) -> EncodeResult {\n+        fn wr_tagged_raw_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n             self.wr_tagged_raw_bytes(tag_id, &[v])\n         }\n \n-        fn wr_tagged_raw_i64(&mut self, tag_id: uint, v: i64) -> EncodeResult {\n+        fn wr_tagged_raw_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n             self.wr_tagged_raw_u64(tag_id, v as u64)\n         }\n \n-        fn wr_tagged_raw_i32(&mut self, tag_id: uint, v: i32) -> EncodeResult {\n+        fn wr_tagged_raw_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n             self.wr_tagged_raw_u32(tag_id, v as u32)\n         }\n \n-        fn wr_tagged_raw_i16(&mut self, tag_id: uint, v: i16) -> EncodeResult {\n+        fn wr_tagged_raw_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n             self.wr_tagged_raw_u16(tag_id, v as u16)\n         }\n \n-        fn wr_tagged_raw_i8(&mut self, tag_id: uint, v: i8) -> EncodeResult {\n+        fn wr_tagged_raw_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n             self.wr_tagged_raw_bytes(tag_id, &[v as u8])\n         }\n \n@@ -1073,11 +1072,11 @@ pub mod writer {\n \n     impl<'a> Encoder<'a> {\n         // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_sub(&mut self, v: uint) -> EncodeResult {\n+        fn _emit_tagged_sub(&mut self, v: usize) -> EncodeResult {\n             if let Some(v) = v.to_u8() {\n-                self.wr_tagged_raw_u8(EsSub8 as uint, v)\n+                self.wr_tagged_raw_u8(EsSub8 as usize, v)\n             } else if let Some(v) = v.to_u32() {\n-                self.wr_tagged_raw_u32(EsSub32 as uint, v)\n+                self.wr_tagged_raw_u32(EsSub32 as usize, v)\n             } else {\n                 Err(io::Error::new(io::ErrorKind::Other,\n                                    \"length or variant id too big\",\n@@ -1088,7 +1087,7 @@ pub mod writer {\n         pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder) -> EncodeResult,\n         {\n-            try!(self.start_tag(EsOpaque as uint));\n+            try!(self.start_tag(EsOpaque as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n@@ -1101,105 +1100,105 @@ pub mod writer {\n             Ok(())\n         }\n \n-        fn emit_uint(&mut self, v: uint) -> EncodeResult {\n+        fn emit_uint(&mut self, v: usize) -> EncodeResult {\n             self.emit_u64(v as u64)\n         }\n         fn emit_u64(&mut self, v: u64) -> EncodeResult {\n             match v.to_u32() {\n                 Some(v) => self.emit_u32(v),\n-                None => self.wr_tagged_raw_u64(EsU64 as uint, v)\n+                None => self.wr_tagged_raw_u64(EsU64 as usize, v)\n             }\n         }\n         fn emit_u32(&mut self, v: u32) -> EncodeResult {\n             match v.to_u16() {\n                 Some(v) => self.emit_u16(v),\n-                None => self.wr_tagged_raw_u32(EsU32 as uint, v)\n+                None => self.wr_tagged_raw_u32(EsU32 as usize, v)\n             }\n         }\n         fn emit_u16(&mut self, v: u16) -> EncodeResult {\n             match v.to_u8() {\n                 Some(v) => self.emit_u8(v),\n-                None => self.wr_tagged_raw_u16(EsU16 as uint, v)\n+                None => self.wr_tagged_raw_u16(EsU16 as usize, v)\n             }\n         }\n         fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-            self.wr_tagged_raw_u8(EsU8 as uint, v)\n+            self.wr_tagged_raw_u8(EsU8 as usize, v)\n         }\n \n-        fn emit_int(&mut self, v: int) -> EncodeResult {\n+        fn emit_int(&mut self, v: isize) -> EncodeResult {\n             self.emit_i64(v as i64)\n         }\n         fn emit_i64(&mut self, v: i64) -> EncodeResult {\n             match v.to_i32() {\n                 Some(v) => self.emit_i32(v),\n-                None => self.wr_tagged_raw_i64(EsI64 as uint, v)\n+                None => self.wr_tagged_raw_i64(EsI64 as usize, v)\n             }\n         }\n         fn emit_i32(&mut self, v: i32) -> EncodeResult {\n             match v.to_i16() {\n                 Some(v) => self.emit_i16(v),\n-                None => self.wr_tagged_raw_i32(EsI32 as uint, v)\n+                None => self.wr_tagged_raw_i32(EsI32 as usize, v)\n             }\n         }\n         fn emit_i16(&mut self, v: i16) -> EncodeResult {\n             match v.to_i8() {\n                 Some(v) => self.emit_i8(v),\n-                None => self.wr_tagged_raw_i16(EsI16 as uint, v)\n+                None => self.wr_tagged_raw_i16(EsI16 as usize, v)\n             }\n         }\n         fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-            self.wr_tagged_raw_i8(EsI8 as uint, v)\n+            self.wr_tagged_raw_i8(EsI8 as usize, v)\n         }\n \n         fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-            self.wr_tagged_raw_u8(EsBool as uint, v as u8)\n+            self.wr_tagged_raw_u8(EsBool as usize, v as u8)\n         }\n \n         fn emit_f64(&mut self, v: f64) -> EncodeResult {\n             let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_raw_u64(EsF64 as uint, bits)\n+            self.wr_tagged_raw_u64(EsF64 as usize, bits)\n         }\n         fn emit_f32(&mut self, v: f32) -> EncodeResult {\n             let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_raw_u32(EsF32 as uint, bits)\n+            self.wr_tagged_raw_u32(EsF32 as usize, bits)\n         }\n         fn emit_char(&mut self, v: char) -> EncodeResult {\n-            self.wr_tagged_raw_u32(EsChar as uint, v as u32)\n+            self.wr_tagged_raw_u32(EsChar as usize, v as u32)\n         }\n \n         fn emit_str(&mut self, v: &str) -> EncodeResult {\n-            self.wr_tagged_str(EsStr as uint, v)\n+            self.wr_tagged_str(EsStr as usize, v)\n         }\n \n         fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n-            try!(self.start_tag(EsEnum as uint));\n+            try!(self.start_tag(EsEnum as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n \n         fn emit_enum_variant<F>(&mut self,\n                                 _: &str,\n-                                v_id: uint,\n-                                _: uint,\n+                                v_id: usize,\n+                                _: usize,\n                                 f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             try!(self._emit_tagged_sub(v_id));\n             f(self)\n         }\n \n-        fn emit_enum_variant_arg<F>(&mut self, _: uint, f: F) -> EncodeResult where\n+        fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             f(self)\n         }\n \n         fn emit_enum_struct_variant<F>(&mut self,\n                                        v_name: &str,\n-                                       v_id: uint,\n-                                       cnt: uint,\n+                                       v_id: usize,\n+                                       cnt: usize,\n                                        f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n@@ -1208,42 +1207,42 @@ pub mod writer {\n \n         fn emit_enum_struct_variant_field<F>(&mut self,\n                                              _: &str,\n-                                             idx: uint,\n+                                             idx: usize,\n                                              f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct<F>(&mut self, _: &str, _len: uint, f: F) -> EncodeResult where\n+        fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             f(self)\n         }\n \n-        fn emit_struct_field<F>(&mut self, _name: &str, _: uint, f: F) -> EncodeResult where\n+        fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             f(self)\n         }\n \n-        fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+        fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq_elt(idx, f)\n@@ -1264,56 +1263,56 @@ pub mod writer {\n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n-        fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             if len == 0 {\n                 // empty vector optimization\n-                return self.wr_tagged_bytes(EsVec as uint, &[]);\n+                return self.wr_tagged_bytes(EsVec as usize, &[]);\n             }\n \n-            try!(self.start_tag(EsVec as uint));\n+            try!(self.start_tag(EsVec as usize));\n             try!(self._emit_tagged_sub(len));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_seq_elt<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+        fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n \n-            try!(self.start_tag(EsVecElt as uint));\n+            try!(self.start_tag(EsVecElt as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             if len == 0 {\n                 // empty map optimization\n-                return self.wr_tagged_bytes(EsMap as uint, &[]);\n+                return self.wr_tagged_bytes(EsMap as usize, &[]);\n             }\n \n-            try!(self.start_tag(EsMap as uint));\n+            try!(self.start_tag(EsMap as usize));\n             try!(self._emit_tagged_sub(len));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map_elt_key<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+        fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n \n-            try!(self.start_tag(EsMapKey as uint));\n+            try!(self.start_tag(EsMapKey as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+        fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n-            try!(self.start_tag(EsMapVal as uint));\n+            try!(self.start_tag(EsMapVal as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n@@ -1381,7 +1380,7 @@ mod tests {\n \n     #[test]\n     fn test_option_int() {\n-        fn test_v(v: Option<int>) {\n+        fn test_v(v: Option<isize>) {\n             debug!(\"v == {:?}\", v);\n             let mut wr = Cursor::new(Vec::new());\n             {"}, {"sha": "f31f8e8d4ce2708894ccf804ffaac8c1aee544a7", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -30,9 +30,7 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(hash)]\n-#![feature(int_uint)]\n #![feature(libc)]\n-#![feature(old_path)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -45,10 +43,10 @@\n #![feature(str_char)]\n #![feature(convert)]\n #![feature(into_cow)]\n+#![feature(slice_patterns)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(trivial_casts)]\n-#![allow(trivial_numeric_casts)]\n \n extern crate arena;\n extern crate flate;\n@@ -65,7 +63,7 @@ extern crate collections;\n #[macro_use] extern crate syntax;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n \n-extern crate \"serialize\" as rustc_serialize; // used by deriving\n+extern crate serialize as rustc_serialize; // used by deriving\n \n #[cfg(test)]\n extern crate test;"}, {"sha": "9093cd00ca0014d4b729239ca382c95f055bd282", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -102,13 +102,13 @@ declare_lint! {\n \n declare_lint! {\n     pub TRIVIAL_CASTS,\n-    Warn,\n+    Allow,\n     \"detects trivial casts which could be removed\"\n }\n \n declare_lint! {\n     pub TRIVIAL_NUMERIC_CASTS,\n-    Warn,\n+    Allow,\n     \"detects trivial casts of numeric types which could be removed\"\n }\n /// Does nothing as a lint pass, but registers some `Lint`s"}, {"sha": "e4c0eda0448bdae443eeaeed4503b5dee84ff8d8", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 109, "deletions": 109, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -21,82 +21,82 @@ use back::svh::Svh;\n // 0xf0..0xff: internally used by RBML to encode 0x100..0xfff in two bytes\n // 0x100..0xfff: free for use, preferred for infrequent tags\n \n-pub const tag_items: uint = 0x100; // top-level only\n+pub const tag_items: usize = 0x100; // top-level only\n \n-pub const tag_paths_data_name: uint = 0x20;\n+pub const tag_paths_data_name: usize = 0x20;\n \n-pub const tag_def_id: uint = 0x21;\n+pub const tag_def_id: usize = 0x21;\n \n-pub const tag_items_data: uint = 0x22;\n+pub const tag_items_data: usize = 0x22;\n \n-pub const tag_items_data_item: uint = 0x23;\n+pub const tag_items_data_item: usize = 0x23;\n \n-pub const tag_items_data_item_family: uint = 0x24;\n+pub const tag_items_data_item_family: usize = 0x24;\n \n-pub const tag_items_data_item_type: uint = 0x25;\n+pub const tag_items_data_item_type: usize = 0x25;\n \n-pub const tag_items_data_item_symbol: uint = 0x26;\n+pub const tag_items_data_item_symbol: usize = 0x26;\n \n-pub const tag_items_data_item_variant: uint = 0x27;\n+pub const tag_items_data_item_variant: usize = 0x27;\n \n-pub const tag_items_data_parent_item: uint = 0x28;\n+pub const tag_items_data_parent_item: usize = 0x28;\n \n-pub const tag_items_data_item_is_tuple_struct_ctor: uint = 0x29;\n+pub const tag_items_data_item_is_tuple_struct_ctor: usize = 0x29;\n \n-pub const tag_index: uint = 0x2a;\n+pub const tag_index: usize = 0x2a;\n \n-pub const tag_index_buckets: uint = 0x2b;\n+pub const tag_index_buckets: usize = 0x2b;\n \n-pub const tag_index_buckets_bucket: uint = 0x2c;\n+pub const tag_index_buckets_bucket: usize = 0x2c;\n \n-pub const tag_index_buckets_bucket_elt: uint = 0x2d;\n+pub const tag_index_buckets_bucket_elt: usize = 0x2d;\n \n-pub const tag_index_table: uint = 0x2e;\n+pub const tag_index_table: usize = 0x2e;\n \n-pub const tag_meta_item_name_value: uint = 0x2f;\n+pub const tag_meta_item_name_value: usize = 0x2f;\n \n-pub const tag_meta_item_name: uint = 0x30;\n+pub const tag_meta_item_name: usize = 0x30;\n \n-pub const tag_meta_item_value: uint = 0x31;\n+pub const tag_meta_item_value: usize = 0x31;\n \n-pub const tag_attributes: uint = 0x101; // top-level only\n+pub const tag_attributes: usize = 0x101; // top-level only\n \n-pub const tag_attribute: uint = 0x32;\n+pub const tag_attribute: usize = 0x32;\n \n-pub const tag_meta_item_word: uint = 0x33;\n+pub const tag_meta_item_word: usize = 0x33;\n \n-pub const tag_meta_item_list: uint = 0x34;\n+pub const tag_meta_item_list: usize = 0x34;\n \n // The list of crates that this crate depends on\n-pub const tag_crate_deps: uint = 0x102; // top-level only\n+pub const tag_crate_deps: usize = 0x102; // top-level only\n \n // A single crate dependency\n-pub const tag_crate_dep: uint = 0x35;\n+pub const tag_crate_dep: usize = 0x35;\n \n-pub const tag_crate_hash: uint = 0x103; // top-level only\n-pub const tag_crate_crate_name: uint = 0x104; // top-level only\n+pub const tag_crate_hash: usize = 0x103; // top-level only\n+pub const tag_crate_crate_name: usize = 0x104; // top-level only\n \n-pub const tag_crate_dep_crate_name: uint = 0x36;\n-pub const tag_crate_dep_hash: uint = 0x37;\n+pub const tag_crate_dep_crate_name: usize = 0x36;\n+pub const tag_crate_dep_hash: usize = 0x37;\n \n-pub const tag_mod_impl: uint = 0x38;\n+pub const tag_mod_impl: usize = 0x38;\n \n-pub const tag_item_trait_item: uint = 0x39;\n+pub const tag_item_trait_item: usize = 0x39;\n \n-pub const tag_item_trait_ref: uint = 0x3a;\n+pub const tag_item_trait_ref: usize = 0x3a;\n \n // discriminator value for variants\n-pub const tag_disr_val: uint = 0x3c;\n+pub const tag_disr_val: usize = 0x3c;\n \n // used to encode ast_map::PathElem\n-pub const tag_path: uint = 0x3d;\n-pub const tag_path_len: uint = 0x3e;\n-pub const tag_path_elem_mod: uint = 0x3f;\n-pub const tag_path_elem_name: uint = 0x40;\n-pub const tag_item_field: uint = 0x41;\n-pub const tag_item_field_origin: uint = 0x42;\n-\n-pub const tag_item_variances: uint = 0x43;\n+pub const tag_path: usize = 0x3d;\n+pub const tag_path_len: usize = 0x3e;\n+pub const tag_path_elem_mod: usize = 0x3f;\n+pub const tag_path_elem_name: usize = 0x40;\n+pub const tag_item_field: usize = 0x41;\n+pub const tag_item_field_origin: usize = 0x42;\n+\n+pub const tag_item_variances: usize = 0x43;\n /*\n   trait items contain tag_item_trait_item elements,\n   impl items contain tag_item_impl_item elements, and classes\n@@ -105,19 +105,19 @@ pub const tag_item_variances: uint = 0x43;\n   both, tag_item_trait_item and tag_item_impl_item have to be two\n   different tags.\n  */\n-pub const tag_item_impl_item: uint = 0x44;\n-pub const tag_item_trait_method_explicit_self: uint = 0x45;\n+pub const tag_item_impl_item: usize = 0x44;\n+pub const tag_item_trait_method_explicit_self: usize = 0x45;\n \n \n // Reexports are found within module tags. Each reexport contains def_ids\n // and names.\n-pub const tag_items_data_item_reexport: uint = 0x46;\n-pub const tag_items_data_item_reexport_def_id: uint = 0x47;\n-pub const tag_items_data_item_reexport_name: uint = 0x48;\n+pub const tag_items_data_item_reexport: usize = 0x46;\n+pub const tag_items_data_item_reexport_def_id: usize = 0x47;\n+pub const tag_items_data_item_reexport_name: usize = 0x48;\n \n // used to encode crate_ctxt side tables\n #[derive(Copy, PartialEq, FromPrimitive)]\n-#[repr(uint)]\n+#[repr(usize)]\n pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_ast = 0x50,\n \n@@ -149,15 +149,15 @@ pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_const_qualif = 0x69,\n }\n \n-pub const tag_item_trait_item_sort: uint = 0x70;\n+pub const tag_item_trait_item_sort: usize = 0x70;\n \n-pub const tag_item_trait_parent_sort: uint = 0x71;\n+pub const tag_item_trait_parent_sort: usize = 0x71;\n \n-pub const tag_item_impl_type_basename: uint = 0x72;\n+pub const tag_item_impl_type_basename: usize = 0x72;\n \n-pub const tag_crate_triple: uint = 0x105; // top-level only\n+pub const tag_crate_triple: usize = 0x105; // top-level only\n \n-pub const tag_dylib_dependency_formats: uint = 0x106; // top-level only\n+pub const tag_dylib_dependency_formats: usize = 0x106; // top-level only\n \n // Language items are a top-level directory (for speed). Hierarchy:\n //\n@@ -166,93 +166,93 @@ pub const tag_dylib_dependency_formats: uint = 0x106; // top-level only\n //   - tag_lang_items_item_id: u32\n //   - tag_lang_items_item_node_id: u32\n \n-pub const tag_lang_items: uint = 0x107; // top-level only\n-pub const tag_lang_items_item: uint = 0x73;\n-pub const tag_lang_items_item_id: uint = 0x74;\n-pub const tag_lang_items_item_node_id: uint = 0x75;\n-pub const tag_lang_items_missing: uint = 0x76;\n+pub const tag_lang_items: usize = 0x107; // top-level only\n+pub const tag_lang_items_item: usize = 0x73;\n+pub const tag_lang_items_item_id: usize = 0x74;\n+pub const tag_lang_items_item_node_id: usize = 0x75;\n+pub const tag_lang_items_missing: usize = 0x76;\n \n-pub const tag_item_unnamed_field: uint = 0x77;\n-pub const tag_items_data_item_visibility: uint = 0x78;\n+pub const tag_item_unnamed_field: usize = 0x77;\n+pub const tag_items_data_item_visibility: usize = 0x78;\n \n-pub const tag_item_method_tps: uint = 0x79;\n-pub const tag_item_method_fty: uint = 0x7a;\n+pub const tag_item_method_tps: usize = 0x79;\n+pub const tag_item_method_fty: usize = 0x7a;\n \n-pub const tag_mod_child: uint = 0x7b;\n-pub const tag_misc_info: uint = 0x108; // top-level only\n-pub const tag_misc_info_crate_items: uint = 0x7c;\n+pub const tag_mod_child: usize = 0x7b;\n+pub const tag_misc_info: usize = 0x108; // top-level only\n+pub const tag_misc_info_crate_items: usize = 0x7c;\n \n-pub const tag_item_method_provided_source: uint = 0x7d;\n-pub const tag_item_impl_vtables: uint = 0x7e;\n+pub const tag_item_method_provided_source: usize = 0x7d;\n+pub const tag_item_impl_vtables: usize = 0x7e;\n \n-pub const tag_impls: uint = 0x109; // top-level only\n-pub const tag_impls_impl: uint = 0x7f;\n+pub const tag_impls: usize = 0x109; // top-level only\n+pub const tag_impls_impl: usize = 0x7f;\n \n-pub const tag_items_data_item_inherent_impl: uint = 0x80;\n-pub const tag_items_data_item_extension_impl: uint = 0x81;\n+pub const tag_items_data_item_inherent_impl: usize = 0x80;\n+pub const tag_items_data_item_extension_impl: usize = 0x81;\n \n-pub const tag_native_libraries: uint = 0x10a; // top-level only\n-pub const tag_native_libraries_lib: uint = 0x82;\n-pub const tag_native_libraries_name: uint = 0x83;\n-pub const tag_native_libraries_kind: uint = 0x84;\n+pub const tag_native_libraries: usize = 0x10a; // top-level only\n+pub const tag_native_libraries_lib: usize = 0x82;\n+pub const tag_native_libraries_name: usize = 0x83;\n+pub const tag_native_libraries_kind: usize = 0x84;\n \n-pub const tag_plugin_registrar_fn: uint = 0x10b; // top-level only\n+pub const tag_plugin_registrar_fn: usize = 0x10b; // top-level only\n \n-pub const tag_method_argument_names: uint = 0x85;\n-pub const tag_method_argument_name: uint = 0x86;\n+pub const tag_method_argument_names: usize = 0x85;\n+pub const tag_method_argument_name: usize = 0x86;\n \n-pub const tag_reachable_extern_fns: uint = 0x10c; // top-level only\n-pub const tag_reachable_extern_fn_id: uint = 0x87;\n+pub const tag_reachable_extern_fns: usize = 0x10c; // top-level only\n+pub const tag_reachable_extern_fn_id: usize = 0x87;\n \n-pub const tag_items_data_item_stability: uint = 0x88;\n+pub const tag_items_data_item_stability: usize = 0x88;\n \n-pub const tag_items_data_item_repr: uint = 0x89;\n+pub const tag_items_data_item_repr: usize = 0x89;\n \n #[derive(Clone, Debug)]\n pub struct LinkMeta {\n     pub crate_name: String,\n     pub crate_hash: Svh,\n }\n \n-pub const tag_struct_fields: uint = 0x10d; // top-level only\n-pub const tag_struct_field: uint = 0x8a;\n-pub const tag_struct_field_id: uint = 0x8b;\n+pub const tag_struct_fields: usize = 0x10d; // top-level only\n+pub const tag_struct_field: usize = 0x8a;\n+pub const tag_struct_field_id: usize = 0x8b;\n \n-pub const tag_attribute_is_sugared_doc: uint = 0x8c;\n+pub const tag_attribute_is_sugared_doc: usize = 0x8c;\n \n-pub const tag_items_data_region: uint = 0x8e;\n+pub const tag_items_data_region: usize = 0x8e;\n \n-pub const tag_region_param_def: uint = 0x8f;\n-pub const tag_region_param_def_ident: uint = 0x90;\n-pub const tag_region_param_def_def_id: uint = 0x91;\n-pub const tag_region_param_def_space: uint = 0x92;\n-pub const tag_region_param_def_index: uint = 0x93;\n+pub const tag_region_param_def: usize = 0x8f;\n+pub const tag_region_param_def_ident: usize = 0x90;\n+pub const tag_region_param_def_def_id: usize = 0x91;\n+pub const tag_region_param_def_space: usize = 0x92;\n+pub const tag_region_param_def_index: usize = 0x93;\n \n-pub const tag_type_param_def: uint = 0x94;\n+pub const tag_type_param_def: usize = 0x94;\n \n-pub const tag_item_generics: uint = 0x95;\n-pub const tag_method_ty_generics: uint = 0x96;\n+pub const tag_item_generics: usize = 0x95;\n+pub const tag_method_ty_generics: usize = 0x96;\n \n-pub const tag_predicate: uint = 0x97;\n-pub const tag_predicate_space: uint = 0x98;\n-pub const tag_predicate_data: uint = 0x99;\n+pub const tag_predicate: usize = 0x97;\n+pub const tag_predicate_space: usize = 0x98;\n+pub const tag_predicate_data: usize = 0x99;\n \n-pub const tag_unsafety: uint = 0x9a;\n+pub const tag_unsafety: usize = 0x9a;\n \n-pub const tag_associated_type_names: uint = 0x9b;\n-pub const tag_associated_type_name: uint = 0x9c;\n+pub const tag_associated_type_names: usize = 0x9b;\n+pub const tag_associated_type_name: usize = 0x9c;\n \n-pub const tag_polarity: uint = 0x9d;\n+pub const tag_polarity: usize = 0x9d;\n \n-pub const tag_macro_defs: uint = 0x10e; // top-level only\n-pub const tag_macro_def: uint = 0x9e;\n-pub const tag_macro_def_body: uint = 0x9f;\n+pub const tag_macro_defs: usize = 0x10e; // top-level only\n+pub const tag_macro_def: usize = 0x9e;\n+pub const tag_macro_def_body: usize = 0x9f;\n \n-pub const tag_paren_sugar: uint = 0xa0;\n+pub const tag_paren_sugar: usize = 0xa0;\n \n-pub const tag_codemap: uint = 0xa1;\n-pub const tag_codemap_filemap: uint = 0xa2;\n+pub const tag_codemap: usize = 0xa1;\n+pub const tag_codemap_filemap: usize = 0xa2;\n \n-pub const tag_item_super_predicates: uint = 0xa3;\n+pub const tag_item_super_predicates: usize = 0xa3;\n \n-pub const tag_defaulted_trait: uint = 0xa4;\n+pub const tag_defaulted_trait: usize = 0xa4;"}, {"sha": "b6a8525675e456c64afad6b7c8ee895eebb3d948", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -73,24 +73,20 @@ struct CrateInfo {\n }\n \n pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n-    let say = |s: &str, warn: bool| {\n+    let say = |s: &str| {\n         match (sp, sess) {\n             (_, None) => panic!(\"{}\", s),\n-            (Some(sp), Some(sess)) if warn => sess.span_warn(sp, s),\n             (Some(sp), Some(sess)) => sess.span_err(sp, s),\n-            (None, Some(sess)) if warn => sess.warn(s),\n             (None, Some(sess)) => sess.err(s),\n         }\n     };\n     if s.len() == 0 {\n-        say(\"crate name must not be empty\", false);\n-    } else if s.contains(\"-\") {\n-        say(&format!(\"crate names soon cannot contain hyphens: {}\", s), true);\n+        say(\"crate name must not be empty\");\n     }\n     for c in s.chars() {\n         if c.is_alphanumeric() { continue }\n-        if c == '_' || c == '-' { continue }\n-        say(&format!(\"invalid character `{}` in crate name: `{}`\", c, s), false);\n+        if c == '_'  { continue }\n+        say(&format!(\"invalid character `{}` in crate name: `{}`\", c, s));\n     }\n     match sess {\n         Some(sess) => sess.abort_if_errors(),\n@@ -306,13 +302,7 @@ impl<'a> CrateReader<'a> {\n                       -> Option<ast::CrateNum> {\n         let mut ret = None;\n         self.sess.cstore.iter_crate_data(|cnum, data| {\n-            // For now we do a \"fuzzy match\" on crate names by considering\n-            // hyphens equal to underscores. This is purely meant to be a\n-            // transitionary feature while we deprecate the quote syntax of\n-            // `extern crate` statements.\n-            if data.name != name.replace(\"-\", \"_\") {\n-                return\n-            }\n+            if data.name != name { return }\n \n             match hash {\n                 Some(hash) if *hash == data.hash() => { ret = Some(cnum); return }"}, {"sha": "ebc3a6fd52c939b0afaf4b9004970f9450314bd5", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -46,7 +46,7 @@ pub fn each_lang_item<F>(cstore: &cstore::CStore,\n                          cnum: ast::CrateNum,\n                          f: F)\n                          -> bool where\n-    F: FnMut(ast::NodeId, uint) -> bool,\n+    F: FnMut(ast::NodeId, usize) -> bool,\n {\n     let crate_data = cstore.get_crate_data(cnum);\n     decoder::each_lang_item(&*crate_data, f)"}, {"sha": "811aa21a0b7b986ce8888cf73b83ad0ed2a25184", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -252,7 +252,7 @@ impl MetadataBlob {\n             let len = (((slice[0] as u32) << 24) |\n                        ((slice[1] as u32) << 16) |\n                        ((slice[2] as u32) << 8) |\n-                       ((slice[3] as u32) << 0)) as uint;\n+                       ((slice[3] as u32) << 0)) as usize;\n             if len + 4 <= slice.len() {\n                 &slice[4.. len + 4]\n             } else {"}, {"sha": "fc0b8543ea60c588ff6332ca82f1646300bc07cf", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -71,15 +71,15 @@ fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml:\n {\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n-    let hash_pos = table.start + (hash % 256 * 4) as uint;\n-    let pos = u32_from_be_bytes(&d.data[hash_pos..]) as uint;\n+    let hash_pos = table.start + (hash % 256 * 4) as usize;\n+    let pos = u32_from_be_bytes(&d.data[hash_pos..]) as usize;\n     let tagged_doc = reader::doc_at(d.data, pos).unwrap();\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n-        let pos = u32_from_be_bytes(&elt.data[elt.start..]) as uint;\n+        let pos = u32_from_be_bytes(&elt.data[elt.start..]) as usize;\n         if eq_fn(&elt.data[elt.start + 4 .. elt.end]) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n@@ -274,7 +274,7 @@ fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n     let path_doc = reader::get_doc(item_doc, tag_path);\n \n     let len_doc = reader::get_doc(path_doc, tag_path_len);\n-    let len = reader::doc_as_u32(len_doc) as uint;\n+    let len = reader::doc_as_u32(len_doc) as usize;\n \n     let mut result = Vec::with_capacity(len);\n     reader::docs(path_doc, |tag, elt_doc| {\n@@ -513,13 +513,13 @@ pub enum DefLike {\n \n /// Iterates over the language items in the given crate.\n pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n-    F: FnMut(ast::NodeId, uint) -> bool,\n+    F: FnMut(ast::NodeId, usize) -> bool,\n {\n     let root = rbml::Doc::new(cdata.data());\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     reader::tagged_docs(lang_items, tag_lang_items_item, |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n-        let id = reader::doc_as_u32(id_doc) as uint;\n+        let id = reader::doc_as_u32(id_doc) as usize;\n         let node_id_doc = reader::get_doc(item_doc,\n                                           tag_lang_items_item_node_id);\n         let node_id = reader::doc_as_u32(node_id_doc) as ast::NodeId;\n@@ -1194,7 +1194,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     let cratedoc = rbml::Doc::new(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: rbml::Doc, tag_: uint) -> String {\n+    fn docstr(doc: rbml::Doc, tag_: usize) -> String {\n         let d = reader::get_doc(doc, tag_);\n         d.as_str_slice().to_string()\n     }\n@@ -1454,7 +1454,7 @@ pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n fn doc_generics<'tcx>(base_doc: rbml::Doc,\n                       tcx: &ty::ctxt<'tcx>,\n                       cdata: Cmd,\n-                      tag: uint)\n+                      tag: usize)\n                       -> ty::Generics<'tcx>\n {\n     let doc = reader::get_doc(base_doc, tag);\n@@ -1479,7 +1479,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         let def_id = translate_def_id(cdata, def_id);\n \n         let doc = reader::get_doc(rp_doc, tag_region_param_def_space);\n-        let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as uint);\n+        let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as usize);\n \n         let doc = reader::get_doc(rp_doc, tag_region_param_def_index);\n         let index = reader::doc_as_u64(doc) as u32;\n@@ -1508,15 +1508,15 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n                         tcx: &ty::ctxt<'tcx>,\n                         cdata: Cmd,\n-                        tag: uint)\n+                        tag: usize)\n                         -> ty::GenericPredicates<'tcx>\n {\n     let doc = reader::get_doc(base_doc, tag);\n \n     let mut predicates = subst::VecPerParamSpace::empty();\n     reader::tagged_docs(doc, tag_predicate, |predicate_doc| {\n         let space_doc = reader::get_doc(predicate_doc, tag_predicate_space);\n-        let space = subst::ParamSpace::from_uint(reader::doc_as_u8(space_doc) as uint);\n+        let space = subst::ParamSpace::from_uint(reader::doc_as_u8(space_doc) as usize);\n \n         let data_doc = reader::get_doc(predicate_doc, tag_predicate_data);\n         let data = parse_predicate_data(data_doc.data, data_doc.start, cdata.cnum, tcx,"}, {"sha": "d5e8e152ee94998a4a2bfe29bc09928bdccb3520", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -105,7 +105,7 @@ struct entry<T> {\n fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a, 'tcx>,\n                               trait_ref: &ty::TraitRef<'tcx>,\n-                              tag: uint) {\n+                              tag: usize) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n@@ -703,7 +703,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n                              ecx: &EncodeContext<'a, 'tcx>,\n                              generics: &ty::Generics<'tcx>,\n                              predicates: &ty::GenericPredicates<'tcx>,\n-                             tag: uint)\n+                             tag: usize)\n {\n     rbml_w.start_tag(tag);\n \n@@ -777,7 +777,7 @@ fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a,'tcx>,\n                               predicates: &ty::GenericPredicates<'tcx>,\n-                              tag: uint)\n+                              tag: usize)\n {\n     rbml_w.start_tag(tag);\n     encode_predicates_in_current_doc(rbml_w, ecx, predicates);\n@@ -1538,7 +1538,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     for elt in index {\n         let mut s = SipHasher::new();\n         elt.val.hash(&mut s);\n-        let h = s.finish() as uint;\n+        let h = s.finish() as usize;\n         (&mut buckets[h % 256]).push(elt);\n     }\n \n@@ -1944,7 +1944,7 @@ pub fn encode_metadata(parms: EncodeParams, krate: &ast::Crate) -> Vec<u8> {\n \n     // RBML compacts the encoded bytes whenever appropriate,\n     // so there are some garbages left after the end of the data.\n-    let metalen = wr.seek(SeekFrom::Current(0)).unwrap() as uint;\n+    let metalen = wr.seek(SeekFrom::Current(0)).unwrap() as usize;\n     let mut v = wr.into_inner();\n     v.truncate(metalen);\n     assert_eq!(v.len(), metalen);"}, {"sha": "d83b05cbeb034e53c3b4383b02302394896a8ad3", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -745,7 +745,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n     unsafe {\n         let buf = common::path2cstr(filename);\n         let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n-        if mb as int == 0 {\n+        if mb as isize == 0 {\n             return Err(format!(\"error reading library: '{}'\",\n                                filename.display()))\n         }\n@@ -761,12 +761,12 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n             let mut name_buf = ptr::null();\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n             let name = slice::from_raw_parts(name_buf as *const u8,\n-                                             name_len as uint).to_vec();\n+                                             name_len as usize).to_vec();\n             let name = String::from_utf8(name).unwrap();\n             debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(is_osx) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n-                let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n+                let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n                 let cvbuf: *const u8 = cbuf as *const u8;\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n@@ -779,7 +779,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n                                         filename.display())));\n                 }\n \n-                let cvbuf1 = cvbuf.offset(vlen as int);\n+                let cvbuf1 = cvbuf.offset(vlen as isize);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n                 let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);"}, {"sha": "c2d7911d151fbfb7f3a79e2e4d61776a4e851a59", "filename": "src/librustc/metadata/macro_import.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -79,15 +79,6 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n         for attr in &item.attrs {\n             let mut used = true;\n             match &attr.name()[..] {\n-                \"phase\" => {\n-                    self.sess.span_err(attr.span, \"#[phase] is deprecated\");\n-                }\n-                \"plugin\" => {\n-                    self.sess.span_err(attr.span, \"#[plugin] on `extern crate` is deprecated\");\n-                    self.sess.fileline_help(attr.span, &format!(\"use a crate attribute instead, \\\n-                                                            i.e. #![plugin({})]\",\n-                                                            item.ident.as_str()));\n-                }\n                 \"macro_use\" => {\n                     let names = attr.meta_item_list();\n                     if names.is_none() {"}, {"sha": "e2eebbfdc724d255056aad3cb6ba03d08a39e7c9", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -66,7 +66,7 @@ pub enum DefIdSource {\n pub struct PState<'a, 'tcx: 'a> {\n     data: &'a [u8],\n     krate: ast::CrateNum,\n-    pos: uint,\n+    pos: usize,\n     tcx: &'a ty::ctxt<'tcx>\n }\n \n@@ -119,7 +119,7 @@ fn parse_name_<F>(st: &mut PState, is_last: F) -> ast::Name where\n }\n \n pub fn parse_state_from_data<'a, 'tcx>(data: &'a [u8], crate_num: ast::CrateNum,\n-                                       pos: uint, tcx: &'a ty::ctxt<'tcx>)\n+                                       pos: usize, tcx: &'a ty::ctxt<'tcx>)\n                                        -> PState<'a, 'tcx> {\n     PState {\n         data: data,\n@@ -129,7 +129,7 @@ pub fn parse_state_from_data<'a, 'tcx>(data: &'a [u8], crate_num: ast::CrateNum,\n     }\n }\n \n-fn data_log_string(data: &[u8], pos: uint) -> String {\n+fn data_log_string(data: &[u8], pos: usize) -> String {\n     let mut buf = String::new();\n     buf.push_str(\"<<\");\n     for i in pos..data.len() {\n@@ -146,7 +146,7 @@ fn data_log_string(data: &[u8], pos: uint) -> String {\n \n pub fn parse_ty_closure_data<'tcx, F>(data: &[u8],\n                                       crate_num: ast::CrateNum,\n-                                      pos: uint,\n+                                      pos: usize,\n                                       tcx: &ty::ctxt<'tcx>,\n                                       conv: F)\n                                       -> ty::ClosureTy<'tcx> where\n@@ -156,7 +156,7 @@ pub fn parse_ty_closure_data<'tcx, F>(data: &[u8],\n     parse_closure_ty(&mut st, conv)\n }\n \n-pub fn parse_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+pub fn parse_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n                               tcx: &ty::ctxt<'tcx>, conv: F) -> Ty<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n@@ -165,7 +165,7 @@ pub fn parse_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n     parse_ty(&mut st, conv)\n }\n \n-pub fn parse_region_data<F>(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n+pub fn parse_region_data<F>(data: &[u8], crate_num: ast::CrateNum, pos: usize, tcx: &ty::ctxt,\n                             conv: F) -> ty::Region where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n@@ -174,7 +174,7 @@ pub fn parse_region_data<F>(data: &[u8], crate_num: ast::CrateNum, pos: uint, tc\n     parse_region(&mut st, conv)\n }\n \n-pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n                                       tcx: &ty::ctxt<'tcx>, conv: F)\n                                       -> ty::BareFnTy<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n@@ -184,7 +184,7 @@ pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos\n     parse_bare_fn_ty(&mut st, conv)\n }\n \n-pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n                                      tcx: &ty::ctxt<'tcx>, conv: F)\n                                      -> Rc<ty::TraitRef<'tcx>> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n@@ -194,7 +194,7 @@ pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos:\n     parse_trait_ref(&mut st, conv)\n }\n \n-pub fn parse_substs_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+pub fn parse_substs_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n                                   tcx: &ty::ctxt<'tcx>, conv: F) -> subst::Substs<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n@@ -204,7 +204,7 @@ pub fn parse_substs_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: ui\n }\n \n pub fn parse_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum,\n-                                  pos: uint, tcx: &ty::ctxt<'tcx>, conv: F)\n+                                  pos: usize, tcx: &ty::ctxt<'tcx>, conv: F)\n                                   -> ty::ParamBounds<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n@@ -213,7 +213,7 @@ pub fn parse_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum,\n }\n \n pub fn parse_existential_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum,\n-                                              pos: uint, tcx: &ty::ctxt<'tcx>, conv: F)\n+                                              pos: usize, tcx: &ty::ctxt<'tcx>, conv: F)\n                                               -> ty::ExistentialBounds<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n@@ -222,15 +222,15 @@ pub fn parse_existential_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::Crate\n }\n \n pub fn parse_builtin_bounds_data<F>(data: &[u8], crate_num: ast::CrateNum,\n-                                    pos: uint, tcx: &ty::ctxt, conv: F)\n+                                    pos: usize, tcx: &ty::ctxt, conv: F)\n                                     -> ty::BuiltinBounds where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_builtin_bounds(&mut st, conv)\n }\n \n-fn parse_size(st: &mut PState) -> Option<uint> {\n+fn parse_size(st: &mut PState) -> Option<usize> {\n     assert_eq!(next(st), '/');\n \n     if peek(st) == '|' {\n@@ -447,8 +447,8 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n     let tcx = st.tcx;\n     match next(st) {\n       'b' => return tcx.types.bool,\n-      'i' => { /* eat the s of is */ next(st); return tcx.types.int },\n-      'u' => { /* eat the s of us */ next(st); return tcx.types.uint },\n+      'i' => { /* eat the s of is */ next(st); return tcx.types.isize },\n+      'u' => { /* eat the s of us */ next(st); return tcx.types.usize },\n       'M' => {\n         match next(st) {\n           'b' => return tcx.types.u8,\n@@ -592,38 +592,38 @@ fn parse_def_<F>(st: &mut PState, source: DefIdSource, conv: &mut F) -> ast::Def\n     return (*conv)(source, scan(st, |c| { c == '|' }, parse_def_id));\n }\n \n-fn parse_uint(st: &mut PState) -> uint {\n+fn parse_uint(st: &mut PState) -> usize {\n     let mut n = 0;\n     loop {\n         let cur = peek(st);\n         if cur < '0' || cur > '9' { return n; }\n         st.pos = st.pos + 1;\n         n *= 10;\n-        n += (cur as uint) - ('0' as uint);\n+        n += (cur as usize) - ('0' as usize);\n     };\n }\n \n fn parse_u32(st: &mut PState) -> u32 {\n     let n = parse_uint(st);\n     let m = n as u32;\n-    assert_eq!(m as uint, n);\n+    assert_eq!(m as usize, n);\n     m\n }\n \n fn parse_param_space(st: &mut PState) -> subst::ParamSpace {\n     subst::ParamSpace::from_uint(parse_uint(st))\n }\n \n-fn parse_hex(st: &mut PState) -> uint {\n+fn parse_hex(st: &mut PState) -> usize {\n     let mut n = 0;\n     loop {\n         let cur = peek(st);\n         if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { return n; }\n         st.pos = st.pos + 1;\n         n *= 16;\n         if '0' <= cur && cur <= '9' {\n-            n += (cur as uint) - ('0' as uint);\n-        } else { n += 10 + (cur as uint) - ('a' as uint); }\n+            n += (cur as usize) - ('0' as usize);\n+        } else { n += 10 + (cur as usize) - ('a' as usize); }\n     };\n }\n \n@@ -725,14 +725,14 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let def_part = &buf[colon_idx + 1..len];\n \n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| {\n-        s.parse::<uint>().ok()\n+        s.parse::<usize>().ok()\n     }) {\n        Some(cn) => cn as ast::CrateNum,\n        None => panic!(\"internal error: parse_def_id: crate number expected, found {:?}\",\n                      crate_part)\n     };\n     let def_num = match str::from_utf8(def_part).ok().and_then(|s| {\n-        s.parse::<uint>().ok()\n+        s.parse::<usize>().ok()\n     }) {\n        Some(dn) => dn as ast::NodeId,\n        None => panic!(\"internal error: parse_def_id: id expected, found {:?}\",\n@@ -742,7 +742,7 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n }\n \n pub fn parse_predicate_data<'tcx, F>(data: &[u8],\n-                                     start: uint,\n+                                     start: usize,\n                                      crate_num: ast::CrateNum,\n                                      tcx: &ty::ctxt<'tcx>,\n                                      conv: F)\n@@ -794,7 +794,7 @@ fn parse_projection_predicate_<'a,'tcx, F>(\n     }\n }\n \n-pub fn parse_type_param_def_data<'tcx, F>(data: &[u8], start: uint,\n+pub fn parse_type_param_def_data<'tcx, F>(data: &[u8], start: usize,\n                                           crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n                                           conv: F) -> ty::TypeParameterDef<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,"}, {"sha": "7a2df4966283a6d7339d3040e2e312fa927a32c5", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -64,7 +64,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n         ty::ty_char => mywrite!(w, \"c\"),\n         ty::ty_int(t) => {\n             match t {\n-                ast::TyIs(_) => mywrite!(w, \"is\"),\n+                ast::TyIs => mywrite!(w, \"is\"),\n                 ast::TyI8 => mywrite!(w, \"MB\"),\n                 ast::TyI16 => mywrite!(w, \"MW\"),\n                 ast::TyI32 => mywrite!(w, \"ML\"),\n@@ -73,7 +73,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n         }\n         ty::ty_uint(t) => {\n             match t {\n-                ast::TyUs(_) => mywrite!(w, \"us\"),\n+                ast::TyUs => mywrite!(w, \"us\"),\n                 ast::TyU8 => mywrite!(w, \"Mb\"),\n                 ast::TyU16 => mywrite!(w, \"Mw\"),\n                 ast::TyU32 => mywrite!(w, \"Ml\"),"}, {"sha": "698cf105ae53c12d6b1a5d4dabec5175f1dc6c63", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -19,10 +19,10 @@ use middle::ty::{self, Ty};\n use syntax::ast;\n use util::ppaux::Repr;\n \n-pub const NO_REGIONS: uint = 1;\n-pub const NO_TPS: uint = 2;\n+pub const NO_REGIONS: usize = 1;\n+pub const NO_TPS: usize = 2;\n \n-pub fn check_path_args(tcx: &ty::ctxt, segments: &[ast::PathSegment], flags: uint) {\n+pub fn check_path_args(tcx: &ty::ctxt, segments: &[ast::PathSegment], flags: usize) {\n     for segment in segments {\n         if (flags & NO_TPS) != 0 {\n             for typ in segment.parameters.types() {"}, {"sha": "0b8469eda39c5c146560bf7435878dd99d6979c8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -93,7 +93,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     let ii = simplify_ast(ii);\n     let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n \n-    rbml_w.start_tag(c::tag_ast as uint);\n+    rbml_w.start_tag(c::tag_ast as usize);\n     id_range.encode(rbml_w);\n     encode_ast(rbml_w, &ii);\n     encode_side_tables_for_ii(ecx, rbml_w, &ii);\n@@ -360,7 +360,7 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D\n // but eventually we should add entries to the local codemap as required.\n \n fn encode_ast(rbml_w: &mut Encoder, item: &ast::InlinedItem) {\n-    rbml_w.start_tag(c::tag_tree as uint);\n+    rbml_w.start_tag(c::tag_tree as usize);\n     item.encode(rbml_w);\n     rbml_w.end_tag();\n }\n@@ -437,7 +437,7 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n }\n \n fn decode_ast(par_doc: rbml::Doc) -> ast::InlinedItem {\n-    let chi_doc = par_doc.get(c::tag_tree as uint);\n+    let chi_doc = par_doc.get(c::tag_tree as usize);\n     let mut d = reader::Decoder::new(chi_doc);\n     Decodable::decode(&mut d).unwrap()\n }\n@@ -1150,7 +1150,7 @@ impl<'a> write_tag_and_id for Encoder<'a> {\n               f: F) where\n         F: FnOnce(&mut Encoder<'a>),\n     {\n-        self.start_tag(tag_id as uint);\n+        self.start_tag(tag_id as usize);\n         f(self);\n         self.end_tag();\n     }\n@@ -1175,7 +1175,7 @@ impl<'a, 'b, 'c, 'tcx> ast_util::IdVisitingOperation for\n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              rbml_w: &mut Encoder,\n                              ii: &ast::InlinedItem) {\n-    rbml_w.start_tag(c::tag_table as uint);\n+    rbml_w.start_tag(c::tag_table as usize);\n     ast_util::visit_ids_for_inlined_item(ii, &mut SideTableEncodingIdVisitor {\n         ecx: ecx,\n         rbml_w: rbml_w\n@@ -1323,14 +1323,14 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n }\n \n trait doc_decoder_helpers {\n-    fn as_int(&self) -> int;\n+    fn as_int(&self) -> isize;\n     fn opt_child(&self, tag: c::astencode_tag) -> Option<Self>;\n }\n \n impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n-    fn as_int(&self) -> int { reader::doc_as_u64(*self) as int }\n+    fn as_int(&self) -> isize { reader::doc_as_u64(*self) as isize }\n     fn opt_child(&self, tag: c::astencode_tag) -> Option<rbml::Doc<'a>> {\n-        reader::maybe_get_doc(*self, tag as uint)\n+        reader::maybe_get_doc(*self, tag as usize)\n     }\n }\n \n@@ -1746,7 +1746,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n-                        let len: uint =\n+                        let len: usize =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n                         ty::UnsizeLength(len)\n@@ -1755,7 +1755,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                         let uk: ty::UnsizeKind =\n                             this.read_enum_variant_arg(0,\n                                 |this| Ok(this.read_unsize_kind(dcx))).unwrap();\n-                        let idx: uint =\n+                        let idx: usize =\n                             this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n \n                         ty::UnsizeStruct(box uk, idx)\n@@ -1851,7 +1851,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n fn decode_side_tables(dcx: &DecodeContext,\n                       ast_doc: rbml::Doc) {\n-    let tbl_doc = ast_doc.get(c::tag_table as uint);\n+    let tbl_doc = ast_doc.get(c::tag_table as usize);\n     reader::docs(tbl_doc, |tag, entry_doc| {\n         let mut entry_dsr = reader::Decoder::new(entry_doc);\n         let id0: ast::NodeId = Decodable::decode(&mut entry_dsr).unwrap();\n@@ -1969,14 +1969,14 @@ fn decode_side_tables(dcx: &DecodeContext,\n \n #[cfg(test)]\n fn encode_item_ast(rbml_w: &mut Encoder, item: &ast::Item) {\n-    rbml_w.start_tag(c::tag_tree as uint);\n+    rbml_w.start_tag(c::tag_tree as usize);\n     (*item).encode(rbml_w);\n     rbml_w.end_tag();\n }\n \n #[cfg(test)]\n fn decode_item_ast(par_doc: rbml::Doc) -> ast::Item {\n-    let chi_doc = par_doc.get(c::tag_tree as uint);\n+    let chi_doc = par_doc.get(c::tag_tree as usize);\n     let mut d = reader::Decoder::new(chi_doc);\n     Decodable::decode(&mut d).unwrap()\n }\n@@ -2035,7 +2035,7 @@ fn test_basic() {\n fn test_smalltalk() {\n     let cx = mk_ctxt();\n     roundtrip(quote_item!(&cx,\n-        fn foo() -> int { 3 + 4 } // first smalltalk program ever executed.\n+        fn foo() -> isize { 3 + 4 } // first smalltalk program ever executed.\n     ));\n }\n */\n@@ -2044,7 +2044,7 @@ fn test_smalltalk() {\n fn test_more() {\n     let cx = mk_ctxt();\n     roundtrip(quote_item!(&cx,\n-        fn foo(x: uint, y: uint) -> uint {\n+        fn foo(x: usize, y: usize) -> usize {\n             let z = x + y;\n             return z;\n         }\n@@ -2055,15 +2055,15 @@ fn test_more() {\n fn test_simplification() {\n     let cx = mk_ctxt();\n     let item = quote_item!(&cx,\n-        fn new_int_alist<B>() -> alist<int, B> {\n-            fn eq_int(a: int, b: int) -> bool { a == b }\n+        fn new_int_alist<B>() -> alist<isize, B> {\n+            fn eq_int(a: isize, b: isize) -> bool { a == b }\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap();\n     let item_in = e::IIItemRef(&*item);\n     let item_out = simplify_ast(item_in);\n     let item_exp = ast::IIItem(quote_item!(&cx,\n-        fn new_int_alist<B>() -> alist<int, B> {\n+        fn new_int_alist<B>() -> alist<isize, B> {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap());"}, {"sha": "69da9c252c864e67cf39a1052d405aade6cd29da", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -72,7 +72,7 @@ impl<'a> fmt::Debug for Matrix<'a> {\n \n         let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n         assert!(m.iter().all(|row| row.len() == column_count));\n-        let column_widths: Vec<uint> = (0..column_count).map(|col| {\n+        let column_widths: Vec<usize> = (0..column_count).map(|col| {\n             pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0)\n         }).collect();\n \n@@ -116,9 +116,9 @@ pub enum Constructor {\n     /// Ranges of literal values (2..5).\n     ConstantRange(const_val, const_val),\n     /// Array patterns of length n.\n-    Slice(uint),\n+    Slice(usize),\n     /// Array patterns with a subslice.\n-    SliceWithSubslice(uint, uint)\n+    SliceWithSubslice(usize, usize)\n }\n \n #[derive(Clone, PartialEq)]\n@@ -498,7 +498,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n /// left_ty: tuple of 3 elements\n /// pats: [10, 20, _]           => (10, 20, _)\n ///\n-/// left_ty: struct X { a: (bool, &'static str), b: uint}\n+/// left_ty: struct X { a: (bool, &'static str), b: usize}\n /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n                      pats: Vec<&Pat>, left_ty: Ty) -> P<Pat> {\n@@ -580,7 +580,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n }\n \n fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n-                       left_ty: Ty, max_slice_length: uint) -> Option<Constructor> {\n+                       left_ty: Ty, max_slice_length: usize) -> Option<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n         .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length).into_iter())\n         .collect();\n@@ -594,7 +594,7 @@ fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n /// but is instead bounded by the maximum fixed length of slice patterns in\n /// the column of patterns being analyzed.\n fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n-                    max_slice_length: uint) -> Vec<Constructor> {\n+                    max_slice_length: usize) -> Vec<Constructor> {\n     match left_ty.sty {\n         ty::ty_bool =>\n             [true, false].iter().map(|b| ConstantValue(const_bool(*b))).collect(),\n@@ -741,7 +741,7 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n /// On the other hand, a wild pattern and an identifier pattern cannot be\n /// specialized in any way.\n fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n-                    left_ty: Ty, max_slice_length: uint) -> Vec<Constructor> {\n+                    left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n         ast::PatIdent(..) =>\n@@ -798,7 +798,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n ///\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> uint {\n+pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n     match ty.sty {\n         ty::ty_tup(ref fs) => fs.len(),\n         ty::ty_uniq(_) => 1,\n@@ -850,7 +850,7 @@ fn range_covered_by_constructor(ctor: &Constructor,\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n-                      constructor: &Constructor, col: uint, arity: uint) -> Option<Vec<&'a Pat>> {\n+                      constructor: &Constructor, col: usize, arity: usize) -> Option<Vec<&'a Pat>> {\n     let &Pat {\n         id: pat_id, ref node, span: pat_span\n     } = raw_pat(r[col]);"}, {"sha": "0d9e0d14def645ced90898ae7b5c300def44859e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -262,8 +262,8 @@ impl ConstEvalErr {\n             CannotCastTo(s) => format!(\"can't cast this type to {}\", s).into_cow(),\n             InvalidOpForBools(_) =>  \"can't do this op on bools\".into_cow(),\n             InvalidOpForFloats(_) => \"can't do this op on floats\".into_cow(),\n-            InvalidOpForIntUint(..) => \"can't do this op on an int and uint\".into_cow(),\n-            InvalidOpForUintInt(..) => \"can't do this op on a uint and int\".into_cow(),\n+            InvalidOpForIntUint(..) => \"can't do this op on an isize and usize\".into_cow(),\n+            InvalidOpForUintInt(..) => \"can't do this op on a usize and isize\".into_cow(),\n             NegateOnString => \"negate on string\".into_cow(),\n             NegateOnBoolean => \"negate on boolean\".into_cow(),\n             NegateOnBinary => \"negate on binary literal\".into_cow(),\n@@ -369,7 +369,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n       }\n       ast::ExprBinary(op, ref a, ref b) => {\n         let b_ty = match op.node {\n-            ast::BiShl | ast::BiShr => Some(tcx.types.uint),\n+            ast::BiShl | ast::BiShr => Some(tcx.types.usize),\n             _ => ety\n         };\n         match (try!(eval_const_expr_partial(tcx, &**a, ety)),\n@@ -396,7 +396,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     Some(&ty::ty_int(int_ty)) => int_ty,\n                     _ => return false\n                 };\n-                let int_ty = if let ast::TyIs(_) = int_ty {\n+                let int_ty = if let ast::TyIs = int_ty {\n                     tcx.sess.target.int_type\n                 } else {\n                     int_ty\n@@ -406,7 +406,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     ast::TyI16 =>  (a as i16) == i16::MIN,\n                     ast::TyI32 =>  (a as i32) == i32::MIN,\n                     ast::TyI64 =>  (a as i64) == i64::MIN,\n-                    ast::TyIs(_) => unreachable!()\n+                    ast::TyIs => unreachable!()\n                 }\n             };\n             match op.node {\n@@ -434,8 +434,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiAnd | ast::BiBitAnd => const_int(a & b),\n               ast::BiOr | ast::BiBitOr => const_int(a | b),\n               ast::BiBitXor => const_int(a ^ b),\n-              ast::BiShl => const_int(a << b as uint),\n-              ast::BiShr => const_int(a >> b as uint),\n+              ast::BiShl => const_int(a << b as usize),\n+              ast::BiShr => const_int(a >> b as usize),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -456,8 +456,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiAnd | ast::BiBitAnd => const_uint(a & b),\n               ast::BiOr | ast::BiBitOr => const_uint(a | b),\n               ast::BiBitXor => const_uint(a ^ b),\n-              ast::BiShl => const_uint(a << b as uint),\n-              ast::BiShr => const_uint(a >> b as uint),\n+              ast::BiShl => const_uint(a << b as usize),\n+              ast::BiShr => const_uint(a >> b as usize),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -469,15 +469,15 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           // shifts can have any integral type as their rhs\n           (const_int(a), const_uint(b)) => {\n             match op.node {\n-              ast::BiShl => const_int(a << b as uint),\n-              ast::BiShr => const_int(a >> b as uint),\n+              ast::BiShl => const_int(a << b as usize),\n+              ast::BiShr => const_int(a >> b as usize),\n               _ => signal!(e, InvalidOpForIntUint(op.node)),\n             }\n           }\n           (const_uint(a), const_int(b)) => {\n             match op.node {\n-              ast::BiShl => const_uint(a << b as uint),\n-              ast::BiShr => const_uint(a >> b as uint),\n+              ast::BiShl => const_uint(a << b as usize),\n+              ast::BiShr => const_uint(a >> b as usize),\n               _ => signal!(e, InvalidOpForUintInt(op.node)),\n             }\n           }\n@@ -628,12 +628,12 @@ fn cast_const(val: const_val, ty: Ty) -> Result<const_val, ErrKind> {\n     }\n \n     define_casts!{\n-        ty::ty_int(ast::TyIs(_)) => (int, const_int, i64),\n+        ty::ty_int(ast::TyIs) => (isize, const_int, i64),\n         ty::ty_int(ast::TyI8) => (i8, const_int, i64),\n         ty::ty_int(ast::TyI16) => (i16, const_int, i64),\n         ty::ty_int(ast::TyI32) => (i32, const_int, i64),\n         ty::ty_int(ast::TyI64) => (i64, const_int, i64),\n-        ty::ty_uint(ast::TyUs(_)) => (uint, const_uint, u64),\n+        ty::ty_uint(ast::TyUs) => (usize, const_uint, u64),\n         ty::ty_uint(ast::TyU8) => (u8, const_uint, u64),\n         ty::ty_uint(ast::TyU16) => (u16, const_uint, u64),\n         ty::ty_uint(ast::TyU32) => (u32, const_uint, u64),"}, {"sha": "a112ce6bd287c6053b6d2d82684ee8f9287321b0", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -45,11 +45,11 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n     oper: O,\n \n     /// number of bits to propagate per id\n-    bits_per_id: uint,\n+    bits_per_id: usize,\n \n     /// number of words we will use to store bits_per_id.\n     /// equal to bits_per_id/usize::BITS rounded up.\n-    words_per_id: uint,\n+    words_per_id: usize,\n \n     // mapping from node to cfg node index\n     // FIXME (#6298): Shouldn't this go with CFG?\n@@ -62,19 +62,19 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n     // the full vector (see the method `compute_id_range()`).\n \n     /// bits generated as we exit the cfg node. Updated by `add_gen()`.\n-    gens: Vec<uint>,\n+    gens: Vec<usize>,\n \n     /// bits killed as we exit the cfg node. Updated by `add_kill()`.\n-    kills: Vec<uint>,\n+    kills: Vec<usize>,\n \n     /// bits that are valid on entry to the cfg node. Updated by\n     /// `propagate()`.\n-    on_entry: Vec<uint>,\n+    on_entry: Vec<usize>,\n }\n \n pub trait BitwiseOperator {\n     /// Joins two predecessor bits together, typically either `|` or `&`\n-    fn join(&self, succ: uint, pred: uint) -> uint;\n+    fn join(&self, succ: usize, pred: usize) -> usize;\n }\n \n /// Parameterization for the precise form of data flow that is used.\n@@ -194,7 +194,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                cfg: &cfg::CFG,\n                oper: O,\n                id_range: IdRange,\n-               bits_per_id: uint) -> DataFlowContext<'a, 'tcx, O> {\n+               bits_per_id: usize) -> DataFlowContext<'a, 'tcx, O> {\n         let words_per_id = (bits_per_id + usize::BITS as usize - 1) / usize::BITS as usize;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n@@ -225,7 +225,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n     }\n \n-    pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {\n+    pub fn add_gen(&mut self, id: ast::NodeId, bit: usize) {\n         //! Indicates that `id` generates `bit`\n         debug!(\"{} add_gen(id={}, bit={})\",\n                self.analysis_name, id, bit);\n@@ -240,7 +240,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n     }\n \n-    pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n+    pub fn add_kill(&mut self, id: ast::NodeId, bit: usize) {\n         //! Indicates that `id` kills `bit`\n         debug!(\"{} add_kill(id={}, bit={})\",\n                self.analysis_name, id, bit);\n@@ -255,7 +255,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n     }\n \n-    fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n+    fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [usize]) {\n         //! Applies the gen and kill sets for `cfgidx` to `bits`\n         debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [before]\",\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n@@ -271,7 +271,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n     }\n \n-    fn compute_id_range(&self, cfgidx: CFGIndex) -> (uint, uint) {\n+    fn compute_id_range(&self, cfgidx: CFGIndex) -> (usize, usize) {\n         let n = cfgidx.node_id();\n         let start = n * self.words_per_id;\n         let end = start + self.words_per_id;\n@@ -286,7 +286,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n \n     pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n-        F: FnMut(uint) -> bool,\n+        F: FnMut(usize) -> bool,\n     {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n@@ -303,7 +303,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n \n     pub fn each_bit_for_node<F>(&self, e: EntryOrExit, cfgidx: CFGIndex, f: F) -> bool where\n-        F: FnMut(uint) -> bool,\n+        F: FnMut(usize) -> bool,\n     {\n         //! Iterates through each bit that is set on entry/exit to `cfgidx`.\n         //! Only useful after `propagate()` has been called.\n@@ -332,7 +332,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n \n     pub fn each_gen_bit<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n-        F: FnMut(uint) -> bool,\n+        F: FnMut(usize) -> bool,\n     {\n         //! Iterates through each bit in the gen set for `id`.\n         if !self.has_bitset_for_nodeid(id) {\n@@ -358,8 +358,8 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         return true;\n     }\n \n-    fn each_bit<F>(&self, words: &[uint], mut f: F) -> bool where\n-        F: FnMut(uint) -> bool,\n+    fn each_bit<F>(&self, words: &[usize], mut f: F) -> bool where\n+        F: FnMut(usize) -> bool,\n     {\n         //! Helper for iterating over the bits in a bit set.\n         //! Returns false on the first call to `f` that returns false;\n@@ -495,7 +495,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     fn walk_cfg(&mut self,\n                 cfg: &cfg::CFG,\n-                in_out: &mut [uint]) {\n+                in_out: &mut [usize]) {\n         debug!(\"DataFlowContext::walk_cfg(in_out={}) {}\",\n                bits_to_string(in_out), self.dfcx.analysis_name);\n         assert!(self.dfcx.bits_per_id > 0);\n@@ -519,15 +519,15 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n         });\n     }\n \n-    fn reset(&mut self, bits: &mut [uint]) {\n+    fn reset(&mut self, bits: &mut [usize]) {\n         let e = if self.dfcx.oper.initial_value() {usize::MAX} else {0};\n         for b in bits {\n             *b = e;\n         }\n     }\n \n     fn propagate_bits_into_graph_successors_of(&mut self,\n-                                               pred_bits: &[uint],\n+                                               pred_bits: &[usize],\n                                                cfg: &cfg::CFG,\n                                                cfgidx: CFGIndex) {\n         cfg.graph.each_outgoing_edge(cfgidx, |_e_idx, edge| {\n@@ -537,7 +537,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     }\n \n     fn propagate_bits_into_entry_set_for(&mut self,\n-                                         pred_bits: &[uint],\n+                                         pred_bits: &[usize],\n                                          edge: &cfg::CFGEdge) {\n         let source = edge.source();\n         let cfgidx = edge.target();\n@@ -560,11 +560,11 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     }\n }\n \n-fn mut_bits_to_string(words: &mut [uint]) -> String {\n+fn mut_bits_to_string(words: &mut [usize]) -> String {\n     bits_to_string(words)\n }\n \n-fn bits_to_string(words: &[uint]) -> String {\n+fn bits_to_string(words: &[usize]) -> String {\n     let mut result = String::new();\n     let mut sep = '[';\n \n@@ -584,8 +584,8 @@ fn bits_to_string(words: &[uint]) -> String {\n }\n \n #[inline]\n-fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],\n-                               in_vec: &[uint],\n+fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n+                               in_vec: &[usize],\n                                op: &Op) -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n@@ -598,7 +598,7 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],\n     changed\n }\n \n-fn set_bit(words: &mut [uint], bit: uint) -> bool {\n+fn set_bit(words: &mut [usize], bit: usize) -> bool {\n     debug!(\"set_bit: words={} bit={}\",\n            mut_bits_to_string(words), bit_str(bit));\n     let word = bit / usize::BITS as usize;\n@@ -611,17 +611,17 @@ fn set_bit(words: &mut [uint], bit: uint) -> bool {\n     oldv != newv\n }\n \n-fn bit_str(bit: uint) -> String {\n+fn bit_str(bit: usize) -> String {\n     let byte = bit >> 8;\n     let lobits = 1 << (bit & 0xFF);\n     format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }\n \n struct Union;\n impl BitwiseOperator for Union {\n-    fn join(&self, a: uint, b: uint) -> uint { a | b }\n+    fn join(&self, a: usize, b: usize) -> usize { a | b }\n }\n struct Subtract;\n impl BitwiseOperator for Subtract {\n-    fn join(&self, a: uint, b: uint) -> uint { a & !b }\n+    fn join(&self, a: usize, b: usize) -> usize { a & !b }\n }"}, {"sha": "568375597c0de1bfd9f1d2dd9db2ee5a9a2fa108", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: uint) {\n+    fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: usize) {\n         match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n             ty::ty_struct(id, _) => {\n                 let fields = ty::lookup_struct_fields(self.tcx, id);"}, {"sha": "0b688e1e08a2e3eabdc7a7324b3eb2cf05c0784c", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -172,7 +172,7 @@ fn calculate_type(sess: &session::Session,\n             assert!(src.rlib.is_some());\n             debug!(\"adding staticlib: {}\", data.name);\n             add_library(sess, cnum, cstore::RequireStatic, &mut formats);\n-            ret[cnum as uint - 1] = Some(cstore::RequireStatic);\n+            ret[cnum as usize - 1] = Some(cstore::RequireStatic);\n         }\n     });\n "}, {"sha": "36c9e582b41e9769dfa21cda7f75f5376c98e221", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -823,7 +823,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     /// `deref()` is declared with `&self`, this is an autoref of `x`.\n     fn walk_autoderefs(&mut self,\n                        expr: &ast::Expr,\n-                       autoderefs: uint) {\n+                       autoderefs: usize) {\n         debug!(\"walk_autoderefs expr={} autoderefs={}\", expr.repr(self.tcx()), autoderefs);\n \n         for i in 0..autoderefs {\n@@ -855,7 +855,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_autoref(&mut self,\n                     expr: &ast::Expr,\n                     autoref: &ty::AutoRef,\n-                    n: uint) {\n+                    n: usize) {\n         debug!(\"walk_autoref expr={}\", expr.repr(self.tcx()));\n \n         match *autoref {"}, {"sha": "36065aaca57f33b4708d7ce721d95cc54238b6fa", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -25,11 +25,11 @@ pub enum SimplifiedType {\n     StrSimplifiedType,\n     VecSimplifiedType,\n     PtrSimplifiedType,\n-    TupleSimplifiedType(uint),\n+    TupleSimplifiedType(usize),\n     TraitSimplifiedType(ast::DefId),\n     StructSimplifiedType(ast::DefId),\n     ClosureSimplifiedType(ast::DefId),\n-    FunctionSimplifiedType(uint),\n+    FunctionSimplifiedType(usize),\n     ParameterSimplifiedType,\n }\n "}, {"sha": "8673273f9b3c9c3c4fdd947ea14c462110fbc5b3", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -62,33 +62,33 @@ impl<E: Debug> Debug for Edge<E> {\n }\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n-pub struct NodeIndex(pub uint);\n+pub struct NodeIndex(pub usize);\n #[allow(non_upper_case_globals)]\n pub const InvalidNodeIndex: NodeIndex = NodeIndex(usize::MAX);\n \n #[derive(Copy, PartialEq, Debug)]\n-pub struct EdgeIndex(pub uint);\n+pub struct EdgeIndex(pub usize);\n #[allow(non_upper_case_globals)]\n pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(usize::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n #[derive(Copy, Debug)]\n-pub struct Direction { repr: uint }\n+pub struct Direction { repr: usize }\n #[allow(non_upper_case_globals)]\n pub const Outgoing: Direction = Direction { repr: 0 };\n #[allow(non_upper_case_globals)]\n pub const Incoming: Direction = Direction { repr: 1 };\n \n impl NodeIndex {\n-    fn get(&self) -> uint { let NodeIndex(v) = *self; v }\n+    fn get(&self) -> usize { let NodeIndex(v) = *self; v }\n     /// Returns unique id (unique with respect to the graph holding associated node).\n-    pub fn node_id(&self) -> uint { self.get() }\n+    pub fn node_id(&self) -> usize { self.get() }\n }\n \n impl EdgeIndex {\n-    fn get(&self) -> uint { let EdgeIndex(v) = *self; v }\n+    fn get(&self) -> usize { let EdgeIndex(v) = *self; v }\n     /// Returns unique id (unique with respect to the graph holding associated edge).\n-    pub fn edge_id(&self) -> uint { self.get() }\n+    pub fn edge_id(&self) -> usize { self.get() }\n }\n \n impl<N,E> Graph<N,E> {\n@@ -99,8 +99,8 @@ impl<N,E> Graph<N,E> {\n         }\n     }\n \n-    pub fn with_capacity(num_nodes: uint,\n-                         num_edges: uint) -> Graph<N,E> {\n+    pub fn with_capacity(num_nodes: usize,\n+                         num_edges: usize) -> Graph<N,E> {\n         Graph {\n             nodes: Vec::with_capacity(num_nodes),\n             edges: Vec::with_capacity(num_edges),\n@@ -275,7 +275,7 @@ impl<N,E> Graph<N,E> {\n     // computation.\n \n     pub fn iterate_until_fixed_point<'a, F>(&'a self, mut op: F) where\n-        F: FnMut(uint, EdgeIndex, &'a Edge<E>) -> bool,\n+        F: FnMut(usize, EdgeIndex, &'a Edge<E>) -> bool,\n     {\n         let mut iteration = 0;\n         let mut changed = true;"}, {"sha": "36229a558e95585756eeff466e5ef13af245575c", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -1752,7 +1752,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n // LifeGiver is responsible for generating fresh lifetime names\n struct LifeGiver {\n     taken: HashSet<String>,\n-    counter: Cell<uint>,\n+    counter: Cell<usize>,\n     generated: RefCell<Vec<ast::Lifetime>>,\n }\n \n@@ -1792,7 +1792,7 @@ impl LifeGiver {\n         return lifetime;\n \n         // 0 .. 25 generates a .. z, 26 .. 51 generates aa .. zz, and so on\n-        fn num_to_string(counter: uint) -> String {\n+        fn num_to_string(counter: usize) -> String {\n             let mut s = String::new();\n             let (n, r) = (counter/26 + 1, counter % 26);\n             let letter: char = from_u32((r+97) as u32).unwrap();"}, {"sha": "2018f2e9a8676279d0f284963888190a040a8980", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -836,7 +836,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty::mk_var(self.tcx, self.next_ty_var_id(true))\n     }\n \n-    pub fn next_ty_vars(&self, n: uint) -> Vec<Ty<'tcx>> {\n+    pub fn next_ty_vars(&self, n: usize) -> Vec<Ty<'tcx>> {\n         (0..n).map(|_i| self.next_ty_var()).collect()\n     }\n "}, {"sha": "1fcbf80c904e0d7175c6cd69341529d0aa122f3a", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -121,7 +121,7 @@ struct ConstraintGraph<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     graph_name: String,\n     map: &'a FnvHashMap<Constraint, SubregionOrigin<'tcx>>,\n-    node_ids: FnvHashMap<Node, uint>,\n+    node_ids: FnvHashMap<Node, usize>,\n }\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug, Copy)]"}, {"sha": "c432d114b6eed5cbe38d42c5dc5c4baeefb1f9a3", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -86,7 +86,7 @@ pub enum UndoLogEntry {\n     CommitedSnapshot,\n     AddVar(RegionVid),\n     AddConstraint(Constraint),\n-    AddVerify(uint),\n+    AddVerify(usize),\n     AddGiven(ty::FreeRegion, ty::RegionVid),\n     AddCombination(CombineMapType, TwoRegions)\n }\n@@ -224,7 +224,7 @@ pub struct RegionVarBindings<'a, 'tcx: 'a> {\n \n #[derive(Debug)]\n pub struct RegionSnapshot {\n-    length: uint,\n+    length: usize,\n     skolemization_count: u32,\n }\n \n@@ -284,7 +284,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 AddVar(vid) => {\n                     let mut var_origins = self.var_origins.borrow_mut();\n                     var_origins.pop().unwrap();\n-                    assert_eq!(var_origins.len(), vid.index as uint);\n+                    assert_eq!(var_origins.len(), vid.index as usize);\n                 }\n                 AddConstraint(ref constraint) => {\n                     self.constraints.borrow_mut().remove(constraint);\n@@ -312,7 +312,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     pub fn num_vars(&self) -> u32 {\n         let len = self.var_origins.borrow().len();\n         // enforce no overflow\n-        assert!(len as u32 as uint == len);\n+        assert!(len as u32 as usize == len);\n         len as u32\n     }\n \n@@ -557,7 +557,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         match *self.values.borrow() {\n             None => {\n                 self.tcx.sess.span_bug(\n-                    (*self.var_origins.borrow())[rid.index as uint].span(),\n+                    (*self.var_origins.borrow())[rid.index as usize].span(),\n                     \"attempt to resolve region variable before values have \\\n                      been computed!\")\n             }\n@@ -629,7 +629,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let mut result_set = vec!(r0);\n         let mut result_index = 0;\n         while result_index < result_set.len() {\n-            // nb: can't use uint::range() here because result_set grows\n+            // nb: can't use usize::range() here because result_set grows\n             let r = result_set[result_index];\n             debug!(\"result_index={}, r={:?}\", result_index, r);\n \n@@ -746,7 +746,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n-                (*self.var_origins.borrow())[v_id.index as uint].span(),\n+                (*self.var_origins.borrow())[v_id.index as usize].span(),\n                 &format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {:?}, {:?}\",\n                         a,\n@@ -850,7 +850,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (ReInfer(ReVar(v_id)), _) |\n             (_, ReInfer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n-                    (*self.var_origins.borrow())[v_id.index as uint].span(),\n+                    (*self.var_origins.borrow())[v_id.index as usize].span(),\n                     &format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {:?}, {:?}\",\n                             a,\n@@ -984,7 +984,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn construct_var_data(&self) -> Vec<VarData> {\n-        (0..self.num_vars() as uint).map(|_| {\n+        (0..self.num_vars() as usize).map(|_| {\n             VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n@@ -1013,14 +1013,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                    .repr(self.tcx));\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n-                let b_data = &mut var_data[b_vid.index as uint];\n+                let b_data = &mut var_data[b_vid.index as usize];\n                 self.expand_node(a_region, b_vid, b_data)\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match var_data[a_vid.index as uint].value {\n+                match var_data[a_vid.index as usize].value {\n                   NoValue | ErrorValue => false,\n                   Value(a_region) => {\n-                    let b_node = &mut var_data[b_vid.index as uint];\n+                    let b_node = &mut var_data[b_vid.index as usize];\n                     self.expand_node(a_region, b_vid, b_node)\n                   }\n                 }\n@@ -1101,16 +1101,16 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 false\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match var_data[b_vid.index as uint].value {\n+                match var_data[b_vid.index as usize].value {\n                   NoValue | ErrorValue => false,\n                   Value(b_region) => {\n-                    let a_data = &mut var_data[a_vid.index as uint];\n+                    let a_data = &mut var_data[a_vid.index as usize];\n                     self.contract_node(a_vid, a_data, b_region)\n                   }\n                 }\n               }\n               ConstrainVarSubReg(a_vid, b_region) => {\n-                let a_data = &mut var_data[a_vid.index as uint];\n+                let a_data = &mut var_data[a_vid.index as usize];\n                 self.contract_node(a_vid, a_data, b_region)\n               }\n             }\n@@ -1250,11 +1250,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec: Vec<_> = repeat(u32::MAX).take(self.num_vars() as uint).collect();\n+        let mut dup_vec: Vec<_> = repeat(u32::MAX).take(self.num_vars() as usize).collect();\n \n         let mut opt_graph = None;\n \n-        for idx in 0..self.num_vars() as uint {\n+        for idx in 0..self.num_vars() as usize {\n             match var_data[idx].value {\n                 Value(_) => {\n                     /* Inference successful */\n@@ -1311,7 +1311,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n         }\n \n-        (0..self.num_vars() as uint).map(|idx| var_data[idx].value).collect()\n+        (0..self.num_vars() as usize).map(|idx| var_data[idx].value).collect()\n     }\n \n     fn construct_graph(&self) -> RegionGraph {\n@@ -1320,7 +1320,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let constraints = self.constraints.borrow();\n         let num_edges = constraints.len();\n \n-        let mut graph = graph::Graph::with_capacity(num_vars as uint + 1,\n+        let mut graph = graph::Graph::with_capacity(num_vars as usize + 1,\n                                                     num_edges);\n \n         for _ in 0..num_vars {\n@@ -1331,17 +1331,17 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         for (constraint, _) in &*constraints {\n             match *constraint {\n                 ConstrainVarSubVar(a_id, b_id) => {\n-                    graph.add_edge(NodeIndex(a_id.index as uint),\n-                                   NodeIndex(b_id.index as uint),\n+                    graph.add_edge(NodeIndex(a_id.index as usize),\n+                                   NodeIndex(b_id.index as usize),\n                                    *constraint);\n                 }\n                 ConstrainRegSubVar(_, b_id) => {\n                     graph.add_edge(dummy_idx,\n-                                   NodeIndex(b_id.index as uint),\n+                                   NodeIndex(b_id.index as usize),\n                                    *constraint);\n                 }\n                 ConstrainVarSubReg(a_id, _) => {\n-                    graph.add_edge(NodeIndex(a_id.index as uint),\n+                    graph.add_edge(NodeIndex(a_id.index as usize),\n                                    dummy_idx,\n                                    *constraint);\n                 }\n@@ -1395,7 +1395,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     debug!(\"pushing SubSupConflict sub: {:?} sup: {:?}\",\n                            lower_bound.region, upper_bound.region);\n                     errors.push(SubSupConflict(\n-                        (*self.var_origins.borrow())[node_idx.index as uint].clone(),\n+                        (*self.var_origins.borrow())[node_idx.index as usize].clone(),\n                         lower_bound.origin.clone(),\n                         lower_bound.region,\n                         upper_bound.origin.clone(),\n@@ -1406,7 +1406,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         self.tcx.sess.span_bug(\n-            (*self.var_origins.borrow())[node_idx.index as uint].span(),\n+            (*self.var_origins.borrow())[node_idx.index as usize].span(),\n             &format!(\"collect_error_for_expanding_node() could not find error \\\n                     for var {:?}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n@@ -1439,7 +1439,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                   Ok(_) => {}\n                   Err(_) => {\n                     errors.push(SupSupConflict(\n-                        (*self.var_origins.borrow())[node_idx.index as uint].clone(),\n+                        (*self.var_origins.borrow())[node_idx.index as usize].clone(),\n                         upper_bound_1.origin.clone(),\n                         upper_bound_1.region,\n                         upper_bound_2.origin.clone(),\n@@ -1451,7 +1451,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         self.tcx.sess.span_bug(\n-            (*self.var_origins.borrow())[node_idx.index as uint].span(),\n+            (*self.var_origins.borrow())[node_idx.index as usize].span(),\n             &format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {:?}, upper_bounds={}\",\n                     node_idx,\n@@ -1485,12 +1485,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         while !state.stack.is_empty() {\n             let node_idx = state.stack.pop().unwrap();\n-            let classification = var_data[node_idx.index as uint].classification;\n+            let classification = var_data[node_idx.index as usize].classification;\n \n             // check whether we've visited this node on some previous walk\n-            if dup_vec[node_idx.index as uint] == u32::MAX {\n-                dup_vec[node_idx.index as uint] = orig_node_idx.index;\n-            } else if dup_vec[node_idx.index as uint] != orig_node_idx.index {\n+            if dup_vec[node_idx.index as usize] == u32::MAX {\n+                dup_vec[node_idx.index as usize] = orig_node_idx.index;\n+            } else if dup_vec[node_idx.index as usize] != orig_node_idx.index {\n                 state.dup_found = true;\n             }\n \n@@ -1518,7 +1518,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                          dir: Direction) {\n             debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n-            let source_node_index = NodeIndex(source_vid.index as uint);\n+            let source_node_index = NodeIndex(source_vid.index as usize);\n             graph.each_adjacent_edge(source_node_index, dir, |_, edge| {\n                 match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n@@ -1603,7 +1603,7 @@ fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n }\n \n fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n-    match values[rid.index as uint] {\n+    match values[rid.index as usize] {\n         Value(r) => r,\n         NoValue => ReEmpty, // No constraints, return ty::ReEmpty\n         ErrorValue => ReStatic, // Previously reported error."}, {"sha": "553ef9afc28165da821f6dad614e8d2d30d6a78d", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -69,11 +69,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n \n     fn relations<'a>(&'a mut self, a: ty::TyVid) -> &'a mut Vec<Relation> {\n-        relations(self.values.get_mut(a.index as uint))\n+        relations(self.values.get_mut(a.index as usize))\n     }\n \n     pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n-        self.values.get(vid.index as uint).diverging\n+        self.values.get(vid.index as usize).diverging\n     }\n \n     /// Records that `a <: b`, `a :> b`, or `a == b`, depending on `dir`.\n@@ -97,7 +97,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         stack: &mut Vec<(Ty<'tcx>, RelationDir, ty::TyVid)>)\n     {\n         let old_value = {\n-            let value_ptr = &mut self.values.get_mut(vid.index as uint).value;\n+            let value_ptr = &mut self.values.get_mut(vid.index as usize).value;\n             mem::replace(value_ptr, Known(ty))\n         };\n \n@@ -123,7 +123,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n \n     pub fn probe(&self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n-        match self.values.get(vid.index as uint).value {\n+        match self.values.get(vid.index as usize).value {\n             Bounded(..) => None,\n             Known(t) => Some(t)\n         }\n@@ -206,12 +206,12 @@ impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n                action: UndoEntry) {\n         match action {\n             SpecifyVar(vid, relations) => {\n-                values[vid.index as uint].value = Bounded(relations);\n+                values[vid.index as usize].value = Bounded(relations);\n             }\n \n             Relate(a, b) => {\n-                relations(&mut (*values)[a.index as uint]).pop();\n-                relations(&mut (*values)[b.index as uint]).pop();\n+                relations(&mut (*values)[a.index as usize]).pop();\n+                relations(&mut (*values)[b.index as usize]).pop();\n             }\n         }\n     }"}, {"sha": "8a736d47b5d8944a338c1ad9a9dcdc3ee2bea29f", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -35,9 +35,9 @@ use util::snapshot_vec as sv;\n pub trait UnifyKey : Clone + Debug + PartialEq {\n     type Value : UnifyValue;\n \n-    fn index(&self) -> uint;\n+    fn index(&self) -> usize;\n \n-    fn from_index(u: uint) -> Self;\n+    fn from_index(u: usize) -> Self;\n \n     // Given an inference context, returns the unification table\n     // appropriate to this key type.\n@@ -67,7 +67,7 @@ pub trait UnifyValue : Clone + PartialEq + Debug {\n #[derive(PartialEq,Clone,Debug)]\n pub enum VarValue<K:UnifyKey> {\n     Redirect(K),\n-    Root(K::Value, uint),\n+    Root(K::Value, usize),\n }\n \n /// Table of unification keys and their values.\n@@ -89,7 +89,7 @@ pub struct Snapshot<K:UnifyKey> {\n pub struct Node<K:UnifyKey> {\n     pub key: K,\n     pub value: K::Value,\n-    pub rank: uint,\n+    pub rank: usize,\n }\n \n #[derive(Copy)]\n@@ -186,7 +186,7 @@ impl<K:UnifyKey> UnificationTable<K> {\n                        tcx: &ty::ctxt<'tcx>,\n                        node_a: &Node<K>,\n                        node_b: &Node<K>)\n-                       -> (K, uint)\n+                       -> (K, usize)\n     {\n         debug!(\"unify(node_a(id={:?}, rank={:?}), node_b(id={:?}, rank={:?}))\",\n                node_a.key,\n@@ -358,9 +358,9 @@ impl<'a,'tcx,V,K> InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V> for InferCtx\n impl UnifyKey for ty::IntVid {\n     type Value = Option<IntVarValue>;\n \n-    fn index(&self) -> uint { self.index as uint }\n+    fn index(&self) -> usize { self.index as usize }\n \n-    fn from_index(i: uint) -> ty::IntVid { ty::IntVid { index: i as u32 } }\n+    fn from_index(i: usize) -> ty::IntVid { ty::IntVid { index: i as u32 } }\n \n     fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::IntVid>> {\n         return &infcx.int_unification_table;\n@@ -391,9 +391,9 @@ impl UnifyValue for Option<IntVarValue> { }\n impl UnifyKey for ty::FloatVid {\n     type Value = Option<ast::FloatTy>;\n \n-    fn index(&self) -> uint { self.index as uint }\n+    fn index(&self) -> usize { self.index as usize }\n \n-    fn from_index(i: uint) -> ty::FloatVid { ty::FloatVid { index: i as u32 } }\n+    fn from_index(i: usize) -> ty::FloatVid { ty::FloatVid { index: i as u32 } }\n \n     fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::FloatVid>> {\n         return &infcx.float_unification_table;"}, {"sha": "2a4c25345447fb84e980525862e8b8b984fafbd5", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -28,8 +28,8 @@ pub fn check_crate(tcx: &ctxt) {\n     let mut visitor = IntrinsicCheckingVisitor {\n         tcx: tcx,\n         param_envs: Vec::new(),\n-        dummy_sized_ty: tcx.types.int,\n-        dummy_unsized_ty: ty::mk_vec(tcx, tcx.types.int, None),\n+        dummy_sized_ty: tcx.types.isize,\n+        dummy_unsized_ty: ty::mk_vec(tcx, tcx.types.isize, None),\n     };\n     visit::walk_crate(&mut visitor, tcx.map.krate());\n }"}, {"sha": "b9a82669f65d3910f0606e884f88aafc7d64f141", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -70,7 +70,7 @@ impl LanguageItems {\n         self.items.iter().enumerate()\n     }\n \n-    pub fn item_name(index: uint) -> &'static str {\n+    pub fn item_name(index: usize) -> &'static str {\n         let item: Option<LangItem> = FromPrimitive::from_usize(index);\n         match item {\n             $( Some($variant) => $name, )*\n@@ -79,11 +79,11 @@ impl LanguageItems {\n     }\n \n     pub fn require(&self, it: LangItem) -> Result<ast::DefId, String> {\n-        match self.items[it as uint] {\n+        match self.items[it as usize] {\n             Some(id) => Ok(id),\n             None => {\n                 Err(format!(\"requires `{}` lang_item\",\n-                            LanguageItems::item_name(it as uint)))\n+                            LanguageItems::item_name(it as usize)))\n             }\n         }\n     }\n@@ -132,7 +132,7 @@ impl LanguageItems {\n     $(\n         #[allow(dead_code)]\n         pub fn $method(&self) -> Option<ast::DefId> {\n-            self.items[$variant as uint]\n+            self.items[$variant as usize]\n         }\n     )*\n }\n@@ -142,7 +142,7 @@ struct LanguageItemCollector<'a> {\n \n     session: &'a Session,\n \n-    item_refs: FnvHashMap<&'static str, uint>,\n+    item_refs: FnvHashMap<&'static str, usize>,\n }\n \n impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n@@ -163,7 +163,7 @@ impl<'a> LanguageItemCollector<'a> {\n     pub fn new(session: &'a Session) -> LanguageItemCollector<'a> {\n         let mut item_refs = FnvHashMap();\n \n-        $( item_refs.insert($name, $variant as uint); )*\n+        $( item_refs.insert($name, $variant as usize); )*\n \n         LanguageItemCollector {\n             session: session,\n@@ -172,7 +172,7 @@ impl<'a> LanguageItemCollector<'a> {\n         }\n     }\n \n-    pub fn collect_item(&mut self, item_index: uint,\n+    pub fn collect_item(&mut self, item_index: usize,\n                         item_def_id: ast::DefId, span: Span) {\n         // Check for duplicates.\n         match self.items.items[item_index] {"}, {"sha": "e4e6a5016937d895bda0709babdb094d81851483", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -94,7 +94,7 @@ pub enum categorization<'tcx> {\n     cat_static_item,\n     cat_upvar(Upvar),                          // upvar referenced by closure env\n     cat_local(ast::NodeId),                    // local variable\n-    cat_deref(cmt<'tcx>, uint, PointerKind),   // deref of a ptr\n+    cat_deref(cmt<'tcx>, usize, PointerKind),   // deref of a ptr\n     cat_interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n     cat_downcast(cmt<'tcx>, ast::DefId),       // selects a particular enum variant (*1)\n \n@@ -135,7 +135,7 @@ pub enum InteriorKind {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum FieldName {\n     NamedField(ast::Name),\n-    PositionalField(uint)\n+    PositionalField(usize)\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -462,7 +462,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_expr_autoderefd(&self,\n                                expr: &ast::Expr,\n-                               autoderefs: uint)\n+                               autoderefs: usize)\n                                -> McResult<cmt<'tcx>> {\n         let mut cmt = try!(self.cat_expr_unadjusted(expr));\n         debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n@@ -868,7 +868,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_tup_field<N:ast_node>(&self,\n                                      node: &N,\n                                      base_cmt: cmt<'tcx>,\n-                                     f_idx: uint,\n+                                     f_idx: usize,\n                                      f_ty: Ty<'tcx>)\n                                      -> cmt<'tcx> {\n         Rc::new(cmt_ {\n@@ -884,7 +884,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt<'tcx>,\n-                             deref_cnt: uint,\n+                             deref_cnt: usize,\n                              deref_context: DerefKindContext)\n                              -> McResult<cmt<'tcx>> {\n         let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n@@ -928,7 +928,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     fn cat_deref_common<N:ast_node>(&self,\n                                     node: &N,\n                                     base_cmt: cmt<'tcx>,\n-                                    deref_cnt: uint,\n+                                    deref_cnt: usize,\n                                     deref_ty: Ty<'tcx>,\n                                     deref_context: DerefKindContext,\n                                     implicit: bool)"}, {"sha": "8d2de18fea13e955757dfffe09962108dee81ea9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -136,7 +136,7 @@ impl DestructionScopeData {\n          RustcDecodable, Debug, Copy)]\n pub struct BlockRemainder {\n     pub block: ast::NodeId,\n-    pub first_statement_index: uint,\n+    pub first_statement_index: usize,\n }\n \n impl CodeExtent {\n@@ -284,7 +284,7 @@ impl InnermostDeclaringBlock {\n struct DeclaringStatementContext {\n     stmt_id: ast::NodeId,\n     block_id: ast::NodeId,\n-    stmt_index: uint,\n+    stmt_index: usize,\n }\n \n impl DeclaringStatementContext {"}, {"sha": "e2ebe2bc0f1e53fa1ad1cb39aebf17f116469f9b", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -98,7 +98,7 @@ impl<'tcx> Substs<'tcx> {\n     }\n \n     pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n-        *self.types.get(ty_param_def.space, ty_param_def.index as uint)\n+        *self.types.get(ty_param_def.space, ty_param_def.index as usize)\n     }\n \n     pub fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n@@ -193,15 +193,15 @@ impl ParamSpace {\n         [TypeSpace, SelfSpace, FnSpace]\n     }\n \n-    pub fn to_uint(self) -> uint {\n+    pub fn to_uint(self) -> usize {\n         match self {\n             TypeSpace => 0,\n             SelfSpace => 1,\n             FnSpace => 2,\n         }\n     }\n \n-    pub fn from_uint(u: uint) -> ParamSpace {\n+    pub fn from_uint(u: usize) -> ParamSpace {\n         match u {\n             0 => TypeSpace,\n             1 => SelfSpace,\n@@ -226,8 +226,8 @@ pub struct VecPerParamSpace<T> {\n     // AF(self) = (self.content[..self.type_limit],\n     //             self.content[self.type_limit..self.self_limit],\n     //             self.content[self.self_limit..])\n-    type_limit: uint,\n-    self_limit: uint,\n+    type_limit: usize,\n+    self_limit: usize,\n     content: Vec<T>,\n }\n \n@@ -251,7 +251,7 @@ impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n }\n \n impl<T> VecPerParamSpace<T> {\n-    fn limits(&self, space: ParamSpace) -> (uint, uint) {\n+    fn limits(&self, space: ParamSpace) -> (usize, usize) {\n         match space {\n             TypeSpace => (0, self.type_limit),\n             SelfSpace => (self.type_limit, self.self_limit),\n@@ -290,7 +290,7 @@ impl<T> VecPerParamSpace<T> {\n         }\n     }\n \n-    fn new_internal(content: Vec<T>, type_limit: uint, self_limit: uint)\n+    fn new_internal(content: Vec<T>, type_limit: usize, self_limit: usize)\n                     -> VecPerParamSpace<T>\n     {\n         VecPerParamSpace {\n@@ -343,7 +343,7 @@ impl<T> VecPerParamSpace<T> {\n         }\n     }\n \n-    pub fn truncate(&mut self, space: ParamSpace, len: uint) {\n+    pub fn truncate(&mut self, space: ParamSpace, len: usize) {\n         // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n         while self.len(space) > len {\n             self.pop(space);\n@@ -364,7 +364,7 @@ impl<T> VecPerParamSpace<T> {\n         if v.len() == 0 { None } else { Some(&v[0]) }\n     }\n \n-    pub fn len(&self, space: ParamSpace) -> uint {\n+    pub fn len(&self, space: ParamSpace) -> usize {\n         self.get_slice(space).len()\n     }\n \n@@ -384,13 +384,13 @@ impl<T> VecPerParamSpace<T> {\n \n     pub fn opt_get<'a>(&'a self,\n                        space: ParamSpace,\n-                       index: uint)\n+                       index: usize)\n                        -> Option<&'a T> {\n         let v = self.get_slice(space);\n         if index < v.len() { Some(&v[index]) } else { None }\n     }\n \n-    pub fn get<'a>(&'a self, space: ParamSpace, index: uint) -> &'a T {\n+    pub fn get<'a>(&'a self, space: ParamSpace, index: usize) -> &'a T {\n         &self.get_slice(space)[index]\n     }\n \n@@ -441,7 +441,7 @@ impl<T> VecPerParamSpace<T> {\n     }\n \n     pub fn map_enumerated<U, P>(&self, pred: P) -> VecPerParamSpace<U> where\n-        P: FnMut((ParamSpace, uint, &T)) -> U,\n+        P: FnMut((ParamSpace, usize, &T)) -> U,\n     {\n         let result = self.iter_enumerated().map(pred).collect();\n         VecPerParamSpace::new_internal(result,\n@@ -487,8 +487,8 @@ impl<T> VecPerParamSpace<T> {\n #[derive(Clone)]\n pub struct EnumeratedItems<'a,T:'a> {\n     vec: &'a VecPerParamSpace<T>,\n-    space_index: uint,\n-    elem_index: uint\n+    space_index: usize,\n+    elem_index: usize\n }\n \n impl<'a,T> EnumeratedItems<'a,T> {\n@@ -511,9 +511,9 @@ impl<'a,T> EnumeratedItems<'a,T> {\n }\n \n impl<'a,T> Iterator for EnumeratedItems<'a,T> {\n-    type Item = (ParamSpace, uint, &'a T);\n+    type Item = (ParamSpace, usize, &'a T);\n \n-    fn next(&mut self) -> Option<(ParamSpace, uint, &'a T)> {\n+    fn next(&mut self) -> Option<(ParamSpace, usize, &'a T)> {\n         let spaces = ParamSpace::all();\n         if self.space_index < spaces.len() {\n             let space = spaces[self.space_index];\n@@ -598,7 +598,7 @@ struct SubstFolder<'a, 'tcx: 'a> {\n     root_ty: Option<Ty<'tcx>>,\n \n     // Depth of type stack\n-    ty_stack_depth: uint,\n+    ty_stack_depth: usize,\n \n     // Number of region binders we have passed through while doing the substitution\n     region_binders_passed: u32,\n@@ -626,7 +626,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                 match self.substs.regions {\n                     ErasedRegions => ty::ReStatic,\n                     NonerasedRegions(ref regions) =>\n-                        match regions.opt_get(space, i as uint) {\n+                        match regions.opt_get(space, i as usize) {\n                             Some(&r) => {\n                                 self.shift_region_through_binders(r)\n                             }\n@@ -682,7 +682,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n impl<'a,'tcx> SubstFolder<'a,'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.types.opt_get(p.space, p.idx as uint);\n+        let opt_ty = self.substs.types.opt_get(p.space, p.idx as usize);\n         let ty = match opt_ty {\n             Some(t) => *t,\n             None => {"}, {"sha": "5b260598e107713d11853ea91f6bf63c19dc606b", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -53,7 +53,7 @@ pub struct FulfillmentContext<'tcx> {\n     // Remembers the count of trait obligations that we have already\n     // attempted to select. This is used to avoid repeating work\n     // when `select_new_obligations` is called.\n-    attempted_mark: uint,\n+    attempted_mark: usize,\n \n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n@@ -163,6 +163,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         // debug output much nicer to read and so on.\n         let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n \n+        assert!(!obligation.has_escaping_regions());\n+\n         if !self.duplicate_set.insert(obligation.predicate.clone()) {\n             debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr(infcx.tcx));\n             return;"}, {"sha": "8809abdd70e62b10d664263917bdab2ed643f5b6", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -39,6 +39,7 @@ pub use self::object_safety::is_object_safe;\n pub use self::object_safety::object_safety_violations;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n+pub use self::object_safety::is_vtable_safe_method;\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n@@ -48,6 +49,8 @@ pub use self::util::get_vtable_index_of_object_method;\n pub use self::util::trait_ref_for_builtin_bound;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n+pub use self::util::supertrait_def_ids;\n+pub use self::util::SupertraitDefIds;\n pub use self::util::transitive_bounds;\n pub use self::util::upcast;\n \n@@ -68,7 +71,7 @@ mod util;\n #[derive(Clone, PartialEq, Eq)]\n pub struct Obligation<'tcx, T> {\n     pub cause: ObligationCause<'tcx>,\n-    pub recursion_depth: uint,\n+    pub recursion_depth: usize,\n     pub predicate: T,\n }\n \n@@ -482,7 +485,7 @@ impl<'tcx,O> Obligation<'tcx,O> {\n     }\n \n     fn with_depth(cause: ObligationCause<'tcx>,\n-                  recursion_depth: uint,\n+                  recursion_depth: usize,\n                   trait_ref: O)\n                   -> Obligation<'tcx, O>\n     {\n@@ -640,7 +643,7 @@ impl<'tcx> FulfillmentError<'tcx> {\n }\n \n impl<'tcx> TraitObligation<'tcx> {\n-    fn self_ty(&self) -> Ty<'tcx> {\n-        self.predicate.0.self_ty()\n+    fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n+        ty::Binder(self.predicate.skip_binder().self_ty())\n     }\n }"}, {"sha": "af6bb4ccccd8026d35a4d3d9d7c5d7f57a597695", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -53,36 +53,36 @@ pub enum MethodViolationCode {\n }\n \n pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                            trait_ref: ty::PolyTraitRef<'tcx>)\n+                            trait_def_id: ast::DefId)\n                             -> bool\n {\n     // Because we query yes/no results frequently, we keep a cache:\n     let cached_result =\n-        tcx.object_safety_cache.borrow().get(&trait_ref.def_id()).cloned();\n+        tcx.object_safety_cache.borrow().get(&trait_def_id).cloned();\n \n     let result =\n         cached_result.unwrap_or_else(|| {\n-            let result = object_safety_violations(tcx, trait_ref.clone()).is_empty();\n+            let result = object_safety_violations(tcx, trait_def_id).is_empty();\n \n             // Record just a yes/no result in the cache; this is what is\n             // queried most frequently. Note that this may overwrite a\n             // previous result, but always with the same thing.\n-            tcx.object_safety_cache.borrow_mut().insert(trait_ref.def_id(), result);\n+            tcx.object_safety_cache.borrow_mut().insert(trait_def_id, result);\n \n             result\n         });\n \n-    debug!(\"is_object_safe({}) = {}\", trait_ref.repr(tcx), result);\n+    debug!(\"is_object_safe({}) = {}\", trait_def_id.repr(tcx), result);\n \n     result\n }\n \n pub fn object_safety_violations<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                      sub_trait_ref: ty::PolyTraitRef<'tcx>)\n+                                      trait_def_id: ast::DefId)\n                                       -> Vec<ObjectSafetyViolation<'tcx>>\n {\n-    supertraits(tcx, sub_trait_ref)\n-        .flat_map(|tr| object_safety_violations_for_trait(tcx, tr.def_id()).into_iter())\n+    traits::supertrait_def_ids(tcx, trait_def_id)\n+        .flat_map(|def_id| object_safety_violations_for_trait(tcx, def_id).into_iter())\n         .collect()\n }\n \n@@ -96,7 +96,7 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .flat_map(|item| {\n             match *item {\n                 ty::MethodTraitItem(ref m) => {\n-                    object_safety_violations_for_method(tcx, trait_def_id, &**m)\n+                    object_safety_violation_for_method(tcx, trait_def_id, &**m)\n                         .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n                         .into_iter()\n                 }\n@@ -193,17 +193,42 @@ fn generics_require_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n         })\n }\n \n-fn object_safety_violations_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                             trait_def_id: ast::DefId,\n-                                             method: &ty::Method<'tcx>)\n-                                             -> Option<MethodViolationCode>\n+/// Returns `Some(_)` if this method makes the containing trait not object safe.\n+fn object_safety_violation_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                            trait_def_id: ast::DefId,\n+                                            method: &ty::Method<'tcx>)\n+                                            -> Option<MethodViolationCode>\n {\n     // Any method that has a `Self : Sized` requisite is otherwise\n     // exempt from the regulations.\n     if generics_require_sized_self(tcx, &method.generics, &method.predicates) {\n         return None;\n     }\n \n+    virtual_call_violation_for_method(tcx, trait_def_id, method)\n+}\n+\n+/// We say a method is *vtable safe* if it can be invoked on a trait\n+/// object.  Note that object-safe traits can have some\n+/// non-vtable-safe methods, so long as they require `Self:Sized` or\n+/// otherwise ensure that they cannot be used when `Self=Trait`.\n+pub fn is_vtable_safe_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                   trait_def_id: ast::DefId,\n+                                   method: &ty::Method<'tcx>)\n+                                   -> bool\n+{\n+    virtual_call_violation_for_method(tcx, trait_def_id, method).is_none()\n+}\n+\n+/// Returns `Some(_)` if this method cannot be called on a trait\n+/// object; this does not necessarily imply that the enclosing trait\n+/// is not object safe, because the method might have a where clause\n+/// `Self:Sized`.\n+fn virtual_call_violation_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                           trait_def_id: ast::DefId,\n+                                           method: &ty::Method<'tcx>)\n+                                           -> Option<MethodViolationCode>\n+{\n     // The method's first parameter must be something that derefs (or\n     // autorefs) to `&self`. For now, we only accept `self`, `&self`\n     // and `Box<Self>`."}, {"sha": "1594d8b2e0d047b06a836e72ea02afe7a307416d", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -197,7 +197,7 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n /// As `normalize`, but with a custom depth.\n pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                           cause: ObligationCause<'tcx>,\n-                                          depth: uint,\n+                                          depth: usize,\n                                           value: &T)\n                                           -> Normalized<'tcx, T>\n     where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n@@ -214,13 +214,13 @@ struct AssociatedTypeNormalizer<'a,'b:'a,'tcx:'b> {\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     cause: ObligationCause<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n-    depth: uint,\n+    depth: usize,\n }\n \n impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n     fn new(selcx: &'a mut SelectionContext<'b,'tcx>,\n            cause: ObligationCause<'tcx>,\n-           depth: uint)\n+           depth: usize)\n            -> AssociatedTypeNormalizer<'a,'b,'tcx>\n     {\n         AssociatedTypeNormalizer {\n@@ -314,7 +314,7 @@ pub fn normalize_projection_type<'a,'b,'tcx>(\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    depth: uint)\n+    depth: usize)\n     -> NormalizedTy<'tcx>\n {\n     opt_normalize_projection_type(selcx, projection_ty.clone(), cause.clone(), depth)\n@@ -344,7 +344,7 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    depth: uint)\n+    depth: usize)\n     -> Option<NormalizedTy<'tcx>>\n {\n     debug!(\"normalize_projection_type(\\\n@@ -412,7 +412,7 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n fn normalize_to_error<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                projection_ty: ty::ProjectionTy<'tcx>,\n                                cause: ObligationCause<'tcx>,\n-                               depth: uint)\n+                               depth: usize)\n                                -> NormalizedTy<'tcx>\n {\n     let trait_ref = projection_ty.trait_ref.to_poly_trait_ref();\n@@ -699,10 +699,10 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             // But wait, you say! What about an example like this:\n             //\n             // ```\n-            // fn bar<T:SomeTrait<Foo=uint>>(...) { ... }\n+            // fn bar<T:SomeTrait<Foo=usize>>(...) { ... }\n             // ```\n             //\n-            // Doesn't the `T : Sometrait<Foo=uint>` predicate help\n+            // Doesn't the `T : Sometrait<Foo=usize>` predicate help\n             // resolve `T::Foo`? And of course it does, but in fact\n             // that single predicate is desugared into two predicates\n             // in the compiler: a trait predicate (`T : SomeTrait`) and a"}, {"sha": "bc56d9683ece55e14e4d1cef1f942644c6828cf4", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 224, "deletions": 133, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -110,7 +110,7 @@ pub enum MethodMatchedData {\n /// The selection process begins by considering all impls, where\n /// clauses, and so forth that might resolve an obligation.  Sometimes\n /// we'll be able to say definitively that (e.g.) an impl does not\n-/// apply to the obligation: perhaps it is defined for `uint` but the\n+/// apply to the obligation: perhaps it is defined for `usize` but the\n /// obligation is for `int`. In that case, we drop the impl out of the\n /// list.  But the other cases are considered *candidates*.\n ///\n@@ -138,6 +138,7 @@ enum SelectionCandidate<'tcx> {\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n     ImplCandidate(ast::DefId),\n     DefaultImplCandidate(ast::DefId),\n+    DefaultImplObjectCandidate(ast::DefId),\n \n     /// This is a trait matching with a projected type as `Self`, and\n     /// we found an applicable bound in the trait definition.\n@@ -171,7 +172,7 @@ struct SelectionCandidateSet<'tcx> {\n }\n \n enum BuiltinBoundConditions<'tcx> {\n-    If(Vec<Ty<'tcx>>),\n+    If(ty::Binder<Vec<Ty<'tcx>>>),\n     ParameterBuiltin,\n     AmbiguousBuiltin\n }\n@@ -292,7 +293,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // because if it is a closure type, it must be a closure type from\n         // within this current fn, and hence none of the higher-ranked\n         // lifetimes can appear inside the self-type.\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::ty_closure(id, ref substs) => (id, substs.clone()),\n             _ => { return; }\n@@ -627,7 +628,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // for example, we are looking for $0:Eq where $0 is some\n         // unconstrained type variable. In that case, we'll get a\n         // candidate which assumes $0 == int, one that assumes $0 ==\n-        // uint, etc. This spells an ambiguity.\n+        // usize, etc. This spells an ambiguity.\n \n         // If there is more than one candidate, first winnow them down\n         // by considering extra conditions (nested obligations and so\n@@ -1050,7 +1051,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => { return Ok(()); }\n         };\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // ok to skip binder because the substs on closure types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::ty_closure(id, ref substs) => (id, substs.clone()),\n             ty::ty_infer(ty::TyVar(_)) => {\n@@ -1093,7 +1097,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(());\n         }\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // ok to skip binder because what we are inspecting doesn't involve bound regions\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         match self_ty.sty {\n             ty::ty_infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n@@ -1125,8 +1130,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidates: &mut SelectionCandidateSet<'tcx>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-        debug!(\"assemble_candidates_from_impls(self_ty={})\", self_ty.repr(self.tcx()));\n+        debug!(\"assemble_candidates_from_impls(obligation={})\", obligation.repr(self.tcx()));\n \n         let def_id = obligation.predicate.def_id();\n         let all_impls = self.all_impls(def_id);\n@@ -1152,15 +1156,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               candidates: &mut SelectionCandidateSet<'tcx>)\n                                               -> Result<(), SelectionError<'tcx>>\n     {\n-\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // OK to skip binder here because the tests we do below do not involve bound regions\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         debug!(\"assemble_candidates_from_default_impls(self_ty={})\", self_ty.repr(self.tcx()));\n \n         let def_id = obligation.predicate.def_id();\n \n         if ty::trait_has_default_impl(self.tcx(), def_id) {\n             match self_ty.sty {\n-                ty::ty_trait(..) |\n+                ty::ty_trait(..) => {\n+                    // For object types, we don't know what the closed\n+                    // over types are. For most traits, this means we\n+                    // conservatively say nothing; a candidate may be\n+                    // added by `assemble_candidates_from_object_ty`.\n+                    // However, for the kind of magic reflect trait,\n+                    // we consider it to be implemented even for\n+                    // object types, because it just lets you reflect\n+                    // onto the object type, not into the object's\n+                    // interior.\n+                    if ty::has_attr(self.tcx(), def_id, \"rustc_reflect_like\") {\n+                        candidates.vec.push(DefaultImplObjectCandidate(def_id));\n+                    }\n+                }\n                 ty::ty_param(..) |\n                 ty::ty_projection(..) => {\n                     // In these cases, we don't know what the actual\n@@ -1210,10 +1227,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           obligation: &TraitObligation<'tcx>,\n                                           candidates: &mut SelectionCandidateSet<'tcx>)\n     {\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-\n         debug!(\"assemble_candidates_from_object_ty(self_ty={})\",\n-               self_ty.repr(self.tcx()));\n+               self.infcx.shallow_resolve(*obligation.self_ty().skip_binder()).repr(self.tcx()));\n \n         // Object-safety candidates are only applicable to object-safe\n         // traits. Including this check is useful because it helps\n@@ -1222,47 +1237,56 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // self-type from one of the other inputs. Without this check,\n         // these cases wind up being considered ambiguous due to a\n         // (spurious) ambiguity introduced here.\n-        if !object_safety::is_object_safe(self.tcx(), obligation.predicate.to_poly_trait_ref()) {\n+        let predicate_trait_ref = obligation.predicate.to_poly_trait_ref();\n+        if !object_safety::is_object_safe(self.tcx(), predicate_trait_ref.def_id()) {\n             return;\n         }\n \n-        let poly_trait_ref = match self_ty.sty {\n-            ty::ty_trait(ref data) => {\n-                match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n-                    Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n-                        if data.bounds.builtin_bounds.contains(&bound) {\n-                            debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n-                            pushing candidate\");\n-                            candidates.vec.push(BuiltinObjectCandidate);\n-                            return;\n+        self.infcx.try(|snapshot| {\n+            let bound_self_ty =\n+                self.infcx.resolve_type_vars_if_possible(&obligation.self_ty());\n+            let (self_ty, _) =\n+                self.infcx().skolemize_late_bound_regions(&bound_self_ty, snapshot);\n+            let poly_trait_ref = match self_ty.sty {\n+                ty::ty_trait(ref data) => {\n+                    match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n+                        Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n+                            if data.bounds.builtin_bounds.contains(&bound) {\n+                                debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n+                                        pushing candidate\");\n+                                candidates.vec.push(BuiltinObjectCandidate);\n+                                return Ok(());\n+                            }\n                         }\n+                        _ => {}\n                     }\n-                    _ => {}\n+\n+                    data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+                }\n+                ty::ty_infer(ty::TyVar(_)) => {\n+                    debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n+                    candidates.ambiguous = true; // could wind up being an object type\n+                    return Ok(());\n+                }\n+                _ => {\n+                    return Ok(());\n                 }\n+            };\n \n-                data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n-            }\n-            ty::ty_infer(ty::TyVar(_)) => {\n-                debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n-                candidates.ambiguous = true; // could wind up being an object type\n-                return;\n-            }\n-            _ => {\n-                return;\n-            }\n-        };\n+            debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={}\",\n+                   poly_trait_ref.repr(self.tcx()));\n \n-        debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={}\",\n-               poly_trait_ref.repr(self.tcx()));\n+            // see whether the object trait can be upcast to the trait we are looking for\n+            let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n+            if upcast_trait_refs.len() > 1 {\n+                // can be upcast in many ways; need more type information\n+                candidates.ambiguous = true;\n+            } else if upcast_trait_refs.len() == 1 {\n+                candidates.vec.push(ObjectCandidate);\n+            }\n \n-        // see whether the object trait can be upcast to the trait we are looking for\n-        let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n-        if upcast_trait_refs.len() > 1 {\n-            // can be upcast in many ways; need more type information\n-            candidates.ambiguous = true;\n-        } else if upcast_trait_refs.len() == 1 {\n-            candidates.vec.push(ObjectCandidate);\n-        }\n+            Ok::<(),()>(())\n+        }).unwrap();\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -1397,23 +1421,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n         return match self_ty.sty {\n-            ty::ty_infer(ty::IntVar(_))\n-            | ty::ty_infer(ty::FloatVar(_))\n-            | ty::ty_uint(_)\n-            | ty::ty_int(_)\n-            | ty::ty_bool\n-            | ty::ty_float(_)\n-            | ty::ty_bare_fn(..)\n-            | ty::ty_char => {\n+            ty::ty_infer(ty::IntVar(_)) |\n+            ty::ty_infer(ty::FloatVar(_)) |\n+            ty::ty_uint(_) |\n+            ty::ty_int(_) |\n+            ty::ty_bool |\n+            ty::ty_float(_) |\n+            ty::ty_bare_fn(..) |\n+            ty::ty_char => {\n                 // safe for everything\n-                Ok(If(Vec::new()))\n+                ok_if(Vec::new())\n             }\n \n             ty::ty_uniq(_) => {  // Box<T>\n                 match bound {\n                     ty::BoundCopy => Err(Unimplemented),\n \n-                    ty::BoundSized => Ok(If(Vec::new())),\n+                    ty::BoundSized => ok_if(Vec::new()),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1423,7 +1447,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::ty_ptr(..) => {     // *const T, *mut T\n                 match bound {\n-                    ty::BoundCopy | ty::BoundSized => Ok(If(Vec::new())),\n+                    ty::BoundCopy | ty::BoundSized => ok_if(Vec::new()),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1436,7 +1460,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundSized => Err(Unimplemented),\n                     ty::BoundCopy => {\n                         if data.bounds.builtin_bounds.contains(&bound) {\n-                            Ok(If(Vec::new()))\n+                            ok_if(Vec::new())\n                         } else {\n                             // Recursively check all supertraits to find out if any further\n                             // bounds are required and thus we must fulfill.\n@@ -1446,7 +1470,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             let desired_def_id = obligation.predicate.def_id();\n                             for tr in util::supertraits(self.tcx(), principal) {\n                                 if tr.def_id() == desired_def_id {\n-                                    return Ok(If(Vec::new()))\n+                                    return ok_if(Vec::new())\n                                 }\n                             }\n \n@@ -1468,11 +1492,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             ast::MutMutable => Err(Unimplemented),\n \n                             // &T is always copyable\n-                            ast::MutImmutable => Ok(If(Vec::new())),\n+                            ast::MutImmutable => ok_if(Vec::new()),\n                         }\n                     }\n \n-                    ty::BoundSized => Ok(If(Vec::new())),\n+                    ty::BoundSized => ok_if(Vec::new()),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1486,7 +1510,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundCopy => {\n                         match *len {\n                             // [T, ..n] is copy iff T is copy\n-                            Some(_) => Ok(If(vec![element_ty])),\n+                            Some(_) => ok_if(vec![element_ty]),\n \n                             // [T] is unsized and hence affine\n                             None => Err(Unimplemented),\n@@ -1495,7 +1519,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     ty::BoundSized => {\n                         if len.is_some() {\n-                            Ok(If(Vec::new()))\n+                            ok_if(Vec::new())\n                         } else {\n                             Err(Unimplemented)\n                         }\n@@ -1519,7 +1543,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-            ty::ty_tup(ref tys) => Ok(If(tys.clone())),\n+            ty::ty_tup(ref tys) => ok_if(tys.clone()),\n \n             ty::ty_closure(def_id, substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n@@ -1544,11 +1568,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // unsized, so the closure struct as a whole must be\n                 // Sized.\n                 if bound == ty::BoundSized {\n-                    return Ok(If(Vec::new()));\n+                    return ok_if(Vec::new());\n                 }\n \n                 match self.closure_typer.closure_upvars(def_id, substs) {\n-                    Some(upvars) => Ok(If(upvars.iter().map(|c| c.ty).collect())),\n+                    Some(upvars) => ok_if(upvars.iter().map(|c| c.ty).collect()),\n                     None => {\n                         debug!(\"assemble_builtin_bound_candidates: no upvar types available yet\");\n                         Ok(AmbiguousBuiltin)\n@@ -1590,7 +1614,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(AmbiguousBuiltin)\n             }\n \n-            ty::ty_err => Ok(If(Vec::new())),\n+            ty::ty_err => ok_if(Vec::new()),\n \n             ty::ty_infer(ty::FreshTy(_))\n             | ty::ty_infer(ty::FreshIntTy(_)) => {\n@@ -1601,6 +1625,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n+        fn ok_if<'tcx>(v: Vec<Ty<'tcx>>)\n+                       -> Result<BuiltinBoundConditions<'tcx>, SelectionError<'tcx>> {\n+            Ok(If(ty::Binder(v)))\n+        }\n+\n         fn nominal<'cx, 'tcx>(bound: ty::BuiltinBound,\n                               types: Vec<Ty<'tcx>>)\n                               -> Result<BuiltinBoundConditions<'tcx>, SelectionError<'tcx>>\n@@ -1611,7 +1640,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::BoundCopy => Ok(ParameterBuiltin),\n \n                 // Sized if all the component types are sized.\n-                ty::BoundSized => Ok(If(types)),\n+                ty::BoundSized => ok_if(types),\n \n                 // Shouldn't be coming through here.\n                 ty::BoundSend | ty::BoundSync => unreachable!(),\n@@ -1714,8 +1743,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn collect_predicates_for_types(&mut self,\n                                     obligation: &TraitObligation<'tcx>,\n                                     trait_def_id: ast::DefId,\n-                                    types: Vec<Ty<'tcx>>) -> Vec<PredicateObligation<'tcx>> {\n-\n+                                    types: ty::Binder<Vec<Ty<'tcx>>>)\n+                                    -> Vec<PredicateObligation<'tcx>>\n+    {\n         let derived_cause = match self.tcx().lang_items.to_builtin_kind(trait_def_id) {\n             Some(_) => {\n                 self.derived_cause(obligation, BuiltinDerivedObligation)\n@@ -1725,43 +1755,52 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        let normalized = project::normalize_with_depth(self, obligation.cause.clone(),\n-                                                       obligation.recursion_depth + 1,\n-                                                       &types);\n-\n-        let obligations = normalized.value.iter().map(|&nested_ty| {\n-            // the obligation might be higher-ranked, e.g. for<'a> &'a\n-            // int : Copy. In that case, we will wind up with\n-            // late-bound regions in the `nested` vector. So for each\n-            // one we instantiate to a skolemized region, do our work\n-            // to produce something like `&'0 int : Copy`, and then\n-            // re-bind it. This is a bit of busy-work but preserves\n-            // the invariant that we only manipulate free regions, not\n-            // bound ones.\n+        // Because the types were potentially derived from\n+        // higher-ranked obligations they may reference late-bound\n+        // regions. For example, `for<'a> Foo<&'a int> : Copy` would\n+        // yield a type like `for<'a> &'a int`. In general, we\n+        // maintain the invariant that we never manipulate bound\n+        // regions, so we have to process these bound regions somehow.\n+        //\n+        // The strategy is to:\n+        //\n+        // 1. Instantiate those regions to skolemized regions (e.g.,\n+        //    `for<'a> &'a int` becomes `&0 int`.\n+        // 2. Produce something like `&'0 int : Copy`\n+        // 3. Re-bind the regions back to `for<'a> &'a int : Copy`\n+\n+        // Move the binder into the individual types\n+        let bound_types: Vec<ty::Binder<Ty<'tcx>>> =\n+            types.skip_binder()\n+                 .iter()\n+                 .map(|&nested_ty| ty::Binder(nested_ty))\n+                 .collect();\n+\n+        // For each type, produce a vector of resulting obligations\n+        let obligations: Result<Vec<Vec<_>>, _> = bound_types.iter().map(|nested_ty| {\n             self.infcx.try(|snapshot| {\n                 let (skol_ty, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(&ty::Binder(nested_ty), snapshot);\n-                let skol_predicate =\n-                    util::predicate_for_trait_def(\n-                        self.tcx(),\n-                        derived_cause.clone(),\n-                        trait_def_id,\n-                        obligation.recursion_depth + 1,\n-                        skol_ty);\n-                match skol_predicate {\n-                    Ok(skol_predicate) => Ok(self.infcx().plug_leaks(skol_map, snapshot,\n-                                                                     &skol_predicate)),\n-                    Err(ErrorReported) => Err(ErrorReported)\n-                }\n+                    self.infcx().skolemize_late_bound_regions(nested_ty, snapshot);\n+                let Normalized { value: normalized_ty, mut obligations } =\n+                    project::normalize_with_depth(self,\n+                                                  obligation.cause.clone(),\n+                                                  obligation.recursion_depth + 1,\n+                                                  &skol_ty);\n+                let skol_obligation =\n+                    try!(util::predicate_for_trait_def(self.tcx(),\n+                                                       derived_cause.clone(),\n+                                                       trait_def_id,\n+                                                       obligation.recursion_depth + 1,\n+                                                       normalized_ty));\n+                obligations.push(skol_obligation);\n+                Ok(self.infcx().plug_leaks(skol_map, snapshot, &obligations))\n             })\n-        }).collect::<Result<Vec<PredicateObligation<'tcx>>, _>>();\n+        }).collect();\n \n+        // Flatten those vectors (couldn't do it above due `collect`)\n         match obligations {\n-            Ok(mut obls) => {\n-                obls.push_all(&normalized.obligations);\n-                obls\n-            },\n-            Err(ErrorReported) => Vec::new()\n+            Ok(obligations) => obligations.into_iter().flat_map(|o| o.into_iter()).collect(),\n+            Err(ErrorReported) => Vec::new(),\n         }\n     }\n \n@@ -1798,7 +1837,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             DefaultImplCandidate(trait_def_id) => {\n-                let data = try!(self.confirm_default_impl_candidate(obligation, trait_def_id));\n+                let data = self.confirm_default_impl_candidate(obligation, trait_def_id);\n+                Ok(VtableDefaultImpl(data))\n+            }\n+\n+            DefaultImplObjectCandidate(trait_def_id) => {\n+                let data = self.confirm_default_impl_object_candidate(obligation, trait_def_id);\n                 Ok(VtableDefaultImpl(data))\n             }\n \n@@ -1900,7 +1944,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn vtable_builtin_data(&mut self,\n                            obligation: &TraitObligation<'tcx>,\n                            bound: ty::BuiltinBound,\n-                           nested: Vec<Ty<'tcx>>)\n+                           nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n         let trait_def = match self.tcx().lang_items.from_builtin_kind(bound) {\n@@ -1927,17 +1971,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// 2. For each where-clause `C` declared on `Foo`, `[Self => X] C` holds.\n     fn confirm_default_impl_candidate(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n-                                      impl_def_id: ast::DefId)\n-                              -> Result<VtableDefaultImplData<PredicateObligation<'tcx>>,\n-                                        SelectionError<'tcx>>\n+                                      trait_def_id: ast::DefId)\n+                                      -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_default_impl_candidate({}, {})\",\n                obligation.repr(self.tcx()),\n-               impl_def_id.repr(self.tcx()));\n+               trait_def_id.repr(self.tcx()));\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n+        // binder is moved below\n+        let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n         match self.constituent_types_for_ty(self_ty) {\n-            Some(types) => Ok(self.vtable_default_impl(obligation, impl_def_id, types)),\n+            Some(types) => self.vtable_default_impl(obligation, trait_def_id, ty::Binder(types)),\n             None => {\n                 self.tcx().sess.bug(\n                     &format!(\n@@ -1947,33 +1991,72 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    fn confirm_default_impl_object_candidate(&mut self,\n+                                             obligation: &TraitObligation<'tcx>,\n+                                             trait_def_id: ast::DefId)\n+                                             -> VtableDefaultImplData<PredicateObligation<'tcx>>\n+    {\n+        debug!(\"confirm_default_impl_object_candidate({}, {})\",\n+               obligation.repr(self.tcx()),\n+               trait_def_id.repr(self.tcx()));\n+\n+        assert!(ty::has_attr(self.tcx(), trait_def_id, \"rustc_reflect_like\"));\n+\n+        // OK to skip binder, it is reintroduced below\n+        let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n+        match self_ty.sty {\n+            ty::ty_trait(ref data) => {\n+                // OK to skip the binder, it is reintroduced below\n+                let input_types = data.principal.skip_binder().substs.types.get_slice(TypeSpace);\n+                let assoc_types = data.bounds.projection_bounds\n+                                             .iter()\n+                                             .map(|pb| pb.skip_binder().ty);\n+                let all_types: Vec<_> = input_types.iter().cloned()\n+                                                          .chain(assoc_types)\n+                                                          .collect();\n+\n+                // reintroduce the two binding levels we skipped, then flatten into one\n+                let all_types = ty::Binder(ty::Binder(all_types));\n+                let all_types = ty::flatten_late_bound_regions(self.tcx(), &all_types);\n+\n+                self.vtable_default_impl(obligation, trait_def_id, all_types)\n+            }\n+            _ => {\n+                self.tcx().sess.bug(\n+                    &format!(\n+                        \"asked to confirm default object implementation for non-object type: {}\",\n+                        self_ty.repr(self.tcx())));\n+            }\n+        }\n+    }\n+\n     /// See `confirm_default_impl_candidate`\n     fn vtable_default_impl(&mut self,\n                            obligation: &TraitObligation<'tcx>,\n                            trait_def_id: ast::DefId,\n-                           nested: Vec<Ty<'tcx>>)\n+                           nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n+        debug!(\"vtable_default_impl_data: nested={}\", nested.repr(self.tcx()));\n \n         let mut obligations = self.collect_predicates_for_types(obligation,\n                                                                 trait_def_id,\n                                                                 nested);\n \n-        let _: Result<(),()> = self.infcx.try(|snapshot| {\n-            let (_, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n-\n-            let substs = obligation.predicate.to_poly_trait_ref().substs();\n-            let trait_obligations = self.impl_or_trait_obligations(obligation.cause.clone(),\n-                                                                   obligation.recursion_depth + 1,\n-                                                                   trait_def_id,\n-                                                                   substs,\n-                                                                   skol_map,\n-                                                                   snapshot);\n-            obligations.push_all(trait_obligations.as_slice());\n-            Ok(())\n+        let trait_obligations: Result<VecPerParamSpace<_>,()> = self.infcx.try(|snapshot| {\n+            let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n+            let (trait_ref, skol_map) =\n+                self.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n+            Ok(self.impl_or_trait_obligations(obligation.cause.clone(),\n+                                              obligation.recursion_depth + 1,\n+                                              trait_def_id,\n+                                              &trait_ref.substs,\n+                                              skol_map,\n+                                              snapshot))\n         });\n \n+        obligations.extend(trait_obligations.unwrap().into_iter()); // no Errors in that code above\n+\n         debug!(\"vtable_default_impl_data: obligations={}\", obligations.repr(self.tcx()));\n \n         VtableDefaultImplData {\n@@ -2010,7 +2093,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                    impl_def_id: ast::DefId,\n                    substs: Normalized<'tcx, Substs<'tcx>>,\n                    cause: ObligationCause<'tcx>,\n-                   recursion_depth: uint,\n+                   recursion_depth: usize,\n                    skol_map: infer::SkolemizationMap,\n                    snapshot: &infer::CombinedSnapshot)\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n@@ -2047,7 +2130,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"confirm_object_candidate({})\",\n                obligation.repr(self.tcx()));\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // FIXME skipping binder here seems wrong -- we should\n+        // probably flatten the binder from the obligation and the\n+        // binder from the object. Have to try to make a broken test\n+        // case that results. -nmatsakis\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n             ty::ty_trait(ref data) => {\n                 data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n@@ -2085,15 +2172,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"confirm_fn_pointer_candidate({})\",\n                obligation.repr(self.tcx()));\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // ok to skip binder; it is reintroduced below\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let sig = ty::ty_fn_sig(self_ty);\n-        let ty::Binder((trait_ref, _)) =\n+        let trait_ref =\n             util::closure_trait_ref_and_return_type(self.tcx(),\n                                                     obligation.predicate.def_id(),\n                                                     self_ty,\n                                                     sig,\n-                                                    util::TupleArgumentsFlag::Yes);\n-        let trait_ref = ty::Binder(trait_ref);\n+                                                    util::TupleArgumentsFlag::Yes)\n+            .map_bound(|(trait_ref, _)| trait_ref);\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.predicate.to_poly_trait_ref(),\n@@ -2142,9 +2230,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///\n     ///     impl Fn(int) for Closure { ... }\n     ///\n-    /// Now imagine our obligation is `Fn(uint) for Closure`. So far\n+    /// Now imagine our obligation is `Fn(usize) for Closure`. So far\n     /// we have matched the self-type `Closure`. At this point we'll\n-    /// compare the `int` to `uint` and generate an error.\n+    /// compare the `int` to `usize` and generate an error.\n     ///\n     /// Note that this checking occurs *after* the impl has selected,\n     /// because these output type parameters should not affect the\n@@ -2441,13 +2529,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// impl.\n     fn impl_or_trait_obligations(&mut self,\n                                  cause: ObligationCause<'tcx>,\n-                                 recursion_depth: uint,\n+                                 recursion_depth: usize,\n                                  def_id: ast::DefId, // of impl or trait\n                                  substs: &Substs<'tcx>, // for impl or trait\n                                  skol_map: infer::SkolemizationMap,\n                                  snapshot: &infer::CombinedSnapshot)\n                                  -> VecPerParamSpace<PredicateObligation<'tcx>>\n     {\n+        debug!(\"impl_or_trait_obligations(def_id={})\", def_id.repr(self.tcx()));\n+\n         let predicates = ty::lookup_predicates(self.tcx(), def_id);\n         let predicates = predicates.instantiate(self.tcx(), substs);\n         let predicates = normalize_with_depth(self, cause.clone(), recursion_depth, &predicates);\n@@ -2530,6 +2620,7 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n             ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n             ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n             DefaultImplCandidate(t) => format!(\"DefaultImplCandidate({:?})\", t),\n+            DefaultImplObjectCandidate(t) => format!(\"DefaultImplObjectCandidate({:?})\", t),\n             ProjectionCandidate => format!(\"ProjectionCandidate\"),\n             FnPointerCandidate => format!(\"FnPointerCandidate\"),\n             ObjectCandidate => format!(\"ObjectCandidate\"),"}, {"sha": "7c7db4a64c02eec186a47ad066fbe5100361d566", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -209,6 +209,47 @@ pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Iterator over def-ids of supertraits\n+\n+pub struct SupertraitDefIds<'cx, 'tcx:'cx> {\n+    tcx: &'cx ty::ctxt<'tcx>,\n+    stack: Vec<ast::DefId>,\n+    visited: FnvHashSet<ast::DefId>,\n+}\n+\n+pub fn supertrait_def_ids<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n+                                     trait_def_id: ast::DefId)\n+                                     -> SupertraitDefIds<'cx, 'tcx>\n+{\n+    SupertraitDefIds {\n+        tcx: tcx,\n+        stack: vec![trait_def_id],\n+        visited: Some(trait_def_id).into_iter().collect(),\n+    }\n+}\n+\n+impl<'cx, 'tcx> Iterator for SupertraitDefIds<'cx, 'tcx> {\n+    type Item = ast::DefId;\n+\n+    fn next(&mut self) -> Option<ast::DefId> {\n+        let def_id = match self.stack.pop() {\n+            Some(def_id) => def_id,\n+            None => { return None; }\n+        };\n+\n+        let predicates = ty::lookup_super_predicates(self.tcx, def_id);\n+        let visited = &mut self.visited;\n+        self.stack.extend(\n+            predicates.predicates\n+                      .iter()\n+                      .filter_map(|p| p.to_opt_poly_trait_ref())\n+                      .map(|t| t.def_id())\n+                      .filter(|&super_def_id| visited.insert(super_def_id)));\n+        Some(def_id)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Other\n ///////////////////////////////////////////////////////////////////////////\n@@ -278,7 +319,7 @@ impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n /// See `super::obligations_for_generics`\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,\n-                                     recursion_depth: uint,\n+                                     recursion_depth: usize,\n                                      generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> VecPerParamSpace<PredicateObligation<'tcx>>\n {\n@@ -316,7 +357,7 @@ pub fn trait_ref_for_builtin_bound<'tcx>(\n pub fn predicate_for_trait_ref<'tcx>(\n     cause: ObligationCause<'tcx>,\n     trait_ref: Rc<ty::TraitRef<'tcx>>,\n-    recursion_depth: uint)\n+    recursion_depth: usize)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n     Ok(Obligation {\n@@ -330,7 +371,7 @@ pub fn predicate_for_trait_def<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     trait_def_id: ast::DefId,\n-    recursion_depth: uint,\n+    recursion_depth: usize,\n     param_ty: Ty<'tcx>)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n@@ -345,7 +386,7 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n-    recursion_depth: uint,\n+    recursion_depth: usize,\n     param_ty: Ty<'tcx>)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n@@ -377,7 +418,7 @@ pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                object_trait_ref: ty::PolyTraitRef<'tcx>,\n                                                trait_def_id: ast::DefId,\n-                                               method_offset_in_trait: uint) -> uint {\n+                                               method_offset_in_trait: usize) -> usize {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by\n     // iterating down the supertraits of the object's trait until"}, {"sha": "c95f27af0c438af87bb6608c1e7d2def72ffdeb3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 146, "deletions": 101, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -261,8 +261,8 @@ pub struct field_ty {\n #[derive(Copy, PartialEq, Eq, Hash)]\n pub struct creader_cache_key {\n     pub cnum: CrateNum,\n-    pub pos: uint,\n-    pub len: uint\n+    pub pos: usize,\n+    pub len: usize\n }\n \n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n@@ -288,18 +288,18 @@ pub enum AutoAdjustment<'tcx> {\n \n #[derive(Clone, PartialEq, Debug)]\n pub enum UnsizeKind<'tcx> {\n-    // [T, ..n] -> [T], the uint field is n.\n-    UnsizeLength(uint),\n+    // [T, ..n] -> [T], the usize field is n.\n+    UnsizeLength(usize),\n     // An unsize coercion applied to the tail field of a struct.\n-    // The uint is the index of the type parameter which is unsized.\n-    UnsizeStruct(Box<UnsizeKind<'tcx>>, uint),\n+    // The usize is the index of the type parameter which is unsized.\n+    UnsizeStruct(Box<UnsizeKind<'tcx>>, usize),\n     UnsizeVtable(TyTrait<'tcx>, /* the self type of the trait */ Ty<'tcx>),\n     UnsizeUpcast(Ty<'tcx>),\n }\n \n #[derive(Clone, Debug)]\n pub struct AutoDerefRef<'tcx> {\n-    pub autoderefs: uint,\n+    pub autoderefs: usize,\n     pub autoref: Option<AutoRef<'tcx>>\n }\n \n@@ -423,7 +423,7 @@ pub fn type_of_adjust<'tcx>(cx: &ctxt<'tcx>, adj: &AutoAdjustment<'tcx>) -> Opti\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Debug)]\n pub struct param_index {\n     pub space: subst::ParamSpace,\n-    pub index: uint\n+    pub index: usize\n }\n \n #[derive(Clone, Debug)]\n@@ -452,10 +452,10 @@ pub struct MethodParam<'tcx> {\n     // instantiated with fresh variables at this point.\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n-    // index of uint in the list of trait items. Note that this is NOT\n+    // index of usize in the list of trait items. Note that this is NOT\n     // the index into the vtable, because the list of trait items\n     // includes associated types.\n-    pub method_num: uint,\n+    pub method_num: usize,\n \n     /// The impl for the trait from which the method comes. This\n     /// should only be used for certain linting/heuristic purposes\n@@ -474,13 +474,13 @@ pub struct MethodObject<'tcx> {\n     pub object_trait_id: ast::DefId,\n \n     // index of the method to be invoked amongst the trait's items\n-    pub method_num: uint,\n+    pub method_num: usize,\n \n     // index into the actual runtime vtable.\n     // the vtable is formed by concatenating together the method lists of\n     // the base object trait and all supertraits; this is the index into\n     // that vtable\n-    pub vtable_index: uint,\n+    pub vtable_index: usize,\n }\n \n #[derive(Clone)]\n@@ -511,7 +511,7 @@ pub struct MethodCall {\n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy)]\n pub enum ExprAdjustment {\n     NoAdjustment,\n-    AutoDeref(uint),\n+    AutoDeref(usize),\n     AutoObject\n }\n \n@@ -530,7 +530,7 @@ impl MethodCall {\n         }\n     }\n \n-    pub fn autoderef(expr_id: ast::NodeId, autoderef: uint) -> MethodCall {\n+    pub fn autoderef(expr_id: ast::NodeId, autoderef: usize) -> MethodCall {\n         MethodCall {\n             expr_id: expr_id,\n             adjustment: AutoDeref(1 + autoderef)\n@@ -564,7 +564,7 @@ pub enum vtable_origin<'tcx> {\n       The first argument is the param index (identifying T in the example),\n       and the second is the bound number (identifying baz)\n      */\n-    vtable_param(param_index, uint),\n+    vtable_param(param_index, usize),\n \n     /*\n       Vtable automatically generated for a closure. The def ID is the\n@@ -639,12 +639,12 @@ impl<'tcx> CtxtArenas<'tcx> {\n pub struct CommonTypes<'tcx> {\n     pub bool: Ty<'tcx>,\n     pub char: Ty<'tcx>,\n-    pub int: Ty<'tcx>,\n+    pub isize: Ty<'tcx>,\n     pub i8: Ty<'tcx>,\n     pub i16: Ty<'tcx>,\n     pub i32: Ty<'tcx>,\n     pub i64: Ty<'tcx>,\n-    pub uint: Ty<'tcx>,\n+    pub usize: Ty<'tcx>,\n     pub u8: Ty<'tcx>,\n     pub u16: Ty<'tcx>,\n     pub u32: Ty<'tcx>,\n@@ -877,10 +877,10 @@ macro_rules! sty_debug_print {\n             use middle::ty;\n             #[derive(Copy)]\n             struct DebugStat {\n-                total: uint,\n-                region_infer: uint,\n-                ty_infer: uint,\n-                both_infer: uint,\n+                total: usize,\n+                region_infer: usize,\n+                ty_infer: usize,\n+                both_infer: usize,\n             }\n \n             pub fn go(tcx: &ty::ctxt) {\n@@ -1024,7 +1024,7 @@ pub fn type_has_late_bound_regions(ty: Ty) -> bool {\n ///\n /// So, for example, consider a type like the following, which has two binders:\n ///\n-///    for<'a> fn(x: for<'b> fn(&'a int, &'b int))\n+///    for<'a> fn(x: for<'b> fn(&'a isize, &'b isize))\n ///    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ outer scope\n ///                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~  inner scope\n ///\n@@ -1108,16 +1108,16 @@ pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n \n impl<'tcx> PolyFnSig<'tcx> {\n     pub fn inputs(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n-        ty::Binder(self.0.inputs.clone())\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs.clone())\n     }\n-    pub fn input(&self, index: uint) -> ty::Binder<Ty<'tcx>> {\n-        ty::Binder(self.0.inputs[index])\n+    pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs[index])\n     }\n     pub fn output(&self) -> ty::Binder<FnOutput<'tcx>> {\n-        ty::Binder(self.0.output.clone())\n+        self.map_bound_ref(|fn_sig| fn_sig.output.clone())\n     }\n     pub fn variadic(&self) -> bool {\n-        self.0.variadic\n+        self.skip_binder().variadic\n     }\n }\n \n@@ -1132,7 +1132,7 @@ pub struct ParamTy {\n /// regions (and perhaps later types) in a higher-ranked setting. In\n /// particular, imagine a type like this:\n ///\n-///     for<'a> fn(for<'b> fn(&'b int, &'a int), &'a char)\n+///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n ///     ^          ^            |        |         |\n ///     |          |            |        |         |\n ///     |          +------------+ 1      |         |\n@@ -1149,11 +1149,11 @@ pub struct ParamTy {\n /// count the number of binders, inside out. Some examples should help\n /// clarify what I mean.\n ///\n-/// Let's start with the reference type `&'b int` that is the first\n+/// Let's start with the reference type `&'b isize` that is the first\n /// argument to the inner function. This region `'b` is assigned a De\n /// Bruijn index of 1, meaning \"the innermost binder\" (in this case, a\n /// fn). The region `'a` that appears in the second argument type (`&'a\n-/// int`) would then be assigned a De Bruijn index of 2, meaning \"the\n+/// isize`) would then be assigned a De Bruijn index of 2, meaning \"the\n /// second-innermost binder\". (These indices are written on the arrays\n /// in the diagram).\n ///\n@@ -1234,23 +1234,23 @@ pub enum BorrowKind {\n     /// implicit closure bindings. It is needed when you the closure\n     /// is borrowing or mutating a mutable referent, e.g.:\n     ///\n-    ///    let x: &mut int = ...;\n+    ///    let x: &mut isize = ...;\n     ///    let y = || *x += 5;\n     ///\n     /// If we were to try to translate this closure into a more explicit\n     /// form, we'd encounter an error with the code as written:\n     ///\n-    ///    struct Env { x: & &mut int }\n-    ///    let x: &mut int = ...;\n+    ///    struct Env { x: & &mut isize }\n+    ///    let x: &mut isize = ...;\n     ///    let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n     ///    fn fn_ptr(env: &mut Env) { **env.x += 5; }\n     ///\n     /// This is then illegal because you cannot mutate a `&mut` found\n     /// in an aliasable location. To solve, you'd have to translate with\n     /// an `&mut` borrow:\n     ///\n-    ///    struct Env { x: & &mut int }\n-    ///    let x: &mut int = ...;\n+    ///    struct Env { x: & &mut isize }\n+    ///    let x: &mut isize = ...;\n     ///    let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n     ///    fn fn_ptr(env: &mut Env) { **env.x += 5; }\n     ///\n@@ -1361,7 +1361,7 @@ pub enum sty<'tcx> {\n     ty_enum(DefId, &'tcx Substs<'tcx>),\n     ty_uniq(Ty<'tcx>),\n     ty_str,\n-    ty_vec(Ty<'tcx>, Option<uint>), // Second field is length.\n+    ty_vec(Ty<'tcx>, Option<usize>), // Second field is length.\n     ty_ptr(mt<'tcx>),\n     ty_rptr(&'tcx Region, mt<'tcx>),\n \n@@ -1491,7 +1491,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n }\n \n /// Binder is a binder for higher-ranked lifetimes. It is part of the\n-/// compiler's representation for things like `for<'a> Fn(&'a int)`\n+/// compiler's representation for things like `for<'a> Fn(&'a isize)`\n /// (which would be represented by the type `PolyTraitRef ==\n /// Binder<TraitRef>`). Note that when we skolemize, instantiate,\n /// erase, or otherwise \"discharge\" these bound regions, we change the\n@@ -1519,6 +1519,22 @@ impl<T> Binder<T> {\n     pub fn skip_binder(&self) -> &T {\n         &self.0\n     }\n+\n+    pub fn as_ref(&self) -> Binder<&T> {\n+        ty::Binder(&self.0)\n+    }\n+\n+    pub fn map_bound_ref<F,U>(&self, f: F) -> Binder<U>\n+        where F: FnOnce(&T) -> U\n+    {\n+        self.as_ref().map_bound(f)\n+    }\n+\n+    pub fn map_bound<F,U>(self, f: F) -> Binder<U>\n+        where F: FnOnce(T) -> U\n+    {\n+        ty::Binder(f(self.0))\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq)]\n@@ -1552,9 +1568,9 @@ pub enum type_err<'tcx> {\n     terr_ptr_mutability,\n     terr_ref_mutability,\n     terr_vec_mutability,\n-    terr_tuple_size(expected_found<uint>),\n-    terr_fixed_array_size(expected_found<uint>),\n-    terr_ty_param_size(expected_found<uint>),\n+    terr_tuple_size(expected_found<usize>),\n+    terr_fixed_array_size(expected_found<usize>),\n+    terr_ty_param_size(expected_found<usize>),\n     terr_arg_count,\n     terr_regions_does_not_outlive(Region, Region),\n     terr_regions_not_same(Region, Region),\n@@ -1571,7 +1587,7 @@ pub enum type_err<'tcx> {\n     terr_cyclic_ty,\n     terr_convergence_mismatch(expected_found<bool>),\n     terr_projection_name_mismatched(expected_found<ast::Name>),\n-    terr_projection_bounds_length(expected_found<uint>),\n+    terr_projection_bounds_length(expected_found<usize>),\n }\n \n /// Bounds suitable for a named type parameter like `A` in `fn foo<A>`\n@@ -1600,7 +1616,7 @@ pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n #[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n            Debug, Copy)]\n-#[repr(uint)]\n+#[repr(usize)]\n pub enum BuiltinBound {\n     BoundSend,\n     BoundSized,\n@@ -1628,10 +1644,10 @@ pub fn region_existential_bound<'tcx>(r: ty::Region) -> ExistentialBounds<'tcx>\n }\n \n impl CLike for BuiltinBound {\n-    fn to_usize(&self) -> uint {\n-        *self as uint\n+    fn to_usize(&self) -> usize {\n+        *self as usize\n     }\n-    fn from_usize(v: uint) -> BuiltinBound {\n+    fn from_usize(v: usize) -> BuiltinBound {\n         unsafe { mem::transmute(v) }\n     }\n }\n@@ -2062,8 +2078,7 @@ impl<'tcx> ToPolyTraitRef<'tcx> for Rc<TraitRef<'tcx>> {\n \n impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n-        // We are just preserving the binder levels here\n-        ty::Binder(self.0.trait_ref.clone())\n+        self.map_bound_ref(|trait_pred| trait_pred.trait_ref.clone())\n     }\n }\n \n@@ -2202,8 +2217,8 @@ impl<'tcx> Predicate<'tcx> {\n ///\n /// Here, the `GenericPredicates` for `Foo` would contain a list of bounds like\n /// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n-/// like `Foo<int,uint>`, then the `InstantiatedPredicates` would be `[[],\n-/// [uint:Bar<int>]]`.\n+/// like `Foo<isize,usize>`, then the `InstantiatedPredicates` would be `[[],\n+/// [usize:Bar<isize>]]`.\n #[derive(Clone, Debug)]\n pub struct InstantiatedPredicates<'tcx> {\n     pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n@@ -2545,12 +2560,12 @@ impl<'tcx> CommonTypes<'tcx> {\n             bool: intern_ty(arena, interner, ty_bool),\n             char: intern_ty(arena, interner, ty_char),\n             err: intern_ty(arena, interner, ty_err),\n-            int: intern_ty(arena, interner, ty_int(ast::TyIs(false))),\n+            isize: intern_ty(arena, interner, ty_int(ast::TyIs)),\n             i8: intern_ty(arena, interner, ty_int(ast::TyI8)),\n             i16: intern_ty(arena, interner, ty_int(ast::TyI16)),\n             i32: intern_ty(arena, interner, ty_int(ast::TyI32)),\n             i64: intern_ty(arena, interner, ty_int(ast::TyI64)),\n-            uint: intern_ty(arena, interner, ty_uint(ast::TyUs(false))),\n+            usize: intern_ty(arena, interner, ty_uint(ast::TyUs)),\n             u8: intern_ty(arena, interner, ty_uint(ast::TyU8)),\n             u16: intern_ty(arena, interner, ty_uint(ast::TyU16)),\n             u32: intern_ty(arena, interner, ty_uint(ast::TyU32)),\n@@ -2935,7 +2950,7 @@ impl FlagComputation {\n \n pub fn mk_mach_int<'tcx>(tcx: &ctxt<'tcx>, tm: ast::IntTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyIs(_)   => tcx.types.int,\n+        ast::TyIs   => tcx.types.isize,\n         ast::TyI8   => tcx.types.i8,\n         ast::TyI16  => tcx.types.i16,\n         ast::TyI32  => tcx.types.i32,\n@@ -2945,7 +2960,7 @@ pub fn mk_mach_int<'tcx>(tcx: &ctxt<'tcx>, tm: ast::IntTy) -> Ty<'tcx> {\n \n pub fn mk_mach_uint<'tcx>(tcx: &ctxt<'tcx>, tm: ast::UintTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyUs(_)   => tcx.types.uint,\n+        ast::TyUs   => tcx.types.usize,\n         ast::TyU8   => tcx.types.u8,\n         ast::TyU16  => tcx.types.u16,\n         ast::TyU32  => tcx.types.u32,\n@@ -3004,7 +3019,7 @@ pub fn mk_nil_ptr<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n     mk_ptr(cx, mt {ty: mk_nil(cx), mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_vec<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, sz: Option<uint>) -> Ty<'tcx> {\n+pub fn mk_vec<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, sz: Option<usize>) -> Ty<'tcx> {\n     mk_t(cx, ty_vec(ty, sz))\n }\n \n@@ -3130,9 +3145,9 @@ impl<'tcx> TyS<'tcx> {\n     /// structs or variants. For example:\n     ///\n     /// ```notrust\n-    /// int => { int }\n-    /// Foo<Bar<int>> => { Foo<Bar<int>>, Bar<int>, int }\n-    /// [int] => { [int], int }\n+    /// isize => { isize }\n+    /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n+    /// [isize] => { [isize], isize }\n     /// ```\n     pub fn walk(&'tcx self) -> TypeWalker<'tcx> {\n         TypeWalker::new(self)\n@@ -3143,9 +3158,9 @@ impl<'tcx> TyS<'tcx> {\n     /// example:\n     ///\n     /// ```notrust\n-    /// int => { }\n-    /// Foo<Bar<int>> => { Bar<int>, int }\n-    /// [int] => { int }\n+    /// isize => { }\n+    /// Foo<Bar<isize>> => { Bar<isize>, isize }\n+    /// [isize] => { isize }\n     /// ```\n     pub fn walk_children(&'tcx self) -> TypeWalker<'tcx> {\n         // Walks type reachable from `self` but not `self\n@@ -3343,7 +3358,7 @@ pub fn simd_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     }\n }\n \n-pub fn simd_size(cx: &ctxt, ty: Ty) -> uint {\n+pub fn simd_size(cx: &ctxt, ty: Ty) -> usize {\n     match ty.sty {\n         ty_struct(did, _) => {\n             let fields = lookup_struct_fields(cx, did);\n@@ -3611,8 +3626,8 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n         cache.insert(ty, TC::None);\n \n         let result = match ty.sty {\n-            // uint and int are ffi-unsafe\n-            ty_uint(ast::TyUs(_)) | ty_int(ast::TyIs(_)) => {\n+            // usize and isize are ffi-unsafe\n+            ty_uint(ast::TyUs) | ty_int(ast::TyIs) => {\n                 TC::ReachesFfiUnsafe\n             }\n \n@@ -4175,7 +4190,7 @@ pub fn type_is_fresh(ty: Ty) -> bool {\n \n pub fn type_is_uint(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_infer(IntVar(_)) | ty_uint(ast::TyUs(_)) => true,\n+      ty_infer(IntVar(_)) | ty_uint(ast::TyUs) => true,\n       _ => false\n     }\n }\n@@ -4221,7 +4236,7 @@ pub fn type_is_signed(ty: Ty) -> bool {\n \n pub fn type_is_machine(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_int(ast::TyIs(_)) | ty_uint(ast::TyUs(_)) => false,\n+        ty_int(ast::TyIs) | ty_uint(ast::TyUs) => false,\n         ty_int(..) | ty_uint(..) | ty_float(..) => true,\n         _ => false\n     }\n@@ -4292,7 +4307,7 @@ pub fn array_element_ty<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>\n /// For an enum `t`, `variant` is None only if `t` is a univariant enum.\n pub fn positional_element_ty<'tcx>(cx: &ctxt<'tcx>,\n                                    ty: Ty<'tcx>,\n-                                   i: uint,\n+                                   i: usize,\n                                    variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n \n     match (&ty.sty, variant) {\n@@ -4468,8 +4483,8 @@ pub fn pat_ty_opt<'tcx>(cx: &ctxt<'tcx>, pat: &ast::Pat) -> Option<Ty<'tcx>> {\n // adjustments.  See `expr_ty_adjusted()` instead.\n //\n // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n-// ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n-// instead of \"fn(ty) -> T with T = int\".\n+// ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n+// instead of \"fn(ty) -> T with T = isize\".\n pub fn expr_ty<'tcx>(cx: &ctxt<'tcx>, expr: &ast::Expr) -> Ty<'tcx> {\n     return node_id_to_type(cx, expr.id);\n }\n@@ -4879,7 +4894,7 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n }\n \n pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n-                     -> uint {\n+                     -> usize {\n     let mut i = 0;\n     for f in fields { if f.name == name { return i; } i += 1; }\n     tcx.sess.bug(&format!(\n@@ -4891,7 +4906,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n }\n \n pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n-                              -> Option<uint> {\n+                              -> Option<usize> {\n     trait_items.iter().position(|m| m.name() == id)\n }\n \n@@ -5163,7 +5178,7 @@ fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n     v\n }\n \n-pub fn trait_item<'tcx>(cx: &ctxt<'tcx>, trait_did: ast::DefId, idx: uint)\n+pub fn trait_item<'tcx>(cx: &ctxt<'tcx>, trait_did: ast::DefId, idx: usize)\n                         -> ImplOrTraitItem<'tcx> {\n     let method_def_id = (*ty::trait_item_def_ids(cx, trait_did))[idx].def_id();\n     impl_or_trait_item(cx, method_def_id)\n@@ -5238,10 +5253,10 @@ pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n pub fn associated_type_parameter_index(cx: &ctxt,\n                                        trait_def: &TraitDef,\n                                        associated_type_id: ast::DefId)\n-                                       -> uint {\n+                                       -> usize {\n     for type_parameter_def in trait_def.generics.types.iter() {\n         if type_parameter_def.def_id == associated_type_id {\n-            return type_parameter_def.index as uint\n+            return type_parameter_def.index as usize\n         }\n     }\n     cx.sess.bug(\"couldn't find associated type parameter index\")\n@@ -5792,24 +5807,24 @@ pub fn closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n \n pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool {\n     #![allow(non_upper_case_globals)]\n-    const tycat_other: int = 0;\n-    const tycat_bool: int = 1;\n-    const tycat_char: int = 2;\n-    const tycat_int: int = 3;\n-    const tycat_float: int = 4;\n-    const tycat_raw_ptr: int = 6;\n-\n-    const opcat_add: int = 0;\n-    const opcat_sub: int = 1;\n-    const opcat_mult: int = 2;\n-    const opcat_shift: int = 3;\n-    const opcat_rel: int = 4;\n-    const opcat_eq: int = 5;\n-    const opcat_bit: int = 6;\n-    const opcat_logic: int = 7;\n-    const opcat_mod: int = 8;\n-\n-    fn opcat(op: ast::BinOp) -> int {\n+    const tycat_other: isize = 0;\n+    const tycat_bool: isize = 1;\n+    const tycat_char: isize = 2;\n+    const tycat_int: isize = 3;\n+    const tycat_float: isize = 4;\n+    const tycat_raw_ptr: isize = 6;\n+\n+    const opcat_add: isize = 0;\n+    const opcat_sub: isize = 1;\n+    const opcat_mult: isize = 2;\n+    const opcat_shift: isize = 3;\n+    const opcat_rel: isize = 4;\n+    const opcat_eq: isize = 5;\n+    const opcat_bit: isize = 6;\n+    const opcat_logic: isize = 7;\n+    const opcat_mod: isize = 8;\n+\n+    fn opcat(op: ast::BinOp) -> isize {\n         match op.node {\n           ast::BiAdd => opcat_add,\n           ast::BiSub => opcat_sub,\n@@ -5832,7 +5847,7 @@ pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool\n         }\n     }\n \n-    fn tycat<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> int {\n+    fn tycat<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> isize {\n         if type_is_simd(cx, ty) {\n             return tycat(cx, simd_type(cx, ty))\n         }\n@@ -5854,21 +5869,21 @@ pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool\n     /*other*/   [f, f, f, f,     f,   f,  f,   f,     f],\n     /*bool*/    [f, f, f, f,     t,   t,  t,   t,     f],\n     /*char*/    [f, f, f, f,     t,   t,  f,   f,     f],\n-    /*int*/     [t, t, t, t,     t,   t,  t,   f,     t],\n+    /*isize*/     [t, t, t, t,     t,   t,  t,   f,     t],\n     /*float*/   [t, t, t, f,     t,   t,  f,   f,     f],\n     /*bot*/     [t, t, t, t,     t,   t,  t,   t,     t],\n     /*raw ptr*/ [f, f, f, f,     t,   t,  f,   f,     f]];\n \n-    return tbl[tycat(cx, ty) as uint ][opcat(op) as uint];\n+    return tbl[tycat(cx, ty) as usize ][opcat(op) as usize];\n }\n \n // Returns the repeat count for a repeating vector expression.\n-pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n-    match const_eval::eval_const_expr_partial(tcx, count_expr, Some(tcx.types.uint)) {\n+pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> usize {\n+    match const_eval::eval_const_expr_partial(tcx, count_expr, Some(tcx.types.usize)) {\n         Ok(val) => {\n             let found = match val {\n-                const_eval::const_uint(count) => return count as uint,\n-                const_eval::const_int(count) if count >= 0 => return count as uint,\n+                const_eval::const_uint(count) => return count as usize,\n+                const_eval::const_int(count) if count >= 0 => return count as usize,\n                 const_eval::const_int(_) => \"negative integer\",\n                 const_eval::const_float(_) => \"float\",\n                 const_eval::const_str(_) => \"string\",\n@@ -6737,7 +6752,7 @@ pub fn liberate_late_bound_regions<'tcx, T>(\n pub fn count_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n-    -> uint\n+    -> usize\n     where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n     let (_, skol_map) = replace_late_bound_regions(tcx, value, |_| ty::ReStatic);\n@@ -6753,6 +6768,30 @@ pub fn binds_late_bound_regions<'tcx, T>(\n     count_late_bound_regions(tcx, value) > 0\n }\n \n+/// Flattens two binding levels into one. So `for<'a> for<'b> Foo`\n+/// becomes `for<'a,'b> Foo`.\n+pub fn flatten_late_bound_regions<'tcx, T>(\n+    tcx: &ty::ctxt<'tcx>,\n+    bound2_value: &Binder<Binder<T>>)\n+    -> Binder<T>\n+    where T: TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    let bound0_value = bound2_value.skip_binder().skip_binder();\n+    let value = ty_fold::fold_regions(tcx, bound0_value, |region, current_depth| {\n+        match region {\n+            ty::ReLateBound(debruijn, br) if debruijn.depth >= current_depth => {\n+                // should be true if no escaping regions from bound2_value\n+                assert!(debruijn.depth - current_depth <= 1);\n+                ty::ReLateBound(DebruijnIndex::new(current_depth), br)\n+            }\n+            _ => {\n+                region\n+            }\n+        }\n+    });\n+    Binder(value)\n+}\n+\n pub fn no_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n@@ -6783,8 +6822,8 @@ pub fn erase_late_bound_regions<'tcx, T>(\n ///\n /// The chief purpose of this function is to canonicalize regions so that two\n /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n-/// structurally identical.  For example, `for<'a, 'b> fn(&'a int, &'b int)` and\n-/// `for<'a, 'b> fn(&'b int, &'a int)` will become identical after anonymization.\n+/// structurally identical.  For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n+/// `for<'a, 'b> fn(&'b isize, &'a isize)` will become identical after anonymization.\n pub fn anonymize_late_bound_regions<'tcx, T>(\n     tcx: &ctxt<'tcx>,\n     sig: &Binder<T>)\n@@ -7089,6 +7128,12 @@ impl<'tcx> RegionEscape for Predicate<'tcx> {\n     }\n }\n \n+impl<'tcx,P:RegionEscape> RegionEscape for traits::Obligation<'tcx,P> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.predicate.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n impl<'tcx> RegionEscape for TraitRef<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) ||"}, {"sha": "5d492f1c95e11c81ccb8b4a528e2484a4a3712af", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -15,7 +15,7 @@ use std::iter::Iterator;\n \n pub struct TypeWalker<'tcx> {\n     stack: Vec<Ty<'tcx>>,\n-    last_subtree: uint,\n+    last_subtree: usize,\n }\n \n impl<'tcx> TypeWalker<'tcx> {\n@@ -80,14 +80,14 @@ impl<'tcx> TypeWalker<'tcx> {\n     /// Skips the subtree of types corresponding to the last type\n     /// returned by `next()`.\n     ///\n-    /// Example: Imagine you are walking `Foo<Bar<int>, uint>`.\n+    /// Example: Imagine you are walking `Foo<Bar<int>, usize>`.\n     ///\n     /// ```\n     /// let mut iter: TypeWalker = ...;\n     /// iter.next(); // yields Foo\n     /// iter.next(); // yields Bar<int>\n     /// iter.skip_current_subtree(); // skips int\n-    /// iter.next(); // yields uint\n+    /// iter.next(); // yields usize\n     /// ```\n     pub fn skip_current_subtree(&mut self) {\n         self.stack.truncate(self.last_subtree);"}, {"sha": "752e71bc19131b3dad208ac4f7a9559cf8883d6e", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -18,10 +18,6 @@ use std::borrow::ToOwned;\n use std::dynamic_lib::DynamicLibrary;\n use std::env;\n use std::mem;\n-\n-#[allow(deprecated)]\n-use std::old_path;\n-\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::codemap::{Span, COMMAND_LINE_SP};\n@@ -110,7 +106,6 @@ impl<'a> PluginLoader<'a> {\n                         symbol: String) -> PluginRegistrarFun {\n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(&path);\n-        let path = old_path::Path::new(path.to_str().unwrap());\n \n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,"}, {"sha": "3162c4fc570236d75246364cea365867f97e9ed6", "filename": "src/librustc/plugin/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fplugin%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fplugin%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -47,7 +47,7 @@\n //! #![plugin(myplugin)]\n //! ```\n //!\n-//! See [the compiler plugin guide](../../guide-plugin.html)\n+//! See the [Plugins Chapter](../../book/plugins.html) of the book\n //! for more examples.\n \n pub use self::registry::Registry;"}, {"sha": "c67819ab7e3c42751c327342ed53ab86f73f8bf1", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -439,14 +439,14 @@ macro_rules! options {\n             }\n         }\n \n-        fn parse_uint(slot: &mut uint, v: Option<&str>) -> bool {\n+        fn parse_uint(slot: &mut usize, v: Option<&str>) -> bool {\n             match v.and_then(|s| s.parse().ok()) {\n                 Some(i) => { *slot = i; true },\n                 None => false\n             }\n         }\n \n-        fn parse_opt_uint(slot: &mut Option<uint>, v: Option<&str>) -> bool {\n+        fn parse_opt_uint(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => { *slot = s.parse().ok(); slot.is_some() }\n                 None => { *slot = None; true }\n@@ -518,16 +518,16 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n          \"metadata to mangle symbol names with\"),\n     extra_filename: String = (\"\".to_string(), parse_string,\n          \"extra data to put in each output filename\"),\n-    codegen_units: uint = (1, parse_uint,\n+    codegen_units: usize = (1, parse_uint,\n         \"divide crate into N units to optimize in parallel\"),\n     remark: Passes = (SomePasses(Vec::new()), parse_passes,\n         \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n     no_stack_check: bool = (false, parse_bool,\n         \"disable checks for stack exhaustion (a memory-safety hazard!)\"),\n-    debuginfo: Option<uint> = (None, parse_opt_uint,\n+    debuginfo: Option<usize> = (None, parse_opt_uint,\n         \"debug info emission level, 0 = no debug info, 1 = line tables only, \\\n          2 = full debug info with variable and type information\"),\n-    opt_level: Option<uint> = (None, parse_opt_uint,\n+    opt_level: Option<usize> = (None, parse_opt_uint,\n         \"Optimize with possible levels 0-3\"),\n     debug_assertions: Option<bool> = (None, parse_opt_bool,\n         \"explicitly enable the cfg(debug_assertions) directive\"),\n@@ -604,6 +604,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"Print the size of enums and their variants\"),\n     force_overflow_checks: Option<bool> = (None, parse_opt_bool,\n           \"Force overflow checks on or off\"),\n+    force_dropflag_checks: Option<bool> = (None, parse_opt_bool,\n+          \"Force drop flag checks on or off\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -958,24 +960,6 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n         let mut parts = s.splitn(1, '=');\n         let kind = parts.next().unwrap();\n-        if let Some(name) = parts.next() {\n-            let kind = match kind {\n-                \"dylib\" => cstore::NativeUnknown,\n-                \"framework\" => cstore::NativeFramework,\n-                \"static\" => cstore::NativeStatic,\n-                s => {\n-                    early_error(&format!(\"unknown library kind `{}`, expected \\\n-                                          one of dylib, framework, or static\",\n-                                         s));\n-                }\n-            };\n-            return (name.to_string(), kind)\n-        }\n-\n-        // FIXME(acrichto) remove this once crates have stopped using it, this\n-        //                 is deprecated behavior now.\n-        let mut parts = s.rsplitn(1, ':');\n-        let kind = parts.next().unwrap();\n         let (name, kind) = match (parts.next(), kind) {\n             (None, name) |\n             (Some(name), \"dylib\") => (name, cstore::NativeUnknown),"}, {"sha": "3e3e5e17963cd1ac294782be0b19838f2132c91c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -58,7 +58,7 @@ pub struct Session {\n \n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n-    pub recursion_limit: Cell<uint>,\n+    pub recursion_limit: Cell<usize>,\n \n     pub can_print_warnings: bool\n }\n@@ -106,7 +106,7 @@ impl Session {\n         }\n         self.diagnostic().handler().err(msg)\n     }\n-    pub fn err_count(&self) -> uint {\n+    pub fn err_count(&self) -> usize {\n         self.diagnostic().handler().err_count()\n     }\n     pub fn has_errors(&self) -> bool {"}, {"sha": "60ae053dbaf04eeabc5f1b6684bf6347a8768e6c", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -35,7 +35,7 @@ pub struct ErrorReported;\n pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n     F: FnOnce(U) -> T,\n {\n-    thread_local!(static DEPTH: Cell<uint> = Cell::new(0));\n+    thread_local!(static DEPTH: Cell<usize> = Cell::new(0));\n     if !do_it { return f(u); }\n \n     let old = DEPTH.with(|slot| {\n@@ -196,10 +196,10 @@ pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n /// # Examples\n /// ```\n /// struct Context {\n-///    cache: RefCell<HashMap<uint, uint>>\n+///    cache: RefCell<HashMap<usize, usize>>\n /// }\n ///\n-/// fn factorial(ctxt: &Context, n: uint) -> uint {\n+/// fn factorial(ctxt: &Context, n: usize) -> usize {\n ///     memoized(&ctxt.cache, n, |n| match n {\n ///         0 | 1 => n,\n ///         _ => factorial(ctxt, n - 2) + factorial(ctxt, n - 1)"}, {"sha": "28f8510ce3fee150100523f49c455f82e2c6e7c3", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -10,7 +10,7 @@\n \n use std::cmp;\n \n-pub fn lev_distance(me: &str, t: &str) -> uint {\n+pub fn lev_distance(me: &str, t: &str) -> usize {\n     if me.is_empty() { return t.chars().count(); }\n     if t.is_empty() { return me.chars().count(); }\n "}, {"sha": "d2e0b3aec2f40236d3ac6615a42b8f4629858486", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -30,10 +30,10 @@ pub enum UndoLog<D:SnapshotVecDelegate> {\n     CommittedSnapshot,\n \n     /// New variable with given index was created.\n-    NewElem(uint),\n+    NewElem(usize),\n \n     /// Variable with given index was changed *from* the given value.\n-    SetElem(uint, D::Value),\n+    SetElem(usize, D::Value),\n \n     /// Extensible set of actions\n     Other(D::Undo)\n@@ -48,7 +48,7 @@ pub struct SnapshotVec<D:SnapshotVecDelegate> {\n // Snapshots are tokens that should be created/consumed linearly.\n pub struct Snapshot {\n     // Length of the undo log at the time the snapshot was taken.\n-    length: uint,\n+    length: usize,\n }\n \n pub trait SnapshotVecDelegate {\n@@ -77,7 +77,7 @@ impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n         }\n     }\n \n-    pub fn push(&mut self, elem: D::Value) -> uint {\n+    pub fn push(&mut self, elem: D::Value) -> usize {\n         let len = self.values.len();\n         self.values.push(elem);\n \n@@ -88,20 +88,20 @@ impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n         len\n     }\n \n-    pub fn get<'a>(&'a self, index: uint) -> &'a D::Value {\n+    pub fn get<'a>(&'a self, index: usize) -> &'a D::Value {\n         &self.values[index]\n     }\n \n     /// Returns a mutable pointer into the vec; whatever changes you make here cannot be undone\n     /// automatically, so you should be sure call `record()` with some sort of suitable undo\n     /// action.\n-    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut D::Value {\n+    pub fn get_mut<'a>(&'a mut self, index: usize) -> &'a mut D::Value {\n         &mut self.values[index]\n     }\n \n     /// Updates the element at the given index. The old value will saved (and perhaps restored) if\n     /// a snapshot is active.\n-    pub fn set(&mut self, index: uint, new_elem: D::Value) {\n+    pub fn set(&mut self, index: usize, new_elem: D::Value) {\n         let old_elem = mem::replace(&mut self.values[index], new_elem);\n         if self.in_snapshot() {\n             self.undo_log.push(SetElem(index, old_elem));"}, {"sha": "c3a3a8d582aff91f2fc400141e0b57d16d605234", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -8,17 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub const BOX_FIELD_DROP_GLUE: uint = 1;\n-pub const BOX_FIELD_BODY: uint = 4;\n+pub const BOX_FIELD_DROP_GLUE: usize = 1;\n+pub const BOX_FIELD_BODY: usize = 4;\n \n /// The first half of a fat pointer.\n /// - For a closure, this is the code address.\n /// - For an object or trait instance, this is the address of the box.\n /// - For a slice, this is the base address.\n-pub const FAT_PTR_ADDR: uint = 0;\n+pub const FAT_PTR_ADDR: usize = 0;\n \n /// The second half of a fat pointer.\n /// - For a closure, this is the address of the environment.\n /// - For an object or trait instance, this is the address of the vtable.\n /// - For a slice, this is the length.\n-pub const FAT_PTR_EXTRA: uint = 1;\n+pub const FAT_PTR_EXTRA: usize = 1;"}, {"sha": "9f5751c421ecebe39ad56cc1f866e2bd0a916b19", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -246,7 +246,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // Don't allow the total size of `args` to grow beyond 32,000 bytes.\n         // Windows will raise an error if the argument string is longer than\n         // 32,768, and we leave a bit of extra space for the program name.\n-        const ARG_LENGTH_LIMIT: uint = 32_000;\n+        const ARG_LENGTH_LIMIT: usize = 32_000;\n \n         for member_name in &self.members {\n             let len = member_name.to_string_lossy().len();"}, {"sha": "fe457841e9116c81c5ea88b21240f13b9f3a6c45", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -36,7 +36,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(old_fs)]\n-#![feature(int_uint)]\n #![feature(io)]\n #![feature(old_io)]\n #![feature(old_path)]"}, {"sha": "c7049f750fcdb84d0d2b270dfbbe5de12d416939", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -90,29 +90,29 @@ trait FixedBuffer {\n \n     /// Zero the buffer up until the specified index. The buffer position currently must not be\n     /// greater than that index.\n-    fn zero_until(&mut self, idx: uint);\n+    fn zero_until(&mut self, idx: usize);\n \n     /// Get a slice of the buffer of the specified size. There must be at least that many bytes\n     /// remaining in the buffer.\n-    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8];\n+    fn next<'s>(&'s mut self, len: usize) -> &'s mut [u8];\n \n     /// Get the current buffer. The buffer must already be full. This clears the buffer as well.\n     fn full_buffer<'s>(&'s mut self) -> &'s [u8];\n \n     /// Get the current position of the buffer.\n-    fn position(&self) -> uint;\n+    fn position(&self) -> usize;\n \n     /// Get the number of bytes remaining in the buffer until it is full.\n-    fn remaining(&self) -> uint;\n+    fn remaining(&self) -> usize;\n \n     /// Get the size of the buffer\n-    fn size(&self) -> uint;\n+    fn size(&self) -> usize;\n }\n \n /// A FixedBuffer of 64 bytes useful for implementing Sha256 which has a 64 byte blocksize.\n struct FixedBuffer64 {\n     buffer: [u8; 64],\n-    buffer_idx: uint,\n+    buffer_idx: usize,\n }\n \n impl FixedBuffer64 {\n@@ -174,13 +174,13 @@ impl FixedBuffer for FixedBuffer64 {\n         self.buffer_idx = 0;\n     }\n \n-    fn zero_until(&mut self, idx: uint) {\n+    fn zero_until(&mut self, idx: usize) {\n         assert!(idx >= self.buffer_idx);\n         self.buffer[self.buffer_idx..idx].set_memory(0);\n         self.buffer_idx = idx;\n     }\n \n-    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n+    fn next<'s>(&'s mut self, len: usize) -> &'s mut [u8] {\n         self.buffer_idx += len;\n         return &mut self.buffer[self.buffer_idx - len..self.buffer_idx];\n     }\n@@ -191,11 +191,11 @@ impl FixedBuffer for FixedBuffer64 {\n         return &self.buffer[..64];\n     }\n \n-    fn position(&self) -> uint { self.buffer_idx }\n+    fn position(&self) -> usize { self.buffer_idx }\n \n-    fn remaining(&self) -> uint { 64 - self.buffer_idx }\n+    fn remaining(&self) -> usize { 64 - self.buffer_idx }\n \n-    fn size(&self) -> uint { 64 }\n+    fn size(&self) -> usize { 64 }\n }\n \n /// The StandardPadding trait adds a method useful for Sha256 to a FixedBuffer struct.\n@@ -204,11 +204,11 @@ trait StandardPadding {\n     /// guaranteed to have exactly rem remaining bytes when it returns. If there are not at least\n     /// rem bytes available, the buffer will be zero padded, processed, cleared, and then filled\n     /// with zeros again until only rem bytes are remaining.\n-    fn standard_padding<F>(&mut self, rem: uint, func: F) where F: FnMut(&[u8]);\n+    fn standard_padding<F>(&mut self, rem: usize, func: F) where F: FnMut(&[u8]);\n }\n \n impl <T: FixedBuffer> StandardPadding for T {\n-    fn standard_padding<F>(&mut self, rem: uint, mut func: F) where F: FnMut(&[u8]) {\n+    fn standard_padding<F>(&mut self, rem: usize, mut func: F) where F: FnMut(&[u8]) {\n         let size = self.size();\n \n         self.next(1)[0] = 128;\n@@ -244,7 +244,7 @@ pub trait Digest {\n     fn reset(&mut self);\n \n     /// Get the output size in bits.\n-    fn output_bits(&self) -> uint;\n+    fn output_bits(&self) -> usize;\n \n     /// Convenience function that feeds a string into a digest.\n     ///\n@@ -514,7 +514,7 @@ impl Digest for Sha256 {\n         self.engine.reset(&H256);\n     }\n \n-    fn output_bits(&self) -> uint { 256 }\n+    fn output_bits(&self) -> usize { 256 }\n }\n \n static H256: [u32; 8] = [\n@@ -613,7 +613,7 @@ mod tests {\n \n     /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n     /// correct.\n-    fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n+    fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: usize, expected: &str) {\n         let total_size = 1000000;\n         let buffer: Vec<u8> = repeat('a' as u8).take(blocksize * 2).collect();\n         let mut rng = IsaacRng::new_unseeded();\n@@ -622,7 +622,7 @@ mod tests {\n         digest.reset();\n \n         while count < total_size {\n-            let next: uint = rng.gen_range(0, 2 * blocksize + 1);\n+            let next: usize = rng.gen_range(0, 2 * blocksize + 1);\n             let remaining = total_size - count;\n             let size = if next > remaining { remaining } else { next };\n             digest.input(&buffer[..size]);"}, {"sha": "f9416d53a8fa3a51dcf74ab662d2393d152ab8d3", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -221,7 +221,7 @@ mod svh_visitor {\n \n         SawExprLoop(Option<token::InternedString>),\n         SawExprField(token::InternedString),\n-        SawExprTupField(uint),\n+        SawExprTupField(usize),\n         SawExprBreak(Option<token::InternedString>),\n         SawExprAgain(Option<token::InternedString>),\n "}, {"sha": "d4503ae7fc9872e3309111bb953f80a9324e9ca2", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -27,7 +27,7 @@ const NUM_RETRIES: u32 = 1 << 31;\n // be enough to dissuade an attacker from trying to preemptively create names\n // of that length, but not so huge that we unnecessarily drain the random number\n // generator of entropy.\n-const NUM_RAND_CHARS: uint = 12;\n+const NUM_RAND_CHARS: usize = 12;\n \n impl TempDir {\n     /// Attempts to make a temporary directory inside of `tmpdir` whose name"}, {"sha": "f268a957fe84c80834456cf16c1ee208cbd5acd4", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -335,7 +335,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         return true;\n     }\n \n-    pub fn loans_generated_by(&self, scope: region::CodeExtent) -> Vec<uint> {\n+    pub fn loans_generated_by(&self, scope: region::CodeExtent) -> Vec<usize> {\n         //! Returns a vector of the loans that are generated as\n         //! we enter `scope`.\n \n@@ -727,7 +727,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     /// let a: int;\n     /// a = 10; // ok, even though a is uninitialized\n     ///\n-    /// struct Point { x: uint, y: uint }\n+    /// struct Point { x: usize, y: usize }\n     /// let p: Point;\n     /// p.x = 22; // ok, even though `p` is uninitialized\n     ///"}, {"sha": "b5ceff6124d995f80011b3fea3825693737f4011", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -88,7 +88,7 @@ pub fn check_crate(tcx: &ty::ctxt) {\n                  make_stat(&bccx, bccx.stats.stable_paths));\n     }\n \n-    fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> String {\n+    fn make_stat(bccx: &BorrowckCtxt, stat: usize) -> String {\n         let total = bccx.stats.guaranteed_paths as f64;\n         let perc = if total == 0.0 { 0.0 } else { stat as f64 * 100.0 / total };\n         format!(\"{} ({:.0}%)\", stat, perc)\n@@ -238,10 +238,10 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n }\n \n struct BorrowStats {\n-    loaned_paths_same: uint,\n-    loaned_paths_imm: uint,\n-    stable_paths: uint,\n-    guaranteed_paths: uint\n+    loaned_paths_same: usize,\n+    loaned_paths_imm: usize,\n+    stable_paths: usize,\n+    guaranteed_paths: usize\n }\n \n pub type BckResult<'tcx, T> = Result<T, BckError<'tcx>>;\n@@ -251,7 +251,7 @@ pub type BckResult<'tcx, T> = Result<T, BckError<'tcx>>;\n \n /// Record of a loan that was issued.\n pub struct Loan<'tcx> {\n-    index: uint,\n+    index: usize,\n     loan_path: Rc<LoanPath<'tcx>>,\n     kind: ty::BorrowKind,\n     restricted_paths: Vec<Rc<LoanPath<'tcx>>>,\n@@ -382,7 +382,7 @@ impl<'tcx> LoanPath<'tcx> {\n         }\n     }\n \n-    fn depth(&self) -> uint {\n+    fn depth(&self) -> usize {\n         match self.kind {\n             LpExtend(ref base, _, LpDeref(_)) => base.depth(),\n             LpExtend(ref base, _, LpInterior(_)) => base.depth() + 1,\n@@ -1043,7 +1043,7 @@ fn is_statement_scope(tcx: &ty::ctxt, region: ty::Region) -> bool {\n \n impl BitwiseOperator for LoanDataFlowOperator {\n     #[inline]\n-    fn join(&self, succ: uint, pred: uint) -> uint {\n+    fn join(&self, succ: usize, pred: usize) -> usize {\n         succ | pred // loans from both preds are in scope\n     }\n }"}, {"sha": "a4470acbe4d20dc8f043943759a32982c7a4ba6b", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -76,10 +76,10 @@ pub struct FlowedMoveData<'a, 'tcx: 'a> {\n \n /// Index into `MoveData.paths`, used like a pointer\n #[derive(Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n-pub struct MovePathIndex(uint);\n+pub struct MovePathIndex(usize);\n \n impl MovePathIndex {\n-    fn get(&self) -> uint {\n+    fn get(&self) -> usize {\n         let MovePathIndex(v) = *self; v\n     }\n }\n@@ -95,10 +95,10 @@ const InvalidMovePathIndex: MovePathIndex = MovePathIndex(usize::MAX);\n \n /// Index into `MoveData.moves`, used like a pointer\n #[derive(Copy, PartialEq)]\n-pub struct MoveIndex(uint);\n+pub struct MoveIndex(usize);\n \n impl MoveIndex {\n-    fn get(&self) -> uint {\n+    fn get(&self) -> usize {\n         let MoveIndex(v) = *self; v\n     }\n }\n@@ -740,7 +740,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n impl BitwiseOperator for MoveDataFlowOperator {\n     #[inline]\n-    fn join(&self, succ: uint, pred: uint) -> uint {\n+    fn join(&self, succ: usize, pred: usize) -> usize {\n         succ | pred // moves from both preds are in scope\n     }\n }\n@@ -754,7 +754,7 @@ impl DataFlowOperator for MoveDataFlowOperator {\n \n impl BitwiseOperator for AssignDataFlowOperator {\n     #[inline]\n-    fn join(&self, succ: uint, pred: uint) -> uint {\n+    fn join(&self, succ: usize, pred: usize) -> usize {\n         succ | pred // moves from both preds are in scope\n     }\n }"}, {"sha": "624a95c2906e139182f91802a44f29a6c3ce634a", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                                         cfgidx: CFGIndex,\n                                         dfcx: &DataFlowContext<'a, 'tcx, O>,\n                                         mut to_lp: F) -> String where\n-        F: FnMut(uint) -> Rc<LoanPath<'tcx>>,\n+        F: FnMut(usize) -> Rc<LoanPath<'tcx>>,\n     {\n         let mut saw_some = false;\n         let mut set = \"{\".to_string();"}, {"sha": "54feed930a80d7b9766d1e54bade1090abcf5da6", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -21,8 +21,6 @@\n \n #![allow(non_camel_case_types)]\n \n-#![feature(core)]\n-#![feature(int_uint)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -35,7 +33,7 @@\n \n // for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n // refers to the borrowck-specific graphviz adapter traits.\n-extern crate \"graphviz\" as dot;\n+extern crate graphviz as dot;\n extern crate rustc;\n \n pub use borrowck::check_crate;"}, {"sha": "dc06bb96152e9a0c0528bb3d9580645452747cc4", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -501,8 +501,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         let features =\n             syntax::feature_gate::check_crate(sess.codemap(),\n                                               &sess.parse_sess.span_diagnostic,\n-                                              &krate,\n-                                              true);\n+                                              &krate);\n         *sess.features.borrow_mut() = features;\n         sess.abort_if_errors();\n     });\n@@ -532,8 +531,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         let features =\n             syntax::feature_gate::check_crate(sess.codemap(),\n                                               &sess.parse_sess.span_diagnostic,\n-                                              &krate,\n-                                              false);\n+                                              &krate);\n         *sess.features.borrow_mut() = features;\n         sess.abort_if_errors();\n     });"}, {"sha": "456d5f7a60ab7bec88aa167507125b6da085e801", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -28,7 +28,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n@@ -55,7 +54,7 @@ extern crate rustc_resolve;\n extern crate rustc_trans;\n extern crate rustc_typeck;\n extern crate serialize;\n-extern crate \"rustc_llvm\" as llvm;\n+extern crate rustc_llvm as llvm;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n \n@@ -101,7 +100,7 @@ const BUG_REPORT_URL: &'static str =\n     \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\";\n \n \n-pub fn run(args: Vec<String>) -> int {\n+pub fn run(args: Vec<String>) -> isize {\n     monitor(move || run_compiler(&args, &mut RustcDefaultCalls));\n     0\n }\n@@ -795,7 +794,7 @@ fn parse_crate_attrs(sess: &Session, input: &Input) ->\n /// errors of the compiler.\n #[allow(deprecated)]\n pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n-    const STACK_SIZE: uint = 8 * 1024 * 1024; // 8MB\n+    const STACK_SIZE: usize = 8 * 1024 * 1024; // 8MB\n \n     struct Sink(Arc<Mutex<Vec<u8>>>);\n     impl Write for Sink {"}, {"sha": "fcb0b9bdd3cfb05db2e0d6fefd0e54ae999227e3", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -88,13 +88,13 @@ impl Emitter for ExpectErrorEmitter {\n     }\n }\n \n-fn errors(msgs: &[&str]) -> (Box<Emitter+Send>, uint) {\n+fn errors(msgs: &[&str]) -> (Box<Emitter+Send>, usize) {\n     let v = msgs.iter().map(|m| m.to_string()).collect();\n     (box ExpectErrorEmitter { messages: v } as Box<Emitter+Send>, msgs.len())\n }\n \n fn test_env<F>(source_string: &str,\n-               (emitter, expected_err_count): (Box<Emitter+Send>, uint),\n+               (emitter, expected_err_count): (Box<Emitter+Send>, usize),\n                body: F) where\n     F: FnOnce(Env),\n {\n@@ -178,7 +178,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n         fn search_mod(this: &Env,\n                       m: &ast::Mod,\n-                      idx: uint,\n+                      idx: usize,\n                       names: &[String])\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n@@ -192,7 +192,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n         fn search(this: &Env,\n                   it: &ast::Item,\n-                  idx: uint,\n+                  idx: usize,\n                   names: &[String])\n                   -> Option<ast::NodeId> {\n             if idx == names.len() {\n@@ -300,14 +300,14 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn t_rptr(&self, r: ty::Region) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.int)\n+                        self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound(&self, id: u32) -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1));\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.int)\n+                        self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound_with_debruijn(&self,\n@@ -317,13 +317,13 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, debruijn);\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.int)\n+                        self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n         let r = ty::ReScope(CodeExtent::from_node_id(id));\n         ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.int)\n+                        self.tcx().types.isize)\n     }\n \n     pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region {\n@@ -335,13 +335,13 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         let r = self.re_free(nid, id);\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.int)\n+                        self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_static(&self) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(ty::ReStatic),\n-                        self.tcx().types.int)\n+                        self.tcx().types.isize)\n     }\n \n     pub fn dummy_type_trace(&self) -> infer::TypeTrace<'tcx> {\n@@ -464,67 +464,67 @@ fn contravariant_region_ptr_err() {\n fn sub_free_bound_false() {\n     //! Test that:\n     //!\n-    //!     fn(&'a int) <: for<'b> fn(&'b int)\n+    //!     fn(&'a isize) <: for<'b> fn(&'b isize)\n     //!\n     //! does NOT hold.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n-                          env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+                          env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n     })\n }\n \n #[test]\n fn sub_bound_free_true() {\n     //! Test that:\n     //!\n-    //!     for<'a> fn(&'a int) <: fn(&'b int)\n+    //!     for<'a> fn(&'a isize) <: fn(&'b isize)\n     //!\n     //! DOES hold.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.int));\n+        env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n     })\n }\n \n #[test]\n fn sub_free_bound_false_infer() {\n     //! Test that:\n     //!\n-    //!     fn(_#1) <: for<'b> fn(&'b int)\n+    //!     fn(_#1) <: for<'b> fn(&'b isize)\n     //!\n     //! does NOT hold for any instantiation of `_#1`.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_infer1 = env.infcx.next_ty_var();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.int),\n-                          env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n+                          env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n     })\n }\n \n #[test]\n fn lub_free_bound_infer() {\n     //! Test result of:\n     //!\n-    //!     LUB(fn(_#1), for<'b> fn(&'b int))\n+    //!     LUB(fn(_#1), for<'b> fn(&'b isize))\n     //!\n-    //! This should yield `fn(&'_ int)`. We check\n-    //! that it yields `fn(&'x int)` for some free `'x`,\n+    //! This should yield `fn(&'_ isize)`. We check\n+    //! that it yields `fn(&'x isize)` for some free `'x`,\n     //! anyhow.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_infer1 = env.infcx.next_ty_var();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.int));\n+        env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n     });\n }\n \n@@ -533,9 +533,9 @@ fn lub_bound_bound() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound2], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound2], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n     })\n }\n \n@@ -544,9 +544,9 @@ fn lub_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.int));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n     })\n }\n \n@@ -555,9 +555,9 @@ fn lub_bound_static() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.int));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.isize));\n     })\n }\n \n@@ -578,9 +578,9 @@ fn lub_free_free() {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free2], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.int));\n+        env.check_lub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.isize));\n     })\n }\n \n@@ -603,9 +603,9 @@ fn glb_free_free_with_common_scope() {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_scope = env.t_rptr_scope(0);\n-        env.check_glb(env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free2], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_scope], env.tcx().types.int));\n+        env.check_glb(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_scope], env.tcx().types.isize));\n     })\n }\n \n@@ -614,9 +614,9 @@ fn glb_bound_bound() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound2], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound2], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n     })\n }\n \n@@ -625,9 +625,9 @@ fn glb_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n     })\n }\n \n@@ -637,14 +637,14 @@ fn glb_bound_free_infer() {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_infer1 = env.infcx.next_ty_var();\n \n-        // compute GLB(fn(_) -> int, for<'b> fn(&'b int) -> int),\n-        // which should yield for<'b> fn(&'b int) -> int\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_infer1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        // compute GLB(fn(_) -> isize, for<'b> fn(&'b isize) -> isize),\n+        // which should yield for<'b> fn(&'b isize) -> isize\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_infer1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n \n         // as a side-effect, computing GLB should unify `_` with\n-        // `&'_ int`\n+        // `&'_ isize`\n         let t_resolve1 = env.infcx.shallow_resolve(t_infer1);\n         match t_resolve1.sty {\n             ty::ty_rptr(..) => { }\n@@ -658,9 +658,9 @@ fn glb_bound_static() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n     })\n }\n \n@@ -684,7 +684,7 @@ fn subst_ty_renumber_bound() {\n         let substs = subst::Substs::new_type(vec![t_rptr_bound1], vec![]);\n         let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n \n-        // t_expected = fn(&'a int)\n+        // t_expected = fn(&'a isize)\n         let t_expected = {\n             let t_ptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(2));\n             env.t_fn(&[t_ptr_bound2], env.t_nil())\n@@ -719,7 +719,7 @@ fn subst_ty_renumber_some_bounds() {\n         let substs = subst::Substs::new_type(vec![t_rptr_bound1], vec![]);\n         let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n \n-        // t_expected = (&'a int, fn(&'a int))\n+        // t_expected = (&'a isize, fn(&'a isize))\n         //\n         // but not that the Debruijn index is different in the different cases.\n         let t_expected = {\n@@ -771,7 +771,7 @@ fn subst_region_renumber_region() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let re_bound1 = env.re_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));\n \n-        // type t_source<'a> = fn(&'a int)\n+        // type t_source<'a> = fn(&'a isize)\n         let t_source = {\n             let re_early = env.re_early_bound(subst::TypeSpace, 0, \"'a\");\n             env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n@@ -780,7 +780,7 @@ fn subst_region_renumber_region() {\n         let substs = subst::Substs::new_type(vec![], vec![re_bound1]);\n         let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n \n-        // t_expected = fn(&'a int)\n+        // t_expected = fn(&'a isize)\n         //\n         // but not that the Debruijn index is different in the different cases.\n         let t_expected = {\n@@ -802,8 +802,8 @@ fn subst_region_renumber_region() {\n fn walk_ty() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let tcx = env.infcx.tcx;\n-        let int_ty = tcx.types.int;\n-        let uint_ty = tcx.types.uint;\n+        let int_ty = tcx.types.isize;\n+        let uint_ty = tcx.types.usize;\n         let tup1_ty = ty::mk_tup(tcx, vec!(int_ty, uint_ty, int_ty, uint_ty));\n         let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n         let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n@@ -821,8 +821,8 @@ fn walk_ty() {\n fn walk_ty_skip_subtree() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let tcx = env.infcx.tcx;\n-        let int_ty = tcx.types.int;\n-        let uint_ty = tcx.types.uint;\n+        let int_ty = tcx.types.isize;\n+        let uint_ty = tcx.types.usize;\n         let tup1_ty = ty::mk_tup(tcx, vec!(int_ty, uint_ty, int_ty, uint_ty));\n         let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n         let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n@@ -836,7 +836,7 @@ fn walk_ty_skip_subtree() {\n                                 (uint_ty, false),\n                                 (int_ty, false),\n                                 (uint_ty, false),\n-                                (tup1_ty, true), // skip the int/uint/int/uint\n+                                (tup1_ty, true), // skip the isize/usize/isize/usize\n                                 (uint_ty, false));\n         expected.reverse();\n "}, {"sha": "5a3d7c728e0735326d75beb05a42918c207b7d5b", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -180,7 +180,7 @@ impl LintPass for TypeLimits {\n                             if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n                             else { false }\n                         } else {\n-                            match eval_const_expr_partial(cx.tcx, &**r, Some(cx.tcx.types.uint)) {\n+                            match eval_const_expr_partial(cx.tcx, &**r, Some(cx.tcx.types.usize)) {\n                                 Ok(const_int(shift)) => { shift as u64 >= bits },\n                                 Ok(const_uint(shift)) => { shift >= bits },\n                                 _ => { false }\n@@ -199,7 +199,7 @@ impl LintPass for TypeLimits {\n                         match lit.node {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n                             ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                                let int_type = if let ast::TyIs(_) = t {\n+                                let int_type = if let ast::TyIs = t {\n                                     cx.sess().target.int_type\n                                 } else {\n                                     t\n@@ -218,7 +218,7 @@ impl LintPass for TypeLimits {\n                         };\n                     },\n                     ty::ty_uint(t) => {\n-                        let uint_type = if let ast::TyUs(_) = t {\n+                        let uint_type = if let ast::TyUs = t {\n                             cx.sess().target.uint_type\n                         } else {\n                             t\n@@ -283,7 +283,7 @@ impl LintPass for TypeLimits {\n         // warnings are consistent between 32- and 64-bit platforms\n         fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n             match int_ty {\n-                ast::TyIs(_) => (i64::MIN,        i64::MAX),\n+                ast::TyIs => (i64::MIN,        i64::MAX),\n                 ast::TyI8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n                 ast::TyI16 =>   (i16::MIN as i64, i16::MAX as i64),\n                 ast::TyI32 =>   (i32::MIN as i64, i32::MAX as i64),\n@@ -293,7 +293,7 @@ impl LintPass for TypeLimits {\n \n         fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n             match uint_ty {\n-                ast::TyUs(_) => (u64::MIN,         u64::MAX),\n+                ast::TyUs => (u64::MIN,         u64::MAX),\n                 ast::TyU8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n                 ast::TyU16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n                 ast::TyU32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n@@ -310,7 +310,7 @@ impl LintPass for TypeLimits {\n \n         fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n             match int_ty {\n-                ast::TyIs(_) => int_ty_bits(target_int_ty, target_int_ty),\n+                ast::TyIs => int_ty_bits(target_int_ty, target_int_ty),\n                 ast::TyI8 =>    i8::BITS  as u64,\n                 ast::TyI16 =>   i16::BITS as u64,\n                 ast::TyI32 =>   i32::BITS as u64,\n@@ -320,7 +320,7 @@ impl LintPass for TypeLimits {\n \n         fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n             match uint_ty {\n-                ast::TyUs(_) => uint_ty_bits(target_uint_ty, target_uint_ty),\n+                ast::TyUs => uint_ty_bits(target_uint_ty, target_uint_ty),\n                 ast::TyU8 =>    u8::BITS  as u64,\n                 ast::TyU16 =>   u16::BITS as u64,\n                 ast::TyU32 =>   u32::BITS as u64,\n@@ -395,12 +395,12 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n         match self.cx.tcx.def_map.borrow().get(&id).unwrap().full_def() {\n-            def::DefPrimTy(ast::TyInt(ast::TyIs(_))) => {\n+            def::DefPrimTy(ast::TyInt(ast::TyIs)) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `isize` in foreign module, while \\\n                                    libc::c_int or libc::c_long should be used\");\n             }\n-            def::DefPrimTy(ast::TyUint(ast::TyUs(_))) => {\n+            def::DefPrimTy(ast::TyUint(ast::TyUs)) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `usize` in foreign module, while \\\n                                    libc::c_uint or libc::c_ulong should be used\");"}, {"sha": "34f7436d0cd5d8d7cc5ccc9be4e2b88664b1183e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -34,7 +34,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "cc6a85e86ce077646aa5ee75b4c0c0cb0899cd94", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -61,7 +61,7 @@ impl ArchiveRO {\n             if ptr.is_null() {\n                 None\n             } else {\n-                Some(slice::from_raw_parts(ptr as *const u8, size as uint))\n+                Some(slice::from_raw_parts(ptr as *const u8, size as usize))\n             }\n         }\n     }"}, {"sha": "c7b5b2e75346f9d2f77b31d24fe276eae5332e4c", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -15,7 +15,6 @@\n #![allow(non_snake_case)]\n #![allow(dead_code)]\n #![allow(trivial_casts)]\n-#![allow(trivial_numeric_casts)]\n \n #![crate_name = \"rustc_llvm\"]\n #![unstable(feature = \"rustc_private\")]\n@@ -28,7 +27,6 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(int_uint)]\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(staged_api)]\n@@ -77,7 +75,7 @@ pub type Bool = c_uint;\n pub const True: Bool = 1 as Bool;\n pub const False: Bool = 0 as Bool;\n \n-// Consts for the LLVM CallConv type, pre-cast to uint.\n+// Consts for the LLVM CallConv type, pre-cast to usize.\n \n #[derive(Copy, PartialEq)]\n pub enum CallConv {\n@@ -242,7 +240,7 @@ impl AttrHelper for SpecialAttribute {\n }\n \n pub struct AttrBuilder {\n-    attrs: Vec<(uint, Box<AttrHelper+'static>)>\n+    attrs: Vec<(usize, Box<AttrHelper+'static>)>\n }\n \n impl AttrBuilder {\n@@ -252,13 +250,13 @@ impl AttrBuilder {\n         }\n     }\n \n-    pub fn arg<'a, T: AttrHelper + 'static>(&'a mut self, idx: uint, a: T) -> &'a mut AttrBuilder {\n+    pub fn arg<'a, T: AttrHelper + 'static>(&'a mut self, idx: usize, a: T) -> &'a mut AttrBuilder {\n         self.attrs.push((idx, box a as Box<AttrHelper+'static>));\n         self\n     }\n \n     pub fn ret<'a, T: AttrHelper + 'static>(&'a mut self, a: T) -> &'a mut AttrBuilder {\n-        self.attrs.push((ReturnIndex as uint, box a as Box<AttrHelper+'static>));\n+        self.attrs.push((ReturnIndex as usize, box a as Box<AttrHelper+'static>));\n         self\n     }\n \n@@ -693,7 +691,7 @@ extern {\n                          -> ValueRef;\n     pub fn LLVMConstFCmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n                          -> ValueRef;\n-    /* only for int/vector */\n+    /* only for isize/vector */\n     pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n     pub fn LLVMIsConstant(Val: ValueRef) -> Bool;\n     pub fn LLVMIsNull(Val: ValueRef) -> Bool;\n@@ -2167,7 +2165,7 @@ impl ObjectFile {\n     pub fn new(llmb: MemoryBufferRef) -> Option<ObjectFile> {\n         unsafe {\n             let llof = LLVMCreateObjectFile(llmb);\n-            if llof as int == 0 {\n+            if llof as isize == 0 {\n                 // LLVMCreateObjectFile took ownership of llmb\n                 return None\n             }\n@@ -2227,7 +2225,7 @@ type RustStringRepr = *mut RefCell<Vec<u8>>;\n pub unsafe extern \"C\" fn rust_llvm_string_write_impl(sr: RustStringRef,\n                                                      ptr: *const c_char,\n                                                      size: size_t) {\n-    let slice = slice::from_raw_parts(ptr as *const u8, size as uint);\n+    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n \n     let sr: RustStringRepr = mem::transmute(sr);\n     (*sr).borrow_mut().push_all(slice);"}, {"sha": "9b1b57e7bbe282b702352e50c11fbc85fbf5a287", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -19,7 +19,6 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(int_uint)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -378,7 +377,7 @@ enum PrivacyResult {\n }\n \n enum FieldName {\n-    UnnamedField(uint), // index\n+    UnnamedField(usize), // index\n     // (Name, not Ident, because struct fields are not macro-hygienic)\n     NamedField(ast::Name),\n }"}, {"sha": "24278af48a964e9687d63565337cecdcab7ece7e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -21,8 +21,6 @@\n \n #![feature(alloc)]\n #![feature(collections)]\n-#![feature(core)]\n-#![feature(int_uint)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -326,7 +324,7 @@ enum UseLexicalScopeFlag {\n \n enum ModulePrefixResult {\n     NoPrefixFound,\n-    PrefixFound(Rc<Module>, uint)\n+    PrefixFound(Rc<Module>, usize)\n }\n \n #[derive(Copy, PartialEq)]\n@@ -414,10 +412,10 @@ pub struct Module {\n     import_resolutions: RefCell<HashMap<Name, ImportResolution>>,\n \n     // The number of unresolved globs that this module exports.\n-    glob_count: Cell<uint>,\n+    glob_count: Cell<usize>,\n \n     // The index of the import we're resolving.\n-    resolved_import_count: Cell<uint>,\n+    resolved_import_count: Cell<usize>,\n \n     // Whether this module is populated. If not populated, any attempt to\n     // access the children must be preceded with a\n@@ -743,15 +741,13 @@ impl PrimitiveTypeTable {\n         table.intern(\"char\",    TyChar);\n         table.intern(\"f32\",     TyFloat(TyF32));\n         table.intern(\"f64\",     TyFloat(TyF64));\n-        table.intern(\"int\",     TyInt(TyIs(true)));\n-        table.intern(\"isize\",   TyInt(TyIs(false)));\n+        table.intern(\"isize\",   TyInt(TyIs));\n         table.intern(\"i8\",      TyInt(TyI8));\n         table.intern(\"i16\",     TyInt(TyI16));\n         table.intern(\"i32\",     TyInt(TyI32));\n         table.intern(\"i64\",     TyInt(TyI64));\n         table.intern(\"str\",     TyStr);\n-        table.intern(\"uint\",    TyUint(TyUs(true)));\n-        table.intern(\"usize\",   TyUint(TyUs(false)));\n+        table.intern(\"usize\",   TyUint(TyUs));\n         table.intern(\"u8\",      TyUint(TyU8));\n         table.intern(\"u16\",     TyUint(TyU16));\n         table.intern(\"u32\",     TyUint(TyU32));\n@@ -778,7 +774,7 @@ pub struct Resolver<'a, 'tcx:'a> {\n     structs: FnvHashMap<DefId, Vec<Name>>,\n \n     // The number of imports that are currently unresolved.\n-    unresolved_imports: uint,\n+    unresolved_imports: usize,\n \n     // The module that represents the current item scope.\n     current_module: Rc<Module>,\n@@ -960,7 +956,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn resolve_module_path_from_root(&mut self,\n                                      module_: Rc<Module>,\n                                      module_path: &[Name],\n-                                     index: uint,\n+                                     index: usize,\n                                      span: Span,\n                                      name_search_type: NameSearchType,\n                                      lp: LastPrivate)\n@@ -3054,12 +3050,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         NoSuggestion\n     }\n \n-    fn find_best_match_for_name(&mut self, name: &str, max_distance: uint)\n+    fn find_best_match_for_name(&mut self, name: &str, max_distance: usize)\n                                 -> Option<String> {\n         let this = &mut *self;\n \n         let mut maybes: Vec<token::InternedString> = Vec::new();\n-        let mut values: Vec<uint> = Vec::new();\n+        let mut values: Vec<usize> = Vec::new();\n \n         for rib in this.value_ribs.iter().rev() {\n             for (&k, _) in &rib.bindings {"}, {"sha": "44c803c77656d68e3704f4549e30d7ee99dbb306", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -115,7 +115,7 @@ pub struct ImportResolution {\n     // Note that this is usually either 0 or 1 - shadowing is forbidden the only\n     // way outstanding_references is > 1 in a legal program is if the name is\n     // used in both namespaces.\n-    pub outstanding_references: uint,\n+    pub outstanding_references: usize,\n \n     /// The value that this `use` directive names, if there is one.\n     pub value_target: Option<Target>,"}, {"sha": "ad777351898912f6608370e51c4c63c78e477309", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -60,16 +60,16 @@ pub const RLIB_BYTECODE_OBJECT_MAGIC: &'static [u8] = b\"RUST_OBJECT\";\n pub const RLIB_BYTECODE_OBJECT_VERSION: u32 = 1;\n \n // The offset in bytes the bytecode object format version number can be found at\n-pub const RLIB_BYTECODE_OBJECT_VERSION_OFFSET: uint = 11;\n+pub const RLIB_BYTECODE_OBJECT_VERSION_OFFSET: usize = 11;\n \n // The offset in bytes the size of the compressed bytecode can be found at in\n // format version 1\n-pub const RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: uint =\n+pub const RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: usize =\n     RLIB_BYTECODE_OBJECT_VERSION_OFFSET + 4;\n \n // The offset in bytes the compressed LLVM bytecode can be found at in format\n // version 1\n-pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: uint =\n+pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: usize =\n     RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n \n \n@@ -159,11 +159,19 @@ pub fn find_crate_name(sess: Option<&Session>,\n     }\n     if let Input::File(ref path) = *input {\n         if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n-            return validate(s.to_string(), None);\n+            if s.starts_with(\"-\") {\n+                let msg = format!(\"crate names cannot start with a `-`, but \\\n+                                   `{}` has a leading hyphen\", s);\n+                if let Some(sess) = sess {\n+                    sess.err(&msg);\n+                }\n+            } else {\n+                return validate(s.replace(\"-\", \"_\"), None);\n+            }\n         }\n     }\n \n-    \"rust-out\".to_string()\n+    \"rust_out\".to_string()\n }\n \n pub fn build_link_meta(sess: &Session, krate: &ast::Crate,\n@@ -323,7 +331,7 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n         \"abcdefghijklmnopqrstuvwxyz\\\n          ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n          0123456789\";\n-    let id = id as uint;\n+    let id = id as usize;\n     let extra1 = id % EXTRA_CHARS.len();\n     let id = id / EXTRA_CHARS.len();\n     let extra2 = id % EXTRA_CHARS.len();\n@@ -455,7 +463,11 @@ pub fn filename_for_input(sess: &Session,\n         }\n         config::CrateTypeExecutable => {\n             let suffix = &sess.target.target.options.exe_suffix;\n-            out_filename.with_file_name(&format!(\"{}{}\", libname, suffix))\n+            if suffix.len() == 0 {\n+                out_filename.to_path_buf()\n+            } else {\n+                out_filename.with_extension(&suffix[1..])\n+            }\n         }\n     }\n }\n@@ -695,7 +707,7 @@ fn write_rlib_bytecode_object_v1(writer: &mut Write,\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n         mem::size_of_val(&RLIB_BYTECODE_OBJECT_VERSION) + // version\n         mem::size_of_val(&bc_data_deflated_size) +        // data size field\n-        bc_data_deflated_size as uint;                    // actual data\n+        bc_data_deflated_size as usize;                    // actual data\n \n     // If the number of bytes written to the object so far is odd, add a\n     // padding byte to make it even. This works around a crash bug in LLDB\n@@ -1154,7 +1166,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n-        let kind = match data[cnum as uint - 1] {\n+        let kind = match data[cnum as usize - 1] {\n             Some(t) => t,\n             None => continue\n         };"}, {"sha": "056550f6635da306015955e60fe9a8f94f84e4d0", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -92,7 +92,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                         let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n                         let compressed_data = &bc_encoded[\n                             link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET..\n-                            (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint)];\n+                            (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as usize)];\n \n                         match flate::inflate_bytes(compressed_data) {\n                             Ok(inflated) => inflated,\n@@ -204,7 +204,7 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n     return read_from_le_bytes::<u64>(bc, link::RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET);\n }\n \n-fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n+fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: usize) -> T {\n     let byte_data = &bytes[position_in_bytes..position_in_bytes + mem::size_of::<T>()];\n     let data = unsafe {\n         *(byte_data.as_ptr() as *const T)"}, {"sha": "cc588a365f6e68c5ab2ca3d950f1787d5eee82e6", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -898,7 +898,7 @@ fn run_work_singlethreaded(sess: &Session,\n \n fn run_work_multithreaded(sess: &Session,\n                           work_items: Vec<WorkItem>,\n-                          num_workers: uint) {\n+                          num_workers: usize) {\n     // Run some workers to process the work items.\n     let work_items_arc = Arc::new(Mutex::new(work_items));\n     let mut diag_emitter = SharedEmitter::new();"}, {"sha": "a3ac0473bfa26c3b31b0fb751b48a4af5207a048", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -30,7 +30,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n@@ -44,7 +43,6 @@\n #![feature(path_relative_from)]\n \n #![allow(trivial_casts)]\n-#![allow(trivial_numeric_casts)]\n \n extern crate arena;\n extern crate flate;\n@@ -54,7 +52,7 @@ extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n extern crate serialize;\n-extern crate \"rustc_llvm\" as llvm;\n+extern crate rustc_llvm as llvm;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "a415875d852cc8bb8a94ae4d0fba41156c674f75", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -465,7 +465,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // However full span is the entire enum/fn/struct block, so we only want\n         // the first few to match the number of generics we're looking for.\n         let param_sub_spans = self.span.spans_for_ty_params(full_span,\n-                                                           (generics.ty_params.len() as int));\n+                                                           (generics.ty_params.len() as isize));\n         for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans.iter()) {\n             // Append $id to name to make sure each one is unique\n             let name = format!(\"{}::{}${}\","}, {"sha": "84a7678959d3efdcb792489e81aff6e98f913441", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -24,7 +24,7 @@ use syntax::parse::token::{keywords, Token};\n #[derive(Clone)]\n pub struct SpanUtils<'a> {\n     pub sess: &'a Session,\n-    pub err_count: Cell<int>,\n+    pub err_count: Cell<isize>,\n }\n \n impl<'a> SpanUtils<'a> {\n@@ -232,7 +232,7 @@ impl<'a> SpanUtils<'a> {\n     // example with Foo<Bar<T,V>, Bar<T,V>>\n     // Nesting = 0: all idents outside of brackets: ~[Foo]\n     // Nesting = 1: idents within one level of brackets: ~[Bar, Bar]\n-    pub fn spans_with_brackets(&self, span: Span, nesting: int, limit: int) -> Vec<Span> {\n+    pub fn spans_with_brackets(&self, span: Span, nesting: isize, limit: isize) -> Vec<Span> {\n         let mut result: Vec<Span> = vec!();\n \n         let mut toks = self.retokenise_span(span);\n@@ -250,7 +250,7 @@ impl<'a> SpanUtils<'a> {\n                 }\n                 return result\n             }\n-            if (result.len() as int) == limit {\n+            if (result.len() as isize) == limit {\n                 return result;\n             }\n             bracket_count += match ts.tok {\n@@ -347,7 +347,7 @@ impl<'a> SpanUtils<'a> {\n \n     // Return an owned vector of the subspans of the param identifier\n     // tokens found in span.\n-    pub fn spans_for_ty_params(&self, span: Span, number: int) -> Vec<Span> {\n+    pub fn spans_for_ty_params(&self, span: Span, number: isize) -> Vec<Span> {\n         if generated_code(span) {\n             return vec!();\n         }"}, {"sha": "ea8197d0c407e57a841e85f32488e072b8c2cf67", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -28,7 +28,7 @@\n //! constituent pattern.  N here is usually the number of arms but may be\n //! greater, if some arms have multiple alternatives.  For example, here:\n //!\n-//!     enum Foo { A, B(int), C(uint, uint) }\n+//!     enum Foo { A, B(int), C(usize, usize) }\n //!     match foo {\n //!         A => ...,\n //!         B(x) => ...,\n@@ -246,9 +246,9 @@ enum Opt<'a, 'tcx> {\n     ConstantValue(ConstantExpr<'a>, DebugLoc),\n     ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>, DebugLoc),\n     Variant(ty::Disr, Rc<adt::Repr<'tcx>>, ast::DefId, DebugLoc),\n-    SliceLengthEqual(uint, DebugLoc),\n-    SliceLengthGreaterOrEqual(/* prefix length */ uint,\n-                              /* suffix length */ uint,\n+    SliceLengthEqual(usize, DebugLoc),\n+    SliceLengthGreaterOrEqual(/* prefix length */ usize,\n+                              /* suffix length */ usize,\n                               DebugLoc),\n }\n \n@@ -381,7 +381,7 @@ impl<'a, 'p, 'blk, 'tcx> Repr<'tcx> for Match<'a, 'p, 'blk, 'tcx> {\n     }\n }\n \n-fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n+fn has_nested_bindings(m: &[Match], col: usize) -> bool {\n     for br in m {\n         match br.pats[col].node {\n             ast::PatIdent(_, _, Some(_)) => return true,\n@@ -393,7 +393,7 @@ fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n \n fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                               m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                              col: uint,\n+                                              col: usize,\n                                               val: ValueRef)\n                                               -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n@@ -430,7 +430,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                           dm: &DefMap,\n                                           m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                          col: uint,\n+                                          col: usize,\n                                           val: ValueRef,\n                                           mut e: F)\n                                           -> Vec<Match<'a, 'p, 'blk, 'tcx>> where\n@@ -476,7 +476,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      dm: &DefMap,\n                                      m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                     col: uint,\n+                                     col: usize,\n                                      val: ValueRef)\n                                      -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n@@ -532,8 +532,8 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              dm: &DefMap,\n              m: &[Match<'a, 'p, 'blk, 'tcx>],\n              opt: &Opt,\n-             col: uint,\n-             variant_size: uint,\n+             col: usize,\n+             variant_size: usize,\n              val: ValueRef)\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n@@ -575,7 +575,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n // on a set of enum variants or a literal.\n fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                    col: uint)\n+                                    col: usize)\n                                     -> Vec<Opt<'p, 'tcx>> {\n     let tcx = bcx.tcx();\n \n@@ -656,8 +656,8 @@ fn match_datum<'tcx>(val: ValueRef, left_ty: Ty<'tcx>) -> Datum<'tcx, Lvalue> {\n fn bind_subslice_pat(bcx: Block,\n                      pat_id: ast::NodeId,\n                      val: ValueRef,\n-                     offset_left: uint,\n-                     offset_right: uint) -> ValueRef {\n+                     offset_left: usize,\n+                     offset_right: usize) -> ValueRef {\n     let _icx = push_ctxt(\"match::bind_subslice_pat\");\n     let vec_ty = node_id_type(bcx, pat_id);\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty));\n@@ -679,8 +679,8 @@ fn bind_subslice_pat(bcx: Block,\n \n fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  left_ty: Ty<'tcx>,\n-                                 before: uint,\n-                                 after: uint,\n+                                 before: usize,\n+                                 after: usize,\n                                  val: ValueRef)\n                                  -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n@@ -711,15 +711,15 @@ macro_rules! any_pat {\n     )\n }\n \n-fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n+fn any_uniq_pat(m: &[Match], col: usize) -> bool {\n     any_pat!(m, col, ast::PatBox(_))\n }\n \n-fn any_region_pat(m: &[Match], col: uint) -> bool {\n+fn any_region_pat(m: &[Match], col: usize) -> bool {\n     any_pat!(m, col, ast::PatRegion(..))\n }\n \n-fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: uint) -> bool {\n+fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: usize) -> bool {\n     m.iter().any(|br| {\n         let pat = br.pats[col];\n         match pat.node {\n@@ -772,16 +772,16 @@ impl FailureHandler {\n     }\n }\n \n-fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n-    fn pat_score(def_map: &DefMap, pat: &ast::Pat) -> uint {\n+fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<usize> {\n+    fn pat_score(def_map: &DefMap, pat: &ast::Pat) -> usize {\n         match pat.node {\n             ast::PatIdent(_, _, Some(ref inner)) => pat_score(def_map, &**inner),\n             _ if pat_is_refutable(def_map, pat) => 1,\n             _ => 0\n         }\n     }\n \n-    let column_score = |m: &[Match], col: uint| -> uint {\n+    let column_score = |m: &[Match], col: usize| -> usize {\n         let total_score = m.iter()\n             .map(|row| row.pats[col])\n             .map(|pat| pat_score(def_map, pat))\n@@ -795,7 +795,7 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n         }\n     };\n \n-    let column_contains_any_nonwild_patterns = |&col: &uint| -> bool {\n+    let column_contains_any_nonwild_patterns = |&col: &usize| -> bool {\n         m.iter().any(|row| match row.pats[col].node {\n             ast::PatWild(_) => false,\n             _ => true\n@@ -1047,7 +1047,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                                  vals: &[ValueRef],\n                                                  chk: &FailureHandler,\n-                                                 col: uint,\n+                                                 col: usize,\n                                                  val: ValueRef,\n                                                  has_genuine_default: bool) {\n     let fcx = bcx.fcx;\n@@ -1187,7 +1187,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     let t = if kind == Compare {\n                         left_ty\n                     } else {\n-                        tcx.types.uint // vector length\n+                        tcx.types.usize // vector length\n                     };\n                     let Result { bcx: after_cx, val: matches } = {\n                         match opt.trans(bcx) {\n@@ -1528,7 +1528,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let scope = cleanup::var_scope(tcx, p_id);\n             bcx = mk_binding_alloca(\n                 bcx, p_id, &path1.node, scope, (),\n-                |(), bcx, llval, ty| { zero_mem(bcx, llval, ty); bcx });\n+                |(), bcx, llval, ty| { drop_done_fill_mem(bcx, llval, ty); bcx });\n         });\n         bcx\n     }"}, {"sha": "963f7a0543f5e47edbb2edc9cde57357c7ec55b9", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 85, "deletions": 33, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -81,14 +81,18 @@ pub enum Repr<'tcx> {\n     /// Structs with destructors need a dynamic destroyedness flag to\n     /// avoid running the destructor too many times; this is included\n     /// in the `Struct` if present.\n-    Univariant(Struct<'tcx>, bool),\n+    /// (The flag if nonzero, represents the initialization value to use;\n+    ///  if zero, then use no flag at all.)\n+    Univariant(Struct<'tcx>, u8),\n     /// General-case enums: for each case there is a struct, and they\n     /// all start with a field for the discriminant.\n     ///\n     /// Types with destructors need a dynamic destroyedness flag to\n     /// avoid running the destructor too many times; the last argument\n     /// indicates whether such a flag is present.\n-    General(IntType, Vec<Struct<'tcx>>, bool),\n+    /// (The flag, if nonzero, represents the initialization value to use;\n+    ///  if zero, then use no flag at all.)\n+    General(IntType, Vec<Struct<'tcx>>, u8),\n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n     /// `nndiscr` must have single field which is known to be nonnull due to its type.\n     /// The other case is known to be zero sized. Hence we represent the enum\n@@ -151,11 +155,59 @@ pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     repr\n }\n \n+macro_rules! repeat_u8_as_u32 {\n+    ($name:expr) => { (($name as u32) << 24 |\n+                       ($name as u32) << 16 |\n+                       ($name as u32) <<  8 |\n+                       ($name as u32)) }\n+}\n+macro_rules! repeat_u8_as_u64 {\n+    ($name:expr) => { ((repeat_u8_as_u32!($name) as u64) << 32 |\n+                       (repeat_u8_as_u32!($name) as u64)) }\n+}\n+\n+pub const DTOR_NEEDED: u8 = 0xd4;\n+pub const DTOR_NEEDED_U32: u32 = repeat_u8_as_u32!(DTOR_NEEDED);\n+pub const DTOR_NEEDED_U64: u64 = repeat_u8_as_u64!(DTOR_NEEDED);\n+#[allow(dead_code)]\n+pub fn dtor_needed_usize(ccx: &CrateContext) -> usize {\n+    match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n+        \"32\" => DTOR_NEEDED_U32 as usize,\n+        \"64\" => DTOR_NEEDED_U64 as usize,\n+        tws => panic!(\"Unsupported target word size for int: {}\", tws),\n+    }\n+}\n+\n+pub const DTOR_DONE: u8 = 0x1d;\n+pub const DTOR_DONE_U32: u32 = repeat_u8_as_u32!(DTOR_DONE);\n+pub const DTOR_DONE_U64: u64 = repeat_u8_as_u64!(DTOR_DONE);\n+#[allow(dead_code)]\n+pub fn dtor_done_usize(ccx: &CrateContext) -> usize {\n+    match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n+        \"32\" => DTOR_DONE_U32 as usize,\n+        \"64\" => DTOR_DONE_U64 as usize,\n+        tws => panic!(\"Unsupported target word size for int: {}\", tws),\n+    }\n+}\n+\n+fn dtor_to_init_u8(dtor: bool) -> u8 {\n+    if dtor { DTOR_NEEDED } else { 0 }\n+}\n+\n+pub trait GetDtorType<'tcx> { fn dtor_type(&self) -> Ty<'tcx>; }\n+impl<'tcx> GetDtorType<'tcx> for ty::ctxt<'tcx> {\n+    fn dtor_type(&self) -> Ty<'tcx> { self.types.u8 }\n+}\n+\n+fn dtor_active(flag: u8) -> bool {\n+    flag != 0\n+}\n+\n fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, &elems[..], false, t), false)\n+            Univariant(mk_struct(cx, &elems[..], false, t), 0)\n         }\n         ty::ty_struct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -165,15 +217,15 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }).collect::<Vec<_>>();\n             let packed = ty::lookup_packed(cx.tcx(), def_id);\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n-            if dtor { ftys.push(cx.tcx().types.bool); }\n+            if dtor { ftys.push(cx.tcx().dtor_type()); }\n \n-            Univariant(mk_struct(cx, &ftys[..], packed, t), dtor)\n+            Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n         }\n         ty::ty_closure(def_id, substs) => {\n             let typer = NormalizingClosureTyper::new(cx.tcx());\n             let upvars = typer.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, &upvar_types[..], false, t), false)\n+            Univariant(mk_struct(cx, &upvar_types[..], false, t), 0)\n         }\n         ty::ty_enum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n@@ -186,9 +238,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // Uninhabitable; represent as unit\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                let ftys = if dtor { vec!(cx.tcx().types.bool) } else { vec!() };\n+                let ftys = if dtor { vec!(cx.tcx().dtor_type()) } else { vec!() };\n                 return Univariant(mk_struct(cx, &ftys[..], false, t),\n-                                  dtor);\n+                                  dtor_to_init_u8(dtor));\n             }\n \n             if !dtor && cases.iter().all(|c| c.tys.len() == 0) {\n@@ -218,9 +270,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n-                if dtor { ftys.push(cx.tcx().types.bool); }\n+                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 return Univariant(mk_struct(cx, &ftys[..], false, t),\n-                                  dtor);\n+                                  dtor_to_init_u8(dtor));\n             }\n \n             if !dtor && cases.len() == 2 && hint == attr::ReprAny {\n@@ -266,7 +318,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), min_ity));\n                 ftys.push_all(&c.tys);\n-                if dtor { ftys.push(cx.tcx().types.bool); }\n+                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 mk_struct(cx, &ftys, false, t)\n             }).collect();\n \n@@ -319,13 +371,13 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n                 ftys.push_all(&c.tys);\n-                if dtor { ftys.push(cx.tcx().types.bool); }\n+                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 mk_struct(cx, &ftys[..], false, t)\n             }).collect();\n \n             ensure_enum_fits_in_address_space(cx, &fields[..], t);\n \n-            General(ity, fields, dtor)\n+            General(ity, fields, dtor_to_init_u8(dtor))\n         }\n         _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\",\n                            ty_to_string(cx.tcx(), t)))\n@@ -339,7 +391,7 @@ struct Case<'tcx> {\n }\n \n /// This represents the (GEP) indices to follow to get to the discriminant field\n-pub type DiscrField = Vec<uint>;\n+pub type DiscrField = Vec<usize>;\n \n fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                     ty: Ty<'tcx>,\n@@ -776,7 +828,7 @@ fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n     let bits = machine::llbitsize_of_real(bcx.ccx(), llty);\n     assert!(bits <= 64);\n-    let  bits = bits as uint;\n+    let  bits = bits as usize;\n     let mask = (-1u64 >> (64 - bits)) as Disr;\n     // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n     // However, that is fine here (it would still represent the full range),\n@@ -830,18 +882,18 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n                   val)\n         }\n         General(ity, ref cases, dtor) => {\n-            if dtor {\n+            if dtor_active(dtor) {\n                 let ptr = trans_field_ptr(bcx, r, val, discr,\n-                                          cases[discr as uint].fields.len() - 2);\n-                Store(bcx, C_u8(bcx.ccx(), 1), ptr);\n+                                          cases[discr as usize].fields.len() - 2);\n+                Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED as usize), ptr);\n             }\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n                   GEPi(bcx, val, &[0, 0]))\n         }\n         Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n-            if dtor {\n-                Store(bcx, C_u8(bcx.ccx(), 1),\n+            if dtor_active(dtor) {\n+                Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED as usize),\n                     GEPi(bcx, val, &[0, st.fields.len() - 1]));\n             }\n         }\n@@ -870,15 +922,15 @@ fn assert_discr_in_range(ity: IntType, min: Disr, max: Disr, discr: Disr) {\n \n /// The number of fields in a given case; for use when obtaining this\n /// information from the type or definition is less convenient.\n-pub fn num_args(r: &Repr, discr: Disr) -> uint {\n+pub fn num_args(r: &Repr, discr: Disr) -> usize {\n     match *r {\n         CEnum(..) => 0,\n         Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n-            st.fields.len() - (if dtor { 1 } else { 0 })\n+            st.fields.len() - (if dtor_active(dtor) { 1 } else { 0 })\n         }\n         General(_, ref cases, dtor) => {\n-            cases[discr as uint].fields.len() - 1 - (if dtor { 1 } else { 0 })\n+            cases[discr as usize].fields.len() - 1 - (if dtor_active(dtor) { 1 } else { 0 })\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } => {\n             if discr == nndiscr { 1 } else { nullfields.len() }\n@@ -892,7 +944,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n \n /// Access a field, at a point when the value's case is known.\n pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n-                                   val: ValueRef, discr: Disr, ix: uint) -> ValueRef {\n+                                   val: ValueRef, discr: Disr, ix: usize) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n@@ -905,7 +957,7 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(_, ref cases, _) => {\n-            struct_field_ptr(bcx, &cases[discr as uint], val, ix + 1, true)\n+            struct_field_ptr(bcx, &cases[discr as usize], val, ix + 1, true)\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } |\n         StructWrappedNullablePointer { nndiscr, ref nullfields, .. } if discr != nndiscr => {\n@@ -931,7 +983,7 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n }\n \n pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, val: ValueRef,\n-                                    ix: uint, needs_cast: bool) -> ValueRef {\n+                                    ix: usize, needs_cast: bool) -> ValueRef {\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n@@ -992,17 +1044,17 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx\n                                        -> datum::DatumBlock<'blk, 'tcx, datum::Expr>\n {\n     let tcx = bcx.tcx();\n-    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), tcx.types.bool);\n+    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), tcx.dtor_type());\n     match *r {\n-        Univariant(ref st, true) => {\n+        Univariant(ref st, dtor) if dtor_active(dtor) => {\n             let flag_ptr = GEPi(bcx, val, &[0, st.fields.len() - 1]);\n             datum::immediate_rvalue_bcx(bcx, flag_ptr, ptr_ty).to_expr_datumblock()\n         }\n-        General(_, _, true) => {\n+        General(_, _, dtor) if dtor_active(dtor) => {\n             let fcx = bcx.fcx;\n             let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n             let scratch = unpack_datum!(bcx, datum::lvalue_scratch_datum(\n-                bcx, tcx.types.bool, \"drop_flag\",\n+                bcx, tcx.dtor_type(), \"drop_flag\",\n                 cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| bcx\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {\n@@ -1046,7 +1098,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             C_integral(ll_inttype(ccx, ity), discr as u64, true)\n         }\n         General(ity, ref cases, _) => {\n-            let case = &cases[discr as uint];\n+            let case = &cases[discr as usize];\n             let (max_sz, _) = union_size_and_align(&cases[..]);\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let mut f = vec![lldiscr];\n@@ -1184,7 +1236,7 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef) -> Disr {\n /// (Not to be confused with `common::const_get_elt`, which operates on\n /// raw LLVM-level structs and arrays.)\n pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n-                       _discr: Disr, ix: uint) -> ValueRef {\n+                       _discr: Disr, ix: usize) -> ValueRef {\n     match *r {\n         CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n         Univariant(..) => const_struct_field(ccx, val, ix),\n@@ -1198,7 +1250,7 @@ pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n }\n \n /// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint) -> ValueRef {\n+fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: usize) -> ValueRef {\n     // Get the ix-th non-undef element of the struct.\n     let mut real_ix = 0; // actual position in the struct\n     let mut ix = ix; // logical index relative to real_ix"}, {"sha": "d9c90945925e7b27730e39ea439006b996e420b1", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -151,7 +151,7 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n pub struct StatRecorder<'a, 'tcx: 'a> {\n     ccx: &'a CrateContext<'a, 'tcx>,\n     name: Option<String>,\n-    istart: uint,\n+    istart: usize,\n }\n \n impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n@@ -707,7 +707,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                     substs, &mut f);\n               }\n               (_match::Switch, Some(lldiscrim_a)) => {\n-                  cx = f(cx, lldiscrim_a, cx.tcx().types.int);\n+                  cx = f(cx, lldiscrim_a, cx.tcx().types.isize);\n                   let unr_cx = fcx.new_temp_block(\"enum-iter-unr\");\n                   Unreachable(unr_cx);\n                   let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb,\n@@ -847,8 +847,8 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             ty::ty_int(t) => {\n                 let llty = Type::int_from_ty(cx.ccx(), t);\n                 let min = match t {\n-                    ast::TyIs(_) if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n-                    ast::TyIs(_) => i64::MIN as u64,\n+                    ast::TyIs if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n+                    ast::TyIs => i64::MIN as u64,\n                     ast::TyI8 => i8::MIN as u64,\n                     ast::TyI16 => i16::MIN as u64,\n                     ast::TyI32 => i32::MIN as u64,\n@@ -1146,20 +1146,27 @@ pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n+pub fn drop_done_fill_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n     if cx.unreachable.get() { return; }\n-    let _icx = push_ctxt(\"zero_mem\");\n+    let _icx = push_ctxt(\"drop_done_fill_mem\");\n     let bcx = cx;\n-    memzero(&B(bcx), llptr, t);\n+    memfill(&B(bcx), llptr, t, adt::DTOR_DONE);\n }\n \n-// Always use this function instead of storing a zero constant to the memory\n-// in question. If you store a zero constant, LLVM will drown in vreg\n+pub fn init_zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n+    if cx.unreachable.get() { return; }\n+    let _icx = push_ctxt(\"init_zero_mem\");\n+    let bcx = cx;\n+    memfill(&B(bcx), llptr, t, 0);\n+}\n+\n+// Always use this function instead of storing a constant byte to the memory\n+// in question. e.g. if you store a zero constant, LLVM will drown in vreg\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n-    let _icx = push_ctxt(\"memzero\");\n+fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte: u8) {\n+    let _icx = push_ctxt(\"memfill\");\n     let ccx = b.ccx;\n \n     let llty = type_of::type_of(ccx, ty);\n@@ -1172,7 +1179,7 @@ fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n \n     let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n     let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());\n-    let llzeroval = C_u8(ccx, 0);\n+    let llzeroval = C_u8(ccx, byte as usize);\n     let size = machine::llsize_of(ccx, llty);\n     let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n     let volatile = C_bool(ccx, false);\n@@ -3022,6 +3029,12 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         tcx.sess.opts.debug_assertions\n     };\n \n+    let check_dropflag = if let Some(v) = tcx.sess.opts.debugging_opts.force_dropflag_checks {\n+        v\n+    } else {\n+        tcx.sess.opts.debug_assertions\n+    };\n+\n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n         use std::sync::{Once, ONCE_INIT};\n@@ -3050,7 +3063,8 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n                                              Sha256::new(),\n                                              link_meta.clone(),\n                                              reachable,\n-                                             check_overflow);\n+                                             check_overflow,\n+                                             check_dropflag);\n \n     {\n         let ccx = shared_ccx.get_ccx(0);"}, {"sha": "a16c4d6c2c4a78f1e1bb42a1095df124622a7167", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -105,7 +105,7 @@ pub fn CondBr(cx: Block,\n     B(cx).cond_br(if_, then, else_);\n }\n \n-pub fn Switch(cx: Block, v: ValueRef, else_: BasicBlockRef, num_cases: uint)\n+pub fn Switch(cx: Block, v: ValueRef, else_: BasicBlockRef, num_cases: usize)\n     -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     check_not_terminated(cx);\n@@ -122,7 +122,7 @@ pub fn AddCase(s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n \n pub fn IndirectBr(cx: Block,\n                   addr: ValueRef,\n-                  num_dests: uint,\n+                  num_dests: usize,\n                   debug_loc: DebugLoc) {\n     if cx.unreachable.get() {\n         return;\n@@ -673,7 +673,7 @@ pub fn GEP(cx: Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n #[inline]\n-pub fn GEPi(cx: Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n+pub fn GEPi(cx: Block, base: ValueRef, ixs: &[usize]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n@@ -691,7 +691,7 @@ pub fn InBoundsGEP(cx: Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueR\n     }\n }\n \n-pub fn StructGEP(cx: Block, pointer: ValueRef, idx: uint) -> ValueRef {\n+pub fn StructGEP(cx: Block, pointer: ValueRef, idx: usize) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n@@ -1011,7 +1011,7 @@ pub fn ShuffleVector(cx: Block, v1: ValueRef, v2: ValueRef,\n     }\n }\n \n-pub fn VectorSplat(cx: Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n+pub fn VectorSplat(cx: Block, num_elts: usize, elt_val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -1020,7 +1020,7 @@ pub fn VectorSplat(cx: Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn ExtractValue(cx: Block, agg_val: ValueRef, index: uint) -> ValueRef {\n+pub fn ExtractValue(cx: Block, agg_val: ValueRef, index: usize) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -1029,7 +1029,7 @@ pub fn ExtractValue(cx: Block, agg_val: ValueRef, index: uint) -> ValueRef {\n     }\n }\n \n-pub fn InsertValue(cx: Block, agg_val: ValueRef, elt_val: ValueRef, index: uint) -> ValueRef {\n+pub fn InsertValue(cx: Block, agg_val: ValueRef, elt_val: ValueRef, index: usize) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -1070,7 +1070,7 @@ pub fn Trap(cx: Block) {\n }\n \n pub fn LandingPad(cx: Block, ty: Type, pers_fn: ValueRef,\n-                  num_clauses: uint) -> ValueRef {\n+                  num_clauses: usize) -> ValueRef {\n     check_not_terminated(cx);\n     assert!(!cx.unreachable.get());\n     B(cx).landing_pad(ty, pers_fn, num_clauses)"}, {"sha": "92bc20bafcfbe59412f82290db5173b71a044e6c", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -140,13 +140,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn switch(&self, v: ValueRef, else_llbb: BasicBlockRef, num_cases: uint) -> ValueRef {\n+    pub fn switch(&self, v: ValueRef, else_llbb: BasicBlockRef, num_cases: usize) -> ValueRef {\n         unsafe {\n             llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, num_cases as c_uint)\n         }\n     }\n \n-    pub fn indirect_br(&self, addr: ValueRef, num_dests: uint) {\n+    pub fn indirect_br(&self, addr: ValueRef, num_dests: usize) {\n         self.count_insn(\"indirectbr\");\n         unsafe {\n             llvm::LLVMBuildIndirectBr(self.llbuilder, addr, num_dests as c_uint);\n@@ -555,7 +555,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Simple wrapper around GEP that takes an array of ints and wraps them\n     // in C_i32()\n     #[inline]\n-    pub fn gepi(&self, base: ValueRef, ixs: &[uint]) -> ValueRef {\n+    pub fn gepi(&self, base: ValueRef, ixs: &[usize]) -> ValueRef {\n         // Small vector optimization. This should catch 100% of the cases that\n         // we care about.\n         if ixs.len() < 16 {\n@@ -579,7 +579,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn struct_gep(&self, ptr: ValueRef, idx: uint) -> ValueRef {\n+    pub fn struct_gep(&self, ptr: ValueRef, idx: usize) -> ValueRef {\n         self.count_insn(\"structgep\");\n         unsafe {\n             llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n@@ -886,7 +886,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn vector_splat(&self, num_elts: uint, elt: ValueRef) -> ValueRef {\n+    pub fn vector_splat(&self, num_elts: usize, elt: ValueRef) -> ValueRef {\n         unsafe {\n             let elt_ty = val_ty(elt);\n             let undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, num_elts as u64).to_ref());\n@@ -896,15 +896,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn extract_value(&self, agg_val: ValueRef, idx: uint) -> ValueRef {\n+    pub fn extract_value(&self, agg_val: ValueRef, idx: usize) -> ValueRef {\n         self.count_insn(\"extractvalue\");\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n         }\n     }\n \n     pub fn insert_value(&self, agg_val: ValueRef, elt: ValueRef,\n-                       idx: uint) -> ValueRef {\n+                       idx: usize) -> ValueRef {\n         self.count_insn(\"insertvalue\");\n         unsafe {\n             llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint,\n@@ -940,15 +940,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let m: ModuleRef = llvm::LLVMGetGlobalParent(fn_);\n             let p = \"llvm.trap\\0\".as_ptr();\n             let t: ValueRef = llvm::LLVMGetNamedFunction(m, p as *const _);\n-            assert!((t as int != 0));\n+            assert!((t as isize != 0));\n             let args: &[ValueRef] = &[];\n             self.count_insn(\"trap\");\n             llvm::LLVMBuildCall(\n                 self.llbuilder, t, args.as_ptr(), args.len() as c_uint, noname());\n         }\n     }\n \n-    pub fn landing_pad(&self, ty: Type, pers_fn: ValueRef, num_clauses: uint) -> ValueRef {\n+    pub fn landing_pad(&self, ty: Type, pers_fn: ValueRef, num_clauses: usize) -> ValueRef {\n         self.count_insn(\"landingpad\");\n         unsafe {\n             llvm::LLVMBuildLandingPad("}, {"sha": "8ac4f84d6ef9f9088db9e15af7ac05c49e36f148", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -18,18 +18,18 @@ use trans::type_::Type;\n \n use std::cmp;\n \n-fn align_up_to(off: uint, a: uint) -> uint {\n+fn align_up_to(off: usize, a: usize) -> usize {\n     return (off + a - 1) / a * a;\n }\n \n-fn align(off: uint, ty: Type) -> uint {\n+fn align(off: usize, ty: Type) -> usize {\n     let a = ty_align(ty);\n     return align_up_to(off, a);\n }\n \n-fn ty_align(ty: Type) -> uint {\n+fn ty_align(ty: Type) -> usize {\n     match ty.kind() {\n-        Integer => ((ty.int_width() as uint) + 7) / 8,\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n         Pointer => 8,\n         Float => 4,\n         Double => 8,\n@@ -54,9 +54,9 @@ fn ty_align(ty: Type) -> uint {\n     }\n }\n \n-fn ty_size(ty: Type) -> uint {\n+fn ty_size(ty: Type) -> usize {\n     match ty.kind() {\n-        Integer => ((ty.int_width() as uint) + 7) / 8,\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n         Pointer => 8,\n         Float => 4,\n         Double => 8,"}, {"sha": "941c065e3d5d43b9769ce8bc49bf44c60dd0bf64", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -23,20 +23,20 @@ pub enum Flavor {\n     Ios\n }\n \n-type TyAlignFn = fn(ty: Type) -> uint;\n+type TyAlignFn = fn(ty: Type) -> usize;\n \n-fn align_up_to(off: uint, a: uint) -> uint {\n+fn align_up_to(off: usize, a: usize) -> usize {\n     return (off + a - 1) / a * a;\n }\n \n-fn align(off: uint, ty: Type, align_fn: TyAlignFn) -> uint {\n+fn align(off: usize, ty: Type, align_fn: TyAlignFn) -> usize {\n     let a = align_fn(ty);\n     return align_up_to(off, a);\n }\n \n-fn general_ty_align(ty: Type) -> uint {\n+fn general_ty_align(ty: Type) -> usize {\n     match ty.kind() {\n-        Integer => ((ty.int_width() as uint) + 7) / 8,\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n         Pointer => 4,\n         Float => 4,\n         Double => 8,\n@@ -68,9 +68,9 @@ fn general_ty_align(ty: Type) -> uint {\n // ARMv6\n // https://developer.apple.com/library/ios/documentation/Xcode/Conceptual\n //    /iPhoneOSABIReference/Articles/ARMv6FunctionCallingConventions.html\n-fn ios_ty_align(ty: Type) -> uint {\n+fn ios_ty_align(ty: Type) -> usize {\n     match ty.kind() {\n-        Integer => cmp::min(4, ((ty.int_width() as uint) + 7) / 8),\n+        Integer => cmp::min(4, ((ty.int_width() as usize) + 7) / 8),\n         Pointer => 4,\n         Float => 4,\n         Double => 4,\n@@ -95,9 +95,9 @@ fn ios_ty_align(ty: Type) -> uint {\n     }\n }\n \n-fn ty_size(ty: Type, align_fn: TyAlignFn) -> uint {\n+fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n     match ty.kind() {\n-        Integer => ((ty.int_width() as uint) + 7) / 8,\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n         Pointer => 4,\n         Float => 4,\n         Double => 8,"}, {"sha": "2d7fdd2f2eba47a0acdcff06e96804d69bb680e3", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -19,18 +19,18 @@ use trans::cabi::{ArgType, FnType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n-fn align_up_to(off: uint, a: uint) -> uint {\n+fn align_up_to(off: usize, a: usize) -> usize {\n     return (off + a - 1) / a * a;\n }\n \n-fn align(off: uint, ty: Type) -> uint {\n+fn align(off: usize, ty: Type) -> usize {\n     let a = ty_align(ty);\n     return align_up_to(off, a);\n }\n \n-fn ty_align(ty: Type) -> uint {\n+fn ty_align(ty: Type) -> usize {\n     match ty.kind() {\n-        Integer => ((ty.int_width() as uint) + 7) / 8,\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n         Pointer => 4,\n         Float => 4,\n         Double => 8,\n@@ -55,9 +55,9 @@ fn ty_align(ty: Type) -> uint {\n     }\n }\n \n-fn ty_size(ty: Type) -> uint {\n+fn ty_size(ty: Type) -> usize {\n     match ty.kind() {\n-        Integer => ((ty.int_width() as uint) + 7) / 8,\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n         Pointer => 4,\n         Float => 4,\n         Double => 8,\n@@ -96,7 +96,7 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut uint) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType {\n     let orig_offset = *offset;\n     let size = ty_size(ty) * 8;\n     let mut align = ty_align(ty);\n@@ -129,15 +129,15 @@ fn is_reg_ty(ty: Type) -> bool {\n     };\n }\n \n-fn padding_ty(ccx: &CrateContext, align: uint, offset: uint) -> Option<Type> {\n+fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n     if ((align - 1 ) & offset) > 0 {\n         Some(Type::i32(ccx))\n     } else {\n         None\n     }\n }\n \n-fn coerce_to_int(ccx: &CrateContext, size: uint) -> Vec<Type> {\n+fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n     let int_ty = Type::i32(ccx);\n     let mut args = Vec::new();\n "}, {"sha": "8c30d4fcc2b1f2c35310ee9dd557819f4e1f8842", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -18,20 +18,20 @@ use trans::type_::Type;\n \n use std::cmp;\n \n-fn align_up_to(off: uint, a: uint) -> uint {\n+fn align_up_to(off: usize, a: usize) -> usize {\n     return (off + a - 1) / a * a;\n }\n \n-fn align(off: uint, ty: Type) -> uint {\n+fn align(off: usize, ty: Type) -> usize {\n     let a = ty_align(ty);\n     return align_up_to(off, a);\n }\n \n-fn ty_align(ty: Type) -> uint {\n+fn ty_align(ty: Type) -> usize {\n     match ty.kind() {\n         Integer => {\n             unsafe {\n-                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n+                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as usize) + 7) / 8\n             }\n         }\n         Pointer => 4,\n@@ -53,11 +53,11 @@ fn ty_align(ty: Type) -> uint {\n     }\n }\n \n-fn ty_size(ty: Type) -> uint {\n+fn ty_size(ty: Type) -> usize {\n     match ty.kind() {\n         Integer => {\n             unsafe {\n-                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n+                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as usize) + 7) / 8\n             }\n         }\n         Pointer => 4,\n@@ -92,7 +92,7 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut uint) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType {\n     let orig_offset = *offset;\n     let size = ty_size(ty) * 8;\n     let mut align = ty_align(ty);\n@@ -124,15 +124,15 @@ fn is_reg_ty(ty: Type) -> bool {\n     };\n }\n \n-fn padding_ty(ccx: &CrateContext, align: uint, offset: uint) -> Option<Type> {\n+fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n     if ((align - 1 ) & offset) > 0 {\n         Some(Type::i32(ccx))\n     } else {\n         None\n     }\n }\n \n-fn coerce_to_int(ccx: &CrateContext, size: uint) -> Vec<Type> {\n+fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n     let int_ty = Type::i32(ccx);\n     let mut args = Vec::new();\n "}, {"sha": "754b7ee5cf555d7c26ad89e7ecb3947d8b759ef3", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -86,14 +86,14 @@ impl ClassList for [RegClass] {\n }\n \n fn classify_ty(ty: Type) -> Vec<RegClass> {\n-    fn align(off: uint, ty: Type) -> uint {\n+    fn align(off: usize, ty: Type) -> usize {\n         let a = ty_align(ty);\n         return (off + a - 1) / a * a;\n     }\n \n-    fn ty_align(ty: Type) -> uint {\n+    fn ty_align(ty: Type) -> usize {\n         match ty.kind() {\n-            Integer => ((ty.int_width() as uint) + 7) / 8,\n+            Integer => ((ty.int_width() as usize) + 7) / 8,\n             Pointer => 8,\n             Float => 4,\n             Double => 8,\n@@ -118,9 +118,9 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n         }\n     }\n \n-    fn ty_size(ty: Type) -> uint {\n+    fn ty_size(ty: Type) -> usize {\n         match ty.kind() {\n-            Integer => (ty.int_width() as uint + 7) / 8,\n+            Integer => (ty.int_width() as usize + 7) / 8,\n             Pointer => 8,\n             Float => 4,\n             Double => 8,\n@@ -157,7 +157,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     }\n \n     fn unify(cls: &mut [RegClass],\n-             i: uint,\n+             i: usize,\n              newv: RegClass) {\n         if cls[i] == newv { return }\n \n@@ -191,8 +191,8 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n \n     fn classify_struct(tys: &[Type],\n                        cls: &mut [RegClass],\n-                       i: uint,\n-                       off: uint,\n+                       i: usize,\n+                       off: usize,\n                        packed: bool) {\n         let mut field_off = off;\n         for ty in tys {\n@@ -205,8 +205,8 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     }\n \n     fn classify(ty: Type,\n-                cls: &mut [RegClass], ix: uint,\n-                off: uint) {\n+                cls: &mut [RegClass], ix: usize,\n+                off: usize) {\n         let t_align = ty_align(ty);\n         let t_size = ty_size(ty);\n \n@@ -331,7 +331,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n }\n \n fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n-    fn llvec_len(cls: &[RegClass]) -> uint {\n+    fn llvec_len(cls: &[RegClass]) -> usize {\n         let mut len = 1;\n         for c in cls {\n             if *c != SSEUp {"}, {"sha": "4897ae286d3e96354b19cbeb5dbbf3bb40beddb9", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -155,12 +155,12 @@ pub struct CleanupScope<'blk, 'tcx: 'blk> {\n \n #[derive(Copy, Debug)]\n pub struct CustomScopeIndex {\n-    index: uint\n+    index: usize\n }\n \n-pub const EXIT_BREAK: uint = 0;\n-pub const EXIT_LOOP: uint = 1;\n-pub const EXIT_MAX: uint = 2;\n+pub const EXIT_BREAK: usize = 0;\n+pub const EXIT_LOOP: usize = 1;\n+pub const EXIT_MAX: usize = 2;\n \n pub enum CleanupScopeKind<'blk, 'tcx: 'blk> {\n     CustomScopeKind,\n@@ -188,7 +188,7 @@ impl<'blk, 'tcx: 'blk> fmt::Debug for CleanupScopeKind<'blk, 'tcx> {\n pub enum EarlyExitLabel {\n     UnwindExit,\n     ReturnExit,\n-    LoopExit(ast::NodeId, uint)\n+    LoopExit(ast::NodeId, usize)\n }\n \n #[derive(Copy)]\n@@ -357,7 +357,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     /// break/continue (depending on `exit`) out of the loop with id `cleanup_scope`\n     fn normal_exit_block(&'blk self,\n                          cleanup_scope: ast::NodeId,\n-                         exit: uint) -> BasicBlockRef {\n+                         exit: usize) -> BasicBlockRef {\n         self.trans_cleanups_to_exit_scope(LoopExit(cleanup_scope, exit))\n     }\n \n@@ -585,7 +585,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         None\n     }\n \n-    fn top_nonempty_cleanup_scope(&self) -> Option<uint> {\n+    fn top_nonempty_cleanup_scope(&self) -> Option<usize> {\n         self.scopes.borrow().iter().rev().position(|s| !s.cleanups.is_empty())\n     }\n \n@@ -614,7 +614,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         bcx\n     }\n \n-    fn scopes_len(&self) -> uint {\n+    fn scopes_len(&self) -> usize {\n         self.scopes.borrow().len()\n     }\n \n@@ -962,7 +962,7 @@ impl<'blk, 'tcx> CleanupScopeKind<'blk, 'tcx> {\n     /// If this is a loop scope with id `id`, return the early exit block `exit`, else `None`\n     fn early_exit_block(&self,\n                         id: ast::NodeId,\n-                        exit: uint) -> Option<BasicBlockRef> {\n+                        exit: usize) -> Option<BasicBlockRef> {\n         match *self {\n             LoopScopeKind(i, ref exits) if id == i => Some(exits[exit].llbb),\n             _ => None,\n@@ -1015,7 +1015,7 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n             glue::drop_ty(bcx, self.val, self.ty, debug_loc)\n         };\n         if self.zero {\n-            base::zero_mem(bcx, self.val, self.ty);\n+            base::drop_done_fill_mem(bcx, self.val, self.ty);\n         }\n         bcx\n     }\n@@ -1182,7 +1182,7 @@ pub trait CleanupMethods<'blk, 'tcx> {\n     fn top_loop_scope(&self) -> ast::NodeId;\n     fn normal_exit_block(&'blk self,\n                          cleanup_scope: ast::NodeId,\n-                         exit: uint) -> BasicBlockRef;\n+                         exit: usize) -> BasicBlockRef;\n     fn return_exit_block(&'blk self) -> BasicBlockRef;\n     fn schedule_lifetime_end(&self,\n                          cleanup_scope: ScopeId,\n@@ -1225,7 +1225,7 @@ pub trait CleanupMethods<'blk, 'tcx> {\n \n trait CleanupHelperMethods<'blk, 'tcx> {\n     fn top_ast_scope(&self) -> Option<ast::NodeId>;\n-    fn top_nonempty_cleanup_scope(&self) -> Option<uint>;\n+    fn top_nonempty_cleanup_scope(&self) -> Option<usize>;\n     fn is_valid_to_pop_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool;\n     fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool;\n     fn trans_scope_cleanups(&self,\n@@ -1235,7 +1235,7 @@ trait CleanupHelperMethods<'blk, 'tcx> {\n                                     label: EarlyExitLabel)\n                                     -> BasicBlockRef;\n     fn get_or_create_landing_pad(&'blk self) -> BasicBlockRef;\n-    fn scopes_len(&self) -> uint;\n+    fn scopes_len(&self) -> usize;\n     fn push_scope(&self, scope: CleanupScope<'blk, 'tcx>);\n     fn pop_scope(&self) -> CleanupScope<'blk, 'tcx>;\n     fn top_scope<R, F>(&self, f: F) -> R where F: FnOnce(&CleanupScope<'blk, 'tcx>) -> R;"}, {"sha": "745098d6e87d11f9b1b8cac372e313dadbb91e40", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -459,7 +459,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    pub fn arg_pos(&self, arg: uint) -> uint {\n+    pub fn arg_pos(&self, arg: usize) -> usize {\n         let arg = self.env_arg_pos() + arg;\n         if self.llenv.is_some() {\n             arg + 1\n@@ -468,7 +468,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn env_arg_pos(&self) -> uint {\n+    pub fn env_arg_pos(&self) -> usize {\n         if self.caller_expects_out_pointer {\n             1\n         } else {\n@@ -846,13 +846,13 @@ pub trait AsU64 { fn as_u64(self) -> u64; }\n // are host-architecture-dependent\n impl AsI64 for i64 { fn as_i64(self) -> i64 { self as i64 }}\n impl AsI64 for i32 { fn as_i64(self) -> i64 { self as i64 }}\n-impl AsI64 for int { fn as_i64(self) -> i64 { self as i64 }}\n+impl AsI64 for isize { fn as_i64(self) -> i64 { self as i64 }}\n \n impl AsU64 for u64  { fn as_u64(self) -> u64 { self as u64 }}\n impl AsU64 for u32  { fn as_u64(self) -> u64 { self as u64 }}\n-impl AsU64 for uint { fn as_u64(self) -> u64 { self as u64 }}\n+impl AsU64 for usize { fn as_u64(self) -> u64 { self as u64 }}\n \n-pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n+pub fn C_u8(ccx: &CrateContext, i: usize) -> ValueRef {\n     C_integral(Type::i8(ccx), i as u64, false)\n }\n \n@@ -1069,17 +1069,30 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     vtable\n }\n \n-pub fn predicates_hold<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                 predicates: Vec<ty::Predicate<'tcx>>)\n-                                 -> bool\n+/// Normalizes the predicates and checks whether they hold.  If this\n+/// returns false, then either normalize encountered an error or one\n+/// of the predicates did not hold. Used when creating vtables to\n+/// check for unsatisfiable methods.\n+pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                               predicates: Vec<ty::Predicate<'tcx>>)\n+                                               -> bool\n {\n-    debug!(\"predicates_hold(predicates={})\",\n+    debug!(\"normalize_and_test_predicates(predicates={})\",\n            predicates.repr(ccx.tcx()));\n \n-    let infcx = infer::new_infer_ctxt(ccx.tcx());\n+    let tcx = ccx.tcx();\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    let typer = NormalizingClosureTyper::new(tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let cause = traits::ObligationCause::dummy();\n+    let traits::Normalized { value: predicates, obligations } =\n+        traits::normalize(&mut selcx, cause.clone(), &predicates);\n+    for obligation in obligations {\n+        fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+    }\n     for predicate in predicates {\n-        let obligation = traits::Obligation::new(traits::ObligationCause::dummy(), predicate);\n+        let obligation = traits::Obligation::new(cause.clone(), predicate);\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n     drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()).is_ok()"}, {"sha": "348335139da649e4c4a8a4919cfd376c5c9d36ec", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -53,7 +53,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n                 }\n                 _ => cx.sess().span_bug(lit.span,\n                         &format!(\"integer literal has type {} (expected int \\\n-                                 or uint)\",\n+                                 or usize)\",\n                                 ty_to_string(cx.tcx(), lit_int_ty)))\n             }\n         }\n@@ -652,8 +652,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let n = match const_eval::eval_const_expr_partial(cx.tcx(), &**count, None) {\n-                Ok(const_eval::const_int(i))  => i as uint,\n-                Ok(const_eval::const_uint(i)) => i as uint,\n+                Ok(const_eval::const_int(i))  => i as usize,\n+                Ok(const_eval::const_uint(i)) => i as usize,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n             let unit_val = const_expr(cx, &**elem, param_substs).0;"}, {"sha": "6566f3818f182a1cff253159e8f12c53beb8c344", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -38,17 +38,17 @@ use syntax::ast;\n use syntax::parse::token::InternedString;\n \n pub struct Stats {\n-    pub n_glues_created: Cell<uint>,\n-    pub n_null_glues: Cell<uint>,\n-    pub n_real_glues: Cell<uint>,\n-    pub n_fns: Cell<uint>,\n-    pub n_monos: Cell<uint>,\n-    pub n_inlines: Cell<uint>,\n-    pub n_closures: Cell<uint>,\n-    pub n_llvm_insns: Cell<uint>,\n-    pub llvm_insns: RefCell<FnvHashMap<String, uint>>,\n+    pub n_glues_created: Cell<usize>,\n+    pub n_null_glues: Cell<usize>,\n+    pub n_real_glues: Cell<usize>,\n+    pub n_fns: Cell<usize>,\n+    pub n_monos: Cell<usize>,\n+    pub n_inlines: Cell<usize>,\n+    pub n_closures: Cell<usize>,\n+    pub n_llvm_insns: Cell<usize>,\n+    pub llvm_insns: RefCell<FnvHashMap<String, usize>>,\n     // (ident, llvm-instructions)\n-    pub fn_stats: RefCell<Vec<(String, uint)> >,\n+    pub fn_stats: RefCell<Vec<(String, usize)> >,\n }\n \n /// The shared portion of a `CrateContext`.  There is one `SharedCrateContext`\n@@ -69,6 +69,7 @@ pub struct SharedCrateContext<'tcx> {\n     tcx: ty::ctxt<'tcx>,\n     stats: Stats,\n     check_overflow: bool,\n+    check_drop_flag_for_sanity: bool,\n \n     available_monomorphizations: RefCell<FnvHashSet<String>>,\n     available_drop_glues: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n@@ -95,7 +96,7 @@ pub struct LocalCrateContext<'tcx> {\n     external_srcs: RefCell<NodeMap<ast::DefId>>,\n     /// Cache instances of monomorphized functions\n     monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n-    monomorphizing: RefCell<DefIdMap<uint>>,\n+    monomorphizing: RefCell<DefIdMap<usize>>,\n     /// Cache generated vtables\n     vtables: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n     /// Cache of constant strings,\n@@ -149,7 +150,7 @@ pub struct LocalCrateContext<'tcx> {\n     /// Number of LLVM instructions translated into this `LocalCrateContext`.\n     /// This is used to perform some basic load-balancing to keep all LLVM\n     /// contexts around the same size.\n-    n_llvm_insns: Cell<uint>,\n+    n_llvm_insns: Cell<usize>,\n \n     trait_cache: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>,\n                                     traits::Vtable<'tcx, ()>>>,\n@@ -160,12 +161,12 @@ pub struct CrateContext<'a, 'tcx: 'a> {\n     local: &'a LocalCrateContext<'tcx>,\n     /// The index of `local` in `shared.local_ccxs`.  This is used in\n     /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n-    index: uint,\n+    index: usize,\n }\n \n pub struct CrateContextIterator<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'tcx>,\n-    index: uint,\n+    index: usize,\n }\n \n impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n@@ -190,9 +191,9 @@ impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n /// The iterator produced by `CrateContext::maybe_iter`.\n pub struct CrateContextMaybeIterator<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'tcx>,\n-    index: uint,\n+    index: usize,\n     single: bool,\n-    origin: uint,\n+    origin: usize,\n }\n \n impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n@@ -236,13 +237,14 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n \n impl<'tcx> SharedCrateContext<'tcx> {\n     pub fn new(crate_name: &str,\n-               local_count: uint,\n+               local_count: usize,\n                tcx: ty::ctxt<'tcx>,\n                export_map: ExportMap,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet,\n-               check_overflow: bool)\n+               check_overflow: bool,\n+               check_drop_flag_for_sanity: bool)\n                -> SharedCrateContext<'tcx> {\n         let (metadata_llcx, metadata_llmod) = unsafe {\n             create_context_and_module(&tcx.sess, \"metadata\")\n@@ -271,6 +273,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n                 fn_stats: RefCell::new(Vec::new()),\n             },\n             check_overflow: check_overflow,\n+            check_drop_flag_for_sanity: check_drop_flag_for_sanity,\n             available_monomorphizations: RefCell::new(FnvHashSet()),\n             available_drop_glues: RefCell::new(FnvHashMap()),\n         };\n@@ -299,7 +302,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n         }\n     }\n \n-    pub fn get_ccx<'a>(&'a self, index: uint) -> CrateContext<'a, 'tcx> {\n+    pub fn get_ccx<'a>(&'a self, index: usize) -> CrateContext<'a, 'tcx> {\n         CrateContext {\n             shared: self,\n             local: &self.local_ccxs[index],\n@@ -456,7 +459,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n         CrateContext {\n             shared: shared,\n             local: self,\n-            index: -1 as uint,\n+            index: -1 as usize,\n         }\n     }\n }\n@@ -588,7 +591,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.monomorphized\n     }\n \n-    pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<uint>> {\n+    pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<usize>> {\n         &self.local.monomorphizing\n     }\n \n@@ -727,6 +730,13 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn check_overflow(&self) -> bool {\n         self.shared.check_overflow\n     }\n+\n+    pub fn check_drop_flag_for_sanity(&self) -> bool {\n+        // This controls whether we emit a conditional llvm.debugtrap\n+        // guarded on whether the dropflag is one of its (two) valid\n+        // values.\n+        self.shared.check_drop_flag_for_sanity\n+    }\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {"}, {"sha": "bd31580333fab25f5cfba61820afbdfcea84dfb0", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -293,7 +293,7 @@ pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     expr: &ast::Expr,\n                                     opt_label: Option<Ident>,\n-                                    exit: uint)\n+                                    exit: usize)\n                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_break_cont\");\n     let fcx = bcx.fcx;"}, {"sha": "399b7eb102e83cc478a67588e90e43375b51ce7d", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -307,8 +307,8 @@ impl KindOps for Lvalue {\n                               -> Block<'blk, 'tcx> {\n         let _icx = push_ctxt(\"<Lvalue as KindOps>::post_store\");\n         if bcx.fcx.type_needs_drop(ty) {\n-            // cancel cleanup of affine values by zeroing out\n-            let () = zero_mem(bcx, val, ty);\n+            // cancel cleanup of affine values by drop-filling the memory\n+            let () = drop_done_fill_mem(bcx, val, ty);\n             bcx\n         } else {\n             bcx"}, {"sha": "f2c24501c66c8e6c97856919fa471b01f01b0fcb", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -694,7 +694,7 @@ impl FunctionDebugContext {\n struct FunctionDebugContextData {\n     scope_map: RefCell<NodeMap<DIScope>>,\n     fn_metadata: DISubprogram,\n-    argument_counter: Cell<uint>,\n+    argument_counter: Cell<usize>,\n     source_locations_enabled: Cell<bool>,\n     source_location_override: Cell<bool>,\n }\n@@ -708,7 +708,7 @@ enum VariableAccess<'a> {\n }\n \n enum VariableKind {\n-    ArgumentVariable(uint /*index*/),\n+    ArgumentVariable(usize /*index*/),\n     LocalVariable,\n     CapturedVariable,\n }\n@@ -876,7 +876,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                 node_id: ast::NodeId,\n                                                 env_pointer: ValueRef,\n-                                                env_index: uint,\n+                                                env_index: usize,\n                                                 captured_by_ref: bool,\n                                                 span: Span) {\n     if bcx.unreachable.get() ||\n@@ -1814,14 +1814,14 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_bool => (\"bool\".to_string(), DW_ATE_boolean),\n         ty::ty_char => (\"char\".to_string(), DW_ATE_unsigned_char),\n         ty::ty_int(int_ty) => match int_ty {\n-            ast::TyIs(_) => (\"isize\".to_string(), DW_ATE_signed),\n+            ast::TyIs => (\"isize\".to_string(), DW_ATE_signed),\n             ast::TyI8 => (\"i8\".to_string(), DW_ATE_signed),\n             ast::TyI16 => (\"i16\".to_string(), DW_ATE_signed),\n             ast::TyI32 => (\"i32\".to_string(), DW_ATE_signed),\n             ast::TyI64 => (\"i64\".to_string(), DW_ATE_signed)\n         },\n         ty::ty_uint(uint_ty) => match uint_ty {\n-            ast::TyUs(_) => (\"usize\".to_string(), DW_ATE_unsigned),\n+            ast::TyUs => (\"usize\".to_string(), DW_ATE_unsigned),\n             ast::TyU8 => (\"u8\".to_string(), DW_ATE_unsigned),\n             ast::TyU16 => (\"u16\".to_string(), DW_ATE_unsigned),\n             ast::TyU32 => (\"u32\".to_string(), DW_ATE_unsigned),\n@@ -1873,7 +1873,7 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n //=-----------------------------------------------------------------------------\n \n enum MemberOffset {\n-    FixedMemberOffset { bytes: uint },\n+    FixedMemberOffset { bytes: usize },\n     // For ComputedMemberOffset, the offset is read from the llvm type definition\n     ComputedMemberOffset\n }\n@@ -2022,7 +2022,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n         }\n \n         let field_size = if self.is_simd {\n-            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields[0].mt.ty)) as uint\n+            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields[0].mt.ty)) as usize\n         } else {\n             0xdeadbeef\n         };\n@@ -2245,7 +2245,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // DWARF representation of enums uniform.\n \n                 // First create a description of the artificial wrapper struct:\n-                let non_null_variant = &(*self.variants)[non_null_variant_index as uint];\n+                let non_null_variant = &(*self.variants)[non_null_variant_index as usize];\n                 let non_null_variant_name = token::get_name(non_null_variant.name);\n \n                 // The llvm type and metadata of the pointer\n@@ -2290,7 +2290,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n-                let null_variant_index = (1 - non_null_variant_index) as uint;\n+                let null_variant_index = (1 - non_null_variant_index) as usize;\n                 let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 0,\n@@ -2316,7 +2316,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n-                                          &*(*self.variants)[nndiscr as uint],\n+                                          &*(*self.variants)[nndiscr as usize],\n                                           OptimizedDiscriminant,\n                                           self.containing_scope,\n                                           self.span);\n@@ -2331,7 +2331,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n-                let null_variant_index = (1 - nndiscr) as uint;\n+                let null_variant_index = (1 - nndiscr) as usize;\n                 let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n                 let discrfield = discrfield.iter()\n                                            .skip(1)\n@@ -2813,7 +2813,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         MemberDescription {\n             name: \"length\".to_string(),\n             llvm_type: member_llvm_types[1],\n-            type_metadata: type_metadata(cx, cx.tcx().types.uint, span),\n+            type_metadata: type_metadata(cx, cx.tcx().types.usize, span),\n             offset: ComputedMemberOffset,\n             flags: FLAGS_NONE\n         },\n@@ -3108,12 +3108,12 @@ impl MetadataCreationResult {\n \n #[derive(Copy, PartialEq)]\n enum InternalDebugLocation {\n-    KnownLocation { scope: DIScope, line: uint, col: uint },\n+    KnownLocation { scope: DIScope, line: usize, col: usize },\n     UnknownLocation\n }\n \n impl InternalDebugLocation {\n-    fn new(scope: DIScope, line: uint, col: uint) -> InternalDebugLocation {\n+    fn new(scope: DIScope, line: usize, col: usize) -> InternalDebugLocation {\n         KnownLocation {\n             scope: scope,\n             line: line,\n@@ -3745,12 +3745,12 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_bool              => output.push_str(\"bool\"),\n         ty::ty_char              => output.push_str(\"char\"),\n         ty::ty_str               => output.push_str(\"str\"),\n-        ty::ty_int(ast::TyIs(_))     => output.push_str(\"isize\"),\n+        ty::ty_int(ast::TyIs)     => output.push_str(\"isize\"),\n         ty::ty_int(ast::TyI8)    => output.push_str(\"i8\"),\n         ty::ty_int(ast::TyI16)   => output.push_str(\"i16\"),\n         ty::ty_int(ast::TyI32)   => output.push_str(\"i32\"),\n         ty::ty_int(ast::TyI64)   => output.push_str(\"i64\"),\n-        ty::ty_uint(ast::TyUs(_))    => output.push_str(\"usize\"),\n+        ty::ty_uint(ast::TyUs)    => output.push_str(\"usize\"),\n         ty::ty_uint(ast::TyU8)   => output.push_str(\"u8\"),\n         ty::ty_uint(ast::TyU16)  => output.push_str(\"u16\"),\n         ty::ty_uint(ast::TyU32)  => output.push_str(\"u32\"),"}, {"sha": "b064f16ebd409e70c59a3fc04843dc21aafdfb01", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -521,7 +521,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     fn unsize_unique_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      expr: &ast::Expr,\n                                      datum: Datum<'tcx, Expr>,\n-                                     len: uint)\n+                                     len: usize)\n                                      -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n         let tcx = bcx.tcx();\n@@ -744,7 +744,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                               base: &ast::Expr,\n                               get_idx: F)\n                               -> DatumBlock<'blk, 'tcx, Expr> where\n-    F: FnOnce(&'blk ty::ctxt<'tcx>, &[ty::field<'tcx>]) -> uint,\n+    F: FnOnce(&'blk ty::ctxt<'tcx>, &[ty::field<'tcx>]) -> usize,\n {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rec_field\");\n@@ -785,7 +785,7 @@ fn trans_rec_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Translates `base.<idx>`.\n fn trans_rec_tup_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    base: &ast::Expr,\n-                                   idx: uint)\n+                                   idx: usize)\n                                    -> DatumBlock<'blk, 'tcx, Expr> {\n     trans_field(bcx, base, |_, _| idx)\n }\n@@ -1149,7 +1149,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::ExprTup(ref args) => {\n-            let numbered_fields: Vec<(uint, &ast::Expr)> =\n+            let numbered_fields: Vec<(usize, &ast::Expr)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, &**arg)).collect();\n             trans_adt(bcx,\n                       expr_ty(bcx, expr),\n@@ -1485,7 +1485,7 @@ pub struct StructBaseInfo<'a, 'tcx> {\n     /// The base expression; will be evaluated after all explicit fields.\n     expr: &'a ast::Expr,\n     /// The indices of fields to copy paired with their types.\n-    fields: Vec<(uint, Ty<'tcx>)>\n+    fields: Vec<(usize, Ty<'tcx>)>\n }\n \n /// Constructs an ADT instance:\n@@ -1499,7 +1499,7 @@ pub struct StructBaseInfo<'a, 'tcx> {\n pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                  ty: Ty<'tcx>,\n                                  discr: ty::Disr,\n-                                 fields: &[(uint, &ast::Expr)],\n+                                 fields: &[(usize, &ast::Expr)],\n                                  optbase: Option<StructBaseInfo<'a, 'tcx>>,\n                                  dest: Dest,\n                                  debug_location: DebugLoc)\n@@ -2228,7 +2228,7 @@ fn auto_ref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn deref_multiple<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               expr: &ast::Expr,\n                               datum: Datum<'tcx, Expr>,\n-                              times: uint)\n+                              times: usize)\n                               -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n     let mut datum = datum;\n@@ -2426,12 +2426,12 @@ impl OverflowOpViaIntrinsic {\n         use middle::ty::{ty_int, ty_uint};\n \n         let new_sty = match ty.sty {\n-            ty_int(TyIs(_)) => match &tcx.sess.target.target.target_pointer_width[..] {\n+            ty_int(TyIs) => match &tcx.sess.target.target.target_pointer_width[..] {\n                 \"32\" => ty_int(TyI32),\n                 \"64\" => ty_int(TyI64),\n                 _ => panic!(\"unsupported target word size\")\n             },\n-            ty_uint(TyUs(_)) => match &tcx.sess.target.target.target_pointer_width[..] {\n+            ty_uint(TyUs) => match &tcx.sess.target.target.target_pointer_width[..] {\n                 \"32\" => ty_uint(TyU32),\n                 \"64\" => ty_uint(TyU64),\n                 _ => panic!(\"unsupported target word size\")"}, {"sha": "32b4d14177c2a050fbd512c4df1b0efe32b09448", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -21,6 +21,7 @@ use middle::lang_items::ExchangeFreeFnLangItem;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n use trans::adt;\n+use trans::adt::GetDtorType; // for tcx.dtor_type()\n use trans::base::*;\n use trans::build::*;\n use trans::callee;\n@@ -231,9 +232,31 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         Load(bcx, llval)\n     };\n     let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, struct_data));\n-    with_cond(bcx, load_ty(bcx, drop_flag.val, bcx.tcx().types.bool), |cx| {\n+    let loaded = load_ty(bcx, drop_flag.val, bcx.tcx().dtor_type());\n+    let drop_flag_llty = type_of(bcx.fcx.ccx, bcx.tcx().dtor_type());\n+    let init_val = C_integral(drop_flag_llty, adt::DTOR_NEEDED as u64, false);\n+\n+    let bcx = if !bcx.ccx().check_drop_flag_for_sanity() {\n+        bcx\n+    } else {\n+        let drop_flag_llty = type_of(bcx.fcx.ccx, bcx.tcx().dtor_type());\n+        let done_val = C_integral(drop_flag_llty, adt::DTOR_DONE as u64, false);\n+        let not_init = ICmp(bcx, llvm::IntNE, loaded, init_val, DebugLoc::None);\n+        let not_done = ICmp(bcx, llvm::IntNE, loaded, done_val, DebugLoc::None);\n+        let drop_flag_neither_initialized_nor_cleared =\n+            And(bcx, not_init, not_done, DebugLoc::None);\n+        with_cond(bcx, drop_flag_neither_initialized_nor_cleared, |cx| {\n+            let llfn = cx.ccx().get_intrinsic(&(\"llvm.debugtrap\"));\n+            Call(cx, llfn, &[], None, DebugLoc::None);\n+            cx\n+        })\n+    };\n+\n+    let drop_flag_dtor_needed = ICmp(bcx, llvm::IntEQ, loaded, init_val, DebugLoc::None);\n+    with_cond(bcx, drop_flag_dtor_needed, |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n+\n }\n \n fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -395,13 +418,24 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n+\n+    // Only drop the value when it ... well, we used to check for\n+    // non-null, (and maybe we need to continue doing so), but we now\n+    // must definitely check for special bit-patterns corresponding to\n+    // the special dtor markings.\n+\n+    let inttype = Type::int(bcx.ccx());\n+    let dropped_pattern = C_integral(inttype, adt::dtor_done_usize(bcx.fcx.ccx) as u64, false);\n+\n     match t.sty {\n         ty::ty_uniq(content_ty) => {\n             if !type_is_sized(bcx.tcx(), content_ty) {\n                 let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n                 let llbox = Load(bcx, llval);\n-                let not_null = IsNotNull(bcx, llbox);\n-                with_cond(bcx, not_null, |bcx| {\n+                let llbox_as_usize = PtrToInt(bcx, llbox, Type::int(bcx.ccx()));\n+                let drop_flag_not_dropped_already =\n+                    ICmp(bcx, llvm::IntNE, llbox_as_usize, dropped_pattern, DebugLoc::None);\n+                with_cond(bcx, drop_flag_not_dropped_already, |bcx| {\n                     let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n                     let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n                     let info = Load(bcx, info);\n@@ -420,8 +454,10 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n             } else {\n                 let llval = v0;\n                 let llbox = Load(bcx, llval);\n-                let not_null = IsNotNull(bcx, llbox);\n-                with_cond(bcx, not_null, |bcx| {\n+                let llbox_as_usize = PtrToInt(bcx, llbox, inttype);\n+                let drop_flag_not_dropped_already =\n+                    ICmp(bcx, llvm::IntNE, llbox_as_usize, dropped_pattern, DebugLoc::None);\n+                with_cond(bcx, drop_flag_not_dropped_already, |bcx| {\n                     let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n                     trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n                 })"}, {"sha": "cfd5b6c13d882969131715b721ba3b6b3b102660", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -121,21 +121,21 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                     &format!(\"transmute called on types with potentially different sizes: \\\n                               {} (could be {} bit{}) to {} (could be {} bit{})\",\n                              ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n-                             from_type_size as uint,\n+                             from_type_size as usize,\n                              if from_type_size == 1 {\"\"} else {\"s\"},\n                              ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n-                             to_type_size as uint,\n+                             to_type_size as usize,\n                              if to_type_size == 1 {\"\"} else {\"s\"}));\n             } else {\n                 ccx.sess().span_err(\n                     transmute_restriction.span,\n                     &format!(\"transmute called on types with different sizes: \\\n                               {} ({} bit{}) to {} ({} bit{})\",\n                              ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n-                             from_type_size as uint,\n+                             from_type_size as usize,\n                              if from_type_size == 1 {\"\"} else {\"s\"},\n                              ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n-                             to_type_size as uint,\n+                             to_type_size as usize,\n                              if to_type_size == 1 {\"\"} else {\"s\"}));\n             }\n         }\n@@ -359,11 +359,18 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 &ccx.link_meta().crate_hash);\n             C_u64(ccx, hash)\n         }\n+        (_, \"init_dropped\") => {\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            if !return_type_is_void(ccx, tp_ty) {\n+                drop_done_fill_mem(bcx, llresult, tp_ty);\n+            }\n+            C_nil(ccx)\n+        }\n         (_, \"init\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             if !return_type_is_void(ccx, tp_ty) {\n                 // Just zero out the stack slot. (See comment on base::memzero for explanation)\n-                zero_mem(bcx, llresult, tp_ty);\n+                init_zero_mem(bcx, llresult, tp_ty);\n             }\n             C_nil(ccx)\n         }"}, {"sha": "ce37d38dc894fb3ff2efcedfca6c705bf8d0266c", "filename": "src/librustc_trans/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -99,7 +99,7 @@ pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> llalign {\n     }\n }\n \n-pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: uint) -> u64 {\n+pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: usize) -> u64 {\n     unsafe {\n         return llvm::LLVMOffsetOfElement(cx.td().lltd, struct_ty.to_ref(),\n                                          element as u32);"}, {"sha": "190e44c9674cb5a13d10826aa60156fb15b40adc", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -13,7 +13,7 @@ use back::abi;\n use back::link;\n use llvm::{ValueRef, get_param};\n use metadata::csearch;\n-use middle::subst::Substs;\n+use middle::subst::{Subst, Substs};\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n@@ -47,7 +47,7 @@ use syntax::codemap::DUMMY_SP;\n use syntax::ptr::P;\n \n // drop_glue pointer, size, align.\n-const VTABLE_OFFSET: uint = 3;\n+const VTABLE_OFFSET: usize = 3;\n \n /// The main \"translation\" pass for methods.  Generates code\n /// for non-monomorphized methods only.  Other methods will\n@@ -325,7 +325,7 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           method_call: MethodCall,\n                                           trait_id: ast::DefId,\n-                                          n_method: uint,\n+                                          n_method: usize,\n                                           vtable: traits::Vtable<'tcx, ()>)\n                                           -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n@@ -437,7 +437,7 @@ fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// extract the self data and vtable out of the pair.\n fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   method_ty: Ty<'tcx>,\n-                                  vtable_index: uint,\n+                                  vtable_index: usize,\n                                   self_expr: &ast::Expr,\n                                   arg_cleanup_scope: cleanup::ScopeId)\n                                   -> Callee<'blk, 'tcx> {\n@@ -474,7 +474,7 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// pair.\n pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                  callee_ty: Ty<'tcx>,\n-                                                 vtable_index: uint,\n+                                                 vtable_index: usize,\n                                                  llpair: ValueRef)\n                                                  -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_trait_callee\");\n@@ -547,7 +547,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     object_ty: Ty<'tcx>,\n     upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-    method_offset_in_trait: uint)\n+    method_offset_in_trait: usize)\n     -> (ValueRef, Ty<'tcx>)\n {\n     let _icx = push_ctxt(\"trans_object_shim\");\n@@ -784,6 +784,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     ty::populate_implementations_for_trait_if_necessary(tcx, trt_id);\n \n+    let nullptr = C_null(Type::nil(ccx).ptr_to());\n     let trait_item_def_ids = ty::trait_item_def_ids(tcx, trt_id);\n     trait_item_def_ids\n         .iter()\n@@ -809,6 +810,12 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             };\n             let name = trait_method_type.name;\n \n+            // Some methods cannot be called on an object; skip those.\n+            if !traits::is_vtable_safe_method(tcx, trt_id, &trait_method_type) {\n+                debug!(\"emit_vtable_methods: not vtable safe\");\n+                return nullptr;\n+            }\n+\n             debug!(\"emit_vtable_methods: trait_method_type={}\",\n                    trait_method_type.repr(tcx));\n \n@@ -820,35 +827,17 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 ty::TypeTraitItem(_) => ccx.sess().bug(\"should be a method, not assoc type\")\n             };\n \n-            debug!(\"emit_vtable_methods: m={}\",\n+            debug!(\"emit_vtable_methods: impl_method_type={}\",\n                    impl_method_type.repr(tcx));\n \n-            let nullptr = C_null(Type::nil(ccx).ptr_to());\n-\n-            if impl_method_type.generics.has_type_params(subst::FnSpace) {\n-                debug!(\"emit_vtable_methods: generic\");\n-                return nullptr;\n-            }\n-\n-            let bare_fn_ty =\n-                ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(impl_method_type.fty.clone()));\n-            if ty::type_has_self(bare_fn_ty) {\n-                debug!(\"emit_vtable_methods: type_has_self {}\",\n-                       bare_fn_ty.repr(tcx));\n-                return nullptr;\n-            }\n-\n             // If this is a default method, it's possible that it\n             // relies on where clauses that do not hold for this\n             // particular set of type parameters. Note that this\n             // method could then never be called, so we do not want to\n             // try and trans it, in that case. Issue #23435.\n             if ty::provided_source(tcx, impl_method_def_id).is_some() {\n-                let predicates =\n-                    monomorphize::apply_param_substs(tcx,\n-                                                     &substs,\n-                                                     &impl_method_type.predicates.predicates);\n-                if !predicates_hold(ccx, predicates.into_vec()) {\n+                let predicates = impl_method_type.predicates.predicates.subst(tcx, &substs);\n+                if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                     debug!(\"emit_vtable_methods: predicates do not hold\");\n                     return nullptr;\n                 }"}, {"sha": "8f1ef84386f4faf9018f67c41f2a56a607a35b2c", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -265,7 +265,7 @@ fn vec_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, unit_ty: Ty<'tcx>)\n     }\n }\n \n-fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n+fn elements_required(bcx: Block, content_expr: &ast::Expr) -> usize {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n@@ -291,7 +291,7 @@ fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n /// which should be by ref.\n pub fn get_fixed_base_and_len(bcx: Block,\n                               llval: ValueRef,\n-                              vec_length: uint)\n+                              vec_length: usize)\n                               -> (ValueRef, ValueRef) {\n     let ccx = bcx.ccx();\n "}, {"sha": "339b4734ee4b1b82da3ed88cf46794314666ade2", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -118,7 +118,7 @@ impl Type {\n \n     pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            ast::TyIs(_) => ccx.int_type(),\n+            ast::TyIs => ccx.int_type(),\n             ast::TyI8 => Type::i8(ccx),\n             ast::TyI16 => Type::i16(ccx),\n             ast::TyI32 => Type::i32(ccx),\n@@ -128,7 +128,7 @@ impl Type {\n \n     pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            ast::TyUs(_) => ccx.int_type(),\n+            ast::TyUs => ccx.int_type(),\n             ast::TyU8 => Type::i8(ccx),\n             ast::TyU16 => Type::i16(ccx),\n             ast::TyU32 => Type::i32(ccx),\n@@ -239,21 +239,21 @@ impl Type {\n     }\n \n     /// Return the number of elements in `self` if it is a LLVM vector type.\n-    pub fn vector_length(&self) -> uint {\n+    pub fn vector_length(&self) -> usize {\n         unsafe {\n-            llvm::LLVMGetVectorSize(self.to_ref()) as uint\n+            llvm::LLVMGetVectorSize(self.to_ref()) as usize\n         }\n     }\n \n-    pub fn array_length(&self) -> uint {\n+    pub fn array_length(&self) -> usize {\n         unsafe {\n-            llvm::LLVMGetArrayLength(self.to_ref()) as uint\n+            llvm::LLVMGetArrayLength(self.to_ref()) as usize\n         }\n     }\n \n     pub fn field_types(&self) -> Vec<Type> {\n         unsafe {\n-            let n_elts = llvm::LLVMCountStructElementTypes(self.to_ref()) as uint;\n+            let n_elts = llvm::LLVMCountStructElementTypes(self.to_ref()) as usize;\n             if n_elts == 0 {\n                 return Vec::new();\n             }\n@@ -270,15 +270,15 @@ impl Type {\n \n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n-            let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n+            let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as usize;\n             let mut args: Vec<_> = repeat(Type { rf: ptr::null_mut() }).take(n_args).collect();\n             llvm::LLVMGetParamTypes(self.to_ref(),\n                                     args.as_mut_ptr() as *mut TypeRef);\n             args\n         }\n     }\n \n-    pub fn float_width(&self) -> uint {\n+    pub fn float_width(&self) -> usize {\n         match self.kind() {\n             Float => 32,\n             Double => 64,"}, {"sha": "99dc9ceacec881cf44d0a15130d73466bd3f7c4c", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -361,7 +361,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                   let unsized_part = unsized_part_of_type(cx.tcx(), ty);\n                   let info_ty = match unsized_part.sty {\n                       ty::ty_str | ty::ty_vec(..) => {\n-                          Type::uint_from_ty(cx, ast::TyUs(false))\n+                          Type::uint_from_ty(cx, ast::TyUs)\n                       }\n                       ty::ty_trait(_) => Type::vtable_ptr(cx),\n                       _ => panic!(\"Unexpected type returned from \\"}, {"sha": "c2d91e4e160248925d084b34c5e259515b0645f9", "filename": "src/librustc_trans/trans/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -107,7 +107,7 @@ impl Value {\n \n     /// Returns the requested operand of this instruction\n     /// Returns None, if there's no operand at the given index\n-    pub fn get_operand(self, i: uint) -> Option<Value> {\n+    pub fn get_operand(self, i: usize) -> Option<Value> {\n         opt_val!(llvm::LLVMGetOperand(self.get(), i as c_uint))\n     }\n "}, {"sha": "0d6ca7430d38ed0792bba57990444c3697090ea4", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -504,9 +504,9 @@ fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n /// (if one exists) and a vector of the (pattern, number of lifetimes)\n /// corresponding to each input type/pattern.\n fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n-                              -> (Option<ty::Region>, Vec<(String, uint)>)\n+                              -> (Option<ty::Region>, Vec<(String, usize)>)\n {\n-    let mut lifetimes_for_params: Vec<(String, uint)> = Vec::new();\n+    let mut lifetimes_for_params: Vec<(String, usize)> = Vec::new();\n     let mut possible_implied_output_region = None;\n \n     for (input_type, input_pat) in input_tys.iter().zip(input_pats.into_iter()) {\n@@ -534,7 +534,7 @@ fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n \n fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n                                           implied_output_region: Option<ty::Region>,\n-                                          param_lifetimes: Vec<(String, uint)>,\n+                                          param_lifetimes: Vec<(String, usize)>,\n                                           ty: &ast::Ty)\n                                           -> Ty<'tcx>\n {\n@@ -1401,15 +1401,15 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             ty\n         }\n         ast::TyFixedLengthVec(ref ty, ref e) => {\n-            match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.uint)) {\n+            match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.usize)) {\n                 Ok(r) => {\n                     match r {\n                         const_eval::const_int(i) =>\n                             ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n-                                        Some(i as uint)),\n+                                        Some(i as usize)),\n                         const_eval::const_uint(i) =>\n                             ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n-                                        Some(i as uint)),\n+                                        Some(i as usize)),\n                         _ => {\n                             span_err!(tcx.sess, ast_ty.span, E0249,\n                                       \"expected constant expr for array length\");\n@@ -1666,7 +1666,7 @@ fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n         }\n     };\n \n-    fn count_modifiers(ty: Ty) -> uint {\n+    fn count_modifiers(ty: Ty) -> usize {\n         match ty.sty {\n             ty::ty_rptr(_, mt) => count_modifiers(mt.ty) + 1,\n             ty::ty_uniq(t) => count_modifiers(t) + 1,"}, {"sha": "49f4399b2c7b43b32638072928b096ef9be7a3b4", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -339,8 +339,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n     ty_root: ty::Ty<'tcx>,\n     span: Span,\n     scope: region::CodeExtent,\n-    depth: uint,\n-    xref_depth: uint) -> Result<(), Error<'tcx>>\n+    depth: usize,\n+    xref_depth: usize) -> Result<(), Error<'tcx>>\n {\n     // Issue #22443: Watch out for overflow. While we are careful to\n     // handle regular types properly, non-regular ones cause problems."}, {"sha": "930ba4ae03ef3ac6b512ce17af9134943f6a3292", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -58,7 +58,7 @@ pub enum CandidateSource {\n     TraitSource(/* trait id */ ast::DefId),\n }\n \n-type MethodIndex = uint; // just for doc purposes\n+type MethodIndex = usize; // just for doc purposes\n \n /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -334,7 +334,7 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       trait_def_id: ast::DefId,\n                       method_name: ast::Name)\n-                      -> Option<(uint, Rc<ty::Method<'tcx>>)>\n+                      -> Option<(usize, Rc<ty::Method<'tcx>>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     trait_items"}, {"sha": "d1ebfe7d26edd27f5c787abb28e028446d5f1722", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -60,7 +60,7 @@ struct Candidate<'tcx> {\n \n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n-    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ uint, /* vtable index */ uint),\n+    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ usize, /* vtable index */ usize),\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n                            subst::Substs<'tcx>, MethodIndex),\n     ClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n@@ -77,7 +77,7 @@ pub struct Pick<'tcx> {\n #[derive(Clone,Debug)]\n pub enum PickKind<'tcx> {\n     InherentImplPick(/* Impl */ ast::DefId),\n-    ObjectPick(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n+    ObjectPick(/* Trait */ ast::DefId, /* method_num */ usize, /* real_index */ usize),\n     ExtensionImplPick(/* Impl */ ast::DefId, MethodIndex),\n     TraitPick(/* Trait */ ast::DefId, MethodIndex),\n     WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, MethodIndex),\n@@ -94,14 +94,14 @@ pub enum PickAdjustment {\n     // Indicates that the source expression should be autoderef'd N times\n     //\n     // A = expr | *expr | **expr\n-    AutoDeref(uint),\n+    AutoDeref(usize),\n \n     // Indicates that the source expression should be autoderef'd N\n     // times and then \"unsized\". This should probably eventually go\n     // away in favor of just coercing method receivers.\n     //\n     // A = unsize(expr | *expr | **expr)\n-    AutoUnsizeLength(/* number of autoderefs */ uint, /* length*/ uint),\n+    AutoUnsizeLength(/* number of autoderefs */ usize, /* length*/ usize),\n \n     // Indicates that an autoref is applied after some number of other adjustments\n     //\n@@ -325,7 +325,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 let lang_def_id = self.tcx().lang_items.i64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_int(ast::TyIs(_)) => {\n+            ty::ty_int(ast::TyIs) => {\n                 let lang_def_id = self.tcx().lang_items.isize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n@@ -345,7 +345,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 let lang_def_id = self.tcx().lang_items.u64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::ty_uint(ast::TyUs(_)) => {\n+            ty::ty_uint(ast::TyUs) => {\n                 let lang_def_id = self.tcx().lang_items.usize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n@@ -526,7 +526,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             &mut ProbeContext<'b, 'tcx>,\n             ty::PolyTraitRef<'tcx>,\n             Rc<ty::Method<'tcx>>,\n-            uint,\n+            usize,\n         ),\n     {\n         debug!(\"elaborate_bounds(bounds={})\", bounds.repr(self.tcx()));\n@@ -625,7 +625,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      trait_def_id: ast::DefId,\n                                                      method: Rc<ty::Method<'tcx>>,\n-                                                     method_index: uint)\n+                                                     method_index: usize)\n     {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n                                                             trait_def_id);\n@@ -692,7 +692,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_closure_candidates(&mut self,\n                                    trait_def_id: ast::DefId,\n                                    method_ty: Rc<ty::Method<'tcx>>,\n-                                   method_index: uint)\n+                                   method_index: usize)\n                                    -> Result<(),MethodError>\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n@@ -754,7 +754,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_projection_candidates(&mut self,\n                                       trait_def_id: ast::DefId,\n                                       method: Rc<ty::Method<'tcx>>,\n-                                      method_index: uint)\n+                                      method_index: usize)\n     {\n         debug!(\"assemble_projection_candidates(\\\n                trait_def_id={}, \\\n@@ -815,7 +815,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: ast::DefId,\n                                         method_ty: Rc<ty::Method<'tcx>>,\n-                                        method_index: uint)\n+                                        method_index: usize)\n     {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n@@ -933,7 +933,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         return self.pick_method(step.self_ty).map(|r| self.adjust(r, adjustment.clone()));\n \n-        fn consider_reborrow<'tcx>(ty: Ty<'tcx>, d: uint) -> PickAdjustment {\n+        fn consider_reborrow<'tcx>(ty: Ty<'tcx>, d: usize) -> PickAdjustment {\n             // Insert a `&*` or `&mut *` if this is a reference type:\n             match ty.sty {\n                 ty::ty_rptr(_, ref mt) => AutoRef(mt.mutbl, box AutoDeref(d+1)),\n@@ -1100,7 +1100,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     /// ```\n     /// trait Foo { ... }\n     /// impl Foo for Vec<int> { ... }\n-    /// impl Foo for Vec<uint> { ... }\n+    /// impl Foo for Vec<usize> { ... }\n     /// ```\n     ///\n     /// Now imagine the receiver is `Vec<_>`. It doesn't really matter at this time which impl we\n@@ -1281,7 +1281,7 @@ fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       trait_def_id: ast::DefId,\n                       method_name: ast::Name)\n-                      -> Option<(uint, Rc<ty::Method<'tcx>>)>\n+                      -> Option<(usize, Rc<ty::Method<'tcx>>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     debug!(\"trait_method; items: {:?}\", trait_items);"}, {"sha": "def877d92b52380a57fa9d9ad27b504472b9b78e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -309,7 +309,7 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n     // checking this function. On exit, if we find that *more* errors\n     // have been reported, we will skip regionck and other work that\n     // expects the types within the function to be consistent.\n-    err_count_on_creation: uint,\n+    err_count_on_creation: usize,\n \n     ret_ty: ty::FnOutput<'tcx>,\n \n@@ -467,7 +467,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx ast::Ty) {\n         match t.node {\n             ast::TyFixedLengthVec(_, ref expr) => {\n-                check_const_in_type(self.ccx, &**expr, self.ccx.tcx.types.uint);\n+                check_const_in_type(self.ccx, &**expr, self.ccx.tcx.types.usize);\n             }\n             _ => {}\n         }\n@@ -611,7 +611,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n         match t.node {\n             ast::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&**ty);\n-                check_expr_with_hint(self.fcx, &**count_expr, self.fcx.tcx().types.uint);\n+                check_expr_with_hint(self.fcx, &**count_expr, self.fcx.tcx().types.usize);\n             }\n             _ => visit::walk_ty(self, t)\n         }\n@@ -1104,14 +1104,18 @@ fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n                 fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n                                         e.id,\n                                         span,\n-                                        format!(\"trivial numeric cast: `{}` as `{}`\",\n+                                        format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n+                                                 replaced by coercion, this might require type \\\n+                                                 ascription or a temporary variable\",\n                                                 fcx.infcx().ty_to_string(t_e),\n                                                 fcx.infcx().ty_to_string(t_1)));\n             } else {\n                 fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n                                         e.id,\n                                         span,\n-                                        format!(\"trivial cast: `{}` as `{}`\",\n+                                        format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n+                                                 replaced by coercion, this might require type \\\n+                                                 ascription or a temporary variable\",\n                                                 fcx.infcx().ty_to_string(t_e),\n                                                 fcx.infcx().ty_to_string(t_1)));\n             }\n@@ -1313,7 +1317,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self.tcx().sess\n     }\n \n-    pub fn err_count_since_creation(&self) -> uint {\n+    pub fn err_count_since_creation(&self) -> usize {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n@@ -1432,7 +1436,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn write_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n                                       span: Span,\n-                                      derefs: uint) {\n+                                      derefs: usize) {\n         if derefs == 0 { return; }\n         self.write_adjustment(\n             node_id,\n@@ -1909,7 +1913,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                span: Span,\n                                class_id: ast::DefId,\n                                items: &[ty::field_ty],\n-                               idx: uint,\n+                               idx: usize,\n                                substs: &subst::Substs<'tcx>)\n                                -> Option<Ty<'tcx>>\n     {\n@@ -1940,8 +1944,8 @@ impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n         Some(self.infcx().next_region_var(infer::MiscVariable(span)))\n     }\n \n-    fn anon_regions(&self, span: Span, count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+    fn anon_regions(&self, span: Span, count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>> {\n         Ok((0..count).map(|_| {\n             self.infcx().next_region_var(infer::MiscVariable(span))\n         }).collect())\n@@ -1977,8 +1981,8 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  unresolved_type_action: UnresolvedTypeAction,\n                                  mut lvalue_pref: LvaluePreference,\n                                  mut should_stop: F)\n-                                 -> (Ty<'tcx>, uint, Option<T>)\n-    where F: FnMut(Ty<'tcx>, uint) -> Option<T>,\n+                                 -> (Ty<'tcx>, usize, Option<T>)\n+    where F: FnMut(Ty<'tcx>, usize) -> Option<T>,\n {\n     debug!(\"autoderef(base_ty={}, opt_expr={}, lvalue_pref={:?})\",\n            base_ty.repr(fcx.tcx()),\n@@ -2181,10 +2185,10 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // First, try built-in indexing.\n     match (ty::index(adjusted_ty), &index_ty.sty) {\n-        (Some(ty), &ty::ty_uint(ast::TyUs(_))) | (Some(ty), &ty::ty_infer(ty::IntVar(_))) => {\n+        (Some(ty), &ty::ty_uint(ast::TyUs)) | (Some(ty), &ty::ty_infer(ty::IntVar(_))) => {\n             debug!(\"try_index_step: success, using built-in indexing\");\n             fcx.write_adjustment(base_expr.id, base_expr.span, ty::AdjustDerefRef(adjustment));\n-            return Some((tcx.types.uint, ty));\n+            return Some((tcx.types.usize, ty));\n         }\n         _ => {}\n     }\n@@ -2485,7 +2489,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n-fn err_args<'tcx>(tcx: &ty::ctxt<'tcx>, len: uint) -> Vec<Ty<'tcx>> {\n+fn err_args<'tcx>(tcx: &ty::ctxt<'tcx>, len: usize) -> Vec<Ty<'tcx>> {\n     (0..len).map(|_| tcx.types.err).collect()\n }\n \n@@ -2523,8 +2527,8 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 match ty.sty {\n                     ty::ty_int(_) | ty::ty_uint(_) => Some(ty),\n                     ty::ty_char => Some(tcx.types.u8),\n-                    ty::ty_ptr(..) => Some(tcx.types.uint),\n-                    ty::ty_bare_fn(..) => Some(tcx.types.uint),\n+                    ty::ty_ptr(..) => Some(tcx.types.usize),\n+                    ty::ty_bare_fn(..) => Some(tcx.types.usize),\n                     _ => None\n                 }\n             });\n@@ -2633,7 +2637,7 @@ pub enum AutorefArgs {\n /// passed as a single parameter. For example, if tupling is enabled, this\n /// function:\n ///\n-///     fn f(x: (int, int))\n+///     fn f(x: (isize, isize))\n ///\n /// Can be called as:\n ///\n@@ -2916,7 +2920,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             });\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op.node) {\n-            // Shift is a special case: rhs must be uint, no matter what lhs is\n+            // Shift is a special case: rhs must be usize, no matter what lhs is\n             check_expr(fcx, &**rhs);\n             let rhs_ty = fcx.expr_ty(&**rhs);\n             let rhs_ty = structurally_resolved_type(fcx, rhs.span, rhs_ty);\n@@ -3179,7 +3183,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                 expr: &'tcx ast::Expr,\n                                 lvalue_pref: LvaluePreference,\n                                 base: &'tcx ast::Expr,\n-                                idx: codemap::Spanned<uint>) {\n+                                idx: codemap::Spanned<usize>) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -3829,7 +3833,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprCast(ref e, ref t) => {\n         if let ast::TyFixedLengthVec(_, ref count_expr) = t.node {\n-            check_expr_with_hint(fcx, &**count_expr, tcx.types.uint);\n+            check_expr_with_hint(fcx, &**count_expr, tcx.types.usize);\n         }\n \n         // Find the type of `e`. Supply hints based on the type we are casting to,\n@@ -3886,7 +3890,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(ref element, ref count_expr) => {\n-        check_expr_has_type(fcx, &**count_expr, tcx.types.uint);\n+        check_expr_has_type(fcx, &**count_expr, tcx.types.usize);\n         let count = ty::eval_repeat_count(fcx.tcx(), &**count_expr);\n \n         let uty = match expected {\n@@ -4194,16 +4198,16 @@ impl<'tcx> Expectation<'tcx> {\n     /// is useful in determining the concrete type.\n     ///\n     /// The primary use case is where the expected type is a fat pointer,\n-    /// like `&[int]`. For example, consider the following statement:\n+    /// like `&[isize]`. For example, consider the following statement:\n     ///\n-    ///    let x: &[int] = &[1, 2, 3];\n+    ///    let x: &[isize] = &[1, 2, 3];\n     ///\n     /// In this case, the expected type for the `&[1, 2, 3]` expression is\n-    /// `&[int]`. If however we were to say that `[1, 2, 3]` has the\n-    /// expectation `ExpectHasType([int])`, that would be too strong --\n-    /// `[1, 2, 3]` does not have the type `[int]` but rather `[int; 3]`.\n+    /// `&[isize]`. If however we were to say that `[1, 2, 3]` has the\n+    /// expectation `ExpectHasType([isize])`, that would be too strong --\n+    /// `[1, 2, 3]` does not have the type `[isize]` but rather `[isize; 3]`.\n     /// It is only the `&[1, 2, 3]` expression as a whole that can be coerced\n-    /// to the type `&[int]`. Therefore, we propagate this more limited hint,\n+    /// to the type `&[isize]`. Therefore, we propagate this more limited hint,\n     /// which still is useful, because it informs integer literals and the like.\n     /// See the test case `test/run-pass/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n@@ -4590,14 +4594,12 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                      ty: attr::IntType,\n                      disr: ty::Disr) -> bool {\n         fn uint_in_range(ccx: &CrateCtxt, ty: ast::UintTy, disr: ty::Disr) -> bool {\n-            #![allow(trivial_numeric_casts)]\n-\n             match ty {\n                 ast::TyU8 => disr as u8 as Disr == disr,\n                 ast::TyU16 => disr as u16 as Disr == disr,\n                 ast::TyU32 => disr as u32 as Disr == disr,\n                 ast::TyU64 => disr as u64 as Disr == disr,\n-                ast::TyUs(_) => uint_in_range(ccx, ccx.tcx.sess.target.uint_type, disr)\n+                ast::TyUs => uint_in_range(ccx, ccx.tcx.sess.target.uint_type, disr)\n             }\n         }\n         fn int_in_range(ccx: &CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool {\n@@ -4606,7 +4608,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 ast::TyI16 => disr as i16 as Disr == disr,\n                 ast::TyI32 => disr as i32 as Disr == disr,\n                 ast::TyI64 => disr as i64 as Disr == disr,\n-                ast::TyIs(_) => int_in_range(ccx, ccx.tcx.sess.target.int_type, disr)\n+                ast::TyIs => int_in_range(ccx, ccx.tcx.sess.target.int_type, disr)\n             }\n         }\n         match ty {\n@@ -4620,7 +4622,6 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                           id: ast::NodeId,\n                           hint: attr::ReprAttr)\n                           -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n-        #![allow(trivial_numeric_casts)]\n         use std::num::Int;\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n@@ -4650,7 +4651,9 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                     let inh = static_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n                     let declty = match hint {\n-                        attr::ReprAny | attr::ReprPacked | attr::ReprExtern => fcx.tcx().types.int,\n+                        attr::ReprAny | attr::ReprPacked |\n+                        attr::ReprExtern => fcx.tcx().types.isize,\n+\n                         attr::ReprInt(_, attr::SignedInt(ity)) => {\n                             ty::mk_mach_int(fcx.tcx(), ity)\n                         }\n@@ -5319,7 +5322,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             match t.sty {\n                 ty::ty_param(ParamTy {idx, ..}) => {\n                     debug!(\"Found use of ty param num {}\", idx);\n-                    tps_used[idx as uint] = true;\n+                    tps_used[idx as usize] = true;\n                 }\n                 _ => ()\n             }\n@@ -5378,8 +5381,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         let (n_tps, inputs, output) = match &name[..] {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n-            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.uint),\n-            \"init\" => (1, Vec::new(), param(ccx, 0)),\n+            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.usize),\n+            \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n             \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n@@ -5407,7 +5410,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n-                  ccx.tcx.types.int\n+                  ccx.tcx.types.isize\n                ),\n                ty::mk_ptr(tcx, ty::mt {\n                    ty: param(ccx, 0),\n@@ -5426,7 +5429,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n-                  tcx.types.uint,\n+                  tcx.types.usize,\n                ),\n                ty::mk_nil(tcx))\n             }\n@@ -5438,7 +5441,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                       mutbl: ast::MutMutable\n                   }),\n                   tcx.types.u8,\n-                  tcx.types.uint,\n+                  tcx.types.usize,\n                ),\n                ty::mk_nil(tcx))\n             }"}, {"sha": "3edea6d3004449b3e8d586902180feb24886e07c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -319,7 +319,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// This method populates the region map's `free_region_map`. It walks over the transformed\n     /// argument and return types for each function just before we check the body of that function,\n     /// looking for types where you have a borrowed pointer to other borrowed data (e.g., `&'a &'b\n-    /// [uint]`.  We do not allow references to outlive the things they point at, so we can assume\n+    /// [usize]`.  We do not allow references to outlive the things they point at, so we can assume\n     /// that `'a <= 'b`. This holds for both the argument and return types, basically because, on\n     /// the caller side, the caller is responsible for checking that the type of every expression\n     /// (including the actual values for the arguments, as well as the return type of the fn call)\n@@ -862,7 +862,7 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n /// dereferenced, the lifetime of the pointer includes the deref expr.\n fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                   deref_expr: &ast::Expr,\n-                                  derefs: uint,\n+                                  derefs: usize,\n                                   mut derefd_ty: Ty<'tcx>)\n {\n     debug!(\"constrain_autoderefs(deref_expr={}, derefs={}, derefd_ty={})\",\n@@ -1118,7 +1118,7 @@ fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n /// autoref'd.\n fn link_autoref(rcx: &Rcx,\n                 expr: &ast::Expr,\n-                autoderefs: uint,\n+                autoderefs: usize,\n                 autoref: &ty::AutoRef) {\n \n     debug!(\"link_autoref(autoref={:?})\", autoref);"}, {"sha": "67461ff561bb8beb529a74f4ba1a6a876c091113", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -28,18 +28,17 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  object_trait: &ty::TyTrait<'tcx>,\n                                  span: Span)\n {\n-    let object_trait_ref =\n-        object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n+    let trait_def_id = object_trait.principal_def_id();\n \n-    if traits::is_object_safe(tcx, object_trait_ref.clone()) {\n+    if traits::is_object_safe(tcx, trait_def_id) {\n         return;\n     }\n \n     span_err!(tcx.sess, span, E0038,\n               \"cannot convert to a trait object because trait `{}` is not object-safe\",\n-              ty::item_path_str(tcx, object_trait_ref.def_id()));\n+              ty::item_path_str(tcx, trait_def_id));\n \n-    let violations = traits::object_safety_violations(tcx, object_trait_ref.clone());\n+    let violations = traits::object_safety_violations(tcx, trait_def_id);\n     for violation in violations {\n         match violation {\n             ObjectSafetyViolation::SizedSelf => {"}, {"sha": "d26d26557ab79cb355c3eb8df4346bdb7f17c5a2", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -528,7 +528,7 @@ pub struct BoundsChecker<'cx,'tcx:'cx> {\n     // has left it as a NodeId rather than porting to CodeExtent.\n     scope: ast::NodeId,\n \n-    binding_count: uint,\n+    binding_count: usize,\n     cache: Option<&'cx mut HashSet<Ty<'tcx>>>,\n }\n "}, {"sha": "e555d3085a4c7348fa4d3b2c176e8641e06c0a57", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -169,7 +169,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n         match t.node {\n             ast::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&**ty);\n-                write_ty_to_tcx(self.tcx(), count_expr.id, self.tcx().types.uint);\n+                write_ty_to_tcx(self.tcx(), count_expr.id, self.tcx().types.usize);\n             }\n             _ => visit::walk_ty(self, t)\n         }"}, {"sha": "7b76f3681c16330bcef1e1bae46ab7679427cb6c", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -143,7 +143,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                                   \"i64\",\n                                                   item.span);\n                     }\n-                    ty::ty_int(ast::TyIs(_)) => {\n+                    ty::ty_int(ast::TyIs) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.isize_impl(),\n                                                   \"isize\",\n@@ -178,7 +178,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                                   \"u64\",\n                                                   item.span);\n                     }\n-                    ty::ty_uint(ast::TyUs(_)) => {\n+                    ty::ty_uint(ast::TyUs) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.usize_impl(),\n                                                   \"usize\","}, {"sha": "abb68d8fe0dc2a369b3f34363846f8ae90cd3cc4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -2208,18 +2208,10 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      idx: index as u32,\n                                      name: ty_param.ident.name };\n         if !input_parameters.contains(&param_ty) {\n-            if ty::has_attr(tcx, impl_def_id, \"old_impl_check\") {\n-                tcx.sess.span_warn(\n-                    ty_param.span,\n-                    &format!(\"the type parameter `{}` is not constrained by the \\\n-                              impl trait, self type, or predicates\",\n-                             param_ty.user_string(tcx)));\n-            } else {\n-                span_err!(tcx.sess, ty_param.span, E0207,\n-                    \"the type parameter `{}` is not constrained by the \\\n-                             impl trait, self type, or predicates\",\n-                            param_ty.user_string(tcx));\n-            }\n+            span_err!(tcx.sess, ty_param.span, E0207,\n+                \"the type parameter `{}` is not constrained by the \\\n+                         impl trait, self type, or predicates\",\n+                        param_ty.user_string(tcx));\n         }\n     }\n }"}, {"sha": "91410fa808c78a8436c7d639ba2a78a1eabac0fb", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -79,7 +79,6 @@ This API is completely unstable and subject to change.\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -281,10 +280,10 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: vec!(\n-                        tcx.types.int,\n+                        tcx.types.isize,\n                         ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, tcx.types.u8))\n                     ),\n-                    output: ty::FnConverging(tcx.types.int),\n+                    output: ty::FnConverging(tcx.types.isize),\n                     variadic: false,\n                 }),\n             }));"}, {"sha": "f1050a936e276f480f5ff0f822432dafe4ba90de", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -29,8 +29,8 @@ use syntax::codemap::Span;\n pub trait RegionScope {\n     fn anon_regions(&self,\n                     span: Span,\n-                    count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>;\n+                    count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>;\n \n     /// If an object omits any explicit lifetime bound, and none can\n     /// be derived from the object traits, what should we use? If\n@@ -50,17 +50,17 @@ impl RegionScope for ExplicitRscope {\n \n     fn anon_regions(&self,\n                     _span: Span,\n-                    _count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+                    _count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>> {\n         Err(None)\n     }\n }\n \n // Same as `ExplicitRscope`, but provides some extra information for diagnostics\n-pub struct UnelidableRscope(Vec<(String, uint)>);\n+pub struct UnelidableRscope(Vec<(String, usize)>);\n \n impl UnelidableRscope {\n-    pub fn new(v: Vec<(String, uint)>) -> UnelidableRscope {\n+    pub fn new(v: Vec<(String, usize)>) -> UnelidableRscope {\n         UnelidableRscope(v)\n     }\n }\n@@ -72,8 +72,8 @@ impl RegionScope for UnelidableRscope {\n \n     fn anon_regions(&self,\n                     _span: Span,\n-                    _count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+                    _count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>> {\n         let UnelidableRscope(ref v) = *self;\n         Err(Some(v.clone()))\n     }\n@@ -103,8 +103,8 @@ impl RegionScope for ElidableRscope {\n \n     fn anon_regions(&self,\n                     _span: Span,\n-                    count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n+                    count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n     {\n         Ok(repeat(self.default).take(count).collect())\n     }\n@@ -140,8 +140,8 @@ impl RegionScope for BindingRscope {\n \n     fn anon_regions(&self,\n                     _: Span,\n-                    count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n+                    count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n     {\n         Ok((0..count).map(|_| self.next_region()).collect())\n     }\n@@ -176,8 +176,8 @@ impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n \n     fn anon_regions(&self,\n                     span: Span,\n-                    count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n+                    count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n     {\n         self.base_scope.anon_regions(span, count)\n     }\n@@ -203,8 +203,8 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n \n     fn anon_regions(&self,\n                     span: Span,\n-                    count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n+                    count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n     {\n         match self.base_scope.anon_regions(span, count) {\n             Ok(mut v) => {"}, {"sha": "b014238b6f286d32fa50502c38188f21234a7d47", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -296,7 +296,7 @@ pub fn infer_variance(tcx: &ty::ctxt) {\n type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n #[derive(Copy, Debug)]\n-struct InferredIndex(uint);\n+struct InferredIndex(usize);\n \n #[derive(Copy)]\n enum VarianceTerm<'a> {\n@@ -346,7 +346,7 @@ struct InferredInfo<'a> {\n     item_id: ast::NodeId,\n     kind: ParamKind,\n     space: ParamSpace,\n-    index: uint,\n+    index: usize,\n     param_id: ast::NodeId,\n     term: VarianceTermPtr<'a>,\n \n@@ -457,7 +457,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                     item_id: ast::NodeId,\n                     kind: ParamKind,\n                     space: ParamSpace,\n-                    index: uint,\n+                    index: usize,\n                     param_id: ast::NodeId) {\n         let inf_index = InferredIndex(self.inferred_infos.len());\n         let term = self.arena.alloc(InferredTerm(inf_index));\n@@ -488,7 +488,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn pick_initial_variance(&self,\n                              item_id: ast::NodeId,\n                              space: ParamSpace,\n-                             index: uint)\n+                             index: usize)\n                              -> ty::Variance\n     {\n         match space {\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         }\n     }\n \n-    fn num_inferred(&self) -> uint {\n+    fn num_inferred(&self) -> usize {\n         self.inferred_infos.len()\n     }\n }\n@@ -791,7 +791,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                          item_def_id: ast::DefId,\n                          kind: ParamKind,\n                          space: ParamSpace,\n-                         index: uint)\n+                         index: usize)\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n \n@@ -977,7 +977,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ty_param(ref data) => {\n-                let def_id = generics.types.get(data.space, data.idx as uint).def_id;\n+                let def_id = generics.types.get(data.space, data.idx as usize).def_id;\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n                 match self.terms_cx.inferred_map.get(&def_id.node) {\n                     Some(&index) => {\n@@ -1027,9 +1027,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         for p in type_param_defs {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id, TypeParam,\n-                                       p.space, p.index as uint);\n+                                       p.space, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_ty = *substs.types.get(p.space, p.index as uint);\n+            let substs_ty = *substs.types.get(p.space, p.index as usize);\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl, variance_i);\n             self.add_constraints_from_ty(generics, substs_ty, variance_i);\n@@ -1038,9 +1038,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         for p in region_param_defs {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id,\n-                                       RegionParam, p.space, p.index as uint);\n+                                       RegionParam, p.space, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_r = *substs.regions().get(p.space, p.index as uint);\n+            let substs_r = *substs.regions().get(p.space, p.index as usize);\n             self.add_constraints_from_region(generics, substs_r, variance_i);\n         }\n     }\n@@ -1059,14 +1059,29 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n \n                 ty::Predicate::Equate(ty::Binder(ref data)) => {\n-                    self.add_constraints_from_ty(generics, data.0, variance);\n-                    self.add_constraints_from_ty(generics, data.1, variance);\n+                    // A == B is only true if A and B are the same\n+                    // types, not subtypes of one another, so this is\n+                    // an invariant position:\n+                    self.add_constraints_from_ty(generics, data.0, self.invariant);\n+                    self.add_constraints_from_ty(generics, data.1, self.invariant);\n                 }\n \n                 ty::Predicate::TypeOutlives(ty::Binder(ref data)) => {\n-                    self.add_constraints_from_ty(generics, data.0, variance);\n+                    // Why contravariant on both? Let's consider:\n+                    //\n+                    // Under what conditions is `(T:'t) <: (U:'u)`,\n+                    // meaning that `(T:'t) => (U:'u)`. The answer is\n+                    // if `U <: T` or `'u <= 't`. Let's see some examples:\n+                    //\n+                    //   (T: 'big) => (T: 'small)\n+                    //   where 'small <= 'big\n+                    //\n+                    //   (&'small Foo: 't) => (&'big Foo: 't)\n+                    //   where 'small <= 'big\n+                    //   note that &'big Foo <: &'small Foo\n \n                     let variance_r = self.xform(variance, self.contravariant);\n+                    self.add_constraints_from_ty(generics, data.0, variance_r);\n                     self.add_constraints_from_region(generics, data.1, variance_r);\n                 }\n \n@@ -1084,6 +1099,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                                         &*data.projection_ty.trait_ref,\n                                                         variance);\n \n+                    // as the equality predicate above, a binder is a\n+                    // type equality relation, not a subtyping\n+                    // relation\n                     self.add_constraints_from_ty(generics, data.ty, self.invariant);\n                 }\n             }"}, {"sha": "e4d9fac5b9cb53e5d90bb790ef877d10879efecc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -1322,7 +1322,7 @@ pub enum Type {\n     /// For parameterized types, so the consumer of the JSON don't go\n     /// looking for types which don't exist anywhere.\n     Generic(String),\n-    /// Primitives are the fixed-size numeric types (plus int/uint/float), char,\n+    /// Primitives are the fixed-size numeric types (plus int/usize/float), char,\n     /// arrays, slices, and tuples.\n     Primitive(PrimitiveType),\n     /// extern \"ABI\" fn\n@@ -1383,12 +1383,12 @@ pub enum TypeKind {\n impl PrimitiveType {\n     fn from_str(s: &str) -> Option<PrimitiveType> {\n         match s {\n-            \"isize\" | \"int\" => Some(Isize),\n+            \"isize\" => Some(Isize),\n             \"i8\" => Some(I8),\n             \"i16\" => Some(I16),\n             \"i32\" => Some(I32),\n             \"i64\" => Some(I64),\n-            \"usize\" | \"uint\" => Some(Usize),\n+            \"usize\" => Some(Usize),\n             \"u8\" => Some(U8),\n             \"u16\" => Some(U16),\n             \"u32\" => Some(U32),\n@@ -1516,12 +1516,12 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n         match self.sty {\n             ty::ty_bool => Primitive(Bool),\n             ty::ty_char => Primitive(Char),\n-            ty::ty_int(ast::TyIs(_)) => Primitive(Isize),\n+            ty::ty_int(ast::TyIs) => Primitive(Isize),\n             ty::ty_int(ast::TyI8) => Primitive(I8),\n             ty::ty_int(ast::TyI16) => Primitive(I16),\n             ty::ty_int(ast::TyI32) => Primitive(I32),\n             ty::ty_int(ast::TyI64) => Primitive(I64),\n-            ty::ty_uint(ast::TyUs(_)) => Primitive(Usize),\n+            ty::ty_uint(ast::TyUs) => Primitive(Usize),\n             ty::ty_uint(ast::TyU8) => Primitive(U8),\n             ty::ty_uint(ast::TyU16) => Primitive(U16),\n             ty::ty_uint(ast::TyU32) => Primitive(U32),\n@@ -1833,10 +1833,10 @@ impl Clean<VariantKind> for ast::VariantKind {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Span {\n     pub filename: String,\n-    pub loline: uint,\n-    pub locol: uint,\n-    pub hiline: uint,\n-    pub hicol: uint,\n+    pub loline: usize,\n+    pub locol: usize,\n+    pub hiline: usize,\n+    pub hicol: usize,\n }\n \n impl Span {\n@@ -2399,12 +2399,12 @@ fn resolve_type(cx: &DocContext,\n             ast::TyStr => return Primitive(Str),\n             ast::TyBool => return Primitive(Bool),\n             ast::TyChar => return Primitive(Char),\n-            ast::TyInt(ast::TyIs(_)) => return Primitive(Isize),\n+            ast::TyInt(ast::TyIs) => return Primitive(Isize),\n             ast::TyInt(ast::TyI8) => return Primitive(I8),\n             ast::TyInt(ast::TyI16) => return Primitive(I16),\n             ast::TyInt(ast::TyI32) => return Primitive(I32),\n             ast::TyInt(ast::TyI64) => return Primitive(I64),\n-            ast::TyUint(ast::TyUs(_)) => return Primitive(Usize),\n+            ast::TyUint(ast::TyUs) => return Primitive(Usize),\n             ast::TyUint(ast::TyU8) => return Primitive(U8),\n             ast::TyUint(ast::TyU16) => return Primitive(U16),\n             ast::TyUint(ast::TyU32) => return Primitive(U32),"}, {"sha": "afc434eb2dfdaf62dd6afc7281b669fd73d11972", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -185,7 +185,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n-thread_local!(static USED_HEADER_MAP: RefCell<HashMap<String, uint>> = {\n+thread_local!(static USED_HEADER_MAP: RefCell<HashMap<String, usize>> = {\n     RefCell::new(HashMap::new())\n });\n \n@@ -356,7 +356,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n             });\n             let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n             tests.add_test(text.to_string(),\n-                           block_info.should_fail, block_info.no_run,\n+                           block_info.should_panic, block_info.no_run,\n                            block_info.ignore, block_info.test_harness);\n         }\n     }\n@@ -397,7 +397,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n \n #[derive(Eq, PartialEq, Clone, Debug)]\n struct LangString {\n-    should_fail: bool,\n+    should_panic: bool,\n     no_run: bool,\n     ignore: bool,\n     rust: bool,\n@@ -407,7 +407,7 @@ struct LangString {\n impl LangString {\n     fn all_false() -> LangString {\n         LangString {\n-            should_fail: false,\n+            should_panic: false,\n             no_run: false,\n             ignore: false,\n             rust: true,  // NB This used to be `notrust = false`\n@@ -427,7 +427,7 @@ impl LangString {\n         for token in tokens {\n             match token {\n                 \"\" => {},\n-                \"should_fail\" => { data.should_fail = true; seen_rust_tags = true; },\n+                \"should_panic\" => { data.should_panic = true; seen_rust_tags = true; },\n                 \"no_run\" => { data.no_run = true; seen_rust_tags = true; },\n                 \"ignore\" => { data.ignore = true; seen_rust_tags = true; },\n                 \"rust\" => { data.rust = true; seen_rust_tags = true; },\n@@ -528,26 +528,26 @@ mod tests {\n     #[test]\n     fn test_lang_string_parse() {\n         fn t(s: &str,\n-            should_fail: bool, no_run: bool, ignore: bool, rust: bool, test_harness: bool) {\n+            should_panic: bool, no_run: bool, ignore: bool, rust: bool, test_harness: bool) {\n             assert_eq!(LangString::parse(s), LangString {\n-                should_fail: should_fail,\n+                should_panic: should_panic,\n                 no_run: no_run,\n                 ignore: ignore,\n                 rust: rust,\n                 test_harness: test_harness,\n             })\n         }\n \n-        // marker                | should_fail | no_run | ignore | rust | test_harness\n+        // marker                | should_panic| no_run | ignore | rust | test_harness\n         t(\"\",                      false,        false,   false,   true,  false);\n         t(\"rust\",                  false,        false,   false,   true,  false);\n         t(\"sh\",                    false,        false,   false,   false, false);\n         t(\"ignore\",                false,        false,   true,    true,  false);\n-        t(\"should_fail\",           true,         false,   false,   true,  false);\n+        t(\"should_panic\",          true,         false,   false,   true,  false);\n         t(\"no_run\",                false,        true,    false,   true,  false);\n         t(\"test_harness\",          false,        false,   false,   true,  true);\n         t(\"{.no_run .example}\",    false,        true,    false,   true,  false);\n-        t(\"{.sh .should_fail}\",    true,         false,   false,   true,  false);\n+        t(\"{.sh .should_panic}\",   true,         false,   false,   true,  false);\n         t(\"{.example .rust}\",      false,        false,   false,   true,  false);\n         t(\"{.test_harness .rust}\", false,        false,   false,   true,  true);\n     }"}, {"sha": "b4375d76d593dfe798a219315e2fa65d13773c76", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -498,7 +498,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n             try!(write!(&mut w, \",\"));\n         }\n         try!(write!(&mut w, r#\"[{},\"{}\",\"{}\",{}\"#,\n-                    item.ty as uint, item.name, path,\n+                    item.ty as usize, item.name, path,\n                     item.desc.to_json().to_string()));\n         match item.parent {\n             Some(nodeid) => {\n@@ -522,7 +522,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n             try!(write!(&mut w, \",\"));\n         }\n         try!(write!(&mut w, r#\"[{},\"{}\"]\"#,\n-                    short as uint, *fqp.last().unwrap()));\n+                    short as usize, *fqp.last().unwrap()));\n     }\n \n     try!(write!(&mut w, \"]}};\"));\n@@ -1567,7 +1567,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n     let mut indices = (0..items.len()).filter(|i| {\n         !cx.ignore_private_item(&items[*i])\n-    }).collect::<Vec<uint>>();\n+    }).collect::<Vec<usize>>();\n \n     // the order of item types in the listing\n     fn reorder(ty: ItemType) -> u8 {\n@@ -1588,7 +1588,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         }\n     }\n \n-    fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n+    fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: usize, idx2: usize) -> Ordering {\n         let ty1 = shortty(i1);\n         let ty2 = shortty(i2);\n         if ty1 == ty2 {"}, {"sha": "78feb6c77c45451f8f2df38420c850651825923c", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -33,7 +33,7 @@ pub struct Toc {\n }\n \n impl Toc {\n-    fn count_entries_with_level(&self, level: u32) -> uint {\n+    fn count_entries_with_level(&self, level: u32) -> usize {\n         self.entries.iter().filter(|e| e.level == level).count()\n     }\n }"}, {"sha": "431cb4a28989e1902866b7d5674b38c3dd17839b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -16,19 +16,17 @@\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n+   html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+   html_root_url = \"http://doc.rust-lang.org/nightly/\",\n+   html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n #![feature(exit_status)]\n-#![feature(int_uint)]\n #![feature(set_stdio)]\n #![feature(libc)]\n-#![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n@@ -39,6 +37,7 @@\n #![feature(path_ext)]\n #![feature(path_relative_from)]\n #![feature(convert)]\n+#![feature(slice_patterns)]\n \n extern crate arena;\n extern crate getopts;\n@@ -51,11 +50,11 @@ extern crate rustc_lint;\n extern crate rustc_back;\n extern crate serialize;\n extern crate syntax;\n-extern crate \"test\" as testing;\n+extern crate test as testing;\n extern crate unicode;\n #[macro_use] extern crate log;\n \n-extern crate \"serialize\" as rustc_serialize; // used by deriving\n+extern crate serialize as rustc_serialize; // used by deriving\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n@@ -66,8 +65,6 @@ use std::path::PathBuf;\n use std::rc::Rc;\n use std::sync::mpsc::channel;\n \n-#[allow(deprecated)] use std::old_path::Path;\n-\n use externalfiles::ExternalHtml;\n use serialize::Decodable;\n use serialize::json::{self, Json};\n@@ -195,7 +192,7 @@ pub fn usage(argv0: &str) {\n                             &opts()));\n }\n \n-pub fn main_args(args: &[String]) -> int {\n+pub fn main_args(args: &[String]) -> isize {\n     let matches = match getopts::getopts(args.tail(), &opts()) {\n         Ok(m) => m,\n         Err(err) => {\n@@ -435,7 +432,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     // Load all plugins/passes into a PluginManager\n     let path = matches.opt_str(\"plugin-path\")\n                       .unwrap_or(\"/tmp/rustdoc/plugins\".to_string());\n-    let mut pm = plugins::PluginManager::new(Path::new(path));\n+    let mut pm = plugins::PluginManager::new(PathBuf::from(path));\n     for pass in &passes {\n         let plugin = match PASSES.iter()\n                                  .position(|&(p, _, _)| {"}, {"sha": "a84da60b01831da1b6e7733ef105539a7d0dec0c", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -44,7 +44,7 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n /// (e.g. output = \"bar\" => \"bar/foo.html\").\n pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n-              external_html: &ExternalHtml, include_toc: bool) -> int {\n+              external_html: &ExternalHtml, include_toc: bool) -> isize {\n     let input_p = Path::new(input);\n     output.push(input_p.file_stem().unwrap());\n     output.set_extension(\"html\");\n@@ -140,7 +140,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n \n /// Run any tests/code examples in the markdown file `input`.\n pub fn test(input: &str, libs: SearchPaths, externs: core::Externs,\n-            mut test_args: Vec<String>) -> int {\n+            mut test_args: Vec<String>) -> isize {\n     let input_str = load_or_return!(input, 1, 2);\n \n     let mut collector = Collector::new(input.to_string(), libs, externs, true, false);"}, {"sha": "d4d214f449d5921733ca9c2c9c9140e23b02fd9b", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -16,7 +16,7 @@ use std::dynamic_lib as dl;\n use serialize::json;\n use std::mem;\n use std::string::String;\n-use std::old_path::{Path, GenericPath};\n+use std::path::PathBuf;\n \n pub type PluginJson = Option<(String, json::Json)>;\n pub type PluginResult = (clean::Crate, PluginJson);\n@@ -27,12 +27,12 @@ pub struct PluginManager {\n     dylibs: Vec<dl::DynamicLibrary> ,\n     callbacks: Vec<PluginCallback> ,\n     /// The directory plugins will be loaded from\n-    pub prefix: Path,\n+    pub prefix: PathBuf,\n }\n \n impl PluginManager {\n     /// Create a new plugin manager\n-    pub fn new(prefix: Path) -> PluginManager {\n+    pub fn new(prefix: PathBuf) -> PluginManager {\n         PluginManager {\n             dylibs: Vec::new(),\n             callbacks: Vec::new(),"}, {"sha": "702a32be58684af5a56c7529dc570934628c8c27", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -45,7 +45,7 @@ pub fn run(input: &str,\n            externs: core::Externs,\n            mut test_args: Vec<String>,\n            crate_name: Option<String>)\n-           -> int {\n+           -> isize {\n     let input_path = PathBuf::from(input);\n     let input = config::Input::File(input_path.clone());\n \n@@ -224,7 +224,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     // environment to ensure that the target loads the right libraries at\n     // runtime. It would be a sad day if the *host* libraries were loaded as a\n     // mistake.\n-    let mut cmd = Command::new(&outdir.path().join(\"rust-out\"));\n+    let mut cmd = Command::new(&outdir.path().join(\"rust_out\"));\n     let var = DynamicLibrary::envvar();\n     let newpath = {\n         let path = env::var_os(var).unwrap_or(OsString::new());\n@@ -321,7 +321,7 @@ pub struct Collector {\n     names: Vec<String>,\n     libs: SearchPaths,\n     externs: core::Externs,\n-    cnt: uint,\n+    cnt: usize,\n     use_headers: bool,\n     current_header: Option<String>,\n     cratename: String,"}, {"sha": "dc44536d60cea0403a619e3a27f814926111a6b3", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -44,8 +44,8 @@ impl ToHex for [u8] {\n     fn to_hex(&self) -> String {\n         let mut v = Vec::with_capacity(self.len() * 2);\n         for &byte in self {\n-            v.push(CHARS[(byte >> 4) as uint]);\n-            v.push(CHARS[(byte & 0xf) as uint]);\n+            v.push(CHARS[(byte >> 4) as usize]);\n+            v.push(CHARS[(byte & 0xf) as usize]);\n         }\n \n         unsafe {\n@@ -65,7 +65,7 @@ pub trait FromHex {\n #[derive(Copy, Debug)]\n pub enum FromHexError {\n     /// The input contained a character not part of the hex format\n-    InvalidHexCharacter(char, uint),\n+    InvalidHexCharacter(char, usize),\n     /// The input had an invalid length\n     InvalidHexLength,\n }\n@@ -188,18 +188,18 @@ mod tests {\n     #[test]\n     pub fn test_to_hex_all_bytes() {\n         for i in 0..256 {\n-            assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as uint));\n+            assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as usize));\n         }\n     }\n \n     #[test]\n     pub fn test_from_hex_all_bytes() {\n         for i in 0..256 {\n             let ii: &[u8] = &[i as u8];\n-            assert_eq!(format!(\"{:02x}\", i as uint).from_hex()\n+            assert_eq!(format!(\"{:02x}\", i as usize).from_hex()\n                                                    .unwrap(),\n                        ii);\n-            assert_eq!(format!(\"{:02X}\", i as uint).from_hex()\n+            assert_eq!(format!(\"{:02X}\", i as usize).from_hex()\n                                                    .unwrap(),\n                        ii);\n         }"}, {"sha": "e9060721318b1a9d3f2231696eef18b6bbafbad5", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 95, "deletions": 120, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -233,7 +233,7 @@ pub type Object = BTreeMap<string::String, Json>;\n pub struct PrettyJson<'a> { inner: &'a Json }\n \n pub struct AsJson<'a, T: 'a> { inner: &'a T }\n-pub struct AsPrettyJson<'a, T: 'a> { inner: &'a T, indent: Option<uint> }\n+pub struct AsPrettyJson<'a, T: 'a> { inner: &'a T, indent: Option<usize> }\n \n /// The errors that can arise while parsing a JSON stream.\n #[derive(Clone, Copy, PartialEq, Debug)]\n@@ -260,7 +260,7 @@ pub enum ErrorCode {\n #[derive(Clone, PartialEq, Debug)]\n pub enum ParserError {\n     /// msg, line, col\n-    SyntaxError(ErrorCode, uint, uint),\n+    SyntaxError(ErrorCode, usize, usize),\n     IoError(io::ErrorKind, String),\n }\n \n@@ -441,7 +441,7 @@ fn escape_char(writer: &mut fmt::Write, v: char) -> EncodeResult {\n     escape_str(writer, buf)\n }\n \n-fn spaces(wr: &mut fmt::Write, mut n: uint) -> EncodeResult {\n+fn spaces(wr: &mut fmt::Write, mut n: usize) -> EncodeResult {\n     const BUF: &'static str = \"                \";\n \n     while n >= BUF.len() {\n@@ -498,13 +498,13 @@ impl<'a> ::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_uint(&mut self, v: uint) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_uint(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n-    fn emit_int(&mut self, v: int) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_int(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n@@ -542,8 +542,8 @@ impl<'a> ::Encoder for Encoder<'a> {\n \n     fn emit_enum_variant<F>(&mut self,\n                             name: &str,\n-                            _id: uint,\n-                            cnt: uint,\n+                            _id: usize,\n+                            cnt: usize,\n                             f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n@@ -563,7 +563,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         }\n     }\n \n-    fn emit_enum_variant_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_enum_variant_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -575,8 +575,8 @@ impl<'a> ::Encoder for Encoder<'a> {\n \n     fn emit_enum_struct_variant<F>(&mut self,\n                                    name: &str,\n-                                   id: uint,\n-                                   cnt: uint,\n+                                   id: usize,\n+                                   cnt: usize,\n                                    f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n@@ -586,15 +586,15 @@ impl<'a> ::Encoder for Encoder<'a> {\n \n     fn emit_enum_struct_variant_field<F>(&mut self,\n                                          _: &str,\n-                                         idx: uint,\n+                                         idx: usize,\n                                          f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct<F>(&mut self, _: &str, _: uint, f: F) -> EncodeResult where\n+    fn emit_struct<F>(&mut self, _: &str, _: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -604,7 +604,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_struct_field<F>(&mut self, name: &str, idx: uint, f: F) -> EncodeResult where\n+    fn emit_struct_field<F>(&mut self, name: &str, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -614,26 +614,26 @@ impl<'a> ::Encoder for Encoder<'a> {\n         f(self)\n     }\n \n-    fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct<F>(&mut self, _name: &str, len: uint, f: F) -> EncodeResult where\n+    fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -657,7 +657,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         f(self)\n     }\n \n-    fn emit_seq<F>(&mut self, _len: uint, f: F) -> EncodeResult where\n+    fn emit_seq<F>(&mut self, _len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -667,7 +667,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -677,7 +677,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         f(self)\n     }\n \n-    fn emit_map<F>(&mut self, _len: uint, f: F) -> EncodeResult where\n+    fn emit_map<F>(&mut self, _len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -687,7 +687,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -698,7 +698,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -711,8 +711,8 @@ impl<'a> ::Encoder for Encoder<'a> {\n /// compact data\n pub struct PrettyEncoder<'a> {\n     writer: &'a mut (fmt::Write+'a),\n-    curr_indent: uint,\n-    indent: uint,\n+    curr_indent: usize,\n+    indent: usize,\n     is_emitting_map_key: bool,\n }\n \n@@ -729,7 +729,7 @@ impl<'a> PrettyEncoder<'a> {\n \n     /// Set the number of spaces to indent for each level.\n     /// This is safe to set during encoding.\n-    pub fn set_indent(&mut self, indent: uint) {\n+    pub fn set_indent(&mut self, indent: usize) {\n         // self.indent very well could be 0 so we need to use checked division.\n         let level = self.curr_indent.checked_div(self.indent).unwrap_or(0);\n         self.indent = indent;\n@@ -746,13 +746,13 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_uint(&mut self, v: uint) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_uint(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n-    fn emit_int(&mut self, v: int) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_int(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n@@ -790,8 +790,8 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n \n     fn emit_enum_variant<F>(&mut self,\n                             name: &str,\n-                            _id: uint,\n-                            cnt: uint,\n+                            _id: usize,\n+                            cnt: usize,\n                             f: F)\n                             -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n@@ -821,7 +821,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         }\n     }\n \n-    fn emit_enum_variant_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_enum_variant_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -834,8 +834,8 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n \n     fn emit_enum_struct_variant<F>(&mut self,\n                                    name: &str,\n-                                   id: uint,\n-                                   cnt: uint,\n+                                   id: usize,\n+                                   cnt: usize,\n                                    f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n@@ -845,7 +845,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n \n     fn emit_enum_struct_variant_field<F>(&mut self,\n                                          _: &str,\n-                                         idx: uint,\n+                                         idx: usize,\n                                          f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n@@ -854,7 +854,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     }\n \n \n-    fn emit_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+    fn emit_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -872,7 +872,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_struct_field<F>(&mut self, name: &str, idx: uint, f: F) -> EncodeResult where\n+    fn emit_struct_field<F>(&mut self, name: &str, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -887,26 +887,26 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         f(self)\n     }\n \n-    fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+    fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -930,7 +930,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         f(self)\n     }\n \n-    fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+    fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -948,7 +948,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -961,7 +961,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         f(self)\n     }\n \n-    fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+    fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -979,7 +979,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -995,7 +995,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -1218,16 +1218,6 @@ impl Json {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'a> Index<&'a str>  for Json {\n-    type Output = Json;\n-\n-    fn index(&self, idx: & &str) -> &Json {\n-        self.find(*idx).unwrap()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<'a> Index<&'a str>  for Json {\n     type Output = Json;\n \n@@ -1236,26 +1226,13 @@ impl<'a> Index<&'a str>  for Json {\n     }\n }\n \n-#[cfg(stage0)]\n-impl Index<uint> for Json {\n-    type Output = Json;\n-\n-    fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n-        match self {\n-            &Json::Array(ref v) => &v[*idx],\n-            _ => panic!(\"can only index Json with uint if it is an array\")\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n-impl Index<uint> for Json {\n+impl Index<usize> for Json {\n     type Output = Json;\n \n-    fn index<'a>(&'a self, idx: uint) -> &'a Json {\n+    fn index<'a>(&'a self, idx: usize) -> &'a Json {\n         match self {\n             &Json::Array(ref v) => &v[idx],\n-            _ => panic!(\"can only index Json with uint if it is an array\")\n+            _ => panic!(\"can only index Json with usize if it is an array\")\n         }\n     }\n }\n@@ -1326,20 +1303,20 @@ impl Stack {\n     }\n \n     /// Returns The number of elements in the Stack.\n-    pub fn len(&self) -> uint { self.stack.len() }\n+    pub fn len(&self) -> usize { self.stack.len() }\n \n     /// Returns true if the stack is empty.\n     pub fn is_empty(&self) -> bool { self.stack.is_empty() }\n \n     /// Provides access to the StackElement at a given index.\n     /// lower indices are at the bottom of the stack while higher indices are\n     /// at the top.\n-    pub fn get<'l>(&'l self, idx: uint) -> StackElement<'l> {\n+    pub fn get<'l>(&'l self, idx: usize) -> StackElement<'l> {\n         match self.stack[idx] {\n             InternalIndex(i) => StackElement::Index(i),\n             InternalKey(start, size) => {\n                 StackElement::Key(str::from_utf8(\n-                    &self.str_buffer[start as uint .. start as uint + size as uint])\n+                    &self.str_buffer[start as usize .. start as usize + size as usize])\n                         .unwrap())\n             }\n         }\n@@ -1382,7 +1359,7 @@ impl Stack {\n             Some(&InternalIndex(i)) => Some(StackElement::Index(i)),\n             Some(&InternalKey(start, size)) => {\n                 Some(StackElement::Key(str::from_utf8(\n-                    &self.str_buffer[start as uint .. (start+size) as uint]\n+                    &self.str_buffer[start as usize .. (start+size) as usize]\n                 ).unwrap()))\n             }\n         }\n@@ -1406,7 +1383,7 @@ impl Stack {\n         assert!(!self.is_empty());\n         match *self.stack.last().unwrap() {\n             InternalKey(_, sz) => {\n-                let new_size = self.str_buffer.len() - sz as uint;\n+                let new_size = self.str_buffer.len() - sz as usize;\n                 self.str_buffer.truncate(new_size);\n             }\n             InternalIndex(_) => {}\n@@ -1439,8 +1416,8 @@ impl Stack {\n pub struct Parser<T> {\n     rdr: T,\n     ch: Option<char>,\n-    line: uint,\n-    col: uint,\n+    line: usize,\n+    col: usize,\n     // We maintain a stack representing where we are in the logical structure\n     // of the JSON stream.\n     stack: Stack,\n@@ -1625,7 +1602,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n             match self.ch_or_null() {\n                 c @ '0' ... '9' => {\n                     dec /= 10.0;\n-                    res += (((c as int) - ('0' as int)) as f64) * dec;\n+                    res += (((c as isize) - ('0' as isize)) as f64) * dec;\n                     self.bump();\n                 }\n                 _ => break,\n@@ -1657,7 +1634,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n             match self.ch_or_null() {\n                 c @ '0' ... '9' => {\n                     exp *= 10;\n-                    exp += (c as uint) - ('0' as uint);\n+                    exp += (c as usize) - ('0' as usize);\n \n                     self.bump();\n                 }\n@@ -1769,7 +1746,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n     // information to return a JsonEvent.\n     // Manages an internal state so that parsing can be interrupted and resumed.\n     // Also keeps track of the position in the logical structure of the json\n-    // stream int the form of a stack that can be queried by the user using the\n+    // stream isize the form of a stack that can be queried by the user using the\n     // stack() method.\n     fn parse(&mut self) -> JsonEvent {\n         loop {\n@@ -2150,7 +2127,7 @@ macro_rules! read_primitive {\n                     None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n                 },\n                 Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{}\", f))),\n-                // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n+                // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n                 // is going to have a string here, as per JSON spec.\n                 Json::String(s) => match s.parse().ok() {\n                     Some(f) => Ok(f),\n@@ -2169,12 +2146,12 @@ impl ::Decoder for Decoder {\n         expect!(self.pop(), Null)\n     }\n \n-    read_primitive! { read_uint, uint }\n+    read_primitive! { read_uint, usize }\n     read_primitive! { read_u8, u8 }\n     read_primitive! { read_u16, u16 }\n     read_primitive! { read_u32, u32 }\n     read_primitive! { read_u64, u64 }\n-    read_primitive! { read_int, int }\n+    read_primitive! { read_int, isize }\n     read_primitive! { read_i8, i8 }\n     read_primitive! { read_i16, i16 }\n     read_primitive! { read_i32, i32 }\n@@ -2188,7 +2165,7 @@ impl ::Decoder for Decoder {\n             Json::U64(f) => Ok(f as f64),\n             Json::F64(f) => Ok(f),\n             Json::String(s) => {\n-                // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n+                // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n                 // is going to have a string here, as per JSON spec.\n                 match s.parse().ok() {\n                     Some(f) => Ok(f),\n@@ -2229,7 +2206,7 @@ impl ::Decoder for Decoder {\n \n     fn read_enum_variant<T, F>(&mut self, names: &[&str],\n                                mut f: F) -> DecodeResult<T>\n-        where F: FnMut(&mut Decoder, uint) -> DecodeResult<T>,\n+        where F: FnMut(&mut Decoder, usize) -> DecodeResult<T>,\n     {\n         let name = match self.pop() {\n             Json::String(s) => s,\n@@ -2269,30 +2246,30 @@ impl ::Decoder for Decoder {\n         f(self, idx)\n     }\n \n-    fn read_enum_variant_arg<T, F>(&mut self, _idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_enum_variant_arg<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         f(self)\n     }\n \n     fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> DecodeResult<T> where\n-        F: FnMut(&mut Decoder, uint) -> DecodeResult<T>,\n+        F: FnMut(&mut Decoder, usize) -> DecodeResult<T>,\n     {\n         self.read_enum_variant(names, f)\n     }\n \n \n     fn read_enum_struct_variant_field<T, F>(&mut self,\n                                          _name: &str,\n-                                         idx: uint,\n+                                         idx: usize,\n                                          f: F)\n                                          -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         self.read_enum_variant_arg(idx, f)\n     }\n \n-    fn read_struct<T, F>(&mut self, _name: &str, _len: uint, f: F) -> DecodeResult<T> where\n+    fn read_struct<T, F>(&mut self, _name: &str, _len: usize, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         let value = try!(f(self));\n@@ -2302,7 +2279,7 @@ impl ::Decoder for Decoder {\n \n     fn read_struct_field<T, F>(&mut self,\n                                name: &str,\n-                               _idx: uint,\n+                               _idx: usize,\n                                f: F)\n                                -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n@@ -2328,7 +2305,7 @@ impl ::Decoder for Decoder {\n         Ok(value)\n     }\n \n-    fn read_tuple<T, F>(&mut self, tuple_len: uint, f: F) -> DecodeResult<T> where\n+    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         self.read_seq(move |d, len| {\n@@ -2340,15 +2317,15 @@ impl ::Decoder for Decoder {\n         })\n     }\n \n-    fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         self.read_seq_elt(idx, f)\n     }\n \n     fn read_tuple_struct<T, F>(&mut self,\n                                _name: &str,\n-                               len: uint,\n+                               len: usize,\n                                f: F)\n                                -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n@@ -2357,7 +2334,7 @@ impl ::Decoder for Decoder {\n     }\n \n     fn read_tuple_struct_arg<T, F>(&mut self,\n-                                   idx: uint,\n+                                   idx: usize,\n                                    f: F)\n                                    -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n@@ -2375,7 +2352,7 @@ impl ::Decoder for Decoder {\n     }\n \n     fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder, usize) -> DecodeResult<T>,\n     {\n         let array = try!(expect!(self.pop(), Array));\n         let len = array.len();\n@@ -2385,14 +2362,14 @@ impl ::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_seq_elt<T, F>(&mut self, _idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         f(self)\n     }\n \n     fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder, usize) -> DecodeResult<T>,\n     {\n         let obj = try!(expect!(self.pop(), Object));\n         let len = obj.len();\n@@ -2403,13 +2380,13 @@ impl ::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_map_elt_key<T, F>(&mut self, _idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T> where\n        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         f(self)\n     }\n \n-    fn read_map_elt_val<T, F>(&mut self, _idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T> where\n        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         f(self)\n@@ -2430,27 +2407,25 @@ macro_rules! to_json_impl_i64 {\n     ($($t:ty), +) => (\n         $(impl ToJson for $t {\n             fn to_json(&self) -> Json {\n-                #![allow(trivial_numeric_casts)]\n                 Json::I64(*self as i64)\n             }\n         })+\n     )\n }\n \n-to_json_impl_i64! { int, i8, i16, i32, i64 }\n+to_json_impl_i64! { isize, i8, i16, i32, i64 }\n \n macro_rules! to_json_impl_u64 {\n     ($($t:ty), +) => (\n         $(impl ToJson for $t {\n             fn to_json(&self) -> Json {\n-                #![allow(trivial_numeric_casts)]\n                 Json::U64(*self as u64)\n             }\n         })+\n     )\n }\n \n-to_json_impl_u64! { uint, u8, u16, u32, u64 }\n+to_json_impl_u64! { usize, u8, u16, u32, u64 }\n \n impl ToJson for Json {\n     fn to_json(&self) -> Json { self.clone() }\n@@ -2605,7 +2580,7 @@ impl<'a, T: Encodable> fmt::Display for AsJson<'a, T> {\n \n impl<'a, T> AsPrettyJson<'a, T> {\n     /// Set the indentation level for the emitted JSON\n-    pub fn indent(mut self, indent: uint) -> AsPrettyJson<'a, T> {\n+    pub fn indent(mut self, indent: usize) -> AsPrettyJson<'a, T> {\n         self.indent = Some(indent);\n         self\n     }\n@@ -2655,7 +2630,7 @@ mod tests {\n \n     #[derive(RustcDecodable, Eq, PartialEq, Debug)]\n     struct OptionData {\n-        opt: Option<uint>,\n+        opt: Option<usize>,\n     }\n \n     #[test]\n@@ -2683,13 +2658,13 @@ mod tests {\n     #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n     enum Animal {\n         Dog,\n-        Frog(string::String, int)\n+        Frog(string::String, isize)\n     }\n \n     #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n     struct Inner {\n         a: (),\n-        b: uint,\n+        b: usize,\n         c: Vec<string::String>,\n     }\n \n@@ -3113,30 +3088,30 @@ mod tests {\n         let v: Vec<bool> = super::decode(\"[true]\").unwrap();\n         assert_eq!(v, [true]);\n \n-        let v: Vec<int> = super::decode(\"[3, 1]\").unwrap();\n+        let v: Vec<isize> = super::decode(\"[3, 1]\").unwrap();\n         assert_eq!(v, [3, 1]);\n \n-        let v: Vec<Vec<uint>> = super::decode(\"[[3], [1, 2]]\").unwrap();\n+        let v: Vec<Vec<usize>> = super::decode(\"[[3], [1, 2]]\").unwrap();\n         assert_eq!(v, [vec![3], vec![1, 2]]);\n     }\n \n     #[test]\n     fn test_decode_tuple() {\n-        let t: (uint, uint, uint) = super::decode(\"[1, 2, 3]\").unwrap();\n+        let t: (usize, usize, usize) = super::decode(\"[1, 2, 3]\").unwrap();\n         assert_eq!(t, (1, 2, 3));\n \n-        let t: (uint, string::String) = super::decode(\"[1, \\\"two\\\"]\").unwrap();\n+        let t: (usize, string::String) = super::decode(\"[1, \\\"two\\\"]\").unwrap();\n         assert_eq!(t, (1, \"two\".to_string()));\n     }\n \n     #[test]\n     fn test_decode_tuple_malformed_types() {\n-        assert!(super::decode::<(uint, string::String)>(\"[1, 2]\").is_err());\n+        assert!(super::decode::<(usize, string::String)>(\"[1, 2]\").is_err());\n     }\n \n     #[test]\n     fn test_decode_tuple_malformed_length() {\n-        assert!(super::decode::<(uint, uint)>(\"[1, 2, 3]\").is_err());\n+        assert!(super::decode::<(usize, usize)>(\"[1, 2, 3]\").is_err());\n     }\n \n     #[test]\n@@ -3488,7 +3463,7 @@ mod tests {\n         use std::str::from_utf8;\n         use std::old_io::Writer;\n         use std::collections::HashMap;\n-        let mut hm: HashMap<uint, bool> = HashMap::new();\n+        let mut hm: HashMap<usize, bool> = HashMap::new();\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n@@ -3504,7 +3479,7 @@ mod tests {\n         use std::str::from_utf8;\n         use std::old_io::Writer;\n         use std::collections::HashMap;\n-        let mut hm: HashMap<uint, bool> = HashMap::new();\n+        let mut hm: HashMap<usize, bool> = HashMap::new();\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n@@ -3537,7 +3512,7 @@ mod tests {\n         );\n \n         // Helper function for counting indents\n-        fn indents(source: &str) -> uint {\n+        fn indents(source: &str) -> usize {\n             let trimmed = source.trim_left_matches(' ');\n             source.len() - trimmed.len()\n         }\n@@ -3595,7 +3570,7 @@ mod tests {\n             Ok(o) => o\n         };\n         let mut decoder = Decoder::new(json_obj);\n-        let _hm: HashMap<uint, bool> = Decodable::decode(&mut decoder).unwrap();\n+        let _hm: HashMap<usize, bool> = Decodable::decode(&mut decoder).unwrap();\n     }\n \n     #[test]\n@@ -3608,7 +3583,7 @@ mod tests {\n             Ok(o) => o\n         };\n         let mut decoder = Decoder::new(json_obj);\n-        let result: Result<HashMap<uint, bool>, DecoderError> = Decodable::decode(&mut decoder);\n+        let result: Result<HashMap<usize, bool>, DecoderError> = Decodable::decode(&mut decoder);\n         assert_eq!(result, Err(ExpectedError(\"Number\".to_string(), \"a\".to_string())));\n     }\n \n@@ -3971,14 +3946,14 @@ mod tests {\n         assert_eq!(hash_map.to_json(), object);\n         assert_eq!(Some(15).to_json(), I64(15));\n         assert_eq!(Some(15 as usize).to_json(), U64(15));\n-        assert_eq!(None::<int>.to_json(), Null);\n+        assert_eq!(None::<isize>.to_json(), Null);\n     }\n \n     #[test]\n     fn test_encode_hashmap_with_arbitrary_key() {\n         use std::collections::HashMap;\n         #[derive(PartialEq, Eq, Hash, RustcEncodable)]\n-        struct ArbitraryType(uint);\n+        struct ArbitraryType(usize);\n         let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();\n         hm.insert(ArbitraryType(1), true);\n         let mut mem_buf = string::String::new();"}, {"sha": "b79323b3f962de18e5241780813d3fba3c188831", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -30,7 +30,6 @@ Core encoding and decoding interfaces.\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "81b5d4c5818b659d48b216d703f78c09fa3b4e56", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -26,12 +26,12 @@ pub trait Encoder {\n \n     // Primitive types:\n     fn emit_nil(&mut self) -> Result<(), Self::Error>;\n-    fn emit_uint(&mut self, v: uint) -> Result<(), Self::Error>;\n+    fn emit_uint(&mut self, v: usize) -> Result<(), Self::Error>;\n     fn emit_u64(&mut self, v: u64) -> Result<(), Self::Error>;\n     fn emit_u32(&mut self, v: u32) -> Result<(), Self::Error>;\n     fn emit_u16(&mut self, v: u16) -> Result<(), Self::Error>;\n     fn emit_u8(&mut self, v: u8) -> Result<(), Self::Error>;\n-    fn emit_int(&mut self, v: int) -> Result<(), Self::Error>;\n+    fn emit_int(&mut self, v: isize) -> Result<(), Self::Error>;\n     fn emit_i64(&mut self, v: i64) -> Result<(), Self::Error>;\n     fn emit_i32(&mut self, v: i32) -> Result<(), Self::Error>;\n     fn emit_i16(&mut self, v: i16) -> Result<(), Self::Error>;\n@@ -47,41 +47,41 @@ pub trait Encoder {\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n     fn emit_enum_variant<F>(&mut self, v_name: &str,\n-                            v_id: uint,\n-                            len: uint,\n+                            v_id: usize,\n+                            len: usize,\n                             f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_enum_variant_arg<F>(&mut self, a_idx: uint, f: F)\n+    fn emit_enum_variant_arg<F>(&mut self, a_idx: usize, f: F)\n                                 -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n     fn emit_enum_struct_variant<F>(&mut self, v_name: &str,\n-                                   v_id: uint,\n-                                   len: uint,\n+                                   v_id: usize,\n+                                   len: usize,\n                                    f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n     fn emit_enum_struct_variant_field<F>(&mut self,\n                                          f_name: &str,\n-                                         f_idx: uint,\n+                                         f_idx: usize,\n                                          f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n-    fn emit_struct<F>(&mut self, name: &str, len: uint, f: F)\n+    fn emit_struct<F>(&mut self, name: &str, len: usize, f: F)\n                       -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_struct_field<F>(&mut self, f_name: &str, f_idx: uint, f: F)\n+    fn emit_struct_field<F>(&mut self, f_name: &str, f_idx: usize, f: F)\n                             -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n-    fn emit_tuple<F>(&mut self, len: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_tuple<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n-    fn emit_tuple_struct<F>(&mut self, name: &str, len: uint, f: F)\n+    fn emit_tuple_struct<F>(&mut self, name: &str, len: usize, f: F)\n                             -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_tuple_struct_arg<F>(&mut self, f_idx: uint, f: F)\n+    fn emit_tuple_struct_arg<F>(&mut self, f_idx: usize, f: F)\n                                 -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n@@ -92,16 +92,16 @@ pub trait Encoder {\n     fn emit_option_some<F>(&mut self, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n-    fn emit_seq<F>(&mut self, len: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_seq<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n-    fn emit_map<F>(&mut self, len: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_map<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_map_elt_val<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_map_elt_val<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n }\n \n@@ -110,12 +110,12 @@ pub trait Decoder {\n \n     // Primitive types:\n     fn read_nil(&mut self) -> Result<(), Self::Error>;\n-    fn read_uint(&mut self) -> Result<uint, Self::Error>;\n+    fn read_uint(&mut self) -> Result<usize, Self::Error>;\n     fn read_u64(&mut self) -> Result<u64, Self::Error>;\n     fn read_u32(&mut self) -> Result<u32, Self::Error>;\n     fn read_u16(&mut self) -> Result<u16, Self::Error>;\n     fn read_u8(&mut self) -> Result<u8, Self::Error>;\n-    fn read_int(&mut self) -> Result<int, Self::Error>;\n+    fn read_int(&mut self) -> Result<isize, Self::Error>;\n     fn read_i64(&mut self) -> Result<i64, Self::Error>;\n     fn read_i32(&mut self) -> Result<i32, Self::Error>;\n     fn read_i16(&mut self) -> Result<i16, Self::Error>;\n@@ -132,41 +132,41 @@ pub trait Decoder {\n \n     fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F)\n                                -> Result<T, Self::Error>\n-        where F: FnMut(&mut Self, uint) -> Result<T, Self::Error>;\n-    fn read_enum_variant_arg<T, F>(&mut self, a_idx: uint, f: F)\n+        where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>;\n+    fn read_enum_variant_arg<T, F>(&mut self, a_idx: usize, f: F)\n                                    -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n     fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F)\n                                       -> Result<T, Self::Error>\n-        where F: FnMut(&mut Self, uint) -> Result<T, Self::Error>;\n+        where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>;\n     fn read_enum_struct_variant_field<T, F>(&mut self,\n                                             &f_name: &str,\n-                                            f_idx: uint,\n+                                            f_idx: usize,\n                                             f: F)\n                                             -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n-    fn read_struct<T, F>(&mut self, s_name: &str, len: uint, f: F)\n+    fn read_struct<T, F>(&mut self, s_name: &str, len: usize, f: F)\n                          -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n     fn read_struct_field<T, F>(&mut self,\n                                f_name: &str,\n-                               f_idx: uint,\n+                               f_idx: usize,\n                                f: F)\n                                -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n-    fn read_tuple<T, F>(&mut self, len: uint, f: F) -> Result<T, Self::Error>\n+    fn read_tuple<T, F>(&mut self, len: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n-    fn read_tuple_arg<T, F>(&mut self, a_idx: uint, f: F)\n+    fn read_tuple_arg<T, F>(&mut self, a_idx: usize, f: F)\n                             -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n-    fn read_tuple_struct<T, F>(&mut self, s_name: &str, len: uint, f: F)\n+    fn read_tuple_struct<T, F>(&mut self, s_name: &str, len: usize, f: F)\n                                -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n-    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: uint, f: F)\n+    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: usize, f: F)\n                                    -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n@@ -175,16 +175,16 @@ pub trait Decoder {\n         where F: FnMut(&mut Self, bool) -> Result<T, Self::Error>;\n \n     fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self, uint) -> Result<T, Self::Error>;\n-    fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>;\n+    fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n     fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self, uint) -> Result<T, Self::Error>;\n-    fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F)\n+        where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>;\n+    fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F)\n                               -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n-    fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F)\n+    fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F)\n                               -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n@@ -200,14 +200,14 @@ pub trait Decodable {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error>;\n }\n \n-impl Encodable for uint {\n+impl Encodable for usize {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_uint(*self)\n     }\n }\n \n-impl Decodable for uint {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<uint, D::Error> {\n+impl Decodable for usize {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<usize, D::Error> {\n         d.read_uint()\n     }\n }\n@@ -260,14 +260,14 @@ impl Decodable for u64 {\n     }\n }\n \n-impl Encodable for int {\n+impl Encodable for isize {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_int(*self)\n     }\n }\n \n-impl Decodable for int {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<int, D::Error> {\n+impl Decodable for isize {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<isize, D::Error> {\n         d.read_int()\n     }\n }\n@@ -510,7 +510,7 @@ macro_rules! tuple {\n         impl<$($name:Decodable),*> Decodable for ($($name,)*) {\n             #[allow(non_snake_case)]\n             fn decode<D: Decoder>(d: &mut D) -> Result<($($name,)*), D::Error> {\n-                let len: uint = count_idents!($($name,)*);\n+                let len: usize = count_idents!($($name,)*);\n                 d.read_tuple(len, |d| {\n                     let mut i = 0;\n                     let ret = ($(try!(d.read_tuple_arg({ i+=1; i-1 },"}, {"sha": "20ad71a4bf8c854ef1144a9ba91356d131d12c60", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 98, "deletions": 4, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -34,44 +34,124 @@ pub trait OwnedAsciiExt {\n     fn into_ascii_lowercase(self) -> Self;\n }\n \n-/// Extension methods for ASCII-subset only operations on string slices\n+/// Extension methods for ASCII-subset only operations on string slices.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsciiExt {\n     /// Container type for copied ASCII characters.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Owned;\n \n     /// Check if within the ASCII range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    ///\n+    /// let ascii = 'a';\n+    /// let utf8 = '\u2764';\n+    ///\n+    /// assert_eq!(true, ascii.is_ascii());\n+    /// assert_eq!(false, utf8.is_ascii())\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_ascii(&self) -> bool;\n \n-    /// Makes a copy of the string in ASCII upper case:\n+    /// Makes a copy of the string in ASCII upper case.\n+    ///\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    ///\n+    /// let ascii = 'a';\n+    /// let utf8 = '\u2764';\n+    ///\n+    /// assert_eq!('A', ascii.to_ascii_uppercase());\n+    /// assert_eq!('\u2764', utf8.to_ascii_uppercase());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_ascii_uppercase(&self) -> Self::Owned;\n \n-    /// Makes a copy of the string in ASCII lower case:\n+    /// Makes a copy of the string in ASCII lower case.\n+    ///\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    ///\n+    /// let ascii = 'A';\n+    /// let utf8 = '\u2764';\n+    ///\n+    /// assert_eq!('a', ascii.to_ascii_lowercase());\n+    /// assert_eq!('\u2764', utf8.to_ascii_lowercase());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_ascii_lowercase(&self) -> Self::Owned;\n \n     /// Check that two strings are an ASCII case-insensitive match.\n+    ///\n     /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n     /// but without allocating and copying temporary strings.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    ///\n+    /// let ascii1 = 'A';\n+    /// let ascii2 = 'a';\n+    /// let ascii3 = 'A';\n+    /// let ascii4 = 'z';\n+    ///\n+    /// assert_eq!(true, ascii1.eq_ignore_ascii_case(&ascii2));\n+    /// assert_eq!(true, ascii1.eq_ignore_ascii_case(&ascii3));\n+    /// assert_eq!(false, ascii1.eq_ignore_ascii_case(&ascii4));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n \n     /// Convert this type to its ASCII upper case equivalent in-place.\n     ///\n     /// See `to_ascii_uppercase` for more information.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(ascii)]\n+    /// use std::ascii::AsciiExt;\n+    ///\n+    /// let mut ascii = 'a';\n+    ///\n+    /// ascii.make_ascii_uppercase();\n+    ///\n+    /// assert_eq!('A', ascii);\n+    /// ```\n     #[unstable(feature = \"ascii\")]\n     fn make_ascii_uppercase(&mut self);\n \n     /// Convert this type to its ASCII lower case equivalent in-place.\n     ///\n     /// See `to_ascii_lowercase` for more information.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(ascii)]\n+    /// use std::ascii::AsciiExt;\n+    ///\n+    /// let mut ascii = 'A';\n+    ///\n+    /// ascii.make_ascii_lowercase();\n+    ///\n+    /// assert_eq!('a', ascii);\n+    /// ```\n     #[unstable(feature = \"ascii\")]\n     fn make_ascii_lowercase(&mut self);\n }\n@@ -246,7 +326,7 @@ pub struct EscapeDefault {\n     data: [u8; 4],\n }\n \n-/// Returns a 'default' ASCII and C++11-like literal escape of a `u8`\n+/// Returns an iterator that produces an escaped version of a `u8`.\n ///\n /// The default is chosen with a bias toward producing literals that are\n /// legal in a variety of languages, including C++11 and similar C-family\n@@ -257,6 +337,20 @@ pub struct EscapeDefault {\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n /// - Any other chars are given hex escapes of the form '\\xNN'.\n /// - Unicode escapes are never generated by this function.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ascii;\n+///\n+/// let escaped = ascii::escape_default(b'0').next().unwrap();\n+/// assert_eq!(b'0', escaped);\n+///\n+/// let mut escaped = ascii::escape_default(b'\\t');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b't', escaped.next().unwrap());\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn escape_default(c: u8) -> EscapeDefault {\n     let (data, len) = match c {"}, {"sha": "f9e1cb877b60bfd847443b4e451cbfabf49490f7", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -505,7 +505,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::new();\n+    /// let mut map: HashMap<&str, isize> = HashMap::new();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -519,7 +519,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n+    /// let mut map: HashMap<&str, isize> = HashMap::with_capacity(10);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -596,7 +596,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let map: HashMap<int, int> = HashMap::with_capacity(100);\n+    /// let map: HashMap<isize, isize> = HashMap::with_capacity(100);\n     /// assert!(map.capacity() >= 100);\n     /// ```\n     #[inline]\n@@ -617,7 +617,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::new();\n+    /// let mut map: HashMap<&str, isize> = HashMap::new();\n     /// map.reserve(10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -725,7 +725,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     /// use std::collections::HashMap;\n     ///\n-    /// let mut map: HashMap<int, int> = HashMap::with_capacity(100);\n+    /// let mut map: HashMap<isize, isize> = HashMap::with_capacity(100);\n     /// map.insert(1, 2);\n     /// map.insert(3, 4);\n     /// assert!(map.capacity() >= 100);\n@@ -797,9 +797,9 @@ impl<K, V, S> HashMap<K, V, S>\n                 }\n             }\n \n-            let robin_ib = bucket.index() as int - bucket.distance() as int;\n+            let robin_ib = bucket.index() as isize - bucket.distance() as isize;\n \n-            if (ib as int) < robin_ib {\n+            if (ib as isize) < robin_ib {\n                 // Found a luckier bucket than me. Better steal his spot.\n                 return robin_hood(bucket, robin_ib as usize, hash, k, v);\n             }\n@@ -924,7 +924,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// map.insert(\"c\", 3);\n     ///\n     /// // Not possible with .iter()\n-    /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n+    /// let vec: Vec<(&str, isize)> = map.into_iter().collect();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n@@ -1188,9 +1188,9 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n             }\n         }\n \n-        let robin_ib = bucket.index() as int - bucket.distance() as int;\n+        let robin_ib = bucket.index() as isize - bucket.distance() as isize;\n \n-        if (ib as int) < robin_ib {\n+        if (ib as isize) < robin_ib {\n             // Found a luckier bucket than me. Better steal his spot.\n             return Vacant(VacantEntry {\n                 hash: hash,\n@@ -1247,22 +1247,6 @@ impl<K, V, S> Default for HashMap<K, V, S>\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash + Borrow<Q>,\n-          Q: Eq + Hash,\n-          S: HashState,\n-{\n-    type Output = V;\n-\n-    #[inline]\n-    fn index<'a>(&'a self, index: &Q) -> &'a V {\n-        self.get(index).expect(\"no entry found for key\")\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, Q: ?Sized, V, S> Index<&'a Q> for HashMap<K, V, S>\n     where K: Eq + Hash + Borrow<Q>,\n@@ -1673,7 +1657,7 @@ mod test_map {\n         assert_eq!(*m.get(&2).unwrap(), 4);\n     }\n \n-    thread_local! { static DROP_VECTOR: RefCell<Vec<int>> = RefCell::new(Vec::new()) }\n+    thread_local! { static DROP_VECTOR: RefCell<Vec<isize>> = RefCell::new(Vec::new()) }\n \n     #[derive(Hash, PartialEq, Eq)]\n     struct Dropable {\n@@ -1830,7 +1814,7 @@ mod test_map {\n \n     #[test]\n     fn test_empty_pop() {\n-        let mut m: HashMap<int, bool> = HashMap::new();\n+        let mut m: HashMap<isize, bool> = HashMap::new();\n         assert_eq!(m.remove(&0), None);\n     }\n "}, {"sha": "710f0fe19db8e6d36782a44700db27857982277a", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -985,7 +985,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n #[unsafe_destructor]\n impl<K, V> Drop for RawTable<K, V> {\n     fn drop(&mut self) {\n-        if self.capacity == 0 {\n+        if self.capacity == 0 || self.capacity == mem::POST_DROP_USIZE {\n             return;\n         }\n "}, {"sha": "b96fe94dd2ed736d0f530701f52460dcdb23b620", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -14,16 +14,13 @@\n \n #![unstable(feature = \"std_misc\")]\n #![allow(missing_docs)]\n-#![allow(deprecated)] // will be addressed by #23197\n \n use prelude::v1::*;\n \n use env;\n-use ffi::CString;\n+use ffi::{AsOsStr, CString, OsString};\n use mem;\n-use old_path::{Path, GenericPath};\n-use os;\n-use str;\n+use path::{Path, PathBuf};\n \n pub struct DynamicLibrary {\n     handle: *mut u8\n@@ -54,7 +51,7 @@ impl DynamicLibrary {\n     /// Lazily open a dynamic library. When passed None it gives a\n     /// handle to the calling process\n     pub fn open(filename: Option<&Path>) -> Result<DynamicLibrary, String> {\n-        let maybe_library = dl::open(filename.map(|path| path.as_vec()));\n+        let maybe_library = dl::open(filename.map(|path| path.as_os_str()));\n \n         // The dynamic library must not be constructed if there is\n         // an error opening the library so the destructor does not\n@@ -68,19 +65,17 @@ impl DynamicLibrary {\n     /// Prepends a path to this process's search path for dynamic libraries\n     pub fn prepend_search_path(path: &Path) {\n         let mut search_path = DynamicLibrary::search_path();\n-        search_path.insert(0, path.clone());\n-        let newval = DynamicLibrary::create_path(&search_path);\n-        env::set_var(DynamicLibrary::envvar(),\n-                     str::from_utf8(&newval).unwrap());\n+        search_path.insert(0, path.to_path_buf());\n+        env::set_var(DynamicLibrary::envvar(), &DynamicLibrary::create_path(&search_path));\n     }\n \n     /// From a slice of paths, create a new vector which is suitable to be an\n     /// environment variable for this platforms dylib search path.\n-    pub fn create_path(path: &[Path]) -> Vec<u8> {\n-        let mut newvar = Vec::new();\n+    pub fn create_path(path: &[PathBuf]) -> OsString {\n+        let mut newvar = OsString::new();\n         for (i, path) in path.iter().enumerate() {\n             if i > 0 { newvar.push(DynamicLibrary::separator()); }\n-            newvar.push_all(path.as_vec());\n+            newvar.push(path);\n         }\n         return newvar;\n     }\n@@ -97,15 +92,15 @@ impl DynamicLibrary {\n         }\n     }\n \n-    fn separator() -> u8 {\n-        if cfg!(windows) {b';'} else {b':'}\n+    fn separator() -> &'static str {\n+        if cfg!(windows) { \";\" } else { \":\" }\n     }\n \n     /// Returns the current search path for dynamic libraries being used by this\n     /// process\n-    pub fn search_path() -> Vec<Path> {\n+    pub fn search_path() -> Vec<PathBuf> {\n         match env::var_os(DynamicLibrary::envvar()) {\n-            Some(var) => os::split_paths(var.to_str().unwrap()),\n+            Some(var) => env::split_paths(&var).collect(),\n             None => Vec::new(),\n         }\n     }\n@@ -134,8 +129,8 @@ mod test {\n     use super::*;\n     use prelude::v1::*;\n     use libc;\n-    use old_path::Path;\n     use mem;\n+    use path::Path;\n \n     #[test]\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)] // FIXME #8818, #10379\n@@ -192,12 +187,13 @@ mod test {\n mod dl {\n     use prelude::v1::*;\n \n-    use ffi::{CString, CStr};\n+    use ffi::{CStr, OsStr};\n     use str;\n     use libc;\n+    use os::unix::prelude::*;\n     use ptr;\n \n-    pub fn open(filename: Option<&[u8]>) -> Result<*mut u8, String> {\n+    pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         check_for_errors_in(|| {\n             unsafe {\n                 match filename {\n@@ -210,8 +206,8 @@ mod dl {\n \n     const LAZY: libc::c_int = 1;\n \n-    unsafe fn open_external(filename: &[u8]) -> *mut u8 {\n-        let s = CString::new(filename).unwrap();\n+    unsafe fn open_external(filename: &OsStr) -> *mut u8 {\n+        let s = filename.to_cstring().unwrap();\n         dlopen(s.as_ptr(), LAZY) as *mut u8\n     }\n \n@@ -264,21 +260,22 @@ mod dl {\n \n #[cfg(target_os = \"windows\")]\n mod dl {\n+    use ffi::OsStr;\n     use iter::IteratorExt;\n     use libc;\n     use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n     use ops::FnOnce;\n-    use os;\n+    use sys::os;\n+    use os::windows::prelude::*;\n     use option::Option::{self, Some, None};\n     use ptr;\n     use result::Result;\n     use result::Result::{Ok, Err};\n-    use str;\n     use string::String;\n     use vec::Vec;\n     use sys::c::compat::kernel32::SetThreadErrorMode;\n \n-    pub fn open(filename: Option<&[u8]>) -> Result<*mut u8, String> {\n+    pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         // disable \"dll load failed\" error dialog.\n         let mut use_thread_mode = true;\n         let prev_error_mode = unsafe {\n@@ -308,9 +305,8 @@ mod dl {\n \n         let result = match filename {\n             Some(filename) => {\n-                let filename_str = str::from_utf8(filename).unwrap();\n-                let mut filename_str: Vec<u16> = filename_str.utf16_units().collect();\n-                filename_str.push(0);\n+                let filename_str: Vec<_> =\n+                    filename.encode_wide().chain(Some(0).into_iter()).collect();\n                 let result = unsafe {\n                     LoadLibraryW(filename_str.as_ptr() as *const libc::c_void)\n                 };"}, {"sha": "49dbac4585bc31edb20ec5ae49e0ab59eed42013", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -113,38 +113,12 @@ impl From<String> for OsString {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> From<&'a String> for OsString {\n-    fn from(s: &'a String) -> OsString {\n-        OsString { inner: Buf::from_str(s) }\n+impl<'a, T: ?Sized + AsRef<OsStr>> From<&'a T> for OsString {\n+    fn from(s: &'a T) -> OsString {\n+        s.as_ref().to_os_string()\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> From<&'a str> for OsString {\n-    fn from(s: &'a str) -> OsString {\n-        OsString { inner: Buf::from_str(s) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> From<&'a OsStr> for OsString {\n-    fn from(s: &'a OsStr) -> OsString {\n-        OsString { inner: s.inner.to_owned() }\n-    }\n-}\n-\n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ops::Index<ops::RangeFull> for OsString {\n-    type Output = OsStr;\n-\n-    #[inline]\n-    fn index(&self, _index: &ops::RangeFull) -> &OsStr {\n-        unsafe { mem::transmute(self.inner.as_slice()) }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFull> for OsString {\n     type Output = OsStr;"}, {"sha": "8cc1dde98a0b8bd25178874dfda8da92742d7d46", "filename": "src/libstd/fs/tempdir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Ffs%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Ffs%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Ftempdir.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -34,7 +34,7 @@ const NUM_RETRIES: u32 = 1 << 31;\n // be enough to dissuade an attacker from trying to preemptively create names\n // of that length, but not so huge that we unnecessarily drain the random number\n // generator of entropy.\n-const NUM_RAND_CHARS: uint = 12;\n+const NUM_RAND_CHARS: usize = 12;\n \n impl TempDir {\n     /// Attempts to make a temporary directory inside of `tmpdir` whose name"}, {"sha": "998f37e6a6805f37e2236a261fffc6a553bdd973", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -98,7 +98,7 @@ impl<R: Read> BufRead for BufReader<R> {\n         self.buf.fill_buf()\n     }\n \n-    fn consume(&mut self, amt: uint) {\n+    fn consume(&mut self, amt: usize) {\n         self.buf.consume(amt)\n     }\n }\n@@ -427,7 +427,7 @@ impl<S: Read + Write> BufStream<S> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Read + Write> BufRead for BufStream<S> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }\n-    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n+    fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -681,7 +681,7 @@ mod tests {\n     }\n \n     #[test]\n-    #[should_fail]\n+    #[should_panic]\n     fn dont_panic_in_drop_on_panicked_flush() {\n         struct FailFlushWriter;\n "}, {"sha": "5d62f1341e300f046100ffd2abcd7a112c4ebfa4", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -609,8 +609,7 @@ pub trait BufRead: Read {\n     ///\n     /// This function will yield errors whenever `read_until` would have also\n     /// yielded an error.\n-    #[unstable(feature = \"io\", reason = \"may be renamed to not conflict with \\\n-                                         SliceExt::split\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split(self, byte: u8) -> Split<Self> where Self: Sized {\n         Split { buf: self, delim: byte }\n     }\n@@ -854,13 +853,13 @@ impl fmt::Display for CharsError {\n /// particular byte.\n ///\n /// See `BufReadExt::split` for more information.\n-#[unstable(feature = \"io\", reason = \"awaiting stability of BufReadExt::split\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<B> {\n     buf: B,\n     delim: u8,\n }\n \n-#[unstable(feature = \"io\", reason = \"awaiting stability of BufReadExt::split\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: BufRead> Iterator for Split<B> {\n     type Item = Result<Vec<u8>>;\n "}, {"sha": "8de6e5257ecd021f4cf23cf10621f75e01f2ab41", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -67,9 +67,8 @@\n //! module encapsulates the platform-specific rules for dealing\n //! with file paths.\n //!\n-//! `std` also includes modules for interoperating with the\n-//! C language: [`c_str`](c_str/index.html) and\n-//! [`c_vec`](c_vec/index.html).\n+//! `std` also includes the [`ffi`](ffi/index.html) module for interoperating\n+//! with the C language.\n //!\n //! ## Concurrency, I/O, and the runtime\n //!\n@@ -114,29 +113,27 @@\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(linkage, thread_local, asm)]\n-#![feature(old_impl_check)]\n #![feature(optin_builtin_traits)]\n #![feature(rand)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unsafe_destructor)]\n-#![feature(unsafe_no_drop_flag)]\n+#![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(macro_reexport)]\n-#![feature(int_uint)]\n #![feature(unique)]\n #![feature(convert)]\n #![feature(allow_internal_unstable)]\n #![feature(str_char)]\n #![feature(into_cow)]\n+#![feature(slice_patterns)]\n #![cfg_attr(test, feature(test, rustc_private, std_misc))]\n \n // Don't link to std. We are std.\n #![feature(no_std)]\n #![no_std]\n \n #![allow(trivial_casts)]\n-#![allow(trivial_numeric_casts)]\n #![deny(missing_docs)]\n \n #[cfg(test)] extern crate test;\n@@ -149,17 +146,17 @@ extern crate core;\n \n #[macro_use]\n #[macro_reexport(vec, format)]\n-extern crate \"collections\" as core_collections;\n+extern crate collections as core_collections;\n \n-#[allow(deprecated)] extern crate \"rand\" as core_rand;\n+#[allow(deprecated)] extern crate rand as core_rand;\n extern crate alloc;\n extern crate unicode;\n extern crate libc;\n \n #[macro_use] #[no_link] extern crate rustc_bitflags;\n \n // Make std testable by not duplicating lang items. See #2912\n-#[cfg(test)] extern crate \"std\" as realstd;\n+#[cfg(test)] extern crate std as realstd;\n #[cfg(test)] pub use realstd::marker;\n #[cfg(test)] pub use realstd::ops;\n #[cfg(test)] pub use realstd::cmp;"}, {"sha": "52492a019a2988170e2e94f52457b438264c5958", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -28,7 +28,7 @@\n ///\n /// # Examples\n ///\n-/// ```should_fail\n+/// ```should_panic\n /// # #![allow(unreachable_code)]\n /// panic!();\n /// panic!(\"this is a terrible mistake!\");"}, {"sha": "7c1667a603f65f7e8bcaf2cf3891f79320a32b0c", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -16,19 +16,14 @@\n use prelude::v1::*;\n \n use str::FromStr;\n-use net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n+use net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n \n struct Parser<'a> {\n     // parsing as ASCII, so can use byte array\n     s: &'a [u8],\n     pos: usize,\n }\n \n-enum IpAddr {\n-    V4(Ipv4Addr),\n-    V6(Ipv6Addr),\n-}\n-\n impl<'a> Parser<'a> {\n     fn new(s: &'a str) -> Parser<'a> {\n         Parser {\n@@ -296,6 +291,17 @@ impl<'a> Parser<'a> {\n     }\n }\n \n+#[unstable(feature = \"ip_addr\", reason = \"recent addition\")]\n+impl FromStr for IpAddr {\n+    type Err = AddrParseError;\n+    fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(AddrParseError(()))\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for Ipv4Addr {\n     type Err = AddrParseError;"}, {"sha": "dc1d53b8a3963f6d8f8623b9715f156b5f0f5057", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -91,27 +91,27 @@ impl Float for f32 {\n \n     #[allow(deprecated)]\n     #[inline]\n-    fn mantissa_digits(unused_self: Option<f32>) -> uint {\n+    fn mantissa_digits(unused_self: Option<f32>) -> usize {\n         num::Float::mantissa_digits(unused_self)\n     }\n     #[allow(deprecated)]\n     #[inline]\n-    fn digits(unused_self: Option<f32>) -> uint { num::Float::digits(unused_self) }\n+    fn digits(unused_self: Option<f32>) -> usize { num::Float::digits(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n     fn epsilon() -> f32 { num::Float::epsilon() }\n     #[allow(deprecated)]\n     #[inline]\n-    fn min_exp(unused_self: Option<f32>) -> int { num::Float::min_exp(unused_self) }\n+    fn min_exp(unused_self: Option<f32>) -> isize { num::Float::min_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n-    fn max_exp(unused_self: Option<f32>) -> int { num::Float::max_exp(unused_self) }\n+    fn max_exp(unused_self: Option<f32>) -> isize { num::Float::max_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n-    fn min_10_exp(unused_self: Option<f32>) -> int { num::Float::min_10_exp(unused_self) }\n+    fn min_10_exp(unused_self: Option<f32>) -> isize { num::Float::min_10_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n-    fn max_10_exp(unused_self: Option<f32>) -> int { num::Float::max_10_exp(unused_self) }\n+    fn max_10_exp(unused_self: Option<f32>) -> isize { num::Float::max_10_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n     fn min_value() -> f32 { num::Float::min_value() }\n@@ -201,11 +201,11 @@ impl Float for f32 {\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     #[inline]\n-    fn frexp(self) -> (f32, int) {\n+    fn frexp(self) -> (f32, isize) {\n         unsafe {\n             let mut exp = 0;\n             let x = cmath::frexpf(self, &mut exp);\n-            (x, exp as int)\n+            (x, exp as isize)\n         }\n     }\n \n@@ -476,7 +476,7 @@ impl f32 {\n                            `std::f64::MANTISSA_DIGITS` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn mantissa_digits(unused_self: Option<f32>) -> uint {\n+    pub fn mantissa_digits(unused_self: Option<f32>) -> usize {\n         num::Float::mantissa_digits(unused_self)\n     }\n \n@@ -486,7 +486,7 @@ impl f32 {\n                  reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn digits(unused_self: Option<f32>) -> uint { num::Float::digits(unused_self) }\n+    pub fn digits(unused_self: Option<f32>) -> usize { num::Float::digits(unused_self) }\n \n     /// Deprecated: use `std::f32::EPSILON` or `std::f64::EPSILON` instead.\n     #[unstable(feature = \"std_misc\")]\n@@ -502,31 +502,31 @@ impl f32 {\n                  reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn min_exp(unused_self: Option<f32>) -> int { num::Float::min_exp(unused_self) }\n+    pub fn min_exp(unused_self: Option<f32>) -> isize { num::Float::min_exp(unused_self) }\n \n     /// Deprecated: use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn max_exp(unused_self: Option<f32>) -> int { num::Float::max_exp(unused_self) }\n+    pub fn max_exp(unused_self: Option<f32>) -> isize { num::Float::max_exp(unused_self) }\n \n     /// Deprecated: use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn min_10_exp(unused_self: Option<f32>) -> int { num::Float::min_10_exp(unused_self) }\n+    pub fn min_10_exp(unused_self: Option<f32>) -> isize { num::Float::min_10_exp(unused_self) }\n \n     /// Deprecated: use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn max_10_exp(unused_self: Option<f32>) -> int { num::Float::max_10_exp(unused_self) }\n+    pub fn max_10_exp(unused_self: Option<f32>) -> isize { num::Float::max_10_exp(unused_self) }\n \n     /// Returns the smallest finite value that this type can represent.\n     ///\n@@ -1126,7 +1126,7 @@ impl f32 {\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n-    pub fn ldexp(x: f32, exp: int) -> f32 {\n+    pub fn ldexp(x: f32, exp: isize) -> f32 {\n         unsafe { cmath::ldexpf(x, exp as c_int) }\n     }\n \n@@ -1153,11 +1153,11 @@ impl f32 {\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n-    pub fn frexp(self) -> (f32, int) {\n+    pub fn frexp(self) -> (f32, isize) {\n         unsafe {\n             let mut exp = 0;\n             let x = cmath::frexpf(self, &mut exp);\n-            (x, exp as int)\n+            (x, exp as isize)\n         }\n     }\n \n@@ -1681,7 +1681,7 @@ pub fn to_str_radix_special(num: f32, rdx: u32) -> (String, bool) {\n /// * digits - The number of significant digits\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exact(num: f32, dig: uint) -> String {\n+pub fn to_str_exact(num: f32, dig: usize) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n     r\n@@ -1696,7 +1696,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> String {\n /// * digits - The number of significant digits\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_digits(num: f32, dig: uint) -> String {\n+pub fn to_str_digits(num: f32, dig: usize) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n     r\n@@ -1712,7 +1712,7 @@ pub fn to_str_digits(num: f32, dig: uint) -> String {\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n+pub fn to_str_exp_exact(num: f32, dig: usize, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n     r\n@@ -1728,7 +1728,7 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n+pub fn to_str_exp_digits(num: f32, dig: usize, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n     r"}, {"sha": "41ce9a2598c44a63cd673f1ce0f67f484c7a00a3", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -101,27 +101,27 @@ impl Float for f64 {\n \n     #[allow(deprecated)]\n     #[inline]\n-    fn mantissa_digits(unused_self: Option<f64>) -> uint {\n+    fn mantissa_digits(unused_self: Option<f64>) -> usize {\n         num::Float::mantissa_digits(unused_self)\n     }\n     #[allow(deprecated)]\n     #[inline]\n-    fn digits(unused_self: Option<f64>) -> uint { num::Float::digits(unused_self) }\n+    fn digits(unused_self: Option<f64>) -> usize { num::Float::digits(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n     fn epsilon() -> f64 { num::Float::epsilon() }\n     #[allow(deprecated)]\n     #[inline]\n-    fn min_exp(unused_self: Option<f64>) -> int { num::Float::min_exp(unused_self) }\n+    fn min_exp(unused_self: Option<f64>) -> isize { num::Float::min_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n-    fn max_exp(unused_self: Option<f64>) -> int { num::Float::max_exp(unused_self) }\n+    fn max_exp(unused_self: Option<f64>) -> isize { num::Float::max_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n-    fn min_10_exp(unused_self: Option<f64>) -> int { num::Float::min_10_exp(unused_self) }\n+    fn min_10_exp(unused_self: Option<f64>) -> isize { num::Float::min_10_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n-    fn max_10_exp(unused_self: Option<f64>) -> int { num::Float::max_10_exp(unused_self) }\n+    fn max_10_exp(unused_self: Option<f64>) -> isize { num::Float::max_10_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n     fn min_value() -> f64 { num::Float::min_value() }\n@@ -210,11 +210,11 @@ impl Float for f64 {\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     #[inline]\n-    fn frexp(self) -> (f64, int) {\n+    fn frexp(self) -> (f64, isize) {\n         unsafe {\n             let mut exp = 0;\n             let x = cmath::frexp(self, &mut exp);\n-            (x, exp as int)\n+            (x, exp as isize)\n         }\n     }\n \n@@ -485,7 +485,7 @@ impl f64 {\n                            `std::f64::MANTISSA_DIGITS` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn mantissa_digits(unused_self: Option<f64>) -> uint {\n+    pub fn mantissa_digits(unused_self: Option<f64>) -> usize {\n         num::Float::mantissa_digits(unused_self)\n     }\n \n@@ -495,7 +495,7 @@ impl f64 {\n                  reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn digits(unused_self: Option<f64>) -> uint { num::Float::digits(unused_self) }\n+    pub fn digits(unused_self: Option<f64>) -> usize { num::Float::digits(unused_self) }\n \n     /// Deprecated: use `std::f32::EPSILON` or `std::f64::EPSILON` instead.\n     #[unstable(feature = \"std_misc\")]\n@@ -511,31 +511,31 @@ impl f64 {\n                  reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn min_exp(unused_self: Option<f64>) -> int { num::Float::min_exp(unused_self) }\n+    pub fn min_exp(unused_self: Option<f64>) -> isize { num::Float::min_exp(unused_self) }\n \n     /// Deprecated: use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn max_exp(unused_self: Option<f64>) -> int { num::Float::max_exp(unused_self) }\n+    pub fn max_exp(unused_self: Option<f64>) -> isize { num::Float::max_exp(unused_self) }\n \n     /// Deprecated: use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn min_10_exp(unused_self: Option<f64>) -> int { num::Float::min_10_exp(unused_self) }\n+    pub fn min_10_exp(unused_self: Option<f64>) -> isize { num::Float::min_10_exp(unused_self) }\n \n     /// Deprecated: use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn max_10_exp(unused_self: Option<f64>) -> int { num::Float::max_10_exp(unused_self) }\n+    pub fn max_10_exp(unused_self: Option<f64>) -> isize { num::Float::max_10_exp(unused_self) }\n \n     /// Returns the smallest finite value that this type can represent.\n     ///\n@@ -1134,7 +1134,7 @@ impl f64 {\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n-    pub fn ldexp(x: f64, exp: int) -> f64 {\n+    pub fn ldexp(x: f64, exp: isize) -> f64 {\n         unsafe { cmath::ldexp(x, exp as c_int) }\n     }\n \n@@ -1161,11 +1161,11 @@ impl f64 {\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n-    pub fn frexp(self) -> (f64, int) {\n+    pub fn frexp(self) -> (f64, isize) {\n         unsafe {\n             let mut exp = 0;\n             let x = cmath::frexp(self, &mut exp);\n-            (x, exp as int)\n+            (x, exp as isize)\n         }\n     }\n \n@@ -1687,7 +1687,7 @@ pub fn to_str_radix_special(num: f64, rdx: u32) -> (String, bool) {\n /// * digits - The number of significant digits\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exact(num: f64, dig: uint) -> String {\n+pub fn to_str_exact(num: f64, dig: usize) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n     r\n@@ -1702,7 +1702,7 @@ pub fn to_str_exact(num: f64, dig: uint) -> String {\n /// * digits - The number of significant digits\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_digits(num: f64, dig: uint) -> String {\n+pub fn to_str_digits(num: f64, dig: usize) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n     r\n@@ -1718,7 +1718,7 @@ pub fn to_str_digits(num: f64, dig: uint) -> String {\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n+pub fn to_str_exp_exact(num: f64, dig: usize, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n     r\n@@ -1734,7 +1734,7 @@ pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n+pub fn to_str_exp_digits(num: f64, dig: usize, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n     r"}, {"sha": "1c1aaeb6d535a1519660af80f08b0158aa7032b3", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -49,10 +49,10 @@ pub enum SignificantDigits {\n \n     /// At most the given number of digits will be printed, truncating any\n     /// trailing zeroes.\n-    DigMax(uint),\n+    DigMax(usize),\n \n     /// Precisely the given number of digits will be printed.\n-    DigExact(uint)\n+    DigExact(usize)\n }\n \n /// How to emit the sign of a number.\n@@ -87,7 +87,7 @@ pub enum SignFormat {\n /// # Panics\n ///\n /// - Panics if `radix` < 2 or `radix` > 36.\n-fn int_to_str_bytes_common<T, F>(num: T, radix: uint, sign: SignFormat, mut f: F) where\n+fn int_to_str_bytes_common<T, F>(num: T, radix: usize, sign: SignFormat, mut f: F) where\n     T: Int,\n     F: FnMut(u8),\n {\n@@ -216,7 +216,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n \n     let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n     let mut buf = Vec::new();\n-    let radix_gen: T = num::cast(radix as int).unwrap();\n+    let radix_gen: T = num::cast(radix as isize).unwrap();\n \n     let (num, exp) = match exp_format {\n         ExpNone => (num, 0),\n@@ -328,28 +328,28 @@ pub fn float_to_str_bytes_common<T: Float>(\n \n             let extra_digit = ascii2value(buf.pop().unwrap());\n             if extra_digit >= radix / 2 { // -> need to round\n-                let mut i: int = buf.len() as int - 1;\n+                let mut i: isize = buf.len() as isize - 1;\n                 loop {\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || buf[i as uint] == b'-'\n-                    || buf[i as uint] == b'+' {\n-                        buf.insert((i + 1) as uint, value2ascii(1));\n+                    || buf[i as usize] == b'-'\n+                    || buf[i as usize] == b'+' {\n+                        buf.insert((i + 1) as usize, value2ascii(1));\n                         break;\n                     }\n \n                     // Skip the '.'\n-                    if buf[i as uint] == b'.' { i -= 1; continue; }\n+                    if buf[i as usize] == b'.' { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as uint]);\n+                    let current_digit = ascii2value(buf[i as usize]);\n                     if current_digit < (radix - 1) {\n-                        buf[i as uint] = value2ascii(current_digit+1);\n+                        buf[i as usize] = value2ascii(current_digit+1);\n                         break;\n                     } else {\n-                        buf[i as uint] = value2ascii(0);\n+                        buf[i as usize] = value2ascii(0);\n                         i -= 1;\n                     }\n                 }\n@@ -461,85 +461,85 @@ mod bench {\n     #![allow(deprecated)] // rand\n     extern crate test;\n \n-    mod uint {\n+    mod usize {\n         use super::test::Bencher;\n         use rand::{weak_rng, Rng};\n         use std::fmt;\n \n         #[inline]\n-        fn to_string(x: uint, base: u8) {\n+        fn to_string(x: usize, base: u8) {\n             format!(\"{}\", fmt::radix(x, base));\n         }\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<uint>(), 2); })\n+            b.iter(|| { to_string(rng.gen::<usize>(), 2); })\n         }\n \n         #[bench]\n         fn to_str_oct(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<uint>(), 8); })\n+            b.iter(|| { to_string(rng.gen::<usize>(), 8); })\n         }\n \n         #[bench]\n         fn to_str_dec(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<uint>(), 10); })\n+            b.iter(|| { to_string(rng.gen::<usize>(), 10); })\n         }\n \n         #[bench]\n         fn to_str_hex(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<uint>(), 16); })\n+            b.iter(|| { to_string(rng.gen::<usize>(), 16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<uint>(), 36); })\n+            b.iter(|| { to_string(rng.gen::<usize>(), 36); })\n         }\n     }\n \n-    mod int {\n+    mod isize {\n         use super::test::Bencher;\n         use rand::{weak_rng, Rng};\n         use std::fmt;\n \n         #[inline]\n-        fn to_string(x: int, base: u8) {\n+        fn to_string(x: isize, base: u8) {\n             format!(\"{}\", fmt::radix(x, base));\n         }\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<int>(), 2); })\n+            b.iter(|| { to_string(rng.gen::<isize>(), 2); })\n         }\n \n         #[bench]\n         fn to_str_oct(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<int>(), 8); })\n+            b.iter(|| { to_string(rng.gen::<isize>(), 8); })\n         }\n \n         #[bench]\n         fn to_str_dec(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<int>(), 10); })\n+            b.iter(|| { to_string(rng.gen::<isize>(), 10); })\n         }\n \n         #[bench]\n         fn to_str_hex(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<int>(), 16); })\n+            b.iter(|| { to_string(rng.gen::<isize>(), 16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<int>(), 36); })\n+            b.iter(|| { to_string(rng.gen::<isize>(), 36); })\n         }\n     }\n "}, {"sha": "502f414d50b98f1224e54d20cf3f7e52e0b7661f", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -49,8 +49,8 @@ use vec::Vec;\n pub struct BufferedReader<R> {\n     inner: R,\n     buf: Vec<u8>,\n-    pos: uint,\n-    cap: uint,\n+    pos: usize,\n+    cap: usize,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -63,7 +63,7 @@ impl<R> fmt::Debug for BufferedReader<R> where R: fmt::Debug {\n \n impl<R: Reader> BufferedReader<R> {\n     /// Creates a new `BufferedReader` with the specified buffer capacity\n-    pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> {\n+    pub fn with_capacity(cap: usize, inner: R) -> BufferedReader<R> {\n         BufferedReader {\n             inner: inner,\n             // We can't use the same trick here as we do for BufferedWriter,\n@@ -104,14 +104,14 @@ impl<R: Reader> Buffer for BufferedReader<R> {\n         Ok(&self.buf[self.pos..self.cap])\n     }\n \n-    fn consume(&mut self, amt: uint) {\n+    fn consume(&mut self, amt: usize) {\n         self.pos += amt;\n         assert!(self.pos <= self.cap);\n     }\n }\n \n impl<R: Reader> Reader for BufferedReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         if self.pos == self.cap && buf.len() >= self.buf.len() {\n             return self.inner.read(buf);\n         }\n@@ -151,7 +151,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n pub struct BufferedWriter<W: Writer> {\n     inner: Option<W>,\n     buf: Vec<u8>,\n-    pos: uint\n+    pos: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -164,7 +164,7 @@ impl<W: Writer> fmt::Debug for BufferedWriter<W> where W: fmt::Debug {\n \n impl<W: Writer> BufferedWriter<W> {\n     /// Creates a new `BufferedWriter` with the specified buffer capacity\n-    pub fn with_capacity(cap: uint, inner: W) -> BufferedWriter<W> {\n+    pub fn with_capacity(cap: usize, inner: W) -> BufferedWriter<W> {\n         // It's *much* faster to create an uninitialized buffer than it is to\n         // fill everything in with 0. This buffer is entirely an implementation\n         // detail and is never exposed, so we're safe to not initialize\n@@ -309,7 +309,7 @@ impl<W: Writer> InternalBufferedWriter<W> {\n }\n \n impl<W: Reader + Writer> Reader for InternalBufferedWriter<W> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.get_mut().inner.as_mut().unwrap().read(buf)\n     }\n }\n@@ -362,7 +362,7 @@ impl<S: Writer> fmt::Debug for BufferedStream<S> where S: fmt::Debug {\n impl<S: Stream> BufferedStream<S> {\n     /// Creates a new buffered stream with explicitly listed capacities for the\n     /// reader/writer buffer.\n-    pub fn with_capacities(reader_cap: uint, writer_cap: uint, inner: S)\n+    pub fn with_capacities(reader_cap: usize, writer_cap: usize, inner: S)\n                            -> BufferedStream<S> {\n         let writer = BufferedWriter::with_capacity(writer_cap, inner);\n         let internal_writer = InternalBufferedWriter(writer);\n@@ -407,11 +407,11 @@ impl<S: Stream> BufferedStream<S> {\n \n impl<S: Stream> Buffer for BufferedStream<S> {\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }\n-    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n+    fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n }\n \n impl<S: Stream> Reader for BufferedStream<S> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.inner.read(buf)\n     }\n }\n@@ -442,7 +442,7 @@ mod test {\n     pub struct NullStream;\n \n     impl Reader for NullStream {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n             Err(old_io::standard_error(old_io::EndOfFile))\n         }\n     }\n@@ -453,11 +453,11 @@ mod test {\n \n     /// A dummy reader intended at testing short-reads propagation.\n     pub struct ShortReader {\n-        lengths: Vec<uint>,\n+        lengths: Vec<usize>,\n     }\n \n     impl Reader for ShortReader {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n             if self.lengths.is_empty() {\n                 Err(old_io::standard_error(old_io::EndOfFile))\n             } else {\n@@ -510,45 +510,45 @@ mod test {\n \n         writer.write_all(&[0, 1]).unwrap();\n         let b: &[_] = &[];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n \n         writer.write_all(&[2]).unwrap();\n         let b: &[_] = &[0, 1];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n \n         writer.write_all(&[3]).unwrap();\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n \n         writer.flush().unwrap();\n         let a: &[_] = &[0, 1, 2, 3];\n-        assert_eq!(a, &writer.get_ref()[]);\n+        assert_eq!(a, &writer.get_ref()[..]);\n \n         writer.write_all(&[4]).unwrap();\n         writer.write_all(&[5]).unwrap();\n-        assert_eq!(a, &writer.get_ref()[]);\n+        assert_eq!(a, &writer.get_ref()[..]);\n \n         writer.write_all(&[6]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5];\n-        assert_eq!(a, &writer.get_ref()[]);\n+        assert_eq!(a, &writer.get_ref()[..]);\n \n         writer.write_all(&[7, 8]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5, 6];\n-        assert_eq!(a, &writer.get_ref()[]);\n+        assert_eq!(a, &writer.get_ref()[..]);\n \n         writer.write_all(&[9, 10, 11]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n-        assert_eq!(a, &writer.get_ref()[]);\n+        assert_eq!(a, &writer.get_ref()[..]);\n \n         writer.flush().unwrap();\n-        assert_eq!(a, &writer.get_ref()[]);\n+        assert_eq!(a, &writer.get_ref()[..]);\n     }\n \n     #[test]\n     fn test_buffered_writer_inner_flushes() {\n         let mut w = BufferedWriter::with_capacity(3, Vec::new());\n         w.write_all(&[0, 1]).unwrap();\n         let a: &[_] = &[];\n-        assert_eq!(a, &w.get_ref()[]);\n+        assert_eq!(a, &w.get_ref()[..]);\n         let w = w.into_inner();\n         let a: &[_] = &[0, 1];\n         assert_eq!(a, &w[..]);\n@@ -565,7 +565,7 @@ mod test {\n         }\n \n         impl old_io::Reader for S {\n-            fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+            fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n                 Err(old_io::standard_error(old_io::EndOfFile))\n             }\n         }\n@@ -593,21 +593,21 @@ mod test {\n         let mut writer = LineBufferedWriter::new(Vec::new());\n         writer.write_all(&[0]).unwrap();\n         let b: &[_] = &[];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n         writer.write_all(&[1]).unwrap();\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n         writer.flush().unwrap();\n         let b: &[_] = &[0, 1];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n         writer.write_all(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n'];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n         writer.flush().unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n         writer.write_all(&[3, b'\\n']).unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n'];\n-        assert_eq!(&writer.get_ref()[], b);\n+        assert_eq!(&writer.get_ref()[..], b);\n     }\n \n     #[test]"}, {"sha": "35bc58fecd282f3b6fc6886984bb89e13ce692d6", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -39,7 +39,7 @@ use vec::Vec;\n /// ```\n pub struct ChanReader {\n     buf: Vec<u8>,          // A buffer of bytes received but not consumed.\n-    pos: uint,             // How many of the buffered bytes have already be consumed.\n+    pos: usize,             // How many of the buffered bytes have already be consumed.\n     rx: Receiver<Vec<u8>>, // The Receiver to pull data from.\n     closed: bool,          // Whether the channel this Receiver connects to has been closed.\n }\n@@ -77,14 +77,14 @@ impl Buffer for ChanReader {\n         }\n     }\n \n-    fn consume(&mut self, amt: uint) {\n+    fn consume(&mut self, amt: usize) {\n         self.pos += amt;\n         assert!(self.pos <= self.buf.len());\n     }\n }\n \n impl Reader for ChanReader {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         let mut num_read = 0;\n         loop {\n             let count = match self.fill_buf().ok() {"}, {"sha": "441f0a7536e14139000ee6a78c0dcb31213cc2ad", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -81,7 +81,7 @@ impl<'r, R: Reader> Iterator for Bytes<'r, R> {\n /// * `f`: A callback that receives the value.\n ///\n /// This function returns the value returned by the callback, for convenience.\n-pub fn u64_to_le_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n+pub fn u64_to_le_bytes<T, F>(n: u64, size: usize, f: F) -> T where\n     F: FnOnce(&[u8]) -> T,\n {\n     use mem::transmute;\n@@ -122,7 +122,7 @@ pub fn u64_to_le_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n /// * `f`: A callback that receives the value.\n ///\n /// This function returns the value returned by the callback, for convenience.\n-pub fn u64_to_be_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n+pub fn u64_to_be_bytes<T, F>(n: u64, size: usize, f: F) -> T where\n     F: FnOnce(&[u8]) -> T,\n {\n     use mem::transmute;\n@@ -158,7 +158,7 @@ pub fn u64_to_be_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n ///           less, or task panic occurs. If this is less than 8, then only\n ///           that many bytes are parsed. For example, if `size` is 4, then a\n ///           32-bit value is parsed.\n-pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n+pub fn u64_from_be_bytes(data: &[u8], start: usize, size: usize) -> u64 {\n     use ptr::{copy_nonoverlapping};\n \n     assert!(size <= 8);\n@@ -169,9 +169,9 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n \n     let mut buf = [0; 8];\n     unsafe {\n-        let ptr = data.as_ptr().offset(start as int);\n+        let ptr = data.as_ptr().offset(start as isize);\n         let out = buf.as_mut_ptr();\n-        copy_nonoverlapping(out.offset((8 - size) as int), ptr, size);\n+        copy_nonoverlapping(out.offset((8 - size) as isize), ptr, size);\n         (*(out as *const u64)).to_be()\n     }\n }\n@@ -183,11 +183,11 @@ mod test {\n     use old_io::{MemReader, BytesReader};\n \n     struct InitialZeroByteReader {\n-        count: int,\n+        count: isize,\n     }\n \n     impl Reader for InitialZeroByteReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n             if self.count == 0 {\n                 self.count = 1;\n                 Ok(0)\n@@ -201,25 +201,25 @@ mod test {\n     struct EofReader;\n \n     impl Reader for EofReader {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n             Err(old_io::standard_error(old_io::EndOfFile))\n         }\n     }\n \n     struct ErroringReader;\n \n     impl Reader for ErroringReader {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n             Err(old_io::standard_error(old_io::InvalidInput))\n         }\n     }\n \n     struct PartialReader {\n-        count: int,\n+        count: isize,\n     }\n \n     impl Reader for PartialReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n@@ -234,11 +234,11 @@ mod test {\n     }\n \n     struct ErroringLaterReader {\n-        count: int,\n+        count: isize,\n     }\n \n     impl Reader for ErroringLaterReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n@@ -250,11 +250,11 @@ mod test {\n     }\n \n     struct ThreeChunkReader {\n-        count: int,\n+        count: isize,\n     }\n \n     impl Reader for ThreeChunkReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;"}, {"sha": "e47c1b238ebeec73c37f269248847e3ef99cb778", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -88,7 +88,7 @@ use sys_common;\n pub struct File {\n     fd: fs_imp::FileDesc,\n     path: Path,\n-    last_nread: int,\n+    last_nread: isize,\n }\n \n impl sys_common::AsInner<fs_imp::FileDesc> for File {\n@@ -105,7 +105,7 @@ impl File {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,should_fail\n+    /// ```rust,should_panic\n     /// # #![feature(old_io, old_path)]\n     /// use std::old_io::*;\n     /// use std::old_path::Path;\n@@ -472,14 +472,14 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::set_permissions\")]\n #[unstable(feature = \"old_io\")]\n pub fn chmod(path: &Path, mode: old_io::FilePermission) -> IoResult<()> {\n-    fs_imp::chmod(path, mode.bits() as uint)\n+    fs_imp::chmod(path, mode.bits() as usize)\n            .update_err(\"couldn't chmod path\", |e|\n                format!(\"{}; path={}; mode={:?}\", e, path.display(), mode))\n }\n \n /// Change the user and group owners of a file at the specified path.\n #[unstable(feature = \"old_fs\")]\n-pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n+pub fn chown(path: &Path, uid: isize, gid: isize) -> IoResult<()> {\n     fs_imp::chown(path, uid, gid)\n            .update_err(\"couldn't chown path\", |e|\n                format!(\"{}; path={}; uid={}; gid={}\", e, path.display(), uid, gid))\n@@ -541,7 +541,7 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n /// new directory at the provided `path`, or if the directory already exists.\n #[unstable(feature = \"old_fs\")]\n pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n-    fs_imp::mkdir(path, mode.bits() as uint)\n+    fs_imp::mkdir(path, mode.bits() as usize)\n            .update_err(\"couldn't create directory\", |e|\n                format!(\"{}; path={}; mode={}\", e, path.display(), mode))\n }\n@@ -773,7 +773,7 @@ pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n }\n \n impl Reader for File {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         fn update_err<T>(result: IoResult<T>, file: &File) -> IoResult<T> {\n             result.update_err(\"couldn't read file\",\n                               |e| format!(\"{}; path={}\",\n@@ -784,10 +784,10 @@ impl Reader for File {\n \n         match result {\n             Ok(read) => {\n-                self.last_nread = read as int;\n+                self.last_nread = read as isize;\n                 match read {\n                     0 => update_err(Err(standard_error(old_io::EndOfFile)), self),\n-                    _ => Ok(read as uint)\n+                    _ => Ok(read as usize)\n                 }\n             },\n             Err(e) => Err(e)\n@@ -1227,8 +1227,8 @@ mod test {\n             let stem = f.filestem_str().unwrap();\n             let root = stem.as_bytes()[0] - b'0';\n             let name = stem.as_bytes()[1] - b'0';\n-            assert!(cur[root as uint] < name);\n-            cur[root as uint] = name;\n+            assert!(cur[root as usize] < name);\n+            cur[root as usize] = name;\n         }\n \n         check!(rmdir_recursive(dir));"}, {"sha": "76a448c4aae0e4f96e3212b6ba66e95a1c509ecf", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -20,9 +20,9 @@ use old_io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice;\n use vec::Vec;\n \n-const BUF_CAPACITY: uint = 128;\n+const BUF_CAPACITY: usize = 128;\n \n-fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n+fn combine(seek: SeekStyle, cur: usize, end: usize, offset: i64) -> IoResult<u64> {\n     // compute offset as signed and clamp to prevent overflow\n     let pos = match seek {\n         old_io::SeekSet => 0,\n@@ -82,7 +82,7 @@ impl MemWriter {\n     /// Create a new `MemWriter`, allocating at least `n` bytes for\n     /// the internal buffer.\n     #[inline]\n-    pub fn with_capacity(n: uint) -> MemWriter {\n+    pub fn with_capacity(n: usize) -> MemWriter {\n         MemWriter::from_vec(Vec::with_capacity(n))\n     }\n     /// Create a new `MemWriter` that will append to an existing `Vec`.\n@@ -125,7 +125,7 @@ impl Writer for MemWriter {\n /// ```\n pub struct MemReader {\n     buf: Vec<u8>,\n-    pos: uint\n+    pos: usize\n }\n \n impl MemReader {\n@@ -160,7 +160,7 @@ impl MemReader {\n \n impl Reader for MemReader {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         if self.eof() { return Err(old_io::standard_error(old_io::EndOfFile)) }\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n@@ -184,7 +184,7 @@ impl Seek for MemReader {\n     #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = new as uint;\n+        self.pos = new as usize;\n         Ok(())\n     }\n }\n@@ -200,12 +200,12 @@ impl Buffer for MemReader {\n     }\n \n     #[inline]\n-    fn consume(&mut self, amt: uint) { self.pos += amt; }\n+    fn consume(&mut self, amt: usize) { self.pos += amt; }\n }\n \n impl<'a> Reader for &'a [u8] {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         if self.is_empty() { return Err(old_io::standard_error(old_io::EndOfFile)); }\n \n         let write_len = min(buf.len(), self.len());\n@@ -232,7 +232,7 @@ impl<'a> Buffer for &'a [u8] {\n     }\n \n     #[inline]\n-    fn consume(&mut self, amt: uint) {\n+    fn consume(&mut self, amt: usize) {\n         *self = &self[amt..];\n     }\n }\n@@ -259,7 +259,7 @@ impl<'a> Buffer for &'a [u8] {\n /// ```\n pub struct BufWriter<'a> {\n     buf: &'a mut [u8],\n-    pos: uint\n+    pos: usize\n }\n \n impl<'a> BufWriter<'a> {\n@@ -309,7 +309,7 @@ impl<'a> Seek for BufWriter<'a> {\n     #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = min(new as uint, self.buf.len());\n+        self.pos = min(new as usize, self.buf.len());\n         Ok(())\n     }\n }\n@@ -330,7 +330,7 @@ impl<'a> Seek for BufWriter<'a> {\n /// ```\n pub struct BufReader<'a> {\n     buf: &'a [u8],\n-    pos: uint\n+    pos: usize\n }\n \n impl<'a> BufReader<'a> {\n@@ -352,7 +352,7 @@ impl<'a> BufReader<'a> {\n \n impl<'a> Reader for BufReader<'a> {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         if self.eof() { return Err(old_io::standard_error(old_io::EndOfFile)) }\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n@@ -376,7 +376,7 @@ impl<'a> Seek for BufReader<'a> {\n     #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = new as uint;\n+        self.pos = new as usize;\n         Ok(())\n     }\n }\n@@ -392,12 +392,12 @@ impl<'a> Buffer for BufReader<'a> {\n     }\n \n     #[inline]\n-    fn consume(&mut self, amt: uint) { self.pos += amt; }\n+    fn consume(&mut self, amt: usize) { self.pos += amt; }\n }\n \n #[cfg(test)]\n mod test {\n-    extern crate \"test\" as test_crate;\n+    extern crate test as test_crate;\n     use old_io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek, Buffer};\n     use prelude::v1::{Ok, Err, Vec,  AsSlice};\n     use prelude::v1::IteratorExt;\n@@ -663,7 +663,7 @@ mod test {\n         assert_eq!(buf, b);\n     }\n \n-    fn do_bench_mem_writer(b: &mut Bencher, times: uint, len: uint) {\n+    fn do_bench_mem_writer(b: &mut Bencher, times: usize, len: usize) {\n         let src: Vec<u8> = repeat(5).take(len).collect();\n \n         b.bytes = (times * len) as u64;"}, {"sha": "aaa55c5d1d9b9eba876ea1aa10773ffbd799b556", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -326,7 +326,7 @@ pub mod test;\n /// The default buffer size for various I/O operations\n // libuv recommends 64k buffers to maximize throughput\n // https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n-const DEFAULT_BUF_SIZE: uint = 1024 * 64;\n+const DEFAULT_BUF_SIZE: usize = 1024 * 64;\n \n /// A convenient typedef of the return value of any I/O action.\n pub type IoResult<T> = Result<T, IoError>;\n@@ -441,7 +441,7 @@ pub enum IoErrorKind {\n     ///\n     /// The payload contained as part of this variant is the number of bytes\n     /// which are known to have been successfully written.\n-    ShortWrite(uint),\n+    ShortWrite(usize),\n     /// The Reader returned 0 bytes from `read()` too many times.\n     NoProgress,\n }\n@@ -483,7 +483,7 @@ impl<T> UpdateIoError for IoResult<T> {\n     }\n }\n \n-static NO_PROGRESS_LIMIT: uint = 1000;\n+static NO_PROGRESS_LIMIT: usize = 1000;\n \n /// A trait for objects which are byte-oriented streams. Readers are defined by\n /// one method, `read`. This function will block until data is available,\n@@ -511,7 +511,7 @@ pub trait Reader {\n     ///\n     /// When implementing this method on a new Reader, you are strongly encouraged\n     /// not to return 0 if you can avoid it.\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize>;\n \n     // Convenient helper methods based on the above methods\n \n@@ -526,7 +526,7 @@ pub trait Reader {\n     ///\n     /// If an error occurs at any point, that error is returned, and no further\n     /// bytes are read.\n-    fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read_at_least(&mut self, min: usize, buf: &mut [u8]) -> IoResult<usize> {\n         if min > buf.len() {\n             return Err(IoError {\n                 detail: Some(String::from_str(\"the buffer is too short\")),\n@@ -570,7 +570,7 @@ pub trait Reader {\n     ///\n     /// If an error occurs during this I/O operation, then it is returned\n     /// as `Err(IoError)`. See `read()` for more details.\n-    fn push(&mut self, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n+    fn push(&mut self, len: usize, buf: &mut Vec<u8>) -> IoResult<usize> {\n         let start_len = buf.len();\n         buf.reserve(len);\n \n@@ -594,7 +594,7 @@ pub trait Reader {\n     ///\n     /// If an error occurs at any point, that error is returned, and no further\n     /// bytes are read.\n-    fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n+    fn push_at_least(&mut self, min: usize, len: usize, buf: &mut Vec<u8>) -> IoResult<usize> {\n         if min > len {\n             return Err(IoError {\n                 detail: Some(String::from_str(\"the buffer is too short\")),\n@@ -629,7 +629,7 @@ pub trait Reader {\n     /// have already been consumed from the underlying reader, and they are lost\n     /// (not returned as part of the error). If this is unacceptable, then it is\n     /// recommended to use the `push_at_least` or `read` methods.\n-    fn read_exact(&mut self, len: uint) -> IoResult<Vec<u8>> {\n+    fn read_exact(&mut self, len: usize) -> IoResult<Vec<u8>> {\n         let mut buf = Vec::with_capacity(len);\n         match self.push_at_least(len, len, &mut buf) {\n             Ok(_) => Ok(buf),\n@@ -679,7 +679,7 @@ pub trait Reader {\n     /// Reads `n` little-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n+    fn read_le_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0;\n@@ -696,14 +696,14 @@ pub trait Reader {\n     /// Reads `n` little-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_int_n(&mut self, nbytes: uint) -> IoResult<i64> {\n+    fn read_le_int_n(&mut self, nbytes: usize) -> IoResult<i64> {\n         self.read_le_uint_n(nbytes).map(|i| extend_sign(i, nbytes))\n     }\n \n     /// Reads `n` big-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n+    fn read_be_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0;\n@@ -718,36 +718,36 @@ pub trait Reader {\n     /// Reads `n` big-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_int_n(&mut self, nbytes: uint) -> IoResult<i64> {\n+    fn read_be_int_n(&mut self, nbytes: usize) -> IoResult<i64> {\n         self.read_be_uint_n(nbytes).map(|i| extend_sign(i, nbytes))\n     }\n \n     /// Reads a little-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n-    fn read_le_uint(&mut self) -> IoResult<uint> {\n-        self.read_le_uint_n(usize::BYTES as usize).map(|i| i as uint)\n+    fn read_le_uint(&mut self) -> IoResult<usize> {\n+        self.read_le_uint_n(usize::BYTES as usize).map(|i| i as usize)\n     }\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n-    fn read_le_int(&mut self) -> IoResult<int> {\n-        self.read_le_int_n(isize::BYTES as usize).map(|i| i as int)\n+    fn read_le_int(&mut self) -> IoResult<isize> {\n+        self.read_le_int_n(isize::BYTES as usize).map(|i| i as isize)\n     }\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n-    fn read_be_uint(&mut self) -> IoResult<uint> {\n-        self.read_be_uint_n(usize::BYTES as usize).map(|i| i as uint)\n+    fn read_be_uint(&mut self) -> IoResult<usize> {\n+        self.read_be_uint_n(usize::BYTES as usize).map(|i| i as usize)\n     }\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n-    fn read_be_int(&mut self) -> IoResult<int> {\n-        self.read_be_int_n(isize::BYTES as usize).map(|i| i as int)\n+    fn read_be_int(&mut self) -> IoResult<isize> {\n+        self.read_be_int_n(isize::BYTES as usize).map(|i| i as isize)\n     }\n \n     /// Reads a big-endian `u64`.\n@@ -919,14 +919,14 @@ impl<T: Reader> BytesReader for T {\n }\n \n impl<'a> Reader for Box<Reader+'a> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         let reader: &mut Reader = &mut **self;\n         reader.read(buf)\n     }\n }\n \n impl<'a> Reader for &'a mut (Reader+'a) {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { (*self).read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> { (*self).read(buf) }\n }\n \n /// Returns a slice of `v` between `start` and `end`.\n@@ -940,13 +940,13 @@ impl<'a> Reader for &'a mut (Reader+'a) {\n /// `start` > `end`.\n // Private function here because we aren't sure if we want to expose this as\n // API yet. If so, it should be a method on Vec.\n-unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -> &'a mut [T] {\n+unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: usize, end: usize) -> &'a mut [T] {\n     use slice;\n \n     assert!(start <= end);\n     assert!(end <= v.capacity());\n     slice::from_raw_parts_mut(\n-        v.as_mut_ptr().offset(start as int),\n+        v.as_mut_ptr().offset(start as isize),\n         end - start\n     )\n }\n@@ -980,15 +980,15 @@ pub struct RefReader<'a, R:'a> {\n }\n \n impl<'a, R: Reader> Reader for RefReader<'a, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.inner.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> { self.inner.read(buf) }\n }\n \n impl<'a, R: Buffer> Buffer for RefReader<'a, R> {\n     fn fill_buf(&mut self) -> IoResult<&[u8]> { self.inner.fill_buf() }\n-    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n+    fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n }\n \n-fn extend_sign(val: u64, nbytes: uint) -> i64 {\n+fn extend_sign(val: u64, nbytes: usize) -> i64 {\n     let shift = (8 - nbytes) * 8;\n     (val << shift) as i64 >> shift\n }\n@@ -1095,39 +1095,39 @@ pub trait Writer {\n         self.write_all(&buf[..n])\n     }\n \n-    /// Write the result of passing n through `int::to_str_bytes`.\n+    /// Write the result of passing n through `isize::to_str_bytes`.\n     #[inline]\n-    fn write_int(&mut self, n: int) -> IoResult<()> {\n+    fn write_int(&mut self, n: isize) -> IoResult<()> {\n         write!(self, \"{}\", n)\n     }\n \n-    /// Write the result of passing n through `uint::to_str_bytes`.\n+    /// Write the result of passing n through `usize::to_str_bytes`.\n     #[inline]\n-    fn write_uint(&mut self, n: uint) -> IoResult<()> {\n+    fn write_uint(&mut self, n: usize) -> IoResult<()> {\n         write!(self, \"{}\", n)\n     }\n \n-    /// Write a little-endian uint (number of bytes depends on system).\n+    /// Write a little-endian usize (number of bytes depends on system).\n     #[inline]\n-    fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n+    fn write_le_uint(&mut self, n: usize) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, usize::BYTES as usize, |v| self.write_all(v))\n     }\n \n-    /// Write a little-endian int (number of bytes depends on system).\n+    /// Write a little-endian isize (number of bytes depends on system).\n     #[inline]\n-    fn write_le_int(&mut self, n: int) -> IoResult<()> {\n+    fn write_le_int(&mut self, n: isize) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, isize::BYTES as usize, |v| self.write_all(v))\n     }\n \n-    /// Write a big-endian uint (number of bytes depends on system).\n+    /// Write a big-endian usize (number of bytes depends on system).\n     #[inline]\n-    fn write_be_uint(&mut self, n: uint) -> IoResult<()> {\n+    fn write_be_uint(&mut self, n: usize) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, usize::BYTES as usize, |v| self.write_all(v))\n     }\n \n-    /// Write a big-endian int (number of bytes depends on system).\n+    /// Write a big-endian isize (number of bytes depends on system).\n     #[inline]\n-    fn write_be_int(&mut self, n: int) -> IoResult<()> {\n+    fn write_be_int(&mut self, n: isize) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, isize::BYTES as usize, |v| self.write_all(v))\n     }\n \n@@ -1409,7 +1409,7 @@ pub trait Buffer: Reader {\n \n     /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n     /// so they should no longer be returned in calls to `read`.\n-    fn consume(&mut self, amt: uint);\n+    fn consume(&mut self, amt: usize);\n \n     /// Reads the next line of input, interpreted as a sequence of UTF-8\n     /// encoded Unicode codepoints. If a newline is encountered, then the\n@@ -1588,9 +1588,7 @@ pub trait Seek {\n /// connections.\n ///\n /// Doing so produces some sort of Acceptor.\n-pub trait Listener<T, A: Acceptor<T>>\n-    : PhantomFn<T,T> // FIXME should be an assoc type anyhow\n-{\n+pub trait Listener<A: Acceptor> {\n     /// Spin up the listener and start queuing incoming connections\n     ///\n     /// # Error\n@@ -1601,13 +1599,16 @@ pub trait Listener<T, A: Acceptor<T>>\n }\n \n /// An acceptor is a value that presents incoming connections\n-pub trait Acceptor<T> {\n+pub trait Acceptor {\n+    /// Type of connection that is accepted by this acceptor.\n+    type Connection;\n+\n     /// Wait for and accept an incoming connection\n     ///\n     /// # Error\n     ///\n     /// Returns `Err` if an I/O error is encountered.\n-    fn accept(&mut self) -> IoResult<T>;\n+    fn accept(&mut self) -> IoResult<Self::Connection>;\n \n     /// Create an iterator over incoming connection attempts.\n     ///\n@@ -1628,11 +1629,10 @@ pub struct IncomingConnections<'a, A: ?Sized +'a> {\n     inc: &'a mut A,\n }\n \n-#[old_impl_check]\n-impl<'a, T, A: ?Sized + Acceptor<T>> Iterator for IncomingConnections<'a, A> {\n-    type Item = IoResult<T>;\n+impl<'a, A: ?Sized + Acceptor> Iterator for IncomingConnections<'a, A> {\n+    type Item = IoResult<A::Connection>;\n \n-    fn next(&mut self) -> Option<IoResult<T>> {\n+    fn next(&mut self) -> Option<IoResult<A::Connection>> {\n         Some(self.inc.accept())\n     }\n }\n@@ -1870,8 +1870,8 @@ mod tests {\n \n     #[derive(Clone, PartialEq, Debug)]\n     enum BadReaderBehavior {\n-        GoodBehavior(uint),\n-        BadBehavior(uint)\n+        GoodBehavior(usize),\n+        BadBehavior(usize)\n     }\n \n     struct BadReader<T> {\n@@ -1886,7 +1886,7 @@ mod tests {\n     }\n \n     impl<T: Reader> Reader for BadReader<T> {\n-        fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n             let BadReader { ref mut behavior, ref mut r } = *self;\n             loop {\n                 if behavior.is_empty() {"}, {"sha": "0413a89ac4f29e9e25054c53a964a3674223d159", "filename": "src/libstd/old_io/net/addrinfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -63,19 +63,19 @@ pub enum Protocol {\n /// `man -s 3 getaddrinfo`\n #[derive(Copy, Debug)]\n pub struct Hint {\n-    pub family: uint,\n+    pub family: usize,\n     pub socktype: Option<SocketType>,\n     pub protocol: Option<Protocol>,\n-    pub flags: uint,\n+    pub flags: usize,\n }\n \n #[derive(Copy, Debug)]\n pub struct Info {\n     pub address: SocketAddr,\n-    pub family: uint,\n+    pub family: usize,\n     pub socktype: Option<SocketType>,\n     pub protocol: Option<Protocol>,\n-    pub flags: uint,\n+    pub flags: usize,\n }\n \n /// Easy name resolution. Given a hostname, returns the list of IP addresses for"}, {"sha": "ba3578f742596f5d422c17207e7c707cd690be31", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -82,7 +82,7 @@ impl fmt::Display for SocketAddr {\n struct Parser<'a> {\n     // parsing as ASCII, so can use byte array\n     s: &'a [u8],\n-    pos: uint,\n+    pos: usize,\n }\n \n impl<'a> Parser<'a> {\n@@ -256,7 +256,7 @@ impl<'a> Parser<'a> {\n             Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n \n-        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: uint) -> (uint, bool) {\n+        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: usize) -> (usize, bool) {\n             let mut i = 0;\n             while i < limit {\n                 if i < limit - 1 {"}, {"sha": "3a071e832af64baa01133cc934eb18ae775becd2", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -150,7 +150,7 @@ impl Clone for UnixStream {\n }\n \n impl Reader for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.inner.read(buf)\n     }\n }\n@@ -202,7 +202,7 @@ impl UnixListener {\n     }\n }\n \n-impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n+impl Listener<UnixAcceptor> for UnixListener {\n     fn listen(self) -> IoResult<UnixAcceptor> {\n         self.inner.listen()\n             .map(|inner| UnixAcceptor { inner: inner })\n@@ -250,7 +250,8 @@ impl UnixAcceptor {\n     }\n }\n \n-impl Acceptor<UnixStream> for UnixAcceptor {\n+impl Acceptor for UnixAcceptor {\n+    type Connection = UnixStream;\n     fn accept(&mut self) -> IoResult<UnixStream> {\n         self.inner.accept().map(|s| {\n             UnixStream { inner: s }"}, {"sha": "7fc460c16efca2454a61b7e48bb5d606c62741cf", "filename": "src/libstd/old_io/net/tcp.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -122,7 +122,7 @@ impl TcpStream {\n     /// this connection. Otherwise, the keepalive timeout will be set to the\n     /// specified time, in seconds.\n     #[unstable(feature = \"io\")]\n-    pub fn set_keepalive(&mut self, delay_in_seconds: Option<uint>) -> IoResult<()> {\n+    pub fn set_keepalive(&mut self, delay_in_seconds: Option<usize>) -> IoResult<()> {\n         self.inner.set_keepalive(delay_in_seconds)\n     }\n \n@@ -257,7 +257,7 @@ impl Clone for TcpStream {\n }\n \n impl Reader for TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.inner.read(buf)\n     }\n }\n@@ -338,7 +338,7 @@ impl TcpListener {\n     }\n }\n \n-impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n+impl Listener<TcpAcceptor> for TcpListener {\n     fn listen(self) -> IoResult<TcpAcceptor> {\n         self.inner.listen(128).map(|a| TcpAcceptor { inner: a })\n     }\n@@ -453,7 +453,8 @@ impl TcpAcceptor {\n     }\n }\n \n-impl Acceptor<TcpStream> for TcpAcceptor {\n+impl Acceptor for TcpAcceptor {\n+    type Connection = TcpStream;\n     fn accept(&mut self) -> IoResult<TcpStream> {\n         self.inner.accept().map(TcpStream::new)\n     }\n@@ -789,12 +790,12 @@ mod test {\n     #[test]\n     fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         let addr = next_test_ip4();\n-        static MAX: int = 10;\n+        static MAX: isize = 10;\n         let acceptor = TcpListener::bind(addr).listen();\n \n         let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n-            for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n+            for (i, stream) in acceptor.incoming().enumerate().take(MAX as usize) {\n                 // Start another task to handle the connection\n                 let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n@@ -808,7 +809,7 @@ mod test {\n \n         connect(0, addr);\n \n-        fn connect(i: int, addr: SocketAddr) {\n+        fn connect(i: isize, addr: SocketAddr) {\n             if i == MAX { return }\n \n             let _t = thread::spawn(move|| {\n@@ -825,12 +826,12 @@ mod test {\n     #[test]\n     fn multiple_connect_interleaved_greedy_schedule_ip6() {\n         let addr = next_test_ip6();\n-        static MAX: int = 10;\n+        static MAX: isize = 10;\n         let acceptor = TcpListener::bind(addr).listen();\n \n         let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n-            for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n+            for (i, stream) in acceptor.incoming().enumerate().take(MAX as usize) {\n                 // Start another task to handle the connection\n                 let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n@@ -844,7 +845,7 @@ mod test {\n \n         connect(0, addr);\n \n-        fn connect(i: int, addr: SocketAddr) {\n+        fn connect(i: isize, addr: SocketAddr) {\n             if i == MAX { return }\n \n             let _t = thread::spawn(move|| {\n@@ -860,13 +861,13 @@ mod test {\n \n     #[test]\n     fn multiple_connect_interleaved_lazy_schedule_ip4() {\n-        static MAX: int = 10;\n+        static MAX: isize = 10;\n         let addr = next_test_ip4();\n         let acceptor = TcpListener::bind(addr).listen();\n \n         let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n-            for stream in acceptor.incoming().take(MAX as uint) {\n+            for stream in acceptor.incoming().take(MAX as usize) {\n                 // Start another task to handle the connection\n                 let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n@@ -880,7 +881,7 @@ mod test {\n \n         connect(0, addr);\n \n-        fn connect(i: int, addr: SocketAddr) {\n+        fn connect(i: isize, addr: SocketAddr) {\n             if i == MAX { return }\n \n             let _t = thread::spawn(move|| {\n@@ -896,13 +897,13 @@ mod test {\n \n     #[test]\n     fn multiple_connect_interleaved_lazy_schedule_ip6() {\n-        static MAX: int = 10;\n+        static MAX: isize = 10;\n         let addr = next_test_ip6();\n         let acceptor = TcpListener::bind(addr).listen();\n \n         let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n-            for stream in acceptor.incoming().take(MAX as uint) {\n+            for stream in acceptor.incoming().take(MAX as usize) {\n                 // Start another task to handle the connection\n                 let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n@@ -916,7 +917,7 @@ mod test {\n \n         connect(0, addr);\n \n-        fn connect(i: int, addr: SocketAddr) {\n+        fn connect(i: isize, addr: SocketAddr) {\n             if i == MAX { return }\n \n             let _t = thread::spawn(move|| {"}, {"sha": "196447d71efbf8ff598cf6fa4bb564365aa790b1", "filename": "src/libstd/old_io/net/udp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -73,7 +73,7 @@ impl UdpSocket {\n \n     /// Receives data from the socket. On success, returns the number of bytes\n     /// read and the address from whence the data came.\n-    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> {\n+    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(usize, SocketAddr)> {\n         self.inner.recv_from(buf)\n     }\n \n@@ -113,13 +113,13 @@ impl UdpSocket {\n \n     /// Sets the multicast TTL\n     #[unstable(feature = \"io\")]\n-    pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> {\n+    pub fn set_multicast_ttl(&mut self, ttl: isize) -> IoResult<()> {\n         self.inner.multicast_time_to_live(ttl)\n     }\n \n     /// Sets this socket's TTL\n     #[unstable(feature = \"io\")]\n-    pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> {\n+    pub fn set_ttl(&mut self, ttl: isize) -> IoResult<()> {\n         self.inner.time_to_live(ttl)\n     }\n "}, {"sha": "26f2460047982eb3223604cfc173e40eb1e522e8", "filename": "src/libstd/old_io/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fpipe.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -100,7 +100,7 @@ impl Clone for PipeStream {\n }\n \n impl Reader for PipeStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.inner.read(buf)\n     }\n }"}, {"sha": "06940bf6860a409e8ebe3cf6a8ef865faa46eab7", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -41,16 +41,16 @@ use thread;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n-#[cfg(windows)] pub const PleaseExitSignal: int = 15;\n+#[cfg(windows)] pub const PleaseExitSignal: isize = 15;\n /// Signal a process to exit immediately, forcibly killing it. Corresponds to\n /// SIGKILL on unix platforms.\n-#[cfg(windows)] pub const MustDieSignal: int = 9;\n+#[cfg(windows)] pub const MustDieSignal: isize = 9;\n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n-#[cfg(not(windows))] pub const PleaseExitSignal: int = libc::SIGTERM as int;\n+#[cfg(not(windows))] pub const PleaseExitSignal: isize = libc::SIGTERM as isize;\n /// Signal a process to exit immediately, forcibly killing it. Corresponds to\n /// SIGKILL on unix platforms.\n-#[cfg(not(windows))] pub const MustDieSignal: int = libc::SIGKILL as int;\n+#[cfg(not(windows))] pub const MustDieSignal: isize = libc::SIGKILL as isize;\n \n /// Representation of a running or exited child process.\n ///\n@@ -60,7 +60,7 @@ use thread;\n ///\n /// # Examples\n ///\n-/// ```should_fail\n+/// ```should_panic\n /// # #![feature(old_io)]\n /// use std::old_io::*;\n ///\n@@ -80,7 +80,7 @@ pub struct Process {\n     exit_code: Option<ProcessExit>,\n \n     /// Manually delivered signal\n-    exit_signal: Option<int>,\n+    exit_signal: Option<isize>,\n \n     /// Deadline after which wait() will return\n     deadline: u64,\n@@ -186,8 +186,8 @@ pub struct Command {\n     stdin: StdioContainer,\n     stdout: StdioContainer,\n     stderr: StdioContainer,\n-    uid: Option<uint>,\n-    gid: Option<uint>,\n+    uid: Option<usize>,\n+    gid: Option<usize>,\n     detach: bool,\n }\n \n@@ -321,14 +321,14 @@ impl Command {\n     /// the child process. Setting this value on windows will cause the spawn to\n     /// fail. Failure in the `setuid` call on unix will also cause the spawn to\n     /// fail.\n-    pub fn uid<'a>(&'a mut self, id: uint) -> &'a mut Command {\n+    pub fn uid<'a>(&'a mut self, id: usize) -> &'a mut Command {\n         self.uid = Some(id);\n         self\n     }\n \n     /// Similar to `uid`, but sets the group id of the child process. This has\n     /// the same semantics as the `uid` field.\n-    pub fn gid<'a>(&'a mut self, id: uint) -> &'a mut Command {\n+    pub fn gid<'a>(&'a mut self, id: usize) -> &'a mut Command {\n         self.gid = Some(id);\n         self\n     }\n@@ -458,10 +458,10 @@ impl sys::process::ProcessConfig<EnvKey, CString> for Command {\n     fn cwd(&self) -> Option<&CString> {\n         self.cwd.as_ref()\n     }\n-    fn uid(&self) -> Option<uint> {\n+    fn uid(&self) -> Option<usize> {\n         self.uid.clone()\n     }\n-    fn gid(&self) -> Option<uint> {\n+    fn gid(&self) -> Option<usize> {\n         self.gid.clone()\n     }\n     fn detach(&self) -> bool {\n@@ -507,10 +507,10 @@ pub enum StdioContainer {\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub enum ProcessExit {\n     /// Normal termination with an exit status.\n-    ExitStatus(int),\n+    ExitStatus(isize),\n \n     /// Termination by signal, with the signal number.\n-    ExitSignal(int),\n+    ExitSignal(isize),\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -533,7 +533,7 @@ impl ProcessExit {\n \n     /// Checks whether this ProcessExit matches the given exit status.\n     /// Termination by signal will never match an exit code.\n-    pub fn matches_exit_status(&self, wanted: int) -> bool {\n+    pub fn matches_exit_status(&self, wanted: isize) -> bool {\n         *self == ExitStatus(wanted)\n     }\n }\n@@ -549,7 +549,7 @@ impl Process {\n     /// process. Note, though, that on some platforms signals will continue to\n     /// be successfully delivered if the child has exited, but not yet been\n     /// reaped.\n-    pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> {\n+    pub fn kill(id: libc::pid_t, signal: isize) -> IoResult<()> {\n         unsafe { ProcessImp::killpid(id, signal) }\n     }\n \n@@ -571,7 +571,7 @@ impl Process {\n     /// # Errors\n     ///\n     /// If the signal delivery fails, the corresponding error is returned.\n-    pub fn signal(&mut self, signal: int) -> IoResult<()> {\n+    pub fn signal(&mut self, signal: isize) -> IoResult<()> {\n         #[cfg(unix)] fn collect_status(p: &mut Process) {\n             // On Linux (and possibly other unices), a process that has exited will\n             // continue to accept signals because it is \"defunct\". The delivery of\n@@ -888,8 +888,8 @@ mod tests {\n         use libc;\n         let mut p = Command::new(\"/bin/sh\")\n                             .arg(\"-c\").arg(\"true\")\n-                            .uid(unsafe { libc::getuid() as uint })\n-                            .gid(unsafe { libc::getgid() as uint })\n+                            .uid(unsafe { libc::getuid() as usize })\n+                            .gid(unsafe { libc::getgid() as usize })\n                             .spawn().unwrap();\n         assert!(p.wait().unwrap().success());\n     }"}, {"sha": "e1037f26b7fcf575bf61f50a0905745125ceb6da", "filename": "src/libstd/old_io/result.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fresult.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -35,7 +35,7 @@ impl<W: Writer> Writer for IoResult<W> {\n }\n \n impl<R: Reader> Reader for IoResult<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         match *self {\n             Ok(ref mut reader) => reader.read(buf),\n             Err(ref e) => Err(e.clone()),\n@@ -58,7 +58,7 @@ impl<S: Seek> Seek for IoResult<S> {\n     }\n }\n \n-impl<T, A: Acceptor<T>, L: Listener<T, A>> Listener<T, A> for IoResult<L> {\n+impl<A: Acceptor, L: Listener<A>> Listener<A> for IoResult<L> {\n     fn listen(self) -> IoResult<A> {\n         match self {\n             Ok(listener) => listener.listen(),\n@@ -67,8 +67,9 @@ impl<T, A: Acceptor<T>, L: Listener<T, A>> Listener<T, A> for IoResult<L> {\n     }\n }\n \n-impl<T, A: Acceptor<T>> Acceptor<T> for IoResult<A> {\n-    fn accept(&mut self) -> IoResult<T> {\n+impl<A: Acceptor> Acceptor for IoResult<A> {\n+    type Connection = A::Connection;\n+    fn accept(&mut self) -> IoResult<A::Connection> {\n         match *self {\n             Ok(ref mut acceptor) => acceptor.accept(),\n             Err(ref e) => Err(e.clone()),"}, {"sha": "b4924c7b78b753112d6e58ff59b9b8872fe4c28c", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -182,31 +182,31 @@ impl StdinReader {\n }\n \n impl Reader for StdinReader {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.inner.lock().unwrap().0.read(buf)\n     }\n \n     // We have to manually delegate all of these because the default impls call\n     // read more than once and we don't want those calls to interleave (or\n     // incur the costs of repeated locking).\n \n-    fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read_at_least(&mut self, min: usize, buf: &mut [u8]) -> IoResult<usize> {\n         self.inner.lock().unwrap().0.read_at_least(min, buf)\n     }\n \n-    fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n+    fn push_at_least(&mut self, min: usize, len: usize, buf: &mut Vec<u8>) -> IoResult<usize> {\n         self.inner.lock().unwrap().0.push_at_least(min, len, buf)\n     }\n \n     fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n         self.inner.lock().unwrap().0.read_to_end()\n     }\n \n-    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n+    fn read_le_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n         self.inner.lock().unwrap().0.read_le_uint_n(nbytes)\n     }\n \n-    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n+    fn read_be_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n         self.inner.lock().unwrap().0.read_be_uint_n(nbytes)\n     }\n }\n@@ -410,16 +410,16 @@ impl StdReader {\n }\n \n impl Reader for StdReader {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         let ret = match self.inner {\n             TTY(ref mut tty) => {\n                 // Flush the task-local stdout so that weird issues like a\n                 // print!'d prompt not being shown until after the user hits\n                 // enter.\n                 flush();\n-                tty.read(buf).map(|i| i as uint)\n+                tty.read(buf).map(|i| i as usize)\n             },\n-            File(ref mut file) => file.read(buf).map(|i| i as uint),\n+            File(ref mut file) => file.read(buf).map(|i| i as usize),\n         };\n         match ret {\n             // When reading a piped stdin, libuv will return 0-length reads when\n@@ -452,7 +452,7 @@ impl StdWriter {\n     ///\n     /// This function will return an error if the output stream is not actually\n     /// connected to a TTY instance, or if querying the TTY instance fails.\n-    pub fn winsize(&mut self) -> IoResult<(int, int)> {\n+    pub fn winsize(&mut self) -> IoResult<(isize, isize)> {\n         match self.inner {\n             TTY(ref mut tty) => {\n                 tty.get_winsize()"}, {"sha": "bf9b79ce65aacc08e204a3f45a97a55db571c429", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -89,7 +89,7 @@ const NUM_RETRIES: u32 = 1 << 31;\n // be enough to dissuade an attacker from trying to preemptively create names\n // of that length, but not so huge that we unnecessarily drain the random number\n // generator of entropy.\n-const NUM_RAND_CHARS: uint = 12;\n+const NUM_RAND_CHARS: usize = 12;\n \n impl TempDir {\n     /// Attempts to make a temporary directory inside of `tmpdir` whose name"}, {"sha": "604099f117884a5126a821af919607d57e2269e3", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -22,7 +22,7 @@ use slice::bytes::MutableByteVector;\n #[deprecated(since = \"1.0.0\", reason = \"use std::io::Take\")]\n #[unstable(feature = \"old_io\")]\n pub struct LimitReader<R> {\n-    limit: uint,\n+    limit: usize,\n     inner: R\n }\n \n@@ -32,7 +32,7 @@ impl<R: Reader> LimitReader<R> {\n     /// Creates a new `LimitReader`\n     #[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n     #[unstable(feature = \"old_io\")]\n-    pub fn new(r: R, limit: uint) -> LimitReader<R> {\n+    pub fn new(r: R, limit: usize) -> LimitReader<R> {\n         LimitReader { limit: limit, inner: r }\n     }\n \n@@ -46,13 +46,13 @@ impl<R: Reader> LimitReader<R> {\n     ///\n     /// The reader may reach EOF after reading fewer bytes than indicated by\n     /// this method if the underlying reader reaches EOF.\n-    pub fn limit(&self) -> uint { self.limit }\n+    pub fn limit(&self) -> usize { self.limit }\n }\n \n #[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n #[unstable(feature = \"old_io\")]\n impl<R: Reader> Reader for LimitReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n         if self.limit == 0 {\n             return Err(old_io::standard_error(old_io::EndOfFile));\n         }\n@@ -80,7 +80,7 @@ impl<R: Buffer> Buffer for LimitReader<R> {\n         }\n     }\n \n-    fn consume(&mut self, amt: uint) {\n+    fn consume(&mut self, amt: usize) {\n         // Don't let callers reset the limit by passing an overlarge value\n         let amt = cmp::min(amt, self.limit);\n         self.limit -= amt;\n@@ -112,7 +112,7 @@ pub struct ZeroReader;\n #[unstable(feature = \"old_io\")]\n impl Reader for ZeroReader {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n         buf.set_memory(0);\n         Ok(buf.len())\n     }\n@@ -126,7 +126,7 @@ impl Buffer for ZeroReader {\n         Ok(&DATA)\n     }\n \n-    fn consume(&mut self, _amt: uint) {}\n+    fn consume(&mut self, _amt: usize) {}\n }\n \n /// A `Reader` which is always at EOF, like /dev/null.\n@@ -139,7 +139,7 @@ pub struct NullReader;\n #[unstable(feature = \"old_io\")]\n impl Reader for NullReader {\n     #[inline]\n-    fn read(&mut self, _buf: &mut [u8]) -> old_io::IoResult<uint> {\n+    fn read(&mut self, _buf: &mut [u8]) -> old_io::IoResult<usize> {\n         Err(old_io::standard_error(old_io::EndOfFile))\n     }\n }\n@@ -150,7 +150,7 @@ impl Buffer for NullReader {\n     fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n         Err(old_io::standard_error(old_io::EndOfFile))\n     }\n-    fn consume(&mut self, _amt: uint) {}\n+    fn consume(&mut self, _amt: usize) {}\n }\n \n /// A `Writer` which multiplexes writes to a set of `Writer`s.\n@@ -216,7 +216,7 @@ impl<R: Reader, I: Iterator<Item=R>> ChainedReader<I, R> {\n #[deprecated(since = \"1.0.0\", reason = \"use std::io::Chain instead\")]\n #[unstable(feature = \"old_io\")]\n impl<R: Reader, I: Iterator<Item=R>> Reader for ChainedReader<I, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n         loop {\n             let err = match self.cur_reader {\n                 Some(ref mut r) => {\n@@ -269,7 +269,7 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n #[deprecated(since = \"1.0.0\", reason = \"use std::io::Tee instead\")]\n #[unstable(feature = \"old_io\")]\n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n         self.reader.read(buf).and_then(|len| {\n             self.writer.write_all(&mut buf[..len]).map(|()| len)\n         })\n@@ -307,7 +307,7 @@ impl<T: Iterator<Item=u8>> IterReader<T> {\n \n impl<T: Iterator<Item=u8>> Reader for IterReader<T> {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n         let mut len = 0;\n         for (slot, elt) in buf.iter_mut().zip(self.iter.by_ref()) {\n             *slot = elt;\n@@ -392,8 +392,8 @@ mod test {\n \n     #[test]\n     fn test_multi_writer() {\n-        static mut writes: uint = 0;\n-        static mut flushes: uint = 0;\n+        static mut writes: usize = 0;\n+        static mut flushes: usize = 0;\n \n         struct TestWriter;\n         impl Writer for TestWriter {"}, {"sha": "67bfe2bd77026f6c0bb725187ceb97fb7735b37d", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -37,7 +37,7 @@ pub type StrComponents<'a> =\n #[derive(Clone)]\n pub struct Path {\n     repr: Vec<u8>, // assumed to never be empty or contain NULs\n-    sepidx: Option<uint> // index of the final separator in repr\n+    sepidx: Option<usize> // index of the final separator in repr\n }\n \n /// The standard path separator character"}, {"sha": "869a8127301730fbf0c599653c9355781657f92a", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -81,7 +81,7 @@ pub type Components<'a> =\n pub struct Path {\n     repr: String, // assumed to never be empty\n     prefix: Option<PathPrefix>,\n-    sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr\n+    sepidx: Option<usize> // index of the final separator in the non-prefix portion of repr\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -749,7 +749,7 @@ impl Path {\n                     if prefix.is_some() && comps.is_empty() {\n                         match prefix.unwrap() {\n                             DiskPrefix => {\n-                                let len = prefix_len(prefix) + is_abs as uint;\n+                                let len = prefix_len(prefix) + is_abs as usize;\n                                 let mut s = String::from_str(&s[..len]);\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n@@ -764,7 +764,7 @@ impl Path {\n                                 Some(s)\n                             }\n                             VerbatimDiskPrefix => {\n-                                let len = prefix_len(prefix) + is_abs as uint;\n+                                let len = prefix_len(prefix) + is_abs as usize;\n                                 let mut s = String::from_str(&s[..len]);\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n@@ -838,7 +838,7 @@ impl Path {\n         self.sepidx = idx.and_then(|x| if x < prefixlen { None } else { Some(x) });\n     }\n \n-    fn prefix_len(&self) -> uint {\n+    fn prefix_len(&self) -> usize {\n         prefix_len(self.prefix)\n     }\n \n@@ -847,7 +847,7 @@ impl Path {\n     // end is the length of the string, normally, or the index of the final character if it is\n     // a non-semantic trailing separator in a verbatim string.\n     // If the prefix is considered the separator, before and after are the same.\n-    fn sepidx_or_prefix_len(&self) -> Option<(uint,uint,uint)> {\n+    fn sepidx_or_prefix_len(&self) -> Option<(usize,usize,usize)> {\n         match self.sepidx {\n             None => match self.prefix_len() { 0 => None, x => Some((x,x,self.repr.len())) },\n             Some(x) => {\n@@ -973,16 +973,16 @@ pub fn is_sep_byte_verbatim(u: &u8) -> bool {\n /// Prefix types for Path\n #[derive(Copy, PartialEq, Clone, Debug)]\n pub enum PathPrefix {\n-    /// Prefix `\\\\?\\`, uint is the length of the following component\n-    VerbatimPrefix(uint),\n+    /// Prefix `\\\\?\\`, usize is the length of the following component\n+    VerbatimPrefix(usize),\n     /// Prefix `\\\\?\\UNC\\`, uints are the lengths of the UNC components\n-    VerbatimUNCPrefix(uint, uint),\n+    VerbatimUNCPrefix(usize, usize),\n     /// Prefix `\\\\?\\C:\\` (for any alphabetic character)\n     VerbatimDiskPrefix,\n-    /// Prefix `\\\\.\\`, uint is the length of the following component\n-    DeviceNSPrefix(uint),\n+    /// Prefix `\\\\.\\`, usize is the length of the following component\n+    DeviceNSPrefix(usize),\n     /// UNC prefix `\\\\server\\share`, uints are the lengths of the server/share\n-    UNCPrefix(uint, uint),\n+    UNCPrefix(usize, usize),\n     /// Prefix `C:` for any alphabetic character\n     DiskPrefix\n }\n@@ -1037,7 +1037,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n     }\n     return None;\n \n-    fn parse_two_comps(mut path: &str, f: fn(char) -> bool) -> Option<(uint, uint)> {\n+    fn parse_two_comps(mut path: &str, f: fn(char) -> bool) -> Option<(usize, usize)> {\n         let idx_a = match path.find(f) {\n             None => return None,\n             Some(x) => x\n@@ -1107,7 +1107,7 @@ fn prefix_is_verbatim(p: Option<PathPrefix>) -> bool {\n     }\n }\n \n-fn prefix_len(p: Option<PathPrefix>) -> uint {\n+fn prefix_len(p: Option<PathPrefix>) -> usize {\n     match p {\n         None => 0,\n         Some(VerbatimPrefix(x)) => 4 + x,"}, {"sha": "2e8521cc94bd77cfb9079c04bcc62ffc0034fd77", "filename": "src/libstd/os.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -100,17 +100,17 @@ fn path2old(path: &path::Path) -> Path {\n }\n \n /// Get the number of cores available\n-pub fn num_cpus() -> uint {\n+pub fn num_cpus() -> usize {\n     unsafe {\n-        return rust_get_num_cpus() as uint;\n+        return rust_get_num_cpus() as usize;\n     }\n \n     extern {\n         fn rust_get_num_cpus() -> libc::uintptr_t;\n     }\n }\n \n-pub const TMPBUF_SZ : uint = 1000;\n+pub const TMPBUF_SZ : usize = 1000;\n \n /// Returns the current working directory as a `Path`.\n ///\n@@ -592,20 +592,20 @@ pub fn last_os_error() -> String {\n /// Note that this is not synchronized against modifications of other threads.\n #[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_exit_status\")]\n #[unstable(feature = \"os\")]\n-pub fn set_exit_status(code: int) {\n+pub fn set_exit_status(code: isize) {\n     env::set_exit_status(code as i32)\n }\n \n /// Fetches the process's current exit code. This defaults to 0 and can change\n /// by calling `set_exit_status`.\n #[deprecated(since = \"1.0.0\", reason = \"renamed to env::get_exit_status\")]\n #[unstable(feature = \"os\")]\n-pub fn get_exit_status() -> int {\n+pub fn get_exit_status() -> isize {\n     env::get_exit_status() as isize\n }\n \n #[cfg(target_os = \"macos\")]\n-unsafe fn load_argc_and_argv(argc: int,\n+unsafe fn load_argc_and_argv(argc: isize,\n                              argv: *const *const c_char) -> Vec<Vec<u8>> {\n     use ffi::CStr;\n \n@@ -620,7 +620,7 @@ unsafe fn load_argc_and_argv(argc: int,\n #[cfg(target_os = \"macos\")]\n fn real_args_as_bytes() -> Vec<Vec<u8>> {\n     unsafe {\n-        let (argc, argv) = (*_NSGetArgc() as int,\n+        let (argc, argv) = (*_NSGetArgc() as isize,\n                             *_NSGetArgv() as *const *const c_char);\n         load_argc_and_argv(argc, argv)\n     }\n@@ -670,7 +670,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n         let info = objc_msgSend(klass, processInfoSel);\n         let args = objc_msgSend(info, argumentsSel);\n \n-        let cnt: int = mem::transmute(objc_msgSend(args, countSel));\n+        let cnt: isize = mem::transmute(objc_msgSend(args, countSel));\n         for i in 0..cnt {\n             let tmp = objc_msgSend(args, objectAtSel, i);\n             let utf_c_str: *const libc::c_char =\n@@ -711,11 +711,11 @@ fn real_args() -> Vec<String> {\n     let lpCmdLine = unsafe { GetCommandLineW() };\n     let szArgList = unsafe { CommandLineToArgvW(lpCmdLine, lpArgCount) };\n \n-    let args: Vec<_> = (0..nArgs as uint).map(|i| unsafe {\n+    let args: Vec<_> = (0..nArgs as usize).map(|i| unsafe {\n         // Determine the length of this argument.\n-        let ptr = *szArgList.offset(i as int);\n+        let ptr = *szArgList.offset(i as isize);\n         let mut len = 0;\n-        while *ptr.offset(len as int) != 0 { len += 1; }\n+        while *ptr.offset(len as isize) != 0 { len += 1; }\n \n         // Push it onto the list.\n         let ptr = ptr as *const u16;\n@@ -796,7 +796,7 @@ extern {\n /// Returns the page size of the current architecture in bytes.\n #[deprecated(since = \"1.0.0\", reason = \"renamed to env::page_size\")]\n #[unstable(feature = \"os\")]\n-pub fn page_size() -> uint {\n+pub fn page_size() -> usize {\n     sys::os::page_size()\n }\n \n@@ -810,7 +810,7 @@ pub fn page_size() -> uint {\n /// let it leave scope by accident if you want it to stick around.\n pub struct MemoryMap {\n     data: *mut u8,\n-    len: uint,\n+    len: usize,\n     kind: MemoryMapKind,\n }\n \n@@ -846,9 +846,9 @@ pub enum MapOption {\n     /// Create a memory mapping for a file with a given fd.\n     #[cfg(not(windows))]\n     MapFd(c_int),\n-    /// When using `MapFd`, the start of the map is `uint` bytes from the start\n+    /// When using `MapFd`, the start of the map is `usize` bytes from the start\n     /// of the file.\n-    MapOffset(uint),\n+    MapOffset(usize),\n     /// On POSIX, this can be used to specify the default flags passed to\n     /// `mmap`. By default it uses `MAP_PRIVATE` and, if not using `MapFd`,\n     /// `MAP_ANON`. This will override both of those. This is platform-specific\n@@ -880,7 +880,7 @@ pub enum MapError {\n     /// Not all platforms obey this, but this wrapper does.\n     ErrZeroLength,\n     /// Unrecognized error. The inner value is the unrecognized errno.\n-    ErrUnknown(int),\n+    ErrUnknown(isize),\n     /// # The following are Windows-specific\n     ///\n     /// Unsupported combination of protection flags\n@@ -940,7 +940,7 @@ impl Error for MapError {\n }\n \n // Round up `from` to be divisible by `to`\n-fn round_up(from: uint, to: uint) -> uint {\n+fn round_up(from: usize, to: usize) -> usize {\n     let r = if from % to == 0 {\n         from\n     } else {\n@@ -958,7 +958,7 @@ impl MemoryMap {\n     /// Create a new mapping with the given `options`, at least `min_len` bytes\n     /// long. `min_len` must be greater than zero; see the note on\n     /// `ErrZeroLength`.\n-    pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n+    pub fn new(min_len: usize, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n         use libc::off_t;\n \n         if min_len == 0 {\n@@ -1002,7 +1002,7 @@ impl MemoryMap {\n                 libc::EINVAL => ErrUnaligned,\n                 libc::ENODEV => ErrNoMapSupport,\n                 libc::ENOMEM => ErrNoMem,\n-                code => ErrUnknown(code as int)\n+                code => ErrUnknown(code as isize)\n             })\n         } else {\n             Ok(MemoryMap {\n@@ -1019,7 +1019,7 @@ impl MemoryMap {\n \n     /// Granularity that the offset or address must be for `MapOffset` and\n     /// `MapAddr` respectively.\n-    pub fn granularity() -> uint {\n+    pub fn granularity() -> usize {\n         env::page_size()\n     }\n }\n@@ -1040,15 +1040,15 @@ impl Drop for MemoryMap {\n #[cfg(windows)]\n impl MemoryMap {\n     /// Create a new mapping with the given `options`, at least `min_len` bytes long.\n-    pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n+    pub fn new(min_len: usize, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n         use libc::types::os::arch::extra::{LPVOID, DWORD, SIZE_T, HANDLE};\n \n         let mut lpAddress: LPVOID = ptr::null_mut();\n         let mut readable = false;\n         let mut writable = false;\n         let mut executable = false;\n         let mut handle: HANDLE = libc::INVALID_HANDLE_VALUE;\n-        let mut offset: uint = 0;\n+        let mut offset: usize = 0;\n         let len = round_up(min_len, env::page_size());\n \n         for &o in options {\n@@ -1083,7 +1083,7 @@ impl MemoryMap {\n                                    libc::MEM_COMMIT | libc::MEM_RESERVE,\n                                    flProtect)\n             };\n-            match r as uint {\n+            match r as usize {\n                 0 => Err(ErrVirtualAlloc(errno())),\n                 _ => Ok(MemoryMap {\n                    data: r as *mut u8,\n@@ -1119,7 +1119,7 @@ impl MemoryMap {\n                                             ((len as u64) >> 32) as DWORD,\n                                             (offset & 0xffff_ffff) as DWORD,\n                                             0);\n-                match r as uint {\n+                match r as usize {\n                     0 => Err(ErrMapViewOfFile(errno())),\n                     _ => Ok(MemoryMap {\n                        data: r as *mut u8,\n@@ -1133,13 +1133,13 @@ impl MemoryMap {\n \n     /// Granularity of MapAddr() and MapOffset() parameter values.\n     /// This may be greater than the value returned by page_size().\n-    pub fn granularity() -> uint {\n+    pub fn granularity() -> usize {\n         use mem;\n         unsafe {\n             let mut info = mem::zeroed();\n             libc::GetSystemInfo(&mut info);\n \n-            return info.dwAllocationGranularity as uint;\n+            return info.dwAllocationGranularity as usize;\n         }\n     }\n }\n@@ -1178,7 +1178,7 @@ impl MemoryMap {\n     /// Returns the pointer to the memory created or modified by this map.\n     pub fn data(&self) -> *mut u8 { self.data }\n     /// Returns the number of bytes this map applies to.\n-    pub fn len(&self) -> uint { self.len }\n+    pub fn len(&self) -> usize { self.len }\n     /// Returns the type of mapping this represents.\n     pub fn kind(&self) -> MemoryMapKind { self.kind }\n }"}, {"sha": "58d3ae9f7cfabcff1c975fa162ac2cb6303e88da", "filename": "src/libstd/path.rs", "status": "modified", "additions": 6, "deletions": 34, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -1038,23 +1038,16 @@ impl PathBuf {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> From<&'a Path> for PathBuf {\n-    fn from(s: &'a Path) -> PathBuf {\n-        s.to_path_buf()\n+impl<'a, T: ?Sized + AsRef<OsStr>> From<&'a T> for PathBuf {\n+    fn from(s: &'a T) -> PathBuf {\n+        PathBuf::from(s.as_ref().to_os_string())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> From<&'a str> for PathBuf {\n-    fn from(s: &'a str) -> PathBuf {\n-        PathBuf::from(OsString::from(s))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> From<&'a String> for PathBuf {\n-    fn from(s: &'a String) -> PathBuf {\n-        PathBuf::from(OsString::from(s))\n+impl From<OsString> for PathBuf {\n+    fn from(s: OsString) -> PathBuf {\n+        PathBuf { inner: s }\n     }\n }\n \n@@ -1065,27 +1058,6 @@ impl From<String> for PathBuf {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> From<&'a OsStr> for PathBuf {\n-    fn from(s: &'a OsStr) -> PathBuf {\n-        PathBuf::from(OsString::from(s))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> From<&'a OsString> for PathBuf {\n-    fn from(s: &'a OsString) -> PathBuf {\n-        PathBuf::from(s.to_os_string())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl From<OsString> for PathBuf {\n-    fn from(s: OsString) -> PathBuf {\n-        PathBuf { inner: s }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<P: AsRef<Path>> iter::FromIterator<P> for PathBuf {\n     fn from_iter<I: IntoIterator<Item = P>>(iter: I) -> PathBuf {"}, {"sha": "b4bd513e8f027ce7c7514ce3ce0c3e613970fbb2", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -37,7 +37,7 @@ use thread;\n ///\n /// # Examples\n ///\n-/// ```should_fail\n+/// ```should_panic\n /// # #![feature(process)]\n ///\n /// use std::process::Command;"}, {"sha": "cfd4e17c021b1d6f55e8e1b9c00c771010e6483d", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -64,7 +64,7 @@\n //!\n //! let mut rng = rand::thread_rng();\n //! if rng.gen() { // random bool\n-//!     println!(\"int: {}, uint: {}\", rng.gen::<int>(), rng.gen::<uint>())\n+//!     println!(\"isize: {}, usize: {}\", rng.gen::<isize>(), rng.gen::<usize>())\n //! }\n //! ```\n //!\n@@ -148,7 +148,7 @@\n //! }\n //!\n //! // Run a single simulation of the Monty Hall problem.\n-//! fn simulate<R: Rng>(random_door: &Range<uint>, rng: &mut R) -> SimulationResult {\n+//! fn simulate<R: Rng>(random_door: &Range<usize>, rng: &mut R) -> SimulationResult {\n //!     let car = random_door.ind_sample(rng);\n //!\n //!     // This is our initial choice\n@@ -168,18 +168,18 @@\n //!\n //! // Returns the door the game host opens given our choice and knowledge of\n //! // where the car is. The game host will never open the door with the car.\n-//! fn game_host_open<R: Rng>(car: uint, choice: uint, rng: &mut R) -> uint {\n+//! fn game_host_open<R: Rng>(car: usize, choice: usize, rng: &mut R) -> usize {\n //!     let choices = free_doors(&[car, choice]);\n //!     rand::sample(rng, choices.into_iter(), 1)[0]\n //! }\n //!\n //! // Returns the door we switch to, given our current choice and\n //! // the open door. There will only be one valid door.\n-//! fn switch_door(choice: uint, open: uint) -> uint {\n+//! fn switch_door(choice: usize, open: usize) -> usize {\n //!     free_doors(&[choice, open])[0]\n //! }\n //!\n-//! fn free_doors(blocked: &[uint]) -> Vec<uint> {\n+//! fn free_doors(blocked: &[usize]) -> Vec<usize> {\n //!     (0..3).filter(|x| !blocked.contains(x)).collect()\n //! }\n //!\n@@ -336,7 +336,7 @@ pub struct ThreadRng {\n \n /// Retrieve the lazily-initialized thread-local random number\n /// generator, seeded by the system. Intended to be used in method\n-/// chaining style, e.g. `thread_rng().gen::<int>()`.\n+/// chaining style, e.g. `thread_rng().gen::<isize>()`.\n ///\n /// The RNG provided will reseed itself from the operating system\n /// after generating a certain amount of randomness.\n@@ -556,14 +556,14 @@ mod test {\n         let mut r = thread_rng();\n         assert_eq!(r.choose(&[1, 1, 1]).cloned(), Some(1));\n \n-        let v: &[int] = &[];\n+        let v: &[isize] = &[];\n         assert_eq!(r.choose(v), None);\n     }\n \n     #[test]\n     fn test_shuffle() {\n         let mut r = thread_rng();\n-        let empty: &mut [int] = &mut [];\n+        let empty: &mut [isize] = &mut [];\n         r.shuffle(empty);\n         let mut one = [1];\n         r.shuffle(&mut one);\n@@ -583,7 +583,7 @@ mod test {\n     #[test]\n     fn test_thread_rng() {\n         let mut r = thread_rng();\n-        r.gen::<int>();\n+        r.gen::<isize>();\n         let mut v = [1, 1, 1];\n         r.shuffle(&mut v);\n         let b: &[_] = &[1, 1, 1];\n@@ -594,12 +594,12 @@ mod test {\n     #[test]\n     fn test_random() {\n         // not sure how to test this aside from just getting some values\n-        let _n : uint = random();\n+        let _n : usize = random();\n         let _f : f32 = random();\n         let _o : Option<Option<i8>> = random();\n         let _many : ((),\n-                     (uint,\n-                      int,\n+                     (usize,\n+                      isize,\n                       Option<(u32, (bool,))>),\n                      (u8, i8, u16, i16, u32, i32, u64, i64),\n                      (f32, (f64, (f64,)))) = random();\n@@ -611,7 +611,7 @@ mod test {\n         let max_val = 100;\n \n         let mut r = thread_rng();\n-        let vals = (min_val..max_val).collect::<Vec<int>>();\n+        let vals = (min_val..max_val).collect::<Vec<isize>>();\n         let small_sample = sample(&mut r, vals.iter(), 5);\n         let large_sample = sample(&mut r, vals.iter(), vals.len() + 5);\n \n@@ -625,7 +625,7 @@ mod test {\n \n     #[test]\n     fn test_std_rng_seeded() {\n-        let s = thread_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n+        let s = thread_rng().gen_iter::<usize>().take(256).collect::<Vec<usize>>();\n         let mut ra: StdRng = SeedableRng::from_seed(&*s);\n         let mut rb: StdRng = SeedableRng::from_seed(&*s);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n@@ -634,7 +634,7 @@ mod test {\n \n     #[test]\n     fn test_std_rng_reseed() {\n-        let s = thread_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n+        let s = thread_rng().gen_iter::<usize>().take(256).collect::<Vec<usize>>();\n         let mut r: StdRng = SeedableRng::from_seed(&*s);\n         let string1 = r.gen_ascii_chars().take(100).collect::<String>();\n \n@@ -662,49 +662,49 @@ mod bench {\n         let mut rng: XorShiftRng = OsRng::new().unwrap().gen();\n         b.iter(|| {\n             for _ in 0..RAND_BENCH_N {\n-                rng.gen::<uint>();\n+                rng.gen::<usize>();\n             }\n         });\n-        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+        b.bytes = size_of::<usize>() as u64 * RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn rand_isaac(b: &mut Bencher) {\n         let mut rng: IsaacRng = OsRng::new().unwrap().gen();\n         b.iter(|| {\n             for _ in 0..RAND_BENCH_N {\n-                rng.gen::<uint>();\n+                rng.gen::<usize>();\n             }\n         });\n-        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+        b.bytes = size_of::<usize>() as u64 * RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn rand_isaac64(b: &mut Bencher) {\n         let mut rng: Isaac64Rng = OsRng::new().unwrap().gen();\n         b.iter(|| {\n             for _ in 0..RAND_BENCH_N {\n-                rng.gen::<uint>();\n+                rng.gen::<usize>();\n             }\n         });\n-        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+        b.bytes = size_of::<usize>() as u64 * RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn rand_std(b: &mut Bencher) {\n         let mut rng = StdRng::new().unwrap();\n         b.iter(|| {\n             for _ in 0..RAND_BENCH_N {\n-                rng.gen::<uint>();\n+                rng.gen::<usize>();\n             }\n         });\n-        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+        b.bytes = size_of::<usize>() as u64 * RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn rand_shuffle_100(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        let x : &mut[uint] = &mut [1; 100];\n+        let x : &mut[usize] = &mut [1; 100];\n         b.iter(|| {\n             rng.shuffle(x);\n         })"}, {"sha": "ece6867ddcaa1e33f3d8639868cb992eecfc1be6", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -29,7 +29,7 @@ use result::Result::{Ok, Err};\n /// use std::old_io::MemReader;\n ///\n /// let mut rng = reader::ReaderRng::new(MemReader::new(vec!(1,2,3,4,5,6,7,8)));\n-/// println!(\"{:x}\", rng.gen::<uint>());\n+/// println!(\"{:x}\", rng.gen::<usize>());\n /// ```\n pub struct ReaderRng<R> {\n     reader: R"}, {"sha": "428bcaa49f7d918d2c0f8f25c763a5e11b866fe5", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -23,7 +23,7 @@ use core::prelude::*;\n use vec::Vec;\n \n /// One-time global initialization.\n-pub unsafe fn init(argc: int, argv: *const *const u8) { imp::init(argc, argv) }\n+pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n \n /// One-time global cleanup.\n pub unsafe fn cleanup() { imp::cleanup() }\n@@ -54,10 +54,10 @@ mod imp {\n \n     use sync::{StaticMutex, MUTEX_INIT};\n \n-    static mut GLOBAL_ARGS_PTR: uint = 0;\n+    static mut GLOBAL_ARGS_PTR: usize = 0;\n     static LOCK: StaticMutex = MUTEX_INIT;\n \n-    pub unsafe fn init(argc: int, argv: *const *const u8) {\n+    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n         let args = load_argc_and_argv(argc, argv);\n         put(args);\n     }\n@@ -146,7 +146,7 @@ mod imp {\n     use core::prelude::*;\n     use vec::Vec;\n \n-    pub unsafe fn init(_argc: int, _argv: *const *const u8) {\n+    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n     }\n \n     pub fn cleanup() {"}, {"sha": "b77699105646d3c009c451122f0fa4d87f5b7224", "filename": "src/libstd/rt/libunwind.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flibunwind.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -64,25 +64,25 @@ pub type _Unwind_Exception_Class = u64;\n pub type _Unwind_Word = libc::uintptr_t;\n \n #[cfg(target_arch = \"x86\")]\n-pub const unwinder_private_data_size: uint = 5;\n+pub const unwinder_private_data_size: usize = 5;\n \n #[cfg(target_arch = \"x86_64\")]\n-pub const unwinder_private_data_size: uint = 6;\n+pub const unwinder_private_data_size: usize = 6;\n \n #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]\n-pub const unwinder_private_data_size: uint = 20;\n+pub const unwinder_private_data_size: usize = 20;\n \n #[cfg(all(target_arch = \"arm\", target_os = \"ios\"))]\n-pub const unwinder_private_data_size: uint = 5;\n+pub const unwinder_private_data_size: usize = 5;\n \n #[cfg(target_arch = \"aarch64\")]\n-pub const unwinder_private_data_size: uint = 2;\n+pub const unwinder_private_data_size: usize = 2;\n \n #[cfg(any(target_arch = \"mips\", target_arch = \"mipsel\"))]\n-pub const unwinder_private_data_size: uint = 2;\n+pub const unwinder_private_data_size: usize = 2;\n \n #[cfg(target_arch = \"powerpc\")]\n-pub const unwinder_private_data_size: uint = 2;\n+pub const unwinder_private_data_size: usize = 2;\n \n #[repr(C)]\n pub struct _Unwind_Exception {"}, {"sha": "696c7960c3e6f4e11b71aa268c932c47ceabf6c2", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -48,16 +48,16 @@ mod libunwind;\n \n /// The default error code of the rust runtime if the main thread panics instead\n /// of exiting cleanly.\n-pub const DEFAULT_ERROR_CODE: int = 101;\n+pub const DEFAULT_ERROR_CODE: isize = 101;\n \n #[cfg(any(windows, android))]\n-const OS_DEFAULT_STACK_ESTIMATE: uint = 1 << 20;\n+const OS_DEFAULT_STACK_ESTIMATE: usize = 1 << 20;\n #[cfg(all(unix, not(android)))]\n-const OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n+const OS_DEFAULT_STACK_ESTIMATE: usize = 2 * (1 << 20);\n \n #[cfg(not(test))]\n #[lang = \"start\"]\n-fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n+fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n     use prelude::v1::*;\n \n     use mem;\n@@ -68,13 +68,13 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     use thread::Thread;\n \n     let something_around_the_top_of_the_stack = 1;\n-    let addr = &something_around_the_top_of_the_stack as *const _ as *const int;\n-    let my_stack_top = addr as uint;\n+    let addr = &something_around_the_top_of_the_stack as *const _ as *const isize;\n+    let my_stack_top = addr as usize;\n \n     // FIXME #11359 we just assume that this thread has a stack of a\n     // certain size, and estimate that there's at most 20KB of stack\n     // frames above our current position.\n-    const TWENTY_KB: uint = 20000;\n+    const TWENTY_KB: usize = 20000;\n \n     // saturating-add to sidestep overflow\n     let top_plus_spill = if usize::MAX - TWENTY_KB < my_stack_top {"}, {"sha": "e4927bbd3d274c5436b4bbeee00457e092f94a3e", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -78,12 +78,12 @@ struct Exception {\n     cause: Option<Box<Any + Send + 'static>>,\n }\n \n-pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: uint);\n+pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: usize);\n \n // Variables used for invoking callbacks when a thread starts to unwind.\n //\n // For more information, see below.\n-const MAX_CALLBACKS: uint = 16;\n+const MAX_CALLBACKS: usize = 16;\n static CALLBACKS: [atomic::AtomicUsize; MAX_CALLBACKS] =\n         [atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n          atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n@@ -176,7 +176,7 @@ fn rust_panic(cause: Box<Any + Send + 'static>) -> ! {\n         };\n         let exception_param = boxed::into_raw(exception) as *mut uw::_Unwind_Exception;\n         let error = uw::_Unwind_RaiseException(exception_param);\n-        rtabort!(\"Could not unwind stack, error = {}\", error as int)\n+        rtabort!(\"Could not unwind stack, error = {}\", error as isize)\n     }\n \n     extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n@@ -484,7 +484,7 @@ pub mod eabi {\n /// Entry point of panic from the libcore crate.\n #[lang = \"panic_fmt\"]\n pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n-                                file: &'static str, line: uint) -> ! {\n+                                file: &'static str, line: usize) -> ! {\n     begin_unwind_fmt(msg, &(file, line))\n }\n \n@@ -496,7 +496,7 @@ pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n /// the actual formatting into this shared place.\n #[inline(never)] #[cold]\n #[stable(since = \"1.0.0\", feature = \"rust1\")]\n-pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n+pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, usize)) -> ! {\n     use fmt::Write;\n \n     // We do two allocations here, unfortunately. But (a) they're\n@@ -512,7 +512,7 @@ pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -\n /// This is the entry point of unwinding for panic!() and assert!().\n #[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n #[stable(since = \"1.0.0\", feature = \"rust1\")]\n-pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) -> ! {\n+pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, usize)) -> ! {\n     // Note that this should be the only allocation performed in this code path.\n     // Currently this means that panic!() on OOM will invoke this code path,\n     // but then again we're not really ready for panic on OOM anyway. If\n@@ -535,7 +535,7 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) ->\n /// }` from ~1900/3700 (-O/no opts) to 180/590.\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n fn begin_unwind_inner(msg: Box<Any + Send>,\n-                      file_line: &(&'static str, uint)) -> ! {\n+                      file_line: &(&'static str, usize)) -> ! {\n     // Make sure the default failure handler is registered before we look at the\n     // callbacks. We also use a raw sys-based mutex here instead of a\n     // `std::sync` one as accessing TLS can cause weird recursive problems (and"}, {"sha": "5a482fbb50fec1d85f37cb50d13bedabd07f0ac9", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -43,7 +43,7 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n     (cfg!(target_os=\"macos\")) && running_on_valgrind()\n }\n \n-pub fn min_stack() -> uint {\n+pub fn min_stack() -> usize {\n     static MIN: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n     match MIN.load(Ordering::SeqCst) {\n         0 => {}"}, {"sha": "b2b87bb6c44a757bcbd2014da07a40d7921e3b44", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -1109,13 +1109,13 @@ mod test {\n \n     #[test]\n     fn drop_full() {\n-        let (tx, _rx) = channel::<Box<int>>();\n+        let (tx, _rx) = channel::<Box<isize>>();\n         tx.send(box 1).unwrap();\n     }\n \n     #[test]\n     fn drop_full_shared() {\n-        let (tx, _rx) = channel::<Box<int>>();\n+        let (tx, _rx) = channel::<Box<isize>>();\n         drop(tx.clone());\n         drop(tx.clone());\n         tx.send(box 1).unwrap();\n@@ -1454,7 +1454,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = channel::<Box<int>>();\n+            let (tx, rx) = channel::<Box<isize>>();\n             let _t = thread::spawn(move|| {\n                 tx.send(box 10).unwrap();\n             });\n@@ -1631,7 +1631,7 @@ mod sync_tests {\n \n     #[test]\n     fn drop_full() {\n-        let (tx, _rx) = sync_channel::<Box<int>>(1);\n+        let (tx, _rx) = sync_channel::<Box<isize>>(1);\n         tx.send(box 1).unwrap();\n     }\n "}, {"sha": "80cbd0761638ff398bc2f4c79a69e7822161b7f7", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -398,7 +398,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     // increment the count on the channel (used for selection)\n-    fn bump(&mut self, amt: int) -> int {\n+    fn bump(&mut self, amt: isize) -> isize {\n         match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n             DISCONNECTED => {\n                 self.cnt.store(DISCONNECTED, Ordering::SeqCst);"}, {"sha": "a79ffaa0860e3673f349396ff880394358d8740b", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -551,7 +551,7 @@ mod tests {\n         let arc2 = arc.clone();\n         let _ = thread::spawn(move|| -> () {\n             struct Unwinder {\n-                i: Arc<RwLock<int>>,\n+                i: Arc<RwLock<isize>>,\n             }\n             impl Drop for Unwinder {\n                 fn drop(&mut self) {"}, {"sha": "be521095aa95f9fa1aeaaa46d457eb1dd2c7d584", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -44,7 +44,7 @@ use sync::{Mutex, Condvar};\n /// sem.release();\n /// ```\n pub struct Semaphore {\n-    lock: Mutex<int>,\n+    lock: Mutex<isize>,\n     cvar: Condvar,\n }\n \n@@ -60,7 +60,7 @@ impl Semaphore {\n     /// The count specified can be thought of as a number of resources, and a\n     /// call to `acquire` or `access` will block until at least one resource is\n     /// available. It is valid to initialize a semaphore with a negative count.\n-    pub fn new(count: int) -> Semaphore {\n+    pub fn new(count: isize) -> Semaphore {\n         Semaphore {\n             lock: Mutex::new(count),\n             cvar: Condvar::new(),"}, {"sha": "cd118b3c9eefe609394f3d71c902691aaa2ade98", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -14,10 +14,10 @@ use io::prelude::*;\n use io;\n \n #[cfg(target_pointer_width = \"64\")]\n-pub const HEX_WIDTH: uint = 18;\n+pub const HEX_WIDTH: usize = 18;\n \n #[cfg(target_pointer_width = \"32\")]\n-pub const HEX_WIDTH: uint = 10;\n+pub const HEX_WIDTH: usize = 10;\n \n // All rust symbols are in theory lists of \"::\"-separated identifiers. Some\n // assemblers, however, can't handle these characters in symbol names. To get\n@@ -57,7 +57,7 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n             let mut i = 0;\n             for c in chars.by_ref() {\n                 if c.is_numeric() {\n-                    i = i * 10 + c as uint - '0' as uint;\n+                    i = i * 10 + c as usize - '0' as usize;\n                 } else {\n                     break\n                 }\n@@ -86,7 +86,7 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n             while rest.char_at(0).is_numeric() {\n                 rest = &rest[1..];\n             }\n-            let i: uint = inner[.. (inner.len() - rest.len())].parse().unwrap();\n+            let i: usize = inner[.. (inner.len() - rest.len())].parse().unwrap();\n             inner = &rest[i..];\n             rest = &rest[..i];\n             while rest.len() > 0 {"}, {"sha": "34a58f6c83aa73002f781376b81c0bc049f211a5", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -51,7 +51,7 @@ pub struct Helper<M:Send> {\n     pub chan: UnsafeCell<*mut Sender<M>>,\n \n     /// OS handle used to wake up a blocked helper thread\n-    pub signal: UnsafeCell<uint>,\n+    pub signal: UnsafeCell<usize>,\n \n     /// Flag if this helper thread has booted and been initialized yet.\n     pub initialized: UnsafeCell<bool>,\n@@ -96,11 +96,11 @@ impl<M: Send> Helper<M> {\n     {\n         unsafe {\n             let _guard = self.lock.lock().unwrap();\n-            if *self.chan.get() as uint == 0 {\n+            if *self.chan.get() as usize == 0 {\n                 let (tx, rx) = channel();\n                 *self.chan.get() = boxed::into_raw(box tx);\n                 let (receive, send) = helper_signal::new();\n-                *self.signal.get() = send as uint;\n+                *self.signal.get() = send as usize;\n \n                 let receive = RaceBox(receive);\n \n@@ -114,7 +114,7 @@ impl<M: Send> Helper<M> {\n \n                 let _ = rt::at_exit(move || { self.shutdown() });\n                 *self.initialized.get() = true;\n-            } else if *self.chan.get() as uint == 1 {\n+            } else if *self.chan.get() as usize == 1 {\n                 panic!(\"cannot continue usage after shutdown\");\n             }\n         }\n@@ -130,8 +130,8 @@ impl<M: Send> Helper<M> {\n             // Must send and *then* signal to ensure that the child receives the\n             // message. Otherwise it could wake up and go to sleep before we\n             // send the message.\n-            assert!(*self.chan.get() as uint != 0);\n-            assert!(*self.chan.get() as uint != 1,\n+            assert!(*self.chan.get() as usize != 0);\n+            assert!(*self.chan.get() as usize != 1,\n                     \"cannot continue usage after shutdown\");\n             (**self.chan.get()).send(msg).unwrap();\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n@@ -146,7 +146,7 @@ impl<M: Send> Helper<M> {\n             let mut guard = self.lock.lock().unwrap();\n \n             let ptr = *self.chan.get();\n-            if ptr as uint == 1 {\n+            if ptr as usize == 1 {\n                 panic!(\"cannot continue usage after shutdown\");\n             }\n             // Close the channel by destroying it"}, {"sha": "a8769ba99e8b368c4c34168b6053bdf611b316f7", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -56,7 +56,7 @@ pub fn timeout(desc: &'static str) -> IoError {\n }\n \n #[allow(deprecated)]\n-pub fn short_write(n: uint, desc: &'static str) -> IoError {\n+pub fn short_write(n: usize, desc: &'static str) -> IoError {\n     IoError {\n         kind: if n == 0 { old_io::TimedOut } else { old_io::ShortWrite(n) },\n         desc: desc,\n@@ -84,7 +84,7 @@ pub fn mkerr_libc<T: Int>(ret: T) -> IoResult<()> {\n }\n \n pub fn keep_going<F>(data: &[u8], mut f: F) -> i64 where\n-    F: FnMut(*const u8, uint) -> i64,\n+    F: FnMut(*const u8, usize) -> i64,\n {\n     let origamt = data.len();\n     let mut data = data.as_ptr();\n@@ -94,8 +94,8 @@ pub fn keep_going<F>(data: &[u8], mut f: F) -> i64 where\n         if ret == 0 {\n             break\n         } else if ret != -1 {\n-            amt -= ret as uint;\n-            data = unsafe { data.offset(ret as int) };\n+            amt -= ret as usize;\n+            data = unsafe { data.offset(ret as isize) };\n         } else {\n             return ret;\n         }\n@@ -134,7 +134,7 @@ pub trait ProcessConfig<K: BytesContainer, V: BytesContainer> {\n     fn args(&self) -> &[CString];\n     fn env(&self) -> Option<&collections::HashMap<K, V>>;\n     fn cwd(&self) -> Option<&CString>;\n-    fn uid(&self) -> Option<uint>;\n-    fn gid(&self) -> Option<uint>;\n+    fn uid(&self) -> Option<usize>;\n+    fn gid(&self) -> Option<usize>;\n     fn detach(&self) -> bool;\n }"}, {"sha": "1a0ee17904a243afa274b3b6347b2e43145feb22", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5", "patch": "@@ -148,7 +148,7 @@ pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n         if ret != 0 {\n             Err(last_net_error())\n         } else {\n-            assert!(len as uint == mem::size_of::<T>());\n+            assert!(len as usize == mem::size_of::<T>());\n             Ok(slot)\n         }\n     }\n@@ -170,14 +170,14 @@ pub fn sockname(fd: sock_t,\n             return Err(last_net_error())\n         }\n     }\n-    return sockaddr_to_addr(&storage, len as uint);\n+    return sockaddr_to_addr(&storage, len as usize);\n }\n \n pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n-                        len: uint) -> IoResult<SocketAddr> {\n+                        len: usize) -> IoResult<SocketAddr> {\n     match storage.ss_family as libc::c_int {\n         libc::AF_INET => {\n-            assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n+            assert!(len as usize >= mem::size_of::<libc::sockaddr_in>());\n             let storage: &libc::sockaddr_in = unsafe {\n                 mem::transmute(storage)\n             };\n@@ -192,7 +192,7 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             })\n         }\n         libc::AF_INET6 => {\n-            assert!(len as uint >= mem::size_of::<libc::sockaddr_in6>());\n+            assert!(len as usize >= mem::size_of::<libc::sockaddr_in6>());\n             let storage: &libc::sockaddr_in6 = unsafe {\n                 mem::transmute(storage)\n             };\n@@ -283,13 +283,13 @@ pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n     while !rp.is_null() {\n         unsafe {\n             let addr = try!(sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n-                                             (*rp).ai_addrlen as uint));\n+                                             (*rp).ai_addrlen as usize));\n             addrs.push(addrinfo::Info {\n                 address: addr,\n-                family: (*rp).ai_family as uint,\n+                family: (*rp).ai_family as usize,\n                 socktype: None,\n                 protocol: None,\n-                flags: (*rp).ai_flags as uint\n+                flags: (*rp).ai_flags as usize\n             });\n \n             rp = (*rp).ai_next as *mut libc::addrinfo;\n@@ -312,7 +312,7 @@ extern \"system\" {\n         flags: c_int) -> c_int;\n }\n \n-const NI_MAXHOST: uint = 1025;\n+const NI_MAXHOST: usize = 1025;\n \n pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> {\n     let addr = SocketAddr{ip: addr, port: 0};\n@@ -393,7 +393,7 @@ pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> {\n // [1] http://twistedmatrix.com/pipermail/twisted-commits/2012-April/034692.html\n // [2] http://stackoverflow.com/questions/19819198/does-send-msg-dontwait\n \n-pub fn read<T, L, R>(fd: sock_t, deadline: u64, mut lock: L, mut read: R) -> IoResult<uint> where\n+pub fn read<T, L, R>(fd: sock_t, deadline: u64, mut lock: L, mut read: R) -> IoResult<usize> where\n     L: FnMut() -> T,\n     R: FnMut(bool) -> libc::c_int,\n {\n@@ -431,7 +431,7 @@ pub fn read<T, L, R>(fd: sock_t, deadline: u64, mut lock: L, mut read: R) -> IoR\n     match ret {\n         0 => Err(sys_common::eof()),\n         n if n < 0 => Err(last_net_error()),\n-        n => Ok(n as uint)\n+        n => Ok(n as usize)\n     }\n }\n \n@@ -440,9 +440,9 @@ pub fn write<T, L, W>(fd: sock_t,\n                       buf: &[u8],\n                       write_everything: bool,\n                       mut lock: L,\n-                      mut write: W) -> IoResult<uint> where\n+                      mut write: W) -> IoResult<usize> where\n     L: FnMut() -> T,\n-    W: FnMut(bool, *const u8, uint) -> i64,\n+    W: FnMut(bool, *const u8, usize) -> i64,\n {\n     let mut ret = -1;\n     let mut written = 0;\n@@ -454,7 +454,7 @@ pub fn write<T, L, W>(fd: sock_t,\n             });\n         } else {\n             ret = retry(|| { write(false, buf.as_ptr(), buf.len()) });\n-            if ret > 0 { written = ret as uint; }\n+            if ret > 0 { written = ret as usize; }\n         }\n     }\n \n@@ -483,7 +483,7 @@ pub fn write<T, L, W>(fd: sock_t,\n             match retry(|| write(deadline.is_some(), ptr, len)) {\n                 -1 if wouldblock() => {}\n                 -1 => return Err(last_net_error()),\n-                n => { written += n as uint; }\n+                n => { written += n as usize; }\n             }\n         }\n         ret = 0;\n@@ -513,8 +513,8 @@ pub fn connect_timeout(fd: sock_t,\n         // If the connection is in progress, then we need to wait for it to\n         // finish (with a timeout). The current strategy for doing this is\n         // to use select() with a timeout.\n-        -1 if os::errno() as int == INPROGRESS as int ||\n-              os::errno() as int == WOULDBLOCK as int => {\n+        -1 if os::errno() as isize == INPROGRESS as isize ||\n+              os::errno() as isize == WOULDBLOCK as isize => {\n             let mut set: c::fd_set = unsafe { mem::zeroed() };\n             c::fd_set(&mut set, fd);\n             match await(fd, &mut set, timeout_ms) {\n@@ -686,7 +686,7 @@ impl TcpStream {\n                    nodelay as libc::c_int)\n     }\n \n-    pub fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> {\n+    pub fn set_keepalive(&mut self, seconds: Option<usize>) -> IoResult<()> {\n         let ret = setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n                              seconds.is_some() as libc::c_int);\n         match seconds {\n@@ -696,18 +696,18 @@ impl TcpStream {\n     }\n \n     #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n                    seconds as libc::c_int)\n     }\n     #[cfg(any(target_os = \"freebsd\",\n               target_os = \"dragonfly\"))]\n-    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n                    seconds as libc::c_int)\n     }\n     #[cfg(target_os = \"openbsd\")]\n-    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::SO_KEEPALIVE,\n                    seconds as libc::c_int)\n     }\n@@ -716,7 +716,7 @@ impl TcpStream {\n                   target_os = \"freebsd\",\n                   target_os = \"dragonfly\",\n                   target_os = \"openbsd\")))]\n-    fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {\n+    fn set_tcp_keepalive(&mut self, _seconds: usize) -> IoResult<()> {\n         Ok(())\n     }\n \n@@ -733,7 +733,7 @@ impl TcpStream {\n         ret\n     }\n \n-    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n         let doread = |nb| unsafe {\n@@ -749,7 +749,7 @@ impl TcpStream {\n     pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n+        let dowrite = |nb: bool, buf: *const u8, len: usize| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::send(fd,\n                        buf as *const _,\n@@ -876,7 +876,7 @@ impl UdpSocket {\n         sockname(self.fd(), libc::getsockname)\n     }\n \n-    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> {\n+    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(usize, SocketAddr)> {\n         let fd = self.fd();\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n@@ -893,7 +893,7 @@ impl UdpSocket {\n                            storagep,\n                            &mut addrlen) as libc::c_int\n         }));\n-        Ok((n as uint, sockaddr_to_addr(&storage, addrlen as uint).unwrap()))\n+        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize).unwrap()))\n     }\n \n     pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n@@ -903,7 +903,7 @@ impl UdpSocket {\n \n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb, buf: *const u8, len: uint| unsafe {\n+        let dowrite = |nb, buf: *const u8, len: usize| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::sendto(fd,\n                          buf as *const libc::c_void,\n@@ -939,11 +939,11 @@ impl UdpSocket {\n         }\n     }\n \n-    pub fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()> {\n+    pub fn multicast_time_to_live(&mut self, ttl: isize) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n                    ttl as libc::c_int)\n     }\n-    pub fn time_to_live(&mut self, ttl: int) -> IoResult<()> {\n+    pub fn time_to_live(&mut self, ttl: isize) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_TTL, ttl as libc::c_int)\n     }\n "}, {"sha": "8dc3407db77a20f27b51818ddd6dec3c0d40c7b4", "filename": "src/libstd/sys/common/stack.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "22cb59433713043dbaf2a3409072e147e13901c5", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "5995d7ac10f73d7b3270c9ab22f3303d20905c37", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "315df411179f9c9d04a00d0e6e533683d1e5c615", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 17, "deletions": 96, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "b46d390826c93934cf292746b2e5b92634297835", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "2514d4bf4a39605b0c7b76a4ae30d51be503ae87", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "2569653811f11e2892900a3ca710551becb07b22", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "724156d81d84e7e515b1997b5fd85cc0aa83375f", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "69d876a48a4b22b3421aa8e293c074dc1497c7af", "filename": "src/libstd/sys/unix/os_str.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "f0071295bf237316afdc4bed80434ea40e267d7f", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "0d35ace185d844b86bf874ee5a1420ffa8338a17", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "6887095c53a7d1cdc24a5a7cf7d1acfe5b9a8baf", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "3c05fd602be8530d5d23251d12930d58bff4e900", "filename": "src/libstd/sys/unix/sync.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fsync.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "a9f2198208bc31cbd825ce36302f2c9c4fa0619f", "filename": "src/libstd/sys/unix/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "d9a162302fc1cc28c1bd0c0756c0c4a20c76b02d", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "2f6fd713bfba50c01d7049e83e84ab5a48d873fd", "filename": "src/libstd/sys/unix/tty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "385834a6226e05ec82d77b760fa897484b2d56d9", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "3330130c7700207fab3279f53768b9d311af9fdd", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "91905ae7489d528b100b874e19183cedaeca9e4c", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "064c003bd15a909b90392f5ce531e5330a6085d7", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "297f6e173abdc9f48d3b6872ab2c712f54fe4e2d", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}, {"sha": "79b7de4f341ac07280d7d69a5c28faa44266f75d", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552080181c58beef03493a110b4a38b20b6b5da5/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=552080181c58beef03493a110b4a38b20b6b5da5"}]}