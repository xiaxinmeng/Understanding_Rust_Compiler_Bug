{"sha": "ce79b0e492f1583debbce3c8155da3536c684d9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNzliMGU0OTJmMTU4M2RlYmJjZTNjODE1NWRhMzUzNmM2ODRkOWE=", "commit": {"author": {"name": "Tohava", "email": "tohava@tohava-laptop.(none)", "date": "2010-08-05T01:19:46Z"}, "committer": {"name": "Tohava", "email": "tohava@tohava-laptop.(none)", "date": "2010-08-05T01:19:46Z"}, "message": "Merge branch 'master' of git://github.com/graydon/rust", "tree": {"sha": "f5a2a22230510dd14901742a4904c576f62a8500", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5a2a22230510dd14901742a4904c576f62a8500"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce79b0e492f1583debbce3c8155da3536c684d9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce79b0e492f1583debbce3c8155da3536c684d9a", "html_url": "https://github.com/rust-lang/rust/commit/ce79b0e492f1583debbce3c8155da3536c684d9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce79b0e492f1583debbce3c8155da3536c684d9a/comments", "author": null, "committer": null, "parents": [{"sha": "0f53d0313912b56be77b267f98daa2569ebb37ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f53d0313912b56be77b267f98daa2569ebb37ea", "html_url": "https://github.com/rust-lang/rust/commit/0f53d0313912b56be77b267f98daa2569ebb37ea"}, {"sha": "6e98a3b64f3c7577aae4317363328ac6a762a2f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e98a3b64f3c7577aae4317363328ac6a762a2f2", "html_url": "https://github.com/rust-lang/rust/commit/6e98a3b64f3c7577aae4317363328ac6a762a2f2"}], "stats": {"total": 300, "additions": 236, "deletions": 64}, "files": [{"sha": "7236e02f8749dbab4d6c4a073510d254f21b299c", "filename": "src/Makefile", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=ce79b0e492f1583debbce3c8155da3536c684d9a", "patch": "@@ -489,6 +489,7 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       obj-recursion.rs \\\n                       obj-return-polytypes.rs \\\n                       obj-with-vec.rs \\\n+                      operator-associativity.rs \\\n                       output-slot-variants.rs \\\n                       pred.rs \\\n                       preempt.rs \\\n@@ -576,10 +577,18 @@ RFAIL_RS := $(wildcard test/run-fail/*.rs)\n CFAIL_RC := $(wildcard test/compile-fail/*.rc)\n CFAIL_RS := $(wildcard test/compile-fail/*.rs)\n \n+ifdef CHECK_XFAILS\n+TEST_RPASS_CRATES_X86 := $(filter $(TEST_XFAILS_X86), $(RPASS_RC))\n+TEST_RPASS_CRATES_LLVM := $(filter $(TEST_XFAILS_LLVM), $(RPASS_RC))\n+TEST_RPASS_SOURCES_X86 := $(filter $(TEST_XFAILS_X86), $(RPASS_RS))\n+TEST_RPASS_SOURCES_LLVM := $(filter $(TEST_XFAILS_LLVM), $(RPASS_RS))\n+else\n TEST_RPASS_CRATES_X86 := $(filter-out $(TEST_XFAILS_X86), $(RPASS_RC))\n TEST_RPASS_CRATES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(RPASS_RC))\n TEST_RPASS_SOURCES_X86 := $(filter-out $(TEST_XFAILS_X86), $(RPASS_RS))\n TEST_RPASS_SOURCES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(RPASS_RS))\n+endif\n+\n TEST_RPASS_EXTRAS := $(wildcard test/run-pass/*/*.rs)\n TEST_RPASS_EXES_X86 := \\\n                       $(TEST_RPASS_CRATES_X86:.rc=.x86$(CFG_EXE_SUFFIX)) \\"}, {"sha": "fb2d91a05bab89d2bff2ad656318da114d21585c", "filename": "src/boot/fe/pexp.ml", "status": "modified", "additions": 86, "deletions": 36, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Fboot%2Ffe%2Fpexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Fboot%2Ffe%2Fpexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fpexp.ml?ref=ce79b0e492f1583debbce3c8155da3536c684d9a", "patch": "@@ -718,142 +718,192 @@ and parse_negation_pexp (ps:pstate) : pexp =\n \n (* Binops are all left-associative,                *)\n (* so we factor out some of the parsing code here. *)\n-and binop_rhs\n+and binop_build\n     (ps:pstate)\n     (name:string)\n     (apos:pos)\n-    (lhs:pexp)\n     (rhs_parse_fn:pstate -> pexp)\n+    (lhs:pexp)\n+    (step_fn:pexp -> pexp)\n     (op:Ast.binop)\n     : pexp =\n   bump ps;\n   let rhs = (ctxt (name ^ \" rhs\") rhs_parse_fn ps) in\n   let bpos = lexpos ps in\n-    span ps apos bpos (PEXP_binop (op, lhs, rhs))\n+  let node = span ps apos bpos (PEXP_binop (op, lhs, rhs)) in\n+    step_fn node\n \n \n and parse_factor_pexp (ps:pstate) : pexp =\n   let name = \"factor pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_negation_pexp ps in\n+  let build = binop_build ps name apos parse_negation_pexp in\n+  let rec step accum =\n     match peek ps with\n-        STAR    -> binop_rhs ps name apos lhs parse_factor_pexp Ast.BINOP_mul\n-      | SLASH   -> binop_rhs ps name apos lhs parse_factor_pexp Ast.BINOP_div\n-      | PERCENT -> binop_rhs ps name apos lhs parse_factor_pexp Ast.BINOP_mod\n-      | _       -> lhs\n+        STAR    -> build accum step Ast.BINOP_mul\n+      | SLASH   -> build accum step Ast.BINOP_div\n+      | PERCENT -> build accum step Ast.BINOP_mod\n+      | _       -> accum\n+  in\n+    step lhs\n \n \n and parse_term_pexp (ps:pstate) : pexp =\n   let name = \"term pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_factor_pexp ps in\n+  let build = binop_build ps name apos parse_factor_pexp in\n+  let rec step accum =\n     match peek ps with\n-        PLUS  -> binop_rhs ps name apos lhs parse_term_pexp Ast.BINOP_add\n-      | MINUS -> binop_rhs ps name apos lhs parse_term_pexp Ast.BINOP_sub\n-      | _     -> lhs\n+        PLUS  -> build accum step Ast.BINOP_add\n+      | MINUS -> build accum step Ast.BINOP_sub\n+      | _     -> accum\n+  in\n+    step lhs\n \n \n and parse_shift_pexp (ps:pstate) : pexp =\n   let name = \"shift pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_term_pexp ps in\n+  let build = binop_build ps name apos parse_term_pexp in\n+  let rec step accum =\n     match peek ps with\n-        LSL -> binop_rhs ps name apos lhs parse_shift_pexp Ast.BINOP_lsl\n-      | LSR -> binop_rhs ps name apos lhs parse_shift_pexp Ast.BINOP_lsr\n-      | ASR -> binop_rhs ps name apos lhs parse_shift_pexp Ast.BINOP_asr\n-      | _ -> lhs\n+        LSL -> build accum step Ast.BINOP_lsl\n+      | LSR -> build accum step Ast.BINOP_lsr\n+      | ASR -> build accum step Ast.BINOP_asr\n+      | _   -> accum\n+  in\n+    step lhs\n \n \n and parse_and_pexp (ps:pstate) : pexp =\n   let name = \"and pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_shift_pexp ps in\n+  let build = binop_build ps name apos parse_shift_pexp in\n+  let rec step accum =\n     match peek ps with\n-        AND -> binop_rhs ps name apos lhs parse_and_pexp Ast.BINOP_and\n-      | _   -> lhs\n+        AND -> build accum step Ast.BINOP_and\n+      | _   -> accum\n+  in\n+    step lhs\n \n \n and parse_xor_pexp (ps:pstate) : pexp =\n   let name = \"xor pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_and_pexp ps in\n+  let build = binop_build ps name apos parse_and_pexp in\n+  let rec step accum =\n     match peek ps with\n-        CARET -> binop_rhs ps name apos lhs parse_xor_pexp Ast.BINOP_xor\n-      | _ -> lhs\n+        CARET -> build accum step Ast.BINOP_xor\n+      | _     -> accum\n+  in\n+    step lhs\n \n \n and parse_or_pexp (ps:pstate) : pexp =\n   let name = \"or pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_xor_pexp ps in\n+  let build = binop_build ps name apos parse_xor_pexp in\n+  let rec step accum =\n     match peek ps with\n-        OR -> binop_rhs ps name apos lhs parse_or_pexp Ast.BINOP_or\n-      | _  -> lhs\n+        OR -> build accum step Ast.BINOP_or\n+      | _  -> accum\n+  in\n+    step lhs\n \n \n and parse_relational_pexp (ps:pstate) : pexp =\n   let name = \"relational pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_or_pexp ps in\n+  let build = binop_build ps name apos parse_or_pexp in\n+  let rec step accum =\n     match peek ps with\n-        LT -> binop_rhs ps name apos lhs parse_relational_pexp Ast.BINOP_lt\n-      | LE -> binop_rhs ps name apos lhs parse_relational_pexp Ast.BINOP_le\n-      | GE -> binop_rhs ps name apos lhs parse_relational_pexp Ast.BINOP_ge\n-      | GT -> binop_rhs ps name apos lhs parse_relational_pexp Ast.BINOP_gt\n-      | _  -> lhs\n+        LT -> build accum step Ast.BINOP_lt\n+      | LE -> build accum step Ast.BINOP_le\n+      | GE -> build accum step Ast.BINOP_ge\n+      | GT -> build accum step Ast.BINOP_gt\n+      | _  -> accum\n+  in\n+    step lhs\n \n \n and parse_equality_pexp (ps:pstate) : pexp =\n   let name = \"equality pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_relational_pexp ps in\n+  let build = binop_build ps name apos parse_relational_pexp in\n+  let rec step accum =\n     match peek ps with\n-        EQEQ -> binop_rhs ps name apos lhs parse_equality_pexp Ast.BINOP_eq\n-      | NE   -> binop_rhs ps name apos lhs parse_equality_pexp Ast.BINOP_ne\n-      | _    -> lhs\n+        EQEQ -> build accum step Ast.BINOP_eq\n+      | NE   -> build accum step Ast.BINOP_ne\n+      | _    -> accum\n+  in\n+    step lhs\n \n \n and parse_andand_pexp (ps:pstate) : pexp =\n   let name = \"andand pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_equality_pexp ps in\n+  let rec step accum =\n     match peek ps with\n         ANDAND ->\n           bump ps;\n-          let rhs = parse_andand_pexp ps in\n+          let rhs = parse_equality_pexp ps in\n           let bpos = lexpos ps in\n-            span ps apos bpos (PEXP_lazy_and (lhs, rhs))\n+          let node = span ps apos bpos (PEXP_lazy_and (accum, rhs)) in\n+            step node\n \n-      | _   -> lhs\n+      | _   -> accum\n+  in\n+    step lhs\n \n \n and parse_oror_pexp (ps:pstate) : pexp =\n   let name = \"oror pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_andand_pexp ps in\n+  let rec step accum =\n     match peek ps with\n         OROR ->\n           bump ps;\n-          let rhs = parse_oror_pexp ps in\n+          let rhs = parse_andand_pexp ps in\n           let bpos = lexpos ps in\n-            span ps apos bpos (PEXP_lazy_or (lhs, rhs))\n+          let node = span ps apos bpos (PEXP_lazy_or (accum, rhs)) in\n+            step node\n+\n+      | _  -> accum\n+  in\n+    step lhs\n \n-      | _  -> lhs\n \n and parse_as_pexp (ps:pstate) : pexp =\n   let apos = lexpos ps in\n   let pexp = ctxt \"as pexp\" parse_oror_pexp ps in\n+  let rec step accum =\n     match peek ps with\n         AS ->\n           bump ps;\n           let tapos = lexpos ps in\n           let t = parse_ty ps in\n           let bpos = lexpos ps in\n           let t = span ps tapos bpos t in\n+          let node =\n             span ps apos bpos\n-              (PEXP_unop ((Ast.UNOP_cast t), pexp))\n+              (PEXP_unop ((Ast.UNOP_cast t), accum))\n+          in\n+            step node\n+\n+      | _ -> accum\n+  in\n+    step pexp\n \n-      | _       -> pexp\n \n and parse_pexp (ps:pstate) : pexp =\n   parse_as_pexp ps"}, {"sha": "787855f0c1a0b3c47635f2a521091d6cfe3b1323", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=ce79b0e492f1583debbce3c8155da3536c684d9a", "patch": "@@ -472,6 +472,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n   and internal_check_outer_lval\n       ~mut:(mut:Ast.mutability)\n       ~deref:(deref:bool)\n+      ~fn_args:(fn_args:(Ast.ty array) option)\n       (infer:Ast.ty option)\n       (lval:Ast.lval)\n       : (Ast.ty * int) =\n@@ -485,11 +486,15 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n           demand expected actual;\n           yield_ty actual\n       | None, (LTYPE_poly _ as lty) ->\n-          Common.err\n-            None\n-            \"not enough context to automatically instantiate the polymorphic \\\n-              type '%a'; supply type parameters explicitly\"\n-            sprintf_ltype lty\n+          begin\n+            match fn_args with\n+                None ->\n+                  Common.err None\n+                    \"can't auto-instantiate %a\" sprintf_ltype lty\n+              | Some args ->\n+                  Common.err None \"can't auto-instantiate %a on %d args\"\n+                    sprintf_ltype lty (Array.length args)\n+          end\n       | Some _, (LTYPE_poly _) ->\n           (* FIXME: auto-instantiate *)\n           Common.unimpl\n@@ -502,6 +507,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n   and generic_check_lval\n       ~mut:(mut:Ast.mutability)\n       ~deref:(deref:bool)\n+      ~fn_args:(fn_args:(Ast.ty array) option)\n       (infer:Ast.ty option)\n       (lval:Ast.lval)\n       : Ast.ty =\n@@ -521,7 +527,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n                 | Some t -> Fmt.fmt_to_str Ast.fmt_ty t))\n     in\n     let (lval_ty, n_boxes) =\n-      internal_check_outer_lval ~mut:mut ~deref:deref infer lval\n+      internal_check_outer_lval ~mut ~deref ~fn_args infer lval\n     in\n     let _ =\n       iflog cx\n@@ -563,9 +569,10 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n   and check_lval\n       ?mut:(mut=Ast.MUT_immutable)\n       ?deref:(deref=false)\n+      ?fn_args:(fn_args=None)\n       (lval:Ast.lval)\n       : Ast.ty =\n-    generic_check_lval ~mut:mut ~deref:deref None lval\n+    generic_check_lval ~fn_args ~mut ~deref None lval\n \n   and check_atom ?deref:(deref=false) (atom:Ast.atom) : Ast.ty =\n     match atom with\n@@ -582,7 +589,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n       (ty:Ast.ty)\n       (lval:Ast.lval)\n       : unit =\n-    ignore (generic_check_lval ?mut:mut ~deref:false\n+    ignore (generic_check_lval ~mut ~deref:false ~fn_args:None\n               (Some (Ast.TY_mutable ty)) lval)\n   in\n \n@@ -636,7 +643,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n    * returns the return type. *)\n   let check_fn (callee:Ast.lval) (args:Ast.atom array) : Ast.ty =\n     let arg_tys = Array.map check_atom args in\n-    let callee_ty = check_lval callee in\n+    let callee_ty = check_lval callee ~fn_args:(Some arg_tys) in\n     demand_fn (Array.map (fun ty -> Some ty) arg_tys) callee_ty\n   in\n "}, {"sha": "142f808a645b5ffb7ce7c40e85b720d198db0ce0", "filename": "src/lib/_io.rs", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Flib%2F_io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Flib%2F_io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_io.rs?ref=ce79b0e492f1583debbce3c8155da3536c684d9a", "patch": "@@ -2,23 +2,19 @@ type buf_reader = unsafe obj {\n   fn read() -> vec[u8];\n };\n \n+type buf_writer = unsafe obj {\n+  fn write(vec[u8] v);\n+};\n+\n fn default_bufsz() -> uint {\n   ret 4096u;\n }\n \n fn new_buf() -> vec[u8] {\n-  let vec[u8] v = vec();\n-  let uint i = default_bufsz();\n-  while (i > 0u) {\n-    i -= 1u;\n-    v += vec(0u8);\n-  }\n-  // FIXME (issue #93): should be:\n-  // ret _vec.alloc[u8](default_bufsz());\n-  ret v;\n+  ret _vec.alloc[u8](default_bufsz());\n }\n \n-fn new_buf_reader(str s) -> buf_reader {\n+fn new_buf_reader(str path) -> buf_reader {\n \n   unsafe obj fd_buf_reader(int fd, mutable vec[u8] buf) {\n \n@@ -47,11 +43,67 @@ fn new_buf_reader(str s) -> buf_reader {\n     }\n   }\n \n-  auto fd = os.libc.open(_str.buf(s), 0);\n+  auto fd = os.libc.open(_str.buf(path),\n+                         os.libc_constants.O_RDONLY() |\n+                         os.libc_constants.O_BINARY(),\n+                         0u);\n+\n   if (fd < 0) {\n-    log \"error opening file\";\n+    log \"error opening file for reading\";\n     log sys.rustrt.last_os_error();\n     fail;\n   }\n   ret fd_buf_reader(fd, new_buf());\n }\n+\n+type fileflag = tag(append(), create(), truncate());\n+\n+fn new_buf_writer(str path, vec[fileflag] flags) -> buf_writer {\n+\n+  unsafe obj fd_buf_writer(int fd) {\n+\n+    fn write(vec[u8] v) {\n+      auto len = _vec.len[u8](v);\n+      auto count = 0u;\n+      auto vbuf;\n+      while (count < len) {\n+        vbuf = _vec.buf_off[u8](v, count);\n+        auto nout = os.libc.write(fd, vbuf, len);\n+        if (nout < 0) {\n+          log \"error dumping buffer\";\n+          log sys.rustrt.last_os_error();\n+          fail;\n+        }\n+        count += nout as uint;\n+      }\n+    }\n+\n+    drop {\n+      os.libc.close(fd);\n+    }\n+  }\n+\n+  let int fflags =\n+    os.libc_constants.O_WRONLY() |\n+    os.libc_constants.O_BINARY();\n+\n+  for (fileflag f in flags) {\n+    alt (f) {\n+      case (append())   { fflags |= os.libc_constants.O_APPEND(); }\n+      case (create())   { fflags |= os.libc_constants.O_CREAT(); }\n+      case (truncate()) { fflags |= os.libc_constants.O_TRUNC(); }\n+    }\n+  }\n+\n+  auto fd = os.libc.open(_str.buf(path),\n+                         fflags,\n+                         os.libc_constants.S_IRUSR() |\n+                         os.libc_constants.S_IWUSR());\n+\n+  if (fd < 0) {\n+    log \"error opening file for writing\";\n+    log sys.rustrt.last_os_error();\n+    fail;\n+  }\n+  ret fd_buf_writer(fd);\n+}"}, {"sha": "e374bf52da13d561aab5a2ab745f59c1f8b52ec1", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=ce79b0e492f1583debbce3c8155da3536c684d9a", "patch": "@@ -3,7 +3,7 @@ import op = util.operator;\n \n native \"rust\" mod rustrt {\n   type vbuf;\n-  fn vec_buf[T](vec[T] v) -> vbuf;\n+  fn vec_buf[T](vec[T] v, uint offset) -> vbuf;\n   fn vec_len[T](vec[T] v) -> uint;\n   /* The T in vec_alloc[T, U] is the type of the vec to allocate.  The\n    * U is the type of an element in the vec.  So to allocate a vec[U] we\n@@ -50,7 +50,12 @@ fn len[T](vec[T] v) -> uint {\n }\n \n fn buf[T](vec[T] v) -> vbuf {\n-  ret rustrt.vec_buf[T](v);\n+  ret rustrt.vec_buf[T](v, 0u);\n+}\n+\n+fn buf_off[T](vec[T] v, uint offset) -> vbuf {\n+  check (offset < len[T](v));\n+  ret rustrt.vec_buf[T](v, offset);\n }\n \n // Returns elements from [start..end) from v."}, {"sha": "3f096e99def35a5f5efeb7a3022a596d1917355c", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=ce79b0e492f1583debbce3c8155da3536c684d9a", "patch": "@@ -3,7 +3,7 @@ import _vec.vbuf;\n \n native mod libc = \"libc.so.6\" {\n \n-  fn open(sbuf s, int flags) -> int;\n+  fn open(sbuf s, int flags, uint mode) -> int;\n   fn read(int fd, vbuf buf, uint count) -> int;\n   fn write(int fd, vbuf buf, uint count) -> int;\n   fn close(int fd) -> int;\n@@ -17,3 +17,18 @@ native mod libc = \"libc.so.6\" {\n   fn setenv(sbuf n, sbuf v, int overwrite) -> int;\n   fn unsetenv(sbuf n) -> int;\n }\n+\n+mod libc_constants {\n+  fn O_RDONLY() -> int { ret 0x0000; }\n+  fn O_WRONLY() -> int { ret 0x0001; }\n+  fn O_RDWR()   -> int { ret 0x0002; }\n+  fn O_APPEND() -> int { ret 0x0400; }\n+  fn O_CREAT()  -> int { ret 0x0040; }\n+  fn O_EXCL()   -> int { ret 0x0080; }\n+  fn O_TRUNC()  -> int { ret 0x0200; }\n+  fn O_TEXT()   -> int { ret 0x0000; } // nonexistent in linux libc\n+  fn O_BINARY() -> int { ret 0x0000; } // nonexistent in linux libc\n+\n+  fn S_IRUSR() -> uint { ret 0x0100u; }\n+  fn S_IWUSR() -> uint { ret 0x0080u; }\n+}"}, {"sha": "2ada5c0781c1a06e9f6053dcbe84db91fcb58102", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=ce79b0e492f1583debbce3c8155da3536c684d9a", "patch": "@@ -3,7 +3,7 @@ import _vec.vbuf;\n \n native mod libc = \"libc.dylib\" {\n \n-  fn open(sbuf s, int flags) -> int;\n+  fn open(sbuf s, int flags, uint mode) -> int;\n   fn read(int fd, vbuf buf, uint count) -> int;\n   fn write(int fd, vbuf buf, uint count) -> int;\n   fn close(int fd) -> int;\n@@ -17,3 +17,18 @@ native mod libc = \"libc.dylib\" {\n   fn setenv(sbuf n, sbuf v, int overwrite) -> int;\n   fn unsetenv(sbuf n) -> int;\n }\n+\n+mod libc_constants {\n+  fn O_RDONLY() -> int { ret 0x0000; }\n+  fn O_WRONLY() -> int { ret 0x0001; }\n+  fn O_RDWR()   -> int { ret 0x0002; }\n+  fn O_APPEND() -> int { ret 0x0008; }\n+  fn O_CREAT()  -> int { ret 0x0200; }\n+  fn O_EXCL()   -> int { ret 0x0800; }\n+  fn O_TRUNC()  -> int { ret 0x0400; }\n+  fn O_TEXT()   -> int { ret 0x0000; } // nonexistent in darwin libc\n+  fn O_BINARY() -> int { ret 0x0000; } // nonexistent in darwin libc\n+\n+  fn S_IRUSR() -> uint { ret 0x0400u; }\n+  fn S_IWUSR() -> uint { ret 0x0200u; }\n+}"}, {"sha": "3d8e5f3a4d9b3fb092cc1c8cceb22f43ec35a493", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=ce79b0e492f1583debbce3c8155da3536c684d9a", "patch": "@@ -2,8 +2,23 @@ import _str.sbuf;\n import _vec.vbuf;\n \n native mod libc = \"msvcrt.dll\" {\n-  fn open(sbuf s, int flags) -> int = \"_open\";\n+  fn open(sbuf s, int flags, uint mode) -> int = \"_open\";\n   fn read(int fd, vbuf buf, uint count) -> int = \"_read\";\n   fn write(int fd, vbuf buf, uint count) -> int = \"_write\";\n   fn close(int fd) -> int = \"_close\";\n }\n+\n+mod libc_constants {\n+  fn O_RDONLY() -> int { ret 0x0000; }\n+  fn O_WRONLY() -> int { ret 0x0001; }\n+  fn O_RDWR()   -> int { ret 0x0002; }\n+  fn O_APPEND() -> int { ret 0x0400; }\n+  fn O_CREAT()  -> int { ret 0x0040; }\n+  fn O_EXCL()   -> int { ret 0x0080; }\n+  fn O_TRUNC()  -> int { ret 0x0200; }\n+  fn O_TEXT()   -> int { ret 0x4000; }\n+  fn O_BINARY() -> int { ret 0x8000; }\n+\n+  fn S_IRUSR() -> uint { ret 0x0100u; } // really _S_IREAD  in win32\n+  fn S_IWUSR() -> uint { ret 0x0080u; } // really _S_IWRITE in win32\n+}"}, {"sha": "657109c6df2eec171b6b39e760d13d0e675bb370", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=ce79b0e492f1583debbce3c8155da3536c684d9a", "patch": "@@ -116,9 +116,9 @@ str_buf(rust_task *task, rust_str *s)\n }\n \n extern \"C\" CDECL void *\n-vec_buf(rust_task *task, type_desc *ty, rust_vec *v)\n+vec_buf(rust_task *task, type_desc *ty, rust_vec *v, size_t offset)\n {\n-    return (void *)&v->data[0];\n+    return (void *)&v->data[ty->size * offset];\n }\n \n extern \"C\" CDECL size_t"}, {"sha": "2c028eba627c6ea93ee731fd4b874e041bf8e764", "filename": "src/test/run-pass/operator-associativity.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Ftest%2Frun-pass%2Foperator-associativity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce79b0e492f1583debbce3c8155da3536c684d9a/src%2Ftest%2Frun-pass%2Foperator-associativity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-associativity.rs?ref=ce79b0e492f1583debbce3c8155da3536c684d9a", "patch": "@@ -0,0 +1,4 @@\n+// Testcase for issue #130, operator associativity.\n+fn main() -> () {\n+  check ((3 * 5 / 2) == 7);\n+}"}]}