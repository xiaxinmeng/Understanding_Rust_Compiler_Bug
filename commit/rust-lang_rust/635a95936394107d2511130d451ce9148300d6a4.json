{"sha": "635a95936394107d2511130d451ce9148300d6a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNWE5NTkzNjM5NDEwN2QyNTExMTMwZDQ1MWNlOTE0ODMwMGQ2YTQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-19T00:07:56Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-19T00:08:42Z"}, "message": "rustc: Make coherence aware of multiple-traits-per-impl", "tree": {"sha": "db636c0a0a0f77fb975f2ee943ed899ac19d0dcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db636c0a0a0f77fb975f2ee943ed899ac19d0dcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/635a95936394107d2511130d451ce9148300d6a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/635a95936394107d2511130d451ce9148300d6a4", "html_url": "https://github.com/rust-lang/rust/commit/635a95936394107d2511130d451ce9148300d6a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/635a95936394107d2511130d451ce9148300d6a4/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5506bf1480ed7e9dc56d3d3f08fdf79003fb1c9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5506bf1480ed7e9dc56d3d3f08fdf79003fb1c9b", "html_url": "https://github.com/rust-lang/rust/commit/5506bf1480ed7e9dc56d3d3f08fdf79003fb1c9b"}], "stats": {"total": 177, "additions": 80, "deletions": 97}, "files": [{"sha": "b9ab1cd289f2cf0664c44bb4d53b65b30d590d07", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 80, "deletions": 97, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/635a95936394107d2511130d451ce9148300d6a4/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/635a95936394107d2511130d451ce9148300d6a4/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=635a95936394107d2511130d451ce9148300d6a4", "patch": "@@ -111,6 +111,7 @@ fn get_base_type_def_id(inference_context: infer_ctxt,\n class CoherenceInfo {\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n+\n     let inherent_methods: hashmap<def_id,@dvec<@Impl>>;\n \n     // Contains implementations of methods associated with a trait. For these,\n@@ -129,14 +130,17 @@ class CoherenceChecker {\n \n     // A mapping from implementations to the corresponding base type\n     // definition ID.\n+\n     let base_type_def_ids: hashmap<def_id,def_id>;\n \n     // A set of implementations in privileged scopes; i.e. those\n     // implementations that are defined in the same scope as their base types.\n+\n     let privileged_implementations: hashmap<node_id,()>;\n \n     // The set of types that we are currently in the privileged scope of. This\n     // is used while we traverse the AST while checking privileged scopes.\n+\n     let privileged_types: hashmap<def_id,()>;\n \n     new(crate_context: @crate_ctxt) {\n@@ -158,17 +162,7 @@ class CoherenceChecker {\n \n                 alt item.node {\n                     item_impl(_, associated_traits, self_type, _) {\n-                        // XXX: Accept an array of traits.\n-                        let optional_associated_trait;\n-                        if associated_traits.len() == 0 {\n-                            optional_associated_trait = none;\n-                        } else {\n-                            optional_associated_trait =\n-                                some(associated_traits[0]);\n-                        }\n-\n-                        self.check_implementation(item,\n-                                                  optional_associated_trait);\n+                        self.check_implementation(item, associated_traits);\n                     }\n                     _ {\n                         // Nothing to do.\n@@ -195,47 +189,49 @@ class CoherenceChecker {\n         self.add_external_crates();\n     }\n \n-    fn check_implementation(item: @item,\n-                            optional_associated_trait: option<@trait_ref>) {\n-\n+    fn check_implementation(item: @item, associated_traits: ~[@trait_ref]) {\n         let self_type = self.crate_context.tcx.tcache.get(local_def(item.id));\n-        alt optional_associated_trait {\n-            none {\n-                #debug(\"(checking implementation) no associated trait for \\\n-                        item '%s'\",\n-                       *item.ident);\n-\n-                alt get_base_type_def_id(self.inference_context,\n-                                         item.span,\n-                                         self_type.ty) {\n-                    none {\n-                        let session = self.crate_context.tcx.sess;\n-                        session.span_err(item.span,\n-                                         ~\"no base type found for inherent \\\n-                                           implementation; implement a \\\n-                                           trait instead\");\n-                    }\n-                    some(_) {\n-                        // Nothing to do.\n-                    }\n+\n+        // If there are no traits, then this implementation must have a\n+        // base type.\n+\n+        if associated_traits.len() == 0 {\n+            #debug(\"(checking implementation) no associated traits for item \\\n+                    '%s'\",\n+                   *item.ident);\n+\n+            alt get_base_type_def_id(self.inference_context,\n+                                     item.span,\n+                                     self_type.ty) {\n+                none {\n+                    let session = self.crate_context.tcx.sess;\n+                    session.span_err(item.span,\n+                                     ~\"no base type found for inherent \\\n+                                       implementation; implement a \\\n+                                       trait instead\");\n+                }\n+                some(_) {\n+                    // Nothing to do.\n                 }\n             }\n-            some(associated_trait) {\n-                let def = self.crate_context.tcx.def_map.get\n-                    (associated_trait.ref_id);\n-                #debug(\"(checking implementation) adding impl for trait \\\n-                        '%s', item '%s'\",\n-                       ast_map::node_id_to_str(self.crate_context.tcx.items,\n-                                               associated_trait.ref_id),\n-                       *item.ident);\n+        }\n \n-                let implementation = self.create_impl_from_item(item);\n-                self.add_trait_method(def_id_of_def(def), implementation);\n-            }\n+        for associated_traits.each |associated_trait| {\n+            let def = self.crate_context.tcx.def_map.get\n+                (associated_trait.ref_id);\n+            #debug(\"(checking implementation) adding impl for trait \\\n+                    '%s', item '%s'\",\n+                   ast_map::node_id_to_str(self.crate_context.tcx.items,\n+                                           associated_trait.ref_id),\n+                   *item.ident);\n+\n+            let implementation = self.create_impl_from_item(item);\n+            self.add_trait_method(def_id_of_def(def), implementation);\n         }\n \n         // Add the implementation to the mapping from implementation to base\n         // type def ID, if there is a base type for this implementation.\n+\n         alt get_base_type_def_id(self.inference_context,\n                                  item.span,\n                                  self_type.ty) {\n@@ -326,6 +322,7 @@ class CoherenceChecker {\n \n     // Converts a polytype to a monotype by replacing all parameters with\n     // type variables.\n+\n     fn universally_quantify_polytype(polytype: ty_param_bounds_and_ty) -> t {\n         let self_region =\n             if !polytype.rp {none}\n@@ -385,14 +382,6 @@ class CoherenceChecker {\n                         }\n                     }\n                     item_impl(_, associated_traits, _, _) {\n-                        // XXX: Accept an array of traits.\n-                        let optional_trait_ref;\n-                        if associated_traits.len() == 0 {\n-                            optional_trait_ref = none;\n-                        } else {\n-                            optional_trait_ref = some(associated_traits[0]);\n-                        }\n-\n                         alt self.base_type_def_ids.find(local_def(item.id)) {\n                             none {\n                                 // Nothing to do.\n@@ -411,56 +400,50 @@ class CoherenceChecker {\n                                 } else {\n                                     // This implementation is not in scope of\n                                     // its base type. This still might be OK\n-                                    // if the trait is defined in the same\n+                                    // if the traits are defined in the same\n                                     // crate.\n \n-                                    alt optional_trait_ref {\n-                                        none {\n-                                            // There is no trait to implement,\n-                                            // so this is an error.\n+                                    if associated_traits.len() == 0 {\n+                                        // There is no trait to implement, so\n+                                        // this is an error.\n+\n+                                        let session =\n+                                            self.crate_context.tcx.sess;\n+                                        session.span_err(item.span,\n+                                                         ~\"cannot implement \\\n+                                                          inherent methods \\\n+                                                          for a type outside \\\n+                                                          the scope the type \\\n+                                                          was defined in; \\\n+                                                          define and \\\n+                                                          implement a trait \\\n+                                                          instead\");\n+                                    }\n \n-                                            let session =\n-                                                self.crate_context.tcx.sess;\n+                                    for associated_traits.each |trait_ref| {\n+                                        // This is OK if and only if the\n+                                        // trait was defined in this\n+                                        // crate.\n+\n+                                        let def_map = self.crate_context.tcx\n+                                            .def_map;\n+                                        let trait_def = def_map.get\n+                                            (trait_ref.ref_id);\n+                                        let trait_id =\n+                                            def_id_of_def(trait_def);\n+                                        if trait_id.crate != local_crate {\n+                                            let session = self.crate_context\n+                                                .tcx.sess;\n                                             session.span_err(item.span,\n                                                              ~\"cannot \\\n-                                                              implement \\\n-                                                              inherent \\\n-                                                              methods for a \\\n-                                                              type outside \\\n-                                                              the scope the \\\n-                                                              type was \\\n-                                                              defined in; \\\n-                                                              define and \\\n-                                                              implement a \\\n-                                                              trait instead\");\n-                                        }\n-                                        some(trait_ref) {\n-                                            // This is OK if and only if the\n-                                            // trait was defined in this\n-                                            // crate.\n-\n-                                            let def_map = self.crate_context\n-                                                .tcx.def_map;\n-                                            let trait_def =\n-                                                def_map.get(trait_ref.ref_id);\n-                                            let trait_id =\n-                                                def_id_of_def(trait_def);\n-                                            if trait_id.crate != local_crate {\n-                                                let session = self\n-                                                    .crate_context.tcx.sess;\n-                                                session.span_err(item.span,\n-                                                                 ~\"cannot \\\n-                                                                   provide \\\n-                                                                   an \\\n-                                                                   extension \\\n-                                                                   implementa\\\n-                                                                      tion \\\n-                                                                   for a \\\n-                                                                   trait not \\\n-                                                                   defined \\\n-                                                                   in this \\\n-                                                                   crate\");\n-                                            }\n+                                                               provide an \\\n+                                                               extension \\\n+                                                               implementa\\\n+                                                                  tion \\\n+                                                               for a trait \\\n+                                                               not defined \\\n+                                                               in this \\\n+                                                               crate\");\n                                         }\n                                     }\n                                 }"}]}