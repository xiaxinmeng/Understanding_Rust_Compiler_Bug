{"sha": "22e53f1d33ec7be6ed0fce499166a90694fd068e", "node_id": "C_kwDOAAsO6NoAKDIyZTUzZjFkMzNlYzdiZTZlZDBmY2U0OTkxNjZhOTA2OTRmZDA2OGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-18T16:29:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-18T16:29:23Z"}, "message": "Auto merge of #12549 - bitgaoshu:goto_where_trait_m_impl, r=Veykril\n\nfeat: Go to implementation of trait methods\n\ntry goto where the trait method implies,  #4558", "tree": {"sha": "29228e666a51e1a14cbfb7932d6c2f63d9bc95b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29228e666a51e1a14cbfb7932d6c2f63d9bc95b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22e53f1d33ec7be6ed0fce499166a90694fd068e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22e53f1d33ec7be6ed0fce499166a90694fd068e", "html_url": "https://github.com/rust-lang/rust/commit/22e53f1d33ec7be6ed0fce499166a90694fd068e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22e53f1d33ec7be6ed0fce499166a90694fd068e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea416175d5401b85a3774a6b2c1e03281dac40c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea416175d5401b85a3774a6b2c1e03281dac40c3", "html_url": "https://github.com/rust-lang/rust/commit/ea416175d5401b85a3774a6b2c1e03281dac40c3"}, {"sha": "38c11bea217847d81da397881f754ae8a8e2725a", "url": "https://api.github.com/repos/rust-lang/rust/commits/38c11bea217847d81da397881f754ae8a8e2725a", "html_url": "https://github.com/rust-lang/rust/commit/38c11bea217847d81da397881f754ae8a8e2725a"}], "stats": {"total": 549, "additions": 419, "deletions": 130}, "files": [{"sha": "d2081d22d79dfc231166a242e57597730d693602", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 86, "deletions": 37, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=22e53f1d33ec7be6ed0fce499166a90694fd068e", "patch": "@@ -8,8 +8,9 @@ use arrayvec::ArrayVec;\n use base_db::{CrateId, Edition};\n use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n use hir_def::{\n-    item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId, ConstId, FunctionId,\n-    GenericDefId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n+    data::ImplData, item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId, ConstId,\n+    FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId,\n+    TraitId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -247,7 +248,7 @@ impl TraitImpls {\n         self.map\n             .get(&trait_)\n             .into_iter()\n-            .flat_map(move |map| map.get(&None).into_iter().chain(map.get(&Some(self_ty))))\n+            .flat_map(move |map| map.get(&Some(self_ty)).into_iter().chain(map.get(&None)))\n             .flat_map(|v| v.iter().copied())\n     }\n \n@@ -575,6 +576,59 @@ pub(crate) fn iterate_method_candidates<T>(\n     slot\n }\n \n+pub fn lookup_impl_method(\n+    self_ty: &Ty,\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    trait_: TraitId,\n+    name: &Name,\n+) -> Option<FunctionId> {\n+    let self_ty_fp = TyFingerprint::for_trait_impl(self_ty)?;\n+    let trait_impls = TraitImpls::trait_impls_in_deps_query(db, env.krate);\n+    let impls = trait_impls.for_trait_and_self_ty(trait_, self_ty_fp);\n+    let mut table = InferenceTable::new(db, env.clone());\n+    find_matching_impl(impls, &mut table, &self_ty).and_then(|data| {\n+        data.items.iter().find_map(|it| match it {\n+            AssocItemId::FunctionId(f) => (db.function_data(*f).name == *name).then(|| *f),\n+            _ => None,\n+        })\n+    })\n+}\n+\n+fn find_matching_impl(\n+    mut impls: impl Iterator<Item = ImplId>,\n+    table: &mut InferenceTable,\n+    self_ty: &Ty,\n+) -> Option<Arc<ImplData>> {\n+    let db = table.db;\n+    loop {\n+        let impl_ = impls.next()?;\n+        let r = table.run_in_snapshot(|table| {\n+            let impl_data = db.impl_data(impl_);\n+            let substs =\n+                TyBuilder::subst_for_def(db, impl_).fill_with_inference_vars(table).build();\n+            let impl_ty = db.impl_self_ty(impl_).substitute(Interner, &substs);\n+\n+            table\n+                .unify(self_ty, &impl_ty)\n+                .then(|| {\n+                    let wh_goals =\n+                        crate::chalk_db::convert_where_clauses(db, impl_.into(), &substs)\n+                            .into_iter()\n+                            .map(|b| b.cast(Interner));\n+\n+                    let goal = crate::Goal::all(Interner, wh_goals);\n+\n+                    table.try_obligation(goal).map(|_| impl_data)\n+                })\n+                .flatten()\n+        });\n+        if r.is_some() {\n+            break r;\n+        }\n+    }\n+}\n+\n pub fn iterate_path_candidates(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n@@ -970,18 +1024,31 @@ fn is_valid_candidate(\n     self_ty: &Ty,\n     visible_from_module: Option<ModuleId>,\n ) -> bool {\n+    macro_rules! check_that {\n+        ($cond:expr) => {\n+            if !$cond {\n+                return false;\n+            }\n+        };\n+    }\n+\n     let db = table.db;\n     match item {\n         AssocItemId::FunctionId(m) => {\n             let data = db.function_data(m);\n-            if let Some(name) = name {\n-                if &data.name != name {\n-                    return false;\n+\n+            check_that!(name.map_or(true, |n| n == &data.name));\n+            check_that!(visible_from_module.map_or(true, |from_module| {\n+                let v = db.function_visibility(m).is_visible_from(db.upcast(), from_module);\n+                if !v {\n+                    cov_mark::hit!(autoderef_candidate_not_visible);\n                 }\n-            }\n+                v\n+            }));\n+\n             table.run_in_snapshot(|table| {\n                 let subst = TyBuilder::subst_for_def(db, m).fill_with_inference_vars(table).build();\n-                let expected_self_ty = match m.lookup(db.upcast()).container {\n+                let expect_self_ty = match m.lookup(db.upcast()).container {\n                     ItemContainerId::TraitId(_) => {\n                         subst.at(Interner, 0).assert_ty_ref(Interner).clone()\n                     }\n@@ -993,49 +1060,31 @@ fn is_valid_candidate(\n                         unreachable!()\n                     }\n                 };\n-                if !table.unify(&expected_self_ty, &self_ty) {\n-                    return false;\n-                }\n+                check_that!(table.unify(&expect_self_ty, self_ty));\n                 if let Some(receiver_ty) = receiver_ty {\n-                    if !data.has_self_param() {\n-                        return false;\n-                    }\n+                    check_that!(data.has_self_param());\n \n                     let sig = db.callable_item_signature(m.into());\n                     let expected_receiver =\n                         sig.map(|s| s.params()[0].clone()).substitute(Interner, &subst);\n-                    let receiver_matches = table.unify(&receiver_ty, &expected_receiver);\n \n-                    if !receiver_matches {\n-                        return false;\n-                    }\n+                    check_that!(table.unify(&receiver_ty, &expected_receiver));\n                 }\n-                if let Some(from_module) = visible_from_module {\n-                    if !db.function_visibility(m).is_visible_from(db.upcast(), from_module) {\n-                        cov_mark::hit!(autoderef_candidate_not_visible);\n-                        return false;\n-                    }\n-                }\n-\n                 true\n             })\n         }\n         AssocItemId::ConstId(c) => {\n             let data = db.const_data(c);\n-            if receiver_ty.is_some() {\n-                return false;\n-            }\n-            if let Some(name) = name {\n-                if data.name.as_ref() != Some(name) {\n-                    return false;\n-                }\n-            }\n-            if let Some(from_module) = visible_from_module {\n-                if !db.const_visibility(c).is_visible_from(db.upcast(), from_module) {\n+            check_that!(receiver_ty.is_none());\n+\n+            check_that!(name.map_or(true, |n| data.name.as_ref() == Some(n)));\n+            check_that!(visible_from_module.map_or(true, |from_module| {\n+                let v = db.const_visibility(c).is_visible_from(db.upcast(), from_module);\n+                if !v {\n                     cov_mark::hit!(const_candidate_not_visible);\n-                    return false;\n                 }\n-            }\n+                v\n+            }));\n             if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n                 let self_ty_matches = table.run_in_snapshot(|table| {\n                     let subst ="}, {"sha": "744f3865aaa4c277ee18915d5d260f6b2ea7d075", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=22e53f1d33ec7be6ed0fce499166a90694fd068e", "patch": "@@ -16,7 +16,6 @@ use hir_expand::{\n     name::{known, AsName},\n     ExpansionInfo, MacroCallId,\n };\n-use hir_ty::Interner;\n use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n use smallvec::{smallvec, SmallVec};\n@@ -975,18 +974,11 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<FunctionId> {\n-        self.analyze(call.syntax())?.resolve_method_call(self.db, call).map(|(id, _)| id)\n+        self.analyze(call.syntax())?.resolve_method_call(self.db, call)\n     }\n \n     fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n-        let source_analyzer = self.analyze(call.syntax())?;\n-        let (func, subst) = source_analyzer.resolve_method_call(self.db, call)?;\n-        let ty = self.db.value_ty(func.into()).substitute(Interner, &subst);\n-        let resolver = source_analyzer.resolver;\n-        let ty = Type::new_with_resolver(self.db, &resolver, ty);\n-        let mut res = ty.as_callable(self.db)?;\n-        res.is_bound_method = true;\n-        Some(res)\n+        self.analyze(call.syntax())?.resolve_method_call_as_callable(self.db, call)\n     }\n \n     fn resolve_field(&self, field: &ast::FieldExpr) -> Option<Field> {"}, {"sha": "984a464ed162b51e261f12897126fb7529fffef9", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=22e53f1d33ec7be6ed0fce499166a90694fd068e", "patch": "@@ -21,7 +21,8 @@ use hir_def::{\n     path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     type_ref::Mutability,\n-    AsMacroCall, DefWithBodyId, FieldId, FunctionId, LocalFieldId, Lookup, ModuleDefId, VariantId,\n+    AsMacroCall, AssocItemId, DefWithBodyId, FieldId, FunctionId, ItemContainerId, LocalFieldId,\n+    Lookup, ModuleDefId, VariantId,\n };\n use hir_expand::{\n     builtin_fn_macro::BuiltinFnLikeExpander, hygiene::Hygiene, name::AsName, HirFileId, InFile,\n@@ -31,8 +32,8 @@ use hir_ty::{\n         record_literal_missing_fields, record_pattern_missing_fields, unsafe_expressions,\n         UnsafeExpr,\n     },\n-    Adjust, Adjustment, AutoBorrow, InferenceResult, Interner, Substitution, TyExt,\n-    TyLoweringContext,\n+    method_resolution, Adjust, Adjustment, AutoBorrow, InferenceResult, Interner, Substitution,\n+    TyExt, TyKind, TyLoweringContext,\n };\n use smallvec::SmallVec;\n use syntax::{\n@@ -42,8 +43,8 @@ use syntax::{\n \n use crate::{\n     db::HirDatabase, semantics::PathResolution, Adt, AssocItem, BindingMode, BuiltinAttr,\n-    BuiltinType, Const, Field, Function, Local, Macro, ModuleDef, Static, Struct, ToolModule,\n-    Trait, Type, TypeAlias, Variant,\n+    BuiltinType, Callable, Const, Field, Function, Local, Macro, ModuleDef, Static, Struct,\n+    ToolModule, Trait, Type, TypeAlias, Variant,\n };\n \n /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n@@ -232,13 +233,29 @@ impl SourceAnalyzer {\n         )\n     }\n \n+    pub(crate) fn resolve_method_call_as_callable(\n+        &self,\n+        db: &dyn HirDatabase,\n+        call: &ast::MethodCallExpr,\n+    ) -> Option<Callable> {\n+        let expr_id = self.expr_id(db, &call.clone().into())?;\n+        let (func, substs) = self.infer.as_ref()?.method_resolution(expr_id)?;\n+        let ty = db.value_ty(func.into()).substitute(Interner, &substs);\n+        let ty = Type::new_with_resolver(db, &self.resolver, ty);\n+        let mut res = ty.as_callable(db)?;\n+        res.is_bound_method = true;\n+        Some(res)\n+    }\n+\n     pub(crate) fn resolve_method_call(\n         &self,\n         db: &dyn HirDatabase,\n         call: &ast::MethodCallExpr,\n-    ) -> Option<(FunctionId, Substitution)> {\n+    ) -> Option<FunctionId> {\n         let expr_id = self.expr_id(db, &call.clone().into())?;\n-        self.infer.as_ref()?.method_resolution(expr_id)\n+        let (f_in_trait, substs) = self.infer.as_ref()?.method_resolution(expr_id)?;\n+        let f_in_impl = self.resolve_impl_method(db, f_in_trait, &substs);\n+        f_in_impl.or(Some(f_in_trait))\n     }\n \n     pub(crate) fn resolve_field(\n@@ -336,6 +353,25 @@ impl SourceAnalyzer {\n                 let expr_id = self.expr_id(db, &path_expr.into())?;\n                 let infer = self.infer.as_ref()?;\n                 if let Some(assoc) = infer.assoc_resolutions_for_expr(expr_id) {\n+                    let assoc = match assoc {\n+                        AssocItemId::FunctionId(f_in_trait) => {\n+                            match infer.type_of_expr.get(expr_id) {\n+                                None => assoc,\n+                                Some(func_ty) => {\n+                                    if let TyKind::FnDef(_fn_def, subs) = func_ty.kind(Interner) {\n+                                        self.resolve_impl_method(db, f_in_trait, subs)\n+                                            .map(AssocItemId::FunctionId)\n+                                            .unwrap_or(assoc)\n+                                    } else {\n+                                        assoc\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                        _ => assoc,\n+                    };\n+\n                     return Some(PathResolution::Def(AssocItem::from(assoc).into()));\n                 }\n                 if let Some(VariantId::EnumVariantId(variant)) =\n@@ -563,6 +599,30 @@ impl SourceAnalyzer {\n         }\n         false\n     }\n+\n+    fn resolve_impl_method(\n+        &self,\n+        db: &dyn HirDatabase,\n+        func: FunctionId,\n+        substs: &Substitution,\n+    ) -> Option<FunctionId> {\n+        let impled_trait = match func.lookup(db.upcast()).container {\n+            ItemContainerId::TraitId(trait_id) => trait_id,\n+            _ => return None,\n+        };\n+        if substs.is_empty(Interner) {\n+            return None;\n+        }\n+        let self_ty = substs.at(Interner, 0).ty(Interner)?;\n+        let krate = self.resolver.krate();\n+        let trait_env = self.resolver.body_owner()?.as_generic_def_id().map_or_else(\n+            || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n+            |d| db.trait_environment(d),\n+        );\n+\n+        let fun_data = db.function_data(func);\n+        method_resolution::lookup_impl_method(self_ty, db, trait_env, impled_trait, &fun_data.name)\n+    }\n }\n \n fn scope_for("}, {"sha": "61cb2f04792713d1027633dd9f5f1c7c5f1782d4", "filename": "crates/ide-assists/src/handlers/qualify_method_call.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs?ref=22e53f1d33ec7be6ed0fce499166a90694fd068e", "patch": "@@ -1,8 +1,5 @@\n-use hir::{ItemInNs, ModuleDef};\n-use ide_db::{\n-    assists::{AssistId, AssistKind},\n-    imports::import_assets::item_for_path_search,\n-};\n+use hir::{db::HirDatabase, AsAssocItem, AssocItem, AssocItemContainer, ItemInNs, ModuleDef};\n+use ide_db::assists::{AssistId, AssistKind};\n use syntax::{ast, AstNode};\n \n use crate::{\n@@ -67,6 +64,26 @@ pub(crate) fn qualify_method_call(acc: &mut Assists, ctx: &AssistContext) -> Opt\n     Some(())\n }\n \n+fn item_for_path_search(db: &dyn HirDatabase, item: ItemInNs) -> Option<ItemInNs> {\n+    Some(match item {\n+        ItemInNs::Types(_) | ItemInNs::Values(_) => match item_as_assoc(db, item) {\n+            Some(assoc_item) => match assoc_item.container(db) {\n+                AssocItemContainer::Trait(trait_) => ItemInNs::from(ModuleDef::from(trait_)),\n+                AssocItemContainer::Impl(impl_) => match impl_.trait_(db) {\n+                    None => ItemInNs::from(ModuleDef::from(impl_.self_ty(db).as_adt()?)),\n+                    Some(trait_) => ItemInNs::from(ModuleDef::from(trait_)),\n+                },\n+            },\n+            None => item,\n+        },\n+        ItemInNs::Macros(_) => item,\n+    })\n+}\n+\n+fn item_as_assoc(db: &dyn HirDatabase, item: ItemInNs) -> Option<AssocItem> {\n+    item.as_module_def().and_then(|module_def| module_def.as_assoc_item(db))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "779cdbc93c54a59d01914edbc84d2056ae61a608", "filename": "crates/ide-assists/src/utils/suggest_name.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=22e53f1d33ec7be6ed0fce499166a90694fd068e", "patch": "@@ -460,6 +460,21 @@ fn foo() { S.bar($01$0, 2) }\n         );\n     }\n \n+    #[test]\n+    fn method_on_impl_trait() {\n+        check(\n+            r#\"\n+struct S;\n+trait T {\n+    fn bar(&self, n: i32, m: u32);\n+}\n+impl T for S { fn bar(&self, n: i32, m: u32); }\n+fn foo() { S.bar($01$0, 2) }\n+\"#,\n+            \"n\",\n+        );\n+    }\n+\n     #[test]\n     fn method_ufcs() {\n         check("}, {"sha": "c2e7142f52fd165af70ba585d58cd23d82ee6895", "filename": "crates/ide-db/src/rename.rs", "status": "modified", "additions": 4, "deletions": 37, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Frename.rs?ref=22e53f1d33ec7be6ed0fce499166a90694fd068e", "patch": "@@ -24,7 +24,7 @@ use std::fmt;\n \n use base_db::{AnchoredPathBuf, FileId, FileRange};\n use either::Either;\n-use hir::{AsAssocItem, FieldSource, HasSource, InFile, ModuleSource, Semantics};\n+use hir::{FieldSource, HasSource, InFile, ModuleSource, Semantics};\n use stdx::never;\n use syntax::{\n     ast::{self, HasName},\n@@ -37,6 +37,7 @@ use crate::{\n     search::FileReference,\n     source_change::{FileSystemEdit, SourceChange},\n     syntax_helpers::node_ext::expr_as_name_ref,\n+    traits::convert_to_def_in_trait,\n     RootDatabase,\n };\n \n@@ -248,7 +249,7 @@ fn rename_mod(\n \n fn rename_reference(\n     sema: &Semantics<RootDatabase>,\n-    mut def: Definition,\n+    def: Definition,\n     new_name: &str,\n ) -> Result<SourceChange> {\n     let ident_kind = IdentifierKind::classify(new_name)?;\n@@ -275,41 +276,7 @@ fn rename_reference(\n         }\n     }\n \n-    let assoc_item = match def {\n-        // HACK: resolve trait impl items to the item def of the trait definition\n-        // so that we properly resolve all trait item references\n-        Definition::Function(it) => it.as_assoc_item(sema.db),\n-        Definition::TypeAlias(it) => it.as_assoc_item(sema.db),\n-        Definition::Const(it) => it.as_assoc_item(sema.db),\n-        _ => None,\n-    };\n-    def = match assoc_item {\n-        Some(assoc) => assoc\n-            .containing_trait_impl(sema.db)\n-            .and_then(|trait_| {\n-                trait_.items(sema.db).into_iter().find_map(|it| match (it, assoc) {\n-                    (hir::AssocItem::Function(trait_func), hir::AssocItem::Function(func))\n-                        if trait_func.name(sema.db) == func.name(sema.db) =>\n-                    {\n-                        Some(Definition::Function(trait_func))\n-                    }\n-                    (hir::AssocItem::Const(trait_konst), hir::AssocItem::Const(konst))\n-                        if trait_konst.name(sema.db) == konst.name(sema.db) =>\n-                    {\n-                        Some(Definition::Const(trait_konst))\n-                    }\n-                    (\n-                        hir::AssocItem::TypeAlias(trait_type_alias),\n-                        hir::AssocItem::TypeAlias(type_alias),\n-                    ) if trait_type_alias.name(sema.db) == type_alias.name(sema.db) => {\n-                        Some(Definition::TypeAlias(trait_type_alias))\n-                    }\n-                    _ => None,\n-                })\n-            })\n-            .unwrap_or(def),\n-        None => def,\n-    };\n+    let def = convert_to_def_in_trait(sema.db, def);\n     let usages = def.usages(sema).all();\n \n     if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {"}, {"sha": "692fce06b0fcb0f5d2261f1221a70bc4909e01dc", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=22e53f1d33ec7be6ed0fce499166a90694fd068e", "patch": "@@ -16,6 +16,7 @@ use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n \n use crate::{\n     defs::{Definition, NameClass, NameRefClass},\n+    traits::convert_to_def_in_trait,\n     RootDatabase,\n };\n \n@@ -619,7 +620,9 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(file_id, reference)\n             }\n-            Some(NameRefClass::Definition(def)) if def == self.def => {\n+            Some(NameRefClass::Definition(def))\n+                if convert_to_def_in_trait(self.sema.db, def) == self.def =>\n+            {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = FileReference {\n                     range,"}, {"sha": "666499ed7a5e3ae6bc8b9599cdd135e13335fd0a", "filename": "crates/ide-db/src/traits.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide-db%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide-db%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Ftraits.rs?ref=22e53f1d33ec7be6ed0fce499166a90694fd068e", "patch": "@@ -1,7 +1,7 @@\n //! Functionality for obtaining data related to traits from the DB.\n \n-use crate::RootDatabase;\n-use hir::Semantics;\n+use crate::{defs::Definition, RootDatabase};\n+use hir::{db::HirDatabase, AsAssocItem, Semantics};\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n \n@@ -69,6 +69,28 @@ pub fn get_missing_assoc_items(\n     })\n }\n \n+/// Converts associated trait impl items to their trait definition counterpart\n+pub(crate) fn convert_to_def_in_trait(db: &dyn HirDatabase, def: Definition) -> Definition {\n+    use hir::AssocItem::*;\n+    (|| {\n+        let assoc = def.as_assoc_item(db)?;\n+        let trait_ = assoc.containing_trait_impl(db)?;\n+        let name = match assoc {\n+            Function(it) => it.name(db),\n+            Const(it) => it.name(db)?,\n+            TypeAlias(it) => it.name(db),\n+        };\n+        let item = trait_.items(db).into_iter().find(|it| match (it, assoc) {\n+            (Function(trait_func), Function(_)) => trait_func.name(db) == name,\n+            (Const(trait_konst), Const(_)) => trait_konst.name(db).map_or(false, |it| it == name),\n+            (TypeAlias(trait_type_alias), TypeAlias(_)) => trait_type_alias.name(db) == name,\n+            _ => false,\n+        })?;\n+        Some(Definition::from(item))\n+    })()\n+    .unwrap_or(def)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use base_db::{fixture::ChangeFixture, FilePosition};"}, {"sha": "e10789fd47aed9f7deb0333c1d9e5d5ae62f4d3b", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 189, "deletions": 29, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=22e53f1d33ec7be6ed0fce499166a90694fd068e", "patch": "@@ -1,7 +1,7 @@\n-use std::convert::TryInto;\n+use std::{convert::TryInto, mem::discriminant};\n \n use crate::{doc_links::token_as_doc_comment, FilePosition, NavigationTarget, RangeInfo, TryToNav};\n-use hir::{AsAssocItem, Semantics};\n+use hir::{AsAssocItem, AssocItem, Semantics};\n use ide_db::{\n     base_db::{AnchoredPath, FileId, FileLoader},\n     defs::{Definition, IdentClass},\n@@ -65,7 +65,7 @@ pub(crate) fn goto_definition(\n                     .definitions()\n                     .into_iter()\n                     .flat_map(|def| {\n-                        try_find_trait_item_definition(sema.db, &def)\n+                        try_filter_trait_item_definition(sema, &def)\n                             .unwrap_or_else(|| def_to_nav(sema.db, def))\n                     })\n                     .collect(),\n@@ -104,32 +104,37 @@ fn try_lookup_include_path(\n         docs: None,\n     })\n }\n-\n-/// finds the trait definition of an impl'd item\n+/// finds the trait definition of an impl'd item, except function\n /// e.g.\n /// ```rust\n-/// trait A { fn a(); }\n+/// trait A { type a; }\n /// struct S;\n-/// impl A for S { fn a(); } // <-- on this function, will get the location of a() in the trait\n+/// impl A for S { type a = i32; } // <-- on this associate type, will get the location of a in the trait\n /// ```\n-fn try_find_trait_item_definition(\n-    db: &RootDatabase,\n+fn try_filter_trait_item_definition(\n+    sema: &Semantics<RootDatabase>,\n     def: &Definition,\n ) -> Option<Vec<NavigationTarget>> {\n-    let name = def.name(db)?;\n+    let db = sema.db;\n     let assoc = def.as_assoc_item(db)?;\n-\n-    let imp = match assoc.container(db) {\n-        hir::AssocItemContainer::Impl(imp) => imp,\n-        _ => return None,\n-    };\n-\n-    let trait_ = imp.trait_(db)?;\n-    trait_\n-        .items(db)\n-        .iter()\n-        .find_map(|itm| (itm.name(db)? == name).then(|| itm.try_to_nav(db)).flatten())\n-        .map(|it| vec![it])\n+    match assoc {\n+        AssocItem::Function(..) => None,\n+        AssocItem::Const(..) | AssocItem::TypeAlias(..) => {\n+            let imp = match assoc.container(db) {\n+                hir::AssocItemContainer::Impl(imp) => imp,\n+                _ => return None,\n+            };\n+            let trait_ = imp.trait_(db)?;\n+            let name = def.name(db)?;\n+            let discri_value = discriminant(&assoc);\n+            trait_\n+                .items(db)\n+                .iter()\n+                .filter(|itm| discriminant(*itm) == discri_value)\n+                .find_map(|itm| (itm.name(db)? == name).then(|| itm.try_to_nav(db)).flatten())\n+                .map(|it| vec![it])\n+        }\n+    }\n }\n \n fn def_to_nav(db: &RootDatabase, def: Definition) -> Vec<NavigationTarget> {\n@@ -172,6 +177,23 @@ mod tests {\n         assert!(navs.is_empty(), \"didn't expect this to resolve anywhere: {:?}\", navs)\n     }\n \n+    #[test]\n+    fn goto_def_if_items_same_name() {\n+        check(\n+            r#\"\n+trait Trait {\n+    type A;\n+    const A: i32;\n+        //^\n+}\n+\n+struct T;\n+impl Trait for T {\n+    type A = i32;\n+    const A$0: i32 = -9;\n+}\"#,\n+        );\n+    }\n     #[test]\n     fn goto_def_in_mac_call_in_attr_invoc() {\n         check(\n@@ -1331,23 +1353,161 @@ fn main() {\n \"#,\n         );\n     }\n-\n-    #[test]\n-    fn goto_def_of_trait_impl_fn() {\n-        check(\n-            r#\"\n+    #[cfg(test)]\n+    mod goto_impl_of_trait_fn {\n+        use super::check;\n+        #[test]\n+        fn cursor_on_impl() {\n+            check(\n+                r#\"\n trait Twait {\n     fn a();\n-    // ^\n }\n \n struct Stwuct;\n \n impl Twait for Stwuct {\n     fn a$0();\n+     //^\n+}\n+        \"#,\n+            );\n+        }\n+        #[test]\n+        fn method_call() {\n+            check(\n+                r#\"\n+trait Twait {\n+    fn a(&self);\n+}\n+\n+struct Stwuct;\n+\n+impl Twait for Stwuct {\n+    fn a(&self){};\n+     //^\n+}\n+fn f() {\n+    let s = Stwuct;\n+    s.a$0();\n+}\n+        \"#,\n+            );\n+        }\n+        #[test]\n+        fn path_call() {\n+            check(\n+                r#\"\n+trait Twait {\n+    fn a(&self);\n+}\n+\n+struct Stwuct;\n+\n+impl Twait for Stwuct {\n+    fn a(&self){};\n+     //^\n+}\n+fn f() {\n+    let s = Stwuct;\n+    Stwuct::a$0(&s);\n+}\n+        \"#,\n+            );\n+        }\n+        #[test]\n+        fn where_clause_can_work() {\n+            check(\n+                r#\"\n+trait G {\n+    fn g(&self);\n+}\n+trait Bound{}\n+trait EA{}\n+struct Gen<T>(T);\n+impl <T:EA> G for Gen<T> {\n+    fn g(&self) {\n+    }\n+}\n+impl <T> G for Gen<T>\n+where T : Bound\n+{\n+    fn g(&self){\n+     //^\n+    }\n+}\n+struct A;\n+impl Bound for A{}\n+fn f() {\n+    let gen = Gen::<A>(A);\n+    gen.g$0();\n+}\n+                \"#,\n+            );\n+        }\n+        #[test]\n+        fn wc_case_is_ok() {\n+            check(\n+                r#\"\n+trait G {\n+    fn g(&self);\n+}\n+trait BParent{}\n+trait Bound: BParent{}\n+struct Gen<T>(T);\n+impl <T> G for Gen<T>\n+where T : Bound\n+{\n+    fn g(&self){\n+     //^\n+    }\n+}\n+struct A;\n+impl Bound for A{}\n+fn f() {\n+    let gen = Gen::<A>(A);\n+    gen.g$0();\n }\n \"#,\n-        );\n+            );\n+        }\n+\n+        #[test]\n+        fn method_call_defaulted() {\n+            check(\n+                r#\"\n+trait Twait {\n+    fn a(&self) {}\n+     //^\n+}\n+\n+struct Stwuct;\n+\n+impl Twait for Stwuct {\n+}\n+fn f() {\n+    let s = Stwuct;\n+    s.a$0();\n+}\n+        \"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn method_call_on_generic() {\n+            check(\n+                r#\"\n+trait Twait {\n+    fn a(&self) {}\n+     //^\n+}\n+\n+fn f<T: Twait>(s: T) {\n+    s.a$0();\n+}\n+        \"#,\n+            );\n+        }\n     }\n \n     #[test]"}, {"sha": "788cbe9272308f1982b4dbd51e11e42cb5a95f0e", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=22e53f1d33ec7be6ed0fce499166a90694fd068e", "patch": "@@ -510,7 +510,11 @@ fn highlight_method_call(\n     if func.is_async(sema.db) {\n         h |= HlMod::Async;\n     }\n-    if func.as_assoc_item(sema.db).and_then(|it| it.containing_trait(sema.db)).is_some() {\n+    if func\n+        .as_assoc_item(sema.db)\n+        .and_then(|it| it.containing_trait_or_trait_impl(sema.db))\n+        .is_some()\n+    {\n         h |= HlMod::Trait;\n     }\n "}, {"sha": "884224960f51565f07513e4ab43c3307beaea719", "filename": "crates/rust-analyzer/tests/slow-tests/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e53f1d33ec7be6ed0fce499166a90694fd068e/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs?ref=22e53f1d33ec7be6ed0fce499166a90694fd068e", "patch": "@@ -919,7 +919,7 @@ pub fn foo(_input: TokenStream) -> TokenStream {\n     expect![[r#\"\n \n         ```rust\n-        foo::Bar\n+        foo::Foo\n         ```\n \n         ```rust"}]}