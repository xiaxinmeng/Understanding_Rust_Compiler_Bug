{"sha": "4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjOTA0OWM1MGM1YzMyZjU1NmVhZWZiY2M1MDIwOWVmOGVlMzUzZDA=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-08-12T13:37:10Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-16T22:05:56Z"}, "message": "Port the stdlib to the decl foo<T> syntax.", "tree": {"sha": "bfb83e800b3ebbba65beb080dad463f72da4ac73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfb83e800b3ebbba65beb080dad463f72da4ac73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "html_url": "https://github.com/rust-lang/rust/commit/4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21f46a1655f2a026546792546b07dec9e039ec54", "url": "https://api.github.com/repos/rust-lang/rust/commits/21f46a1655f2a026546792546b07dec9e039ec54", "html_url": "https://github.com/rust-lang/rust/commit/21f46a1655f2a026546792546b07dec9e039ec54"}], "stats": {"total": 288, "additions": 144, "deletions": 144}, "files": [{"sha": "94132a7f7f84c40b99acd8b22f453a9fe2ac5a4a", "filename": "src/lib/box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbox.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -1,8 +1,8 @@\n \n export ptr_eq;\n \n-fn ptr_eq[T](a: &@T, b: &@T) -> bool {\n+fn ptr_eq<T>(a: &@T, b: &@T) -> bool {\n     let a_ptr: uint = unsafe::reinterpret_cast(a);\n     let b_ptr: uint = unsafe::reinterpret_cast(b);\n     ret a_ptr == b_ptr;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "2fe0dc2bcaac2fe64bee64bc761ef71a52f2297d", "filename": "src/lib/comm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fcomm.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -20,7 +20,7 @@ native \"rust\" mod rustrt {\n     fn take_chan(ch : *rust_chan);\n     fn drop_chan(ch : *rust_chan);\n     fn chan_send(ch: *rust_chan, v : *void);\n-    fn chan_id_send[~T](target_task : task_id, target_port : port_id,\n+    fn chan_id_send<~T>(target_task : task_id, target_port : port_id,\n                         data : -T);\n \n     fn new_port(unit_sz : uint) -> *rust_port;\n@@ -30,12 +30,12 @@ native \"rust\" mod rustrt {\n }\n \n native \"rust-intrinsic\" mod rusti {\n-    fn recv[~T](port : *rustrt::rust_port) -> T;\n+    fn recv<~T>(port : *rustrt::rust_port) -> T;\n }\n \n type port_id = int;\n \n-type _chan[~T] = {\n+type _chan<~T> = {\n     task : task_id,\n     port : port_id\n };\n@@ -45,9 +45,9 @@ resource port_ptr(po: *rustrt::rust_port) {\n     rustrt::del_port(po);\n }\n \n-obj _port[~T](raw_port : @port_ptr) {\n+obj _port<~T>(raw_port : @port_ptr) {\n     // FIXME: rename this to chan once chan is not a keyword.\n-    fn mk_chan() -> _chan[T] {\n+    fn mk_chan() -> _chan<T> {\n         {\n             task: task::get_task_id(),\n             port: rustrt::get_port_id(**raw_port)\n@@ -59,10 +59,10 @@ obj _port[~T](raw_port : @port_ptr) {\n     }\n }\n \n-fn mk_port[~T]() -> _port<T> {\n+fn mk_port<~T>() -> _port<T> {\n     _port(@port_ptr(rustrt::new_port(sys::size_of[T]())))\n }\n \n-fn send[~T](ch : _chan[T], data : -T) {\n+fn send<~T>(ch : _chan<T>, data : -T) {\n     rustrt::chan_id_send(ch.task, ch.port, data);\n }"}, {"sha": "543f22bffe6c93723ec29af428f9b2c7524f8f37", "filename": "src/lib/dbg.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdbg.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -12,23 +12,23 @@\n const const_refcount: uint = 0x7bad_face_u;\n \n native \"rust\" mod rustrt {\n-    fn debug_tydesc[T]();\n-    fn debug_opaque[T](x: &T);\n-    fn debug_box[T](x: @T);\n-    fn debug_tag[T](x: &T);\n-    fn debug_obj[T](x: &T, nmethods: uint, nbytes: uint);\n-    fn debug_fn[T](x: &T);\n-    fn debug_ptrcast[T, U](x: @T) -> @U;\n+    fn debug_tydesc<T>();\n+    fn debug_opaque<T>(x: &T);\n+    fn debug_box<T>(x: @T);\n+    fn debug_tag<T>(x: &T);\n+    fn debug_obj<T>(x: &T, nmethods: uint, nbytes: uint);\n+    fn debug_fn<T>(x: &T);\n+    fn debug_ptrcast<T, U>(x: @T) -> @U;\n     fn debug_trap(msg: str);\n }\n \n fn debug_tydesc[T]() { rustrt::debug_tydesc[T](); }\n \n-fn debug_opaque[T](x: &T) { rustrt::debug_opaque[T](x); }\n+fn debug_opaque<T>(x: &T) { rustrt::debug_opaque[T](x); }\n \n-fn debug_box[T](x: @T) { rustrt::debug_box[T](x); }\n+fn debug_box<T>(x: @T) { rustrt::debug_box[T](x); }\n \n-fn debug_tag[T](x: &T) { rustrt::debug_tag[T](x); }\n+fn debug_tag<T>(x: &T) { rustrt::debug_tag[T](x); }\n \n \n /**\n@@ -40,13 +40,13 @@ fn debug_tag[T](x: &T) { rustrt::debug_tag[T](x); }\n  * this to at least be 4u, since an implicit captured tydesc pointer sits in\n  * the front of any obj's data tuple.x\n  */\n-fn debug_obj[T](x: &T, nmethods: uint, nbytes: uint) {\n+fn debug_obj<T>(x: &T, nmethods: uint, nbytes: uint) {\n     rustrt::debug_obj[T](x, nmethods, nbytes);\n }\n \n-fn debug_fn[T](x: &T) { rustrt::debug_fn[T](x); }\n+fn debug_fn<T>(x: &T) { rustrt::debug_fn[T](x); }\n \n-fn ptr_cast[T, U](x: @T) -> @U { ret rustrt::debug_ptrcast[T, U](x); }\n+fn ptr_cast<T, U>(x: @T) -> @U { ret rustrt::debug_ptrcast[T, U](x); }\n \n fn trap(s: str) { rustrt::debug_trap(s); }\n // Local Variables:"}, {"sha": "bda06870efeb1bcb8f876e3325067ab570ba5c97", "filename": "src/lib/deque.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -4,7 +4,7 @@\n /**\n  * A deque, for fun.  Untested as of yet.  Likely buggy.\n  */\n-type t[T] =\n+type t<T> =\n     obj {\n         fn size() -> uint ;\n         fn add_front(&T) ;\n@@ -16,8 +16,8 @@ type t[T] =\n         fn get(int) -> T ;\n     };\n \n-fn create[@T]() -> t<T> {\n-    type cell[T] = option::t<T>;\n+fn create<@T>() -> t<T> {\n+    type cell<T> = option::t<T>;\n \n     let initial_capacity: uint = 32u; // 2^5\n      /**\n@@ -26,7 +26,7 @@ fn create[@T]() -> t<T> {\n       */\n \n \n-    fn grow[@T](nelts: uint, lo: uint, elts: &[mutable cell<T>]) ->\n+    fn grow<@T>(nelts: uint, lo: uint, elts: &[mutable cell<T>]) ->\n        [mutable cell<T>] {\n         assert (nelts == vec::len(elts));\n         let rv = ~[mutable];\n@@ -42,10 +42,10 @@ fn create[@T]() -> t<T> {\n \n         ret rv;\n     }\n-    fn get[@T](elts: &[mutable cell<T>], i: uint) -> T {\n+    fn get<@T>(elts: &[mutable cell<T>], i: uint) -> T {\n         ret alt elts.(i) { option::some(t) { t } _ { fail } };\n     }\n-    obj deque[@T](mutable nelts: uint,\n+    obj deque<@T>(mutable nelts: uint,\n                   mutable lo: uint,\n                   mutable hi: uint,\n                   mutable elts: [mutable cell<T>]) {"}, {"sha": "95f1d9aca2179ef8afe90bcafe96f7014667561f", "filename": "src/lib/either.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -3,30 +3,30 @@ import option;\n import option::some;\n import option::none;\n \n-tag t[T, U] { left(T); right(U); }\n+tag t<T, U> { left(T); right(U); }\n \n-fn either[T, U, V](f_left: &block(&T) -> V, f_right: &block(&U) -> V,\n+fn either<T, U, V>(f_left: &block(&T) -> V, f_right: &block(&U) -> V,\n                    value: &t<T, U>) -> V {\n     alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n }\n \n-fn lefts[T, U](eithers: &[t<T, U>]) -> [T] {\n+fn lefts<T, U>(eithers: &[t<T, U>]) -> [T] {\n     let result: [T] = ~[];\n     for elt: t<T, U> in eithers {\n         alt elt { left(l) { result += ~[l] } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn rights[T, U](eithers: &[t<T, U>]) -> [U] {\n+fn rights<T, U>(eithers: &[t<T, U>]) -> [U] {\n     let result: [U] = ~[];\n     for elt: t<T, U> in eithers {\n         alt elt { right(r) { result += ~[r] } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn partition[T, U](eithers: &[t<T, U>]) -> {lefts: [T], rights: [U]} {\n+fn partition<T, U>(eithers: &[t<T, U>]) -> {lefts: [T], rights: [U]} {\n     let lefts: [T] = ~[];\n     let rights: [U] = ~[];\n     for elt: t<T, U> in eithers {"}, {"sha": "abc0c363d41cec3fb99f215dfa80792301190d21", "filename": "src/lib/list.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -1,9 +1,9 @@\n import option::some;\n import option::none;\n \n-tag list[T] { cons(T, @list<T>); nil; }\n+tag list<T> { cons(T, @list<T>); nil; }\n \n-fn from_vec[@T](v: &[T]) -> list<T> {\n+fn from_vec<@T>(v: &[T]) -> list<T> {\n     let l = nil[T];\n     // FIXME: This would be faster and more space efficient if it looped over\n     // a reverse vector iterator. Unfortunately generic iterators seem not to\n@@ -13,7 +13,7 @@ fn from_vec[@T](v: &[T]) -> list<T> {\n     ret l;\n }\n \n-fn foldl[@T, @U](ls_: &list<T>, u: &U, f: &block(&T, &U) -> U ) -> U {\n+fn foldl<@T, @U>(ls_: &list<T>, u: &U, f: &block(&T, &U) -> U ) -> U {\n     let accum: U = u;\n     let ls = ls_;\n     while true {\n@@ -25,7 +25,7 @@ fn foldl[@T, @U](ls_: &list<T>, u: &U, f: &block(&T, &U) -> U ) -> U {\n     ret accum;\n }\n \n-fn find[@T, @U](ls_: &list<T>, f: &block(&T) -> option::t<U>)\n+fn find<@T, @U>(ls_: &list<T>, f: &block(&T) -> option::t<U>)\n     -> option::t<U> {\n     let ls = ls_;\n     while true {\n@@ -39,7 +39,7 @@ fn find[@T, @U](ls_: &list<T>, f: &block(&T) -> option::t<U>)\n     ret none;\n }\n \n-fn has[@T](ls_: &list<T>, elt: &T) -> bool {\n+fn has<@T>(ls_: &list<T>, elt: &T) -> bool {\n     let ls = ls_;\n     while true {\n         alt ls {\n@@ -50,26 +50,26 @@ fn has[@T](ls_: &list<T>, elt: &T) -> bool {\n     ret false;\n }\n \n-fn length[@T](ls: &list<T>) -> uint {\n-    fn count[T](t: &T, u: &uint) -> uint { ret u + 1u; }\n+fn length<@T>(ls: &list<T>) -> uint {\n+    fn count<T>(t: &T, u: &uint) -> uint { ret u + 1u; }\n     ret foldl(ls, 0u, count);\n }\n \n-fn cdr[@T](ls: &list<T>) -> list<T> {\n+fn cdr<@T>(ls: &list<T>) -> list<T> {\n     alt ls {\n       cons(_, tl) { ret *tl; }\n       nil. { fail \"list empty\" }\n     }\n }\n \n-fn car[@T](ls: &list<T>) -> T {\n+fn car<@T>(ls: &list<T>) -> T {\n     alt ls {\n       cons(hd, _) { ret hd; }\n       nil. { fail \"list empty\" }\n     }\n }\n \n-fn append[@T](l: &list<T>, m: &list<T>) -> list<T> {\n+fn append<@T>(l: &list<T>, m: &list<T>) -> list<T> {\n     alt l {\n       nil. { ret m; }\n       cons(x, xs) {"}, {"sha": "31ff01ef8b67279d32706f8cb29b63af25a03561", "filename": "src/lib/map.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -1,11 +1,11 @@\n /**\n  * Hashmap implementation.\n  */\n-type hashfn[K] = fn(&K) -> uint ;\n+type hashfn<K> = fn(&K) -> uint ;\n \n-type eqfn[K] = fn(&K, &K) -> bool ;\n+type eqfn<K> = fn(&K, &K) -> bool ;\n \n-type hashmap[K, V] =\n+type hashmap<K, V> =\n     obj {\n         fn size() -> uint ;\n         fn insert(&K, &V) -> bool ;\n@@ -17,16 +17,16 @@ type hashmap[K, V] =\n         iter items() -> @{key: K, val: V} ;\n         iter keys() -> K ;\n     };\n-type hashset[K] = hashmap<K, ()>;\n+type hashset<K> = hashmap<K, ()>;\n \n-fn set_add[@K](set: hashset<K>, key: &K) -> bool { ret set.insert(key, ()); }\n+fn set_add<@K>(set: hashset<K>, key: &K) -> bool { ret set.insert(key, ()); }\n \n-fn mk_hashmap[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n+fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n     let initial_capacity: uint = 32u; // 2^5\n \n     let load_factor: util::rational = {num: 3, den: 4};\n-    tag bucket[@K, @V] { nil; deleted; some(K, V); }\n-    fn make_buckets[@K, @V](nbkts: uint) -> [mutable (bucket<K, V>)] {\n+    tag bucket<@K, @V> { nil; deleted; some(K, V); }\n+    fn make_buckets<@K, @V>(nbkts: uint) -> [mutable (bucket<K, V>)] {\n         ret vec::init_elt_mut[bucket<K, V>](nil[K, V], nbkts);\n     }\n     // Derive two hash functions from the one given by taking the upper\n@@ -53,7 +53,7 @@ fn mk_hashmap[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n      * will fail.\n      */\n \n-    fn insert_common[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>,\n+    fn insert_common<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n                              bkts: &[mutable bucket<K, V>], nbkts: uint,\n                              key: &K, val: &V) -> bool {\n         let i: uint = 0u;\n@@ -76,7 +76,7 @@ fn mk_hashmap[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n         }\n         fail; // full table\n     }\n-    fn find_common[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>,\n+    fn find_common<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n                            bkts: &[mutable bucket<K, V>], nbkts: uint,\n                            key: &K) -> option::t<V> {\n         let i: uint = 0u;\n@@ -97,7 +97,7 @@ fn mk_hashmap[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n         }\n         ret option::none;\n     }\n-    fn rehash[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>,\n+    fn rehash<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n                       oldbkts: &[mutable bucket<K, V>], noldbkts: uint,\n                       newbkts: &[mutable bucket<K, V>], nnewbkts: uint) {\n         for b: bucket<K, V> in oldbkts {\n@@ -111,7 +111,7 @@ fn mk_hashmap[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n             }\n         }\n     }\n-    obj hashmap[@K, @V](hasher: hashfn<K>,\n+    obj hashmap<@K, @V>(hasher: hashfn<K>,\n                         eqer: eqfn<K>,\n                         mutable bkts: [mutable bucket<K, V>],\n                         mutable nbkts: uint,\n@@ -193,17 +193,17 @@ fn mk_hashmap[@K, @V](hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n \n // Hash map constructors for basic types\n \n-fn new_str_hash[@V]() -> hashmap<str, V> {\n+fn new_str_hash<@V>() -> hashmap<str, V> {\n     ret mk_hashmap(str::hash, str::eq);\n }\n \n-fn new_int_hash[@V]() -> hashmap<int, V> {\n+fn new_int_hash<@V>() -> hashmap<int, V> {\n     fn hash_int(x: &int) -> uint { ret x as uint; }\n     fn eq_int(a: &int, b: &int) -> bool { ret a == b; }\n     ret mk_hashmap(hash_int, eq_int);\n }\n \n-fn new_uint_hash[@V]() -> hashmap<uint, V> {\n+fn new_uint_hash<@V>() -> hashmap<uint, V> {\n     fn hash_uint(x: &uint) -> uint { ret x; }\n     fn eq_uint(a: &uint, b: &uint) -> bool { ret a == b; }\n     ret mk_hashmap(hash_uint, eq_uint);"}, {"sha": "e8656b0b77d334de6a82df51391231dd6ae82736", "filename": "src/lib/option.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -1,34 +1,34 @@\n // lib/option::rs\n \n-tag t[@T] { none; some(T); }\n+tag t<@T> { none; some(T); }\n \n-fn get[@T](opt: &t<T>) -> T {\n+fn get<@T>(opt: &t<T>) -> T {\n     alt opt {\n       some(x) { x }\n       none. { fail \"option none\" }\n     }\n }\n \n-fn map[@T, @U](f: &block(&T) -> U, opt: &t<T>) -> t<U> {\n+fn map<@T, @U>(f: &block(&T) -> U, opt: &t<T>) -> t<U> {\n     alt opt { some(x) { some(f(x)) } none. { none } }\n }\n \n-fn is_none[@T](opt: &t<T>) -> bool {\n+fn is_none<@T>(opt: &t<T>) -> bool {\n     alt opt { none. { true } some(_) { false } }\n }\n \n-fn is_some[@T](opt: &t<T>) -> bool { !is_none(opt) }\n+fn is_some<@T>(opt: &t<T>) -> bool { !is_none(opt) }\n \n-fn from_maybe[@T](def: &T, opt: &t<T>) -> T {\n+fn from_maybe<@T>(def: &T, opt: &t<T>) -> T {\n     alt opt { some(x) { x } none. { def } }\n }\n \n-fn maybe[@T, @U](def: &U, f: &block(&T) -> U, opt: &t<T>) -> U {\n+fn maybe<@T, @U>(def: &U, f: &block(&T) -> U, opt: &t<T>) -> U {\n     alt opt { none. { def } some(t) { f(t) } }\n }\n \n // Can be defined in terms of the above when/if we have const bind.\n-fn may[@T](f: &block(&T), opt: &t<T>) {\n+fn may<@T>(f: &block(&T), opt: &t<T>) {\n     alt opt { none. {/* nothing */ } some(t) { f(t); } }\n }\n "}, {"sha": "baacaf2d5e03797bf4c84a24afd5b44659156aec", "filename": "src/lib/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fptr.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -1,12 +1,12 @@\n // Unsafe pointer utility functions.\n \n native \"rust-intrinsic\" mod rusti {\n-    fn addr_of[T](val: &T) -> *mutable T;\n-    fn ptr_offset[T](ptr: *T, count: uint) -> *T;\n+    fn addr_of<T>(val: &T) -> *mutable T;\n+    fn ptr_offset<T>(ptr: *T, count: uint) -> *T;\n }\n \n-fn addr_of[T](val: &T) -> *mutable T { ret rusti::addr_of(val); }\n-fn offset[T](ptr: *T, count: uint) -> *T {\n+fn addr_of<T>(val: &T) -> *mutable T { ret rusti::addr_of(val); }\n+fn offset<T>(ptr: *T, count: uint) -> *T {\n     ret rusti::ptr_offset(ptr, count);\n }\n "}, {"sha": "6d2c6e715c151ac3fa81651143518e338781319c", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -7,38 +7,38 @@ import option::some;\n \n // FIXME: Should not be @; there's a bug somewhere in rustc that requires this\n // to be.\n-type smallintmap[T] = @{mutable v: [mutable option::t<T>]};\n+type smallintmap<T> = @{mutable v: [mutable option::t<T>]};\n \n-fn mk[@T]() -> smallintmap<T> {\n+fn mk<@T>() -> smallintmap<T> {\n     let v: [mutable option::t<T>] = ~[mutable];\n     ret @{mutable v: v};\n }\n \n-fn insert[@T](m: &smallintmap<T>, key: uint, val: &T) {\n+fn insert<@T>(m: &smallintmap<T>, key: uint, val: &T) {\n     vec::grow_set[option::t<T>](m.v, key, none[T], some[T](val));\n }\n \n-fn find[@T](m: &smallintmap<T>, key: uint) -> option::t<T> {\n+fn find<@T>(m: &smallintmap<T>, key: uint) -> option::t<T> {\n     if key < vec::len[option::t<T>](m.v) { ret m.v.(key); }\n     ret none[T];\n }\n \n-fn get[@T](m: &smallintmap<T>, key: uint) -> T {\n+fn get<@T>(m: &smallintmap<T>, key: uint) -> T {\n     alt find[T](m, key) {\n       none[T]. { log_err \"smallintmap::get(): key not present\"; fail; }\n       some[T](v) { ret v; }\n     }\n }\n \n-fn contains_key[@T](m: &smallintmap<T>, key: uint) -> bool {\n+fn contains_key<@T>(m: &smallintmap<T>, key: uint) -> bool {\n     ret !option::is_none(find[T](m, key));\n }\n \n-fn truncate[@T](m: &smallintmap<T>, len: uint) {\n+fn truncate<@T>(m: &smallintmap<T>, len: uint) {\n     m.v = vec::slice_mut[option::t<T>](m.v, 0u, len);\n }\n \n-fn max_key[T](m: &smallintmap<T>) -> uint {\n+fn max_key<T>(m: &smallintmap<T>) -> uint {\n     ret vec::len[option::t<T>](m.v);\n }\n "}, {"sha": "4400b21535b70db42ae977a8b68a6d69b70472ce", "filename": "src/lib/sort.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -6,10 +6,10 @@ export merge_sort;\n export quick_sort;\n export quick_sort3;\n \n-type lteq[T] = block(&T, &T) -> bool ;\n+type lteq<T> = block(&T, &T) -> bool ;\n \n-fn merge_sort[@T](le: &lteq<T>, v: &[T]) -> [T] {\n-    fn merge[@T](le: &lteq<T>, a: &[T], b: &[T]) -> [T] {\n+fn merge_sort<@T>(le: &lteq<T>, v: &[T]) -> [T] {\n+    fn merge<@T>(le: &lteq<T>, a: &[T], b: &[T]) -> [T] {\n         let rs: [T] = ~[];\n         let a_len: uint = len[T](a);\n         let a_ix: uint = 0u;\n@@ -33,13 +33,13 @@ fn merge_sort[@T](le: &lteq<T>, v: &[T]) -> [T] {\n     ret merge[T](le, merge_sort[T](le, a), merge_sort[T](le, b));\n }\n \n-fn swap[@T](arr: &[mutable T], x: uint, y: uint) {\n+fn swap<@T>(arr: &[mutable T], x: uint, y: uint) {\n     let a = arr.(x);\n     arr.(x) = arr.(y);\n     arr.(y) = a;\n }\n \n-fn part[@T](compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n+fn part<@T>(compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n             right: uint, pivot: uint) -> uint {\n     let pivot_value = arr.(pivot);\n     swap[T](arr, pivot, right);\n@@ -56,7 +56,7 @@ fn part[@T](compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n     ret storage_index;\n }\n \n-fn qsort[@T](compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n+fn qsort<@T>(compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n              right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -69,7 +69,7 @@ fn qsort[@T](compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n     }\n }\n \n-fn quick_sort[@T](compare_func: &lteq<T>, arr: &[mutable T]) {\n+fn quick_sort<@T>(compare_func: &lteq<T>, arr: &[mutable T]) {\n     if len[T](arr) == 0u { ret; }\n     qsort[T](compare_func, arr, 0u, len[T](arr) - 1u);\n }\n@@ -79,7 +79,7 @@ fn quick_sort[@T](compare_func: &lteq<T>, arr: &[mutable T]) {\n // http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf\n // According to these slides this is the algorithm of choice for\n // 'randomly ordered keys, abstract compare' & 'small number of key values'\n-fn qsort3[@T](compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n+fn qsort3<@T>(compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n               arr: &[mutable T], left: int, right: int) {\n     if right <= left { ret; }\n     let v: T = arr.(right);\n@@ -127,7 +127,7 @@ fn qsort3[@T](compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n     qsort3[T](compare_func_lt, compare_func_eq, arr, i, right);\n }\n \n-fn quick_sort3[@T](compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n+fn quick_sort3<@T>(compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n                    arr: &[mutable T]) {\n     if len[T](arr) == 0u { ret; }\n     qsort3[T](compare_func_lt, compare_func_eq, arr, 0,"}, {"sha": "b6a6beb0a8d824b45ac44de35021b25ea81d9224", "filename": "src/lib/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -65,7 +65,7 @@ native \"rust\" mod rustrt {\n     fn str_from_buf(buf: sbuf, len: uint) -> str;\n     fn str_push_byte(s: str, byte: uint) -> str;\n     fn str_slice(s: str, begin: uint, end: uint) -> str;\n-    fn refcount[T](s: str) -> uint;\n+    fn refcount<T>(s: str) -> uint;\n }\n \n fn eq(a: &str, b: &str) -> bool {"}, {"sha": "7bec897ab02c384cd64d7a8129077eae5431bd2d", "filename": "src/lib/sys.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsys.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -10,9 +10,9 @@ native \"rust\" mod rustrt {\n     // available outside this crate. Otherwise it's\n     // visible-in-crate, but not re-exported.\n     fn last_os_error() -> str;\n-    fn size_of[T]() -> uint;\n-    fn align_of[T]() -> uint;\n-    fn refcount[T](t: @T) -> uint;\n+    fn size_of<T>() -> uint;\n+    fn align_of<T>() -> uint;\n+    fn refcount<T>(t: @T) -> uint;\n     fn do_gc();\n     fn unsupervise();\n }"}, {"sha": "d50004b33ce4d5c4dd65993738542fcf70502b66", "filename": "src/lib/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -23,7 +23,7 @@ native \"rust\" mod rustrt {\n \n     fn migrate_alloc(alloc : *u8, target : task_id);\n \n-    fn leak[@T](thing : -T);\n+    fn leak<@T>(thing : -T);\n }\n \n type task_id = int;"}, {"sha": "264625cec464db9fa53f8ad675ceea4b8d972072", "filename": "src/lib/unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Funsafe.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -1,9 +1,9 @@\n // Unsafe operations.\n \n native \"rust-intrinsic\" mod rusti {\n-    fn cast[T, U](src: &T) -> U;\n+    fn cast<T, U>(src: &T) -> U;\n }\n \n // Casts the value at `src` to U. The two types must have the same length.\n-fn reinterpret_cast[T, U](src: &T) -> U { ret rusti::cast(src); }\n+fn reinterpret_cast<T, U>(src: &T) -> U { ret rusti::cast(src); }\n "}, {"sha": "24a14b1fa9210cd4c014db0e6ee4ff534ed5ecf2", "filename": "src/lib/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id[T](x: &T) -> T { ret x; }\n+fn id<T>(x: &T) -> T { ret x; }\n \n \n /* FIXME (issue #141):  See test/run-pass/constrained-type.rs.  Uncomment"}, {"sha": "0a6228945fbdee467ae827b8ec0168c41ae1f35a", "filename": "src/lib/vec.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9049c50c5c32f556eaefbcc50209ef8ee353d0/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "patch": "@@ -6,18 +6,18 @@ import uint::next_power_of_two;\n import ptr::addr_of;\n \n native \"rust-intrinsic\" mod rusti {\n-    fn ivec_len[T](v: &[T]) -> uint;\n+    fn ivec_len<T>(v: &[T]) -> uint;\n }\n \n native \"rust\" mod rustrt {\n-    fn ivec_reserve_shared[T](v: &mutable [mutable? T], n: uint);\n-    fn ivec_on_heap[T](v: &[T]) -> uint;\n-    fn ivec_to_ptr[T](v: &[T]) -> *T;\n-    fn ivec_copy_from_buf_shared[T](v: &mutable [mutable? T], ptr: *T,\n+    fn ivec_reserve_shared<T>(v: &mutable [mutable? T], n: uint);\n+    fn ivec_on_heap<T>(v: &[T]) -> uint;\n+    fn ivec_to_ptr<T>(v: &[T]) -> *T;\n+    fn ivec_copy_from_buf_shared<T>(v: &mutable [mutable? T], ptr: *T,\n                                     count: uint);\n }\n \n-fn from_vec[@T](v: &vec<mutable? T>) -> [T] {\n+fn from_vec<@T>(v: &vec<mutable? T>) -> [T] {\n     let iv = ~[];\n     for e in v {\n         iv += ~[e];\n@@ -26,19 +26,19 @@ fn from_vec[@T](v: &vec<mutable? T>) -> [T] {\n }\n \n /// Reserves space for `n` elements in the given vector.\n-fn reserve[@T](v: &mutable [mutable? T], n: uint) {\n+fn reserve<@T>(v: &mutable [mutable? T], n: uint) {\n     rustrt::ivec_reserve_shared(v, n);\n }\n \n-fn on_heap[T](v: &[T]) -> bool { ret rustrt::ivec_on_heap(v) != 0u; }\n+fn on_heap<T>(v: &[T]) -> bool { ret rustrt::ivec_on_heap(v) != 0u; }\n \n-fn to_ptr[T](v: &[T]) -> *T { ret rustrt::ivec_to_ptr(v); }\n+fn to_ptr<T>(v: &[T]) -> *T { ret rustrt::ivec_to_ptr(v); }\n \n-fn len[T](v: &[mutable? T]) -> uint { ret rusti::ivec_len(v); }\n+fn len<T>(v: &[mutable? T]) -> uint { ret rusti::ivec_len(v); }\n \n-type init_op[T] = fn(uint) -> T ;\n+type init_op<T> = fn(uint) -> T ;\n \n-fn init_fn[@T](op: &init_op<T>, n_elts: uint) -> [T] {\n+fn init_fn<@T>(op: &init_op<T>, n_elts: uint) -> [T] {\n     let v = ~[];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -47,15 +47,15 @@ fn init_fn[@T](op: &init_op<T>, n_elts: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n-fn init_fn_mut[@T](op: &init_op<T>, n_elts: uint) -> [mutable T] {\n+fn init_fn_mut<@T>(op: &init_op<T>, n_elts: uint) -> [mutable T] {\n     let v = ~[mutable];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n     while i < n_elts { v += ~[mutable op(i)]; i += 1u; }\n     ret v;\n }\n \n-fn init_elt[@T](t: &T, n_elts: uint) -> [T] {\n+fn init_elt<@T>(t: &T, n_elts: uint) -> [T] {\n     let v = ~[];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -64,53 +64,53 @@ fn init_elt[@T](t: &T, n_elts: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n-fn init_elt_mut[@T](t: &T, n_elts: uint) -> [mutable T] {\n+fn init_elt_mut<@T>(t: &T, n_elts: uint) -> [mutable T] {\n     let v = ~[mutable];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n     while i < n_elts { v += ~[mutable t]; i += 1u; }\n     ret v;\n }\n \n-fn to_mut[@T](v: &[T]) -> [mutable T] {\n+fn to_mut<@T>(v: &[T]) -> [mutable T] {\n     let vres = ~[mutable];\n     for t: T in v { vres += ~[mutable t]; }\n     ret vres;\n }\n \n-fn from_mut[@T](v: &[mutable T]) -> [T] {\n+fn from_mut<@T>(v: &[mutable T]) -> [T] {\n     let vres = ~[];\n     for t: T in v { vres += ~[t]; }\n     ret vres;\n }\n \n // Predicates\n-pred is_empty[T](v: &[mutable? T]) -> bool {\n+pred is_empty<T>(v: &[mutable? T]) -> bool {\n     // FIXME: This would be easier if we could just call len\n     for t: T in v { ret false; }\n     ret true;\n }\n \n-pred is_not_empty[T](v: &[mutable? T]) -> bool { ret !is_empty(v); }\n+pred is_not_empty<T>(v: &[mutable? T]) -> bool { ret !is_empty(v); }\n \n // Accessors\n \n /// Returns the first element of a vector\n-fn head[@T](v: &[mutable? T]) : is_not_empty(v) -> T { ret v.(0); }\n+fn head<@T>(v: &[mutable? T]) : is_not_empty(v) -> T { ret v.(0); }\n \n /// Returns all but the first element of a vector\n-fn tail[@T](v: &[mutable? T]) : is_not_empty(v) -> [mutable? T] {\n+fn tail<@T>(v: &[mutable? T]) : is_not_empty(v) -> [mutable? T] {\n     ret slice(v, 1u, len(v));\n }\n \n /// Returns the last element of `v`.\n-fn last[@T](v: &[mutable? T]) -> option::t<T> {\n+fn last<@T>(v: &[mutable? T]) -> option::t<T> {\n     if len(v) == 0u { ret none; }\n     ret some(v.(len(v) - 1u));\n }\n \n /// Returns a copy of the elements from [`start`..`end`) from `v`.\n-fn slice[@T](v: &[mutable? T], start: uint, end: uint) -> [T] {\n+fn slice<@T>(v: &[mutable? T], start: uint, end: uint) -> [T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let result = ~[];\n@@ -121,7 +121,7 @@ fn slice[@T](v: &[mutable? T], start: uint, end: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n-fn slice_mut[@T](v: &[mutable? T], start: uint, end: uint) -> [mutable T] {\n+fn slice_mut<@T>(v: &[mutable? T], start: uint, end: uint) -> [mutable T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let result = ~[mutable];\n@@ -134,7 +134,7 @@ fn slice_mut[@T](v: &[mutable? T], start: uint, end: uint) -> [mutable T] {\n \n // Mutators\n \n-fn shift[@T](v: &mutable [mutable? T]) -> T {\n+fn shift<@T>(v: &mutable [mutable? T]) -> T {\n     let ln = len[T](v);\n     assert (ln > 0u);\n     let e = v.(0);\n@@ -143,7 +143,7 @@ fn shift[@T](v: &mutable [mutable? T]) -> T {\n }\n \n // TODO: Write this, unsafely, in a way that's not O(n).\n-fn pop[@T](v: &mutable [mutable? T]) -> T {\n+fn pop<@T>(v: &mutable [mutable? T]) -> T {\n     let ln = len(v);\n     assert (ln > 0u);\n     ln -= 1u;\n@@ -158,22 +158,22 @@ fn pop[@T](v: &mutable [mutable? T]) -> T {\n // Appending\n \n /// Expands the given vector in-place by appending `n` copies of `initval`.\n-fn grow[@T](v: &mutable [T], n: uint, initval: &T) {\n+fn grow<@T>(v: &mutable [T], n: uint, initval: &T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += ~[initval]; i += 1u; }\n }\n \n // TODO: Remove me once we have slots.\n-fn grow_mut[@T](v: &mutable [mutable T], n: uint, initval: &T) {\n+fn grow_mut<@T>(v: &mutable [mutable T], n: uint, initval: &T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += ~[mutable initval]; i += 1u; }\n }\n \n /// Calls `f` `n` times and appends the results of these calls to the given\n /// vector.\n-fn grow_fn[@T](v: &mutable [T], n: uint, init_fn: fn(uint) -> T ) {\n+fn grow_fn<@T>(v: &mutable [T], n: uint, init_fn: fn(uint) -> T ) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += ~[init_fn(i)]; i += 1u; }\n@@ -182,15 +182,15 @@ fn grow_fn[@T](v: &mutable [T], n: uint, init_fn: fn(uint) -> T ) {\n /// Sets the element at position `index` to `val`. If `index` is past the end\n /// of the vector, expands the vector by replicating `initval` to fill the\n /// intervening space.\n-fn grow_set[@T](v: &mutable [mutable T], index: uint, initval: &T, val: &T) {\n+fn grow_set<@T>(v: &mutable [mutable T], index: uint, initval: &T, val: &T) {\n     if index >= len(v) { grow_mut(v, index - len(v) + 1u, initval); }\n     v.(index) = val;\n }\n \n \n // Functional utilities\n \n-fn map[@T, @U](f: &block(&T) -> U , v: &[mutable? T]) -> [U] {\n+fn map<@T, @U>(f: &block(&T) -> U , v: &[mutable? T]) -> [U] {\n     let result = ~[];\n     reserve(result, len(v));\n     for elem: T in v {\n@@ -200,7 +200,7 @@ fn map[@T, @U](f: &block(&T) -> U , v: &[mutable? T]) -> [U] {\n     ret result;\n }\n \n-fn map2[@T, @U, @V](f: &block(&T, &U) -> V, v0: &[T], v1: &[U])\n+fn map2<@T, @U, @V>(f: &block(&T, &U) -> V, v0: &[T], v1: &[U])\n     -> [V] {\n     let v0_len = len[T](v0);\n     if v0_len != len[U](v1) { fail; }\n@@ -210,7 +210,7 @@ fn map2[@T, @U, @V](f: &block(&T, &U) -> V, v0: &[T], v1: &[U])\n     ret u;\n }\n \n-fn filter_map[@T, @U](f: &block(&T) -> option::t<U>,\n+fn filter_map<@T, @U>(f: &block(&T) -> option::t<U>,\n                       v: &[mutable? T]) -> [U] {\n     let result = ~[];\n     for elem: T in v {\n@@ -223,53 +223,53 @@ fn filter_map[@T, @U](f: &block(&T) -> option::t<U>,\n     ret result;\n }\n \n-fn foldl[@T, @U](p: &block(&U, &T) -> U , z: &U, v: &[mutable? T]) -> U {\n+fn foldl<@T, @U>(p: &block(&U, &T) -> U , z: &U, v: &[mutable? T]) -> U {\n     let sz = len(v);\n     if sz == 0u { ret z; }\n     let first = v.(0);\n     let rest = slice(v, 1u, sz);\n     ret p(foldl(p, z, rest), first);\n }\n \n-fn any[T](f: &block(&T) -> bool , v: &[T]) -> bool {\n+fn any<T>(f: &block(&T) -> bool, v: &[T]) -> bool {\n     for elem: T in v { if f(elem) { ret true; } }\n     ret false;\n }\n \n-fn all[T](f: &block(&T) -> bool , v: &[T]) -> bool {\n+fn all<T>(f: &block(&T) -> bool, v: &[T]) -> bool {\n     for elem: T in v { if !f(elem) { ret false; } }\n     ret true;\n }\n \n-fn member[T](x: &T, v: &[T]) -> bool {\n+fn member<T>(x: &T, v: &[T]) -> bool {\n     for elt: T in v { if x == elt { ret true; } }\n     ret false;\n }\n \n-fn count[T](x: &T, v: &[mutable? T]) -> uint {\n+fn count<T>(x: &T, v: &[mutable? T]) -> uint {\n     let cnt = 0u;\n     for elt: T in v { if x == elt { cnt += 1u; } }\n     ret cnt;\n }\n \n-fn find[@T](f: &block(&T) -> bool, v: &[T]) -> option::t<T> {\n+fn find<@T>(f: &block(&T) -> bool, v: &[T]) -> option::t<T> {\n     for elt: T in v { if f(elt) { ret some(elt); } }\n     ret none;\n }\n \n-fn position[@T](x: &T, v: &[T]) -> option::t<uint> {\n+fn position<@T>(x: &T, v: &[T]) -> option::t<uint> {\n     let i: uint = 0u;\n     while i < len(v) { if x == v.(i) { ret some[uint](i); } i += 1u; }\n     ret none[uint];\n }\n \n-fn position_pred[T](f: fn(&T) -> bool, v: &[T]) -> option::t<uint> {\n+fn position_pred<T>(f: fn(&T) -> bool, v: &[T]) -> option::t<uint> {\n     let i: uint = 0u;\n     while i < len(v) { if f(v.(i)) { ret some[uint](i); } i += 1u; }\n     ret none[uint];\n }\n \n-fn unzip[@T, @U](v: &[(T, U)]) -> ([T], [U]) {\n+fn unzip<@T, @U>(v: &[(T, U)]) -> ([T], [U]) {\n     let as = ~[], bs = ~[];\n     for (a, b) in v {\n         as += ~[a];\n@@ -279,7 +279,7 @@ fn unzip[@T, @U](v: &[(T, U)]) -> ([T], [U]) {\n }\n \n // FIXME make the lengths being equal a constraint\n-fn zip[@T, @U](v: &[T], u: &[U]) -> [(T, U)] {\n+fn zip<@T, @U>(v: &[T], u: &[U]) -> [(T, U)] {\n     let zipped = ~[];\n     let sz = len(v), i = 0u;\n     assert (sz == len(u));\n@@ -291,22 +291,22 @@ fn zip[@T, @U](v: &[T], u: &[U]) -> [(T, U)] {\n }\n \n // Swaps two elements in a vector\n-fn swap[@T](v: &[mutable T], a: uint, b: uint) {\n+fn swap<@T>(v: &[mutable T], a: uint, b: uint) {\n     let t: T = v.(a);\n     v.(a) = v.(b);\n     v.(b) = t;\n }\n \n // In place vector reversal\n-fn reverse[@T](v: &[mutable T]) {\n+fn reverse<@T>(v: &[mutable T]) {\n     let i: uint = 0u;\n     let ln = len[T](v);\n     while i < ln / 2u { swap(v, i, ln - i - 1u); i += 1u; }\n }\n \n \n // Functional vector reversal. Returns a reversed copy of v.\n-fn reversed[@T](v: &[T]) -> [T] {\n+fn reversed<@T>(v: &[T]) -> [T] {\n     let rs: [T] = ~[];\n     let i = len[T](v);\n     if i == 0u { ret rs; } else { i -= 1u; }\n@@ -323,17 +323,17 @@ mod unsafe {\n          heap_part: *mutable ivec_heap_part};\n     type ivec_heap_part = {mutable fill: uint};\n \n-    fn copy_from_buf[T](v: &mutable [T], ptr: *T, count: uint) {\n+    fn copy_from_buf<T>(v: &mutable [T], ptr: *T, count: uint) {\n         ret rustrt::ivec_copy_from_buf_shared(v, ptr, count);\n     }\n \n-    fn from_buf[T](ptr: *T, bytes: uint) -> [T] {\n+    fn from_buf<T>(ptr: *T, bytes: uint) -> [T] {\n         let v = ~[];\n         copy_from_buf(v, ptr, bytes);\n         ret v;\n     }\n \n-    fn set_len[T](v: &mutable [T], new_len: uint) {\n+    fn set_len<T>(v: &mutable [T], new_len: uint) {\n         let new_fill = new_len * sys::size_of[T]();\n         let stack_part: *mutable ivec_repr =\n             ::unsafe::reinterpret_cast(addr_of(v));"}]}