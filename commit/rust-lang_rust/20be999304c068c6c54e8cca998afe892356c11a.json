{"sha": "20be999304c068c6c54e8cca998afe892356c11a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwYmU5OTkzMDRjMDY4YzZjNTRlOGNjYTk5OGFmZTg5MjM1NmMxMWE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-01T22:20:27Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-01T22:21:21Z"}, "message": "Empower `replace_if_let_with_match`", "tree": {"sha": "487e6a506ad0d78d2eaf65eae36f08f992f3db39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/487e6a506ad0d78d2eaf65eae36f08f992f3db39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20be999304c068c6c54e8cca998afe892356c11a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20be999304c068c6c54e8cca998afe892356c11a", "html_url": "https://github.com/rust-lang/rust/commit/20be999304c068c6c54e8cca998afe892356c11a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20be999304c068c6c54e8cca998afe892356c11a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b9b2d1f40bc694a277947f8f0cb77a3fe7b5c1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b9b2d1f40bc694a277947f8f0cb77a3fe7b5c1a", "html_url": "https://github.com/rust-lang/rust/commit/1b9b2d1f40bc694a277947f8f0cb77a3fe7b5c1a"}], "stats": {"total": 177, "additions": 112, "deletions": 65}, "files": [{"sha": "888b4d090b00672fb735c24921e5fe34cb257fb9", "filename": "crates/ide_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 109, "deletions": 61, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/20be999304c068c6c54e8cca998afe892356c11a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20be999304c068c6c54e8cca998afe892356c11a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=20be999304c068c6c54e8cca998afe892356c11a", "patch": "@@ -1,4 +1,4 @@\n-use std::iter;\n+use std::iter::{self, successors};\n \n use ide_db::{ty_filter::TryEnum, RootDatabase};\n use syntax::{\n@@ -17,7 +17,7 @@ use crate::{\n \n // Assist: replace_if_let_with_match\n //\n-// Replaces `if let` with an else branch with a `match` expression.\n+// Replaces a `if let` expression with a `match` expression.\n //\n // ```\n // enum Action { Move { distance: u32 }, Stop }\n@@ -43,14 +43,28 @@ use crate::{\n // ```\n pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n-    let cond = if_expr.condition()?;\n-    let pat = cond.pat()?;\n-    let expr = cond.expr()?;\n-    let then_block = if_expr.then_branch()?;\n-    let else_block = match if_expr.else_branch()? {\n-        ast::ElseBranch::Block(it) => it,\n-        ast::ElseBranch::IfExpr(_) => return None,\n-    };\n+    let mut else_block = None;\n+    let if_exprs = successors(Some(if_expr.clone()), |expr| match expr.else_branch()? {\n+        ast::ElseBranch::IfExpr(expr) => Some(expr),\n+        ast::ElseBranch::Block(block) => {\n+            else_block = Some(block);\n+            None\n+        }\n+    });\n+    let scrutinee_to_be_expr = if_expr.condition()?.expr()?;\n+\n+    let mut pat_bodies = Vec::new();\n+    for if_expr in if_exprs {\n+        let cond = if_expr.condition()?;\n+        let expr = cond.expr()?;\n+        if scrutinee_to_be_expr.syntax().text() != expr.syntax().text() {\n+            // Only if all condition expressions are equal we can merge them into a match\n+            return None;\n+        }\n+        let pat = cond.pat()?;\n+        let body = if_expr.then_branch()?;\n+        pat_bodies.push((pat, body));\n+    }\n \n     let target = if_expr.syntax().text_range();\n     acc.add(\n@@ -59,33 +73,50 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n         target,\n         move |edit| {\n             let match_expr = {\n-                let then_arm = {\n-                    let then_block = then_block.reset_indent().indent(IndentLevel(1));\n-                    let then_expr = unwrap_trivial_block(then_block);\n-                    make::match_arm(vec![pat.clone()], then_expr)\n-                };\n                 let else_arm = {\n-                    let pattern = ctx\n-                        .sema\n-                        .type_of_pat(&pat)\n-                        .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n-                        .map(|it| {\n-                            if does_pat_match_variant(&pat, &it.sad_pattern()) {\n-                                it.happy_pattern()\n-                            } else {\n-                                it.sad_pattern()\n+                    match else_block {\n+                        Some(else_block) => {\n+                            let pattern = match &*pat_bodies {\n+                                [(pat, _)] => ctx\n+                                    .sema\n+                                    .type_of_pat(&pat)\n+                                    .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n+                                    .map(|it| {\n+                                        if does_pat_match_variant(&pat, &it.sad_pattern()) {\n+                                            it.happy_pattern()\n+                                        } else {\n+                                            it.sad_pattern()\n+                                        }\n+                                    }),\n+                                _ => None,\n                             }\n-                        })\n-                        .unwrap_or_else(|| make::wildcard_pat().into());\n-                    let else_expr = unwrap_trivial_block(else_block);\n-                    make::match_arm(vec![pattern], else_expr)\n+                            .unwrap_or_else(|| make::wildcard_pat().into());\n+                            make::match_arm(iter::once(pattern), unwrap_trivial_block(else_block))\n+                        }\n+                        None => make::match_arm(\n+                            iter::once(make::wildcard_pat().into()),\n+                            make::expr_unit().into(),\n+                        ),\n+                    }\n                 };\n-                let match_expr =\n-                    make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]));\n+                let arms = pat_bodies\n+                    .into_iter()\n+                    .map(|(pat, body)| {\n+                        let body = body.reset_indent().indent(IndentLevel(1));\n+                        make::match_arm(vec![pat], unwrap_trivial_block(body))\n+                    })\n+                    .chain(iter::once(else_arm));\n+                let match_expr = make::expr_match(scrutinee_to_be_expr, make::match_arm_list(arms));\n                 match_expr.indent(IndentLevel::from_node(if_expr.syntax()))\n             };\n \n-            edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n+            let expr =\n+                if if_expr.syntax().parent().map_or(false, |it| ast::IfExpr::can_cast(it.kind())) {\n+                    make::block_expr(None, Some(match_expr)).into()\n+                } else {\n+                    match_expr\n+                };\n+            edit.replace_ast::<ast::Expr>(if_expr.into(), expr);\n         },\n     )\n }\n@@ -182,79 +213,96 @@ mod tests {\n     use crate::tests::{check_assist, check_assist_target};\n \n     #[test]\n-    fn test_replace_if_let_with_match_unwraps_simple_expressions() {\n+    fn test_if_let_with_match_no_else() {\n         check_assist(\n             replace_if_let_with_match,\n             r#\"\n impl VariantData {\n-    pub fn is_struct(&self) -> bool {\n+    pub fn foo(&self) {\n         if $0let VariantData::Struct(..) = *self {\n-            true\n-        } else {\n-            false\n+            self.foo();\n         }\n     }\n }           \"#,\n             r#\"\n impl VariantData {\n-    pub fn is_struct(&self) -> bool {\n+    pub fn foo(&self) {\n         match *self {\n-            VariantData::Struct(..) => true,\n-            _ => false,\n+            VariantData::Struct(..) => {\n+                self.foo();\n+            }\n+            _ => (),\n         }\n     }\n }           \"#,\n         )\n     }\n \n     #[test]\n-    fn test_replace_if_let_with_match_doesnt_unwrap_multiline_expressions() {\n+    fn test_if_let_with_match_basic() {\n         check_assist(\n             replace_if_let_with_match,\n             r#\"\n-fn foo() {\n-    if $0let VariantData::Struct(..) = a {\n-        bar(\n-            123\n-        )\n-    } else {\n-        false\n-    }\n-}           \"#,\n-            r#\"\n-fn foo() {\n-    match a {\n-        VariantData::Struct(..) => {\n+impl VariantData {\n+    pub fn is_struct(&self) -> bool {\n+        if $0let VariantData::Struct(..) = *self {\n+            true\n+        } else if let VariantData::Tuple(..) = *self {\n+            false\n+        } else {\n             bar(\n                 123\n             )\n         }\n-        _ => false,\n+    }\n+}           \"#,\n+            r#\"\n+impl VariantData {\n+    pub fn is_struct(&self) -> bool {\n+        match *self {\n+            VariantData::Struct(..) => true,\n+            VariantData::Tuple(..) => false,\n+            _ => {\n+                    bar(\n+                        123\n+                    )\n+                }\n+        }\n     }\n }           \"#,\n         )\n     }\n \n     #[test]\n-    fn replace_if_let_with_match_target() {\n-        check_assist_target(\n+    fn test_if_let_with_match_on_tail_if_let() {\n+        check_assist(\n             replace_if_let_with_match,\n             r#\"\n impl VariantData {\n     pub fn is_struct(&self) -> bool {\n-        if $0let VariantData::Struct(..) = *self {\n+        if let VariantData::Struct(..) = *self {\n             true\n+        } else if let$0 VariantData::Tuple(..) = *self {\n+            false\n         } else {\n             false\n         }\n     }\n }           \"#,\n-            \"if let VariantData::Struct(..) = *self {\n+            r#\"\n+impl VariantData {\n+    pub fn is_struct(&self) -> bool {\n+        if let VariantData::Struct(..) = *self {\n             true\n         } else {\n-            false\n-        }\",\n-        );\n+    match *self {\n+            VariantData::Tuple(..) => false,\n+            _ => false,\n+        }\n+}\n+    }\n+}           \"#,\n+        )\n     }\n \n     #[test]"}, {"sha": "c3839a2b0bebfac7caa5284f8618590f46b6189f", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/20be999304c068c6c54e8cca998afe892356c11a/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20be999304c068c6c54e8cca998afe892356c11a/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=20be999304c068c6c54e8cca998afe892356c11a", "patch": "@@ -48,15 +48,14 @@ pub fn extract_trivial_expression(block: &ast::BlockExpr) -> Option<ast::Expr> {\n         return Some(expr);\n     }\n     // Unwrap `{ continue; }`\n-    let (stmt,) = block.statements().next_tuple()?;\n+    let stmt = block.statements().next()?;\n     if let ast::Stmt::ExprStmt(expr_stmt) = stmt {\n         if has_anything_else(expr_stmt.syntax()) {\n             return None;\n         }\n         let expr = expr_stmt.expr()?;\n-        match expr.syntax().kind() {\n-            CONTINUE_EXPR | BREAK_EXPR | RETURN_EXPR => return Some(expr),\n-            _ => (),\n+        if matches!(expr.syntax().kind(), CONTINUE_EXPR | BREAK_EXPR | RETURN_EXPR) {\n+            return Some(expr);\n         }\n     }\n     None"}]}