{"sha": "1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNDZiMDA3ZDdkMWFjYmJmYjU5YzdlMGYxMzA3ZTZhMzc4YWI1ODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-09T07:12:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-09T07:12:30Z"}, "message": "auto merge of #17784 : bkoropoff/rust/issue-17780, r=pcwalton\n\nThis fixes a soundness problem where `Fn` unboxed closures can mutate free variables in the environment.\r\nThe following presently builds:\r\n\r\n```rust\r\n#![feature(unboxed_closures, overloaded_calls)]\r\n\r\nfn main() {\r\n    let mut x = 0u;\r\n    let _f = |&:| x = 42;\r\n}\r\n```\r\n\r\nHowever, this is equivalent to writing the following, which borrowck rightly rejects:\r\n\r\n```rust\r\nstruct F<'a> {\r\n    x: &'a mut uint\r\n}\r\n\r\nimpl<'a> Fn<(),()> for F<'a> {\r\n    #[rust_call_abi_hack]\r\n    fn call(&self, _: ()) {\r\n        *self.x = 42; // error: cannot assign to data in a `&` reference\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let mut x = 0u;\r\n    let _f = F { x: &mut x };\r\n}\r\n```\r\n\r\nThis problem is unique to unboxed closures; boxed closures cannot be invoked through an immutable reference and are not subject to it.\r\n\r\nThis change marks upvars of `Fn` unboxed closures as freely aliasable in mem_categorization, which causes borrowck to reject attempts to mutate or mutably borrow them.\r\n\r\n@zwarich pointed out that even with this change, there are remaining soundness issues related to regionck (issue #17403).  This region issue affects boxed closures as well.\r\n\r\nCloses issue #17780", "tree": {"sha": "c42134df1e8c0a521c4bfc3d5536be83277f0d3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c42134df1e8c0a521c4bfc3d5536be83277f0d3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "html_url": "https://github.com/rust-lang/rust/commit/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f965901505268bc70923b76c8771ca5ad781c12", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f965901505268bc70923b76c8771ca5ad781c12", "html_url": "https://github.com/rust-lang/rust/commit/8f965901505268bc70923b76c8771ca5ad781c12"}, {"sha": "4d2ff432e45eedef9d15618b0b9af5378994bc46", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d2ff432e45eedef9d15618b0b9af5378994bc46", "html_url": "https://github.com/rust-lang/rust/commit/4d2ff432e45eedef9d15618b0b9af5378994bc46"}], "stats": {"total": 171, "additions": 135, "deletions": 36}, "files": [{"sha": "df18ec30f0ee3acde38ed5610d4fe2b65b6892fe", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "patch": "@@ -854,6 +854,12 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     check_for_aliasability_violation(this, span, b.clone());\n                 }\n \n+                mc::cat_copied_upvar(mc::CopiedUpvar {\n+                    kind: mc::Unboxed(ty::FnUnboxedClosureKind), ..}) => {\n+                    // Prohibit writes to capture-by-move upvars in non-once closures\n+                    check_for_aliasability_violation(this, span, guarantor.clone());\n+                }\n+\n                 _ => {}\n             }\n "}, {"sha": "cd67169ff5690ce358a0e7c83d7ae15e4cb8e930", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "patch": "@@ -133,16 +133,15 @@ fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::Implicit(..)) |\n         mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-        mc::cat_upvar(..) | mc::cat_static_item |\n-        mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {\n+        mc::cat_upvar(..) | mc::cat_static_item => {\n             Some(cmt.clone())\n         }\n \n-        // Can move out of captured upvars only if the destination closure\n-        // type is 'once'. 1-shot stack closures emit the copied_upvar form\n-        // (see mem_categorization.rs).\n-        mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Once, .. }) => {\n-            None\n+        mc::cat_copied_upvar(mc::CopiedUpvar { kind: kind, .. }) => {\n+            match kind.onceness() {\n+                ast::Once => None,\n+                ast::Many => Some(cmt.clone())\n+            }\n         }\n \n         mc::cat_rvalue(..) |"}, {"sha": "29677cf897144d4c620fa8a88c630022012151eb", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "patch": "@@ -115,8 +115,15 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::Implicit(..)) |\n         mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-        mc::cat_upvar(..) | mc::cat_static_item |\n-        mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {\n+        mc::cat_upvar(..) | mc::cat_static_item => {\n+            bccx.span_err(\n+                move_from.span,\n+                format!(\"cannot move out of {}\",\n+                        bccx.cmt_to_string(&*move_from)).as_slice());\n+        }\n+\n+        mc::cat_copied_upvar(mc::CopiedUpvar { kind: kind, .. })\n+            if kind.onceness() == ast::Many => {\n             bccx.span_err(\n                 move_from.span,\n                 format!(\"cannot move out of {}\","}, {"sha": "f30a370d068526cf5831e9792a8e439321159bf0", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 SafeIf(lp.clone(), vec![lp])\n             }\n \n-            mc::cat_upvar(upvar_id, _) => {\n+            mc::cat_upvar(upvar_id, _, _) => {\n                 // R-Variable, captured into closure\n                 let lp = Rc::new(LpUpvar(upvar_id));\n                 SafeIf(lp.clone(), vec![lp])"}, {"sha": "a86ae420065951e2a8c1da92997e58d9eca18ef3", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "patch": "@@ -354,18 +354,22 @@ pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n \n     match cmt.cat {\n         mc::cat_rvalue(..) |\n-        mc::cat_static_item |\n-        mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {\n+        mc::cat_static_item => {\n+            None\n+        }\n+\n+        mc::cat_copied_upvar(mc::CopiedUpvar { kind: kind, .. })\n+            if kind.onceness() == ast::Many => {\n             None\n         }\n \n         mc::cat_local(id) => {\n             Some(Rc::new(LpVar(id)))\n         }\n \n-        mc::cat_upvar(ty::UpvarId {var_id: id, closure_expr_id: proc_id}, _) |\n+        mc::cat_upvar(ty::UpvarId {var_id: id, closure_expr_id: proc_id}, _, _) |\n         mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id,\n-                                               onceness: _,\n+                                               kind: _,\n                                                capturing_proc: proc_id }) => {\n             let upvar_id = ty::UpvarId{ var_id: id, closure_expr_id: proc_id };\n             Some(Rc::new(LpUpvar(upvar_id)))\n@@ -724,6 +728,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     format!(\"{} in an aliasable location\",\n                              prefix).as_slice());\n             }\n+            mc::AliasableClosure(id) => {\n+                self.tcx.sess.span_err(span,\n+                                       format!(\"{} in a free variable from an \\\n+                                               immutable unboxed closure\", prefix).as_slice());\n+                span_note!(self.tcx.sess, self.tcx.map.span(id),\n+                           \"consider changing this closure to take self by mutable reference\");\n+            }\n             mc::AliasableStatic(..) |\n             mc::AliasableStaticMut(..) => {\n                 self.tcx.sess.span_err("}, {"sha": "9a0885ca30135776a118b3f2101c922af2093755", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "patch": "@@ -83,7 +83,8 @@ pub enum categorization {\n     cat_rvalue(ty::Region),            // temporary val, argument is its scope\n     cat_static_item,\n     cat_copied_upvar(CopiedUpvar),     // upvar copied into proc env\n-    cat_upvar(ty::UpvarId, ty::UpvarBorrow), // by ref upvar from stack closure\n+    cat_upvar(ty::UpvarId, ty::UpvarBorrow,\n+              Option<ty::UnboxedClosureKind>), // by ref upvar from stack or unboxed closure\n     cat_local(ast::NodeId),            // local variable\n     cat_deref(cmt, uint, PointerKind), // deref of a ptr\n     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n@@ -93,10 +94,27 @@ pub enum categorization {\n     // (*1) downcast is only required if the enum has more than one variant\n }\n \n+#[deriving(Clone, PartialEq)]\n+pub enum CopiedUpvarKind {\n+    Boxed(ast::Onceness),\n+    Unboxed(ty::UnboxedClosureKind)\n+}\n+\n+impl CopiedUpvarKind {\n+    pub fn onceness(&self) -> ast::Onceness {\n+        match *self {\n+            Boxed(onceness) => onceness,\n+            Unboxed(ty::FnUnboxedClosureKind) |\n+            Unboxed(ty::FnMutUnboxedClosureKind) => ast::Many,\n+            Unboxed(ty::FnOnceUnboxedClosureKind) => ast::Once\n+        }\n+    }\n+}\n+\n #[deriving(Clone, PartialEq)]\n pub struct CopiedUpvar {\n     pub upvar_id: ast::NodeId,\n-    pub onceness: ast::Onceness,\n+    pub kind: CopiedUpvarKind,\n     pub capturing_proc: ast::NodeId,\n }\n \n@@ -571,14 +589,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n                       };\n                       if var_is_refd {\n-                          self.cat_upvar(id, span, var_id, fn_node_id)\n+                          self.cat_upvar(id, span, var_id, fn_node_id, None)\n                       } else {\n                           Ok(Rc::new(cmt_ {\n                               id:id,\n                               span:span,\n                               cat:cat_copied_upvar(CopiedUpvar {\n                                   upvar_id: var_id,\n-                                  onceness: closure_ty.onceness,\n+                                  kind: Boxed(closure_ty.onceness),\n                                   capturing_proc: fn_node_id,\n                               }),\n                               mutbl: MutabilityCategory::from_local(self.tcx(), var_id),\n@@ -591,20 +609,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                                  .unboxed_closures()\n                                                  .borrow();\n                       let kind = unboxed_closures.get(&closure_id).kind;\n-                      let onceness = match kind {\n-                          ty::FnUnboxedClosureKind |\n-                          ty::FnMutUnboxedClosureKind => ast::Many,\n-                          ty::FnOnceUnboxedClosureKind => ast::Once,\n-                      };\n                       if self.typer.capture_mode(fn_node_id) == ast::CaptureByRef {\n-                          self.cat_upvar(id, span, var_id, fn_node_id)\n+                          self.cat_upvar(id, span, var_id, fn_node_id, Some(kind))\n                       } else {\n                           Ok(Rc::new(cmt_ {\n                               id: id,\n                               span: span,\n                               cat: cat_copied_upvar(CopiedUpvar {\n                                   upvar_id: var_id,\n-                                  onceness: onceness,\n+                                  kind: Unboxed(kind),\n                                   capturing_proc: fn_node_id,\n                               }),\n                               mutbl: MutabilityCategory::from_local(self.tcx(), var_id),\n@@ -638,7 +651,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                  id: ast::NodeId,\n                  span: Span,\n                  var_id: ast::NodeId,\n-                 fn_node_id: ast::NodeId)\n+                 fn_node_id: ast::NodeId,\n+                 kind: Option<ty::UnboxedClosureKind>)\n                  -> McResult<cmt> {\n         /*!\n          * Upvars through a closure are in fact indirect\n@@ -666,7 +680,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let base_cmt = Rc::new(cmt_ {\n             id:id,\n             span:span,\n-            cat:cat_upvar(upvar_id, upvar_borrow),\n+            cat:cat_upvar(upvar_id, upvar_borrow, kind),\n             mutbl:McImmutable,\n             ty:upvar_ty,\n         });\n@@ -1233,6 +1247,7 @@ pub enum InteriorSafety {\n \n pub enum AliasableReason {\n     AliasableBorrowed,\n+    AliasableClosure(ast::NodeId), // Aliasable due to capture by unboxed closure expr\n     AliasableOther,\n     AliasableStatic(InteriorSafety),\n     AliasableStaticMut(InteriorSafety),\n@@ -1287,18 +1302,29 @@ impl cmt_ {\n                 b.freely_aliasable(ctxt)\n             }\n \n-            cat_copied_upvar(CopiedUpvar {onceness: ast::Once, ..}) |\n             cat_rvalue(..) |\n             cat_local(..) |\n-            cat_upvar(..) |\n             cat_deref(_, _, UnsafePtr(..)) => { // yes, it's aliasable, but...\n                 None\n             }\n \n-            cat_copied_upvar(CopiedUpvar {onceness: ast::Many, ..}) => {\n-                Some(AliasableOther)\n+            cat_copied_upvar(CopiedUpvar {kind: kind, capturing_proc: id, ..}) => {\n+                match kind {\n+                    Boxed(ast::Once) |\n+                    Unboxed(ty::FnOnceUnboxedClosureKind) |\n+                    Unboxed(ty::FnMutUnboxedClosureKind) => None,\n+                    Boxed(_) => Some(AliasableOther),\n+                    Unboxed(_) => Some(AliasableClosure(id))\n+                }\n+            }\n+\n+            cat_upvar(ty::UpvarId { closure_expr_id: id, .. }, _,\n+                      Some(ty::FnUnboxedClosureKind)) => {\n+                Some(AliasableClosure(id))\n             }\n \n+            cat_upvar(..) => None,\n+\n             cat_static_item(..) => {\n                 let int_safe = if ty::type_interior_is_unsafe(ctxt, self.ty) {\n                     InteriorUnsafe"}, {"sha": "f533079be69b3ee77b3836ccd859cb38ad6de4f1", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "patch": "@@ -1552,7 +1552,7 @@ fn link_reborrowed_region(rcx: &Rcx,\n \n     // Detect references to an upvar `x`:\n     let cause = match ref_cmt.cat {\n-        mc::cat_upvar(ref upvar_id, _) => {\n+        mc::cat_upvar(ref upvar_id, _, _) => {\n             let mut upvar_borrow_map =\n                 rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n             match upvar_borrow_map.find_mut(upvar_id) {\n@@ -1686,7 +1686,7 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n             mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(base, _, mc::Implicit(..)) => {\n                 match base.cat {\n-                    mc::cat_upvar(ref upvar_id, _) => {\n+                    mc::cat_upvar(ref upvar_id, _, _) => {\n                         // if this is an implicit deref of an\n                         // upvar, then we need to modify the\n                         // borrow_kind of the upvar to make sure it\n@@ -1739,7 +1739,7 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n             mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(base, _, mc::Implicit(..)) => {\n                 match base.cat {\n-                    mc::cat_upvar(ref upvar_id, _) => {\n+                    mc::cat_upvar(ref upvar_id, _, _) => {\n                         // if this is an implicit deref of an\n                         // upvar, then we need to modify the\n                         // borrow_kind of the upvar to make sure it"}, {"sha": "2072b2ee2d2c51e163552190f71238e30eae5f98", "filename": "src/test/compile-fail/issue-17780.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Ftest%2Fcompile-fail%2Fissue-17780.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Ftest%2Fcompile-fail%2Fissue-17780.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17780.rs?ref=1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures, overloaded_calls)]\n+\n+fn set(x: &mut uint) { *x = 5; }\n+\n+fn main() {\n+    // By-ref captures\n+    {\n+        let mut x = 0u;\n+        let _f = |&:| x = 42;\n+        //~^ ERROR cannot assign to data in a free\n+        // variable from an immutable unboxed closure\n+\n+        let mut y = 0u;\n+        let _g = |&:| set(&mut y);\n+        //~^ ERROR cannot borrow data mutably in a free\n+        // variable from an immutable unboxed closure\n+\n+        let mut z = 0u;\n+        let _h = |&mut:| { set(&mut z); |&:| z = 42; };\n+        //~^ ERROR cannot assign to data in a\n+        // free variable from an immutable unboxed closure\n+    }\n+    // By-value captures\n+    {\n+        let mut x = 0u;\n+        let _f = move |&:| x = 42;\n+        //~^ ERROR cannot assign to data in a free\n+        // variable from an immutable unboxed closure\n+\n+        let mut y = 0u;\n+        let _g = move |&:| set(&mut y);\n+        //~^ ERROR cannot borrow data mutably in a free\n+        // variable from an immutable unboxed closure\n+\n+        let mut z = 0u;\n+        let _h = move |&mut:| { set(&mut z); move |&:| z = 42; };\n+        //~^ ERROR cannot assign to data in a free\n+        // variable from an immutable unboxed closure\n+    }\n+}"}, {"sha": "70d41a5c68909c984623be69a32e12b469a58135", "filename": "src/test/run-pass/unboxed-closures-by-ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Ftest%2Frun-pass%2Funboxed-closures-by-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b46b007d7d1acbbfb59c7e0f1307e6a378ab584/src%2Ftest%2Frun-pass%2Funboxed-closures-by-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-by-ref.rs?ref=1b46b007d7d1acbbfb59c7e0f1307e6a378ab584", "patch": "@@ -28,8 +28,8 @@ fn main() {\n     let mut x = 0u;\n     let y = 2u;\n \n-    call_fn(|&:| x += y);\n+    call_fn(|&:| assert_eq!(x, 0));\n     call_fn_mut(|&mut:| x += y);\n     call_fn_once(|:| x += y);\n-    assert_eq!(x, y * 3);\n+    assert_eq!(x, y * 2);\n }"}]}