{"sha": "484db5b08a83bd8875e0e938a0f78ce0a220bb17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NGRiNWIwOGE4M2JkODg3NWUwZTkzOGEwZjc4Y2UwYTIyMGJiMTc=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-06-24T00:23:53Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-09-18T19:23:01Z"}, "message": "Properly inherit conflicts when merging locals", "tree": {"sha": "b8f0716b15c3884ec12acb4af8931ab34c67dcc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8f0716b15c3884ec12acb4af8931ab34c67dcc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/484db5b08a83bd8875e0e938a0f78ce0a220bb17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/484db5b08a83bd8875e0e938a0f78ce0a220bb17", "html_url": "https://github.com/rust-lang/rust/commit/484db5b08a83bd8875e0e938a0f78ce0a220bb17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/484db5b08a83bd8875e0e938a0f78ce0a220bb17/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "934634eacc2721e482672a99f91ed458580eb978", "url": "https://api.github.com/repos/rust-lang/rust/commits/934634eacc2721e482672a99f91ed458580eb978", "html_url": "https://github.com/rust-lang/rust/commit/934634eacc2721e482672a99f91ed458580eb978"}], "stats": {"total": 137, "additions": 84, "deletions": 53}, "files": [{"sha": "cd3708374054a9c22ba4bdec63df0f13f931621b", "filename": "compiler/rustc_mir/src/transform/dest_prop.rs", "status": "modified", "additions": 60, "deletions": 53, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/484db5b08a83bd8875e0e938a0f78ce0a220bb17/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484db5b08a83bd8875e0e938a0f78ce0a220bb17/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs?ref=484db5b08a83bd8875e0e938a0f78ce0a220bb17", "patch": "@@ -166,20 +166,24 @@ impl<'tcx> MirPass<'tcx> for DestinationPropagation {\n         let mut replacements = Replacements::new(body.local_decls.len());\n         for candidate @ CandidateAssignment { dest, src, loc } in candidates {\n             // Merge locals that don't conflict.\n-            if conflicts.contains(dest.local, src) {\n+            if !conflicts.can_unify(dest.local, src) {\n                 debug!(\"at assignment {:?}, conflict {:?} vs. {:?}\", loc, dest.local, src);\n                 continue;\n             }\n \n+            if replacements.for_src(candidate.src).is_some() {\n+                debug!(\"src {:?} already has replacement\", candidate.src);\n+                continue;\n+            }\n+\n             if !tcx.consider_optimizing(|| {\n                 format!(\"DestinationPropagation {:?} {:?}\", source.def_id(), candidate)\n             }) {\n                 break;\n             }\n \n-            if replacements.push(candidate).is_ok() {\n-                conflicts.unify(candidate.src, candidate.dest.local);\n-            }\n+            replacements.push(candidate);\n+            conflicts.unify(candidate.src, candidate.dest.local);\n         }\n \n         replacements.flatten(tcx);\n@@ -220,61 +224,21 @@ struct Replacements<'tcx> {\n \n     /// Whose locals' live ranges to kill.\n     kill: BitSet<Local>,\n-\n-    /// Tracks locals that have already been merged together to prevent cycles.\n-    unified_locals: InPlaceUnificationTable<UnifyLocal>,\n }\n \n impl Replacements<'tcx> {\n     fn new(locals: usize) -> Self {\n-        Self {\n-            map: IndexVec::from_elem_n(None, locals),\n-            kill: BitSet::new_empty(locals),\n-            unified_locals: {\n-                let mut table = InPlaceUnificationTable::new();\n-                for local in 0..locals {\n-                    assert_eq!(table.new_key(()), UnifyLocal(Local::from_usize(local)));\n-                }\n-                table\n-            },\n-        }\n+        Self { map: IndexVec::from_elem_n(None, locals), kill: BitSet::new_empty(locals) }\n     }\n \n-    fn push(&mut self, candidate: CandidateAssignment<'tcx>) -> Result<(), ()> {\n-        if self.unified_locals.unioned(candidate.src, candidate.dest.local) {\n-            // Candidate conflicts with previous replacement (ie. could possibly form a cycle and\n-            // hang).\n-\n-            let replacement = self.map[candidate.src].as_mut().unwrap();\n-\n-            // If the current replacement is for the same `dest` local, there are 2 or more\n-            // equivalent `src = dest;` assignments. This is fine, the replacer will `nop` out all\n-            // of them.\n-            if replacement.local == candidate.dest.local {\n-                assert_eq!(replacement.projection, candidate.dest.projection);\n-            }\n-\n-            // We still return `Err` in any case, as `src` and `dest` do not need to be unified\n-            // *again*.\n-            trace!(\"push({:?}): already unified\", candidate);\n-            return Err(());\n-        }\n-\n+    fn push(&mut self, candidate: CandidateAssignment<'tcx>) {\n+        trace!(\"Replacements::push({:?})\", candidate);\n         let entry = &mut self.map[candidate.src];\n-        if entry.is_some() {\n-            // We're already replacing `src` with something else, so this candidate is out.\n-            trace!(\"push({:?}): src already has replacement\", candidate);\n-            return Err(());\n-        }\n-\n-        self.unified_locals.union(candidate.src, candidate.dest.local);\n+        assert!(entry.is_none());\n \n         *entry = Some(candidate.dest);\n         self.kill.insert(candidate.src);\n         self.kill.insert(candidate.dest.local);\n-\n-        trace!(\"push({:?}): accepted\", candidate);\n-        Ok(())\n     }\n \n     /// Applies the stored replacements to all replacements, until no replacements would result in\n@@ -410,6 +374,9 @@ struct Conflicts<'a> {\n \n     /// Preallocated `BitSet` used by `unify`.\n     unify_cache: BitSet<Local>,\n+\n+    /// Tracks locals that have been merged together to prevent cycles and propagate conflicts.\n+    unified_locals: InPlaceUnificationTable<UnifyLocal>,\n }\n \n impl Conflicts<'a> {\n@@ -495,6 +462,15 @@ impl Conflicts<'a> {\n             relevant_locals,\n             matrix: conflicts,\n             unify_cache: BitSet::new_empty(body.local_decls.len()),\n+            unified_locals: {\n+                let mut table = InPlaceUnificationTable::new();\n+                // Pre-fill table with all locals (this creates N nodes / \"connected\" components,\n+                // \"graph\"-ically speaking).\n+                for local in 0..body.local_decls.len() {\n+                    assert_eq!(table.new_key(()), UnifyLocal(Local::from_usize(local)));\n+                }\n+                table\n+            },\n         };\n \n         let mut live_and_init_locals = Vec::new();\n@@ -761,11 +737,31 @@ impl Conflicts<'a> {\n         }\n     }\n \n-    fn contains(&self, a: Local, b: Local) -> bool {\n-        self.matrix.contains(a, b)\n+    /// Checks whether `a` and `b` may be merged. Returns `false` if there's a conflict.\n+    fn can_unify(&mut self, a: Local, b: Local) -> bool {\n+        // After some locals have been unified, their conflicts are only tracked in the root key,\n+        // so look that up.\n+        let a = self.unified_locals.find(a).0;\n+        let b = self.unified_locals.find(b).0;\n+\n+        if a == b {\n+            // Already merged (part of the same connected component).\n+            return false;\n+        }\n+\n+        if self.matrix.contains(a, b) {\n+            // Conflict (derived via dataflow, intra-statement conflicts, or inherited from another\n+            // local during unification).\n+            return false;\n+        }\n+\n+        true\n     }\n \n     /// Merges the conflicts of `a` and `b`, so that each one inherits all conflicts of the other.\n+    /// \n+    /// `can_unify` must have returned `true` for the same locals, or this may panic or lead to\n+    /// miscompiles.\n     ///\n     /// This is called when the pass makes the decision to unify `a` and `b` (or parts of `a` and\n     /// `b`) and is needed to ensure that future unification decisions take potentially newly\n@@ -781,13 +777,24 @@ impl Conflicts<'a> {\n     /// `_2` with `_0`, which also doesn't have a conflict in the above list. However `_2` is now\n     /// `_3`, which does conflict with `_0`.\n     fn unify(&mut self, a: Local, b: Local) {\n-        // FIXME: This might be somewhat slow. Conflict graphs are undirected, maybe we can use\n-        // something with union-find to speed this up?\n-\n         trace!(\"unify({:?}, {:?})\", a, b);\n+\n+        // Get the root local of the connected components. The root local stores the conflicts of\n+        // all locals in the connected component (and *is stored* as the conflicting local of other\n+        // locals).\n+        let a = self.unified_locals.find(a).0;\n+        let b = self.unified_locals.find(b).0;\n+        assert_ne!(a, b);\n+\n+        trace!(\"roots: a={:?}, b={:?}\", a, b);\n         trace!(\"{:?} conflicts: {:?}\", a, self.matrix.iter(a).format(\", \"));\n         trace!(\"{:?} conflicts: {:?}\", b, self.matrix.iter(b).format(\", \"));\n \n+        self.unified_locals.union(a, b);\n+\n+        let root = self.unified_locals.find(a).0;\n+        assert!(root == a || root == b);\n+\n         // Make all locals that conflict with `a` also conflict with `b`, and vice versa.\n         self.unify_cache.clear();\n         for conflicts_with_a in self.matrix.iter(a) {"}, {"sha": "c27a1f04532e719b1f251fcf4766c519cf8a3e67", "filename": "src/test/ui/dest-prop/skeptic-miscompile.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/484db5b08a83bd8875e0e938a0f78ce0a220bb17/src%2Ftest%2Fui%2Fdest-prop%2Fskeptic-miscompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484db5b08a83bd8875e0e938a0f78ce0a220bb17/src%2Ftest%2Fui%2Fdest-prop%2Fskeptic-miscompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdest-prop%2Fskeptic-miscompile.rs?ref=484db5b08a83bd8875e0e938a0f78ce0a220bb17", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+\n+// compile-flags: -Zmir-opt-level=2\n+\n+trait IterExt: Iterator {\n+    fn fold_ex<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        let mut accum = init;\n+        while let Some(x) = self.next() {\n+            accum = f(accum, x);\n+        }\n+        accum\n+    }\n+}\n+\n+impl<T: Iterator> IterExt for T {}\n+\n+fn main() {\n+    let test = &[\"\\n\"];\n+    test.iter().fold_ex(String::new(), |_, b| b.to_string());\n+}"}]}