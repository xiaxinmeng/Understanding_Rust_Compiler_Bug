{"sha": "bc9ae36dba3bcacdec98af1495d99593bfc59cac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjOWFlMzZkYmEzYmNhY2RlYzk4YWYxNDk1ZDk5NTkzYmZjNTljYWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-24T14:24:42Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-04T20:06:33Z"}, "message": "Separate supertrait collection from processing a `TraitDef`. This allows\nus to construct trait-references and do other things without forcing a\nfull evaluation of the supertraits. One downside of this scheme is that\nwe must invoke `ensure_super_predicates` before using any construct that\nmight require knowing about the super-predicates.", "tree": {"sha": "37e98899e1af44a082669ea979b27b610fdf4a24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37e98899e1af44a082669ea979b27b610fdf4a24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc9ae36dba3bcacdec98af1495d99593bfc59cac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc9ae36dba3bcacdec98af1495d99593bfc59cac", "html_url": "https://github.com/rust-lang/rust/commit/bc9ae36dba3bcacdec98af1495d99593bfc59cac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc9ae36dba3bcacdec98af1495d99593bfc59cac/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ee002a17c62d5e8f42b93cb02bb366423492d98", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ee002a17c62d5e8f42b93cb02bb366423492d98", "html_url": "https://github.com/rust-lang/rust/commit/4ee002a17c62d5e8f42b93cb02bb366423492d98"}], "stats": {"total": 904, "additions": 487, "deletions": 417}, "files": [{"sha": "b28106a72e048603411146eb5baef7c07ddc8fb0", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -84,7 +84,6 @@ pub const tag_mod_impl: uint = 0x38;\n pub const tag_item_trait_item: uint = 0x39;\n \n pub const tag_item_trait_ref: uint = 0x3a;\n-pub const tag_item_super_trait_ref: uint = 0x3b;\n \n // discriminator value for variants\n pub const tag_disr_val: uint = 0x3c;\n@@ -221,8 +220,6 @@ pub const tag_struct_field_id: uint = 0x8b;\n \n pub const tag_attribute_is_sugared_doc: uint = 0x8c;\n \n-pub const tag_trait_def_bounds: uint = 0x8d;\n-\n pub const tag_items_data_region: uint = 0x8e;\n \n pub const tag_region_param_def: uint = 0x8f;\n@@ -255,3 +252,5 @@ pub const tag_paren_sugar: uint = 0xa0;\n \n pub const tag_codemap: uint = 0xa1;\n pub const tag_codemap_filemap: uint = 0xa2;\n+\n+pub const tag_item_super_predicates: uint = 0xa3;"}, {"sha": "c7785ff4c8772dde596ff9a2853b730a114d7e1f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -175,14 +175,6 @@ pub fn get_provided_trait_methods<'tcx>(tcx: &ty::ctxt<'tcx>,\n     decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                             def: ast::DefId)\n-                             -> Vec<Rc<ty::TraitRef<'tcx>>> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_supertraits(&*cdata, def.node, tcx)\n-}\n-\n pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);\n@@ -238,6 +230,14 @@ pub fn get_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n     decoder::get_predicates(&*cdata, def.node, tcx)\n }\n \n+pub fn get_super_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+                                  -> ty::GenericPredicates<'tcx>\n+{\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_super_predicates(&*cdata, def.node, tcx)\n+}\n+\n pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n                             def: ast::DefId) -> ty::TypeScheme<'tcx> {\n     let cstore = &tcx.sess.cstore;"}, {"sha": "68edae7435b971126c0ba9b812e41642fe562b48", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -22,9 +22,8 @@ use metadata::csearch::MethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n use metadata::tydecode::{parse_ty_data, parse_region_data, parse_def_id,\n-                         parse_type_param_def_data, parse_bounds_data,\n-                         parse_bare_fn_ty_data, parse_trait_ref_data,\n-                         parse_predicate_data};\n+                         parse_type_param_def_data, parse_bare_fn_ty_data,\n+                         parse_trait_ref_data, parse_predicate_data};\n use middle::def;\n use middle::lang_items;\n use middle::subst;\n@@ -260,18 +259,6 @@ fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn doc_bounds<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n-                    -> ty::ParamBounds<'tcx> {\n-    parse_bounds_data(doc.data, cdata.cnum, doc.start, tcx,\n-                      |_, did| translate_def_id(cdata, did))\n-}\n-\n-fn trait_def_bounds<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n-                          -> ty::ParamBounds<'tcx> {\n-    let d = reader::get_doc(doc, tag_trait_def_bounds);\n-    doc_bounds(d, tcx, cdata)\n-}\n-\n fn enum_variant_ids(item: rbml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n     let mut ids: Vec<ast::DefId> = Vec::new();\n     let v = tag_items_data_item_variant;\n@@ -406,7 +393,6 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n {\n     let item_doc = lookup_item(item_id, cdata.data());\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n-    let bounds = trait_def_bounds(item_doc, tcx, cdata);\n     let unsafety = parse_unsafety(item_doc);\n     let associated_type_names = parse_associated_type_names(item_doc);\n     let paren_sugar = parse_paren_sugar(item_doc);\n@@ -415,7 +401,6 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n         paren_sugar: paren_sugar,\n         unsafety: unsafety,\n         generics: generics,\n-        bounds: bounds,\n         trait_ref: item_trait_ref(item_doc, tcx, cdata),\n         associated_type_names: associated_type_names,\n     }\n@@ -430,6 +415,15 @@ pub fn get_predicates<'tcx>(cdata: Cmd,\n     doc_predicates(item_doc, tcx, cdata, tag_item_generics)\n }\n \n+pub fn get_super_predicates<'tcx>(cdata: Cmd,\n+                                  item_id: ast::NodeId,\n+                                  tcx: &ty::ctxt<'tcx>)\n+                                  -> ty::GenericPredicates<'tcx>\n+{\n+    let item_doc = lookup_item(item_id, cdata.data());\n+    doc_predicates(item_doc, tcx, cdata, tag_item_super_predicates)\n+}\n+\n pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n                       -> ty::TypeScheme<'tcx>\n {\n@@ -971,24 +965,6 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n     return result;\n }\n \n-/// Returns the supertraits of the given trait.\n-pub fn get_supertraits<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n-                             -> Vec<Rc<ty::TraitRef<'tcx>>> {\n-    let mut results = Vec::new();\n-    let item_doc = lookup_item(id, cdata.data());\n-    reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n-        // NB. Only reads the ones that *aren't* builtin-bounds. See also\n-        // get_trait_def() for collecting the builtin bounds.\n-        // FIXME(#8559): The builtin bounds shouldn't be encoded in the first place.\n-        let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n-        if tcx.lang_items.to_builtin_kind(trait_ref.def_id).is_none() {\n-            results.push(trait_ref);\n-        }\n-        true\n-    });\n-    return results;\n-}\n-\n pub fn get_type_name_if_impl(cdata: Cmd,\n                              node_id: ast::NodeId) -> Option<ast::Name> {\n     let item = lookup_item(node_id, cdata.data());"}, {"sha": "c4ba2373b9f570cb624d9fe4ed43e40e9045af81", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -206,21 +206,6 @@ pub fn write_region(ecx: &EncodeContext,\n     tyencode::enc_region(rbml_w, ty_str_ctxt, r);\n }\n \n-fn encode_bounds<'a, 'tcx>(rbml_w: &mut Encoder,\n-                           ecx: &EncodeContext<'a, 'tcx>,\n-                           bounds: &ty::ParamBounds<'tcx>,\n-                           tag: uint) {\n-    rbml_w.start_tag(tag);\n-\n-    let ty_str_ctxt = &tyencode::ctxt { diag: ecx.diag,\n-                                        ds: def_to_string,\n-                                        tcx: ecx.tcx,\n-                                        abbrevs: &ecx.type_abbrevs };\n-    tyencode::enc_bounds(rbml_w, ty_str_ctxt, bounds);\n-\n-    rbml_w.end_tag();\n-}\n-\n fn encode_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                          rbml_w: &mut Encoder,\n                          typ: Ty<'tcx>) {\n@@ -728,6 +713,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n+\n     for param in generics.types.iter() {\n         rbml_w.start_tag(tag_type_param_def);\n         tyencode::enc_type_param_def(rbml_w, ty_str_ctxt, param);\n@@ -758,6 +744,22 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n     }\n \n+    encode_predicates_in_current_doc(rbml_w, ecx, predicates);\n+\n+    rbml_w.end_tag();\n+}\n+\n+fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n+                                             ecx: &EncodeContext<'a,'tcx>,\n+                                             predicates: &ty::GenericPredicates<'tcx>)\n+{\n+    let ty_str_ctxt = &tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_string,\n+        tcx: ecx.tcx,\n+        abbrevs: &ecx.type_abbrevs\n+    };\n+\n     for (space, _, predicate) in predicates.predicates.iter_enumerated() {\n         rbml_w.start_tag(tag_predicate);\n \n@@ -769,7 +771,15 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n \n         rbml_w.end_tag();\n     }\n+}\n \n+fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n+                              ecx: &EncodeContext<'a,'tcx>,\n+                              predicates: &ty::GenericPredicates<'tcx>,\n+                              tag: uint)\n+{\n+    rbml_w.start_tag(tag);\n+    encode_predicates_in_current_doc(rbml_w, ecx, predicates);\n     rbml_w.end_tag();\n }\n \n@@ -1280,6 +1290,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n         encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n         encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates, tag_item_generics);\n+        encode_predicates(rbml_w, ecx, &ty::lookup_super_predicates(tcx, def_id),\n+                          tag_item_super_predicates);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, &item.attrs);\n@@ -1304,8 +1316,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         encode_path(rbml_w, path.clone());\n \n-        encode_bounds(rbml_w, ecx, &trait_def.bounds, tag_trait_def_bounds);\n-\n         // Encode the implementations of this trait.\n         encode_extension_implementations(ecx, rbml_w, def_id);\n "}, {"sha": "881487a2dad1150b6e9423075c14fbfb042258db", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -22,7 +22,7 @@ use super::elaborate_predicates;\n \n use middle::subst::{self, SelfSpace, TypeSpace};\n use middle::traits;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, ToPolyTraitRef, Ty};\n use std::rc::Rc;\n use syntax::ast;\n use util::ppaux::Repr;\n@@ -128,9 +128,12 @@ fn supertraits_reference_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n     let trait_ref = trait_def.trait_ref.clone();\n-    let predicates = ty::predicates_for_trait_ref(tcx, &ty::Binder(trait_ref));\n+    let trait_ref = trait_ref.to_poly_trait_ref();\n+    let predicates = ty::lookup_super_predicates(tcx, trait_def_id);\n     predicates\n+        .predicates\n         .into_iter()\n+        .map(|predicate| predicate.subst_supertrait(tcx, &trait_ref))\n         .any(|predicate| {\n             match predicate {\n                 ty::Predicate::Trait(ref data) => {"}, {"sha": "36efec0a367fdddf9bdd453b0562bfd5be59b342", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -1455,9 +1455,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             let principal =\n                                 data.principal_trait_ref_with_self_ty(self.tcx(),\n                                                                       self.tcx().types.err);\n+                            let desired_def_id = obligation.predicate.def_id();\n                             for tr in util::supertraits(self.tcx(), principal) {\n-                                let td = ty::lookup_trait_def(self.tcx(), tr.def_id());\n-                                if td.bounds.builtin_bounds.contains(&bound) {\n+                                if tr.def_id() == desired_def_id {\n                                     return Ok(If(Vec::new()))\n                                 }\n                             }"}, {"sha": "0366fc07855e4399a92ecd3b0e50e1d445697cc3", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -117,9 +117,17 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n     fn push(&mut self, predicate: &ty::Predicate<'tcx>) {\n         match *predicate {\n             ty::Predicate::Trait(ref data) => {\n-                let mut predicates =\n-                    ty::predicates_for_trait_ref(self.tcx,\n-                                                 &data.to_poly_trait_ref());\n+                // Predicates declared on the trait.\n+                let predicates = ty::lookup_super_predicates(self.tcx, data.def_id());\n+\n+                let mut predicates: Vec<_> =\n+                    predicates.predicates\n+                              .iter()\n+                              .map(|p| p.subst_supertrait(self.tcx, &data.to_poly_trait_ref()))\n+                              .collect();\n+\n+                debug!(\"super_predicates: data={} predicates={}\",\n+                       data.repr(self.tcx), predicates.repr(self.tcx));\n \n                 // Only keep those bounds that we haven't already\n                 // seen.  This is necessary to prevent infinite"}, {"sha": "dfdb4002be24d1ee422eeed9571e3dfdd309e417", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 137, "deletions": 123, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -17,7 +17,6 @@ pub use self::InferTy::*;\n pub use self::InferRegion::*;\n pub use self::ImplOrTraitItemId::*;\n pub use self::ClosureKind::*;\n-pub use self::ast_ty_to_ty_cache_entry::*;\n pub use self::Variance::*;\n pub use self::AutoAdjustment::*;\n pub use self::Representability::*;\n@@ -266,12 +265,6 @@ pub struct creader_cache_key {\n     pub len: uint\n }\n \n-#[derive(Copy)]\n-pub enum ast_ty_to_ty_cache_entry<'tcx> {\n-    atttce_unresolved,  /* not resolved yet */\n-    atttce_resolved(Ty<'tcx>)  /* resolved to a type, irrespective of region */\n-}\n-\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct ItemVariances {\n     pub types: VecPerParamSpace<Variance>,\n@@ -716,6 +709,14 @@ pub struct ctxt<'tcx> {\n     /// associated predicates.\n     pub predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n \n+    /// Maps from the def-id of a trait to the list of\n+    /// super-predicates. This is a subset of the full list of\n+    /// predicates. We store these in a separate map because we must\n+    /// evaluate them even during type conversion, often before the\n+    /// full predicates are available (note that supertraits have\n+    /// additional acyclicity requirements).\n+    pub super_predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n+\n     /// Maps from node-id of a trait object cast (like `foo as\n     /// Box<Trait>`) to the trait reference.\n     pub object_cast_map: ObjectCastMap<'tcx>,\n@@ -727,7 +728,7 @@ pub struct ctxt<'tcx> {\n     pub rcache: RefCell<FnvHashMap<creader_cache_key, Ty<'tcx>>>,\n     pub short_names_cache: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n     pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, TypeContents>>,\n-    pub ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry<'tcx>>>,\n+    pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n     pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo<'tcx>>>>>>,\n     pub ty_param_defs: RefCell<NodeMap<TypeParameterDef<'tcx>>>,\n     pub adjustments: RefCell<NodeMap<AutoAdjustment<'tcx>>>,\n@@ -1352,7 +1353,7 @@ pub enum sty<'tcx> {\n     /// definition and not a concrete use of it. To get the correct `ty_enum`\n     /// from the tcx, use the `NodeId` from the `ast::Ty` and look it up in\n     /// the `ast_ty_to_ty_cache`. This is probably true for `ty_struct` as\n-    /// well.`\n+    /// well.\n     ty_enum(DefId, &'tcx Substs<'tcx>),\n     ty_uniq(Ty<'tcx>),\n     ty_str,\n@@ -1495,6 +1496,27 @@ impl<'tcx> PolyTraitRef<'tcx> {\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Binder<T>(pub T);\n \n+impl<T> Binder<T> {\n+    /// Skips the binder and returns the \"bound\" value. This is a\n+    /// risky thing to do because it's easy to get confused about\n+    /// debruijn indices and the like. It is usually better to\n+    /// discharge the binder using `no_late_bound_regions` or\n+    /// `replace_late_bound_regions` or something like\n+    /// that. `skip_binder` is only valid when you are either\n+    /// extracting data that has nothing to do with bound regions, you\n+    /// are doing some sort of test that does not involve bound\n+    /// regions, or you are being very careful about your depth\n+    /// accounting.\n+    ///\n+    /// Some examples where `skip_binder` is reasonable:\n+    /// - extracting the def-id from a PolyTraitRef;\n+    /// - compariing the self type of a PolyTraitRef to see if it is equal to\n+    ///   a type parameter `X`, since the type `X`  does not reference any regions\n+    pub fn skip_binder(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq)]\n pub enum IntVarValue {\n     IntType(ast::IntTy),\n@@ -1817,6 +1839,16 @@ impl<'tcx> GenericPredicates<'tcx> {\n             predicates: self.predicates.subst(tcx, substs),\n         }\n     }\n+\n+    pub fn instantiate_supertrait(&self,\n+                                  tcx: &ty::ctxt<'tcx>,\n+                                  poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n+                                  -> InstantiatedPredicates<'tcx>\n+    {\n+        InstantiatedPredicates {\n+            predicates: self.predicates.map(|pred| pred.subst_supertrait(tcx, poly_trait_ref))\n+        }\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n@@ -1840,6 +1872,93 @@ pub enum Predicate<'tcx> {\n     Projection(PolyProjectionPredicate<'tcx>),\n }\n \n+impl<'tcx> Predicate<'tcx> {\n+    /// Performs a substituion suitable for going from a\n+    /// poly-trait-ref to supertraits that must hold if that\n+    /// poly-trait-ref holds. This is slightly different from a normal\n+    /// substitution in terms of what happens with bound regions.  See\n+    /// lengthy comment below for details.\n+    pub fn subst_supertrait(&self,\n+                            tcx: &ty::ctxt<'tcx>,\n+                            trait_ref: &ty::PolyTraitRef<'tcx>)\n+                            -> ty::Predicate<'tcx>\n+    {\n+        // The interaction between HRTB and supertraits is not entirely\n+        // obvious. Let me walk you (and myself) through an example.\n+        //\n+        // Let's start with an easy case. Consider two traits:\n+        //\n+        //     trait Foo<'a> : Bar<'a,'a> { }\n+        //     trait Bar<'b,'c> { }\n+        //\n+        // Now, if we have a trait reference `for<'x> T : Foo<'x>`, then\n+        // we can deduce that `for<'x> T : Bar<'x,'x>`. Basically, if we\n+        // knew that `Foo<'x>` (for any 'x) then we also know that\n+        // `Bar<'x,'x>` (for any 'x). This more-or-less falls out from\n+        // normal substitution.\n+        //\n+        // In terms of why this is sound, the idea is that whenever there\n+        // is an impl of `T:Foo<'a>`, it must show that `T:Bar<'a,'a>`\n+        // holds.  So if there is an impl of `T:Foo<'a>` that applies to\n+        // all `'a`, then we must know that `T:Bar<'a,'a>` holds for all\n+        // `'a`.\n+        //\n+        // Another example to be careful of is this:\n+        //\n+        //     trait Foo1<'a> : for<'b> Bar1<'a,'b> { }\n+        //     trait Bar1<'b,'c> { }\n+        //\n+        // Here, if we have `for<'x> T : Foo1<'x>`, then what do we know?\n+        // The answer is that we know `for<'x,'b> T : Bar1<'x,'b>`. The\n+        // reason is similar to the previous example: any impl of\n+        // `T:Foo1<'x>` must show that `for<'b> T : Bar1<'x, 'b>`.  So\n+        // basically we would want to collapse the bound lifetimes from\n+        // the input (`trait_ref`) and the supertraits.\n+        //\n+        // To achieve this in practice is fairly straightforward. Let's\n+        // consider the more complicated scenario:\n+        //\n+        // - We start out with `for<'x> T : Foo1<'x>`. In this case, `'x`\n+        //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T : Bar1<'x,'b>`,\n+        //   where both `'x` and `'b` would have a DB index of 1.\n+        //   The substitution from the input trait-ref is therefore going to be\n+        //   `'a => 'x` (where `'x` has a DB index of 1).\n+        // - The super-trait-ref is `for<'b> Bar1<'a,'b>`, where `'a` is an\n+        //   early-bound parameter and `'b' is a late-bound parameter with a\n+        //   DB index of 1.\n+        // - If we replace `'a` with `'x` from the input, it too will have\n+        //   a DB index of 1, and thus we'll have `for<'x,'b> Bar1<'x,'b>`\n+        //   just as we wanted.\n+        //\n+        // There is only one catch. If we just apply the substitution `'a\n+        // => 'x` to `for<'b> Bar1<'a,'b>`, the substitution code will\n+        // adjust the DB index because we substituting into a binder (it\n+        // tries to be so smart...) resulting in `for<'x> for<'b>\n+        // Bar1<'x,'b>` (we have no syntax for this, so use your\n+        // imagination). Basically the 'x will have DB index of 2 and 'b\n+        // will have DB index of 1. Not quite what we want. So we apply\n+        // the substitution to the *contents* of the trait reference,\n+        // rather than the trait reference itself (put another way, the\n+        // substitution code expects equal binding levels in the values\n+        // from the substitution and the value being substituted into, and\n+        // this trick achieves that).\n+\n+        let substs = &trait_ref.0.substs;\n+        match *self {\n+            Predicate::Trait(ty::Binder(ref data)) =>\n+                Predicate::Trait(ty::Binder(data.subst(tcx, substs))),\n+            Predicate::Equate(ty::Binder(ref data)) =>\n+                Predicate::Equate(ty::Binder(data.subst(tcx, substs))),\n+            Predicate::RegionOutlives(ty::Binder(ref data)) =>\n+                Predicate::RegionOutlives(ty::Binder(data.subst(tcx, substs))),\n+            Predicate::TypeOutlives(ty::Binder(ref data)) =>\n+                Predicate::TypeOutlives(ty::Binder(data.subst(tcx, substs))),\n+            Predicate::Projection(ty::Binder(ref data)) =>\n+                Predicate::Projection(ty::Binder(data.subst(tcx, substs))),\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: Rc<TraitRef<'tcx>>\n@@ -2324,9 +2443,6 @@ pub struct TraitDef<'tcx> {\n     /// implements the trait.\n     pub generics: Generics<'tcx>,\n \n-    /// The \"supertrait\" bounds.\n-    pub bounds: ParamBounds<'tcx>,\n-\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n     /// A list of the associated types defined in this trait. Useful\n@@ -2451,6 +2567,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         impl_trait_refs: RefCell::new(NodeMap()),\n         trait_defs: RefCell::new(DefIdMap()),\n         predicates: RefCell::new(DefIdMap()),\n+        super_predicates: RefCell::new(DefIdMap()),\n         object_cast_map: RefCell::new(NodeMap()),\n         map: map,\n         intrinsic_defs: RefCell::new(DefIdMap()),\n@@ -5432,7 +5549,7 @@ pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n     })\n }\n \n-/// Given the did of a trait, returns its full set of predicates.\n+/// Given the did of an item, returns its full set of predicates.\n pub fn lookup_predicates<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n                                 -> GenericPredicates<'tcx>\n {\n@@ -5442,117 +5559,14 @@ pub fn lookup_predicates<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n     })\n }\n \n-/// Given a reference to a trait, returns the \"superbounds\" declared\n-/// on the trait, with appropriate substitutions applied. Basically,\n-/// this applies a filter to the where clauses on the trait, returning\n-/// those that have the form:\n-///\n-///     Self : SuperTrait<...>\n-///     Self : 'region\n-pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n-                                      trait_ref: &PolyTraitRef<'tcx>)\n-                                      -> Vec<ty::Predicate<'tcx>>\n+/// Given the did of a trait, returns its superpredicates.\n+pub fn lookup_super_predicates<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n+                                     -> GenericPredicates<'tcx>\n {\n-    let trait_def = lookup_trait_def(tcx, trait_ref.def_id());\n-\n-    debug!(\"bounds_for_trait_ref(trait_def={:?}, trait_ref={:?})\",\n-           trait_def.repr(tcx), trait_ref.repr(tcx));\n-\n-    // The interaction between HRTB and supertraits is not entirely\n-    // obvious. Let me walk you (and myself) through an example.\n-    //\n-    // Let's start with an easy case. Consider two traits:\n-    //\n-    //     trait Foo<'a> : Bar<'a,'a> { }\n-    //     trait Bar<'b,'c> { }\n-    //\n-    // Now, if we have a trait reference `for<'x> T : Foo<'x>`, then\n-    // we can deduce that `for<'x> T : Bar<'x,'x>`. Basically, if we\n-    // knew that `Foo<'x>` (for any 'x) then we also know that\n-    // `Bar<'x,'x>` (for any 'x). This more-or-less falls out from\n-    // normal substitution.\n-    //\n-    // In terms of why this is sound, the idea is that whenever there\n-    // is an impl of `T:Foo<'a>`, it must show that `T:Bar<'a,'a>`\n-    // holds.  So if there is an impl of `T:Foo<'a>` that applies to\n-    // all `'a`, then we must know that `T:Bar<'a,'a>` holds for all\n-    // `'a`.\n-    //\n-    // Another example to be careful of is this:\n-    //\n-    //     trait Foo1<'a> : for<'b> Bar1<'a,'b> { }\n-    //     trait Bar1<'b,'c> { }\n-    //\n-    // Here, if we have `for<'x> T : Foo1<'x>`, then what do we know?\n-    // The answer is that we know `for<'x,'b> T : Bar1<'x,'b>`. The\n-    // reason is similar to the previous example: any impl of\n-    // `T:Foo1<'x>` must show that `for<'b> T : Bar1<'x, 'b>`.  So\n-    // basically we would want to collapse the bound lifetimes from\n-    // the input (`trait_ref`) and the supertraits.\n-    //\n-    // To achieve this in practice is fairly straightforward. Let's\n-    // consider the more complicated scenario:\n-    //\n-    // - We start out with `for<'x> T : Foo1<'x>`. In this case, `'x`\n-    //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T : Bar1<'x,'b>`,\n-    //   where both `'x` and `'b` would have a DB index of 1.\n-    //   The substitution from the input trait-ref is therefore going to be\n-    //   `'a => 'x` (where `'x` has a DB index of 1).\n-    // - The super-trait-ref is `for<'b> Bar1<'a,'b>`, where `'a` is an\n-    //   early-bound parameter and `'b' is a late-bound parameter with a\n-    //   DB index of 1.\n-    // - If we replace `'a` with `'x` from the input, it too will have\n-    //   a DB index of 1, and thus we'll have `for<'x,'b> Bar1<'x,'b>`\n-    //   just as we wanted.\n-    //\n-    // There is only one catch. If we just apply the substitution `'a\n-    // => 'x` to `for<'b> Bar1<'a,'b>`, the substitution code will\n-    // adjust the DB index because we substituting into a binder (it\n-    // tries to be so smart...) resulting in `for<'x> for<'b>\n-    // Bar1<'x,'b>` (we have no syntax for this, so use your\n-    // imagination). Basically the 'x will have DB index of 2 and 'b\n-    // will have DB index of 1. Not quite what we want. So we apply\n-    // the substitution to the *contents* of the trait reference,\n-    // rather than the trait reference itself (put another way, the\n-    // substitution code expects equal binding levels in the values\n-    // from the substitution and the value being substituted into, and\n-    // this trick achieves that).\n-\n-    // Carefully avoid the binder introduced by each trait-ref by\n-    // substituting over the substs, not the trait-refs themselves,\n-    // thus achieving the \"collapse\" described in the big comment\n-    // above.\n-    let trait_bounds: Vec<_> =\n-        trait_def.bounds.trait_bounds\n-        .iter()\n-        .map(|poly_trait_ref| ty::Binder(poly_trait_ref.0.subst(tcx, trait_ref.substs())))\n-        .collect();\n-\n-    let projection_bounds: Vec<_> =\n-        trait_def.bounds.projection_bounds\n-        .iter()\n-        .map(|poly_proj| ty::Binder(poly_proj.0.subst(tcx, trait_ref.substs())))\n-        .collect();\n-\n-    debug!(\"bounds_for_trait_ref: trait_bounds={} projection_bounds={}\",\n-           trait_bounds.repr(tcx),\n-           projection_bounds.repr(tcx));\n-\n-    // The region bounds and builtin bounds do not currently introduce\n-    // binders so we can just substitute in a straightforward way here.\n-    let region_bounds =\n-        trait_def.bounds.region_bounds.subst(tcx, trait_ref.substs());\n-    let builtin_bounds =\n-        trait_def.bounds.builtin_bounds.subst(tcx, trait_ref.substs());\n-\n-    let bounds = ty::ParamBounds {\n-        trait_bounds: trait_bounds,\n-        region_bounds: region_bounds,\n-        builtin_bounds: builtin_bounds,\n-        projection_bounds: projection_bounds,\n-    };\n-\n-    predicates(tcx, trait_ref.self_ty(), &bounds)\n+    memoized(&cx.super_predicates, did, |did: DefId| {\n+        assert!(did.krate != ast::LOCAL_CRATE);\n+        csearch::get_super_predicates(cx, did)\n+    })\n }\n \n pub fn predicates<'tcx>("}, {"sha": "09a122544147704a16436c54460d73e9ef94a341", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -820,9 +820,8 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n \n impl<'tcx> Repr<'tcx> for ty::TraitDef<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"TraitDef(generics={}, bounds={}, trait_ref={})\",\n+        format!(\"TraitDef(generics={}, trait_ref={})\",\n                 self.generics.repr(tcx),\n-                self.bounds.repr(tcx),\n                 self.trait_ref.repr(tcx))\n     }\n }"}, {"sha": "3682fdb74b74f6103fec44006541169bd4d833f4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -432,8 +432,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             }\n             def::DefTy(..) => {\n                 let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n-                    Some(&ty::atttce_resolved(t)) => t,\n-                    _ => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n+                    Some(&t) => t,\n+                    None => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n                 };\n \n                 if !ty::is_ffi_safe(self.cx.tcx, tty) {"}, {"sha": "0da2c86066ae9bb7b982e29749a946544979adb7", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -59,7 +59,6 @@ use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n-use util::nodemap::DefIdMap;\n use util::ppaux::{self, Repr, UserString};\n \n use std::iter::{repeat, AdditiveIterator};\n@@ -73,15 +72,30 @@ use syntax::print::pprust;\n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n \n+    /// Identify the type scheme for an item with a type, like a type\n+    /// alias, fn, or struct. This allows you to figure out the set of\n+    /// type parameters defined on the item.\n     fn get_item_type_scheme(&self, span: Span, id: ast::DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>;\n \n+    /// Returns the `TraitDef` for a given trait. This allows you to\n+    /// figure out the set of type parameters defined on the trait.\n     fn get_trait_def(&self, span: Span, id: ast::DefId)\n                      -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>;\n \n+    /// Ensure that the super-predicates for the trait with the given\n+    /// id are available and also for the transitive set of\n+    /// super-predicates.\n+    fn ensure_super_predicates(&self, span: Span, id: ast::DefId)\n+                               -> Result<(), ErrorReported>;\n+\n+    /// Returns the set of bounds in scope for the type parameter with\n+    /// the given id.\n     fn get_type_parameter_bounds(&self, span: Span, def_id: ast::NodeId)\n                                  -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>;\n \n+    /// Returns true if the trait with id `trait_def_id` defines an\n+    /// associated type with the name `name`.\n     fn trait_defines_associated_type_named(&self, trait_def_id: ast::DefId, name: ast::Name)\n                                            -> bool;\n \n@@ -813,6 +827,8 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n                                               tcx.mk_substs(dummy_substs)));\n     }\n \n+    try!(this.ensure_super_predicates(binding.span, trait_ref.def_id));\n+\n     let mut candidates: Vec<ty::PolyTraitRef> =\n         traits::supertraits(tcx, trait_ref.to_poly_trait_ref())\n         .filter(|r| this.trait_defines_associated_type_named(r.def_id(), binding.item_name))\n@@ -1032,10 +1048,15 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     let ty_param_name = tcx.ty_param_defs.borrow()[ty_param_node_id].name;\n \n-    // FIXME(#20300) -- search where clauses, not bounds\n-    let bounds =\n-        this.get_type_parameter_bounds(span, ty_param_node_id)\n-            .unwrap_or(Vec::new());\n+    let bounds = match this.get_type_parameter_bounds(span, ty_param_node_id) {\n+        Ok(v) => v,\n+        Err(ErrorReported) => { return (tcx.types.err, ty_path_def); }\n+    };\n+\n+    // ensure the super predicates and stop if we encountered an error\n+    if bounds.iter().any(|b| this.ensure_super_predicates(span, b.def_id()).is_err()) {\n+        return (this.tcx().types.err, ty_path_def);\n+    }\n \n     let mut suitable_bounds: Vec<_> =\n         traits::transitive_bounds(tcx, &bounds)\n@@ -1268,20 +1289,9 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     let tcx = this.tcx();\n \n-    let mut ast_ty_to_ty_cache = tcx.ast_ty_to_ty_cache.borrow_mut();\n-    match ast_ty_to_ty_cache.get(&ast_ty.id) {\n-        Some(&ty::atttce_resolved(ty)) => return ty,\n-        Some(&ty::atttce_unresolved) => {\n-            span_err!(tcx.sess, ast_ty.span, E0246,\n-                                \"illegal recursive type; insert an enum \\\n-                                 or struct in the cycle, if this is \\\n-                                 desired\");\n-            return this.tcx().types.err;\n-        }\n-        None => { /* go on */ }\n+    if let Some(&ty) = tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n+        return ty;\n     }\n-    ast_ty_to_ty_cache.insert(ast_ty.id, ty::atttce_unresolved);\n-    drop(ast_ty_to_ty_cache);\n \n     let typ = match ast_ty.node {\n         ast::TyVec(ref ty) => {\n@@ -1414,7 +1424,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n     };\n \n-    tcx.ast_ty_to_ty_cache.borrow_mut().insert(ast_ty.id, ty::atttce_resolved(typ));\n+    tcx.ast_ty_to_ty_cache.borrow_mut().insert(ast_ty.id, typ);\n     return typ;\n }\n \n@@ -1831,6 +1841,10 @@ fn compute_object_lifetime_bound<'tcx>(\n         return ast_region_to_region(tcx, r);\n     }\n \n+    if let Err(ErrorReported) = this.ensure_super_predicates(span,principal_trait_ref.def_id()) {\n+        return ty::ReStatic;\n+    }\n+\n     // No explicit region bound specified. Therefore, examine trait\n     // bounds and see if we can derive region bounds from those.\n     let derived_region_bounds =\n@@ -1916,34 +1930,11 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     let mut builtin_bounds = ty::empty_builtin_bounds();\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n-    let mut trait_def_ids = DefIdMap();\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b, ast::TraitBoundModifier::None) => {\n                 match ::lookup_full_def(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n                     def::DefTrait(trait_did) => {\n-                        match trait_def_ids.get(&trait_did) {\n-                            // Already seen this trait. We forbid\n-                            // duplicates in the list (for some\n-                            // reason).\n-                            Some(span) => {\n-                                span_err!(\n-                                    tcx.sess, b.trait_ref.path.span, E0127,\n-                                    \"trait `{}` already appears in the \\\n-                                     list of bounds\",\n-                                    b.trait_ref.path.user_string(tcx));\n-                                tcx.sess.span_note(\n-                                    *span,\n-                                    \"previous appearance is here\");\n-\n-                                continue;\n-                            }\n-\n-                            None => { }\n-                        }\n-\n-                        trait_def_ids.insert(trait_did, b.trait_ref.path.span);\n-\n                         if ty::try_add_builtin_trait(tcx,\n                                                      trait_did,\n                                                      &mut builtin_bounds) {"}, {"sha": "718804d317fb09c6a8169b5562d7fdc888a674d4", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -456,13 +456,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"elaborate_bounds(bounds={})\", bounds.repr(self.tcx()));\n \n         let tcx = self.tcx();\n-        let mut cache = HashSet::new();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            // Already visited this trait, skip it.\n-            if !cache.insert(bound_trait_ref.def_id()) {\n-                continue;\n-            }\n-\n             let (pos, method) = match trait_method(tcx,\n                                                    bound_trait_ref.def_id(),\n                                                    self.method_name) {\n@@ -1269,10 +1263,12 @@ impl<'tcx> Candidate<'tcx> {\n \n     fn to_trait_data(&self) -> Option<(ast::DefId,MethodIndex)> {\n         match self.kind {\n-            InherentImplCandidate(..) |\n-            ObjectCandidate(..) => {\n+            InherentImplCandidate(..) => {\n                 None\n             }\n+            ObjectCandidate(trait_def_id, method_num, _) => {\n+                Some((trait_def_id, method_num))\n+            }\n             ClosureCandidate(trait_def_id, method_num) => {\n                 Some((trait_def_id, method_num))\n             }"}, {"sha": "9db98bf00cda85fa5fad708d4927edb1789bd182", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -1218,6 +1218,11 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         Ok(ty::lookup_trait_def(self.tcx(), id))\n     }\n \n+    fn ensure_super_predicates(&self, _: Span, _: ast::DefId) -> Result<(), ErrorReported> {\n+        // all super predicates are ensured during collect pass\n+        Ok(())\n+    }\n+\n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n         Some(&self.inh.param_env.free_substs)\n     }"}, {"sha": "fcc5eea76062d817c811cd225cb237c172077ca4", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -281,12 +281,13 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // Find the supertrait bounds. This will add `int:Bar`.\n             let poly_trait_ref = ty::Binder(trait_ref);\n-            let predicates = ty::predicates_for_trait_ref(fcx.tcx(), &poly_trait_ref);\n+            let predicates = ty::lookup_super_predicates(fcx.tcx(), poly_trait_ref.def_id());\n+            let predicates = predicates.instantiate_supertrait(fcx.tcx(), &poly_trait_ref);\n             let predicates = {\n                 let selcx = &mut traits::SelectionContext::new(fcx.infcx(), fcx);\n                 traits::normalize(selcx, cause.clone(), &predicates)\n             };\n-            for predicate in predicates.value {\n+            for predicate in predicates.value.predicates {\n                 fcx.register_predicate(traits::Obligation::new(cause.clone(), predicate));\n             }\n             for obligation in predicates.obligations {"}, {"sha": "8f9ede32ae4db57dcd0b0f9a0fb486122fc4aee7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 214, "deletions": 146, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -26,35 +26,17 @@ represented by an instance of `ty::TypeScheme`.  This combines the\n core type along with a list of the bounds for each parameter. Type\n parameters themselves are represented as `ty_param()` instances.\n \n-The phasing of type conversion is somewhat complicated. There are a\n-number of possible cycles that can arise.\n-\n-Converting types can require:\n-\n-1. `Foo<X>` where `Foo` is a type alias, or trait requires knowing:\n-   - number of region / type parameters\n-   - for type parameters, `T:'a` annotations to control defaults for object lifetimes\n-   - defaults for type parameters (which are themselves types!)\n-2. `Foo<X>` where `Foo` is a type alias requires knowing what `Foo` expands to\n-3. Translating `SomeTrait` with no explicit lifetime bound requires knowing\n-   - supertraits of `SomeTrait`\n-4. Translating `T::X` (vs `<T as Trait>::X`) requires knowing\n-   - bounds on `T`\n-   - supertraits of those bounds\n-\n-So as you can see, in general translating types requires knowing the\n-trait hierarchy. But this gets a bit tricky because translating the\n-trait hierarchy requires converting the types that appear in trait\n-references. One potential saving grace is that in general knowing the\n-trait hierarchy is only necessary for shorthands like `T::X` or\n-handling omitted lifetime bounds on object types. Therefore, if we are\n-lazy about expanding out the trait hierachy, users can sever cycles if\n-necessary. Lazy expansion is also needed for type aliases.\n-\n-This system is not perfect yet. Currently, we \"convert\" types and\n-traits in three phases (note that conversion only affects the types of\n-items / enum variants / methods; it does not e.g. compute the types of\n-individual expressions):\n+The phasing of type conversion is somewhat complicated. There is no\n+clear set of phases we can enforce (e.g., converting traits first,\n+then types, or something like that) because the user can introduce\n+arbitrary interdependencies. So instead we generally convert things\n+lazilly and on demand, and include logic that checks for cycles.\n+Demand is driven by calls to `AstConv::get_item_type_scheme` or\n+`AstConv::lookup_trait_def`.\n+\n+Currently, we \"convert\" types and traits in three phases (note that\n+conversion only affects the types of items / enum variants / methods;\n+it does not e.g. compute the types of individual expressions):\n \n 0. Intrinsics\n 1. Trait definitions\n@@ -64,16 +46,13 @@ Conversion itself is done by simply walking each of the items in turn\n and invoking an appropriate function (e.g., `trait_def_of_item` or\n `convert_item`). However, it is possible that while converting an\n item, we may need to compute the *type scheme* or *trait definition*\n-for other items. This is a kind of shallow conversion that is\n-triggered on demand by calls to `AstConv::get_item_type_scheme` or\n-`AstConv::lookup_trait_def`. It is possible for cycles to result from\n-this (e.g., `type A = B; type B = A;`), in which case astconv\n-(currently) reports the error.\n+for other items.\n \n There are some shortcomings in this design:\n \n-- Cycles through trait definitions (e.g. supertraits) are not currently\n-  detected by astconv. (#12511)\n+- Before walking the set of supertraits for a given trait, you must\n+  call `ensure_super_predicates` on that trait def-id. Otherwise,\n+  `lookup_super_predicates` will result in ICEs.\n - Because the type scheme includes defaults, cycles through type\n   parameter defaults are illegal even if those defaults are never\n   employed. This is not necessarily a bug.\n@@ -169,6 +148,7 @@ struct ItemCtxt<'a,'tcx:'a> {\n enum AstConvRequest {\n     GetItemTypeScheme(ast::DefId),\n     GetTraitDef(ast::DefId),\n+    EnsureSuperPredicates(ast::DefId),\n     GetTypeParameterBounds(ast::NodeId),\n }\n \n@@ -245,7 +225,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                         request: AstConvRequest,\n                         code: F)\n                         -> Result<R,ErrorReported>\n-        where F: FnOnce() -> R\n+        where F: FnOnce() -> Result<R,ErrorReported>\n     {\n         {\n             let mut stack = self.stack.borrow_mut();\n@@ -263,7 +243,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         let result = code();\n \n         self.stack.borrow_mut().pop();\n-        Ok(result)\n+        result\n     }\n \n     fn report_cycle(&self,\n@@ -284,6 +264,11 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                     &format!(\"the cycle begins when processing `{}`...\",\n                              ty::item_path_str(tcx, def_id)));\n             }\n+            AstConvRequest::EnsureSuperPredicates(def_id) => {\n+                tcx.sess.note(\n+                    &format!(\"the cycle begins when computing the supertraits of `{}`...\",\n+                             ty::item_path_str(tcx, def_id)));\n+            }\n             AstConvRequest::GetTypeParameterBounds(id) => {\n                 let def = tcx.type_parameter_def(id);\n                 tcx.sess.note(\n@@ -301,6 +286,11 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                         &format!(\"...which then requires processing `{}`...\",\n                                  ty::item_path_str(tcx, def_id)));\n                 }\n+                AstConvRequest::EnsureSuperPredicates(def_id) => {\n+                    tcx.sess.note(\n+                        &format!(\"...which then requires computing the supertraits of `{}`...\",\n+                                 ty::item_path_str(tcx, def_id)));\n+                }\n                 AstConvRequest::GetTypeParameterBounds(id) => {\n                     let def = tcx.type_parameter_def(id);\n                     tcx.sess.note(\n@@ -318,6 +308,12 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                     &format!(\"...which then again requires processing `{}`, completing the cycle.\",\n                              ty::item_path_str(tcx, def_id)));\n             }\n+            AstConvRequest::EnsureSuperPredicates(def_id) => {\n+                tcx.sess.note(\n+                    &format!(\"...which then again requires computing the supertraits of `{}`, \\\n+                              completing the cycle.\",\n+                             ty::item_path_str(tcx, def_id)));\n+            }\n             AstConvRequest::GetTypeParameterBounds(id) => {\n                 let def = tcx.type_parameter_def(id);\n                 tcx.sess.note(\n@@ -327,6 +323,41 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n             }\n         }\n     }\n+\n+    /// Loads the trait def for a given trait, returning ErrorReported if a cycle arises.\n+    fn get_trait_def(&self, trait_id: ast::DefId)\n+                     -> Rc<ty::TraitDef<'tcx>>\n+    {\n+        let tcx = self.tcx;\n+\n+        if trait_id.krate != ast::LOCAL_CRATE {\n+            return ty::lookup_trait_def(tcx, trait_id)\n+        }\n+\n+        let item = match tcx.map.get(trait_id.node) {\n+            ast_map::NodeItem(item) => item,\n+            _ => tcx.sess.bug(&format!(\"get_trait_def({}): not an item\", trait_id.repr(tcx)))\n+        };\n+\n+        trait_def_of_item(self, &*item)\n+    }\n+\n+    /// Ensure that the (transitive) super predicates for\n+    /// `trait_def_id` are available. This will report a cycle error\n+    /// if a trait `X` (transitively) extends itself in some form.\n+    fn ensure_super_predicates(&self, span: Span, trait_def_id: ast::DefId)\n+                               -> Result<(), ErrorReported>\n+    {\n+        self.cycle_check(span, AstConvRequest::EnsureSuperPredicates(trait_def_id), || {\n+            let def_ids = ensure_super_predicates_step(self, trait_def_id);\n+\n+            for def_id in def_ids {\n+                try!(self.ensure_super_predicates(span, def_id));\n+            }\n+\n+            Ok(())\n+        })\n+    }\n }\n \n impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n@@ -342,25 +373,41 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetItemTypeScheme(id), || {\n-            type_scheme_of_def_id(self.ccx, id)\n+            Ok(type_scheme_of_def_id(self.ccx, id))\n         })\n     }\n \n     fn get_trait_def(&self, span: Span, id: ast::DefId)\n                      -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetTraitDef(id), || {\n-            get_trait_def(self.ccx, id)\n+            Ok(self.ccx.get_trait_def(id))\n         })\n     }\n \n+    fn ensure_super_predicates(&self,\n+                               span: Span,\n+                               trait_def_id: ast::DefId)\n+                               -> Result<(), ErrorReported>\n+    {\n+        debug!(\"ensure_super_predicates(trait_def_id={})\",\n+               trait_def_id.repr(self.tcx()));\n+\n+        self.ccx.ensure_super_predicates(span, trait_def_id)\n+    }\n+\n+\n     fn get_type_parameter_bounds(&self,\n                                  span: Span,\n                                  node_id: ast::NodeId)\n                                  -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetTypeParameterBounds(node_id), || {\n-            self.param_bounds.get_type_parameter_bounds(self, span, node_id)\n+            let v = self.param_bounds.get_type_parameter_bounds(self, span, node_id)\n+                                     .into_iter()\n+                                     .filter_map(|p| p.to_opt_poly_trait_ref())\n+                                     .collect();\n+            Ok(v)\n         })\n     }\n \n@@ -400,7 +447,7 @@ trait GetTypeParameterBounds<'tcx> {\n                                  astconv: &AstConv<'tcx>,\n                                  span: Span,\n                                  node_id: ast::NodeId)\n-                                 -> Vec<ty::PolyTraitRef<'tcx>>;\n+                                 -> Vec<ty::Predicate<'tcx>>;\n }\n \n /// Find bounds from both elements of the tuple.\n@@ -411,7 +458,7 @@ impl<'a,'b,'tcx,A,B> GetTypeParameterBounds<'tcx> for (&'a A,&'b B)\n                                  astconv: &AstConv<'tcx>,\n                                  span: Span,\n                                  node_id: ast::NodeId)\n-                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+                                 -> Vec<ty::Predicate<'tcx>>\n     {\n         let mut v = self.0.get_type_parameter_bounds(astconv, span, node_id);\n         v.extend(self.1.get_type_parameter_bounds(astconv, span, node_id).into_iter());\n@@ -425,7 +472,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for () {\n                                  _astconv: &AstConv<'tcx>,\n                                  _span: Span,\n                                  _node_id: ast::NodeId)\n-                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+                                 -> Vec<ty::Predicate<'tcx>>\n     {\n         Vec::new()\n     }\n@@ -439,29 +486,28 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n                                  astconv: &AstConv<'tcx>,\n                                  _span: Span,\n                                  node_id: ast::NodeId)\n-                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+                                 -> Vec<ty::Predicate<'tcx>>\n     {\n         let def = astconv.tcx().type_parameter_def(node_id);\n \n         self.predicates\n             .iter()\n-            .filter_map(|predicate| {\n-                match *predicate {\n+            .filter(|predicate| {\n+                match **predicate {\n                     ty::Predicate::Trait(ref data) => {\n-                        if data.0.self_ty().is_param(def.space, def.index) {\n-                            Some(data.to_poly_trait_ref())\n-                        } else {\n-                            None\n-                        }\n+                        data.skip_binder().self_ty().is_param(def.space, def.index)\n+                    }\n+                    ty::Predicate::TypeOutlives(ref data) => {\n+                        data.skip_binder().0.is_param(def.space, def.index)\n                     }\n                     ty::Predicate::Equate(..) |\n                     ty::Predicate::RegionOutlives(..) |\n-                    ty::Predicate::TypeOutlives(..) |\n                     ty::Predicate::Projection(..) => {\n-                        None\n+                        false\n                     }\n                 }\n             })\n+            .cloned()\n             .collect()\n     }\n }\n@@ -475,7 +521,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ast::Generics {\n                                  astconv: &AstConv<'tcx>,\n                                  _: Span,\n                                  node_id: ast::NodeId)\n-                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+                                 -> Vec<ty::Predicate<'tcx>>\n     {\n         // In the AST, bounds can derive from two places. Either\n         // written inline like `<T:Foo>` or in a where clause like\n@@ -489,7 +535,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ast::Generics {\n                 .iter()\n                 .filter(|p| p.id == node_id)\n                 .flat_map(|p| p.bounds.iter())\n-                .filter_map(|b| poly_trait_ref_from_bound(astconv, ty, b, &mut Vec::new()));\n+                .flat_map(|b| predicates_from_bound(astconv, ty, b).into_iter());\n \n         let from_where_clauses =\n             self.where_clause\n@@ -501,7 +547,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ast::Generics {\n                 })\n                 .filter(|bp| is_param(astconv.tcx(), &bp.bounded_ty, node_id))\n                 .flat_map(|bp| bp.bounds.iter())\n-                .filter_map(|b| poly_trait_ref_from_bound(astconv, ty, b, &mut Vec::new()));\n+                .flat_map(|b| predicates_from_bound(astconv, ty, b).into_iter());\n \n         from_ty_params.chain(from_where_clauses).collect()\n     }\n@@ -518,10 +564,15 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     if let ast::TyPath(None, _) = ast_ty.node {\n         let path_res = tcx.def_map.borrow()[ast_ty.id];\n-        if let def::DefTyParam(_, _, def_id, _) = path_res.base_def {\n-            path_res.depth == 0 && def_id == local_def(param_id)\n-        } else {\n-            false\n+        match path_res.base_def {\n+            def::DefSelfTy(node_id) =>\n+                path_res.depth == 0 && node_id == param_id,\n+\n+            def::DefTyParam(_, _, def_id, _) =>\n+                path_res.depth == 0 && def_id == local_def(param_id),\n+\n+            _ =>\n+                false,\n         }\n     } else {\n         false\n@@ -790,9 +841,10 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  rcvr_visibility: ast::Visibility)\n                                  where I: Iterator<Item=&'i ast::Method>\n {\n-    debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={})\",\n+    debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={}, rcvr_ty_predicates={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n-           rcvr_ty_generics.repr(ccx.tcx));\n+           rcvr_ty_generics.repr(ccx.tcx),\n+           rcvr_ty_predicates.repr(ccx.tcx));\n \n     let tcx = ccx.tcx;\n     let mut seen_methods = FnvHashSet();\n@@ -1036,6 +1088,8 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n         },\n         ast::ItemTrait(_, _, _, ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n+            let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n+                ccx.ensure_super_predicates(it.span, local_def(it.id));\n             convert_trait_predicates(ccx, it);\n             let trait_predicates = ty::lookup_predicates(ccx.tcx, local_def(it.id));\n \n@@ -1181,22 +1235,84 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                           trait_id: ast::DefId)\n-                           -> Rc<ty::TraitDef<'tcx>> {\n+/// Ensures that the super-predicates of the trait with def-id\n+/// trait_def_id are converted and stored. This does NOT ensure that\n+/// the transitive super-predicates are converted; that is the job of\n+/// the `ensure_super_predicates()` method in the `AstConv` impl\n+/// above. Returns a list of trait def-ids that must be ensured as\n+/// well to guarantee that the transitive superpredicates are\n+/// converted.\n+fn ensure_super_predicates_step(ccx: &CrateCtxt,\n+                                trait_def_id: ast::DefId)\n+                                -> Vec<ast::DefId>\n+{\n     let tcx = ccx.tcx;\n \n-    if trait_id.krate != ast::LOCAL_CRATE {\n-        return ty::lookup_trait_def(tcx, trait_id)\n-    }\n+    debug!(\"ensure_super_predicates_step(trait_def_id={})\", trait_def_id.repr(tcx));\n \n-    match tcx.map.get(trait_id.node) {\n-        ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n-        _ => {\n-            tcx.sess.bug(&format!(\"get_trait_def({}): not an item\",\n-                                  trait_id.node))\n-        }\n+    if trait_def_id.krate != ast::LOCAL_CRATE {\n+        return Vec::new();\n     }\n+\n+    let superpredicates = tcx.super_predicates.borrow().get(&trait_def_id).cloned();\n+    let superpredicates = superpredicates.unwrap_or_else(|| {\n+        let trait_node_id = trait_def_id.node;\n+\n+        let item = match ccx.tcx.map.get(trait_node_id) {\n+            ast_map::NodeItem(item) => item,\n+            _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not an item\", trait_node_id))\n+        };\n+\n+        let (generics, bounds) = match item.node {\n+            ast::ItemTrait(_, ref generics, ref supertraits, _) => (generics, supertraits),\n+            _ => tcx.sess.span_bug(item.span,\n+                                   \"ensure_super_predicates_step invoked on non-trait\"),\n+        };\n+\n+        // In-scope when converting the superbounds for `Trait` are\n+        // that `Self:Trait` as well as any bounds that appear on the\n+        // generic types:\n+        let trait_def = trait_def_of_item(ccx, item);\n+        let self_predicate = ty::GenericPredicates {\n+            predicates: VecPerParamSpace::new(vec![],\n+                                              vec![trait_def.trait_ref.as_predicate()],\n+                                              vec![])\n+        };\n+        let scope = &(generics, &self_predicate);\n+\n+        // Convert the bounds that follow the colon, e.g. `Bar+Zed` in `trait Foo : Bar+Zed`.\n+        let self_param_ty = ty::mk_self_type(tcx);\n+        let superbounds1 = compute_bounds(&ccx.icx(scope), self_param_ty, bounds,\n+                                          SizedByDefault::No, item.span);\n+        let superbounds1 = ty::predicates(tcx, self_param_ty, &superbounds1);\n+\n+        // Convert any explicit superbounds in the where clause,\n+        // e.g. `trait Foo where Self : Bar`:\n+        let superbounds2 = generics.get_type_parameter_bounds(&ccx.icx(scope), item.span, item.id);\n+\n+        // Combine the two lists to form the complete set of superbounds:\n+        let superbounds = superbounds1.into_iter().chain(superbounds2.into_iter()).collect();\n+        let superpredicates = ty::GenericPredicates {\n+            predicates: VecPerParamSpace::new(superbounds, vec![], vec![])\n+        };\n+        debug!(\"superpredicates for trait {} = {}\",\n+               local_def(item.id).repr(ccx.tcx),\n+               superpredicates.repr(ccx.tcx));\n+\n+        tcx.super_predicates.borrow_mut().insert(trait_def_id, superpredicates.clone());\n+\n+        superpredicates\n+    });\n+\n+    let def_ids: Vec<_> = superpredicates.predicates\n+                                         .iter()\n+                                         .filter_map(|p| p.to_opt_poly_trait_ref())\n+                                         .map(|tr| tr.def_id())\n+                                         .collect();\n+\n+    debug!(\"ensure_super_predicates_step: def_ids={}\", def_ids.repr(tcx));\n+\n+    def_ids\n }\n \n fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -1210,18 +1326,9 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         return def.clone();\n     }\n \n-    let (unsafety, generics, bounds, items) = match it.node {\n-        ast::ItemTrait(unsafety,\n-                       ref generics,\n-                       ref supertraits,\n-                       ref items) => {\n-            (unsafety, generics, supertraits, items)\n-        }\n-        ref s => {\n-            tcx.sess.span_bug(\n-                it.span,\n-                &format!(\"trait_def_of_item invoked on {:?}\", s));\n-        }\n+    let (unsafety, generics, items) = match it.node {\n+        ast::ItemTrait(unsafety, ref generics, _, ref items) => (unsafety, generics, items),\n+        _ => tcx.sess.span_bug(it.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n     let paren_sugar = ty::has_attr(tcx, def_id, \"rustc_paren_sugar\");\n@@ -1239,15 +1346,6 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let ty_generics = ty_generics_for_trait(ccx, it.id, substs, generics);\n \n-    let self_param_ty = ty::ParamTy::for_self().to_ty(ccx.tcx);\n-\n-    // supertraits:\n-    let bounds = compute_bounds(&ccx.icx(generics),\n-                                self_param_ty,\n-                                bounds,\n-                                SizedByDefault::No,\n-                                it.span);\n-\n     let associated_type_names: Vec<_> =\n         items.iter()\n              .filter_map(|item| {\n@@ -1267,7 +1365,6 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         paren_sugar: paren_sugar,\n         unsafety: unsafety,\n         generics: ty_generics,\n-        bounds: bounds,\n         trait_ref: trait_ref,\n         associated_type_names: associated_type_names,\n     });\n@@ -1348,19 +1445,14 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n         }\n     };\n \n-    let self_param_ty = ty::ParamTy::for_self().to_ty(ccx.tcx);\n-\n-    let super_predicates = ty::predicates(ccx.tcx, self_param_ty, &trait_def.bounds);\n+    let super_predicates = ty::lookup_super_predicates(ccx.tcx, def_id);\n \n     // `ty_generic_predicates` below will consider the bounds on the type\n     // parameters (including `Self`) and the explicit where-clauses,\n     // but to get the full set of predicates on a trait we need to add\n     // in the supertrait bounds and anything declared on the\n     // associated types.\n-    let mut base_predicates =\n-        ty::GenericPredicates {\n-            predicates: VecPerParamSpace::new(super_predicates, vec![], vec![])\n-        };\n+    let mut base_predicates = super_predicates;\n \n     // Add in a predicate that `Self:Trait` (where `Trait` is the\n     // current trait).  This is needed for builtin bounds.\n@@ -1990,7 +2082,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n }\n \n-enum SizedByDefault { Yes, No }\n+enum SizedByDefault { Yes, No, }\n \n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n@@ -2012,60 +2104,36 @@ fn compute_bounds<'tcx>(astconv: &AstConv<'tcx>,\n                           &mut param_bounds.builtin_bounds,\n                           ast_bounds,\n                           span);\n-\n-        check_bounds_compatible(astconv,\n-                                param_ty,\n-                                &param_bounds,\n-                                span);\n     }\n \n     param_bounds.trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n \n     param_bounds\n }\n \n-fn check_bounds_compatible<'tcx>(astconv: &AstConv<'tcx>,\n-                                 param_ty: Ty<'tcx>,\n-                                 param_bounds: &ty::ParamBounds<'tcx>,\n-                                 span: Span) {\n-    let tcx = astconv.tcx();\n-    if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n-        ty::each_bound_trait_and_supertraits(\n-            tcx,\n-            &param_bounds.trait_bounds,\n-            |trait_ref| {\n-                match astconv.get_trait_def(span, trait_ref.def_id()) {\n-                    Ok(trait_def) => {\n-                        if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n-                            span_err!(tcx.sess, span, E0129,\n-                                      \"incompatible bounds on `{}`, \\\n-                                        bound `{}` does not allow unsized type\",\n-                                      param_ty.user_string(tcx),\n-                                      trait_ref.user_string(tcx));\n-                        }\n-                    }\n-                    Err(ErrorReported) => { }\n-                }\n-                true\n-            });\n-    }\n-}\n-\n /// Converts a specific TyParamBound from the AST into the\n /// appropriate poly-trait-reference.\n-fn poly_trait_ref_from_bound<'tcx>(astconv: &AstConv<'tcx>,\n-                                   param_ty: Ty<'tcx>,\n-                                   bound: &ast::TyParamBound,\n-                                   projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                                   -> Option<ty::PolyTraitRef<'tcx>>\n+fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx>,\n+                               param_ty: Ty<'tcx>,\n+                               bound: &ast::TyParamBound)\n+                               -> Vec<ty::Predicate<'tcx>>\n {\n     match *bound {\n         ast::TraitTyParamBound(ref tr, ast::TraitBoundModifier::None) => {\n-            Some(conv_poly_trait_ref(astconv, param_ty, tr, projections))\n+            let mut projections = Vec::new();\n+            let pred = conv_poly_trait_ref(astconv, param_ty, tr, &mut projections);\n+            projections.into_iter()\n+                       .map(|p| p.as_predicate())\n+                       .chain(Some(pred.as_predicate()).into_iter())\n+                       .collect()\n         }\n-        ast::TraitTyParamBound(_, ast::TraitBoundModifier::Maybe) |\n-        ast::RegionTyParamBound(_) => {\n-            None\n+        ast::RegionTyParamBound(ref lifetime) => {\n+            let region = ast_region_to_region(astconv.tcx(), lifetime);\n+            let pred = ty::Binder(ty::OutlivesPredicate(param_ty, region));\n+            vec![ty::Predicate::TypeOutlives(pred)]\n+        }\n+        ast::TraitTyParamBound(_, ast::TraitBoundModifier::Maybe) => {\n+            Vec::new()\n         }\n     }\n }"}, {"sha": "9b27128ce2ffd5409b40b2694187031b54475684", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -644,9 +644,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n \n             ast::ItemTrait(..) => {\n                 let trait_def = ty::lookup_trait_def(tcx, did);\n-                let predicates = ty::predicates(tcx, ty::mk_self_type(tcx), &trait_def.bounds);\n+                let predicates = ty::lookup_super_predicates(tcx, did);\n                 self.add_constraints_from_predicates(&trait_def.generics,\n-                                                     &predicates,\n+                                                     predicates.predicates.as_slice(),\n                                                      self.covariant);\n \n                 let trait_items = ty::trait_items(tcx, did);"}, {"sha": "db41bf9fee329d9e36e65cf9f183bc1ec7a5a524", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -165,14 +165,12 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n             _ => unreachable!()\n         }\n     });\n-    let trait_def = ty::lookup_trait_def(tcx, did);\n     let predicates = ty::lookup_predicates(tcx, did);\n-    let bounds = trait_def.bounds.clean(cx);\n     clean::Trait {\n         unsafety: def.unsafety,\n         generics: (&def.generics, &predicates, subst::TypeSpace).clean(cx),\n         items: items.collect(),\n-        bounds: bounds,\n+        bounds: vec![], // supertraits can be found in the list of predicates\n     }\n }\n "}, {"sha": "5ca0700ce6edaa8425da266aec76db4953bc71f5", "filename": "src/test/compile-fail/cycle-projection-based-on-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -25,7 +25,7 @@ trait Trait { type Item; }\n struct A<T>\n     where T : Trait,\n           T : Add<T::Item>\n-    //~^ ERROR illegal recursive type\n+    //~^ ERROR unsupported cyclic reference between types/traits detected\n {\n     data: T\n }"}, {"sha": "e6caeb34a8c8f30fddd833c1140200f73f2ea113", "filename": "src/test/compile-fail/cycle-trait-default-type-trait.rs", "status": "renamed", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {}\n+// Test a cycle where a type parameter on a trait has a default that\n+// again references the trait.\n \n-fn foo<T: Foo + Foo>() {} //~ ERROR `Foo` already appears in the list of bounds\n+trait Foo<X = Box<Foo>> {\n+    //~^ ERROR unsupported cyclic reference\n+}\n \n-fn main() {}\n+fn main() { }", "previous_filename": "src/test/compile-fail/duplicate-trait-bounds.rs"}, {"sha": "c9bfde3f4ed12bb9ad233976cd0ec992be83611e", "filename": "src/test/compile-fail/cycle-trait-supertrait-indirect.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -12,9 +12,12 @@\n // a direct participant in the cycle.\n \n trait A: B {\n+    //~^ ERROR unsupported cyclic reference\n }\n \n-trait B: C { }\n+trait B: C {\n+    //~^ ERROR unsupported cyclic reference\n+}\n \n trait C: B { }\n     //~^ ERROR unsupported cyclic reference"}, {"sha": "e5120840f7672a6d19ad8fae9faa4d87f29504df", "filename": "src/test/compile-fail/infinite-vec-type-recursion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: illegal recursive type\n-\n-\n type x = Vec<x>;\n+//~^ ERROR unsupported cyclic reference\n \n fn main() { let b: x = Vec::new(); }"}, {"sha": "271c31bd375484c6ef7c763e8c67f5079433ce75", "filename": "src/test/compile-fail/issue-18389.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -12,18 +12,17 @@\n \n use std::any::Any;\n use std::any::TypeId;\n+use std::marker::MarkerTrait;\n \n-pub trait Pt {}\n-pub trait Rt {}\n+pub trait Pt : MarkerTrait {}\n+pub trait Rt : MarkerTrait {}\n \n trait Private<P: Pt, R: Rt> {\n     fn call(&self, p: P, r: R);\n }\n-pub trait Public: Private<\n+pub trait Public: Private< //~ ERROR private trait in exported type parameter bound\n     <Self as Public>::P,\n-//~^ ERROR illegal recursive type; insert an enum or struct in the cycle, if this is desired\n     <Self as Public>::R\n-//~^ ERROR unsupported cyclic reference between types/traits detected\n > {\n     type P;\n     type R;"}, {"sha": "678a7806e7ab687080ad2711899710cec9234c4d", "filename": "src/test/compile-fail/issue-3953.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -13,16 +13,15 @@\n use std::cmp::PartialEq;\n \n trait Hahaha: PartialEq + PartialEq {\n-    //~^ ERROR trait `PartialEq` already appears in the list of bounds\n }\n \n struct Lol(isize);\n \n impl Hahaha for Lol { }\n \n impl PartialEq for Lol {\n-    fn eq(&self, other: &Lol) -> bool { **self != **other }\n-    fn ne(&self, other: &Lol) -> bool { **self == **other }\n+    fn eq(&self, other: &Lol) -> bool { loop { } }\n+    fn ne(&self, other: &Lol) -> bool { loop { } }\n }\n \n fn main() {"}]}