{"sha": "cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMmRlZjQ2YzEyMGQ4ZDZlZjhhOTg1NzFhMzliZWY0NzhjOGMyYTk=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-15T23:54:02Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-16T16:36:29Z"}, "message": "Removed trans_comm.rs from the compiler. Updating aio/sio to work with the new chan and port system, started on a networking module for the standard library.", "tree": {"sha": "902078db51847e2c3badb941dcbceeb5216d866f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/902078db51847e2c3badb941dcbceeb5216d866f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "html_url": "https://github.com/rust-lang/rust/commit/cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/comments", "author": null, "committer": null, "parents": [{"sha": "e33af7e0b505de6d7c754d2ead26c9ee2bc8974e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e33af7e0b505de6d7c754d2ead26c9ee2bc8974e", "html_url": "https://github.com/rust-lang/rust/commit/e33af7e0b505de6d7c754d2ead26c9ee2bc8974e"}], "stats": {"total": 924, "additions": 325, "deletions": 599}, "files": [{"sha": "ea0a793780a65e28e2be4b6f591b152a450e4687", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -70,12 +70,6 @@ import syntax::print::pprust::path_to_str;\n \n import trans_common::*;\n \n-import trans_comm::trans_port;\n-import trans_comm::trans_chan;\n-import trans_comm::trans_spawn;\n-import trans_comm::trans_send;\n-import trans_comm::trans_recv;\n-\n import trans_objects::trans_anon_obj;\n import trans_objects::trans_obj;\n \n@@ -5172,13 +5166,6 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n       ast::expr_ret(ex) { ret trans_ret(cx, ex); }\n       ast::expr_put(ex) { ret trans_put(cx, ex); }\n       ast::expr_be(ex) { ret trans_be(cx, ex); }\n-      ast::expr_port(_) { ret trans_port(cx, e.id); }\n-      ast::expr_chan(ex) { ret trans_chan(cx, ex, e.id); }\n-      ast::expr_send(lhs, rhs) { ret trans_send(cx, lhs, rhs, e.id); }\n-      ast::expr_recv(lhs, rhs) { ret trans_recv(cx, lhs, rhs, e.id); }\n-      ast::expr_spawn(dom, name, func, args) {\n-        ret trans_spawn(cx, dom, name, func, args, e.id);\n-      }\n       ast::expr_anon_obj(anon_obj) {\n         ret trans_anon_obj(cx, e.span, anon_obj, e.id);\n       }"}, {"sha": "c0a4e15ed8b472221b1ae279bff3e42adb92026f", "filename": "src/comp/middle/trans_comm.rs", "status": "removed", "additions": 0, "deletions": 302, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/e33af7e0b505de6d7c754d2ead26c9ee2bc8974e/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33af7e0b505de6d7c754d2ead26c9ee2bc8974e/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs?ref=e33af7e0b505de6d7c754d2ead26c9ee2bc8974e", "patch": "@@ -1,302 +0,0 @@\n-/**\n-   Translation for various task and comm-related things.\n-\n-   Most of this will probably go away as we move more of this into\n-   libraries.\n-\n-*/\n-\n-import std::str;\n-import std::option;\n-import option::none;\n-import option::some;\n-\n-import lib::llvm::llvm;\n-import lib::llvm::llvm::ValueRef;\n-\n-import util::ppaux::ty_to_str;\n-import syntax::print::pprust::expr_to_str;\n-import syntax::ast;\n-import back::link::mangle_internal_name_by_path_and_seq;\n-\n-import trans_common::*;\n-import trans::*;\n-\n-export trans_port;\n-export trans_chan;\n-export trans_spawn;\n-export trans_send;\n-export trans_recv;\n-\n-fn trans_port(cx: &@block_ctxt, id: ast::node_id) -> result {\n-    let t = node_id_type(cx.fcx.lcx.ccx, id);\n-    let unit_ty;\n-    alt ty::struct(cx.fcx.lcx.ccx.tcx, t) {\n-      ty::ty_port(t) { unit_ty = t; }\n-      _ { cx.fcx.lcx.ccx.sess.bug(\"non-port type in trans_port\"); }\n-    }\n-    let bcx = cx;\n-    let unit_sz = size_of(bcx, unit_ty);\n-    bcx = unit_sz.bcx;\n-    let port_raw_val =\n-        bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_port,\n-                       ~[bcx.fcx.lltaskptr, unit_sz.val]);\n-    let llty = type_of(cx.fcx.lcx.ccx, cx.sp, t);\n-    let port_val = bcx.build.PointerCast(port_raw_val, llty);\n-    add_clean_temp(bcx, port_val, t);\n-    ret rslt(bcx, port_val);\n-}\n-\n-fn trans_chan(cx: &@block_ctxt, e: &@ast::expr, id: ast::node_id) -> result {\n-    let bcx = cx;\n-    let prt = trans_expr(bcx, e);\n-    bcx = prt.bcx;\n-    let prt_val = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n-    let chan_raw_val =\n-        bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_chan,\n-                       ~[bcx.fcx.lltaskptr, prt_val]);\n-    let chan_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n-    let chan_llty = type_of(bcx.fcx.lcx.ccx, e.span, chan_ty);\n-    let chan_val = bcx.build.PointerCast(chan_raw_val, chan_llty);\n-    add_clean_temp(bcx, chan_val, chan_ty);\n-    ret rslt(bcx, chan_val);\n-}\n-\n-fn trans_spawn(cx: &@block_ctxt, dom: &ast::spawn_dom, name: &option::t[str],\n-               func: &@ast::expr, args: &[@ast::expr], id: ast::node_id) ->\n-   result {\n-    let bcx = cx;\n-    // Make the task name\n-\n-    let tname =\n-        alt name {\n-          none. {\n-            let argss = std::ivec::map(expr_to_str, args);\n-            #fmt(\"%s(%s)\", expr_to_str(func), str::connect(argss, \", \"))\n-          }\n-          some(n) { n }\n-        };\n-    // Generate code\n-    //\n-    // This is a several step process. The following things need to happen\n-    // (not necessarily in order):\n-    //\n-    // 1. Evaluate all the arguments to the spawnee.\n-    //\n-    // 2. Alloca a tuple that holds these arguments (they must be in reverse\n-    // order, so that they match the expected stack layout for the spawnee)\n-    //\n-    // 3. Fill the tuple with the arguments we evaluated.\n-    //\n-    // 3.5. Generate a wrapper function that takes the tuple and unpacks it to\n-    // call the real task.\n-    //\n-    // 4. Pass a pointer to the wrapper function and the argument tuple to\n-    // upcall_start_task. In order to do this, we need to allocate another\n-    // tuple that matches the arguments expected by rust_task::start.\n-    //\n-    // 5. Oh yeah, we have to create the task before we start it...\n-\n-    // But first, we'll create a task.\n-\n-    let lltname: ValueRef = C_str(bcx.fcx.lcx.ccx, tname);\n-    let new_task =\n-        bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_task,\n-                       ~[bcx.fcx.lltaskptr, lltname]);\n-\n-    // Translate the arguments, remembering their types and where the values\n-    // ended up.\n-\n-    let arg_tys: [ty::t] = ~[];\n-    let arg_vals: [ValueRef] = ~[];\n-    for e: @ast::expr in args {\n-        let e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n-        let arg = trans_expr(bcx, e);\n-\n-        arg = deep_copy(arg.bcx, arg.val, e_ty, new_task);\n-\n-        bcx = arg.bcx;\n-\n-        arg_vals += ~[arg.val];\n-        arg_tys += ~[e_ty];\n-    }\n-    // Make the tuple.\n-\n-    let args_ty = ty::mk_tup(cx.fcx.lcx.ccx.tcx, arg_tys);\n-    // Allocate and fill the tuple.\n-\n-    let llargs = alloc_ty(bcx, args_ty);\n-    let i = 0u;\n-    for v: ValueRef in arg_vals {\n-        let target = bcx.build.GEP(llargs.val, ~[C_int(0), C_int(i as int)]);\n-\n-        bcx.build.Store(v, target);\n-        i += 1u;\n-    }\n-\n-    // Generate the wrapper function\n-    let wrapper = mk_spawn_wrapper(bcx, func, args_ty);\n-    bcx = wrapper.bcx;\n-    let llfnptr_i = bcx.build.PointerCast(wrapper.val, T_int());\n-\n-    // And start the task\n-    let llargs_i = bcx.build.PointerCast(llargs.val, T_int());\n-    let args_size = size_of(bcx, args_ty).val;\n-    bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.start_task,\n-                   ~[bcx.fcx.lltaskptr, new_task, llfnptr_i, llargs_i,\n-                     args_size]);\n-    let task_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n-    add_clean_temp(bcx, new_task, task_ty);\n-    ret rslt(bcx, new_task);\n-}\n-\n-fn mk_spawn_wrapper(cx: &@block_ctxt, func: &@ast::expr, args_ty: &ty::t) ->\n-   result {\n-    let llmod = cx.fcx.lcx.ccx.llmod;\n-    let wrapper_fn_type =\n-        type_of_fn(cx.fcx.lcx.ccx, cx.sp, ast::proto_fn,\n-                   ~[{mode: ty::mo_alias(false), ty: args_ty}], ty::idx_nil,\n-                   0u);\n-    // TODO: construct a name based on tname\n-\n-    let wrap_name: str =\n-        mangle_internal_name_by_path_and_seq(cx.fcx.lcx.ccx, cx.fcx.lcx.path,\n-                                             \"spawn_wrapper\");\n-    let llfndecl = decl_cdecl_fn(llmod, wrap_name, wrapper_fn_type);\n-    let fcx = new_fn_ctxt(cx.fcx.lcx, cx.sp, llfndecl);\n-    let fbcx = new_top_block_ctxt(fcx);\n-    // 3u to skip the three implicit args\n-\n-    let arg: ValueRef = llvm::LLVMGetParam(fcx.llfn, 3u);\n-    let child_args: [ValueRef] =\n-        ~[llvm::LLVMGetParam(fcx.llfn, 0u), llvm::LLVMGetParam(fcx.llfn, 1u),\n-          llvm::LLVMGetParam(fcx.llfn, 2u)];\n-    // unpack the arguments\n-\n-    alt ty::struct(fcx.lcx.ccx.tcx, args_ty) {\n-      ty::ty_tup(elts) {\n-        let i = 0;\n-        for elt in elts {\n-            let src = fbcx.build.GEP(arg, ~[C_int(0), C_int(i)]);\n-            i += 1;\n-            let child_arg = fbcx.build.Load(src);\n-            child_args += ~[child_arg];\n-        }\n-      }\n-    }\n-    // Find the function\n-\n-    let fnptr = trans_lval(fbcx, func).res;\n-    fbcx = fnptr.bcx;\n-    let llfnptr = fbcx.build.GEP(fnptr.val, ~[C_int(0), C_int(0)]);\n-    let llfn = fbcx.build.Load(llfnptr);\n-    fbcx.build.FastCall(llfn, child_args);\n-    fbcx.build.RetVoid();\n-    finish_fn(fcx, fbcx.llbb);\n-    // TODO: make sure we clean up everything we need to.\n-\n-    ret rslt(cx, llfndecl);\n-}\n-\n-fn trans_send(cx: &@block_ctxt, lhs: &@ast::expr, rhs: &@ast::expr,\n-              id: ast::node_id) -> result {\n-    let bcx = cx;\n-    let chn = trans_expr(bcx, lhs);\n-    bcx = chn.bcx;\n-    let data = trans_lval(bcx, rhs);\n-    bcx = data.res.bcx;\n-    let chan_ty = node_id_type(cx.fcx.lcx.ccx, id);\n-    let unit_ty;\n-    alt ty::struct(cx.fcx.lcx.ccx.tcx, chan_ty) {\n-      ty::ty_chan(t) { unit_ty = t; }\n-      _ { bcx.fcx.lcx.ccx.sess.bug(\"non-chan type in trans_send\"); }\n-    }\n-    let data_alloc = alloc_ty(bcx, unit_ty);\n-    bcx = data_alloc.bcx;\n-    let data_tmp = move_val_if_temp(bcx, INIT, data_alloc.val, data, unit_ty);\n-    bcx = data_tmp.bcx;\n-    let llchanval = bcx.build.PointerCast(chn.val, T_opaque_chan_ptr());\n-    let lldataptr = bcx.build.PointerCast(data_alloc.val, T_ptr(T_i8()));\n-    bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.send,\n-                   ~[bcx.fcx.lltaskptr, llchanval, lldataptr]);\n-\n-    // Deinit the stuff we sent.\n-    bcx = zero_alloca(bcx, data_alloc.val, unit_ty).bcx;\n-\n-    ret rslt(bcx, chn.val);\n-}\n-\n-fn trans_recv(cx: &@block_ctxt, lhs: &@ast::expr, rhs: &@ast::expr,\n-              id: ast::node_id) -> result {\n-    let bcx = cx;\n-    // FIXME: calculate copy init-ness in typestate.\n-\n-    let unit_ty = node_id_type(cx.fcx.lcx.ccx, id);\n-    let tmp_alloc = alloc_ty(bcx, unit_ty);\n-    bcx = tmp_alloc.bcx;\n-\n-    let prt = trans_expr(bcx, lhs);\n-    bcx = prt.bcx;\n-    let lldataptr = bcx.build.PointerCast(tmp_alloc.val,\n-                                          T_ptr(T_ptr(T_i8())));\n-    let llportptr = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n-    bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.recv,\n-                   ~[bcx.fcx.lltaskptr, lldataptr, llportptr]);\n-\n-    let tmp = load_if_immediate(bcx, tmp_alloc.val, unit_ty);\n-\n-    let data = trans_lval(bcx, rhs);\n-    assert (data.is_mem);\n-    bcx = data.res.bcx;\n-\n-    let tmp_lval = lval_val(bcx, tmp);\n-\n-    let recv_res =\n-        move_val(bcx, DROP_EXISTING, data.res.val, tmp_lval, unit_ty);\n-\n-    ret rslt(recv_res.bcx, recv_res.val);\n-}\n-\n-// Does a deep copy of a value. This is needed for passing arguments to child\n-// tasks, and for sending things through channels. There are probably some\n-// uniqueness optimizations and things we can do here for tasks in the same\n-// domain.\n-fn deep_copy(bcx: &@block_ctxt, v: ValueRef, t: ty::t, target_task: ValueRef)\n-   -> result {\n-    // TODO: make sure all paths add any reference counting that they need to.\n-\n-    // TODO: Teach deep copy to understand everything else it needs to.\n-\n-    let tcx = bcx.fcx.lcx.ccx.tcx;\n-    if ty::type_is_scalar(tcx, t) {\n-        ret rslt(bcx, v);\n-    } else if (ty::type_is_str(tcx, t)) {\n-        ret rslt(bcx,\n-                 bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.dup_str,\n-                                ~[bcx.fcx.lltaskptr, target_task, v]));\n-    } else if (ty::type_is_chan(tcx, t)) {\n-        // If this is a channel, we need to clone it.\n-        let chan_ptr = bcx.build.PointerCast(v, T_opaque_chan_ptr());\n-\n-        let chan_raw_val =\n-            bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.clone_chan,\n-                           ~[bcx.fcx.lltaskptr, target_task, chan_ptr]);\n-\n-        // Cast back to the type the context was expecting.\n-        let chan_val = bcx.build.PointerCast(chan_raw_val, val_ty(v));\n-\n-        ret rslt(bcx, chan_val);\n-    } else if (ty::type_is_structural(tcx, t)) {\n-        fn inner_deep_copy(bcx: &@block_ctxt, v: ValueRef, t: ty::t) ->\n-           result {\n-            log_err \"Unimplemented type for deep_copy.\";\n-            fail;\n-        }\n-\n-        ret iter_structural_ty(bcx, v, t, inner_deep_copy);\n-    } else {\n-        bcx.fcx.lcx.ccx.sess.bug(\"unexpected type in \" + \"trans::deep_copy: \"\n-                                     + ty_to_str(tcx, t));\n-    }\n-}\n-"}, {"sha": "e701b40f93922047591da0cd29dc6f434d71d451", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -1,4 +1,3 @@\n-\n // -*- rust -*-\n \n #[link(name = \"rustc\",\n@@ -18,7 +17,6 @@ mod middle {\n     mod trans_common;\n     mod trans;\n     mod trans_alt;\n-    mod trans_comm;\n     mod trans_dps;\n     mod trans_objects;\n     mod trans_vec;"}, {"sha": "e807fda20f92cf0c0095d5fb7576d5255f96e977", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -577,16 +577,6 @@ fn parse_ty(p: &parser, colons_before_params: bool) -> @ast::ty {\n         alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n     } else if (eat_word(p, \"obj\")) {\n         t = parse_ty_obj(p, hi);\n-    } else if (eat_word(p, \"port\")) {\n-        expect(p, token::LBRACKET);\n-        t = ast::ty_port(parse_ty(p, false));\n-        hi = p.get_hi_pos();\n-        expect(p, token::RBRACKET);\n-    } else if (eat_word(p, \"chan\")) {\n-        expect(p, token::LBRACKET);\n-        t = ast::ty_chan(parse_ty(p, false));\n-        hi = p.get_hi_pos();\n-        expect(p, token::RBRACKET);\n     } else if (eat_word(p, \"mutable\")) {\n         p.warn(\"ignoring deprecated 'mutable' type constructor\");\n         let typ = parse_ty(p, false);\n@@ -990,30 +980,11 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         }\n     } else if (eat_word(p, \"be\")) {\n         let e = parse_expr(p);\n-\n-\n         // FIXME: Is this the right place for this check?\n         if /*check*/ast::is_call_expr(e) {\n             hi = e.span.hi;\n             ex = ast::expr_be(e);\n         } else { p.fatal(\"Non-call expression in tail call\"); }\n-    } else if (eat_word(p, \"port\")) {\n-        let ty = @spanned(lo, hi, ast::ty_infer);\n-        if token::LBRACKET == p.peek() {\n-            expect(p, token::LBRACKET);\n-            ty = parse_ty(p, false);\n-            expect(p, token::RBRACKET);\n-        }\n-        expect(p, token::LPAREN);\n-        expect(p, token::RPAREN);\n-        hi = p.get_hi_pos();\n-        ex = ast::expr_port(ty);\n-    } else if (eat_word(p, \"chan\")) {\n-        expect(p, token::LPAREN);\n-        let e = parse_expr(p);\n-        hi = e.span.hi;\n-        expect(p, token::RPAREN);\n-        ex = ast::expr_chan(e);\n     } else if (eat_word(p, \"copy\")) {\n         let e = parse_expr(p);\n         ex = ast::expr_copy(e);\n@@ -1271,16 +1242,6 @@ fn parse_assign_expr(p: &parser) -> @ast::expr {\n         let rhs = parse_expr(p);\n         ret mk_expr(p, lo, rhs.span.hi, ast::expr_move(lhs, rhs));\n       }\n-      token::SEND. {\n-        p.bump();\n-        let rhs = parse_expr(p);\n-        ret mk_expr(p, lo, rhs.span.hi, ast::expr_send(lhs, rhs));\n-      }\n-      token::RECV. {\n-        p.bump();\n-        let rhs = parse_expr(p);\n-        ret mk_expr(p, lo, rhs.span.hi, ast::expr_recv(lhs, rhs));\n-      }\n       token::DARROW. {\n         p.bump();\n         let rhs = parse_expr(p);"}, {"sha": "cfeb73929bba78509ad62ef1cda5b5af1e3eeabf", "filename": "src/lib/aio.rs", "status": "modified", "additions": 82, "deletions": 72, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -1,25 +1,35 @@\n-import str::sbuf;\n import task;\n+import ivec;\n+\n+import comm;\n+import comm::_chan;\n+import comm::_port;\n+import comm::mk_port;\n+import comm::send;\n+\n+import net;\n \n native \"rust\" mod rustrt {\n     type socket;\n     type server;\n     fn aio_init();\n     fn aio_run();\n     fn aio_stop();\n-    fn aio_connect(host: sbuf, port: int, connected: chan[socket]);\n-    fn aio_serve(host: sbuf, port: int, acceptChan: chan[socket]) -> server;\n-    fn aio_writedata(s: socket, buf: *u8, size: uint, status: chan[bool]);\n-    fn aio_read(s: socket, reader: chan[[u8]]);\n-    fn aio_close_server(s: server, status: chan[bool]);\n+    fn aio_connect(host: *u8, port: int, connected: &_chan[socket]);\n+    fn aio_serve(host: *u8, port: int, acceptChan: &_chan[socket]) -> server;\n+    fn aio_writedata(s: socket, buf: *u8, size: uint, status: &_chan[bool]);\n+    fn aio_read(s: socket, reader: &_chan[[u8]]);\n+    fn aio_close_server(s: server, status: &_chan[bool]);\n     fn aio_close_socket(s: socket);\n     fn aio_is_null_client(s: socket) -> bool;\n }\n \n+// FIXME: these should be unsafe pointers or something, but those aren't\n+// currently in the sendable kind, so we'll unsafely cast between ints.\n type server = rustrt::server;\n type client = rustrt::socket;\n tag pending_connection {\n-    remote(str,int);\n+    remote(net::ip_addr,int);\n     incoming(server);\n }\n \n@@ -30,75 +40,77 @@ tag socket_event {\n }\n \n tag server_event {\n-    pending(chan[chan[socket_event]]);\n+    pending(_chan[_chan[socket_event]]);\n }\n \n tag request {\n     quit;\n-    connect(pending_connection,chan[socket_event]);\n-    serve(str,int,chan[server_event],chan[server]);\n-    write(client,[u8],chan[bool]);\n-    close_server(server, chan[bool]);\n+    connect(pending_connection,_chan[socket_event]);\n+    serve(net::ip_addr,int,_chan[server_event],_chan[server]);\n+    write(client,[u8],_chan[bool]);\n+    close_server(server, _chan[bool]);\n     close_client(client);\n }\n \n-type ctx = chan[request];\n+type ctx = _chan[request];\n \n-fn connect_task(ip: str, portnum: int, evt: chan[socket_event]) {\n-    let connecter: port[client] = port();\n-    rustrt::aio_connect(str::buf(ip), portnum, chan(connecter));\n-    let client: client;\n-    connecter |> client;\n+fn ip_to_sbuf(ip: net::ip_addr) -> *u8 {\n+    ivec::to_ptr(str::bytes(net::format_addr(ip)))\n+}\n+\n+fn connect_task(ip: net::ip_addr, portnum: int, evt: _chan[socket_event]) {\n+    let connecter: _port[client] = mk_port();\n+    rustrt::aio_connect(ip_to_sbuf(ip), portnum, connecter.mk_chan());\n+    let client = connecter.recv();\n     new_client(client, evt);\n }\n \n-fn new_client(client: client, evt: chan[socket_event]) {\n+fn new_client(client: client, evt: _chan[socket_event]) {\n     // Start the read before notifying about the connect.  This avoids a race\n     // condition where the receiver can close the socket before we start\n     // reading.\n-    let reader: port[[u8]] = port();\n-    rustrt::aio_read(client, chan(reader));\n+    let reader: _port[[u8]] = mk_port();\n+    rustrt::aio_read(client, reader.mk_chan());\n \n-    evt <| connected(client);\n+    send(evt, connected(client));\n \n     while (true) {\n         log \"waiting for bytes\";\n-        let data: [u8];\n-        reader |> data;\n+        let data: [u8] = reader.recv();\n         log \"got some bytes\";\n         log ivec::len[u8](data);\n         if (ivec::len[u8](data) == 0u) {\n             log \"got empty buffer, bailing\";\n             break;\n         }\n         log \"got non-empty buffer, sending\";\n-        evt <| received(data);\n+        send(evt, received(data));\n         log \"sent non-empty buffer\";\n     }\n     log \"done reading\";\n-    evt <| closed;\n+    send(evt, closed);\n     log \"close message sent\";\n }\n \n-fn accept_task(client: client, events: chan[server_event]) {\n+fn accept_task(client: client, events: _chan[server_event]) {\n     log \"accept task was spawned\";\n-    let p: port[chan[socket_event]] = port();\n-    events <| pending(chan(p));\n-    let evt: chan[socket_event];\n-    p |> evt;\n+    let p: _port[_chan[socket_event]] = mk_port();\n+    send(events, pending(p.mk_chan()));\n+    let evt = p.recv();\n     new_client(client, evt);\n     log \"done accepting\";\n }\n \n-fn server_task(ip: str, portnum: int, events: chan[server_event],\n-               server: chan[server]) {\n-    let accepter: port[client] = port();\n-    server <| rustrt::aio_serve(str::buf(ip), portnum, chan(accepter));\n+fn server_task(ip: net::ip_addr, portnum: int, events: _chan[server_event],\n+               server: _chan[server]) {\n+    let accepter: _port[client] = mk_port();\n+    send(server, rustrt::aio_serve(ip_to_sbuf(ip), portnum,\n+                                   accepter.mk_chan()));\n \n     let client: client;\n     while (true) {\n         log \"preparing to accept a client\";\n-        accepter |> client;\n+        client = accepter.recv();\n         if (rustrt::aio_is_null_client(client)) {\n           log \"client was actually null, returning\";\n           ret;\n@@ -108,48 +120,48 @@ fn server_task(ip: str, portnum: int, events: chan[server_event],\n     }\n }\n \n-fn request_task(c: chan[ctx]) {\n+fn request_task(c: _chan[ctx]) {\n     // Create a port to accept IO requests on\n-    let p: port[request] = port();\n+    let p: _port[request] = mk_port();\n     // Hand of its channel to our spawner\n-    c <| chan(p);\n+    send(c, p.mk_chan());\n     log \"uv run task spawned\";\n     // Spin for requests\n     let req: request;\n     while (true) {\n-        p |> req;\n+        req = p.recv();\n+        log_err req;\n         alt req {\n-            quit. {\n-                log \"got quit message\";\n-\n-                log \"stopping libuv\";\n-                rustrt::aio_stop();\n-                ret;\n-            }\n-            connect(remote(ip,portnum),client) {\n-                task::_spawn(bind connect_task(ip, portnum, client));\n-            }\n-            serve(ip,portnum,events,server) {\n-                task::_spawn(bind server_task(ip, portnum, events, server));\n-            }\n-            write(socket,v,status) {\n-                rustrt::aio_writedata(socket,\n-                                      ivec::to_ptr[u8](v), ivec::len[u8](v),\n-                                      status);\n-            }\n-            close_server(server,status) {\n-                log \"closing server\";\n-                rustrt::aio_close_server(server,status);\n-            }\n-            close_client(client) {\n-                log \"closing client\";\n-                rustrt::aio_close_socket(client);\n-            }\n+          quit. {\n+            log \"got quit message\";\n+            log \"stopping libuv\";\n+            rustrt::aio_stop();\n+            ret;\n+          }\n+          connect(remote(ip,portnum),client) {\n+            task::_spawn(bind connect_task(ip, portnum, client));\n+          }\n+          serve(ip,portnum,events,server) {\n+            task::_spawn(bind server_task(ip, portnum, events, server));\n+          }\n+          write(socket,v,status) {\n+            rustrt::aio_writedata(socket,\n+                                  ivec::to_ptr[u8](v), ivec::len[u8](v),\n+                                  status);\n+          }\n+          close_server(server,status) {\n+            log \"closing server\";\n+            rustrt::aio_close_server(server,status);\n+          }\n+          close_client(client) {\n+            log \"closing client\";\n+            rustrt::aio_close_socket(client);\n+          }\n         }\n     }\n }\n \n-fn iotask(c: chan[ctx]) {\n+fn iotask(c: _chan[ctx]) {\n     log \"io task spawned\";\n     // Initialize before accepting requests\n     rustrt::aio_init();\n@@ -167,11 +179,9 @@ fn iotask(c: chan[ctx]) {\n }\n \n fn new() -> ctx {\n-    let p: port[ctx] = port();\n-    let t = task::_spawn(bind iotask(chan(p)));\n-    let cx: ctx;\n-    p |> cx;\n-    ret cx;\n+    let p: _port[ctx] = mk_port();\n+    task::_spawn(bind iotask(p.mk_chan()));\n+    ret p.recv();\n }\n \n // Local Variables:"}, {"sha": "6a3a6c409c4316a4590e79f91d31b10c1d175960", "filename": "src/lib/net.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Flib%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Flib%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fnet.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -0,0 +1,30 @@\n+import str;\n+import ivec;\n+import uint;\n+\n+tag ip_addr {\n+    ipv4(u8, u8, u8, u8);\n+}\n+\n+fn format_addr(ip : ip_addr) -> str {\n+    alt(ip) {\n+      ipv4(a, b, c, d) {\n+        #fmt(\"%u.%u.%u.%u\",\n+             a as uint,\n+             b as uint,\n+             c as uint,\n+             d as uint)\n+      }\n+      _ { fail \"Unsupported address type\"; }\n+    }\n+}\n+\n+fn parse_addr(ip : str) -> ip_addr {\n+    let parts = ivec::map(uint::from_str, str::split(ip, \".\".(0)));\n+    if ivec::len(parts) != 4u { fail \"Too many dots in IP address\"; }\n+    for i in parts { if i > 255u { fail \"Invalid IP Address part.\"; } }\n+    ipv4(parts.(0) as u8,\n+         parts.(1) as u8,\n+         parts.(2) as u8,\n+         parts.(3) as u8)\n+}"}, {"sha": "7f8e56516e3ba94316e6b7fddbe80999987e5ba2", "filename": "src/lib/sio.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Flib%2Fsio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Flib%2Fsio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsio.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -1,18 +1,27 @@\n+import comm::_port;\n+import comm::_chan;\n+import comm::mk_port;\n+import comm::send;\n+\n+import str;\n+import net;\n+\n type ctx = aio::ctx;\n-type client = { ctx: ctx, client: aio::client, evt: port[aio::socket_event] };\n-type server = { ctx: ctx, server: aio::server, evt: port[aio::server_event] };\n+type client = { ctx: ctx, client: aio::client,\n+               evt: _port[aio::socket_event] };\n+type server = { ctx: ctx, server: aio::server,\n+               evt: _port[aio::server_event] };\n \n fn new() -> ctx {\n     ret aio::new();\n }\n \n fn destroy(ctx: ctx) {\n-    ctx <| aio::quit;\n+    send(ctx, aio::quit);\n }\n \n-fn make_socket(ctx: ctx, p: port[aio::socket_event]) -> client {\n-    let evt: aio::socket_event;\n-    p |> evt;\n+fn make_socket(ctx: ctx, p: _port[aio::socket_event]) -> client {\n+    let evt: aio::socket_event = p.recv();\n     alt evt {\n       aio::connected(client) {\n         ret { ctx: ctx, client: client, evt: p };\n@@ -21,16 +30,14 @@ fn make_socket(ctx: ctx, p: port[aio::socket_event]) -> client {\n     }\n }\n \n-fn connect_to(ctx: ctx, ip: str, portnum: int) -> client {\n-    let p: port[aio::socket_event] = port();\n-    ctx <| aio::connect(aio::remote(ip, portnum), chan(p));\n+fn connect_to(ctx: ctx, ip: net::ip_addr, portnum: int) -> client {\n+    let p: _port[aio::socket_event] = mk_port();\n+    send(ctx, aio::connect(aio::remote(ip, portnum), p.mk_chan()));\n     ret make_socket(ctx, p);\n }\n \n fn read(c: client) -> [u8] {\n-    let evt: aio::socket_event;\n-    c.evt |> evt;\n-    alt evt {\n+    alt c.evt.recv() {\n         aio::closed. {\n             ret ~[];\n         }\n@@ -40,55 +47,51 @@ fn read(c: client) -> [u8] {\n     }\n }\n \n-fn create_server(ctx: ctx, ip: str, portnum: int) -> server {\n-    let evt: port[aio::server_event] = port();\n-    let p: port[aio::server] = port();\n-    ctx <| aio::serve(ip, portnum, chan(evt), chan(p));\n-    let srv: aio::server;\n-    p |> srv;\n+fn create_server(ctx: ctx, ip: net::ip_addr, portnum: int) -> server {\n+    let evt: _port[aio::server_event] = mk_port();\n+    let p: _port[aio::server] = mk_port();\n+    send(ctx, aio::serve(ip, portnum,\n+                         evt.mk_chan(), p.mk_chan()));\n+    let srv: aio::server = p.recv();\n     ret { ctx: ctx, server: srv, evt: evt };\n }\n \n fn accept_from(server: server) -> client {\n-    let evt: aio::server_event;\n-    server.evt |> evt;\n+    let evt: aio::server_event = server.evt.recv();\n     alt evt {\n-        aio::pending(callback) {\n-            let p: port[aio::socket_event] = port();\n-            callback <| chan(p);\n-            ret make_socket(server.ctx, p);\n-        }\n+      aio::pending(callback) {\n+        let p: _port[aio::socket_event] = mk_port();\n+        send(callback, p.mk_chan());\n+        ret make_socket(server.ctx, p);\n+      }\n     }\n }\n \n fn write_data(c: client, data: [u8]) -> bool {\n-    let p: port[bool] = port();\n-    c.ctx <| aio::write(c.client, data, chan(p));\n-    let success: bool;\n-    p |> success;\n-    ret success;\n+    let p: _port[bool] = mk_port();\n+    send(c.ctx, aio::write(c.client, data, p.mk_chan()));\n+    ret p.recv();\n }\n \n fn close_server(server: server) {\n     // TODO: make this unit once we learn to send those from native code\n-    let p: port[bool] = port();\n-    server.ctx <| aio::close_server(server.server, chan(p));\n-    let success: bool;\n+    let p: _port[bool] = mk_port();\n+    send(server.ctx, aio::close_server(server.server, p.mk_chan()));\n     log \"Waiting for close\";\n-    p |> success;\n+    p.recv();\n     log \"Got close\";\n }\n \n fn close_client(client: client) {\n-    client.ctx <| aio::close_client(client.client);\n+    send(client.ctx, aio::close_client(client.client));\n     let evt: aio::socket_event;\n     do {\n-        client.evt |> evt;\n+        evt = client.evt.recv();\n         alt evt {\n-            aio::closed. {\n-                ret;\n-            }\n-            _ {}\n+          aio::closed. {\n+            ret;\n+          }\n+          _ {}\n         }\n     } while (true);\n }"}, {"sha": "715de750da48836493f4f52b5a29e80a3dd7a67c", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -70,6 +70,7 @@ mod run = \"run_program.rs\";\n mod fs;\n mod aio;\n mod sio;\n+mod net;\n \n // FIXME: parametric\n mod map;"}, {"sha": "935eda0e60bf8da0d079f2cf11a8c7a3d15bf436", "filename": "src/lib/task.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -8,7 +8,6 @@ native \"rust\" mod rustrt {\n     fn pin_task();\n     fn unpin_task();\n     fn get_task_id() -> task_id;\n-    fn clone_chan(c: *rust_chan) -> *rust_chan;\n \n     type rust_chan;\n     type rust_task;\n@@ -61,16 +60,6 @@ fn pin() { rustrt::pin_task(); }\n \n fn unpin() { rustrt::unpin_task(); }\n \n-// FIXME: remove this\n-fn clone_chan[T](c: chan[T]) -> chan[T] {\n-    let cloned = rustrt::clone_chan(unsafe::reinterpret_cast(c));\n-    ret unsafe::reinterpret_cast(cloned);\n-}\n-\n-fn send[T](c: chan[T], v: &T) { c <| v; }\n-\n-fn recv[T](p: port[T]) -> T { let v; p |> v; v }\n-\n fn set_min_stack(stack_size : uint) {\n     rustrt::set_min_stack(stack_size);\n }"}, {"sha": "acbaee48ac147300f87a12c5008cabe8cd337475", "filename": "src/lib/uint.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -56,6 +56,10 @@ fn parse_buf(buf: &[u8], radix: uint) -> uint {\n     fail;\n }\n \n+fn from_str(s : &str) -> uint {\n+    parse_buf(str::bytes(s), 10u)\n+}\n+\n fn to_str(num: uint, radix: uint) -> str {\n     let n = num;\n     assert (0u < radix && radix <= 16u);"}, {"sha": "d9755c5588862660ec2d11a5ac06e794a9529eca", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -4,7 +4,7 @@\n // NB: please do not commit code with this uncommented. It's\n // hugely expensive and should only be used as a last resort.\n //\n-// #define TRACK_ALLOCATIONS\n+#define TRACK_ALLOCATIONS\n \n #define MAGIC 0xbadc0ffe\n "}, {"sha": "2675368fd88a512a49885e5f5c1f884390580510", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -775,11 +775,6 @@ migrate_alloc(rust_task *task, void *alloc, rust_task_id tid) {\n     }\n }\n \n-extern \"C\" CDECL rust_chan *\n-clone_chan(rust_task *task, rust_chan *chan) {\n-    return chan->clone(task);\n-}\n-\n // defined in rust_task.cpp\n extern size_t g_custom_min_stack_size;\n extern \"C\" CDECL void"}, {"sha": "99ace5c5294cf70dbaf869fde3efc00765d73b43", "filename": "src/rt/rust_chan.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frust_chan.h", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frust_chan.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.h?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -25,6 +25,12 @@ class rust_chan : public kernel_owned<rust_chan>,\n     rust_chan *clone(rust_task *target);\n };\n \n+// Corresponds to the rust chan (currently _chan) type.\n+struct chan_handle {\n+    rust_task_id task;\n+    rust_port_id port;\n+};\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "65805deefb83b3ea5ef6d368f9f733641b126ac0", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -56,6 +56,7 @@ struct rust_task;\n class rust_log;\n class rust_port;\n class rust_chan;\n+struct chan_handle;\n struct rust_token;\n class rust_kernel;\n class rust_crate_cache;"}, {"sha": "8ef83488513bbe59c6f7a6d7d9c092e5844c9652", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -527,6 +527,17 @@ rust_port *rust_task::get_port_by_id(rust_port_id id) {\n     return port;\n }\n \n+rust_chan *rust_task::get_chan_by_handle(chan_handle *handle) {\n+    rust_task *target_task = kernel->get_task_by_id(handle->task);\n+    if(target_task) {\n+        rust_port *port = target_task->get_port_by_id(handle->port);\n+        target_task->deref();\n+        port->remote_chan->ref();\n+        return port->remote_chan;\n+    }\n+    return NULL;\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "aafc0e1abb732ba976cf738c0207e2712cea3464", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -173,6 +173,8 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     // Use this function sparingly. Depending on the ref count is generally\n     // not at all safe.\n     intptr_t get_ref_count() const { return ref_count; }\n+\n+    rust_chan *get_chan_by_handle(chan_handle *handle);\n };\n \n //"}, {"sha": "b792121de35437057a4d831f2af9407d0d561968", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -170,19 +170,24 @@ static void new_connection(uv_handle_t *socket, int status) {\n }\n \n extern \"C\" CDECL socket_data *aio_serve(rust_task *task, const char *ip,\n-                                        int port, rust_chan *chan) {\n+                                        int port, chan_handle *_chan) {\n   LOG_UPCALL_ENTRY(task);\n+  rust_chan *chan = task->get_chan_by_handle(_chan);\n+  if(!chan) return NULL;\n   struct sockaddr_in addr = uv_ip4_addr(const_cast<char*>(ip), port);\n   socket_data *server = make_socket(iotask, chan);\n   if (!server)\n     goto oom;\n   if (uv_tcp_bind(&server->socket, addr) ||\n       uv_tcp_listen(&server->socket, 128, new_connection)) {\n     aio_close_socket(task, server);\n+    chan->deref();\n     return NULL;\n   }\n+  chan->deref();\n   return server;\n oom:\n+  chan->deref();\n   task->fail();\n   return NULL;\n }\n@@ -218,15 +223,18 @@ extern \"C\" CDECL void aio_close_socket(rust_task *task, socket_data *client) {\n }\n \n extern \"C\" CDECL void aio_close_server(rust_task *task, socket_data *server,\n-                                       rust_chan *chan) {\n+                                       chan_handle *_chan) {\n   LOG_UPCALL_ENTRY(task);\n+  rust_chan *chan = task->get_chan_by_handle(_chan);\n+  if(!chan) return;\n   // XXX: hax until rust_task::kill\n   // send null and the receiver knows to call back into native code to check\n   void* null_client = NULL;\n   server->chan->send(&null_client);\n   server->chan->deref();\n   server->chan = chan->clone(iotask);\n   aio_close_socket(task, server);\n+  chan->deref();\n }\n \n extern \"C\" CDECL bool aio_is_null_client(rust_task *task,\n@@ -243,8 +251,10 @@ static void connection_complete(request *req, int status) {\n }\n \n extern \"C\" CDECL void aio_connect(rust_task *task, const char *host,\n-                                  int port, rust_chan *chan) {\n+                                  int port, chan_handle *_chan) {\n   LOG_UPCALL_ENTRY(task);\n+  rust_chan *chan = task->get_chan_by_handle(_chan);\n+  if(!chan) return;\n   struct sockaddr_in addr = uv_ip4_addr(const_cast<char*>(host), port);\n   request *req;\n   socket_data *client = make_socket(iotask, NULL);\n@@ -257,11 +267,13 @@ extern \"C\" CDECL void aio_connect(rust_task *task, const char *host,\n     goto oom_req;\n   }\n   if (0 == uv_tcp_connect(req, addr)) {\n-    return;\n+      chan->deref();\n+      return;\n   }\n oom_req:\n   aio_close_socket(task, client);\n oom_client:\n+  chan->deref();\n   task->fail();\n   return;\n }\n@@ -274,8 +286,11 @@ static void write_complete(request *req, int status) {\n }\n \n extern \"C\" CDECL void aio_writedata(rust_task *task, socket_data *data,\n-                                    char *buf, size_t size, rust_chan *chan) {\n+                                    char *buf, size_t size,\n+                                    chan_handle *_chan) {\n   LOG_UPCALL_ENTRY(task);\n+  rust_chan *chan = task->get_chan_by_handle(_chan);\n+  if(!chan) return;\n \n   // uv_buf_t is defined backwards on win32...\n   // maybe an indication we shouldn't be building directly?\n@@ -294,15 +309,20 @@ extern \"C\" CDECL void aio_writedata(rust_task *task, socket_data *data,\n     delete req;\n     goto fail;\n   }\n+  chan->deref();\n   return;\n fail:\n+  chan->deref();\n   task->fail();\n }\n \n extern \"C\" CDECL void aio_read(rust_task *task, socket_data *data,\n-                               rust_chan *reader) {\n+                               chan_handle *_chan) {\n   LOG_UPCALL_ENTRY(task);\n+  rust_chan *reader = task->get_chan_by_handle(_chan);\n+  if(!reader) return;\n   I(task->sched, data->reader == NULL);\n   data->reader = reader->clone(iotask);\n   uv_read_start((uv_stream_t*)&data->socket, alloc_buffer, read_progress);\n+  reader->deref();\n }"}, {"sha": "ce8434240d5a3e7c5d442bfb0a172d7c238443ba", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -12,7 +12,6 @@ align_of\n chan_id_send\n chan_send\n check_claims\n-clone_chan\n debug_box\n debug_fn\n debug_obj"}, {"sha": "d97d358d9e0a624c0c98e92e9532a3356454cc65", "filename": "src/test/compile-fail/bad-recv.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e33af7e0b505de6d7c754d2ead26c9ee2bc8974e/src%2Ftest%2Fcompile-fail%2Fbad-recv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33af7e0b505de6d7c754d2ead26c9ee2bc8974e/src%2Ftest%2Fcompile-fail%2Fbad-recv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-recv.rs?ref=e33af7e0b505de6d7c754d2ead26c9ee2bc8974e", "patch": "@@ -1,3 +0,0 @@\n-// error-pattern: mismatched types\n-\n-fn main() { 10 |> 10; }\n\\ No newline at end of file"}, {"sha": "deb7a744c60acf5a1ad88a788712a165aa676417", "filename": "src/test/compile-fail/bad-send.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e33af7e0b505de6d7c754d2ead26c9ee2bc8974e/src%2Ftest%2Fcompile-fail%2Fbad-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33af7e0b505de6d7c754d2ead26c9ee2bc8974e/src%2Ftest%2Fcompile-fail%2Fbad-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-send.rs?ref=e33af7e0b505de6d7c754d2ead26c9ee2bc8974e", "patch": "@@ -1,3 +0,0 @@\n-// error-pattern: mismatched types\n-\n-fn main() { 10 <| 10; }\n\\ No newline at end of file"}, {"sha": "e1b49d75ddbeb382a719194fd1d899deb45dff88", "filename": "src/test/compile-fail/binop-shift-port.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e33af7e0b505de6d7c754d2ead26c9ee2bc8974e/src%2Ftest%2Fcompile-fail%2Fbinop-shift-port.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33af7e0b505de6d7c754d2ead26c9ee2bc8974e/src%2Ftest%2Fcompile-fail%2Fbinop-shift-port.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-shift-port.rs?ref=e33af7e0b505de6d7c754d2ead26c9ee2bc8974e", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern:>> cannot be applied to type `port[int]`\n-\n-fn main() {\n-    let p1: port[int] = port();\n-    let p2: port[int] = port();\n-    let x = p1 >> p2;\n-}\n\\ No newline at end of file"}, {"sha": "4fbb0d1498bd38605a9ae2eede475d05db240994", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -5,11 +5,12 @@\n \n use std;\n import std::task;\n+import std::comm::mk_port;\n \n fn child() { assert (1 == 2); }\n \n fn main() {\n-    let p: port[int] = port();\n+    let p = mk_port[int]();\n     task::_spawn(bind child());\n-    let x: int; p |> x;\n+    let x = p.recv();\n }"}, {"sha": "bacb7f9effc4a3dcde8110feaf10622dfc42c8c1", "filename": "src/test/run-fail/port-type.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-fail%2Fport-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-fail%2Fport-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fport-type.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -1,13 +1,17 @@\n // error-pattern:meep\n-fn echo[T](c: chan[T], oc: chan[chan[T]]) {\n+use std;\n+import std::comm::_chan;\n+import std::comm::mk_port;\n+import std::comm::send;\n+\n+fn echo[~T](c: _chan[T], oc: _chan[_chan[T]]) {\n     // Tests that the type argument in port gets\n     // visited\n-    let p = port[T]();\n-    oc <| chan(p);\n+    let p = mk_port[T]();\n+    send(oc, p.mk_chan());\n \n-    let x;\n-    p |> x;\n-    c <| x;\n+    let x = p.recv();\n+    send(c, x);\n }\n \n-fn main() { fail \"meep\"; }\n\\ No newline at end of file\n+fn main() { fail \"meep\"; }"}, {"sha": "f6f2f5be7e5361fb6ee036db6c23e9e6ab14487b", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -3,6 +3,7 @@\n use std;\n import std::unsafe::reinterpret_cast;\n import std::task;\n+import std::comm;\n \n fn test_nil() {\n     assert (() == ());\n@@ -60,20 +61,21 @@ fn test_box() {\n }\n \n fn test_port() {\n-    let p1: port[int] = port();\n-    let p2: port[int] = port();\n+    let p1 = comm::mk_port[int]();\n+    let p2 = comm::mk_port[int]();\n \n     assert p1 == p1;\n     assert p1 != p2;\n }\n \n fn test_chan() {\n-    let p: port[int] = port();\n-    let ch1 = chan(p);\n-    let ch2 = chan(p);\n+    let p: comm::_port[int] = comm::mk_port();\n+    let ch1 = p.mk_chan();\n+    let ch2 = p.mk_chan();\n \n     assert ch1 == ch1;\n-    assert ch1 != ch2;\n+    // Chans are equal because they are just task:port addresses.\n+    assert ch1 == ch2;\n }\n \n fn test_ptr() {"}, {"sha": "e078bef7131aae182254634138ed895df2012c4a", "filename": "src/test/run-pass/decl-with-recv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -1,16 +1,16 @@\n+// -*- rust -*-\n \n+use std;\n+import std::comm::mk_port;\n+import std::comm::send;\n \n-\n-// -*- rust -*-\n fn main() {\n-    let po: port[int] = port();\n-    let ch: chan[int] = chan(po);\n-    ch <| 10;\n-    let i: int;\n-    po |> i;\n+    let po = mk_port();\n+    let ch = po.mk_chan();\n+    send(ch, 10);\n+    let i = po.recv();\n     assert (i == 10);\n-    ch <| 11;\n-    let j;\n-    po |> j;\n+    send(ch, 11);\n+    let j = po.recv();\n     assert (j == 11);\n }\n\\ No newline at end of file"}, {"sha": "a7cb03906ed9bc4481ccdcea30b62493bade8227", "filename": "src/test/run-pass/obj-docs.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Fobj-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Fobj-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-docs.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -1,5 +1,9 @@\n // Sanity-check the code examples that appear in the object system\n // documentation.\n+use std;\n+import std::comm::_chan;\n+import std::comm::send;\n+import std::comm::mk_port;\n \n fn main() {\n \n@@ -43,9 +47,9 @@ fn main() {\n         }\n     }\n \n-    obj sender(c: chan[int]) {\n+    obj sender(c: _chan[int]) {\n         fn take(z: int) {\n-            c <| z;\n+            send(c, z);\n         }\n     }\n \n@@ -55,10 +59,10 @@ fn main() {\n         t.take(3);\n     }\n \n-    let p: port[int] = port();\n+    let p = mk_port[int]();\n \n     let t1: taker = adder(@mutable 0);\n-    let t2: taker = sender(chan(p));\n+    let t2: taker = sender(p.mk_chan());\n \n     give_ints(t1);\n     give_ints(t2);"}, {"sha": "11b67593bd6c272149361bbdf162afa5f75b9835", "filename": "src/test/run-pass/rt-circular-buffer.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -1,13 +1,13 @@\n-\n-\n // -*- rust -*-\n \n // Regression tests for circular_buffer when using a unit\n // that has a size that is not a power of two\n use std;\n import std::option;\n import std::uint;\n-\n+import std::comm;\n+import std::comm::mk_port;\n+import std::comm::send;\n \n // A 12-byte unit to send over the channel\n type record = {val1: u32, val2: u32, val3: u32};\n@@ -18,50 +18,52 @@ type record = {val1: u32, val2: u32, val3: u32};\n // power of two so needs to be rounded up. Don't trigger any\n // assertions.\n fn test_init() {\n-    let myport: port[record] = port();\n-    let mychan = chan(myport);\n+    let myport = mk_port[record]();\n+    let mychan = myport.mk_chan();\n     let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n-    mychan <| val;\n+    send(mychan, val);\n }\n \n \n // Dump lots of items into the channel so it has to grow.\n // Don't trigger any assertions.\n fn test_grow() {\n-    let myport: port[record] = port();\n-    let mychan = chan(myport);\n-    let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n-    for each i: uint in uint::range(0u, 100u) { mychan <| val; }\n+    let myport: comm::_port[record] = comm::mk_port();\n+    let mychan = myport.mk_chan();\n+    for each i: uint  in uint::range(0u, 100u) {\n+        let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n+        comm::send(mychan, val);\n+    }\n }\n \n \n // Don't allow the buffer to shrink below it's original size\n fn test_shrink1() {\n-    let myport: port[i8] = port();\n-    let mychan = chan(myport);\n-    mychan <| 0i8;\n-    let x;\n-    myport |> x;\n+    let myport = comm::mk_port[i8]();\n+    let mychan = myport.mk_chan();\n+    send(mychan, 0i8);\n+    let x = myport.recv();\n }\n \n fn test_shrink2() {\n-    let myport: port[record] = port();\n-    let mychan = chan(myport);\n-    let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n-    for each i: uint in uint::range(0u, 100u) { mychan <| val; }\n-    for each i: uint in uint::range(0u, 100u) { let x; myport |> x; }\n+    let myport = mk_port[record]();\n+    let mychan = myport.mk_chan();\n+    for each i: uint  in uint::range(0u, 100u) {\n+        let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n+        send(mychan, val);\n+    }\n+    for each i: uint  in uint::range(0u, 100u) { let x = myport.recv(); }\n }\n \n \n // Test rotating the buffer when the unit size is not a power of two\n fn test_rotate() {\n-    let myport: port[record] = port();\n-    let mychan = chan(myport);\n-    for each i: uint in uint::range(0u, 100u) {\n+    let myport = mk_port[record]();\n+    let mychan = myport.mk_chan();\n+    for each i: uint  in uint::range(0u, 100u) {\n         let val = {val1: i as u32, val2: i as u32, val3: i as u32};\n-        mychan <| val;\n-        let x;\n-        myport |> x;\n+        send(mychan, val);\n+        let x = myport.recv();\n         assert (x.val1 == i as u32);\n         assert (x.val2 == i as u32);\n         assert (x.val3 == i as u32);\n@@ -72,17 +74,16 @@ fn test_rotate() {\n // Test rotating and growing the buffer when\n // the unit size is not a power of two\n fn test_rotate_grow() {\n-    let myport: port[record] = port();\n-    let mychan = chan(myport);\n-    for each j: uint in uint::range(0u, 10u) {\n-        for each i: uint in uint::range(0u, 10u) {\n+    let myport = mk_port[record]();\n+    let mychan = myport.mk_chan();\n+    for each j: uint  in uint::range(0u, 10u) {\n+        for each i: uint  in uint::range(0u, 10u) {\n             let val: record =\n                 {val1: i as u32, val2: i as u32, val3: i as u32};\n-            mychan <| val;\n+            send(mychan, val);\n         }\n-        for each i: uint in uint::range(0u, 10u) {\n-            let x;\n-            myport |> x;\n+        for each i: uint  in uint::range(0u, 10u) {\n+            let x = myport.recv();\n             assert (x.val1 == i as u32);\n             assert (x.val2 == i as u32);\n             assert (x.val3 == i as u32);"}, {"sha": "c689c479bacd1c76b735b3a454303bbbe13e4896", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -1,8 +1,13 @@\n+use std;\n+import std::comm::_chan;\n+import std::comm::send;\n+import std::comm::mk_port;\n+\n // tests that ctrl's type gets inferred properly\n type command[K, V] = {key: K, val: V};\n \n-fn cache_server[K, V](c: chan[chan[command[K, V]]]) {\n-    let ctrl = port();\n-    c <| chan(ctrl);\n+fn cache_server[K, V](c: _chan[_chan[command[K, V]]]) {\n+    let ctrl = mk_port[_chan[command[K, V]]]();\n+    send(c, ctrl.mk_chan());\n }\n fn main() { }\n\\ No newline at end of file"}, {"sha": "a5667ff0616768d02864a48694b16565868d129f", "filename": "src/test/run-pass/sio-client.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Fsio-client.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Fsio-client.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-client.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -1,23 +1,26 @@\n // xfail-stage1\n // xfail-stage2\n // xfail-stage3\n-\n use std;\n import std::sio;\n import std::task;\n+import std::net;\n \n-fn connectTask(cx: sio::ctx, ip: str, portnum: int) {\n+fn connectTask(cx: sio::ctx, ip: net::ip_addr, portnum: int) {\n   let client: sio::client;\n   client = sio::connect_to(cx, ip, portnum);\n   sio::close_client(client);\n }\n \n fn main() {\n   let cx: sio::ctx = sio::new();\n-  let srv: sio::server = sio::create_server(cx, \"0.0.0.0\", 9090);\n-  let child: task = spawn connectTask(cx, \"127.0.0.1\", 9090);\n+  let srv: sio::server = sio::create_server(cx,\n+                                            net::parse_addr(\"0.0.0.0\"), 9090);\n+  let child = task::_spawn(bind connectTask(cx,\n+                                            net::parse_addr(\"127.0.0.1\"),\n+                                            9090));\n   let client: sio::client = sio::accept_from(srv);\n-  task::join(child);\n+  task::join_id(child);\n   sio::close_client(client);\n   sio::close_server(srv);\n   sio::destroy(cx);"}, {"sha": "be8018d4278687cf4b427fb5730298b352f745a7", "filename": "src/test/run-pass/task-comm-chan-nil.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -1,16 +1,15 @@\n-\n-\n-\n // -*- rust -*-\n \n+use std;\n+import std::comm;\n+\n // rustboot can't transmit nils across channels because they don't have\n // any size, but rustc currently can because they do have size. Whether\n // or not this is desirable I don't know, but here's a regression test.\n fn main() {\n-    let po: port[()] = port();\n-    let ch: chan[()] = chan(po);\n-    ch <| ();\n-    let n: ();\n-    po |> n;\n+    let po: comm::_port[()] = comm::mk_port();\n+    let ch: comm::_chan[()] = po.mk_chan();\n+    comm::send(ch, ());\n+    let n: () = po.recv();\n     assert (n == ());\n }\n\\ No newline at end of file"}, {"sha": "61e36b171e219581c58ef749c8ee43880ded7b58", "filename": "src/test/run-pass/trivial-message.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial-message.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -1,15 +1,15 @@\n-\n-\n+use std;\n+import std::comm::mk_port;\n+import std::comm::send;\n \n /*\n   This is about the simplest program that can successfully send a\n   message.\n  */\n fn main() {\n-    let po: port[int] = port();\n-    let ch: chan[int] = chan(po);\n-    ch <| 42;\n-    let r;\n-    po |> r;\n+    let po = mk_port[int]();\n+    let ch = po.mk_chan();\n+    send(ch, 42);\n+    let r = po.recv();\n     log_err r;\n }\n\\ No newline at end of file"}, {"sha": "c1a26cb747deff35268b387da7c7d2440cc9d6c7", "filename": "src/test/stdtest/net.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Fstdtest%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Fstdtest%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fnet.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -0,0 +1,12 @@\n+use std;\n+import std::net;\n+\n+#[test]\n+fn test_format_ip() {\n+    assert(net::format_addr(net::ipv4(127u8,0u8,0u8,1u8)) == \"127.0.0.1\")\n+}\n+\n+#[test]\n+fn test_parse_ip() {\n+    assert(net::parse_addr(\"127.0.0.1\") == net::ipv4(127u8,0u8,0u8,1u8));\n+}"}, {"sha": "cda3b939eb3243be996dc1ed583ba2e2559a83b5", "filename": "src/test/stdtest/stdtest.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Fstdtest%2Fstdtest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Fstdtest%2Fstdtest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstdtest.rc?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -12,6 +12,7 @@ mod io;\n mod ivec;\n mod list;\n mod map;\n+mod net;\n mod option;\n mod os;\n mod path;"}, {"sha": "56b555232a924974070c06e6621f1bf29b2ba5eb", "filename": "src/test/stdtest/task.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Fstdtest%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2def46c120d8d6ef8a98571a39bef478c8c2a9/src%2Ftest%2Fstdtest%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftask.rs?ref=cf2def46c120d8d6ef8a98571a39bef478c8c2a9", "patch": "@@ -25,14 +25,6 @@ fn test_join() {\n     assert (task::join_id(failtask) == task::tr_failure);\n }\n \n-#[test]\n-fn test_send_recv() {\n-    let p = port[int]();\n-    let c = chan(p);\n-    task::send(c, 10);\n-    assert (task::recv(p) == 10);\n-}\n-\n #[test]\n fn test_lib_spawn() {\n     fn foo() { log_err \"Hello, World!\"; }"}]}