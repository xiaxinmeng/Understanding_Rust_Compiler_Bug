{"sha": "7afed9274976b6dc427c56b931cffcc1949f52cd", "node_id": "C_kwDOAAsO6NoAKDdhZmVkOTI3NDk3NmI2ZGM0MjdjNTZiOTMxY2ZmY2MxOTQ5ZjUyY2Q", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-23T07:35:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-23T07:35:35Z"}, "message": "Rollup merge of #109475 - scottmcm:simpler-shifts, r=WaffleLapkin\n\nSimpler checked shifts in MIR building\n\nDoing masking to check unsigned shift amounts is overcomplicated; just comparing the shift directly saves a statement and a temporary, as well as is much easier to read as a human.  And shifting by unsigned is the canonical case -- notably, all the library shifting methods (that don't support every type) take shift RHSs as `u32` -- so we might as well make that simpler since it's easy to do so.\n\nThis PR also changes *signed* shift amounts to `IntToInt` casts and then uses the same check as for unsigned.  The bit-masking is a nice trick, but for example LLVM actually canonicalizes it to an unsigned comparison anyway <https://rust.godbolt.org/z/8h59fMGT4> so I don't think it's worth the effort and the extra `Constant`.  (If MIR's `assert` was `assert_nz` then the masking might make sense, but when the `!=` uses another statement I think the comparison is better.)\n\nTo review, I suggest looking at https://github.com/rust-lang/rust/pull/109475/commits/2ee0468c49be9f8ea68b7b935ea1f4c2555849e9 first -- that's the interesting code change and has a MIR diff.\n\nMy favourite part of the diff:\n```diff\n-        _20 = BitAnd(_19, const 340282366920938463463374607431768211448_u128); // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n-        _21 = Ne(move _20, const 0_u128); // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n-        assert(!move _21, \"attempt to shift right by `{}`, which would overflow\", _19) -> [success: bb3, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        _18 = Lt(_17, const 8_u128);     // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        assert(move _18, \"attempt to shift right by `{}`, which would overflow\", _17) -> [success: bb3, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n```", "tree": {"sha": "c4a0ebe3756c1efc64fba7b902d70a883f01d0dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4a0ebe3756c1efc64fba7b902d70a883f01d0dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7afed9274976b6dc427c56b931cffcc1949f52cd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkHAFHCRBK7hj4Ov3rIwAAqekIAGmIIGmBXTgeHl0+PG6/d+L2\n4CvpN86GmwK9gpUtL/dMOGtN+QSUs37kMtUdaffrwsMFkHzA0dUy2SjPndDeQduJ\nPm7fZt0vv+kD9DluVMtUDA03Sz+A1A3YzlolKnvvkzdSS7vapKB2+lHGrbMn5PZM\nkYcSsSp4hJObf+1tXfVGD+bmTOHCBzkzuYlVt283/71euYwTdVYhxunYrsKabjoX\njnMdOtyE6cDLV4ra38+iSvjWfCqUYDOPCbvip1e9HTjZVj37FY2mmF6oOiUwGIWs\n28Yb7yxwTc6rt7OL/FMVrMeWcDcdKL/ZOlwfvYHvPQVRd67bJETTU638fAQnWzg=\n=4DW6\n-----END PGP SIGNATURE-----\n", "payload": "tree c4a0ebe3756c1efc64fba7b902d70a883f01d0dd\nparent 5d28853efe7ae11a77f5f7601a216e8ca36d6234\nparent b537e6bc53bfee64d1e8f8f8d28b2418bddc5a91\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1679556935 +0100\ncommitter GitHub <noreply@github.com> 1679556935 +0100\n\nRollup merge of #109475 - scottmcm:simpler-shifts, r=WaffleLapkin\n\nSimpler checked shifts in MIR building\n\nDoing masking to check unsigned shift amounts is overcomplicated; just comparing the shift directly saves a statement and a temporary, as well as is much easier to read as a human.  And shifting by unsigned is the canonical case -- notably, all the library shifting methods (that don't support every type) take shift RHSs as `u32` -- so we might as well make that simpler since it's easy to do so.\n\nThis PR also changes *signed* shift amounts to `IntToInt` casts and then uses the same check as for unsigned.  The bit-masking is a nice trick, but for example LLVM actually canonicalizes it to an unsigned comparison anyway <https://rust.godbolt.org/z/8h59fMGT4> so I don't think it's worth the effort and the extra `Constant`.  (If MIR's `assert` was `assert_nz` then the masking might make sense, but when the `!=` uses another statement I think the comparison is better.)\n\nTo review, I suggest looking at https://github.com/rust-lang/rust/pull/109475/commits/2ee0468c49be9f8ea68b7b935ea1f4c2555849e9 first -- that's the interesting code change and has a MIR diff.\n\nMy favourite part of the diff:\n```diff\n-        _20 = BitAnd(_19, const 340282366920938463463374607431768211448_u128); // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n-        _21 = Ne(move _20, const 0_u128); // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n-        assert(!move _21, \"attempt to shift right by `{}`, which would overflow\", _19) -> [success: bb3, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        _18 = Lt(_17, const 8_u128);     // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        assert(move _18, \"attempt to shift right by `{}`, which would overflow\", _17) -> [success: bb3, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7afed9274976b6dc427c56b931cffcc1949f52cd", "html_url": "https://github.com/rust-lang/rust/commit/7afed9274976b6dc427c56b931cffcc1949f52cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7afed9274976b6dc427c56b931cffcc1949f52cd/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d28853efe7ae11a77f5f7601a216e8ca36d6234", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d28853efe7ae11a77f5f7601a216e8ca36d6234", "html_url": "https://github.com/rust-lang/rust/commit/5d28853efe7ae11a77f5f7601a216e8ca36d6234"}, {"sha": "b537e6bc53bfee64d1e8f8f8d28b2418bddc5a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/b537e6bc53bfee64d1e8f8f8d28b2418bddc5a91", "html_url": "https://github.com/rust-lang/rust/commit/b537e6bc53bfee64d1e8f8f8d28b2418bddc5a91"}], "stats": {"total": 408, "additions": 371, "deletions": 37}, "files": [{"sha": "3b775f590a4c1fa8427ebd66e6a33f6d6c88a177", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7afed9274976b6dc427c56b931cffcc1949f52cd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7afed9274976b6dc427c56b931cffcc1949f52cd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=7afed9274976b6dc427c56b931cffcc1949f52cd", "patch": "@@ -566,41 +566,51 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Rvalue::Use(Operand::Move(val))\n             }\n             BinOp::Shl | BinOp::Shr if self.check_overflow && ty.is_integral() => {\n-                // Consider that the shift overflows if `rhs < 0` or `rhs >= bits`.\n-                // This can be encoded as a single operation as `(rhs & -bits) != 0`.\n-                let (size, _) = ty.int_size_and_signed(self.tcx);\n-                let bits = size.bits();\n-                debug_assert!(bits.is_power_of_two());\n-                let mask = !((bits - 1) as u128);\n-\n+                // For an unsigned RHS, the shift is in-range for `rhs < bits`.\n+                // For a signed RHS, `IntToInt` cast to the equivalent unsigned\n+                // type and do that same comparison.  Because the type is the\n+                // same size, there's no negative shift amount that ends up\n+                // overlapping with valid ones, thus it catches negatives too.\n+                let (lhs_size, _) = ty.int_size_and_signed(self.tcx);\n                 let rhs_ty = rhs.ty(&self.local_decls, self.tcx);\n                 let (rhs_size, _) = rhs_ty.int_size_and_signed(self.tcx);\n-                let mask = Operand::const_from_scalar(\n+\n+                let (unsigned_rhs, unsigned_ty) = match rhs_ty.kind() {\n+                    ty::Uint(_) => (rhs.to_copy(), rhs_ty),\n+                    ty::Int(int_width) => {\n+                        let uint_ty = self.tcx.mk_mach_uint(int_width.to_unsigned());\n+                        let rhs_temp = self.temp(uint_ty, span);\n+                        self.cfg.push_assign(\n+                            block,\n+                            source_info,\n+                            rhs_temp,\n+                            Rvalue::Cast(CastKind::IntToInt, rhs.to_copy(), uint_ty),\n+                        );\n+                        (Operand::Move(rhs_temp), uint_ty)\n+                    }\n+                    _ => unreachable!(\"only integers are shiftable\"),\n+                };\n+\n+                // This can't overflow because the largest shiftable types are 128-bit,\n+                // which fits in `u8`, the smallest possible `unsigned_ty`.\n+                // (And `from_uint` will `bug!` if that's ever no longer true.)\n+                let lhs_bits = Operand::const_from_scalar(\n                     self.tcx,\n-                    rhs_ty,\n-                    Scalar::from_uint(rhs_size.truncate(mask), rhs_size),\n+                    unsigned_ty,\n+                    Scalar::from_uint(lhs_size.bits(), rhs_size),\n                     span,\n                 );\n \n-                let outer_bits = self.temp(rhs_ty, span);\n-                self.cfg.push_assign(\n-                    block,\n-                    source_info,\n-                    outer_bits,\n-                    Rvalue::BinaryOp(BinOp::BitAnd, Box::new((rhs.to_copy(), mask))),\n-                );\n-\n-                let overflows = self.temp(bool_ty, span);\n-                let zero = self.zero_literal(span, rhs_ty);\n+                let inbounds = self.temp(bool_ty, span);\n                 self.cfg.push_assign(\n                     block,\n                     source_info,\n-                    overflows,\n-                    Rvalue::BinaryOp(BinOp::Ne, Box::new((Operand::Move(outer_bits), zero))),\n+                    inbounds,\n+                    Rvalue::BinaryOp(BinOp::Lt, Box::new((unsigned_rhs, lhs_bits))),\n                 );\n \n                 let overflow_err = AssertKind::Overflow(op, lhs.to_copy(), rhs.to_copy());\n-                block = self.assert(block, Operand::Move(overflows), false, overflow_err, span);\n+                block = self.assert(block, Operand::Move(inbounds), true, overflow_err, span);\n                 Rvalue::BinaryOp(op, Box::new((lhs, rhs)))\n             }\n             BinOp::Div | BinOp::Rem if ty.is_integral() => {"}, {"sha": "8b23fbc75833cf357a86786d8a29b88bc53759e3", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7afed9274976b6dc427c56b931cffcc1949f52cd/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7afed9274976b6dc427c56b931cffcc1949f52cd/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=7afed9274976b6dc427c56b931cffcc1949f52cd", "patch": "@@ -432,6 +432,17 @@ impl IntTy {\n             _ => *self,\n         }\n     }\n+\n+    pub fn to_unsigned(self) -> UintTy {\n+        match self {\n+            IntTy::Isize => UintTy::Usize,\n+            IntTy::I8 => UintTy::U8,\n+            IntTy::I16 => UintTy::U16,\n+            IntTy::I32 => UintTy::U32,\n+            IntTy::I64 => UintTy::U64,\n+            IntTy::I128 => UintTy::U128,\n+        }\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n@@ -479,6 +490,17 @@ impl UintTy {\n             _ => *self,\n         }\n     }\n+\n+    pub fn to_signed(self) -> IntTy {\n+        match self {\n+            UintTy::Usize => IntTy::Isize,\n+            UintTy::U8 => IntTy::I8,\n+            UintTy::U16 => IntTy::I16,\n+            UintTy::U32 => IntTy::I32,\n+            UintTy::U64 => IntTy::I64,\n+            UintTy::U128 => IntTy::I128,\n+        }\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]"}, {"sha": "4b63a00a304dc80b7df45071d42a444c24a3d3de", "filename": "tests/mir-opt/building/shifts.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7afed9274976b6dc427c56b931cffcc1949f52cd/tests%2Fmir-opt%2Fbuilding%2Fshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7afed9274976b6dc427c56b931cffcc1949f52cd/tests%2Fmir-opt%2Fbuilding%2Fshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fshifts.rs?ref=7afed9274976b6dc427c56b931cffcc1949f52cd", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -C debug-assertions=yes\n+\n+// EMIT_MIR shifts.shift_signed.built.after.mir\n+fn shift_signed(small: i8, big: u128, a: i8, b: i32, c: i128) -> ([i8; 3], [u128; 3]) {\n+    (\n+        [small >> a, small >> b, small >> c],\n+        [big << a, big << b, big << c],\n+    )\n+}\n+\n+// EMIT_MIR shifts.shift_unsigned.built.after.mir\n+fn shift_unsigned(small: u8, big: i128, a: u8, b: u32, c: u128) -> ([u8; 3], [i128; 3]) {\n+    (\n+        [small >> a, small >> b, small >> c],\n+        [big << a, big << b, big << c],\n+    )\n+}\n+\n+fn main() {\n+}"}, {"sha": "028777cefdd10a932dbf552153d8ba3f85dbdca1", "filename": "tests/mir-opt/building/shifts.shift_signed.built.after.mir", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/7afed9274976b6dc427c56b931cffcc1949f52cd/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_signed.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7afed9274976b6dc427c56b931cffcc1949f52cd/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_signed.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_signed.built.after.mir?ref=7afed9274976b6dc427c56b931cffcc1949f52cd", "patch": "@@ -0,0 +1,147 @@\n+// MIR for `shift_signed` after built\n+\n+fn shift_signed(_1: i8, _2: u128, _3: i8, _4: i32, _5: i128) -> ([i8; 3], [u128; 3]) {\n+    debug small => _1;                   // in scope 0 at $DIR/shifts.rs:+0:17: +0:22\n+    debug big => _2;                     // in scope 0 at $DIR/shifts.rs:+0:28: +0:31\n+    debug a => _3;                       // in scope 0 at $DIR/shifts.rs:+0:39: +0:40\n+    debug b => _4;                       // in scope 0 at $DIR/shifts.rs:+0:46: +0:47\n+    debug c => _5;                       // in scope 0 at $DIR/shifts.rs:+0:54: +0:55\n+    let mut _0: ([i8; 3], [u128; 3]);    // return place in scope 0 at $DIR/shifts.rs:+0:66: +0:86\n+    let mut _6: [i8; 3];                 // in scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+    let mut _7: i8;                      // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _8: i8;                      // in scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+    let mut _9: i8;                      // in scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+    let mut _10: u8;                     // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _11: bool;                   // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _12: i8;                     // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _13: i8;                     // in scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+    let mut _14: i32;                    // in scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+    let mut _15: u32;                    // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _16: bool;                   // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _17: i8;                     // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _18: i8;                     // in scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+    let mut _19: i128;                   // in scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+    let mut _20: u128;                   // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _21: bool;                   // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _22: [u128; 3];              // in scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+    let mut _23: u128;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _24: u128;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+    let mut _25: i8;                     // in scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+    let mut _26: u8;                     // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _27: bool;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _28: u128;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _29: u128;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+    let mut _30: i32;                    // in scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+    let mut _31: u32;                    // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _32: bool;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _33: u128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    let mut _34: u128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+    let mut _35: i128;                   // in scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+    let mut _36: u128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    let mut _37: bool;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+\n+    bb0: {\n+        StorageLive(_6);                 // scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+        StorageLive(_7);                 // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        StorageLive(_8);                 // scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+        _8 = _1;                         // scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+        StorageLive(_9);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        _9 = _3;                         // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        _10 = _9 as u8 (IntToInt);       // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        _11 = Lt(move _10, const 8_u8);  // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        assert(move _11, \"attempt to shift right by `{}`, which would overflow\", _9) -> [success: bb1, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    }\n+\n+    bb1: {\n+        _7 = Shr(move _8, move _9);      // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        StorageDead(_9);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        StorageDead(_8);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        StorageLive(_12);                // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        StorageLive(_13);                // scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+        _13 = _1;                        // scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+        StorageLive(_14);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        _14 = _4;                        // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        _15 = _14 as u32 (IntToInt);     // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        _16 = Lt(move _15, const 8_u32); // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        assert(move _16, \"attempt to shift right by `{}`, which would overflow\", _14) -> [success: bb2, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    }\n+\n+    bb2: {\n+        _12 = Shr(move _13, move _14);   // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        StorageDead(_14);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        StorageDead(_13);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        StorageLive(_17);                // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        StorageLive(_18);                // scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+        _18 = _1;                        // scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+        StorageLive(_19);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _19 = _5;                        // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _20 = _19 as u128 (IntToInt);    // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        _21 = Lt(move _20, const 8_u128); // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        assert(move _21, \"attempt to shift right by `{}`, which would overflow\", _19) -> [success: bb3, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    }\n+\n+    bb3: {\n+        _17 = Shr(move _18, move _19);   // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        StorageDead(_19);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        StorageDead(_18);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _6 = [move _7, move _12, move _17]; // scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+        StorageDead(_17);                // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageDead(_12);                // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageDead(_7);                 // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageLive(_22);                // scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+        StorageLive(_23);                // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        StorageLive(_24);                // scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+        _24 = _2;                        // scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+        StorageLive(_25);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        _25 = _3;                        // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        _26 = _25 as u8 (IntToInt);      // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        _27 = Lt(move _26, const 128_u8); // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        assert(move _27, \"attempt to shift left by `{}`, which would overflow\", _25) -> [success: bb4, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    }\n+\n+    bb4: {\n+        _23 = Shl(move _24, move _25);   // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        StorageDead(_25);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        StorageDead(_24);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        StorageLive(_28);                // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        StorageLive(_29);                // scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+        _29 = _2;                        // scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+        StorageLive(_30);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        _30 = _4;                        // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        _31 = _30 as u32 (IntToInt);     // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        _32 = Lt(move _31, const 128_u32); // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        assert(move _32, \"attempt to shift left by `{}`, which would overflow\", _30) -> [success: bb5, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    }\n+\n+    bb5: {\n+        _28 = Shl(move _29, move _30);   // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        StorageDead(_30);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        StorageDead(_29);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        StorageLive(_33);                // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        StorageLive(_34);                // scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+        _34 = _2;                        // scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+        StorageLive(_35);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _35 = _5;                        // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _36 = _35 as u128 (IntToInt);    // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        _37 = Lt(move _36, const 128_u128); // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        assert(move _37, \"attempt to shift left by `{}`, which would overflow\", _35) -> [success: bb6, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    }\n+\n+    bb6: {\n+        _33 = Shl(move _34, move _35);   // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        StorageDead(_35);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        StorageDead(_34);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _22 = [move _23, move _28, move _33]; // scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+        StorageDead(_33);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        StorageDead(_28);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        StorageDead(_23);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        _0 = (move _6, move _22);        // scope 0 at $DIR/shifts.rs:+1:5: +4:6\n+        StorageDead(_22);                // scope 0 at $DIR/shifts.rs:+4:5: +4:6\n+        StorageDead(_6);                 // scope 0 at $DIR/shifts.rs:+4:5: +4:6\n+        return;                          // scope 0 at $DIR/shifts.rs:+5:2: +5:2\n+    }\n+\n+    bb7 (cleanup): {\n+        resume;                          // scope 0 at $DIR/shifts.rs:+0:1: +5:2\n+    }\n+}"}, {"sha": "04da2d20d242fab460c7537a2c28532c207635d0", "filename": "tests/mir-opt/building/shifts.shift_unsigned.built.after.mir", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/7afed9274976b6dc427c56b931cffcc1949f52cd/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_unsigned.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7afed9274976b6dc427c56b931cffcc1949f52cd/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_unsigned.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_unsigned.built.after.mir?ref=7afed9274976b6dc427c56b931cffcc1949f52cd", "patch": "@@ -0,0 +1,135 @@\n+// MIR for `shift_unsigned` after built\n+\n+fn shift_unsigned(_1: u8, _2: i128, _3: u8, _4: u32, _5: u128) -> ([u8; 3], [i128; 3]) {\n+    debug small => _1;                   // in scope 0 at $DIR/shifts.rs:+0:19: +0:24\n+    debug big => _2;                     // in scope 0 at $DIR/shifts.rs:+0:30: +0:33\n+    debug a => _3;                       // in scope 0 at $DIR/shifts.rs:+0:41: +0:42\n+    debug b => _4;                       // in scope 0 at $DIR/shifts.rs:+0:48: +0:49\n+    debug c => _5;                       // in scope 0 at $DIR/shifts.rs:+0:56: +0:57\n+    let mut _0: ([u8; 3], [i128; 3]);    // return place in scope 0 at $DIR/shifts.rs:+0:68: +0:88\n+    let mut _6: [u8; 3];                 // in scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+    let mut _7: u8;                      // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _8: u8;                      // in scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+    let mut _9: u8;                      // in scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+    let mut _10: bool;                   // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _11: u8;                     // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _12: u8;                     // in scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+    let mut _13: u32;                    // in scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+    let mut _14: bool;                   // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _15: u8;                     // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _16: u8;                     // in scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+    let mut _17: u128;                   // in scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+    let mut _18: bool;                   // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _19: [i128; 3];              // in scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+    let mut _20: i128;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _21: i128;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+    let mut _22: u8;                     // in scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+    let mut _23: bool;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _24: i128;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _25: i128;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+    let mut _26: u32;                    // in scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+    let mut _27: bool;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _28: i128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    let mut _29: i128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+    let mut _30: u128;                   // in scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+    let mut _31: bool;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+\n+    bb0: {\n+        StorageLive(_6);                 // scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+        StorageLive(_7);                 // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        StorageLive(_8);                 // scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+        _8 = _1;                         // scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+        StorageLive(_9);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        _9 = _3;                         // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        _10 = Lt(_9, const 8_u8);        // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        assert(move _10, \"attempt to shift right by `{}`, which would overflow\", _9) -> [success: bb1, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    }\n+\n+    bb1: {\n+        _7 = Shr(move _8, move _9);      // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        StorageDead(_9);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        StorageDead(_8);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        StorageLive(_11);                // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        StorageLive(_12);                // scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+        _12 = _1;                        // scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+        StorageLive(_13);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        _13 = _4;                        // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        _14 = Lt(_13, const 8_u32);      // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        assert(move _14, \"attempt to shift right by `{}`, which would overflow\", _13) -> [success: bb2, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    }\n+\n+    bb2: {\n+        _11 = Shr(move _12, move _13);   // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        StorageDead(_13);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        StorageDead(_12);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        StorageLive(_15);                // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        StorageLive(_16);                // scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+        _16 = _1;                        // scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+        StorageLive(_17);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _17 = _5;                        // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _18 = Lt(_17, const 8_u128);     // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        assert(move _18, \"attempt to shift right by `{}`, which would overflow\", _17) -> [success: bb3, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    }\n+\n+    bb3: {\n+        _15 = Shr(move _16, move _17);   // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        StorageDead(_17);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        StorageDead(_16);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _6 = [move _7, move _11, move _15]; // scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+        StorageDead(_15);                // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageDead(_11);                // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageDead(_7);                 // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageLive(_19);                // scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+        StorageLive(_20);                // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        StorageLive(_21);                // scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+        _21 = _2;                        // scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+        StorageLive(_22);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        _22 = _3;                        // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        _23 = Lt(_22, const 128_u8);     // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        assert(move _23, \"attempt to shift left by `{}`, which would overflow\", _22) -> [success: bb4, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    }\n+\n+    bb4: {\n+        _20 = Shl(move _21, move _22);   // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        StorageDead(_22);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        StorageDead(_21);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        StorageLive(_24);                // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        StorageLive(_25);                // scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+        _25 = _2;                        // scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+        StorageLive(_26);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        _26 = _4;                        // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        _27 = Lt(_26, const 128_u32);    // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        assert(move _27, \"attempt to shift left by `{}`, which would overflow\", _26) -> [success: bb5, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    }\n+\n+    bb5: {\n+        _24 = Shl(move _25, move _26);   // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        StorageDead(_26);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        StorageDead(_25);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        StorageLive(_28);                // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        StorageLive(_29);                // scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+        _29 = _2;                        // scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+        StorageLive(_30);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _30 = _5;                        // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _31 = Lt(_30, const 128_u128);   // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        assert(move _31, \"attempt to shift left by `{}`, which would overflow\", _30) -> [success: bb6, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    }\n+\n+    bb6: {\n+        _28 = Shl(move _29, move _30);   // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        StorageDead(_30);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        StorageDead(_29);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _19 = [move _20, move _24, move _28]; // scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+        StorageDead(_28);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        StorageDead(_24);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        StorageDead(_20);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        _0 = (move _6, move _19);        // scope 0 at $DIR/shifts.rs:+1:5: +4:6\n+        StorageDead(_19);                // scope 0 at $DIR/shifts.rs:+4:5: +4:6\n+        StorageDead(_6);                 // scope 0 at $DIR/shifts.rs:+4:5: +4:6\n+        return;                          // scope 0 at $DIR/shifts.rs:+5:2: +5:2\n+    }\n+\n+    bb7 (cleanup): {\n+        resume;                          // scope 0 at $DIR/shifts.rs:+0:1: +5:2\n+    }\n+}"}, {"sha": "b377a65b96418f7af20a4f182832246a640e7c73", "filename": "tests/mir-opt/issue_101973.inner.ConstProp.diff", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7afed9274976b6dc427c56b931cffcc1949f52cd/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7afed9274976b6dc427c56b931cffcc1949f52cd/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff?ref=7afed9274976b6dc427c56b931cffcc1949f52cd", "patch": "@@ -12,9 +12,9 @@\n       let mut _7: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n       let mut _8: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       let mut _9: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:33: +1:39\n-      let mut _10: i32;                    // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+      let mut _10: u32;                    // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       let mut _11: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-      let mut _12: i32;                    // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+      let mut _12: u32;                    // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       let mut _13: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       scope 1 (inlined imm8) {             // at $DIR/issue_101973.rs:14:5: 14:17\n           debug x => _1;                   // in scope 1 at $DIR/issue_101973.rs:5:13: 5:14\n@@ -43,24 +43,24 @@\n           StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n           StorageLive(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n           StorageLive(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n--         _10 = BitAnd(const 8_i32, const -32_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n--         _11 = Ne(move _10, const 0_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n--         assert(!move _11, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-+         _10 = const 0_i32;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-+         _11 = const false;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-+         assert(!const false, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         _10 = const 8_i32 as u32 (IntToInt); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         _11 = Lt(move _10, const 32_u32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         assert(move _11, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         _10 = const 8_u32;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         _11 = const true;                // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         assert(const true, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       }\n   \n       bb1: {\n           _8 = Shr(_1, const 8_i32);       // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n           _7 = BitAnd(move _8, const 15_u32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n           StorageDead(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:51: +1:52\n--         _12 = BitAnd(const 1_i32, const -32_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n--         _13 = Ne(move _12, const 0_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n--         assert(!move _13, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-+         _12 = const 0_i32;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-+         _13 = const false;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-+         assert(!const false, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         _12 = const 1_i32 as u32 (IntToInt); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         _13 = Lt(move _12, const 32_u32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         assert(move _13, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         _12 = const 1_u32;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         _13 = const true;                // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         assert(const true, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       }\n   \n       bb2: {"}]}