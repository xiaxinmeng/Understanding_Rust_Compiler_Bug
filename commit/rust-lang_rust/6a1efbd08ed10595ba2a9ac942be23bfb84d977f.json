{"sha": "6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMWVmYmQwOGVkMTA1OTViYTJhOWFjOTQyYmUyM2JmYjg0ZDk3N2Y=", "commit": {"author": {"name": "Chris Stankus", "email": "cdstankus@gmail.com", "date": "2016-08-17T17:31:20Z"}, "committer": {"name": "Chris Stankus", "email": "cdstankus@gmail.com", "date": "2016-08-17T17:31:20Z"}, "message": "Merge branch 'master' into E0403-update-error-format", "tree": {"sha": "cf4cc64cb3418641271355aaa704bf57816af8c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf4cc64cb3418641271355aaa704bf57816af8c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "html_url": "https://github.com/rust-lang/rust/commit/6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/comments", "author": {"login": "circuitfox", "id": 6395282, "node_id": "MDQ6VXNlcjYzOTUyODI=", "avatar_url": "https://avatars.githubusercontent.com/u/6395282?v=4", "gravatar_id": "", "url": "https://api.github.com/users/circuitfox", "html_url": "https://github.com/circuitfox", "followers_url": "https://api.github.com/users/circuitfox/followers", "following_url": "https://api.github.com/users/circuitfox/following{/other_user}", "gists_url": "https://api.github.com/users/circuitfox/gists{/gist_id}", "starred_url": "https://api.github.com/users/circuitfox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/circuitfox/subscriptions", "organizations_url": "https://api.github.com/users/circuitfox/orgs", "repos_url": "https://api.github.com/users/circuitfox/repos", "events_url": "https://api.github.com/users/circuitfox/events{/privacy}", "received_events_url": "https://api.github.com/users/circuitfox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "circuitfox", "id": 6395282, "node_id": "MDQ6VXNlcjYzOTUyODI=", "avatar_url": "https://avatars.githubusercontent.com/u/6395282?v=4", "gravatar_id": "", "url": "https://api.github.com/users/circuitfox", "html_url": "https://github.com/circuitfox", "followers_url": "https://api.github.com/users/circuitfox/followers", "following_url": "https://api.github.com/users/circuitfox/following{/other_user}", "gists_url": "https://api.github.com/users/circuitfox/gists{/gist_id}", "starred_url": "https://api.github.com/users/circuitfox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/circuitfox/subscriptions", "organizations_url": "https://api.github.com/users/circuitfox/orgs", "repos_url": "https://api.github.com/users/circuitfox/repos", "events_url": "https://api.github.com/users/circuitfox/events{/privacy}", "received_events_url": "https://api.github.com/users/circuitfox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0ff2d32c89c2bdec65f55c8a82eb92bd562d231", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0ff2d32c89c2bdec65f55c8a82eb92bd562d231", "html_url": "https://github.com/rust-lang/rust/commit/f0ff2d32c89c2bdec65f55c8a82eb92bd562d231"}, {"sha": "76fa5875c68246384c5057179927cbfdea0cc822", "url": "https://api.github.com/repos/rust-lang/rust/commits/76fa5875c68246384c5057179927cbfdea0cc822", "html_url": "https://github.com/rust-lang/rust/commit/76fa5875c68246384c5057179927cbfdea0cc822"}], "stats": {"total": 8718, "additions": 4440, "deletions": 4278}, "files": [{"sha": "5ff6d7a89dbe0a4bdb2e91f8aa1684c08ac8305b", "filename": "mk/crates.mk", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -60,7 +60,7 @@ RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_\n                 rustc_data_structures rustc_platform_intrinsics rustc_errors \\\n                 rustc_plugin rustc_metadata rustc_passes rustc_save_analysis \\\n                 rustc_const_eval rustc_const_math rustc_incremental\n-HOST_CRATES := syntax syntax_ext syntax_pos $(RUSTC_CRATES) rustdoc fmt_macros \\\n+HOST_CRATES := syntax syntax_ext proc_macro syntax_pos $(RUSTC_CRATES) rustdoc fmt_macros \\\n \t\tflate arena graphviz rbml log serialize\n TOOLS := compiletest rustdoc rustc rustbook error_index_generator\n \n@@ -100,6 +100,7 @@ DEPS_test := std getopts term native:rust_test_helpers\n \n DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos\n DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros\n+DEPS_proc_macro := syntax syntax_pos rustc_plugin log\n DEPS_syntax_pos := serialize\n \n DEPS_rustc_const_math := std syntax log serialize\n@@ -114,8 +115,9 @@ DEPS_rustc_borrowck := rustc log graphviz syntax syntax_pos rustc_errors rustc_m\n DEPS_rustc_data_structures := std log serialize\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\\n-\t             rustc_trans rustc_privacy rustc_lint rustc_plugin \\\n-                     rustc_metadata syntax_ext rustc_passes rustc_save_analysis rustc_const_eval \\\n+                     rustc_trans rustc_privacy rustc_lint rustc_plugin \\\n+                     rustc_metadata syntax_ext proc_macro \\\n+                     rustc_passes rustc_save_analysis rustc_const_eval \\\n                      rustc_incremental syntax_pos rustc_errors\n DEPS_rustc_errors := log libc serialize syntax_pos\n DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval"}, {"sha": "3aefcc7d4cfa4cc76451af203b7a0f60b40c6e4d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -1453,10 +1453,11 @@ impl<T> IntoIterator for Vec<T> {\n             } else {\n                 begin.offset(self.len() as isize) as *const T\n             };\n-            let buf = ptr::read(&self.buf);\n+            let cap = self.buf.cap();\n             mem::forget(self);\n             IntoIter {\n-                _buf: buf,\n+                buf: Shared::new(begin),\n+                cap: cap,\n                 ptr: begin,\n                 end: end,\n             }\n@@ -1708,8 +1709,9 @@ impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n /// [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    _buf: RawVec<T>,\n-    ptr: *mut T,\n+    buf: Shared<T>,\n+    cap: usize,\n+    ptr: *const T,\n     end: *const T,\n }\n \n@@ -1750,7 +1752,7 @@ impl<T> IntoIter<T> {\n     #[unstable(feature = \"vec_into_iter_as_slice\", issue = \"35601\")]\n     pub fn as_mut_slice(&self) -> &mut [T] {\n         unsafe {\n-            slice::from_raw_parts_mut(self.ptr, self.len())\n+            slice::from_raw_parts_mut(self.ptr as *mut T, self.len())\n         }\n     }\n }\n@@ -1846,9 +1848,10 @@ impl<T> Drop for IntoIter<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         // destroy the remaining elements\n-        for _x in self {}\n+        for _x in self.by_ref() {}\n \n         // RawVec handles deallocation\n+        let _ = unsafe { RawVec::from_raw_parts(*self.buf, self.cap) };\n     }\n }\n "}, {"sha": "5b341ab62d097dd3de59d4ed5150a93e93df8e2b", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -645,6 +645,24 @@ fn test_iter_size_hints() {\n     assert_eq!(xs.iter_mut().size_hint(), (5, Some(5)));\n }\n \n+#[test]\n+fn test_iter_as_slice() {\n+    let xs = [1, 2, 5, 10, 11];\n+    let mut iter = xs.iter();\n+    assert_eq!(iter.as_slice(), &[1, 2, 5, 10, 11]);\n+    iter.next();\n+    assert_eq!(iter.as_slice(), &[2, 5, 10, 11]);\n+}\n+\n+#[test]\n+fn test_iter_as_ref() {\n+    let xs = [1, 2, 5, 10, 11];\n+    let mut iter = xs.iter();\n+    assert_eq!(iter.as_ref(), &[1, 2, 5, 10, 11]);\n+    iter.next();\n+    assert_eq!(iter.as_ref(), &[2, 5, 10, 11]);\n+}\n+\n #[test]\n fn test_iter_clone() {\n     let xs = [1, 2, 5];"}, {"sha": "537fabf8ab69bb14391074ad9dacea5bd1fb2318", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -11,7 +11,7 @@\n use std::borrow::Cow;\n use std::iter::{FromIterator, repeat};\n use std::mem::size_of;\n-use std::vec::Drain;\n+use std::vec::{Drain, IntoIter};\n \n use test::Bencher;\n \n@@ -537,6 +537,7 @@ fn test_cow_from() {\n #[allow(dead_code)]\n fn assert_covariance() {\n     fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n+    fn into_iter<'new>(i: IntoIter<&'static str>) -> IntoIter<&'new str> { i }\n }\n \n #[bench]"}, {"sha": "3a820a14f1214aa8424a0222cf6b3885c6f3163f", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -37,6 +37,7 @@ use clone::Clone;\n use cmp::{Ordering, PartialEq, PartialOrd, Eq, Ord};\n use cmp::Ordering::{Less, Equal, Greater};\n use cmp;\n+use convert::AsRef;\n use default::Default;\n use fmt;\n use intrinsics::assume;\n@@ -996,6 +997,13 @@ impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, _marker: self._marker } }\n }\n \n+#[stable(feature = \"slice_iter_as_ref\", since = \"1.12.0\")]\n+impl<'a, T> AsRef<[T]> for Iter<'a, T> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n /// Mutable slice iterator.\n ///\n /// This struct is created by the [`iter_mut`] method on [slices]."}, {"sha": "99fb1d65cda909624aadce2094c1ec7fffc78d09", "filename": "src/libproc_macro/Cargo.toml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2FCargo.toml?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,15 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"proc_macro\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"proc_macro\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+rustc_plugin = { path = \"../librustc_plugin\" }\n+syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "7b7590b863b71aa5e5eba1e63d13a5f707dea352", "filename": "src/libproc_macro/build.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibproc_macro%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibproc_macro%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbuild.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate syntax;\n+extern crate syntax_pos;\n+\n+use syntax::ast::Ident;\n+use syntax::codemap::DUMMY_SP;\n+use syntax::parse::token::{self, Token, keywords, str_to_ident};\n+use syntax::tokenstream::{self, TokenTree, TokenStream};\n+use std::rc::Rc;\n+\n+/// A wrapper around `TokenStream::concat` to avoid extra namespace specification and\n+/// provide TokenStream concatenation as a generic operator.\n+pub fn concat(ts1: TokenStream, ts2: TokenStream) -> TokenStream {\n+    TokenStream::concat(ts1, ts2)\n+}\n+\n+/// Checks if two identifiers have the same name, disregarding context. This allows us to\n+/// fake 'reserved' keywords.\n+// FIXME We really want `free-identifier-=?` (a la Dybvig 1993). von Tander 2007 is\n+// probably the easiest way to do that.\n+pub fn ident_eq(tident: &TokenTree, id: Ident) -> bool {\n+    let tid = match *tident {\n+        TokenTree::Token(_, Token::Ident(ref id)) => id,\n+        _ => {\n+            return false;\n+        }\n+    };\n+\n+    tid.name == id.name\n+}\n+\n+// ____________________________________________________________________________________________\n+// Conversion operators\n+\n+/// Convert a `&str` into a Token.\n+pub fn str_to_token_ident(s: &str) -> Token {\n+    Token::Ident(str_to_ident(s))\n+}\n+\n+/// Converts a keyword (from `syntax::parse::token::keywords`) into a Token that\n+/// corresponds to it.\n+pub fn keyword_to_token_ident(kw: keywords::Keyword) -> Token {\n+    Token::Ident(str_to_ident(&kw.name().as_str()[..]))\n+}\n+\n+// ____________________________________________________________________________________________\n+// Build Procedures\n+\n+/// Generically takes a `ts` and delimiter and returns `ts` delimited by the specified\n+/// delimiter.\n+pub fn build_delimited(ts: TokenStream, delim: token::DelimToken) -> TokenStream {\n+    let tts = ts.to_tts();\n+    TokenStream::from_tts(vec![TokenTree::Delimited(DUMMY_SP,\n+                                                    Rc::new(tokenstream::Delimited {\n+                                                        delim: delim,\n+                                                        open_span: DUMMY_SP,\n+                                                        tts: tts,\n+                                                        close_span: DUMMY_SP,\n+                                                    }))])\n+}\n+\n+/// Takes `ts` and returns `[ts]`.\n+pub fn build_bracket_delimited(ts: TokenStream) -> TokenStream {\n+    build_delimited(ts, token::DelimToken::Bracket)\n+}\n+\n+/// Takes `ts` and returns `{ts}`.\n+pub fn build_brace_delimited(ts: TokenStream) -> TokenStream {\n+    build_delimited(ts, token::DelimToken::Brace)\n+}\n+\n+/// Takes `ts` and returns `(ts)`.\n+pub fn build_paren_delimited(ts: TokenStream) -> TokenStream {\n+    build_delimited(ts, token::DelimToken::Paren)\n+}\n+\n+/// Constructs `()`.\n+pub fn build_empty_args() -> TokenStream {\n+    build_paren_delimited(TokenStream::mk_empty())\n+}"}, {"sha": "9e25cb88e015c8200407ed03c5e53d02566aee06", "filename": "src/libproc_macro/lib.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Proc_Macro\n+//!\n+//! A library for procedural macro writers.\n+//!\n+//! ## Usage\n+//! This package provides the `qquote!` macro for syntax creation, and the prelude\n+//! (at libproc_macro::prelude) provides a number of operations:\n+//! - `concat`, for concatenating two TokenStreams.\n+//! - `ident_eq`, for checking if two identifiers are equal regardless of syntax context.\n+//! - `str_to_token_ident`, for converting an `&str` into a Token.\n+//! - `keyword_to_token_delim`, for converting a `parse::token::keywords::Keyword` into a\n+//!    Token.\n+//! - `build_delimited`, for creating a new TokenStream from an existing one and a delimiter\n+//!    by wrapping the TokenStream in the delimiter.\n+//! - `build_bracket_delimited`, `build_brace_delimited`, and `build_paren_delimited`, for\n+//!    easing the above.\n+//! - `build_empty_args`, which returns a TokenStream containing `()`.\n+//! - `lex`, which takes an `&str` and returns the TokenStream it represents.\n+//!\n+//! The `qquote!` macro also imports `syntax::ext::proc_macro_shim::prelude::*`, so you\n+//! will need to `extern crate syntax` for usage. (This is a temporary solution until more\n+//! of the external API in libproc_macro is stabilized to support the token construction\n+//! operations that the qausiquoter relies on.) The shim file also provides additional\n+//! operations, such as `build_block_emitter` (as used in the `cond` example below).\n+//!\n+//! ## TokenStreams\n+//!\n+//! TokenStreams serve as the basis of the macro system. They are, in essence, vectors of\n+//! TokenTrees, where indexing treats delimited values as a single term. That is, the term\n+//! `even(a+c) && even(b)` will be indexibly encoded as `even | (a+c) | even | (b)` where,\n+//! in reality, `(a+c)` is actually a decorated pointer to `a | + | c`.\n+//!\n+//! If a user has a TokenStream that is a single, delimited value, they can use\n+//! `maybe_delimited` to destruct it and receive the internal vector as a new TokenStream\n+//! as:\n+//! ```\n+//! `(a+c)`.maybe_delimited() ~> Some(a | + | c)`\n+//! ```\n+//!\n+//! Check the TokenStream documentation for more information; the structure also provides\n+//! cheap concatenation and slicing.\n+//!\n+//! ## Quasiquotation\n+//!\n+//! The quasiquoter creates output that, when run, constructs the tokenstream specified as\n+//! input. For example, `qquote!(5 + 5)` will produce a program, that, when run, will\n+//! construct the TokenStream `5 | + | 5`.\n+//!\n+//! ### Unquoting\n+//!\n+//! Unquoting is currently done as `unquote`, and works by taking the single next\n+//! TokenTree in the TokenStream as the unquoted term. Ergonomically, `unquote(foo)` works\n+//! fine, but `unquote foo` is also supported.\n+//!\n+//! A simple example might be:\n+//!\n+//!```\n+//!fn double(tmp: TokenStream) -> TokenStream {\n+//!    qquote!(unquote(tmp) * 2)\n+//!}\n+//!```\n+//!\n+//! ### Large Example: Implementing Scheme's `cond`\n+//!\n+//! Below is the full implementation of Scheme's `cond` operator.\n+//!\n+//! ```\n+//! fn cond_rec(input: TokenStream) -> TokenStream {\n+//!   if input.is_empty() { return quote!(); }\n+//!\n+//!   let next = input.slice(0..1);\n+//!   let rest = input.slice_from(1..);\n+//!\n+//!   let clause : TokenStream = match next.maybe_delimited() {\n+//!     Some(ts) => ts,\n+//!     _ => panic!(\"Invalid input\"),\n+//!   };\n+//!\n+//!   // clause is ([test]) [rhs]\n+//!   if clause.len() < 2 { panic!(\"Invalid macro usage in cond: {:?}\", clause) }\n+//!\n+//!   let test: TokenStream = clause.slice(0..1);\n+//!   let rhs: TokenStream = clause.slice_from(1..);\n+//!\n+//!   if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+//!     quote!({unquote(rhs)})\n+//!   } else {\n+//!     quote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })\n+//!   }\n+//! }\n+//! ```\n+//!\n+\n+#![crate_name = \"proc_macro\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![feature(plugin_registrar)]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+#![feature(staged_api)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_plugin;\n+extern crate syntax;\n+extern crate syntax_pos;\n+#[macro_use] extern crate log;\n+\n+mod qquote;\n+pub mod build;\n+pub mod parse;\n+pub mod prelude;\n+use qquote::qquote;\n+\n+use rustc_plugin::Registry;\n+\n+// ____________________________________________________________________________________________\n+// Main macro definition\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_macro(\"qquote\", qquote);\n+}"}, {"sha": "9af8a68cdcf497887b75e09a94f5917215d33bee", "filename": "src/libproc_macro/parse.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibproc_macro%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibproc_macro%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fparse.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Parsing utilities for writing procedural macros.\n+\n+extern crate syntax;\n+\n+use syntax::parse::{ParseSess, filemap_to_tts};\n+use syntax::tokenstream::TokenStream;\n+\n+/// Map a string to tts, using a made-up filename. For example, `lex(15)` will return a\n+/// TokenStream containing the literal 15.\n+pub fn lex(source_str: &str) -> TokenStream {\n+    let ps = ParseSess::new();\n+    TokenStream::from_tts(filemap_to_tts(&ps,\n+                                         ps.codemap().new_filemap(\"procmacro_lex\".to_string(),\n+                                                                  None,\n+                                                                  source_str.to_owned())))\n+}"}, {"sha": "4c0c8ba6c6684b1c375236a4e13fefa2a5cbcfab", "filename": "src/libproc_macro/prelude.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibproc_macro%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibproc_macro%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fprelude.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use build::*;\n+pub use parse::*;"}, {"sha": "67d0c77b00d83c6404df847ae57b1c6ff5b9d6c3", "filename": "src/libproc_macro/qquote.rs", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibproc_macro%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibproc_macro%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fqquote.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,470 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Quasiquoter\n+//! This file contains the implementation internals of the quasiquoter provided by `quote!`.\n+//!\n+//! ## Ouput\n+//! The quasiquoter produces output of the form:\n+//! let tmp0 = ...;\n+//! let tmp1 = ...;\n+//! ...\n+//! concat(from_tokens(...), concat(...))\n+//!\n+//! To the more explicit, the quasiquoter produces a series of bindings that each\n+//! construct TokenStreams via constructing Tokens and using `from_tokens`, ultimately\n+//! invoking `concat` on these bindings (and inlined expressions) to construct a\n+//! TokenStream that resembles the output syntax.\n+//!\n+\n+extern crate rustc_plugin;\n+extern crate syntax;\n+extern crate syntax_pos;\n+\n+use build::*;\n+use parse::lex;\n+use qquote::int_build::*;\n+\n+use syntax::ast::Ident;\n+use syntax::codemap::Span;\n+use syntax::ext::base::*;\n+use syntax::ext::base;\n+use syntax::ext::proc_macro_shim::build_block_emitter;\n+use syntax::parse::token::{self, Token, gensym_ident, str_to_ident};\n+use syntax::print::pprust;\n+use syntax::tokenstream::{TokenTree, TokenStream};\n+\n+// ____________________________________________________________________________________________\n+// Main definition\n+/// The user should use the macro, not this procedure.\n+pub fn qquote<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n+                   -> Box<base::MacResult + 'cx> {\n+\n+    debug!(\"\\nTTs in: {:?}\\n\", pprust::tts_to_string(&tts[..]));\n+    let output = qquoter(cx, TokenStream::from_tts(tts.clone().to_owned()));\n+    debug!(\"\\nQQ out: {}\\n\", pprust::tts_to_string(&output.to_tts()[..]));\n+    let imports = concat(lex(\"use syntax::ext::proc_macro_shim::prelude::*;\"),\n+                         lex(\"use proc_macro::prelude::*;\"));\n+    build_block_emitter(cx, sp, build_brace_delimited(concat(imports, output)))\n+}\n+\n+// ____________________________________________________________________________________________\n+// Datatype Definitions\n+\n+#[derive(Debug)]\n+struct QDelimited {\n+    delim: token::DelimToken,\n+    open_span: Span,\n+    tts: Vec<QTT>,\n+    close_span: Span,\n+}\n+\n+#[derive(Debug)]\n+enum QTT {\n+    TT(TokenTree),\n+    QDL(QDelimited),\n+    QIdent(TokenTree),\n+}\n+\n+type Bindings = Vec<(Ident, TokenStream)>;\n+\n+// ____________________________________________________________________________________________\n+// Quasiquoter Algorithm\n+// This algorithm works as follows:\n+// Input: TokenStream\n+// 1. Walk the TokenStream, gathering up the unquoted expressions and marking them separately.\n+// 2. Hoist any unquoted term into its own let-binding via a gensym'd identifier\n+// 3. Convert the body from a `complex expression` into a simplified one via `convert_complex_tts\n+// 4. Stitch everything together with `concat`.\n+fn qquoter<'cx>(cx: &'cx mut ExtCtxt, ts: TokenStream) -> TokenStream {\n+    if ts.is_empty() {\n+        return lex(\"TokenStream::mk_empty()\");\n+    }\n+    let qq_res = qquote_iter(cx, 0, ts);\n+    let mut bindings = qq_res.0;\n+    let body = qq_res.1;\n+    let mut cct_res = convert_complex_tts(cx, body);\n+\n+    bindings.append(&mut cct_res.0);\n+\n+    if bindings.is_empty() {\n+        cct_res.1\n+    } else {\n+        debug!(\"BINDINGS\");\n+        for b in bindings.clone() {\n+            debug!(\"{:?} = {}\", b.0, pprust::tts_to_string(&b.1.to_tts()[..]));\n+        }\n+        TokenStream::concat(unravel(bindings), cct_res.1)\n+   }\n+}\n+\n+fn qquote_iter<'cx>(cx: &'cx mut ExtCtxt, depth: i64, ts: TokenStream) -> (Bindings, Vec<QTT>) {\n+    let mut depth = depth;\n+    let mut bindings: Bindings = Vec::new();\n+    let mut output: Vec<QTT> = Vec::new();\n+\n+    let mut iter = ts.iter();\n+\n+    loop {\n+        let next = iter.next();\n+        if next.is_none() {\n+            break;\n+        }\n+        let next = next.unwrap().clone();\n+        match next {\n+            TokenTree::Token(_, Token::Ident(id)) if is_unquote(id) => {\n+                if depth == 0 {\n+                    let exp = iter.next();\n+                    if exp.is_none() {\n+                        break;\n+                    } // produce an error or something first\n+                    let exp = vec![exp.unwrap().to_owned()];\n+                    debug!(\"RHS: {:?}\", exp.clone());\n+                    let new_id = gensym_ident(\"tmp\");\n+                    debug!(\"RHS TS: {:?}\", TokenStream::from_tts(exp.clone()));\n+                    debug!(\"RHS TS TT: {:?}\", TokenStream::from_tts(exp.clone()).to_vec());\n+                    bindings.push((new_id, TokenStream::from_tts(exp)));\n+                    debug!(\"BINDINGS\");\n+                    for b in bindings.clone() {\n+                        debug!(\"{:?} = {}\", b.0, pprust::tts_to_string(&b.1.to_tts()[..]));\n+                    }\n+                    output.push(QTT::QIdent(as_tt(Token::Ident(new_id.clone()))));\n+                } else {\n+                    depth = depth - 1;\n+                    output.push(QTT::TT(next.clone()));\n+                }\n+            }\n+            TokenTree::Token(_, Token::Ident(id)) if is_qquote(id) => {\n+                depth = depth + 1;\n+            }\n+            TokenTree::Delimited(_, ref dl) => {\n+                let br = qquote_iter(cx, depth, TokenStream::from_tts(dl.tts.clone().to_owned()));\n+                let mut bind_ = br.0;\n+                let res_ = br.1;\n+                bindings.append(&mut bind_);\n+\n+                let new_dl = QDelimited {\n+                    delim: dl.delim,\n+                    open_span: dl.open_span,\n+                    tts: res_,\n+                    close_span: dl.close_span,\n+                };\n+\n+                output.push(QTT::QDL(new_dl));\n+            }\n+            t => {\n+                output.push(QTT::TT(t));\n+            }\n+        }\n+    }\n+\n+    (bindings, output)\n+}\n+\n+// ____________________________________________________________________________________________\n+// Turns QQTs into a TokenStream and some Bindings.\n+/// Construct a chain of concatenations.\n+fn unravel_concats(tss: Vec<TokenStream>) -> TokenStream {\n+    let mut pushes: Vec<TokenStream> =\n+        tss.into_iter().filter(|&ref ts| !ts.is_empty()).collect();\n+    let mut output = match pushes.pop() {\n+        Some(ts) => ts,\n+        None => {\n+            return TokenStream::mk_empty();\n+        }\n+    };\n+\n+    while let Some(ts) = pushes.pop() {\n+        output = build_fn_call(str_to_ident(\"concat\"),\n+                               concat(concat(ts,\n+                                             from_tokens(vec![Token::Comma])),\n+                                      output));\n+    }\n+    output\n+}\n+\n+/// This converts the vector of QTTs into a seet of Bindings for construction and the main\n+/// body as a TokenStream.\n+fn convert_complex_tts<'cx>(cx: &'cx mut ExtCtxt, tts: Vec<QTT>) -> (Bindings, TokenStream) {\n+    let mut pushes: Vec<TokenStream> = Vec::new();\n+    let mut bindings: Bindings = Vec::new();\n+\n+    let mut iter = tts.into_iter();\n+\n+    loop {\n+        let next = iter.next();\n+        if next.is_none() {\n+            break;\n+        }\n+        let next = next.unwrap();\n+        match next {\n+            QTT::TT(TokenTree::Token(_, t)) => {\n+                let token_out = emit_token(t);\n+                pushes.push(token_out);\n+            }\n+            // FIXME handle sequence repetition tokens\n+            QTT::QDL(qdl) => {\n+                debug!(\"  QDL: {:?} \", qdl.tts);\n+                let new_id = gensym_ident(\"qdl_tmp\");\n+                let mut cct_rec = convert_complex_tts(cx, qdl.tts);\n+                bindings.append(&mut cct_rec.0);\n+                bindings.push((new_id, cct_rec.1));\n+\n+                let sep = build_delim_tok(qdl.delim);\n+\n+                pushes.push(build_mod_call(vec![str_to_ident(\"proc_macro\"),\n+                                               str_to_ident(\"build\"),\n+                                               str_to_ident(\"build_delimited\")],\n+                                          concat(from_tokens(vec![Token::Ident(new_id)]),\n+                                                 concat(lex(\",\"), sep))));\n+            }\n+            QTT::QIdent(t) => {\n+                pushes.push(TokenStream::from_tts(vec![t]));\n+                pushes.push(TokenStream::mk_empty());\n+            }\n+            _ => panic!(\"Unhandled case!\"),\n+        }\n+\n+    }\n+\n+    (bindings, unravel_concats(pushes))\n+}\n+\n+// ____________________________________________________________________________________________\n+// Utilities\n+\n+/// Unravels Bindings into a TokenStream of `let` declarations.\n+fn unravel(binds: Bindings) -> TokenStream {\n+    let mut output = TokenStream::mk_empty();\n+\n+    for b in binds {\n+        output = concat(output, build_let(b.0, b.1));\n+    }\n+\n+    output\n+}\n+\n+/// Checks if the Ident is `unquote`.\n+fn is_unquote(id: Ident) -> bool {\n+    let qq = str_to_ident(\"unquote\");\n+    id.name == qq.name  // We disregard context; unquote is _reserved_\n+}\n+\n+/// Checks if the Ident is `quote`.\n+fn is_qquote(id: Ident) -> bool {\n+    let qq = str_to_ident(\"qquote\");\n+    id.name == qq.name  // We disregard context; qquote is _reserved_\n+}\n+\n+mod int_build {\n+    extern crate syntax;\n+    extern crate syntax_pos;\n+\n+    use parse::*;\n+    use build::*;\n+\n+    use syntax::ast::{self, Ident};\n+    use syntax::codemap::{DUMMY_SP};\n+    use syntax::parse::token::{self, Token, keywords, str_to_ident};\n+    use syntax::tokenstream::{TokenTree, TokenStream};\n+\n+    // ____________________________________________________________________________________________\n+    // Emitters\n+\n+    pub fn emit_token(t: Token) -> TokenStream {\n+        concat(lex(\"TokenStream::from_tokens\"),\n+               build_paren_delimited(build_vec(build_token_tt(t))))\n+    }\n+\n+    pub fn emit_lit(l: token::Lit, n: Option<ast::Name>) -> TokenStream {\n+        let suf = match n {\n+            Some(n) => format!(\"Some(ast::Name({}))\", n.0),\n+            None => \"None\".to_string(),\n+        };\n+\n+        let lit = match l {\n+            token::Lit::Byte(n) => format!(\"Lit::Byte(token::intern(\\\"{}\\\"))\", n.to_string()),\n+            token::Lit::Char(n) => format!(\"Lit::Char(token::intern(\\\"{}\\\"))\", n.to_string()),\n+            token::Lit::Integer(n) => format!(\"Lit::Integer(token::intern(\\\"{}\\\"))\", n.to_string()),\n+            token::Lit::Float(n) => format!(\"Lit::Float(token::intern(\\\"{}\\\"))\", n.to_string()),\n+            token::Lit::Str_(n) => format!(\"Lit::Str_(token::intern(\\\"{}\\\"))\", n.to_string()),\n+            token::Lit::ByteStr(n) => format!(\"Lit::ByteStr(token::intern(\\\"{}\\\"))\", n.to_string()),\n+            _ => panic!(\"Unsupported literal\"),\n+        };\n+\n+        let res = format!(\"Token::Literal({},{})\", lit, suf);\n+        debug!(\"{}\", res);\n+        lex(&res)\n+    }\n+\n+    // ____________________________________________________________________________________________\n+    // Token Builders\n+\n+    pub fn build_binop_tok(bot: token::BinOpToken) -> TokenStream {\n+        match bot {\n+            token::BinOpToken::Plus => lex(\"Token::BinOp(BinOpToken::Plus)\"),\n+            token::BinOpToken::Minus => lex(\"Token::BinOp(BinOpToken::Minus)\"),\n+            token::BinOpToken::Star => lex(\"Token::BinOp(BinOpToken::Star)\"),\n+            token::BinOpToken::Slash => lex(\"Token::BinOp(BinOpToken::Slash)\"),\n+            token::BinOpToken::Percent => lex(\"Token::BinOp(BinOpToken::Percent)\"),\n+            token::BinOpToken::Caret => lex(\"Token::BinOp(BinOpToken::Caret)\"),\n+            token::BinOpToken::And => lex(\"Token::BinOp(BinOpToken::And)\"),\n+            token::BinOpToken::Or => lex(\"Token::BinOp(BinOpToken::Or)\"),\n+            token::BinOpToken::Shl => lex(\"Token::BinOp(BinOpToken::Shl)\"),\n+            token::BinOpToken::Shr => lex(\"Token::BinOp(BinOpToken::Shr)\"),\n+        }\n+    }\n+\n+    pub fn build_binopeq_tok(bot: token::BinOpToken) -> TokenStream {\n+        match bot {\n+            token::BinOpToken::Plus => lex(\"Token::BinOpEq(BinOpToken::Plus)\"),\n+            token::BinOpToken::Minus => lex(\"Token::BinOpEq(BinOpToken::Minus)\"),\n+            token::BinOpToken::Star => lex(\"Token::BinOpEq(BinOpToken::Star)\"),\n+            token::BinOpToken::Slash => lex(\"Token::BinOpEq(BinOpToken::Slash)\"),\n+            token::BinOpToken::Percent => lex(\"Token::BinOpEq(BinOpToken::Percent)\"),\n+            token::BinOpToken::Caret => lex(\"Token::BinOpEq(BinOpToken::Caret)\"),\n+            token::BinOpToken::And => lex(\"Token::BinOpEq(BinOpToken::And)\"),\n+            token::BinOpToken::Or => lex(\"Token::BinOpEq(BinOpToken::Or)\"),\n+            token::BinOpToken::Shl => lex(\"Token::BinOpEq(BinOpToken::Shl)\"),\n+            token::BinOpToken::Shr => lex(\"Token::BinOpEq(BinOpToken::Shr)\"),\n+        }\n+    }\n+\n+    pub fn build_delim_tok(dt: token::DelimToken) -> TokenStream {\n+        match dt {\n+            token::DelimToken::Paren => lex(\"DelimToken::Paren\"),\n+            token::DelimToken::Bracket => lex(\"DelimToken::Bracket\"),\n+            token::DelimToken::Brace => lex(\"DelimToken::Brace\"),\n+            token::DelimToken::NoDelim => lex(\"DelimToken::NoDelim\"),\n+        }\n+    }\n+\n+    pub fn build_token_tt(t: Token) -> TokenStream {\n+        match t {\n+            Token::Eq => lex(\"Token::Eq\"),\n+            Token::Lt => lex(\"Token::Lt\"),\n+            Token::Le => lex(\"Token::Le\"),\n+            Token::EqEq => lex(\"Token::EqEq\"),\n+            Token::Ne => lex(\"Token::Ne\"),\n+            Token::Ge => lex(\"Token::Ge\"),\n+            Token::Gt => lex(\"Token::Gt\"),\n+            Token::AndAnd => lex(\"Token::AndAnd\"),\n+            Token::OrOr => lex(\"Token::OrOr\"),\n+            Token::Not => lex(\"Token::Not\"),\n+            Token::Tilde => lex(\"Token::Tilde\"),\n+            Token::BinOp(tok) => build_binop_tok(tok),\n+            Token::BinOpEq(tok) => build_binopeq_tok(tok),\n+            Token::At => lex(\"Token::At\"),\n+            Token::Dot => lex(\"Token::Dot\"),\n+            Token::DotDot => lex(\"Token::DotDot\"),\n+            Token::DotDotDot => lex(\"Token::DotDotDot\"),\n+            Token::Comma => lex(\"Token::Comma\"),\n+            Token::Semi => lex(\"Token::Semi\"),\n+            Token::Colon => lex(\"Token::Colon\"),\n+            Token::ModSep => lex(\"Token::ModSep\"),\n+            Token::RArrow => lex(\"Token::RArrow\"),\n+            Token::LArrow => lex(\"Token::LArrow\"),\n+            Token::FatArrow => lex(\"Token::FatArrow\"),\n+            Token::Pound => lex(\"Token::Pound\"),\n+            Token::Dollar => lex(\"Token::Dollar\"),\n+            Token::Question => lex(\"Token::Question\"),\n+            Token::OpenDelim(dt) => {\n+                match dt {\n+                    token::DelimToken::Paren => lex(\"Token::OpenDelim(DelimToken::Paren)\"),\n+                    token::DelimToken::Bracket => lex(\"Token::OpenDelim(DelimToken::Bracket)\"),\n+                    token::DelimToken::Brace => lex(\"Token::OpenDelim(DelimToken::Brace)\"),\n+                    token::DelimToken::NoDelim => lex(\"DelimToken::NoDelim\"),\n+                }\n+            }\n+            Token::CloseDelim(dt) => {\n+                match dt {\n+                    token::DelimToken::Paren => lex(\"Token::CloseDelim(DelimToken::Paren)\"),\n+                    token::DelimToken::Bracket => lex(\"Token::CloseDelim(DelimToken::Bracket)\"),\n+                    token::DelimToken::Brace => lex(\"Token::CloseDelim(DelimToken::Brace)\"),\n+                    token::DelimToken::NoDelim => lex(\"DelimToken::NoDelim\"),\n+                }\n+            }\n+            Token::Underscore => lex(\"_\"),\n+            Token::Literal(lit, sfx) => emit_lit(lit, sfx),\n+            // fix ident expansion information... somehow\n+            Token::Ident(ident) => lex(&format!(\"Token::Ident(str_to_ident(\\\"{}\\\"))\", ident.name)),\n+            Token::Lifetime(ident) => lex(&format!(\"Token::Ident(str_to_ident(\\\"{}\\\"))\",\n+                                                   ident.name)),\n+            _ => panic!(\"Unhandled case!\"),\n+        }\n+    }\n+\n+    // ____________________________________________________________________________________________\n+    // Conversion operators\n+\n+    pub fn as_tt(t: Token) -> TokenTree {\n+        // FIXME do something nicer with the spans\n+        TokenTree::Token(DUMMY_SP, t)\n+    }\n+\n+    // ____________________________________________________________________________________________\n+    // Build Procedures\n+\n+    /// Takes `input` and returns `vec![input]`.\n+    pub fn build_vec(ts: TokenStream) -> TokenStream {\n+        build_mac_call(str_to_ident(\"vec\"), ts)\n+        // tts.clone().to_owned()\n+    }\n+\n+    /// Takes `ident` and `rhs` and produces `let ident = rhs;`.\n+    pub fn build_let(id: Ident, tts: TokenStream) -> TokenStream {\n+        concat(from_tokens(vec![keyword_to_token_ident(keywords::Let),\n+                                Token::Ident(id),\n+                                Token::Eq]),\n+               concat(tts, from_tokens(vec![Token::Semi])))\n+    }\n+\n+    /// Takes `ident ...`, and `args ...` and produces `ident::...(args ...)`.\n+    pub fn build_mod_call(ids: Vec<Ident>, args: TokenStream) -> TokenStream {\n+        let call = from_tokens(intersperse(ids.into_iter().map(|id| Token::Ident(id)).collect(),\n+                                     Token::ModSep));\n+        concat(call, build_paren_delimited(args))\n+    }\n+\n+    /// Takes `ident` and `args ...` and produces `ident(args ...)`.\n+    pub fn build_fn_call(name: Ident, args: TokenStream) -> TokenStream {\n+        concat(from_tokens(vec![Token::Ident(name)]), build_paren_delimited(args))\n+    }\n+\n+    /// Takes `ident` and `args ...` and produces `ident!(args ...)`.\n+    pub fn build_mac_call(name: Ident, args: TokenStream) -> TokenStream {\n+        concat(from_tokens(vec![Token::Ident(name), Token::Not]),\n+               build_paren_delimited(args))\n+    }\n+\n+    // ____________________________________________________________________________________________\n+    // Utilities\n+\n+    /// A wrapper around `TokenStream::from_tokens` to avoid extra namespace specification and\n+    /// provide it as a generic operator.\n+    pub fn from_tokens(tokens: Vec<Token>) -> TokenStream {\n+        TokenStream::from_tokens(tokens)\n+    }\n+\n+    pub fn intersperse<T>(vs: Vec<T>, t: T) -> Vec<T>\n+        where T: Clone\n+    {\n+        if vs.len() < 2 {\n+            return vs;\n+        }\n+        let mut output = vec![vs.get(0).unwrap().to_owned()];\n+\n+        for v in vs.into_iter().skip(1) {\n+            output.push(t.clone());\n+            output.push(v);\n+        }\n+        output\n+    }\n+}"}, {"sha": "d15d51aed09a1049febb903ef1952ee73b56660e", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use ty::subst::ParamSpace;\n use util::nodemap::NodeMap;\n use syntax::ast;\n use hir;\n@@ -31,7 +30,7 @@ pub enum Def {\n     AssociatedTy(DefId /* trait */, DefId),\n     Trait(DefId),\n     PrimTy(hir::PrimTy),\n-    TyParam(ParamSpace, u32, DefId, ast::Name),\n+    TyParam(DefId),\n     Upvar(DefId,        // def id of closed over local\n              ast::NodeId,  // node id of closed over local\n              usize,        // index in the freevars list of the closure\n@@ -122,7 +121,7 @@ impl Def {\n         match *self {\n             Def::Fn(id) | Def::Mod(id) | Def::ForeignMod(id) | Def::Static(id, _) |\n             Def::Variant(_, id) | Def::Enum(id) | Def::TyAlias(id) | Def::AssociatedTy(_, id) |\n-            Def::TyParam(_, _, id, _) | Def::Struct(id) | Def::Trait(id) |\n+            Def::TyParam(id) | Def::Struct(id) | Def::Trait(id) |\n             Def::Method(id) | Def::Const(id) | Def::AssociatedConst(id) |\n             Def::Local(id, _) | Def::Upvar(id, _, _, _) => {\n                 id"}, {"sha": "9a6375719c1bcd406138ce002a37e941c8bdc178", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -82,7 +82,6 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use infer::{self, TypeOrigin};\n use middle::region;\n-use ty::subst;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, ReFree};\n use ty::error::TypeError;\n@@ -1366,10 +1365,10 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 hir::TyPath(ref maybe_qself, ref path) => {\n                     match self.tcx.expect_def(cur_ty.id) {\n                         Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n-                            let generics = self.tcx.lookup_item_type(did).generics;\n+                            let generics = self.tcx.lookup_generics(did);\n \n                             let expected =\n-                                generics.regions.len(subst::TypeSpace) as u32;\n+                                generics.regions.len() as u32;\n                             let lifetimes =\n                                 path.segments.last().unwrap().parameters.lifetimes();\n                             let mut insert = Vec::new();"}, {"sha": "1b65b5dae074850ad2d74951d9102f73849f4921", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 44, "deletions": 89, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -25,9 +25,7 @@ use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::region::CodeExtent;\n use mir::tcx::LvalueTy;\n-use ty::subst;\n-use ty::subst::Substs;\n-use ty::subst::Subst;\n+use ty::subst::{Subst, Substs};\n use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n@@ -1172,15 +1170,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_var(self.next_ty_var_id(false))\n     }\n \n-    pub fn next_ty_var_with_default(&self,\n-                                    default: Option<type_variable::Default<'tcx>>) -> Ty<'tcx> {\n-        let ty_var_id = self.type_variables\n-                            .borrow_mut()\n-                            .new_var(false, default);\n-\n-        self.tcx.mk_var(ty_var_id)\n-    }\n-\n     pub fn next_diverging_ty_var(&self) -> Ty<'tcx> {\n         self.tcx.mk_var(self.next_ty_var_id(true))\n     }\n@@ -1205,89 +1194,55 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         ty::ReVar(self.region_vars.new_region_var(origin))\n     }\n \n-    pub fn region_vars_for_defs(&self,\n-                                span: Span,\n-                                defs: &[ty::RegionParameterDef])\n-                                -> Vec<ty::Region> {\n-        defs.iter()\n-            .map(|d| self.next_region_var(EarlyBoundRegion(span, d.name)))\n-            .collect()\n-    }\n-\n-    // We have to take `&mut Substs` in order to provide the correct substitutions for defaults\n-    // along the way, for this reason we don't return them.\n-    pub fn type_vars_for_defs(&self,\n+    /// Create a region inference variable for the given\n+    /// region parameter definition.\n+    pub fn region_var_for_def(&self,\n                               span: Span,\n-                              space: subst::ParamSpace,\n-                              substs: &mut Substs<'tcx>,\n-                              defs: &[ty::TypeParameterDef<'tcx>]) {\n-\n-        for def in defs.iter() {\n-            let default = def.default.map(|default| {\n-                type_variable::Default {\n-                    ty: default.subst_spanned(self.tcx, substs, Some(span)),\n-                    origin_span: span,\n-                    def_id: def.default_def_id\n-                }\n-            });\n-\n-            let ty_var = self.next_ty_var_with_default(default);\n-            substs.types.push(space, ty_var);\n-        }\n-    }\n-\n-    /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n-    /// type/region parameter to a fresh inference variable.\n-    pub fn fresh_substs_for_generics(&self,\n-                                     span: Span,\n-                                     generics: &ty::Generics<'tcx>)\n-                                     -> &'tcx subst::Substs<'tcx>\n-    {\n-        let type_params = subst::VecPerParamSpace::empty();\n-\n-        let region_params =\n-            generics.regions.map(\n-                |d| self.next_region_var(EarlyBoundRegion(span, d.name)));\n+                              def: &ty::RegionParameterDef)\n+                              -> ty::Region {\n+        self.next_region_var(EarlyBoundRegion(span, def.name))\n+    }\n+\n+    /// Create a type inference variable for the given\n+    /// type parameter definition. The substitutions are\n+    /// for actual parameters that may be referred to by\n+    /// the default of this type parameter, if it exists.\n+    /// E.g. `struct Foo<A, B, C = (A, B)>(...);` when\n+    /// used in a path such as `Foo::<T, U>::new()` will\n+    /// use an inference variable for `C` with `[T, U]`\n+    /// as the substitutions for the default, `(T, U)`.\n+    pub fn type_var_for_def(&self,\n+                            span: Span,\n+                            def: &ty::TypeParameterDef<'tcx>,\n+                            substs: &Substs<'tcx>)\n+                            -> Ty<'tcx> {\n+        let default = def.default.map(|default| {\n+            type_variable::Default {\n+                ty: default.subst_spanned(self.tcx, substs, Some(span)),\n+                origin_span: span,\n+                def_id: def.default_def_id\n+            }\n+        });\n \n-        let mut substs = subst::Substs::new(type_params, region_params);\n \n-        for space in subst::ParamSpace::all().iter() {\n-            self.type_vars_for_defs(\n-                span,\n-                *space,\n-                &mut substs,\n-                generics.types.get_slice(*space));\n-        }\n+        let ty_var_id = self.type_variables\n+                            .borrow_mut()\n+                            .new_var(false, default);\n \n-        self.tcx.mk_substs(substs)\n+        self.tcx.mk_var(ty_var_id)\n     }\n \n-    /// Given a set of generics defined on a trait, returns a substitution mapping each output\n-    /// type/region parameter to a fresh inference variable, and mapping the self type to\n-    /// `self_ty`.\n-    pub fn fresh_substs_for_trait(&self,\n-                                  span: Span,\n-                                  generics: &ty::Generics<'tcx>,\n-                                  self_ty: Ty<'tcx>)\n-                                  -> subst::Substs<'tcx>\n-    {\n-\n-        assert!(generics.types.len(subst::SelfSpace) == 1);\n-        assert!(generics.types.len(subst::FnSpace) == 0);\n-        assert!(generics.regions.len(subst::SelfSpace) == 0);\n-        assert!(generics.regions.len(subst::FnSpace) == 0);\n-\n-        let type_params = Vec::new();\n-\n-        let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n-        let regions = self.region_vars_for_defs(span, region_param_defs);\n-\n-        let mut substs = subst::Substs::new_trait(type_params, regions, self_ty);\n-\n-        let type_parameter_defs = generics.types.get_slice(subst::TypeSpace);\n-        self.type_vars_for_defs(span, subst::TypeSpace, &mut substs, type_parameter_defs);\n-\n-        return substs;\n+    /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n+    /// type/region parameter to a fresh inference variable.\n+    pub fn fresh_substs_for_item(&self,\n+                                 span: Span,\n+                                 def_id: DefId)\n+                                 -> &'tcx Substs<'tcx> {\n+        Substs::for_item(self.tcx, def_id, |def, _| {\n+            self.region_var_for_def(span, def)\n+        }, |def, substs| {\n+            self.type_var_for_def(span, def, substs)\n+        })\n     }\n \n     pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region {"}, {"sha": "abb22783ddc84a72badc40212a5c69e24f8dd16d", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -154,14 +154,16 @@ pub trait CrateStore<'tcx> {\n     fn item_variances(&self, def: DefId) -> ty::ItemVariances;\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                     -> ty::TypeScheme<'tcx>;\n+                     -> Ty<'tcx>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n     fn item_name(&self, def: DefId) -> ast::Name;\n     fn opt_item_name(&self, def: DefId) -> Option<ast::Name>;\n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx>;\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx>;\n+    fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                         -> &'tcx ty::Generics<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n@@ -187,8 +189,7 @@ pub trait CrateStore<'tcx> {\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n-    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                         -> Option<DefId>;\n+    fn trait_of_item(&self, def_id: DefId) -> Option<DefId>;\n     fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<ty::ImplOrTraitItem<'tcx>>;\n \n@@ -334,7 +335,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn item_variances(&self, def: DefId) -> ty::ItemVariances { bug!(\"item_variances\") }\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                     -> ty::TypeScheme<'tcx> { bug!(\"item_type\") }\n+                     -> Ty<'tcx> { bug!(\"item_type\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")\n     }\n@@ -344,6 +345,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                            -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n+    fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                         -> &'tcx ty::Generics<'tcx> { bug!(\"item_generics\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n         { bug!(\"trait_def\") }\n@@ -379,8 +382,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n-    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                         -> Option<DefId> { bug!(\"trait_of_item\") }\n+    fn trait_of_item(&self, def_id: DefId) -> Option<DefId> { bug!(\"trait_of_item\") }\n     fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<ty::ImplOrTraitItem<'tcx>> { bug!(\"impl_or_trait_item\") }\n \n@@ -583,7 +585,7 @@ pub mod tls {\n     pub trait DecodingContext<'tcx> {\n         fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n         fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx>;\n-        fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> Substs<'tcx>;\n+        fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> &'tcx Substs<'tcx>;\n         fn translate_def_id(&self, def_id: DefId) -> DefId;\n     }\n "}, {"sha": "2a8594c59a83764c727862b7f3ff38684154d7e4", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -88,15 +88,24 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn lookup_and_handle_definition(&mut self, id: ast::NodeId) {\n         use ty::TypeVariants::{TyEnum, TyStruct};\n \n+        let def = self.tcx.expect_def(id);\n+\n         // If `bar` is a trait item, make sure to mark Foo as alive in `Foo::bar`\n-        self.tcx.tables.borrow().item_substs.get(&id)\n-            .and_then(|substs| substs.substs.self_ty())\n-            .map(|ty| match ty.sty {\n-                TyEnum(tyid, _) | TyStruct(tyid, _) => self.check_def_id(tyid.did),\n-                _ => (),\n-            });\n+        match def {\n+            Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n+            if self.tcx.trait_of_item(def.def_id()).is_some() => {\n+                if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n+                    match substs.substs.types[0].sty {\n+                        TyEnum(tyid, _) | TyStruct(tyid, _) => {\n+                            self.check_def_id(tyid.did)\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n \n-        let def = self.tcx.expect_def(id);\n         match def {\n             Def::Const(_) | Def::AssociatedConst(..) => {\n                 self.check_def_id(def.def_id());"}, {"sha": "8369a6c39d54d658a825aaa2eb4842e5c9aa06f2", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -24,9 +24,7 @@ use session::Session;\n use hir::def::{Def, DefMap};\n use hir::def_id::DefId;\n use middle::region;\n-use ty::subst;\n use ty;\n-use std::fmt;\n use std::mem::replace;\n use syntax::ast;\n use syntax::parse::token::keywords;\n@@ -41,8 +39,7 @@ use hir::intravisit::{self, Visitor, FnKind};\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum DefRegion {\n     DefStaticRegion,\n-    DefEarlyBoundRegion(/* space */ subst::ParamSpace,\n-                        /* index */ u32,\n+    DefEarlyBoundRegion(/* index */ u32,\n                         /* lifetime decl */ ast::NodeId),\n     DefLateBoundRegion(ty::DebruijnIndex,\n                        /* lifetime decl */ ast::NodeId),\n@@ -90,10 +87,11 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n     labels_in_fn: Vec<(ast::Name, Span)>,\n }\n \n+#[derive(PartialEq, Debug)]\n enum ScopeChain<'a> {\n-    /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n-    /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n-    EarlyScope(subst::ParamSpace, &'a [hir::LifetimeDef], Scope<'a>),\n+    /// EarlyScope(['a, 'b, ...], s) extends s with early-bound\n+    /// lifetimes.\n+    EarlyScope(&'a [hir::LifetimeDef], Scope<'a>),\n     /// LateScope(['a, 'b, ...], s) extends s with late-bound\n     /// lifetimes introduced by the declaration binder_id.\n     LateScope(&'a [hir::LifetimeDef], Scope<'a>),\n@@ -159,8 +157,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n                 hir::ItemImpl(_, _, ref generics, _, _, _) => {\n                     // These kinds of items have only early bound lifetime parameters.\n                     let lifetimes = &generics.lifetimes;\n-                    let early_scope = EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE);\n-                    this.with(early_scope, |old_scope, this| {\n+                    this.with(EarlyScope(lifetimes, &ROOT_SCOPE), |old_scope, this| {\n                         this.check_lifetime_defs(old_scope, lifetimes);\n                         intravisit::walk_item(this, item);\n                     });\n@@ -181,11 +178,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         self.with(RootScope, |_, this| {\n             match item.node {\n                 hir::ForeignItemFn(ref decl, ref generics) => {\n-                    this.visit_early_late(item.id,\n-                                          subst::FnSpace,\n-                                          decl,\n-                                          generics,\n-                                          |this| {\n+                    this.visit_early_late(item.id, decl, generics, |this| {\n                         intravisit::walk_foreign_item(this, item);\n                     })\n                 }\n@@ -203,14 +196,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n                 b: &'v hir::Block, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, _, _, _, _, _) => {\n-                self.visit_early_late(fn_id, subst::FnSpace, decl, generics, |this| {\n+                self.visit_early_late(fn_id,decl, generics, |this| {\n                     this.add_scope_and_walk_fn(fk, decl, b, s, fn_id)\n                 })\n             }\n             FnKind::Method(_, sig, _, _) => {\n                 self.visit_early_late(\n                     fn_id,\n-                    subst::FnSpace,\n                     decl,\n                     &sig.generics,\n                     |this| this.add_scope_and_walk_fn(fk, decl, b, s, fn_id));\n@@ -263,7 +255,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n \n         if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n             self.visit_early_late(\n-                trait_item.id, subst::FnSpace,\n+                trait_item.id,\n                 &sig.decl, &sig.generics,\n                 |this| intravisit::walk_trait_item(this, trait_item))\n         } else {\n@@ -469,7 +461,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n                 FnScope { s, .. } => { scope = s; }\n                 RootScope => { return; }\n \n-                EarlyScope(_, lifetimes, s) |\n+                EarlyScope(lifetimes, s) |\n                 LateScope(lifetimes, s) => {\n                     for lifetime_def in lifetimes {\n                         // FIXME (#24278): non-hygienic comparison\n@@ -557,7 +549,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n                            fn_id: ast::NodeId,\n-                           early_space: subst::ParamSpace,\n                            decl: &hir::FnDecl,\n                            generics: &hir::Generics,\n                            walk: F) where\n@@ -576,7 +567,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     .partition(|l| self.map.late_bound.contains_key(&l.lifetime.id));\n \n         let this = self;\n-        this.with(EarlyScope(early_space, &early, this.scope), move |old_scope, this| {\n+        this.with(EarlyScope(&early, this.scope), move |old_scope, this| {\n             this.with(LateScope(&late, this.scope), move |_, this| {\n                 this.check_lifetime_defs(old_scope, &generics.lifetimes);\n                 walk(this);\n@@ -606,11 +597,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break;\n                 }\n \n-                EarlyScope(space, lifetimes, s) => {\n+                EarlyScope(lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((index, lifetime_def)) => {\n+                        Some((mut index, lifetime_def)) => {\n+                            // Adjust for nested early scopes, e.g. in methods.\n+                            let mut parent = s;\n+                            while let EarlyScope(lifetimes, s) = *parent {\n+                                index += lifetimes.len() as u32;\n+                                parent = s;\n+                            }\n+                            assert_eq!(*parent, RootScope);\n+\n                             let decl_id = lifetime_def.id;\n-                            let def = DefEarlyBoundRegion(space, index, decl_id);\n+                            let def = DefEarlyBoundRegion(index, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n@@ -672,7 +671,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break;\n                 }\n \n-                EarlyScope(_, lifetimes, s) |\n+                EarlyScope(lifetimes, s) |\n                 LateScope(lifetimes, s) => {\n                     search_result = search_lifetimes(lifetimes, lifetime_ref);\n                     if search_result.is_some() {\n@@ -768,7 +767,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     return;\n                 }\n \n-                EarlyScope(_, lifetimes, s) |\n+                EarlyScope(lifetimes, s) |\n                 LateScope(lifetimes, s) => {\n                     if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n                         signal_shadowing_problem(\n@@ -963,14 +962,3 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         }\n     }\n }\n-\n-impl<'a> fmt::Debug for ScopeChain<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({:?}, {:?})\", space, defs),\n-            LateScope(defs, _) => write!(fmt, \"LateScope({:?})\", defs),\n-            FnScope { fn_id, body_id, s: _ } => write!(fmt, \"FnScope({:?}, {:?})\", fn_id, body_id),\n-            RootScope => write!(fmt, \"RootScope\"),\n-        }\n-    }\n-}"}, {"sha": "f511d820fac5878f5f05ee51e79b4b0efb491d36", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -1073,10 +1073,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         let variant_def = &adt_def.variants[variant];\n \n                         ppaux::parameterized(fmt, substs, variant_def.did,\n-                                             ppaux::Ns::Value, &[],\n-                                             |tcx| {\n-                            Some(tcx.lookup_item_type(variant_def.did).generics)\n-                        })?;\n+                                             ppaux::Ns::Value, &[])?;\n \n                         match variant_def.kind {\n                             ty::VariantKind::Unit => Ok(()),\n@@ -1169,9 +1166,7 @@ impl<'tcx> Debug for Literal<'tcx> {\n         use self::Literal::*;\n         match *self {\n             Item { def_id, substs } => {\n-                ppaux::parameterized(\n-                    fmt, substs, def_id, ppaux::Ns::Value, &[],\n-                    |tcx| Some(tcx.lookup_item_type(def_id).generics))\n+                ppaux::parameterized(fmt, substs, def_id, ppaux::Ns::Value, &[])\n             }\n             Value { ref value } => {\n                 write!(fmt, \"const \")?;"}, {"sha": "a5a415dd27c650a1debb9ea50b0bd4e47facc89d", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -14,7 +14,6 @@ use super::{SelectionContext, Obligation, ObligationCause};\n \n use middle::cstore::LOCAL_CRATE;\n use hir::def_id::DefId;\n-use ty::subst::TypeSpace;\n use ty::{self, Ty, TyCtxt};\n use infer::{InferCtxt, TypeOrigin};\n use syntax_pos::DUMMY_SP;\n@@ -160,12 +159,9 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n \n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n-    let input_tys = Some(trait_ref.self_ty());\n-    let input_tys = input_tys.iter().chain(trait_ref.substs.types.get_slice(TypeSpace));\n-\n     // Find the first input type that either references a type parameter OR\n     // some local type.\n-    for input_ty in input_tys {\n+    for input_ty in trait_ref.input_types() {\n         if ty_is_local(tcx, input_ty, infer_is_local) {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n \n@@ -231,7 +227,7 @@ fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n         ty::TyEnum(def, _) | ty::TyStruct(def, _) =>\n             def.is_fundamental(),\n         ty::TyTrait(ref data) =>\n-            tcx.has_attr(data.principal_def_id(), \"fundamental\"),\n+            tcx.has_attr(data.principal.def_id(), \"fundamental\"),\n         _ =>\n             false\n     }\n@@ -275,7 +271,7 @@ fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)->\n         }\n \n         ty::TyTrait(ref tt) => {\n-            tt.principal_def_id().is_local()\n+            tt.principal.def_id().is_local()\n         }\n \n         ty::TyError => {"}, {"sha": "33db0053cda13547a9b33dd3a71cac10f6f958ad", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -31,7 +31,7 @@ use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n-use ty::subst::{self, Subst, TypeSpace};\n+use ty::subst::Subst;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n@@ -167,29 +167,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    fn impl_substs(&self,\n-                   did: DefId,\n-                   obligation: PredicateObligation<'tcx>)\n-                   -> subst::Substs<'tcx> {\n-        let tcx = self.tcx;\n-\n-        let ity = tcx.lookup_item_type(did);\n-        let (tps, rps, _) =\n-            (ity.generics.types.get_slice(TypeSpace),\n-             ity.generics.regions.get_slice(TypeSpace),\n-             ity.ty);\n-\n-        let rps = self.region_vars_for_defs(obligation.cause.span, rps);\n-        let mut substs = subst::Substs::new(\n-            subst::VecPerParamSpace::empty(),\n-            subst::VecPerParamSpace::new(rps, Vec::new(), Vec::new()));\n-        self.type_vars_for_defs(obligation.cause.span,\n-                                TypeSpace,\n-                                &mut substs,\n-                                tps);\n-        substs\n-    }\n-\n     fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         /// returns the fuzzy category of a given type, or None\n         /// if the type can be equated to any type.\n@@ -244,18 +221,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.lookup_trait_def(trait_ref.def_id)\n             .for_each_relevant_impl(self.tcx, trait_self_ty, |def_id| {\n+                let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n                 let impl_trait_ref = tcx\n                     .impl_trait_ref(def_id)\n                     .unwrap()\n-                    .subst(tcx, &self.impl_substs(def_id, obligation.clone()));\n+                    .subst(tcx, impl_substs);\n \n                 let impl_self_ty = impl_trait_ref.self_ty();\n \n                 if let Ok(..) = self.can_equate(&trait_self_ty, &impl_self_ty) {\n                     self_match_impls.push(def_id);\n \n-                    if trait_ref.substs.types.get_slice(TypeSpace).iter()\n-                        .zip(impl_trait_ref.substs.types.get_slice(TypeSpace))\n+                    if trait_ref.substs.types[1..].iter()\n+                        .zip(&impl_trait_ref.substs.types[1..])\n                         .all(|(u,v)| self.fuzzy_match_tys(u, v))\n                     {\n                         fuzzy_match_impls.push(def_id);\n@@ -293,14 +271,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let def = self.tcx.lookup_trait_def(trait_ref.def_id);\n                 let trait_str = def.trait_ref.to_string();\n                 if let Some(ref istring) = item.value_str() {\n-                    let mut generic_map = def.generics.types.iter_enumerated()\n-                                             .map(|(param, i, gen)| {\n-                                                   (gen.name.as_str().to_string(),\n-                                                    trait_ref.substs.types.get(param, i)\n-                                                             .to_string())\n-                                                  }).collect::<FnvHashMap<String, String>>();\n-                    generic_map.insert(\"Self\".to_string(),\n-                                       trait_ref.self_ty().to_string());\n+                    let generic_map = def.generics.types.iter().map(|param| {\n+                        (param.name.as_str().to_string(),\n+                         trait_ref.substs.type_for_def(param).to_string())\n+                    }).collect::<FnvHashMap<String, String>>();\n                     let parser = Parser::new(&istring);\n                     let mut errored = false;\n                     let err: String = parser.filter_map(|p| {"}, {"sha": "837e33b3e7fc2798e2c27af83265ef52845afa17", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n         // Auto trait obligations on `impl Trait`.\n         if tcx.trait_has_default_impl(predicate.def_id()) {\n             let substs = predicate.skip_binder().trait_ref.substs;\n-            if substs.types.as_slice().len() == 1 && substs.regions.is_empty() {\n+            if substs.types.len() == 1 && substs.regions.is_empty() {\n                 if let ty::TyAnon(..) = predicate.skip_binder().self_ty().sty {\n                     return true;\n                 }\n@@ -160,10 +160,9 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n             // We can resolve the `impl Trait` to its concrete type.\n             if let Some(ty_scheme) = tcx.opt_lookup_item_type(def_id) {\n                 let concrete_ty = ty_scheme.ty.subst(tcx, substs);\n-                let concrete_substs = Substs::new_trait(vec![], vec![], concrete_ty);\n                 let predicate = ty::TraitRef {\n                     def_id: self.predicate.def_id(),\n-                    substs: tcx.mk_substs(concrete_substs)\n+                    substs: Substs::new_trait(tcx, vec![], vec![], concrete_ty)\n                 }.to_predicate();\n \n                 let original_obligation = Obligation::new(self.cause.clone(),"}, {"sha": "b86a54f01cf499adde3b251c2a5dd967f646ad21", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -17,7 +17,7 @@ pub use self::ObligationCauseCode::*;\n \n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n-use ty::subst;\n+use ty::subst::Substs;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use infer::InferCtxt;\n \n@@ -272,7 +272,7 @@ pub enum Vtable<'tcx, N> {\n #[derive(Clone, PartialEq, Eq)]\n pub struct VtableImplData<'tcx, N> {\n     pub impl_def_id: DefId,\n-    pub substs: &'tcx subst::Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n     pub nested: Vec<N>\n }\n "}, {"sha": "25d2df8fdedb39a0a260703315e9fee84cc4bcc1", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -20,7 +20,6 @@\n use super::elaborate_predicates;\n \n use hir::def_id::DefId;\n-use ty::subst::{self, SelfSpace, TypeSpace};\n use traits;\n use ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use std::rc::Rc;\n@@ -146,10 +145,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 match predicate {\n                     ty::Predicate::Trait(ref data) => {\n                         // In the case of a trait predicate, we can skip the \"self\" type.\n-                        data.0.trait_ref.substs.types.get_slice(TypeSpace)\n-                                                     .iter()\n-                                                     .cloned()\n-                                                     .any(|t| t.has_self_ty())\n+                        data.0.trait_ref.input_types()[1..].iter().any(|t| t.has_self_ty())\n                     }\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::WellFormed(..) |\n@@ -166,25 +162,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn trait_has_sized_self(self, trait_def_id: DefId) -> bool {\n-        let trait_def = self.lookup_trait_def(trait_def_id);\n-        let trait_predicates = self.lookup_predicates(trait_def_id);\n-        self.generics_require_sized_self(&trait_def.generics, &trait_predicates)\n+        self.generics_require_sized_self(trait_def_id)\n     }\n \n-    fn generics_require_sized_self(self,\n-                                   generics: &ty::Generics<'gcx>,\n-                                   predicates: &ty::GenericPredicates<'gcx>)\n-                                   -> bool\n-    {\n+    fn generics_require_sized_self(self, def_id: DefId) -> bool {\n         let sized_def_id = match self.lang_items.sized_trait() {\n             Some(def_id) => def_id,\n             None => { return false; /* No Sized trait, can't require it! */ }\n         };\n \n         // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-        let free_substs = self.construct_free_substs(generics,\n+        let free_substs = self.construct_free_substs(def_id,\n             self.region_maps.node_extent(ast::DUMMY_NODE_ID));\n-        let predicates = predicates.instantiate(self, &free_substs).predicates.into_vec();\n+        let predicates = self.lookup_predicates(def_id);\n+        let predicates = predicates.instantiate(self, free_substs).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| {\n                 match predicate {\n@@ -214,7 +205,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         // Any method that has a `Self : Sized` requisite is otherwise\n         // exempt from the regulations.\n-        if self.generics_require_sized_self(&method.generics, &method.predicates) {\n+        if self.generics_require_sized_self(method.def_id) {\n             return None;\n         }\n \n@@ -231,7 +222,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  -> bool\n     {\n         // Any method that has a `Self : Sized` requisite can't be called.\n-        if self.generics_require_sized_self(&method.generics, &method.predicates) {\n+        if self.generics_require_sized_self(method.def_id) {\n             return false;\n         }\n \n@@ -274,7 +265,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if !method.generics.types.is_empty_in(subst::FnSpace) {\n+        if !method.generics.types.is_empty() {\n             return Some(MethodViolationCode::Generic);\n         }\n \n@@ -330,7 +321,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         ty.maybe_walk(|ty| {\n             match ty.sty {\n                 ty::TyParam(ref param_ty) => {\n-                    if param_ty.space == SelfSpace {\n+                    if param_ty.is_self() {\n                         error = true;\n                     }\n "}, {"sha": "ea4fc1c25ab42483a4ff73c6844bf8d1479609b5", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -811,7 +811,7 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     // If so, extract what we know from the trait and try to come up with a good answer.\n     let trait_predicates = selcx.tcx().lookup_predicates(def_id);\n     let bounds = trait_predicates.instantiate(selcx.tcx(), substs);\n-    let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates.into_vec());\n+    let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates);\n     assemble_candidates_from_predicates(selcx,\n                                         obligation,\n                                         obligation_trait_ref,\n@@ -1133,10 +1133,9 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n                 object_ty)\n         }\n     };\n-    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n-    let env_predicates = projection_bounds.iter()\n-                                          .map(|p| p.to_predicate())\n-                                          .collect();\n+    let env_predicates = data.projection_bounds.iter().map(|p| {\n+        p.with_self_ty(selcx.tcx(), object_ty).to_predicate()\n+    }).collect();\n     let env_predicate = {\n         let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n "}, {"sha": "9ea738bd326eb7f18bf75d468433e935cc2c3989", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 68, "deletions": 66, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -36,12 +36,13 @@ use super::util;\n use hir::def_id::DefId;\n use infer;\n use infer::{InferCtxt, InferOk, TypeFreshener, TypeOrigin};\n-use ty::subst::{Subst, Substs, TypeSpace};\n+use ty::subst::{Subst, Substs};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use traits;\n use ty::fast_reject;\n use ty::relate::TypeRelation;\n \n+use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n use std::cell::RefCell;\n use std::fmt;\n@@ -1214,7 +1215,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                bounds);\n \n         let matching_bound =\n-            util::elaborate_predicates(self.tcx(), bounds.predicates.into_vec())\n+            util::elaborate_predicates(self.tcx(), bounds.predicates)\n             .filter_to_traits()\n             .find(\n                 |bound| self.probe(\n@@ -1528,7 +1529,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 ty::TyTrait(ref data) => {\n                     match this.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n                         Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n-                            if data.bounds.builtin_bounds.contains(&bound) {\n+                            if data.builtin_bounds.contains(&bound) {\n                                 debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n                                         pushing candidate\");\n                                 candidates.vec.push(BuiltinObjectCandidate);\n@@ -1538,7 +1539,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         _ => {}\n                     }\n \n-                    data.principal_trait_ref_with_self_ty(this.tcx(), self_ty)\n+                    data.principal.with_self_ty(this.tcx(), self_ty)\n                 }\n                 ty::TyInfer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n@@ -1602,7 +1603,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 return;\n             }\n         };\n-        let target = obligation.predicate.0.input_types()[0];\n+        let target = obligation.predicate.skip_binder().input_types()[1];\n \n         debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\",\n                source, target);\n@@ -1622,7 +1623,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // We always upcast when we can because of reason\n                 // #2 (region bounds).\n                 data_a.principal.def_id() == data_a.principal.def_id() &&\n-                data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds)\n+                data_a.builtin_bounds.is_superset(&data_b.builtin_bounds)\n             }\n \n             // T -> Trait.\n@@ -1935,7 +1936,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             // for `PhantomData<T>`, we pass `T`\n             ty::TyStruct(def, substs) if def.is_phantom_data() => {\n-                substs.types.get_slice(TypeSpace).to_vec()\n+                substs.types.to_vec()\n             }\n \n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n@@ -2179,10 +2180,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         match self_ty.sty {\n             ty::TyTrait(ref data) => {\n                 // OK to skip the binder, it is reintroduced below\n-                let input_types = data.principal.skip_binder().substs.types.get_slice(TypeSpace);\n-                let assoc_types = data.bounds.projection_bounds\n-                                             .iter()\n-                                             .map(|pb| pb.skip_binder().ty);\n+                let input_types = data.principal.skip_binder().input_types();\n+                let assoc_types = data.projection_bounds.iter()\n+                                      .map(|pb| pb.skip_binder().ty);\n                 let all_types: Vec<_> = input_types.iter().cloned()\n                                                           .chain(assoc_types)\n                                                           .collect();\n@@ -2315,7 +2315,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n             ty::TyTrait(ref data) => {\n-                data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+                data.principal.with_self_ty(self.tcx(), self_ty)\n             }\n             _ => {\n                 span_bug!(obligation.cause.span,\n@@ -2476,7 +2476,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // regions here. See the comment there for more details.\n         let source = self.infcx.shallow_resolve(\n             tcx.no_late_bound_regions(&obligation.self_ty()).unwrap());\n-        let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n+        let target = obligation.predicate.skip_binder().input_types()[1];\n+        let target = self.infcx.shallow_resolve(target);\n \n         debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\",\n                source, target);\n@@ -2486,13 +2487,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::TyTrait(ref data_a), &ty::TyTrait(ref data_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n-                let bounds = ty::ExistentialBounds {\n-                    region_bound: data_b.bounds.region_bound,\n-                    builtin_bounds: data_b.bounds.builtin_bounds,\n-                    projection_bounds: data_a.bounds.projection_bounds.clone(),\n-                };\n-\n-                let new_trait = tcx.mk_trait(data_a.principal.clone(), bounds);\n+                let new_trait = tcx.mk_trait(ty::TraitObject {\n+                    principal: data_a.principal,\n+                    region_bound: data_b.region_bound,\n+                    builtin_bounds: data_b.builtin_bounds,\n+                    projection_bounds: data_a.projection_bounds.clone(),\n+                });\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_trait, target)\n@@ -2503,21 +2503,21 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let cause = ObligationCause::new(obligation.cause.span,\n                                                  obligation.cause.body_id,\n                                                  ObjectCastObligation(target));\n-                let outlives = ty::OutlivesPredicate(data_a.bounds.region_bound,\n-                                                     data_b.bounds.region_bound);\n+                let outlives = ty::OutlivesPredicate(data_a.region_bound,\n+                                                     data_b.region_bound);\n                 nested.push(Obligation::with_depth(cause,\n                                                    obligation.recursion_depth + 1,\n                                                    ty::Binder(outlives).to_predicate()));\n             }\n \n             // T -> Trait.\n             (_, &ty::TyTrait(ref data)) => {\n-                let mut object_dids = Some(data.principal_def_id()).into_iter();\n+                let mut object_dids = Some(data.principal.def_id()).into_iter();\n                 // FIXME(#33243)\n-//                    data.bounds.builtin_bounds.iter().flat_map(|bound| {\n+//                    data.builtin_bounds.iter().flat_map(|bound| {\n //                        tcx.lang_items.from_builtin_kind(bound).ok()\n //                    })\n-//                    .chain(Some(data.principal_def_id()));\n+//                    .chain(Some(data.principal.def_id()));\n                 if let Some(did) = object_dids.find(|did| {\n                     !tcx.is_object_safe(*did)\n                 }) {\n@@ -2534,10 +2534,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 };\n \n                 // Create the obligation for casting from T to Trait.\n-                push(data.principal_trait_ref_with_self_ty(tcx, source).to_predicate());\n+                push(data.principal.with_self_ty(tcx, source).to_predicate());\n \n                 // We can only make objects from sized types.\n-                let mut builtin_bounds = data.bounds.builtin_bounds;\n+                let mut builtin_bounds = data.builtin_bounds;\n                 builtin_bounds.insert(ty::BoundSized);\n \n                 // Create additional obligations for all the various builtin\n@@ -2553,14 +2553,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n \n                 // Create obligations for the projection predicates.\n-                for bound in data.projection_bounds_with_self_ty(tcx, source) {\n-                    push(bound.to_predicate());\n+                for bound in &data.projection_bounds {\n+                    push(bound.with_self_ty(tcx, source).to_predicate());\n                 }\n \n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` outlives `'a`:\n-                let outlives = ty::OutlivesPredicate(source,\n-                                                     data.bounds.region_bound);\n+                let outlives = ty::OutlivesPredicate(source, data.region_bound);\n                 push(ty::Binder(outlives).to_predicate());\n             }\n \n@@ -2586,30 +2585,32 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 } else {\n                     return Err(Unimplemented);\n                 };\n-                let mut ty_params = vec![];\n+                let mut ty_params = BitVector::new(substs_a.types.len());\n+                let mut found = false;\n                 for ty in field.walk() {\n                     if let ty::TyParam(p) = ty.sty {\n-                        assert!(p.space == TypeSpace);\n-                        let idx = p.idx as usize;\n-                        if !ty_params.contains(&idx) {\n-                            ty_params.push(idx);\n-                        }\n+                        ty_params.insert(p.idx as usize);\n+                        found = true;\n                     }\n                 }\n-                if ty_params.is_empty() {\n+                if !found {\n                     return Err(Unimplemented);\n                 }\n \n                 // Replace type parameters used in unsizing with\n                 // TyError and ensure they do not affect any other fields.\n                 // This could be checked after type collection for any struct\n                 // with a potentially unsized trailing field.\n-                let mut new_substs = substs_a.clone();\n-                for &i in &ty_params {\n-                    new_substs.types.get_mut_slice(TypeSpace)[i] = tcx.types.err;\n-                }\n+                let types = substs_a.types.iter().enumerate().map(|(i, ty)| {\n+                    if ty_params.contains(i) {\n+                        tcx.types.err\n+                    } else {\n+                        ty\n+                    }\n+                }).collect();\n+                let substs = Substs::new(tcx, types, substs_a.regions.clone());\n                 for &ty in fields.split_last().unwrap().1 {\n-                    if ty.subst(tcx, &new_substs).references_error() {\n+                    if ty.subst(tcx, substs).references_error() {\n                         return Err(Unimplemented);\n                     }\n                 }\n@@ -2620,11 +2621,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n                 // Check that the source structure with the target's\n                 // type parameters is a subtype of the target.\n-                for &i in &ty_params {\n-                    let param_b = *substs_b.types.get(TypeSpace, i);\n-                    new_substs.types.get_mut_slice(TypeSpace)[i] = param_b;\n-                }\n-                let new_struct = tcx.mk_struct(def, tcx.mk_substs(new_substs));\n+                let types = substs_a.types.iter().enumerate().map(|(i, ty)| {\n+                    if ty_params.contains(i) {\n+                        substs_b.types[i]\n+                    } else {\n+                        ty\n+                    }\n+                }).collect();\n+                let substs = Substs::new(tcx, types, substs_a.regions.clone());\n+                let new_struct = tcx.mk_struct(def, substs);\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_struct, target)\n@@ -2693,12 +2698,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             snapshot);\n         let skol_obligation_trait_ref = skol_obligation.trait_ref;\n \n-        let impl_substs = util::fresh_type_vars_for_impl(self.infcx,\n-                                                         obligation.cause.span,\n-                                                         impl_def_id);\n+        let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span,\n+                                                           impl_def_id);\n \n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n-                                                  &impl_substs);\n+                                                  impl_substs);\n \n         let impl_trait_ref =\n             project::normalize_with_depth(self,\n@@ -2892,20 +2896,18 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // obligation will normalize to `<$0 as Iterator>::Item = $1` and\n         // `$1: Copy`, so we must ensure the obligations are emitted in\n         // that order.\n-        let predicates = tcx\n-            .lookup_predicates(def_id)\n-            .predicates.iter()\n-            .flat_map(|predicate| {\n-                let predicate =\n-                    normalize_with_depth(self, cause.clone(), recursion_depth,\n-                                         &predicate.subst(tcx, substs));\n-                predicate.obligations.into_iter().chain(\n-                    Some(Obligation {\n-                        cause: cause.clone(),\n-                        recursion_depth: recursion_depth,\n-                        predicate: predicate.value\n-                    }))\n-            }).collect();\n+        let predicates = tcx.lookup_predicates(def_id);\n+        assert_eq!(predicates.parent, None);\n+        let predicates = predicates.predicates.iter().flat_map(|predicate| {\n+            let predicate = normalize_with_depth(self, cause.clone(), recursion_depth,\n+                                                 &predicate.subst(tcx, substs));\n+            predicate.obligations.into_iter().chain(\n+                Some(Obligation {\n+                    cause: cause.clone(),\n+                    recursion_depth: recursion_depth,\n+                    predicate: predicate.value\n+                }))\n+        }).collect();\n         self.infcx().plug_leaks(skol_map, snapshot, &predicates)\n     }\n }"}, {"sha": "9acfe2754820c9bea7f6988149bd1821d0261f61", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -18,7 +18,7 @@\n // fits together with the rest of the trait machinery.\n \n use super::{SelectionContext, FulfillmentContext};\n-use super::util::{fresh_type_vars_for_impl, impl_trait_ref_and_oblig};\n+use super::util::impl_trait_ref_and_oblig;\n \n use rustc_data_structures::fnv::FnvHashMap;\n use hir::def_id::DefId;\n@@ -44,11 +44,10 @@ pub struct OverlapError {\n /// When we have selected one impl, but are actually using item definitions from\n /// a parent impl providing a default, we need a way to translate between the\n /// type parameters of the two impls. Here the `source_impl` is the one we've\n-/// selected, and `source_substs` is a substitution of its generics (and\n-/// possibly some relevant `FnSpace` variables as well). And `target_node` is\n-/// the impl/trait we're actually going to get the definition from. The resulting\n-/// substitution will map from `target_node`'s generics to `source_impl`'s\n-/// generics as instantiated by `source_subst`.\n+/// selected, and `source_substs` is a substitution of its generics.\n+/// And `target_node` is the impl/trait we're actually going to get the\n+/// definition from. The resulting substitution will map from `target_node`'s\n+/// generics to `source_impl`'s generics as instantiated by `source_subst`.\n ///\n /// For example, consider the following scenario:\n ///\n@@ -101,7 +100,7 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     };\n \n     // directly inherent the method generics, since those do not vary across impls\n-    infcx.tcx.mk_substs(target_substs.with_method_from_subst(source_substs))\n+    source_substs.rebase_onto(infcx.tcx, source_impl, target_substs)\n }\n \n /// Is impl1 a specialization of impl2?\n@@ -141,11 +140,8 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n-    let scheme = tcx.lookup_item_type(impl1_def_id);\n-    let predicates = tcx.lookup_predicates(impl1_def_id);\n     let mut penv = tcx.construct_parameter_environment(DUMMY_SP,\n-                                                       &scheme.generics,\n-                                                       &predicates,\n+                                                       impl1_def_id,\n                                                        region::DUMMY_CODE_EXTENT);\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id)\n                              .unwrap()\n@@ -188,10 +184,10 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n     let selcx = &mut SelectionContext::new(&infcx);\n-    let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);\n+    let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n     let (target_trait_ref, obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                    target_impl,\n-                                                                   &target_substs);\n+                                                                   target_substs);\n \n     // do the impls unify? If not, no specialization.\n     if let Err(_) = infcx.eq_trait_refs(true,"}, {"sha": "13193e1b2d71be0ace5fb78560cce06f5563a110", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -122,19 +122,18 @@ impl<'a, 'gcx, 'tcx> Children {\n                     if le == ge {\n                         // overlap, but no specialization; error out\n                         let trait_ref = impl_header.trait_ref.unwrap();\n+                        let self_ty = trait_ref.self_ty();\n                         Err(OverlapError {\n                             with_impl: possible_sibling,\n                             trait_desc: trait_ref.to_string(),\n-                            self_desc: trait_ref.substs.self_ty().and_then(|ty| {\n-                                // only report the Self type if it has at least\n-                                // some outer concrete shell; otherwise, it's\n-                                // not adding much information.\n-                                if ty.has_concrete_skeleton() {\n-                                    Some(ty.to_string())\n-                                } else {\n-                                    None\n-                                }\n-                            })\n+                            // only report the Self type if it has at least\n+                            // some outer concrete shell; otherwise, it's\n+                            // not adding much information.\n+                            self_desc: if self_ty.has_concrete_skeleton() {\n+                                Some(self_ty.to_string())\n+                            } else {\n+                                None\n+                            }\n                         })\n                     } else {\n                         Ok((le, ge))"}, {"sha": "1954ce1993c5e0d71eeb5e604ed6606c68c9f204", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -9,10 +9,8 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use infer::InferCtxt;\n use ty::subst::{Subst, Substs};\n use ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n-use syntax_pos::Span;\n use util::common::ErrorReported;\n use util::nodemap::FnvHashSet;\n \n@@ -349,20 +347,6 @@ pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a,\n     (impl_trait_ref, impl_obligations)\n }\n \n-// determine the `self` type, using fresh variables for all variables\n-// declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n-// would return ($0, $1) where $0 and $1 are freshly instantiated type\n-// variables.\n-pub fn fresh_type_vars_for_impl<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                                span: Span,\n-                                                impl_def_id: DefId)\n-                                                -> &'tcx Substs<'tcx>\n-{\n-    let tcx = infcx.tcx;\n-    let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n-    infcx.fresh_substs_for_generics(span, &impl_generics)\n-}\n-\n /// See `super::obligations_for_generics`\n pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n                                      recursion_depth: usize,\n@@ -402,7 +386,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             Ok(def_id) => {\n                 Ok(ty::TraitRef {\n                     def_id: def_id,\n-                    substs: self.mk_substs(Substs::empty().with_self_ty(param_ty))\n+                    substs: Substs::new_trait(self, vec![], vec![], param_ty)\n                 })\n             }\n             Err(e) => {\n@@ -422,7 +406,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         let trait_ref = ty::TraitRef {\n             def_id: trait_def_id,\n-            substs: self.mk_substs(Substs::new_trait(ty_params, vec![], param_ty))\n+            substs: Substs::new_trait(self, ty_params, vec![], param_ty)\n         };\n         predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n     }\n@@ -510,10 +494,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             TupleArgumentsFlag::No => sig.0.inputs[0],\n             TupleArgumentsFlag::Yes => self.mk_tup(sig.0.inputs.to_vec()),\n         };\n-        let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n         let trait_ref = ty::TraitRef {\n             def_id: fn_trait_def_id,\n-            substs: self.mk_substs(trait_substs),\n+            substs: Substs::new_trait(self, vec![arguments_tuple], vec![], self_ty),\n         };\n         ty::Binder((trait_ref, sig.0.output))\n     }"}, {"sha": "3501dd484608786b7a7a3403eae02852a0e9ca18", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -23,13 +23,13 @@ use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n use middle::stability;\n-use ty::subst::{self, Substs};\n+use ty::subst::Substs;\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants};\n-use ty::{AdtDef, ClosureSubsts, ExistentialBounds, Region};\n+use ty::{AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n-use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n+use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n@@ -63,6 +63,7 @@ pub struct CtxtArenas<'tcx> {\n     layout: TypedArena<Layout>,\n \n     // references\n+    generics: TypedArena<ty::Generics<'tcx>>,\n     trait_defs: TypedArena<ty::TraitDef<'tcx>>,\n     adt_defs: TypedArena<ty::AdtDefData<'tcx, 'tcx>>,\n }\n@@ -78,6 +79,7 @@ impl<'tcx> CtxtArenas<'tcx> {\n             stability: TypedArena::new(),\n             layout: TypedArena::new(),\n \n+            generics: TypedArena::new(),\n             trait_defs: TypedArena::new(),\n             adt_defs: TypedArena::new()\n         }\n@@ -341,7 +343,8 @@ pub struct GlobalCtxt<'tcx> {\n     pub adt_defs: RefCell<DepTrackingMap<maps::AdtDefs<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n-    /// associated predicates.\n+    /// associated generics and predicates.\n+    pub generics: RefCell<DepTrackingMap<maps::Generics<'tcx>>>,\n     pub predicates: RefCell<DepTrackingMap<maps::Predicates<'tcx>>>,\n \n     /// Maps from the def-id of a trait to the list of\n@@ -583,13 +586,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.tables.borrow_mut().node_types.insert(id, ty);\n     }\n \n+    pub fn alloc_generics(self, generics: ty::Generics<'gcx>)\n+                          -> &'gcx ty::Generics<'gcx> {\n+        self.global_interners.arenas.generics.alloc(generics)\n+    }\n+\n     pub fn intern_trait_def(self, def: ty::TraitDef<'gcx>)\n                             -> &'gcx ty::TraitDef<'gcx> {\n         let did = def.trait_ref.def_id;\n-        let interned = self.global_interners.arenas.trait_defs.alloc(def);\n+        let interned = self.alloc_trait_def(def);\n         if let Some(prev) = self.trait_defs.borrow_mut().insert(did, interned) {\n             bug!(\"Tried to overwrite interned TraitDef: {:?}\", prev)\n         }\n+        self.generics.borrow_mut().insert(did, interned.generics);\n         interned\n     }\n \n@@ -711,6 +720,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            generics: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n@@ -1150,12 +1160,6 @@ impl_interners!('tcx,\n     region: mk_region(Region, keep_local) -> Region\n );\n \n-fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n-    bounds.is_empty() ||\n-        bounds[1..].iter().enumerate().all(\n-            |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n-}\n-\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Create an unsafe fn ty based on a safe fn ty.\n     pub fn safe_to_unsafe_fn_ty(self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n@@ -1288,18 +1292,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyFnPtr(fty))\n     }\n \n-    pub fn mk_trait(self,\n-                    principal: ty::PolyTraitRef<'tcx>,\n-                    bounds: ExistentialBounds<'tcx>)\n-                    -> Ty<'tcx>\n-    {\n-        assert!(bound_list_is_sorted(&bounds.projection_bounds));\n-\n-        let inner = box TraitTy {\n-            principal: principal,\n-            bounds: bounds\n-        };\n-        self.mk_ty(TyTrait(inner))\n+    pub fn mk_trait(self, mut obj: TraitObject<'tcx>) -> Ty<'tcx> {\n+        obj.projection_bounds.sort_by(|a, b| a.sort_key().cmp(&b.sort_key()));\n+        self.mk_ty(TyTrait(box obj))\n     }\n \n     pub fn mk_projection(self,\n@@ -1351,18 +1346,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_param(self,\n-                    space: subst::ParamSpace,\n                     index: u32,\n                     name: Name) -> Ty<'tcx> {\n-        self.mk_ty(TyParam(ParamTy { space: space, idx: index, name: name }))\n+        self.mk_ty(TyParam(ParamTy { idx: index, name: name }))\n     }\n \n     pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_param(subst::SelfSpace, 0, keywords::SelfType.name())\n+        self.mk_param(0, keywords::SelfType.name())\n     }\n \n     pub fn mk_param_from_def(self, def: &ty::TypeParameterDef) -> Ty<'tcx> {\n-        self.mk_param(def.space, def.index, def.name)\n+        self.mk_param(def.index, def.name)\n     }\n \n     pub fn mk_anon(self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {"}, {"sha": "17f9b6c25995c48bc1d6f4e72677dd8068debcd2", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use ty::subst;\n use infer::type_variable;\n use ty::{self, BoundRegion, Region, Ty, TyCtxt};\n \n@@ -243,7 +242,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyFnDef(..) => format!(\"fn item\"),\n             ty::TyFnPtr(_) => \"fn pointer\".to_string(),\n             ty::TyTrait(ref inner) => {\n-                format!(\"trait {}\", tcx.item_path_str(inner.principal_def_id()))\n+                format!(\"trait {}\", tcx.item_path_str(inner.principal.def_id()))\n             }\n             ty::TyStruct(def, _) => {\n                 format!(\"struct `{}`\", tcx.item_path_str(def.did))\n@@ -258,7 +257,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyInfer(ty::FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n             ty::TyProjection(_) => \"associated type\".to_string(),\n             ty::TyParam(ref p) => {\n-                if p.space == subst::SelfSpace {\n+                if p.is_self() {\n                     \"Self\".to_string()\n                 } else {\n                     \"type parameter\".to_string()"}, {"sha": "f7472d611befe30732f07bbca9ea9986732ee436", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -61,7 +61,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyArray(..) | ty::TySlice(_) => Some(VecSimplifiedType),\n         ty::TyRawPtr(_) => Some(PtrSimplifiedType),\n         ty::TyTrait(ref trait_info) => {\n-            Some(TraitSimplifiedType(trait_info.principal_def_id()))\n+            Some(TraitSimplifiedType(trait_info.principal.def_id()))\n         }\n         ty::TyStruct(def, _) => {\n             Some(StructSimplifiedType(def.did))"}, {"sha": "c6c37296e9e1242f82ace140e67d388dd8992e9d", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ty::subst;\n+use ty::subst::Substs;\n use ty::{self, Ty, TypeFlags, TypeFoldable};\n \n pub struct FlagComputation {\n@@ -77,7 +77,7 @@ impl FlagComputation {\n \n             &ty::TyParam(ref p) => {\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n-                if p.space == subst::SelfSpace {\n+                if p.is_self() {\n                     self.add_flags(TypeFlags::HAS_SELF);\n                 } else {\n                     self.add_flags(TypeFlags::HAS_PARAMS);\n@@ -116,17 +116,16 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n+            &ty::TyTrait(ref obj) => {\n                 let mut computation = FlagComputation::new();\n-                computation.add_substs(principal.0.substs);\n-                for projection_bound in &bounds.projection_bounds {\n+                computation.add_substs(obj.principal.skip_binder().substs);\n+                for projection_bound in &obj.projection_bounds {\n                     let mut proj_computation = FlagComputation::new();\n-                    proj_computation.add_projection_predicate(&projection_bound.0);\n+                    proj_computation.add_existential_projection(&projection_bound.0);\n                     self.add_bound_computation(&proj_computation);\n                 }\n                 self.add_bound_computation(&computation);\n-\n-                self.add_bounds(bounds);\n+                self.add_region(obj.region_bound);\n             }\n \n             &ty::TyBox(tt) | &ty::TyArray(tt, _) | &ty::TySlice(tt) => {\n@@ -199,23 +198,19 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_projection_predicate(&mut self, projection_predicate: &ty::ProjectionPredicate) {\n-        self.add_projection_ty(&projection_predicate.projection_ty);\n-        self.add_ty(projection_predicate.ty);\n+    fn add_existential_projection(&mut self, projection: &ty::ExistentialProjection) {\n+        self.add_substs(projection.trait_ref.substs);\n+        self.add_ty(projection.ty);\n     }\n \n     fn add_projection_ty(&mut self, projection_ty: &ty::ProjectionTy) {\n         self.add_substs(projection_ty.trait_ref.substs);\n     }\n \n-    fn add_substs(&mut self, substs: &subst::Substs) {\n-        self.add_tys(substs.types.as_slice());\n+    fn add_substs(&mut self, substs: &Substs) {\n+        self.add_tys(&substs.types);\n         for &r in &substs.regions {\n             self.add_region(r);\n         }\n     }\n-\n-    fn add_bounds(&mut self, bounds: &ty::ExistentialBounds) {\n-        self.add_region(bounds.region_bound);\n-    }\n }"}, {"sha": "2e114a801d6ed4a86de846ab4c286ef6bd93e416", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -40,7 +40,7 @@\n //! and does not need to visit anything else.\n \n use middle::region;\n-use ty::subst;\n+use ty::subst::Substs;\n use ty::adjustment;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n@@ -140,17 +140,13 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         t.super_fold_with(self)\n     }\n \n-    fn fold_trait_ref(&mut self, t: &ty::TraitRef<'tcx>) -> ty::TraitRef<'tcx> {\n-        t.super_fold_with(self)\n-    }\n-\n     fn fold_impl_header(&mut self, imp: &ty::ImplHeader<'tcx>) -> ty::ImplHeader<'tcx> {\n         imp.super_fold_with(self)\n     }\n \n     fn fold_substs(&mut self,\n-                   substs: &'tcx subst::Substs<'tcx>)\n-                   -> &'tcx subst::Substs<'tcx> {\n+                   substs: &'tcx Substs<'tcx>)\n+                   -> &'tcx Substs<'tcx> {\n         substs.super_fold_with(self)\n     }\n \n@@ -177,11 +173,6 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         r.super_fold_with(self)\n     }\n \n-    fn fold_existential_bounds(&mut self, s: &ty::ExistentialBounds<'tcx>)\n-                               -> ty::ExistentialBounds<'tcx> {\n-        s.super_fold_with(self)\n-    }\n-\n     fn fold_autoref(&mut self, ar: &adjustment::AutoRef<'tcx>)\n                     -> adjustment::AutoRef<'tcx> {\n         ar.super_fold_with(self)"}, {"sha": "1dcc623d3655868cf931b3538b6bfb6ca2faa524", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -322,7 +322,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n         ty::TyStruct(adt_def, _) |\n         ty::TyEnum(adt_def, _) => Some(adt_def.did),\n \n-        ty::TyTrait(ref data) => Some(data.principal_def_id()),\n+        ty::TyTrait(ref data) => Some(data.principal.def_id()),\n \n         ty::TyArray(subty, _) |\n         ty::TySlice(subty) |"}, {"sha": "d5686906e6a7b7c467d99894b4f80a85aa6d5ab0", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -10,7 +10,7 @@\n \n use dep_graph::{DepNode, DepTrackingMapConfig};\n use hir::def_id::DefId;\n-use ty;\n+use ty::{self, Ty};\n use std::marker::PhantomData;\n use std::rc::Rc;\n use syntax::{attr, ast};\n@@ -30,7 +30,8 @@ macro_rules! dep_map_ty {\n }\n \n dep_map_ty! { ImplOrTraitItems: ImplOrTraitItems(DefId) -> ty::ImplOrTraitItem<'tcx> }\n-dep_map_ty! { Tcache: ItemSignature(DefId) -> ty::TypeScheme<'tcx> }\n+dep_map_ty! { Tcache: ItemSignature(DefId) -> Ty<'tcx> }\n+dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { TraitItemDefIds: TraitItemDefIds(DefId) -> Rc<Vec<ty::ImplOrTraitItemId>> }"}, {"sha": "1f747ddfb295971c13e4a57de31e1fd1ce93ad31", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 132, "deletions": 148, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -28,7 +28,7 @@ use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangIte\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n use traits;\n use ty;\n-use ty::subst::{Subst, Substs, VecPerParamSpace};\n+use ty::subst::{Subst, Substs};\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n use util::nodemap::NodeSet;\n@@ -54,11 +54,13 @@ use hir::{ItemImpl, ItemTrait, PatKind};\n use hir::intravisit::Visitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n-pub use self::sty::{BuiltinBound, BuiltinBounds, ExistentialBounds};\n+pub use self::sty::{BuiltinBound, BuiltinBounds};\n pub use self::sty::{BareFnTy, FnSig, PolyFnSig};\n-pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n+pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n pub use self::sty::{ClosureSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n+pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n+pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::Issue32330;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n@@ -171,15 +173,14 @@ impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n                               -> ImplHeader<'tcx>\n     {\n         let tcx = selcx.tcx();\n-        let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n-        let impl_substs = selcx.infcx().fresh_substs_for_generics(DUMMY_SP, &impl_generics);\n+        let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n \n         let header = ImplHeader {\n             impl_def_id: impl_def_id,\n             self_ty: tcx.lookup_item_type(impl_def_id).ty,\n             trait_ref: tcx.impl_trait_ref(impl_def_id),\n-            predicates: tcx.lookup_predicates(impl_def_id).predicates.into_vec(),\n-        }.subst(tcx, &impl_substs);\n+            predicates: tcx.lookup_predicates(impl_def_id).predicates\n+        }.subst(tcx, impl_substs);\n \n         let traits::Normalized { value: mut header, obligations } =\n             traits::normalize(selcx, traits::ObligationCause::dummy(), &header);\n@@ -346,7 +347,7 @@ impl Visibility {\n #[derive(Clone, Debug)]\n pub struct Method<'tcx> {\n     pub name: Name,\n-    pub generics: Generics<'tcx>,\n+    pub generics: &'tcx Generics<'tcx>,\n     pub predicates: GenericPredicates<'tcx>,\n     pub fty: &'tcx BareFnTy<'tcx>,\n     pub explicit_self: ExplicitSelfCategory,\n@@ -358,7 +359,7 @@ pub struct Method<'tcx> {\n \n impl<'tcx> Method<'tcx> {\n     pub fn new(name: Name,\n-               generics: ty::Generics<'tcx>,\n+               generics: &'tcx ty::Generics<'tcx>,\n                predicates: GenericPredicates<'tcx>,\n                fty: &'tcx BareFnTy<'tcx>,\n                explicit_self: ExplicitSelfCategory,\n@@ -425,8 +426,17 @@ pub struct AssociatedType<'tcx> {\n \n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct ItemVariances {\n-    pub types: VecPerParamSpace<Variance>,\n-    pub regions: VecPerParamSpace<Variance>,\n+    pub types: Vec<Variance>,\n+    pub regions: Vec<Variance>,\n+}\n+\n+impl ItemVariances {\n+    pub fn empty() -> ItemVariances {\n+        ItemVariances {\n+            types: vec![],\n+            regions: vec![],\n+        }\n+    }\n }\n \n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Copy)]\n@@ -442,7 +452,7 @@ pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n     pub def_id: DefId,\n     pub ty: Ty<'tcx>,\n-    pub substs: &'tcx subst::Substs<'tcx>\n+    pub substs: &'tcx Substs<'tcx>\n }\n \n /// With method calls, we store some extra information in\n@@ -713,7 +723,6 @@ pub enum ObjectLifetimeDefault {\n pub struct TypeParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n-    pub space: subst::ParamSpace,\n     pub index: u32,\n     pub default_def_id: DefId, // for use in error reporing about defaults\n     pub default: Option<Ty<'tcx>>,\n@@ -724,15 +733,13 @@ pub struct TypeParameterDef<'tcx> {\n pub struct RegionParameterDef {\n     pub name: Name,\n     pub def_id: DefId,\n-    pub space: subst::ParamSpace,\n     pub index: u32,\n     pub bounds: Vec<ty::Region>,\n }\n \n impl RegionParameterDef {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            space: self.space,\n             index: self.index,\n             name: self.name,\n         })\n@@ -747,59 +754,53 @@ impl RegionParameterDef {\n /// with an item or method. Analogous to hir::Generics.\n #[derive(Clone, Debug)]\n pub struct Generics<'tcx> {\n-    pub types: VecPerParamSpace<TypeParameterDef<'tcx>>,\n-    pub regions: VecPerParamSpace<RegionParameterDef>,\n-}\n-\n-impl<'tcx> Generics<'tcx> {\n-    pub fn empty() -> Generics<'tcx> {\n-        Generics {\n-            types: VecPerParamSpace::empty(),\n-            regions: VecPerParamSpace::empty(),\n-        }\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.types.is_empty() && self.regions.is_empty()\n-    }\n-\n-    pub fn has_type_params(&self, space: subst::ParamSpace) -> bool {\n-        !self.types.is_empty_in(space)\n-    }\n-\n-    pub fn has_region_params(&self, space: subst::ParamSpace) -> bool {\n-        !self.regions.is_empty_in(space)\n-    }\n+    pub parent: Option<DefId>,\n+    pub parent_regions: u32,\n+    pub parent_types: u32,\n+    pub regions: Vec<RegionParameterDef>,\n+    pub types: Vec<TypeParameterDef<'tcx>>,\n+    pub has_self: bool,\n }\n \n /// Bounds on generics.\n #[derive(Clone)]\n pub struct GenericPredicates<'tcx> {\n-    pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n+    pub parent: Option<DefId>,\n+    pub predicates: Vec<Predicate<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n-    pub fn empty() -> GenericPredicates<'tcx> {\n-        GenericPredicates {\n-            predicates: VecPerParamSpace::empty(),\n-        }\n-    }\n-\n     pub fn instantiate(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                        -> InstantiatedPredicates<'tcx> {\n+        let mut instantiated = InstantiatedPredicates::empty();\n+        self.instantiate_into(tcx, &mut instantiated, substs);\n+        instantiated\n+    }\n+    pub fn instantiate_own(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n+                           -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n-            predicates: self.predicates.subst(tcx, substs),\n+            predicates: self.predicates.subst(tcx, substs)\n+        }\n+    }\n+\n+    fn instantiate_into(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        instantiated: &mut InstantiatedPredicates<'tcx>,\n+                        substs: &Substs<'tcx>) {\n+        if let Some(def_id) = self.parent {\n+            tcx.lookup_predicates(def_id).instantiate_into(tcx, instantiated, substs);\n         }\n+        instantiated.predicates.extend(self.predicates.iter().map(|p| p.subst(tcx, substs)))\n     }\n \n     pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n                                   -> InstantiatedPredicates<'tcx>\n     {\n+        assert_eq!(self.parent, None);\n         InstantiatedPredicates {\n-            predicates: self.predicates.map(|pred| {\n+            predicates: self.predicates.iter().map(|pred| {\n                 pred.subst_supertrait(tcx, poly_trait_ref)\n-            })\n+            }).collect()\n         }\n     }\n }\n@@ -808,7 +809,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n-    /// would be the parameters in the `TypeSpace`.\n+    /// would be the type parameters.\n     Trait(PolyTraitPredicate<'tcx>),\n \n     /// A predicate created by RFC1592\n@@ -833,9 +834,9 @@ pub enum Predicate<'tcx> {\n     /// trait must be object-safe\n     ObjectSafe(DefId),\n \n-    /// No direct syntax. May be thought of as `where T : FnFoo<...>` for some 'TypeSpace'\n-    /// substitutions `...` and T being a closure type.  Satisfied (or refuted) once we know the\n-    /// closure's kind.\n+    /// No direct syntax. May be thought of as `where T : FnFoo<...>`\n+    /// for some substitutions `...` and T being a closure type.\n+    /// Satisfied (or refuted) once we know the closure's kind.\n     ClosureKind(DefId, ClosureKind),\n }\n \n@@ -971,7 +972,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n     }\n \n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n-        self.trait_ref.substs.types.as_slice()\n+        &self.trait_ref.substs.types\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n@@ -1113,7 +1114,7 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn walk_tys(&self) -> IntoIter<Ty<'tcx>> {\n         let vec: Vec<_> = match *self {\n             ty::Predicate::Trait(ref data) => {\n-                data.0.trait_ref.substs.types.as_slice().to_vec()\n+                data.0.trait_ref.input_types().to_vec()\n             }\n             ty::Predicate::Rfc1592(ref data) => {\n                 return data.walk_tys()\n@@ -1128,7 +1129,7 @@ impl<'tcx> Predicate<'tcx> {\n                 vec![]\n             }\n             ty::Predicate::Projection(ref data) => {\n-                let trait_inputs = data.0.projection_ty.trait_ref.substs.types.as_slice();\n+                let trait_inputs = data.0.projection_ty.trait_ref.input_types();\n                 trait_inputs.iter()\n                             .cloned()\n                             .chain(Some(data.0.ty))\n@@ -1193,12 +1194,12 @@ impl<'tcx> Predicate<'tcx> {\n /// [usize:Bar<isize>]]`.\n #[derive(Clone)]\n pub struct InstantiatedPredicates<'tcx> {\n-    pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n+    pub predicates: Vec<Predicate<'tcx>>,\n }\n \n impl<'tcx> InstantiatedPredicates<'tcx> {\n     pub fn empty() -> InstantiatedPredicates<'tcx> {\n-        InstantiatedPredicates { predicates: VecPerParamSpace::empty() }\n+        InstantiatedPredicates { predicates: vec![] }\n     }\n \n     pub fn is_empty(&self) -> bool {\n@@ -1212,15 +1213,15 @@ impl<'tcx> TraitRef<'tcx> {\n     }\n \n     pub fn self_ty(&self) -> Ty<'tcx> {\n-        self.substs.self_ty().unwrap()\n+        self.substs.types[0]\n     }\n \n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n         // associated types.\n-        self.substs.types.as_slice()\n+        &self.substs.types\n     }\n }\n \n@@ -1286,23 +1287,17 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         // so for now just grab environment for the impl\n                         let impl_id = tcx.map.get_parent(id);\n                         let impl_def_id = tcx.map.local_def_id(impl_id);\n-                        let scheme = tcx.lookup_item_type(impl_def_id);\n-                        let predicates = tcx.lookup_predicates(impl_def_id);\n                         tcx.construct_parameter_environment(impl_item.span,\n-                                                            &scheme.generics,\n-                                                            &predicates,\n+                                                            impl_def_id,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     hir::ImplItemKind::Method(_, ref body) => {\n                         let method_def_id = tcx.map.local_def_id(id);\n                         match tcx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n-                                let method_generics = &method_ty.generics;\n-                                let method_bounds = &method_ty.predicates;\n                                 tcx.construct_parameter_environment(\n                                     impl_item.span,\n-                                    method_generics,\n-                                    method_bounds,\n+                                    method_ty.def_id,\n                                     tcx.region_maps.call_site_extent(id, body.id))\n                             }\n                             _ => {\n@@ -1320,11 +1315,8 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         // so for now just grab environment for the trait\n                         let trait_id = tcx.map.get_parent(id);\n                         let trait_def_id = tcx.map.local_def_id(trait_id);\n-                        let trait_def = tcx.lookup_trait_def(trait_def_id);\n-                        let predicates = tcx.lookup_predicates(trait_def_id);\n                         tcx.construct_parameter_environment(trait_item.span,\n-                                                            &trait_def.generics,\n-                                                            &predicates,\n+                                                            trait_def_id,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     hir::MethodTraitItem(_, ref body) => {\n@@ -1334,8 +1326,6 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         let method_def_id = tcx.map.local_def_id(id);\n                         match tcx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n-                                let method_generics = &method_ty.generics;\n-                                let method_bounds = &method_ty.predicates;\n                                 let extent = if let Some(ref body) = *body {\n                                     // default impl: use call_site extent as free_id_outlive bound.\n                                     tcx.region_maps.call_site_extent(id, body.id)\n@@ -1345,8 +1335,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                                 };\n                                 tcx.construct_parameter_environment(\n                                     trait_item.span,\n-                                    method_generics,\n-                                    method_bounds,\n+                                    method_ty.def_id,\n                                     extent)\n                             }\n                             _ => {\n@@ -1363,13 +1352,10 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     hir::ItemFn(_, _, _, _, _, ref body) => {\n                         // We assume this is a function.\n                         let fn_def_id = tcx.map.local_def_id(id);\n-                        let fn_scheme = tcx.lookup_item_type(fn_def_id);\n-                        let fn_predicates = tcx.lookup_predicates(fn_def_id);\n \n                         tcx.construct_parameter_environment(\n                             item.span,\n-                            &fn_scheme.generics,\n-                            &fn_predicates,\n+                            fn_def_id,\n                             tcx.region_maps.call_site_extent(id, body.id))\n                     }\n                     hir::ItemEnum(..) |\n@@ -1379,20 +1365,14 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     hir::ItemConst(..) |\n                     hir::ItemStatic(..) => {\n                         let def_id = tcx.map.local_def_id(id);\n-                        let scheme = tcx.lookup_item_type(def_id);\n-                        let predicates = tcx.lookup_predicates(def_id);\n                         tcx.construct_parameter_environment(item.span,\n-                                                            &scheme.generics,\n-                                                            &predicates,\n+                                                            def_id,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     hir::ItemTrait(..) => {\n                         let def_id = tcx.map.local_def_id(id);\n-                        let trait_def = tcx.lookup_trait_def(def_id);\n-                        let predicates = tcx.lookup_predicates(def_id);\n                         tcx.construct_parameter_environment(item.span,\n-                                                            &trait_def.generics,\n-                                                            &predicates,\n+                                                            def_id,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n                     _ => {\n@@ -1413,11 +1393,8 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             }\n             Some(ast_map::NodeForeignItem(item)) => {\n                 let def_id = tcx.map.local_def_id(id);\n-                let scheme = tcx.lookup_item_type(def_id);\n-                let predicates = tcx.lookup_predicates(def_id);\n                 tcx.construct_parameter_environment(item.span,\n-                                                    &scheme.generics,\n-                                                    &predicates,\n+                                                    def_id,\n                                                     ROOT_CODE_EXTENT)\n             }\n             _ => {\n@@ -1450,7 +1427,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n /// `lookup_predicates`.\n #[derive(Clone, Debug)]\n pub struct TypeScheme<'tcx> {\n-    pub generics: Generics<'tcx>,\n+    pub generics: &'tcx Generics<'tcx>,\n     pub ty: Ty<'tcx>,\n }\n \n@@ -1905,9 +1882,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                 };\n                 let sized_predicate = Binder(TraitRef {\n                     def_id: sized_trait,\n-                    substs: tcx.mk_substs(Substs::new_trait(\n-                        vec![], vec![], ty\n-                    ))\n+                    substs: Substs::new_trait(tcx, vec![], vec![], ty)\n                 }).to_predicate();\n                 let predicates = tcx.lookup_predicates(self.did).predicates;\n                 if predicates.into_iter().any(|p| p == sized_predicate) {\n@@ -2158,7 +2133,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn node_id_item_substs(self, id: NodeId) -> ItemSubsts<'gcx> {\n         match self.tables.borrow().item_substs.get(&id) {\n             None => ItemSubsts {\n-                substs: self.global_tcx().mk_substs(Substs::empty())\n+                substs: Substs::empty(self.global_tcx())\n             },\n             Some(ts) => ts.clone(),\n         }\n@@ -2496,27 +2471,36 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Register a given item type\n-    pub fn register_item_type(self, did: DefId, ty: TypeScheme<'gcx>) {\n-        self.tcache.borrow_mut().insert(did, ty);\n+    pub fn register_item_type(self, did: DefId, scheme: TypeScheme<'gcx>) {\n+        self.tcache.borrow_mut().insert(did, scheme.ty);\n+        self.generics.borrow_mut().insert(did, scheme.generics);\n     }\n \n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n     pub fn lookup_item_type(self, did: DefId) -> TypeScheme<'gcx> {\n-        lookup_locally_or_in_crate_store(\n+        let ty = lookup_locally_or_in_crate_store(\n             \"tcache\", did, &self.tcache,\n-            || self.sess.cstore.item_type(self.global_tcx(), did))\n+            || self.sess.cstore.item_type(self.global_tcx(), did));\n+\n+        TypeScheme {\n+            ty: ty,\n+            generics: self.lookup_generics(did)\n+        }\n     }\n \n     pub fn opt_lookup_item_type(self, did: DefId) -> Option<TypeScheme<'gcx>> {\n-        if let Some(scheme) = self.tcache.borrow_mut().get(&did) {\n-            return Some(scheme.clone());\n+        if did.krate != LOCAL_CRATE {\n+            return Some(self.lookup_item_type(did));\n         }\n \n-        if did.krate == LOCAL_CRATE {\n-            None\n+        if let Some(ty) = self.tcache.borrow().get(&did).cloned() {\n+            Some(TypeScheme {\n+                ty: ty,\n+                generics: self.lookup_generics(did)\n+            })\n         } else {\n-            Some(self.sess.cstore.item_type(self.global_tcx(), did))\n+            None\n         }\n     }\n \n@@ -2545,6 +2529,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.lookup_adt_def_master(did)\n     }\n \n+    /// Given the did of an item, returns its generics.\n+    pub fn lookup_generics(self, did: DefId) -> &'gcx Generics<'gcx> {\n+        lookup_locally_or_in_crate_store(\n+            \"generics\", did, &self.generics,\n+            || self.sess.cstore.item_generics(self.global_tcx(), did))\n+    }\n+\n     /// Given the did of an item, returns its full set of predicates.\n     pub fn lookup_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n@@ -2800,18 +2791,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// If the given def ID describes an item belonging to a trait (either a\n-    /// default method or an implementation of a trait method), return the ID of\n-    /// the trait that the method belongs to. Otherwise, return `None`.\n+    /// If the given def ID describes an item belonging to a trait,\n+    /// return the ID of the trait that the trait item belongs to.\n+    /// Otherwise, return `None`.\n     pub fn trait_of_item(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.trait_of_item(self.global_tcx(), def_id);\n+            return self.sess.cstore.trait_of_item(def_id);\n         }\n-        match self.impl_or_trait_items.borrow().get(&def_id).cloned() {\n+        match self.impl_or_trait_items.borrow().get(&def_id) {\n             Some(impl_or_trait_item) => {\n                 match impl_or_trait_item.container() {\n                     TraitContainer(def_id) => Some(def_id),\n-                    ImplContainer(def_id) => self.trait_id_of_impl(def_id),\n+                    ImplContainer(_) => None\n                 }\n             }\n             None => None\n@@ -2825,18 +2816,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// the same).\n     /// Otherwise, return `None`.\n     pub fn trait_item_of_item(self, def_id: DefId) -> Option<ImplOrTraitItemId> {\n-        let impl_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n+        let impl_or_trait_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n             Some(m) => m.clone(),\n             None => return None,\n         };\n-        let name = impl_item.name();\n-        match self.trait_of_item(def_id) {\n-            Some(trait_did) => {\n-                self.trait_items(trait_did).iter()\n-                    .find(|item| item.name() == name)\n-                    .map(|item| item.id())\n+        match impl_or_trait_item.container() {\n+            TraitContainer(_) => Some(impl_or_trait_item.id()),\n+            ImplContainer(def_id) => {\n+                self.trait_id_of_impl(def_id).and_then(|trait_did| {\n+                    let name = impl_or_trait_item.name();\n+                    self.trait_items(trait_did).iter()\n+                        .find(|item| item.name() == name)\n+                        .map(|item| item.id())\n+                })\n             }\n-            None => None\n         }\n     }\n \n@@ -2848,7 +2841,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // regions, so it shouldn't matter what we use for the free id\n         let free_id_outlive = self.region_maps.node_extent(ast::DUMMY_NODE_ID);\n         ty::ParameterEnvironment {\n-            free_substs: self.mk_substs(Substs::empty()),\n+            free_substs: Substs::empty(self),\n             caller_bounds: Vec::new(),\n             implicit_region_bound: ty::ReEmpty,\n             free_id_outlive: free_id_outlive\n@@ -2860,56 +2853,47 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// In general, this means converting from bound parameters to\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an effect on regions.\n-    pub fn construct_free_substs(self, generics: &Generics<'gcx>,\n-                                 free_id_outlive: CodeExtent) -> Substs<'gcx> {\n-        // map T => T\n-        let mut types = VecPerParamSpace::empty();\n-        for def in generics.types.as_slice() {\n-            debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n-                    def);\n-            types.push(def.space, self.global_tcx().mk_param_from_def(def));\n-        }\n+    pub fn construct_free_substs(self, def_id: DefId,\n+                                 free_id_outlive: CodeExtent)\n+                                 -> &'gcx Substs<'gcx> {\n \n-        // map bound 'a => free 'a\n-        let mut regions = VecPerParamSpace::empty();\n-        for def in generics.regions.as_slice() {\n-            let region =\n-                ReFree(FreeRegion { scope: free_id_outlive,\n-                                    bound_region: def.to_bound_region() });\n-            debug!(\"push_region_params {:?}\", region);\n-            regions.push(def.space, region);\n-        }\n+        let substs = Substs::for_item(self.global_tcx(), def_id, |def, _| {\n+            // map bound 'a => free 'a\n+            ReFree(FreeRegion { scope: free_id_outlive,\n+                                bound_region: def.to_bound_region() })\n+        }, |def, _| {\n+            // map T => T\n+            self.global_tcx().mk_param_from_def(def)\n+        });\n \n-        Substs {\n-            types: types,\n-            regions: regions,\n-        }\n+        debug!(\"construct_parameter_environment: {:?}\", substs);\n+        substs\n     }\n \n     /// See `ParameterEnvironment` struct def'n for details.\n     /// If you were using `free_id: NodeId`, you might try `self.region_maps.item_extent(free_id)`\n     /// for the `free_id_outlive` parameter. (But note that that is not always quite right.)\n     pub fn construct_parameter_environment(self,\n                                            span: Span,\n-                                           generics: &ty::Generics<'gcx>,\n-                                           generic_predicates: &ty::GenericPredicates<'gcx>,\n+                                           def_id: DefId,\n                                            free_id_outlive: CodeExtent)\n                                            -> ParameterEnvironment<'gcx>\n     {\n         //\n         // Construct the free substs.\n         //\n \n-        let free_substs = self.construct_free_substs(generics, free_id_outlive);\n+        let free_substs = self.construct_free_substs(def_id, free_id_outlive);\n \n         //\n         // Compute the bounds on Self and the type parameters.\n         //\n \n         let tcx = self.global_tcx();\n-        let bounds = generic_predicates.instantiate(tcx, &free_substs);\n+        let generic_predicates = tcx.lookup_predicates(def_id);\n+        let bounds = generic_predicates.instantiate(tcx, free_substs);\n         let bounds = tcx.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n-        let predicates = bounds.predicates.into_vec();\n+        let predicates = bounds.predicates;\n \n         // Finally, we have to normalize the bounds in the environment, in\n         // case they contain any associated type projections. This process\n@@ -2925,7 +2909,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //\n \n         let unnormalized_env = ty::ParameterEnvironment {\n-            free_substs: tcx.mk_substs(free_substs),\n+            free_substs: free_substs,\n             implicit_region_bound: ty::ReScope(free_id_outlive),\n             caller_bounds: predicates,\n             free_id_outlive: free_id_outlive,"}, {"sha": "abf863f953664258de01fbcbf4f0ba40b8603922", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 67, "deletions": 111, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -14,7 +14,7 @@\n //! type equality, etc.\n \n use hir::def_id::DefId;\n-use ty::subst::{ParamSpace, Substs};\n+use ty::subst::Substs;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::error::{ExpectedFound, TypeError};\n use std::rc::Rc;\n@@ -145,82 +145,21 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                                         -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n     where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n-    let mut substs = Substs::empty();\n-\n-    for &space in &ParamSpace::all() {\n-        let a_tps = a_subst.types.get_slice(space);\n-        let b_tps = b_subst.types.get_slice(space);\n-        let t_variances = variances.map(|v| v.types.get_slice(space));\n-        let tps = relate_type_params(relation, t_variances, a_tps, b_tps)?;\n-        substs.types.replace(space, tps);\n-    }\n-\n-    for &space in &ParamSpace::all() {\n-        let a_regions = a_subst.regions.get_slice(space);\n-        let b_regions = b_subst.regions.get_slice(space);\n-        let r_variances = variances.map(|v| v.regions.get_slice(space));\n-        let regions = relate_region_params(relation,\n-                                           r_variances,\n-                                           a_regions,\n-                                           b_regions)?;\n-        substs.regions.replace(space, regions);\n-    }\n+    let tcx = relation.tcx();\n \n-    Ok(relation.tcx().mk_substs(substs))\n-}\n+    let types = a_subst.types.iter().enumerate().map(|(i, a_ty)| {\n+        let b_ty = &b_subst.types[i];\n+        let variance = variances.map_or(ty::Invariant, |v| v.types[i]);\n+        relation.relate_with_variance(variance, a_ty, b_ty)\n+    }).collect()?;\n \n-fn relate_type_params<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                         variances: Option<&[ty::Variance]>,\n-                                         a_tys: &[Ty<'tcx>],\n-                                         b_tys: &[Ty<'tcx>])\n-                                         -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n-{\n-    if a_tys.len() != b_tys.len() {\n-        return Err(TypeError::TyParamSize(expected_found(relation,\n-                                                         &a_tys.len(),\n-                                                         &b_tys.len())));\n-    }\n+    let regions = a_subst.regions.iter().enumerate().map(|(i, a_r)| {\n+        let b_r = &b_subst.regions[i];\n+        let variance = variances.map_or(ty::Invariant, |v| v.regions[i]);\n+        relation.relate_with_variance(variance, a_r, b_r)\n+    }).collect()?;\n \n-    (0 .. a_tys.len())\n-        .map(|i| {\n-            let a_ty = a_tys[i];\n-            let b_ty = b_tys[i];\n-            let v = variances.map_or(ty::Invariant, |v| v[i]);\n-            relation.relate_with_variance(v, &a_ty, &b_ty)\n-        })\n-        .collect()\n-}\n-\n-fn relate_region_params<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                           variances: Option<&[ty::Variance]>,\n-                                           a_rs: &[ty::Region],\n-                                           b_rs: &[ty::Region])\n-                                           -> RelateResult<'tcx, Vec<ty::Region>>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n-{\n-    let num_region_params = a_rs.len();\n-\n-    debug!(\"relate_region_params(a_rs={:?}, \\\n-            b_rs={:?}, variances={:?})\",\n-           a_rs,\n-           b_rs,\n-           variances);\n-\n-    assert_eq!(num_region_params,\n-               variances.map_or(num_region_params,\n-                                |v| v.len()));\n-\n-    assert_eq!(num_region_params, b_rs.len());\n-\n-    (0..a_rs.len())\n-        .map(|i| {\n-            let a_r = a_rs[i];\n-            let b_r = b_rs[i];\n-            let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-            relation.relate_with_variance(variance, &a_r, &b_r)\n-        })\n-        .collect()\n+    Ok(Substs::new(tcx, types, regions))\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::BareFnTy<'tcx> {\n@@ -326,24 +265,33 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n+impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::ProjectionPredicate<'tcx>,\n-                           b: &ty::ProjectionPredicate<'tcx>)\n-                           -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n+                           a: &ty::ExistentialProjection<'tcx>,\n+                           b: &ty::ExistentialProjection<'tcx>)\n+                           -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n-        let projection_ty = relation.relate(&a.projection_ty, &b.projection_ty)?;\n-        let ty = relation.relate(&a.ty, &b.ty)?;\n-        Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n+        if a.item_name != b.item_name {\n+            Err(TypeError::ProjectionNameMismatched(\n+                expected_found(relation, &a.item_name, &b.item_name)))\n+        } else {\n+            let trait_ref = relation.relate(&a.trait_ref, &b.trait_ref)?;\n+            let ty = relation.relate(&a.ty, &b.ty)?;\n+            Ok(ty::ExistentialProjection {\n+                trait_ref: trait_ref,\n+                item_name: a.item_name,\n+                ty: ty\n+            })\n+        }\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n+impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n-                           b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                           -> RelateResult<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n+                           a: &Vec<ty::PolyExistentialProjection<'tcx>>,\n+                           b: &Vec<ty::PolyExistentialProjection<'tcx>>)\n+                           -> RelateResult<'tcx, Vec<ty::PolyExistentialProjection<'tcx>>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         // To be compatible, `a` and `b` must be for precisely the\n@@ -361,27 +309,6 @@ impl<'tcx> Relate<'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::ExistentialBounds<'tcx>,\n-                           b: &ty::ExistentialBounds<'tcx>)\n-                           -> RelateResult<'tcx, ty::ExistentialBounds<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n-    {\n-        let r =\n-            relation.with_cause(\n-                Cause::ExistentialRegionBound,\n-                |relation| relation.relate_with_variance(ty::Contravariant,\n-                                                         &a.region_bound,\n-                                                         &b.region_bound))?;\n-        let nb = relation.relate(&a.builtin_bounds, &b.builtin_bounds)?;\n-        let pb = relation.relate(&a.projection_bounds, &b.projection_bounds)?;\n-        Ok(ty::ExistentialBounds { region_bound: r,\n-                                   builtin_bounds: nb,\n-                                   projection_bounds: pb })\n-    }\n-}\n-\n impl<'tcx> Relate<'tcx> for ty::BuiltinBounds {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &ty::BuiltinBounds,\n@@ -416,6 +343,23 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::ExistentialTraitRef<'tcx>,\n+                           b: &ty::ExistentialTraitRef<'tcx>)\n+                           -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    {\n+        // Different traits cannot be related\n+        if a.def_id != b.def_id {\n+            Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n+        } else {\n+            let substs = relate_item_substs(relation, a.def_id, a.substs, b.substs)?;\n+            Ok(ty::ExistentialTraitRef { def_id: a.def_id, substs: substs })\n+        }\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &Ty<'tcx>,\n@@ -466,7 +410,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         }\n \n         (&ty::TyParam(ref a_p), &ty::TyParam(ref b_p))\n-            if a_p.idx == b_p.idx && a_p.space == b_p.space =>\n+            if a_p.idx == b_p.idx =>\n         {\n             Ok(a)\n         }\n@@ -478,11 +422,23 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_enum(a_def, substs))\n         }\n \n-        (&ty::TyTrait(ref a_), &ty::TyTrait(ref b_)) =>\n+        (&ty::TyTrait(ref a_obj), &ty::TyTrait(ref b_obj)) =>\n         {\n-            let principal = relation.relate(&a_.principal, &b_.principal)?;\n-            let bounds = relation.relate(&a_.bounds, &b_.bounds)?;\n-            Ok(tcx.mk_trait(principal, bounds))\n+            let principal = relation.relate(&a_obj.principal, &b_obj.principal)?;\n+            let r =\n+                relation.with_cause(\n+                    Cause::ExistentialRegionBound,\n+                    |relation| relation.relate_with_variance(ty::Contravariant,\n+                                                             &a_obj.region_bound,\n+                                                             &b_obj.region_bound))?;\n+            let nb = relation.relate(&a_obj.builtin_bounds, &b_obj.builtin_bounds)?;\n+            let pb = relation.relate(&a_obj.projection_bounds, &b_obj.projection_bounds)?;\n+            Ok(tcx.mk_trait(ty::TraitObject {\n+                principal: principal,\n+                region_bound: r,\n+                builtin_bounds: nb,\n+                projection_bounds: pb\n+            }))\n         }\n \n         (&ty::TyStruct(a_def, a_substs), &ty::TyStruct(b_def, b_substs))"}, {"sha": "f7c4b9938c2794da4c37b619277b6346dd2dee9a", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 66, "deletions": 86, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use infer::type_variable;\n-use ty::subst::{self, VecPerParamSpace};\n-use ty::{self, Lift, TraitRef, Ty, TyCtxt};\n+use ty::subst::Substs;\n+use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::rc::Rc;\n@@ -80,10 +80,20 @@ impl<'tcx> Lift<'tcx> for ty::Region {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n-    type Lifted = TraitRef<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<TraitRef<'tcx>> {\n-        tcx.lift(&self.substs).map(|substs| TraitRef {\n+impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n+    type Lifted = ty::TraitRef<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.substs).map(|substs| ty::TraitRef {\n+            def_id: self.def_id,\n+            substs: substs\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n+    type Lifted = ty::ExistentialTraitRef<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.substs).map(|substs| ty::ExistentialTraitRef {\n             def_id: self.def_id,\n             substs: substs\n         })\n@@ -141,6 +151,19 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n+    type Lifted = ty::ExistentialProjection<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&(self.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n+            ty::ExistentialProjection {\n+                trait_ref: trait_ref,\n+                item_name: self.item_name,\n+                ty: ty\n+            }\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n     type Lifted = ty::Predicate<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -427,26 +450,20 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n     }\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        self.map(|elem| elem.fold_with(folder))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|elem| elem.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitTy<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TraitTy {\n+        ty::TraitObject {\n             principal: self.principal.fold_with(folder),\n-            bounds: self.bounds.fold_with(folder),\n+            region_bound: self.region_bound.fold_with(folder),\n+            builtin_bounds: self.builtin_bounds,\n+            projection_bounds: self.projection_bounds.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.principal.visit_with(visitor) || self.bounds.visit_with(visitor)\n+        self.principal.visit_with(visitor) ||\n+        self.region_bound.visit_with(visitor) ||\n+        self.projection_bounds.visit_with(visitor)\n     }\n }\n \n@@ -599,8 +616,17 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n         }\n     }\n \n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_trait_ref(self)\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.substs.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialTraitRef<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::ExistentialTraitRef {\n+            def_id: self.def_id,\n+            substs: self.substs.fold_with(folder),\n+        }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n@@ -666,13 +692,11 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx subst::Substs<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let substs = subst::Substs {\n-            regions: self.regions.fold_with(folder),\n-            types: self.types.fold_with(folder)\n-        };\n-        folder.tcx().mk_substs(substs)\n+        let types = self.types.fold_with(folder);\n+        let regions = self.regions.fold_with(folder);\n+        Substs::new(folder.tcx(), types, regions)\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n@@ -741,30 +765,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ExistentialBounds {\n-            region_bound: self.region_bound.fold_with(folder),\n-            builtin_bounds: self.builtin_bounds,\n-            projection_bounds: self.projection_bounds.fold_with(folder),\n-        }\n-    }\n-\n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_existential_bounds(self)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.region_bound.visit_with(visitor) || self.projection_bounds.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TypeParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n-            space: self.space,\n             index: self.index,\n             default: self.default.fold_with(folder),\n             default_def_id: self.default_def_id,\n@@ -805,7 +810,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n         ty::RegionParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n-            space: self.space,\n             index: self.index,\n             bounds: self.bounds.fold_with(folder),\n         }\n@@ -816,31 +820,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::Generics {\n-            types: self.types.fold_with(folder),\n-            regions: self.regions.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.types.visit_with(visitor) || self.regions.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::GenericPredicates {\n-            predicates: self.predicates.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.predicates.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n@@ -893,6 +872,20 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialProjection<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::ExistentialProjection {\n+            trait_ref: self.trait_ref.fold_with(folder),\n+            item_name: self.item_name,\n+            ty: self.ty.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.trait_ref.visit_with(visitor) || self.ty.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ProjectionTy {\n@@ -986,19 +979,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TypeScheme<'tcx>  {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TypeScheme {\n-            generics: self.generics.fold_with(folder),\n-            ty: self.ty.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.generics.visit_with(visitor) || self.ty.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::error::ExpectedFound<T> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::error::ExpectedFound {"}, {"sha": "8aa81cc4743c9a639c598863af8fd956f5986215", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 97, "deletions": 95, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -13,7 +13,7 @@\n use middle::cstore;\n use hir::def_id::DefId;\n use middle::region;\n-use ty::subst::{self, Substs};\n+use ty::subst::Substs;\n use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TyS, TypeFoldable};\n use util::common::ErrorReported;\n \n@@ -152,7 +152,7 @@ pub enum TypeVariants<'tcx> {\n     TyFnPtr(&'tcx BareFnTy<'tcx>),\n \n     /// A trait, defined with `trait`.\n-    TyTrait(Box<TraitTy<'tcx>>),\n+    TyTrait(Box<TraitObject<'tcx>>),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n@@ -291,57 +291,11 @@ impl<'tcx> Decodable for ClosureSubsts<'tcx> {\n }\n \n #[derive(Clone, PartialEq, Eq, Hash)]\n-pub struct TraitTy<'tcx> {\n-    pub principal: ty::PolyTraitRef<'tcx>,\n-    pub bounds: ExistentialBounds<'tcx>,\n-}\n-\n-impl<'a, 'gcx, 'tcx> TraitTy<'tcx> {\n-    pub fn principal_def_id(&self) -> DefId {\n-        self.principal.0.def_id\n-    }\n-\n-    /// Object types don't have a self-type specified. Therefore, when\n-    /// we convert the principal trait-ref into a normal trait-ref,\n-    /// you must give *some* self-type. A common choice is `mk_err()`\n-    /// or some skolemized type.\n-    pub fn principal_trait_ref_with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            self_ty: Ty<'tcx>)\n-                                            -> ty::PolyTraitRef<'tcx>\n-    {\n-        // otherwise the escaping regions would be captured by the binder\n-        assert!(!self_ty.has_escaping_regions());\n-\n-        ty::Binder(TraitRef {\n-            def_id: self.principal.0.def_id,\n-            substs: tcx.mk_substs(self.principal.0.substs.with_self_ty(self_ty)),\n-        })\n-    }\n-\n-    pub fn projection_bounds_with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                          self_ty: Ty<'tcx>)\n-                                          -> Vec<ty::PolyProjectionPredicate<'tcx>>\n-    {\n-        // otherwise the escaping regions would be captured by the binders\n-        assert!(!self_ty.has_escaping_regions());\n-\n-        self.bounds.projection_bounds.iter()\n-            .map(|in_poly_projection_predicate| {\n-                let in_projection_ty = &in_poly_projection_predicate.0.projection_ty;\n-                let substs = tcx.mk_substs(in_projection_ty.trait_ref.substs.with_self_ty(self_ty));\n-                let trait_ref = ty::TraitRef::new(in_projection_ty.trait_ref.def_id,\n-                                              substs);\n-                let projection_ty = ty::ProjectionTy {\n-                    trait_ref: trait_ref,\n-                    item_name: in_projection_ty.item_name\n-                };\n-                ty::Binder(ty::ProjectionPredicate {\n-                    projection_ty: projection_ty,\n-                    ty: in_poly_projection_predicate.0.ty\n-                })\n-            })\n-            .collect()\n-    }\n+pub struct TraitObject<'tcx> {\n+    pub principal: PolyExistentialTraitRef<'tcx>,\n+    pub region_bound: ty::Region,\n+    pub builtin_bounds: BuiltinBounds,\n+    pub projection_bounds: Vec<PolyExistentialProjection<'tcx>>,\n }\n \n /// A complete reference to a trait. These take numerous guises in syntax,\n@@ -350,8 +304,8 @@ impl<'a, 'gcx, 'tcx> TraitTy<'tcx> {\n ///     T : Foo<U>\n ///\n /// This would be represented by a trait-reference where the def-id is the\n-/// def-id for the trait `Foo` and the substs defines `T` as parameter 0 in the\n-/// `SelfSpace` and `U` as parameter 0 in the `TypeSpace`.\n+/// def-id for the trait `Foo` and the substs define `T` as parameter 0,\n+/// and `U` as parameter 1.\n ///\n /// Trait references also appear in object types like `Foo<U>`, but in\n /// that case the `Self` parameter is absent from the substitutions.\n@@ -392,6 +346,42 @@ impl<'tcx> PolyTraitRef<'tcx> {\n     }\n }\n \n+/// An existential reference to a trait, where `Self` is erased.\n+/// For example, the trait object `Trait<'a, 'b, X, Y>` is:\n+///\n+///     exists T. T: Trait<'a, 'b, X, Y>\n+///\n+/// The substitutions don't include the erased `Self`, only trait\n+/// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct ExistentialTraitRef<'tcx> {\n+    pub def_id: DefId,\n+    pub substs: &'tcx Substs<'tcx>,\n+}\n+\n+impl<'tcx> ExistentialTraitRef<'tcx> {\n+    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+        // Select only the \"input types\" from a trait-reference. For\n+        // now this is all the types that appear in the\n+        // trait-reference, but it should eventually exclude\n+        // associated types.\n+        &self.substs.types\n+    }\n+}\n+\n+pub type PolyExistentialTraitRef<'tcx> = Binder<ExistentialTraitRef<'tcx>>;\n+\n+impl<'tcx> PolyExistentialTraitRef<'tcx> {\n+    pub fn def_id(&self) -> DefId {\n+        self.0.def_id\n+    }\n+\n+    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+        // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n+        self.0.input_types()\n+    }\n+}\n+\n /// Binder is a binder for higher-ranked lifetimes. It is part of the\n /// compiler's representation for things like `for<'a> Fn(&'a isize)`\n /// (which would be represented by the type `PolyTraitRef ==\n@@ -508,33 +498,34 @@ impl<'tcx> PolyFnSig<'tcx> {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ParamTy {\n-    pub space: subst::ParamSpace,\n     pub idx: u32,\n     pub name: Name,\n }\n \n impl<'a, 'gcx, 'tcx> ParamTy {\n-    pub fn new(space: subst::ParamSpace,\n-               index: u32,\n-               name: Name)\n-               -> ParamTy {\n-        ParamTy { space: space, idx: index, name: name }\n+    pub fn new(index: u32, name: Name) -> ParamTy {\n+        ParamTy { idx: index, name: name }\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(subst::SelfSpace, 0, keywords::SelfType.name())\n+        ParamTy::new(0, keywords::SelfType.name())\n     }\n \n     pub fn for_def(def: &ty::TypeParameterDef) -> ParamTy {\n-        ParamTy::new(def.space, def.index, def.name)\n+        ParamTy::new(def.index, def.name)\n     }\n \n     pub fn to_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        tcx.mk_param(self.space, self.idx, self.name)\n+        tcx.mk_param(self.idx, self.name)\n     }\n \n     pub fn is_self(&self) -> bool {\n-        self.space == subst::SelfSpace && self.idx == 0\n+        if self.name == keywords::SelfType.name() {\n+            assert_eq!(self.idx, 0);\n+            true\n+        } else {\n+            false\n+        }\n     }\n }\n \n@@ -686,7 +677,6 @@ pub enum Region {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n-    pub space: subst::ParamSpace,\n     pub index: u32,\n     pub name: Name,\n }\n@@ -730,27 +720,40 @@ pub enum InferTy {\n     FreshFloatTy(u32)\n }\n \n-/// Bounds suitable for an existentially quantified type parameter\n-/// such as those that appear in object types or closure types.\n-#[derive(PartialEq, Eq, Hash, Clone)]\n-pub struct ExistentialBounds<'tcx> {\n-    pub region_bound: ty::Region,\n-    pub builtin_bounds: BuiltinBounds,\n-    pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n+/// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub struct ExistentialProjection<'tcx> {\n+    pub trait_ref: ExistentialTraitRef<'tcx>,\n+    pub item_name: Name,\n+    pub ty: Ty<'tcx>\n }\n \n-impl<'tcx> ExistentialBounds<'tcx> {\n-    pub fn new(region_bound: ty::Region,\n-               builtin_bounds: BuiltinBounds,\n-               projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>)\n-               -> Self {\n-        let mut projection_bounds = projection_bounds;\n-        projection_bounds.sort_by(|a, b| a.sort_key().cmp(&b.sort_key()));\n-        ExistentialBounds {\n-            region_bound: region_bound,\n-            builtin_bounds: builtin_bounds,\n-            projection_bounds: projection_bounds\n-        }\n+pub type PolyExistentialProjection<'tcx> = Binder<ExistentialProjection<'tcx>>;\n+\n+impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n+    pub fn item_name(&self) -> Name {\n+        self.0.item_name // safe to skip the binder to access a name\n+    }\n+\n+    pub fn sort_key(&self) -> (DefId, Name) {\n+        (self.0.trait_ref.def_id, self.0.item_name)\n+    }\n+\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        self_ty: Ty<'tcx>)\n+                        -> ty::PolyProjectionPredicate<'tcx>\n+    {\n+        // otherwise the escaping regions would be captured by the binders\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        let trait_ref = self.map_bound(|proj| proj.trait_ref);\n+        self.map_bound(|proj| ty::ProjectionPredicate {\n+            projection_ty: ty::ProjectionTy {\n+                trait_ref: trait_ref.with_self_ty(tcx, self_ty).0,\n+                item_name: proj.item_name\n+            },\n+            ty: proj.ty\n+        })\n     }\n }\n \n@@ -942,16 +945,16 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_bool(&self) -> bool { self.sty == TyBool }\n \n-    pub fn is_param(&self, space: subst::ParamSpace, index: u32) -> bool {\n+    pub fn is_param(&self, index: u32) -> bool {\n         match self.sty {\n-            ty::TyParam(ref data) => data.space == space && data.idx == index,\n+            ty::TyParam(ref data) => data.idx == index,\n             _ => false,\n         }\n     }\n \n     pub fn is_self(&self) -> bool {\n         match self.sty {\n-            TyParam(ref p) => p.space == subst::SelfSpace,\n+            TyParam(ref p) => p.is_self(),\n             _ => false\n         }\n     }\n@@ -1185,7 +1188,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn ty_to_def_id(&self) -> Option<DefId> {\n         match self.sty {\n-            TyTrait(ref tt) => Some(tt.principal_def_id()),\n+            TyTrait(ref tt) => Some(tt.principal.def_id()),\n             TyStruct(def, _) |\n             TyEnum(def, _) => Some(def.did),\n             TyClosure(id, _) => Some(id),\n@@ -1209,21 +1212,20 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 vec![*region]\n             }\n             TyTrait(ref obj) => {\n-                let mut v = vec![obj.bounds.region_bound];\n-                v.extend_from_slice(obj.principal.skip_binder()\n-                                       .substs.regions.as_slice());\n+                let mut v = vec![obj.region_bound];\n+                v.extend_from_slice(&obj.principal.skip_binder().substs.regions);\n                 v\n             }\n             TyEnum(_, substs) |\n             TyStruct(_, substs) |\n             TyAnon(_, substs) => {\n-                substs.regions.as_slice().to_vec()\n+                substs.regions.to_vec()\n             }\n             TyClosure(_, ref substs) => {\n-                substs.func_substs.regions.as_slice().to_vec()\n+                substs.func_substs.regions.to_vec()\n             }\n             TyProjection(ref data) => {\n-                data.trait_ref.substs.regions.as_slice().to_vec()\n+                data.trait_ref.substs.regions.to_vec()\n             }\n             TyFnDef(..) |\n             TyFnPtr(_) |"}, {"sha": "e1a19a7b7992ece6edcae09a1b47a11f422cbaea", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 145, "deletions": 463, "changes": 608, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -10,132 +10,127 @@\n \n // Type substitutions.\n \n-pub use self::ParamSpace::*;\n-\n use middle::cstore;\n use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n \n use serialize::{Encodable, Encoder, Decodable, Decoder};\n-use std::fmt;\n-use std::iter::IntoIterator;\n-use std::slice::Iter;\n-use std::vec::{Vec, IntoIter};\n use syntax_pos::{Span, DUMMY_SP};\n \n ///////////////////////////////////////////////////////////////////////////\n \n-/// A substitution mapping type/region parameters to new values. We\n-/// identify each in-scope parameter by an *index* and a *parameter\n-/// space* (which indices where the parameter is defined; see\n-/// `ParamSpace`).\n+/// A substitution mapping type/region parameters to new values.\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Substs<'tcx> {\n-    pub types: VecPerParamSpace<Ty<'tcx>>,\n-    pub regions: VecPerParamSpace<ty::Region>,\n+    pub types: Vec<Ty<'tcx>>,\n+    pub regions: Vec<ty::Region>,\n }\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n-    pub fn new(t: VecPerParamSpace<Ty<'tcx>>,\n-               r: VecPerParamSpace<ty::Region>)\n-               -> Substs<'tcx>\n-    {\n-        Substs { types: t, regions: r }\n-    }\n-\n-    pub fn new_type(t: Vec<Ty<'tcx>>,\n-                    r: Vec<ty::Region>)\n-                    -> Substs<'tcx>\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+               t: Vec<Ty<'tcx>>,\n+               r: Vec<ty::Region>)\n+               -> &'tcx Substs<'tcx>\n     {\n-        Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new()),\n-                    VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n+        tcx.mk_substs(Substs { types: t, regions: r })\n     }\n \n-    pub fn new_trait(t: Vec<Ty<'tcx>>,\n+    pub fn new_trait(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                     mut t: Vec<Ty<'tcx>>,\n                      r: Vec<ty::Region>,\n                      s: Ty<'tcx>)\n-                    -> Substs<'tcx>\n+                    -> &'tcx Substs<'tcx>\n     {\n-        Substs::new(VecPerParamSpace::new(t, vec!(s), Vec::new()),\n-                    VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n-    }\n-\n-    pub fn empty() -> Substs<'tcx> {\n-        Substs {\n-            types: VecPerParamSpace::empty(),\n-            regions: VecPerParamSpace::empty(),\n-        }\n-    }\n+        t.insert(0, s);\n+        Substs::new(tcx, t, r)\n+    }\n+\n+    pub fn empty(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx Substs<'tcx> {\n+        Substs::new(tcx, vec![], vec![])\n+    }\n+\n+    /// Creates a Substs for generic parameter definitions,\n+    /// by calling closures to obtain each region and type.\n+    /// The closures get to observe the Substs as they're\n+    /// being built, which can be used to correctly\n+    /// substitute defaults of type parameters.\n+    pub fn for_item<FR, FT>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                            def_id: DefId,\n+                            mut mk_region: FR,\n+                            mut mk_type: FT)\n+                            -> &'tcx Substs<'tcx>\n+    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n+        let defs = tcx.lookup_generics(def_id);\n+        let num_regions = defs.parent_regions as usize + defs.regions.len();\n+        let num_types = defs.parent_types as usize + defs.types.len();\n+        let mut substs = Substs {\n+            regions: Vec::with_capacity(num_regions),\n+            types: Vec::with_capacity(num_types)\n+        };\n \n-    pub fn is_noop(&self) -> bool {\n-        self.regions.is_empty() && self.types.is_empty()\n-    }\n+        substs.fill_item(tcx, defs, &mut mk_region, &mut mk_type);\n \n-    pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n-        *self.types.get(ty_param_def.space, ty_param_def.index as usize)\n+        Substs::new(tcx, substs.types, substs.regions)\n     }\n \n-    pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n-        self.types.get_self().cloned()\n-    }\n+    fn fill_item<FR, FT>(&mut self,\n+                         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                         defs: &ty::Generics<'tcx>,\n+                         mk_region: &mut FR,\n+                         mk_type: &mut FT)\n+    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n+        if let Some(def_id) = defs.parent {\n+            let parent_defs = tcx.lookup_generics(def_id);\n+            self.fill_item(tcx, parent_defs, mk_region, mk_type);\n+        }\n \n-    pub fn with_self_ty(&self, self_ty: Ty<'tcx>) -> Substs<'tcx> {\n-        assert!(self.self_ty().is_none());\n-        let mut s = (*self).clone();\n-        s.types.push(SelfSpace, self_ty);\n-        s\n-    }\n+        for def in &defs.regions {\n+            let region = mk_region(def, self);\n+            assert_eq!(def.index as usize, self.regions.len());\n+            self.regions.push(region);\n+        }\n \n-    pub fn erase_regions(self) -> Substs<'tcx> {\n-        let Substs { types, regions } = self;\n-        let regions = regions.map(|_| ty::ReErased);\n-        Substs { types: types, regions: regions }\n+        for def in &defs.types {\n+            let ty = mk_type(def, self);\n+            assert_eq!(def.index as usize, self.types.len());\n+            self.types.push(ty);\n+        }\n     }\n \n-    pub fn with_method(self,\n-                       m_types: Vec<Ty<'tcx>>,\n-                       m_regions: Vec<ty::Region>)\n-                       -> Substs<'tcx>\n-    {\n-        let Substs { types, regions } = self;\n-        let types = types.with_slice(FnSpace, &m_types);\n-        let regions = regions.with_slice(FnSpace, &m_regions);\n-        Substs { types: types, regions: regions }\n+    pub fn is_noop(&self) -> bool {\n+        self.regions.is_empty() && self.types.is_empty()\n     }\n \n-    pub fn with_method_from(&self,\n-                            meth_substs: &Substs<'tcx>)\n-                            -> Substs<'tcx>\n-    {\n-        let Substs { types, regions } = self.clone();\n-        let types = types.with_slice(FnSpace, meth_substs.types.get_slice(FnSpace));\n-        let regions = regions.with_slice(FnSpace, meth_substs.regions.get_slice(FnSpace));\n-        Substs { types: types, regions: regions }\n+    pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n+        self.types[ty_param_def.index as usize]\n     }\n \n-    pub fn with_method_from_subst(&self, other: &Substs<'tcx>) -> Substs<'tcx> {\n-        let Substs { types, regions } = self.clone();\n-        let types = types.with_slice(FnSpace, other.types.get_slice(FnSpace));\n-        let regions = regions.with_slice(FnSpace, other.regions.get_slice(FnSpace));\n-        Substs { types: types, regions: regions }\n+    pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> ty::Region {\n+        self.regions[def.index as usize]\n     }\n \n-    /// Creates a trait-ref out of this substs, ignoring the FnSpace substs\n-    pub fn to_trait_ref(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, trait_id: DefId)\n-                        -> ty::TraitRef<'tcx> {\n-        let Substs { mut types, mut regions } = self.clone();\n-        types.truncate(FnSpace, 0);\n-        regions.truncate(FnSpace, 0);\n-\n-        ty::TraitRef {\n-            def_id: trait_id,\n-            substs: tcx.mk_substs(Substs { types: types, regions: regions })\n-        }\n+    /// Transform from substitutions for a child of `source_ancestor`\n+    /// (e.g. a trait or impl) to substitutions for the same child\n+    /// in a different item, with `target_substs` as the base for\n+    /// the target impl/trait, with the source child-specific\n+    /// parameters (e.g. method parameters) on top of that base.\n+    pub fn rebase_onto(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                       source_ancestor: DefId,\n+                       target_substs: &Substs<'tcx>)\n+                       -> &'tcx Substs<'tcx> {\n+        let defs = tcx.lookup_generics(source_ancestor);\n+        let regions = target_substs.regions.iter()\n+            .chain(&self.regions[defs.regions.len()..]).cloned().collect();\n+        let types = target_substs.types.iter()\n+            .chain(&self.types[defs.types.len()..]).cloned().collect();\n+        Substs::new(tcx, types, regions)\n     }\n }\n \n-impl<'tcx> Encodable for Substs<'tcx> {\n+impl<'tcx> Encodable for &'tcx Substs<'tcx> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         cstore::tls::with_encoding_context(s, |ecx, rbml_w| {\n             ecx.encode_substs(rbml_w, self);\n@@ -144,384 +139,16 @@ impl<'tcx> Encodable for Substs<'tcx> {\n     }\n }\n \n-impl<'tcx> Decodable for Substs<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Substs<'tcx>, D::Error> {\n-        cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n-            Ok(dcx.decode_substs(rbml_r))\n-        })\n-    }\n-}\n-\n impl<'tcx> Decodable for &'tcx Substs<'tcx> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<&'tcx Substs<'tcx>, D::Error> {\n         let substs = cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n-            let substs = dcx.decode_substs(rbml_r);\n-            dcx.tcx().mk_substs(substs)\n+            dcx.decode_substs(rbml_r)\n         });\n \n         Ok(substs)\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// ParamSpace\n-\n-#[derive(PartialOrd, Ord, PartialEq, Eq, Copy,\n-           Clone, Hash, RustcEncodable, RustcDecodable, Debug)]\n-pub enum ParamSpace {\n-    TypeSpace,  // Type parameters attached to a type definition, trait, or impl\n-    SelfSpace,  // Self parameter on a trait\n-    FnSpace,    // Type parameters attached to a method or fn\n-}\n-\n-impl ParamSpace {\n-    pub fn all() -> [ParamSpace; 3] {\n-        [TypeSpace, SelfSpace, FnSpace]\n-    }\n-\n-    pub fn to_uint(self) -> usize {\n-        match self {\n-            TypeSpace => 0,\n-            SelfSpace => 1,\n-            FnSpace => 2,\n-        }\n-    }\n-\n-    pub fn from_uint(u: usize) -> ParamSpace {\n-        match u {\n-            0 => TypeSpace,\n-            1 => SelfSpace,\n-            2 => FnSpace,\n-            _ => bug!(\"Invalid ParamSpace: {}\", u)\n-        }\n-    }\n-}\n-\n-/// Vector of things sorted by param space. Used to keep\n-/// the set of things declared on the type, self, or method\n-/// distinct.\n-#[derive(PartialEq, Eq, Clone, Hash, RustcEncodable, RustcDecodable)]\n-pub struct VecPerParamSpace<T> {\n-    // This was originally represented as a tuple with one Vec<T> for\n-    // each variant of ParamSpace, and that remains the abstraction\n-    // that it provides to its clients.\n-    //\n-    // Here is how the representation corresponds to the abstraction\n-    // i.e. the \"abstraction function\" AF:\n-    //\n-    // AF(self) = (self.content[..self.type_limit],\n-    //             self.content[self.type_limit..self.self_limit],\n-    //             self.content[self.self_limit..])\n-    type_limit: usize,\n-    self_limit: usize,\n-    content: Vec<T>,\n-}\n-\n-/// The `split` function converts one `VecPerParamSpace` into this\n-/// `SeparateVecsPerParamSpace` structure.\n-pub struct SeparateVecsPerParamSpace<T> {\n-    pub types: Vec<T>,\n-    pub selfs: Vec<T>,\n-    pub fns: Vec<T>,\n-}\n-\n-impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"[{:?};{:?};{:?}]\",\n-               self.get_slice(TypeSpace),\n-               self.get_slice(SelfSpace),\n-               self.get_slice(FnSpace))\n-    }\n-}\n-\n-impl<T> VecPerParamSpace<T> {\n-    fn limits(&self, space: ParamSpace) -> (usize, usize) {\n-        match space {\n-            TypeSpace => (0, self.type_limit),\n-            SelfSpace => (self.type_limit, self.self_limit),\n-            FnSpace => (self.self_limit, self.content.len()),\n-        }\n-    }\n-\n-    pub fn empty() -> VecPerParamSpace<T> {\n-        VecPerParamSpace {\n-            type_limit: 0,\n-            self_limit: 0,\n-            content: Vec::new()\n-        }\n-    }\n-\n-    /// `t` is the type space.\n-    /// `s` is the self space.\n-    /// `f` is the fn space.\n-    pub fn new(t: Vec<T>, s: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n-        let type_limit = t.len();\n-        let self_limit = type_limit + s.len();\n-\n-        let mut content = t;\n-        content.extend(s);\n-        content.extend(f);\n-\n-        VecPerParamSpace {\n-            type_limit: type_limit,\n-            self_limit: self_limit,\n-            content: content,\n-        }\n-    }\n-\n-    fn new_internal(content: Vec<T>, type_limit: usize, self_limit: usize)\n-                    -> VecPerParamSpace<T>\n-    {\n-        VecPerParamSpace {\n-            type_limit: type_limit,\n-            self_limit: self_limit,\n-            content: content,\n-        }\n-    }\n-\n-    /// Appends `value` to the vector associated with `space`.\n-    ///\n-    /// Unlike the `push` method in `Vec`, this should not be assumed\n-    /// to be a cheap operation (even when amortized over many calls).\n-    pub fn push(&mut self, space: ParamSpace, value: T) {\n-        let (_, limit) = self.limits(space);\n-        match space {\n-            TypeSpace => { self.type_limit += 1; self.self_limit += 1; }\n-            SelfSpace => { self.self_limit += 1; }\n-            FnSpace => { }\n-        }\n-        self.content.insert(limit, value);\n-    }\n-\n-    /// Appends `values` to the vector associated with `space`.\n-    ///\n-    /// Unlike the `extend` method in `Vec`, this should not be assumed\n-    /// to be a cheap operation (even when amortized over many calls).\n-    pub fn extend<I:Iterator<Item=T>>(&mut self, space: ParamSpace, values: I) {\n-        // This could be made more efficient, obviously.\n-        for item in values {\n-            self.push(space, item);\n-        }\n-    }\n-\n-    pub fn pop(&mut self, space: ParamSpace) -> Option<T> {\n-        let (start, limit) = self.limits(space);\n-        if start == limit {\n-            None\n-        } else {\n-            match space {\n-                TypeSpace => { self.type_limit -= 1; self.self_limit -= 1; }\n-                SelfSpace => { self.self_limit -= 1; }\n-                FnSpace => {}\n-            }\n-            if self.content.is_empty() {\n-                None\n-            } else {\n-                Some(self.content.remove(limit - 1))\n-            }\n-        }\n-    }\n-\n-    pub fn truncate(&mut self, space: ParamSpace, len: usize) {\n-        // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n-        while self.len(space) > len {\n-            self.pop(space);\n-        }\n-    }\n-\n-    pub fn replace(&mut self, space: ParamSpace, elems: Vec<T>) {\n-        // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n-        self.truncate(space, 0);\n-        for t in elems {\n-            self.push(space, t);\n-        }\n-    }\n-\n-    pub fn get_self<'a>(&'a self) -> Option<&'a T> {\n-        let v = self.get_slice(SelfSpace);\n-        assert!(v.len() <= 1);\n-        if v.is_empty() { None } else { Some(&v[0]) }\n-    }\n-\n-    pub fn len(&self, space: ParamSpace) -> usize {\n-        self.get_slice(space).len()\n-    }\n-\n-    pub fn is_empty_in(&self, space: ParamSpace) -> bool {\n-        self.len(space) == 0\n-    }\n-\n-    pub fn get_slice<'a>(&'a self, space: ParamSpace) -> &'a [T] {\n-        let (start, limit) = self.limits(space);\n-        &self.content[start.. limit]\n-    }\n-\n-    pub fn get_mut_slice<'a>(&'a mut self, space: ParamSpace) -> &'a mut [T] {\n-        let (start, limit) = self.limits(space);\n-        &mut self.content[start.. limit]\n-    }\n-\n-    pub fn opt_get<'a>(&'a self,\n-                       space: ParamSpace,\n-                       index: usize)\n-                       -> Option<&'a T> {\n-        let v = self.get_slice(space);\n-        if index < v.len() { Some(&v[index]) } else { None }\n-    }\n-\n-    pub fn get<'a>(&'a self, space: ParamSpace, index: usize) -> &'a T {\n-        &self.get_slice(space)[index]\n-    }\n-\n-    pub fn iter<'a>(&'a self) -> Iter<'a,T> {\n-        self.content.iter()\n-    }\n-\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        self.content.into_iter()\n-    }\n-\n-    pub fn iter_enumerated<'a>(&'a self) -> EnumeratedItems<'a,T> {\n-        EnumeratedItems::new(self)\n-    }\n-\n-    pub fn as_slice(&self) -> &[T] {\n-        &self.content\n-    }\n-\n-    pub fn into_vec(self) -> Vec<T> {\n-        self.content\n-    }\n-\n-    pub fn all_vecs<P>(&self, mut pred: P) -> bool where\n-        P: FnMut(&[T]) -> bool,\n-    {\n-        let spaces = [TypeSpace, SelfSpace, FnSpace];\n-        spaces.iter().all(|&space| { pred(self.get_slice(space)) })\n-    }\n-\n-    pub fn all<P>(&self, pred: P) -> bool where P: FnMut(&T) -> bool {\n-        self.iter().all(pred)\n-    }\n-\n-    pub fn any<P>(&self, pred: P) -> bool where P: FnMut(&T) -> bool {\n-        self.iter().any(pred)\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.all_vecs(|v| v.is_empty())\n-    }\n-\n-    pub fn map<U, P>(&self, pred: P) -> VecPerParamSpace<U> where P: FnMut(&T) -> U {\n-        let result = self.iter().map(pred).collect();\n-        VecPerParamSpace::new_internal(result,\n-                                       self.type_limit,\n-                                       self.self_limit)\n-    }\n-\n-    pub fn map_enumerated<U, P>(&self, pred: P) -> VecPerParamSpace<U> where\n-        P: FnMut((ParamSpace, usize, &T)) -> U,\n-    {\n-        let result = self.iter_enumerated().map(pred).collect();\n-        VecPerParamSpace::new_internal(result,\n-                                       self.type_limit,\n-                                       self.self_limit)\n-    }\n-\n-    pub fn split(self) -> SeparateVecsPerParamSpace<T> {\n-        let VecPerParamSpace { type_limit, self_limit, content } = self;\n-\n-        let mut content_iter = content.into_iter();\n-\n-        SeparateVecsPerParamSpace {\n-            types: content_iter.by_ref().take(type_limit).collect(),\n-            selfs: content_iter.by_ref().take(self_limit - type_limit).collect(),\n-            fns: content_iter.collect()\n-        }\n-    }\n-\n-    pub fn with_slice(mut self, space: ParamSpace, slice: &[T])\n-                    -> VecPerParamSpace<T>\n-        where T: Clone\n-    {\n-        assert!(self.is_empty_in(space));\n-        for t in slice {\n-            self.push(space, t.clone());\n-        }\n-\n-        self\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct EnumeratedItems<'a,T:'a> {\n-    vec: &'a VecPerParamSpace<T>,\n-    space_index: usize,\n-    elem_index: usize\n-}\n-\n-impl<'a,T> EnumeratedItems<'a,T> {\n-    fn new(v: &'a VecPerParamSpace<T>) -> EnumeratedItems<'a,T> {\n-        let mut result = EnumeratedItems { vec: v, space_index: 0, elem_index: 0 };\n-        result.adjust_space();\n-        result\n-    }\n-\n-    fn adjust_space(&mut self) {\n-        let spaces = ParamSpace::all();\n-        while\n-            self.space_index < spaces.len() &&\n-            self.elem_index >= self.vec.len(spaces[self.space_index])\n-        {\n-            self.space_index += 1;\n-            self.elem_index = 0;\n-        }\n-    }\n-}\n-\n-impl<'a,T> Iterator for EnumeratedItems<'a,T> {\n-    type Item = (ParamSpace, usize, &'a T);\n-\n-    fn next(&mut self) -> Option<(ParamSpace, usize, &'a T)> {\n-        let spaces = ParamSpace::all();\n-        if self.space_index < spaces.len() {\n-            let space = spaces[self.space_index];\n-            let index = self.elem_index;\n-            let item = self.vec.get(space, index);\n-\n-            self.elem_index += 1;\n-            self.adjust_space();\n-\n-            Some((space, index, item))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let size = self.vec.as_slice().len();\n-        (size, Some(size))\n-    }\n-}\n-\n-impl<T> IntoIterator for VecPerParamSpace<T> {\n-    type Item = T;\n-    type IntoIter = IntoIter<T>;\n-\n-    fn into_iter(self) -> IntoIter<T> {\n-        self.into_vec().into_iter()\n-    }\n-}\n-\n-impl<'a,T> IntoIterator for &'a VecPerParamSpace<T> {\n-    type Item = &'a T;\n-    type IntoIter = Iter<'a, T>;\n-\n-    fn into_iter(self) -> Iter<'a, T> {\n-        self.as_slice().into_iter()\n-    }\n-}\n-\n \n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n@@ -596,7 +223,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         // the specialized routine `ty::replace_late_regions()`.\n         match r {\n             ty::ReEarlyBound(data) => {\n-                match self.substs.regions.opt_get(data.space, data.index as usize) {\n+                match self.substs.regions.get(data.index as usize) {\n                     Some(&r) => {\n                         self.shift_region_through_binders(r)\n                     }\n@@ -606,10 +233,9 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n                             span,\n                             \"Region parameter out of range \\\n                              when substituting in region {} (root type={:?}) \\\n-                             (space={:?}, index={})\",\n+                             (index={})\",\n                             data.name,\n                             self.root_ty,\n-                            data.space,\n                             data.index);\n                     }\n                 }\n@@ -652,18 +278,17 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.types.opt_get(p.space, p.idx as usize);\n+        let opt_ty = self.substs.types.get(p.idx as usize);\n         let ty = match opt_ty {\n             Some(t) => *t,\n             None => {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 span_bug!(\n                     span,\n-                    \"Type parameter `{:?}` ({:?}/{:?}/{}) out of range \\\n+                    \"Type parameter `{:?}` ({:?}/{}) out of range \\\n                          when substituting (root type={:?}) substs={:?}\",\n                     p,\n                     source_ty,\n-                    p.space,\n                     p.idx,\n                     self.root_ty,\n                     self.substs);\n@@ -733,3 +358,60 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n         ty::fold::shift_region(region, self.region_binders_passed)\n     }\n }\n+\n+// Helper methods that modify substitutions.\n+\n+impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n+    pub fn from_method(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                       trait_id: DefId,\n+                       substs: &Substs<'tcx>)\n+                       -> ty::TraitRef<'tcx> {\n+        let defs = tcx.lookup_generics(trait_id);\n+        let regions = substs.regions[..defs.regions.len()].to_vec();\n+        let types = substs.types[..defs.types.len()].to_vec();\n+\n+        ty::TraitRef {\n+            def_id: trait_id,\n+            substs: Substs::new(tcx, types, regions)\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> ty::ExistentialTraitRef<'tcx> {\n+    pub fn erase_self_ty(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                         trait_ref: ty::TraitRef<'tcx>)\n+                         -> ty::ExistentialTraitRef<'tcx> {\n+        let Substs { mut types, regions } = trait_ref.substs.clone();\n+\n+        types.remove(0);\n+\n+        ty::ExistentialTraitRef {\n+            def_id: trait_ref.def_id,\n+            substs: Substs::new(tcx, types, regions)\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> ty::PolyExistentialTraitRef<'tcx> {\n+    /// Object types don't have a self-type specified. Therefore, when\n+    /// we convert the principal trait-ref into a normal trait-ref,\n+    /// you must give *some* self-type. A common choice is `mk_err()`\n+    /// or some skolemized type.\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        self_ty: Ty<'tcx>)\n+                        -> ty::PolyTraitRef<'tcx>  {\n+        // otherwise the escaping regions would be captured by the binder\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        self.map_bound(|trait_ref| {\n+            let Substs { mut types, regions } = trait_ref.substs.clone();\n+\n+            types.insert(0, self_ty);\n+\n+            ty::TraitRef {\n+                def_id: trait_ref.def_id,\n+                substs: Substs::new(tcx, types, regions)\n+            }\n+        })\n+    }\n+}"}, {"sha": "61285e8f8b0a597ef378b284e9410f644ccdc80f", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -34,7 +34,7 @@ pub struct TraitDef<'tcx> {\n     /// `Eq`, there is a single bound `Self : Eq`). This is so that\n     /// default methods get to assume that the `Self` parameters\n     /// implements the trait.\n-    pub generics: ty::Generics<'tcx>,\n+    pub generics: &'tcx ty::Generics<'tcx>,\n \n     pub trait_ref: ty::TraitRef<'tcx>,\n \n@@ -76,7 +76,7 @@ pub struct TraitDef<'tcx> {\n impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n     pub fn new(unsafety: hir::Unsafety,\n                paren_sugar: bool,\n-               generics: ty::Generics<'tcx>,\n+               generics: &'tcx ty::Generics<'tcx>,\n                trait_ref: ty::TraitRef<'tcx>,\n                associated_type_names: Vec<Name>)\n                -> TraitDef<'tcx> {"}, {"sha": "51710c13a7deacb9f389d0735be5376747d6784f", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -11,7 +11,6 @@\n //! misc. type-system utilities too small to deserve their own file\n \n use hir::def_id::DefId;\n-use ty::subst;\n use infer::InferCtxt;\n use hir::pat_util;\n use traits::{self, Reveal};\n@@ -451,21 +450,21 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n                 // to sort them again by the name, in string form.\n \n                 // Hash the whole principal trait ref.\n-                self.def_id(data.principal_def_id());\n+                self.def_id(data.principal.def_id());\n                 data.principal.visit_with(self);\n \n                 // Hash region and builtin bounds.\n-                data.bounds.region_bound.visit_with(self);\n-                self.hash(data.bounds.builtin_bounds);\n+                data.region_bound.visit_with(self);\n+                self.hash(data.builtin_bounds);\n \n                 // Only projection bounds are left, sort and hash them.\n-                let mut projection_bounds: Vec<_> = data.bounds.projection_bounds\n+                let mut projection_bounds: Vec<_> = data.projection_bounds\n                                                         .iter()\n                                                         .map(|b| (b.item_name().as_str(), b))\n                                                         .collect();\n                 projection_bounds.sort_by_key(|&(ref name, _)| name.clone());\n                 for (name, bound) in projection_bounds {\n-                    self.def_id(bound.0.projection_ty.trait_ref.def_id);\n+                    self.def_id(bound.0.trait_ref.def_id);\n                     self.hash(name);\n                     bound.visit_with(self);\n                 }\n@@ -477,7 +476,6 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n                 self.hash(tys.len());\n             }\n             TyParam(p) => {\n-                self.hash(p.space);\n                 self.hash(p.idx);\n                 self.hash(p.name.as_str());\n             }\n@@ -695,12 +693,10 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         return false;\n                     }\n \n-                    let types_a = substs_a.types.get_slice(subst::TypeSpace);\n-                    let types_b = substs_b.types.get_slice(subst::TypeSpace);\n+                    let types_a = &substs_a.types;\n+                    let types_b = &substs_b.types;\n \n-                    let mut pairs = types_a.iter().zip(types_b);\n-\n-                    pairs.all(|(&a, &b)| same_type(a, b))\n+                    types_a.iter().zip(types_b).all(|(&a, &b)| same_type(a, b))\n                 }\n                 _ => {\n                     a == b"}, {"sha": "8a9ee45351dfc26c73813eb2835e8e368570f9a9", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -79,28 +79,28 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n             stack.push(mt.ty);\n         }\n         ty::TyProjection(ref data) => {\n-            push_reversed(stack, data.trait_ref.substs.types.as_slice());\n+            push_reversed(stack, &data.trait_ref.substs.types);\n         }\n-        ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n-            push_reversed(stack, principal.substs().types.as_slice());\n-            push_reversed(stack, &bounds.projection_bounds.iter().map(|pred| {\n+        ty::TyTrait(ref obj) => {\n+            push_reversed(stack, obj.principal.input_types());\n+            push_reversed(stack, &obj.projection_bounds.iter().map(|pred| {\n                 pred.0.ty\n             }).collect::<Vec<_>>());\n         }\n         ty::TyEnum(_, ref substs) |\n         ty::TyStruct(_, ref substs) |\n         ty::TyAnon(_, ref substs) => {\n-            push_reversed(stack, substs.types.as_slice());\n+            push_reversed(stack, &substs.types);\n         }\n         ty::TyClosure(_, ref substs) => {\n-            push_reversed(stack, substs.func_substs.types.as_slice());\n+            push_reversed(stack, &substs.func_substs.types);\n             push_reversed(stack, &substs.upvar_tys);\n         }\n         ty::TyTuple(ref ts) => {\n             push_reversed(stack, ts);\n         }\n         ty::TyFnDef(_, substs, ref ft) => {\n-            push_reversed(stack, substs.types.as_slice());\n+            push_reversed(stack, &substs.types);\n             push_sig_subtypes(stack, &ft.sig);\n         }\n         ty::TyFnPtr(ref ft) => {"}, {"sha": "54b19362b1d86e43afd1b1c36b5a089f95b374c2", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -261,7 +261,6 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         let cause = self.cause(traits::MiscObligation);\n         self.out.extend(\n             trait_ref.substs.types\n-                            .as_slice()\n                             .iter()\n                             .filter(|ty| !ty.has_escaping_regions())\n                             .map(|ty| traits::Obligation::new(cause.clone(),\n@@ -406,13 +405,13 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // FIXME(#33243): remove RFC1592\n                     self.out.push(traits::Obligation::new(\n                         cause.clone(),\n-                        ty::Predicate::ObjectSafe(data.principal_def_id())\n+                        ty::Predicate::ObjectSafe(data.principal.def_id())\n                     ));\n                     let component_traits =\n-                        data.bounds.builtin_bounds.iter().flat_map(|bound| {\n+                        data.builtin_bounds.iter().flat_map(|bound| {\n                             tcx.lang_items.from_builtin_kind(bound).ok()\n                         });\n-//                        .chain(Some(data.principal_def_id()));\n+//                        .chain(Some(data.principal.def_id()));\n                     self.out.extend(\n                         component_traits.map(|did| { traits::Obligation::new(\n                             cause.clone(),\n@@ -476,7 +475,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                   .collect()\n     }\n \n-    fn from_object_ty(&mut self, ty: Ty<'tcx>, data: &ty::TraitTy<'tcx>) {\n+    fn from_object_ty(&mut self, ty: Ty<'tcx>, data: &ty::TraitObject<'tcx>) {\n         // Imagine a type like this:\n         //\n         //     trait Foo { }\n@@ -512,10 +511,10 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         if !data.has_escaping_regions() {\n             let implicit_bounds =\n                 object_region_bounds(self.infcx.tcx,\n-                                     &data.principal,\n-                                     data.bounds.builtin_bounds);\n+                                     data.principal,\n+                                     data.builtin_bounds);\n \n-            let explicit_bound = data.bounds.region_bound;\n+            let explicit_bound = data.region_bound;\n \n             for implicit_bound in implicit_bounds {\n                 let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n@@ -534,7 +533,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n /// `ty::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    principal: &ty::PolyTraitRef<'tcx>,\n+    principal: ty::PolyExistentialTraitRef<'tcx>,\n     others: ty::BuiltinBounds)\n     -> Vec<ty::Region>\n {\n@@ -543,13 +542,8 @@ pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     // a skolemized type.\n     let open_ty = tcx.mk_infer(ty::FreshTy(0));\n \n-    // Note that we preserve the overall binding levels here.\n-    assert!(!open_ty.has_escaping_regions());\n-    let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n-    let trait_refs = vec!(ty::Binder(ty::TraitRef::new(principal.0.def_id, substs)));\n-\n     let mut predicates = others.to_predicates(tcx, open_ty);\n-    predicates.extend(trait_refs.iter().map(|t| t.to_predicate()));\n+    predicates.push(principal.with_self_ty(tcx, open_ty).to_predicate());\n \n     tcx.required_region_bounds(open_ty, predicates)\n }"}, {"sha": "02ad8fb7033ed2d50d9900bf2fe2d42864cd9748", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 137, "deletions": 152, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -10,7 +10,7 @@\n \n \n use hir::def_id::DefId;\n-use ty::subst::{self, Subst};\n+use ty::subst::{self, Subst, Substs};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{TyBool, TyChar, TyStruct, TyEnum};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n@@ -56,78 +56,75 @@ fn fn_sig(f: &mut fmt::Formatter,\n }\n \n /// Namespace of the path given to parameterized to print.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum Ns {\n     Type,\n     Value\n }\n \n-fn number_of_supplied_defaults<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                               substs: &subst::Substs,\n-                                               space: subst::ParamSpace,\n-                                               generics: ty::Generics<'tcx>)\n-                                               -> usize\n-{\n-    let has_self = substs.self_ty().is_some();\n-    let ty_params = generics.types.get_slice(space);\n-    let tps = substs.types.get_slice(space);\n-    if ty_params.last().map_or(false, |def| def.default.is_some()) {\n-        let substs = tcx.lift(&substs);\n-        ty_params.iter().zip(tps).rev().take_while(|&(def, &actual)| {\n-            match def.default {\n-                Some(default) => {\n-                    if !has_self && default.has_self_ty() {\n-                        // In an object type, there is no `Self`, and\n-                        // thus if the default value references Self,\n-                        // the user will be required to give an\n-                        // explicit value. We can't even do the\n-                        // substitution below to check without causing\n-                        // an ICE. (#18956).\n-                        false\n-                    } else {\n-                        let default = tcx.lift(&default);\n-                        substs.and_then(|substs| default.subst(tcx, substs))\n-                            == Some(actual)\n+pub fn parameterized(f: &mut fmt::Formatter,\n+                     substs: &subst::Substs,\n+                     did: DefId,\n+                     ns: Ns,\n+                     projections: &[ty::ProjectionPredicate])\n+                     -> fmt::Result {\n+    let mut verbose = false;\n+    let mut num_supplied_defaults = 0;\n+    let mut has_self = false;\n+    let mut num_regions = 0;\n+    let mut num_types = 0;\n+    let mut item_name = None;\n+    let fn_trait_kind = ty::tls::with(|tcx| {\n+        let mut generics = tcx.lookup_generics(did);\n+        let mut path_def_id = did;\n+        verbose = tcx.sess.verbose();\n+        has_self = generics.has_self;\n+\n+        if let Some(def_id) = generics.parent {\n+            // Methods.\n+            assert_eq!(ns, Ns::Value);\n+            generics = tcx.lookup_generics(def_id);\n+            num_regions = generics.regions.len();\n+            num_types = generics.types.len();\n+\n+            if has_self {\n+                write!(f, \"<{} as \", substs.types[0])?;\n+            }\n+\n+            item_name = Some(tcx.item_name(did));\n+            path_def_id = def_id;\n+        } else {\n+            if ns == Ns::Value {\n+                // Functions.\n+                assert_eq!(has_self, false);\n+            } else {\n+                // Types and traits.\n+                num_regions = generics.regions.len();\n+                num_types = generics.types.len();\n+            }\n+        }\n+\n+        if !verbose {\n+            if generics.types.last().map_or(false, |def| def.default.is_some()) {\n+                if let Some(substs) = tcx.lift(&substs) {\n+                    let tps = &substs.types[..num_types];\n+                    for (def, actual) in generics.types.iter().zip(tps).rev() {\n+                        if def.default.subst(tcx, substs) != Some(actual) {\n+                            break;\n+                        }\n+                        num_supplied_defaults += 1;\n                     }\n                 }\n-                None => false\n             }\n-        }).count()\n-    } else {\n-        0\n-    }\n-}\n-\n-pub fn parameterized<GG>(f: &mut fmt::Formatter,\n-                         substs: &subst::Substs,\n-                         did: DefId,\n-                         ns: Ns,\n-                         projections: &[ty::ProjectionPredicate],\n-                         get_generics: GG)\n-                         -> fmt::Result\n-    where GG: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>)\n-                                         -> Option<ty::Generics<'tcx>>\n-{\n-    if let (Ns::Value, Some(self_ty)) = (ns, substs.self_ty()) {\n-        write!(f, \"<{} as \", self_ty)?;\n-    }\n+        }\n \n-    let (fn_trait_kind, verbose, item_name) = ty::tls::with(|tcx| {\n-        let (did, item_name) = if ns == Ns::Value {\n-            // Try to get the impl/trait parent, if this is an\n-            // associated value item (method or constant).\n-            tcx.trait_of_item(did).or_else(|| tcx.impl_of_method(did))\n-               .map_or((did, None), |parent| (parent, Some(tcx.item_name(did))))\n-        } else {\n-            (did, None)\n-        };\n-        write!(f, \"{}\", tcx.item_path_str(did))?;\n-        Ok((tcx.lang_items.fn_trait_kind(did), tcx.sess.verbose(), item_name))\n+        write!(f, \"{}\", tcx.item_path_str(path_def_id))?;\n+        Ok(tcx.lang_items.fn_trait_kind(path_def_id))\n     })?;\n \n     if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n         let projection_ty = projections[0].ty;\n-        if let TyTuple(ref args) = substs.types.get_slice(subst::TypeSpace)[0].sty {\n+        if let TyTuple(ref args) = substs.types[1].sty {\n             return fn_sig(f, args, false, projection_ty);\n         }\n     }\n@@ -170,23 +167,11 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n         Ok(())\n     };\n \n-    print_regions(f, \"<\", substs.regions.get_slice(subst::TypeSpace))?;\n-\n-    let num_supplied_defaults = if verbose {\n-        0\n-    } else {\n-        ty::tls::with(|tcx| {\n-            if let Some(generics) = get_generics(tcx) {\n-                number_of_supplied_defaults(tcx, substs, subst::TypeSpace, generics)\n-            } else {\n-                0\n-            }\n-        })\n-    };\n+    print_regions(f, \"<\", &substs.regions[..num_regions])?;\n \n-    let tps = substs.types.get_slice(subst::TypeSpace);\n+    let tps = &substs.types[..num_types];\n \n-    for &ty in &tps[..tps.len() - num_supplied_defaults] {\n+    for &ty in &tps[has_self as usize..tps.len() - num_supplied_defaults] {\n         start_or_continue(f, \"<\", \", \")?;\n         write!(f, \"{}\", ty)?;\n     }\n@@ -204,18 +189,18 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     if ns == Ns::Value {\n         empty.set(true);\n \n-        if substs.self_ty().is_some() {\n+        if has_self {\n             write!(f, \">\")?;\n         }\n \n         if let Some(item_name) = item_name {\n             write!(f, \"::{}\", item_name)?;\n         }\n \n-        print_regions(f, \"::<\", substs.regions.get_slice(subst::FnSpace))?;\n+        print_regions(f, \"::<\", &substs.regions[num_regions..])?;\n \n         // FIXME: consider being smart with defaults here too\n-        for ty in substs.types.get_slice(subst::FnSpace) {\n+        for ty in &substs.types[num_types..] {\n             start_or_continue(f, \"::<\", \", \")?;\n             write!(f, \"{}\", ty)?;\n         }\n@@ -288,7 +273,8 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n /// projection bounds, so we just stuff them altogether. But in\n /// reality we should eventually sort things out better.\n #[derive(Clone, Debug)]\n-struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n+struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>,\n+                                 Vec<ty::ProjectionPredicate<'tcx>>);\n \n impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n@@ -306,29 +292,32 @@ impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n         parameterized(f, trait_ref.substs,\n                       trait_ref.def_id,\n                       Ns::Type,\n-                      projection_bounds,\n-                      |tcx| Some(tcx.lookup_trait_def(trait_ref.def_id).generics.clone()))\n+                      projection_bounds)\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n+impl<'tcx> fmt::Display for ty::TraitObject<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let bounds = &self.bounds;\n-\n         // Generate the main trait ref, including associated types.\n         ty::tls::with(|tcx| {\n-            let principal = tcx.lift(&self.principal.0)\n-                               .expect(\"could not lift TraitRef for printing\");\n-            let projections = tcx.lift(&bounds.projection_bounds[..])\n-                                 .expect(\"could not lift projections for printing\");\n-            let projections = projections.into_iter().map(|p| p.0).collect();\n+            // Use a type that can't appear in defaults of type parameters.\n+            let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+\n+            let principal = tcx.lift(&self.principal)\n+                               .expect(\"could not lift TraitRef for printing\")\n+                               .with_self_ty(tcx, dummy_self).0;\n+            let projections = self.projection_bounds.iter().map(|p| {\n+                tcx.lift(p)\n+                    .expect(\"could not lift projection for printing\")\n+                    .with_self_ty(tcx, dummy_self).0\n+            }).collect();\n \n             let tap = ty::Binder(TraitAndProjections(principal, projections));\n             in_binder(f, tcx, &ty::Binder(\"\"), Some(tap))\n         })?;\n \n         // Builtin bounds.\n-        for bound in &bounds.builtin_bounds {\n+        for bound in &self.builtin_bounds {\n             write!(f, \" + {:?}\", bound)?;\n         }\n \n@@ -337,7 +326,7 @@ impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n         // use thread-local data of some kind? There are also\n         // advantages to just showing the region, since it makes\n         // people aware that it's there.\n-        let bound = bounds.region_bound.to_string();\n+        let bound = self.region_bound.to_string();\n         if !bound.is_empty() {\n             write!(f, \" + {}\", bound)?;\n         }\n@@ -348,19 +337,19 @@ impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n \n impl<'tcx> fmt::Debug for ty::TypeParameterDef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TypeParameterDef({}, {:?}, {:?}/{})\",\n+        write!(f, \"TypeParameterDef({}, {:?}, {})\",\n                self.name,\n                self.def_id,\n-               self.space, self.index)\n+               self.index)\n     }\n }\n \n impl fmt::Debug for ty::RegionParameterDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionParameterDef({}, {:?}, {:?}/{}, {:?})\",\n+        write!(f, \"RegionParameterDef({}, {:?}, {}, {:?})\",\n                self.name,\n                self.def_id,\n-               self.space, self.index,\n+               self.index,\n                self.bounds)\n     }\n }\n@@ -379,7 +368,7 @@ impl<'tcx> fmt::Display for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for subst::Substs<'tcx> {\n+impl<'tcx> fmt::Debug for Substs<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"Substs[types={:?}, regions={:?}]\",\n                self.types, self.regions)\n@@ -397,10 +386,20 @@ impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n         // when printing out the debug representation, we don't need\n         // to enumerate the `for<...>` etc because the debruijn index\n         // tells you everything you need to know.\n-        match self.substs.self_ty() {\n-            None => write!(f, \"{}\", *self),\n-            Some(self_ty) => write!(f, \"<{:?} as {}>\", self_ty, *self)\n-        }\n+        write!(f, \"<{:?} as {}>\", self.self_ty(), *self)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+\n+            let trait_ref = tcx.lift(&ty::Binder(*self))\n+                               .expect(\"could not lift TraitRef for printing\")\n+                               .with_self_ty(tcx, dummy_self).0;\n+            parameterized(f, trait_ref.substs, trait_ref.def_id, Ns::Type, &[])\n+        })\n     }\n }\n \n@@ -448,11 +447,38 @@ impl<'tcx> fmt::Debug for ty::adjustment::AutoDerefRef<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TraitTy<'tcx> {\n+impl<'tcx> fmt::Debug for ty::TraitObject<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TraitTy({:?},{:?})\",\n-               self.principal,\n-               self.bounds)\n+        let mut empty = true;\n+        let mut maybe_continue = |f: &mut fmt::Formatter| {\n+            if empty {\n+                empty = false;\n+                Ok(())\n+            } else {\n+                write!(f, \" + \")\n+            }\n+        };\n+\n+        maybe_continue(f)?;\n+        write!(f, \"{:?}\", self.principal)?;\n+\n+        let region_str = format!(\"{:?}\", self.region_bound);\n+        if !region_str.is_empty() {\n+            maybe_continue(f)?;\n+            write!(f, \"{}\", region_str)?;\n+        }\n+\n+        for bound in &self.builtin_bounds {\n+            maybe_continue(f)?;\n+            write!(f, \"{:?}\", bound)?;\n+        }\n+\n+        for projection_bound in &self.projection_bounds {\n+            maybe_continue(f)?;\n+            write!(f, \"{:?}\", projection_bound)?;\n+        }\n+\n+        Ok(())\n     }\n }\n \n@@ -509,8 +535,7 @@ impl fmt::Debug for ty::Region {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n-                write!(f, \"ReEarlyBound({:?}, {}, {})\",\n-                       data.space,\n+                write!(f, \"ReEarlyBound({}, {})\",\n                        data.index,\n                        data.name)\n             }\n@@ -668,38 +693,6 @@ impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ExistentialBounds<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let mut empty = true;\n-        let mut maybe_continue = |f: &mut fmt::Formatter| {\n-            if empty {\n-                empty = false;\n-                Ok(())\n-            } else {\n-                write!(f, \" + \")\n-            }\n-        };\n-\n-        let region_str = format!(\"{:?}\", self.region_bound);\n-        if !region_str.is_empty() {\n-            maybe_continue(f)?;\n-            write!(f, \"{}\", region_str)?;\n-        }\n-\n-        for bound in &self.builtin_bounds {\n-            maybe_continue(f)?;\n-            write!(f, \"{:?}\", bound)?;\n-        }\n-\n-        for projection_bound in &self.projection_bounds {\n-            maybe_continue(f)?;\n-            write!(f, \"{:?}\", projection_bound)?;\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n impl fmt::Display for ty::BuiltinBounds {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut bounds = self.iter();\n@@ -814,8 +807,7 @@ impl fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>>\n \n impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        parameterized(f, self.substs, self.def_id, Ns::Type, &[],\n-                      |tcx| Some(tcx.lookup_trait_def(self.def_id).generics.clone()))\n+        parameterized(f, self.substs, self.def_id, Ns::Type, &[])\n     }\n }\n \n@@ -868,9 +860,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 }\n \n                 write!(f, \"{} {{\", bare_fn.sig.0)?;\n-                parameterized(\n-                    f, substs, def_id, Ns::Value, &[],\n-                    |tcx| tcx.opt_lookup_item_type(def_id).map(|t| t.generics))?;\n+                parameterized(f, substs, def_id, Ns::Value, &[])?;\n                 write!(f, \"}}\")\n             }\n             TyFnPtr(ref bare_fn) => {\n@@ -893,12 +883,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                           !tcx.tcache.borrow().contains_key(&def.did) {\n                         write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n-                        parameterized(\n-                            f, substs, def.did, Ns::Type, &[],\n-                            |tcx| {\n-                                tcx.opt_lookup_item_type(def.did).\n-                                    map(|t| t.generics)\n-                            })\n+                        parameterized(f, substs, def.did, Ns::Type, &[])\n                     }\n                 })\n             }\n@@ -910,14 +895,14 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     // by looking up the projections associated with the def_id.\n                     let item_predicates = tcx.lookup_predicates(def_id);\n                     let substs = tcx.lift(&substs).unwrap_or_else(|| {\n-                        tcx.mk_substs(subst::Substs::empty())\n+                        Substs::empty(tcx)\n                     });\n                     let bounds = item_predicates.instantiate(tcx, substs);\n \n                     let mut first = true;\n                     let mut is_sized = false;\n                     write!(f, \"impl\")?;\n-                    for predicate in bounds.predicates.into_vec() {\n+                    for predicate in bounds.predicates {\n                         if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n                             // Don't print +Sized, but rather +?Sized if absent.\n                             if Some(trait_ref.def_id()) == tcx.lang_items.sized_trait() {\n@@ -1034,7 +1019,7 @@ impl fmt::Display for ty::ParamTy {\n \n impl fmt::Debug for ty::ParamTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}/{:?}.{}\", self, self.space, self.idx)\n+        write!(f, \"{}/#{}\", self, self.idx)\n     }\n }\n "}, {"sha": "111646912ade30998060c70694305ce1dcbe5b8f", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -16,7 +16,7 @@ use super::{drop_flag_effects_for_location, on_all_children_bits};\n use super::{DropFlagState, MoveDataParamEnv};\n use super::patch::MirPatch;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::{Subst, Substs, VecPerParamSpace};\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::mir::repr::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n@@ -859,10 +859,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let unit_temp = Lvalue::Temp(self.patch.new_temp(tcx.mk_nil()));\n         let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n             .unwrap_or_else(|e| tcx.sess.fatal(&e));\n-        let substs = tcx.mk_substs(Substs::new(\n-            VecPerParamSpace::new(vec![], vec![], vec![ty]),\n-            VecPerParamSpace::new(vec![], vec![], vec![])\n-        ));\n+        let substs = Substs::new(tcx, vec![ty], vec![]);\n         let fty = tcx.lookup_item_type(free_func).ty.subst(tcx, substs);\n \n         self.patch.new_block(BasicBlockData {"}, {"sha": "d71add3258fbd888d917e991b2a80f60a1101127", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -22,8 +22,9 @@ use rustc::traits;\n use rustc::hir::def::{Def, PathResolution};\n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::def_to_path;\n-use rustc::ty::{self, Ty, TyCtxt, subst};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n+use rustc::ty::subst::Substs;\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n@@ -93,7 +94,7 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// This generally happens in late/trans const evaluation.\n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n-                                        substs: Option<&'tcx subst::Substs<'tcx>>)\n+                                        substs: Option<&'tcx Substs<'tcx>>)\n                                         -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)> {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         match tcx.map.find(node_id) {\n@@ -110,7 +111,8 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         // If we have a trait item and the substitutions for it,\n                         // `resolve_trait_associated_const` will select an impl\n                         // or the default.\n-                        let trait_id = tcx.trait_of_item(def_id).unwrap();\n+                        let trait_id = tcx.map.get_parent(node_id);\n+                        let trait_id = tcx.map.local_def_id(trait_id);\n                         resolve_trait_associated_const(tcx, ti, trait_id, substs)\n                     } else {\n                         // Technically, without knowing anything about the\n@@ -1045,16 +1047,14 @@ fn infer<'a, 'tcx>(i: ConstInt,\n fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 ti: &'tcx hir::TraitItem,\n                                                 trait_id: DefId,\n-                                                rcvr_substs: &'tcx subst::Substs<'tcx>)\n+                                                rcvr_substs: &'tcx Substs<'tcx>)\n                                                 -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>\n {\n-    let trait_ref = ty::Binder(\n-        rcvr_substs.clone().erase_regions().to_trait_ref(tcx, trait_id)\n-    );\n+    let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, rcvr_substs));\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n-    tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n+    tcx.populate_implementations_for_trait_if_necessary(trait_id);\n     tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),"}, {"sha": "772d83eb2cfadd080df45a69ec493c53ac11e197", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -33,4 +33,5 @@ rustc_metadata = { path = \"../librustc_metadata\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+proc_macro = { path = \"../libproc_macro\" }"}, {"sha": "32d0bbbfdb6b7d8e179542345e71af35580856e2", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -20,8 +20,7 @@ use rustc::middle::region::{self, CodeExtent};\n use rustc::middle::region::CodeExtentData;\n use rustc::middle::resolve_lifetime;\n use rustc::middle::stability;\n-use rustc::ty::subst;\n-use rustc::ty::subst::Subst;\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n@@ -276,19 +275,17 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_tup(vec![ty1, ty2])\n     }\n \n-    pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n+    pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        self.infcx.tcx.mk_param(space, index, token::intern(&name[..]))\n+        self.infcx.tcx.mk_param(index, token::intern(&name[..]))\n     }\n \n     pub fn re_early_bound(&self,\n-                          space: subst::ParamSpace,\n                           index: u32,\n                           name: &'static str)\n                           -> ty::Region {\n         let name = token::intern(name);\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            space: space,\n             index: index,\n             name: name,\n         })\n@@ -674,12 +671,12 @@ fn subst_ty_renumber_bound() {\n \n         // t_source = fn(A)\n         let t_source = {\n-            let t_param = env.t_param(subst::TypeSpace, 0);\n+            let t_param = env.t_param(0);\n             env.t_fn(&[t_param], env.t_nil())\n         };\n \n-        let substs = subst::Substs::new_type(vec![t_rptr_bound1], vec![]);\n-        let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n+        let substs = Substs::new(env.infcx.tcx, vec![t_rptr_bound1], vec![]);\n+        let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)\n         let t_expected = {\n@@ -709,12 +706,12 @@ fn subst_ty_renumber_some_bounds() {\n \n         // t_source = (A, fn(A))\n         let t_source = {\n-            let t_param = env.t_param(subst::TypeSpace, 0);\n+            let t_param = env.t_param(0);\n             env.t_pair(t_param, env.t_fn(&[t_param], env.t_nil()))\n         };\n \n-        let substs = subst::Substs::new_type(vec![t_rptr_bound1], vec![]);\n-        let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n+        let substs = Substs::new(env.infcx.tcx, vec![t_rptr_bound1], vec![]);\n+        let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = (&'a isize, fn(&'a isize))\n         //\n@@ -755,7 +752,7 @@ fn escaping() {\n         assert!(t_rptr_bound2.has_escaping_regions());\n \n         // t_fn = fn(A)\n-        let t_param = env.t_param(subst::TypeSpace, 0);\n+        let t_param = env.t_param(0);\n         assert!(!t_param.has_escaping_regions());\n         let t_fn = env.t_fn(&[t_param], env.t_nil());\n         assert!(!t_fn.has_escaping_regions());\n@@ -771,12 +768,12 @@ fn subst_region_renumber_region() {\n \n         // type t_source<'a> = fn(&'a isize)\n         let t_source = {\n-            let re_early = env.re_early_bound(subst::TypeSpace, 0, \"'a\");\n+            let re_early = env.re_early_bound(0, \"'a\");\n             env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n         };\n \n-        let substs = subst::Substs::new_type(vec![], vec![re_bound1]);\n-        let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n+        let substs = Substs::new(env.infcx.tcx, vec![], vec![re_bound1]);\n+        let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)\n         //"}, {"sha": "61d927239828b2124894debb7581181f9834cff7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -465,16 +465,14 @@ impl LateLintPass for MissingCopyImplementations {\n                     return;\n                 }\n                 let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n-                (def, cx.tcx.mk_struct(def,\n-                                       cx.tcx.mk_substs(Substs::empty())))\n+                (def, cx.tcx.mk_struct(def, Substs::empty(cx.tcx)))\n             }\n             hir::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n                 let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n-                (def, cx.tcx.mk_enum(def,\n-                                     cx.tcx.mk_substs(Substs::empty())))\n+                (def, cx.tcx.mk_enum(def, Substs::empty(cx.tcx)))\n             }\n             _ => return,\n         };\n@@ -898,7 +896,7 @@ impl LateLintPass for UnconditionalRecursion {\n                 // A trait method, from any number of possible sources.\n                 // Attempt to select a concrete impl before checking.\n                 ty::TraitContainer(trait_def_id) => {\n-                    let trait_ref = callee_substs.to_trait_ref(tcx, trait_def_id);\n+                    let trait_ref = ty::TraitRef::from_method(tcx, trait_def_id, callee_substs);\n                     let trait_ref = ty::Binder(trait_ref);\n                     let span = tcx.map.span(expr_id);\n                     let obligation =\n@@ -918,8 +916,7 @@ impl LateLintPass for UnconditionalRecursion {\n                             // If `T` is `Self`, then this call is inside\n                             // a default method definition.\n                             Ok(Some(traits::VtableParam(_))) => {\n-                                let self_ty = callee_substs.self_ty();\n-                                let on_self = self_ty.map_or(false, |t| t.is_self());\n+                                let on_self = trait_ref.self_ty().is_self();\n                                 // We can only be recurring in a default\n                                 // method if we're being called literally\n                                 // on the `Self` type."}, {"sha": "1ef48e6d6565fcc1c43f0570f5d3ba75bc1cefe4", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 10, "deletions": 59, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -34,7 +34,7 @@ use middle::const_qualif::ConstQualif;\n use rustc::hir::def::{self, Def};\n use rustc::hir::def_id::DefId;\n use middle::region;\n-use rustc::ty::subst;\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n \n use syntax::ast;\n@@ -413,7 +413,7 @@ impl tr for Def {\n           Def::AssociatedTy(trait_did, did) =>\n               Def::AssociatedTy(trait_did.tr(dcx), did.tr(dcx)),\n           Def::PrimTy(p) => Def::PrimTy(p),\n-          Def::TyParam(s, index, def_id, n) => Def::TyParam(s, index, def_id.tr(dcx), n),\n+          Def::TyParam(did) => Def::TyParam(did.tr(dcx)),\n           Def::Upvar(_, nid1, index, nid2) => {\n               let nid1 = dcx.tr_id(nid1);\n               let nid2 = dcx.tr_id(nid2);\n@@ -507,7 +507,7 @@ impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n                     Ok(this.read_ty(dcx))\n                 }).unwrap(),\n                 substs: this.read_struct_field(\"substs\", 3, |this| {\n-                    Ok(dcx.tcx.mk_substs(this.read_substs(dcx)))\n+                    Ok(this.read_substs(dcx))\n                 }).unwrap()\n             }))\n         }).unwrap()\n@@ -524,16 +524,8 @@ pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n trait rbml_writer_helpers<'tcx> {\n     fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n-    fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n-    fn emit_predicate<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                          predicate: &ty::Predicate<'tcx>);\n-    fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                          ty: &ty::TraitRef<'tcx>);\n     fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                       substs: &subst::Substs<'tcx>);\n-    fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n-                                   bounds: &ty::ExistentialBounds<'tcx>);\n-    fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds);\n+                       substs: &Substs<'tcx>);\n     fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture);\n     fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                 adj: &adjustment::AutoAdjustment<'tcx>);\n@@ -556,39 +548,6 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                                                     ty)));\n     }\n \n-    fn emit_tys<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, tys: &[Ty<'tcx>]) {\n-        self.emit_from_vec(tys, |this, ty| Ok(this.emit_ty(ecx, *ty)));\n-    }\n-\n-    fn emit_trait_ref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                          trait_ref: &ty::TraitRef<'tcx>) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_trait_ref(&mut this.cursor,\n-                                                           &ecx.ty_str_ctxt(),\n-                                                           *trait_ref)));\n-    }\n-\n-    fn emit_predicate<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                          predicate: &ty::Predicate<'tcx>) {\n-        self.emit_opaque(|this| {\n-            Ok(tyencode::enc_predicate(&mut this.cursor,\n-                                       &ecx.ty_str_ctxt(),\n-                                       predicate))\n-        });\n-    }\n-\n-    fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n-                                   bounds: &ty::ExistentialBounds<'tcx>) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(&mut this.cursor,\n-                                                                    &ecx.ty_str_ctxt(),\n-                                                                    bounds)));\n-    }\n-\n-    fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_builtin_bounds(&mut this.cursor,\n-                                                                &ecx.ty_str_ctxt(),\n-                                                                bounds)));\n-    }\n-\n     fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture) {\n         use rustc_serialize::Encoder;\n \n@@ -610,7 +569,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     }\n \n     fn emit_substs<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                       substs: &subst::Substs<'tcx>) {\n+                       substs: &Substs<'tcx>) {\n         self.emit_opaque(|this| Ok(tyencode::enc_substs(&mut this.cursor,\n                                                         &ecx.ty_str_ctxt(),\n                                                         substs)));\n@@ -879,10 +838,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                    -> ty::PolyTraitRef<'tcx>;\n     fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> ty::Predicate<'tcx>;\n-    fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                       -> ty::ExistentialBounds<'tcx>;\n     fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                           -> subst::Substs<'tcx>;\n+                           -> &'tcx Substs<'tcx>;\n     fn read_upvar_capture(&mut self, dcx: &DecodeContext)\n                           -> ty::UpvarCapture;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -902,7 +859,7 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                           cdata: &cstore::CrateMetadata) -> Vec<Ty<'tcx>>;\n     fn read_substs_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              cdata: &cstore::CrateMetadata)\n-                             -> subst::Substs<'tcx>;\n+                             -> &'tcx Substs<'tcx>;\n }\n \n impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n@@ -927,7 +884,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n     fn read_substs_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                              cdata: &cstore::CrateMetadata)\n-                             -> subst::Substs<'tcx>\n+                             -> &'tcx Substs<'tcx>\n     {\n         self.read_opaque(|_, doc| {\n             Ok(\n@@ -988,14 +945,8 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         self.read_ty_encoded(dcx, |decoder| decoder.parse_predicate())\n     }\n \n-    fn read_existential_bounds<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                       -> ty::ExistentialBounds<'tcx>\n-    {\n-        self.read_ty_encoded(dcx, |decoder| decoder.parse_existential_bounds())\n-    }\n-\n     fn read_substs<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                           -> subst::Substs<'tcx> {\n+                           -> &'tcx Substs<'tcx> {\n         self.read_opaque(|_, doc| {\n             Ok(tydecode::TyDecoder::with_doc(dcx.tcx, dcx.cdata.cnum, doc,\n                                              &mut |d| convert_def_id(dcx, d))\n@@ -1189,7 +1140,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     c::tag_table_item_subst => {\n                         let item_substs = ty::ItemSubsts {\n-                            substs: dcx.tcx.mk_substs(val_dsr.read_substs(dcx))\n+                            substs: val_dsr.read_substs(dcx)\n                         };\n                         dcx.tcx.tables.borrow_mut().item_substs.insert(\n                             id, item_substs);"}, {"sha": "99a3f3b00c8b0f4ca4824c8c457595a9a629b2d5", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -196,20 +196,14 @@ pub const tag_attribute_is_sugared_doc: usize = 0x8c;\n // GAP 0x8d\n pub const tag_items_data_region: usize = 0x8e;\n \n-pub const tag_region_param_def: usize = 0x8f;\n-pub const tag_region_param_def_ident: usize = 0x90;\n-pub const tag_region_param_def_def_id: usize = 0x91;\n-pub const tag_region_param_def_space: usize = 0x92;\n-pub const tag_region_param_def_index: usize = 0x93;\n+pub const tag_item_generics: usize = 0x8f;\n+// GAP 0x90, 0x91, 0x92, 0x93, 0x94\n \n-pub const tag_type_param_def: usize = 0x94;\n+pub const tag_item_predicates: usize = 0x95;\n+// GAP 0x96\n \n-pub const tag_item_generics: usize = 0x95;\n-pub const tag_method_ty_generics: usize = 0x96;\n-\n-pub const tag_type_predicate: usize = 0x97;\n-pub const tag_self_predicate: usize = 0x98;\n-pub const tag_fn_predicate: usize = 0x99;\n+pub const tag_predicate: usize = 0x97;\n+// GAP 0x98, 0x99\n \n pub const tag_unsafety: usize = 0x9a;\n "}, {"sha": "f6d698eb969d80baa919273315ecda8a27289077", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -86,7 +86,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     }\n \n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                     -> ty::TypeScheme<'tcx>\n+                     -> Ty<'tcx>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n@@ -109,6 +109,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_super_predicates(&cdata, def.index, tcx)\n     }\n \n+    fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                         -> &'tcx ty::Generics<'tcx>\n+    {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_generics(&cdata, def.index, tcx)\n+    }\n+\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n@@ -231,11 +239,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_parent_impl(&*cdata, impl_def.index)\n     }\n \n-    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId>\n-    {\n+    fn trait_of_item(&self, def_id: DefId) -> Option<DefId> {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let cdata = self.get_crate_data(def_id.krate);\n-        decoder::get_trait_of_item(&cdata, def_id.index, tcx)\n+        decoder::get_trait_of_item(&cdata, def_id.index)\n     }\n \n     fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)"}, {"sha": "5488f114db32ff610576f227ed063a70bdda421a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 30, "deletions": 71, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -35,7 +35,6 @@ use middle::cstore::{DefLike, DlDef, DlField, DlImpl, tls};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex};\n use middle::lang_items;\n-use rustc::ty::subst;\n use rustc::ty::{ImplContainer, TraitContainer};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, VariantKind};\n \n@@ -265,11 +264,6 @@ fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata:\n     })\n }\n \n-pub fn item_type<'a, 'tcx>(_item_id: DefId, item: rbml::Doc,\n-                           tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n-    doc_type(item, tcx, cdata)\n-}\n-\n fn doc_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n                            -> ty::TraitRef<'tcx> {\n     TyDecoder::with_doc(tcx, cdata.cnum, doc,\n@@ -384,7 +378,7 @@ pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n                                tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::TraitDef<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n-    let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n+    let generics = doc_generics(item_doc, tcx, cdata);\n     let unsafety = parse_unsafety(item_doc);\n     let associated_type_names = parse_associated_type_names(item_doc);\n     let paren_sugar = parse_paren_sugar(item_doc);\n@@ -494,7 +488,7 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n             // from the ctor.\n             debug!(\"evaluating the ctor-type of {:?}\",\n                    variant.name);\n-            let ctor_ty = get_type(cdata, variant.did.index, tcx).ty;\n+            let ctor_ty = get_type(cdata, variant.did.index, tcx);\n             debug!(\"evaluating the ctor-type of {:?}.. {:?}\",\n                    variant.name,\n                    ctor_ty);\n@@ -514,7 +508,7 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n         } else {\n             for field in &variant.fields {\n                 debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n-                let ty = get_type(cdata, field.did.index, tcx).ty;\n+                let ty = get_type(cdata, field.did.index, tcx);\n                 field.fulfill_ty(ty);\n                 debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n                        variant.name, field.name, ty);\n@@ -531,7 +525,7 @@ pub fn get_predicates<'a, 'tcx>(cdata: Cmd,\n                                 -> ty::GenericPredicates<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n-    doc_predicates(item_doc, tcx, cdata, tag_item_generics)\n+    doc_predicates(item_doc, tcx, cdata, tag_item_predicates)\n }\n \n pub fn get_super_predicates<'a, 'tcx>(cdata: Cmd,\n@@ -543,17 +537,20 @@ pub fn get_super_predicates<'a, 'tcx>(cdata: Cmd,\n     doc_predicates(item_doc, tcx, cdata, tag_item_super_predicates)\n }\n \n+pub fn get_generics<'a, 'tcx>(cdata: Cmd,\n+                              item_id: DefIndex,\n+                              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                              -> &'tcx ty::Generics<'tcx>\n+{\n+    let item_doc = cdata.lookup_item(item_id);\n+    doc_generics(item_doc, tcx, cdata)\n+}\n+\n pub fn get_type<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                          -> ty::TypeScheme<'tcx>\n+                          -> Ty<'tcx>\n {\n     let item_doc = cdata.lookup_item(id);\n-    let t = item_type(DefId { krate: cdata.cnum, index: id }, item_doc, tcx,\n-                      cdata);\n-    let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n-    ty::TypeScheme {\n-        generics: generics,\n-        ty: t\n-    }\n+    doc_type(item_doc, tcx, cdata)\n }\n \n pub fn get_stability(cdata: Cmd, id: DefIndex) -> Option<attr::Stability> {\n@@ -961,8 +958,8 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n             }))\n         }\n         Some('r') | Some('p') => {\n-            let generics = doc_generics(item_doc, tcx, cdata, tag_method_ty_generics);\n-            let predicates = doc_predicates(item_doc, tcx, cdata, tag_method_ty_generics);\n+            let generics = doc_generics(item_doc, tcx, cdata);\n+            let predicates = doc_predicates(item_doc, tcx, cdata, tag_item_predicates);\n             let ity = tcx.lookup_item_type(def_id).ty;\n             let fty = match ity.sty {\n                 ty::TyFnDef(_, _, fty) => fty,\n@@ -1394,10 +1391,7 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n     }\n }\n \n-pub fn get_trait_of_item<'a, 'tcx>(cdata: Cmd,\n-                                   id: DefIndex,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                   -> Option<DefId> {\n+pub fn get_trait_of_item(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n     let item_doc = cdata.lookup_item(id);\n     let parent_item_id = match item_parent_item(cdata, item_doc) {\n         None => return None,\n@@ -1406,10 +1400,6 @@ pub fn get_trait_of_item<'a, 'tcx>(cdata: Cmd,\n     let parent_item_doc = cdata.lookup_item(parent_item_id.index);\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n-        Impl | DefaultImpl => {\n-            reader::maybe_get_doc(parent_item_doc, tag_item_trait_ref)\n-                .map(|_| item_trait_ref(parent_item_doc, tcx, cdata).def_id)\n-        }\n         _ => None\n     }\n }\n@@ -1538,11 +1528,7 @@ pub fn is_extern_item<'a, 'tcx>(cdata: Cmd,\n     };\n     let applicable = match item_family(item_doc) {\n         ImmStatic | MutStatic => true,\n-        Fn => {\n-            let ty::TypeScheme { generics, .. } = get_type(cdata, id, tcx);\n-            let no_generics = generics.types.is_empty();\n-            no_generics\n-        },\n+        Fn => get_generics(cdata, id, tcx).types.is_empty(),\n         _ => false,\n     };\n \n@@ -1574,31 +1560,13 @@ pub fn is_impl(cdata: Cmd, id: DefIndex) -> bool {\n \n fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          cdata: Cmd,\n-                          tag: usize)\n-                          -> ty::Generics<'tcx>\n+                          cdata: Cmd)\n+                          -> &'tcx ty::Generics<'tcx>\n {\n-    let doc = reader::get_doc(base_doc, tag);\n-\n-    let mut types = subst::VecPerParamSpace::empty();\n-    for p in reader::tagged_docs(doc, tag_type_param_def) {\n-        let bd =\n-            TyDecoder::with_doc(tcx, cdata.cnum, p,\n-                                &mut |did| translate_def_id(cdata, did))\n-            .parse_type_param_def();\n-        types.push(bd.space, bd);\n-    }\n-\n-    let mut regions = subst::VecPerParamSpace::empty();\n-    for p in reader::tagged_docs(doc, tag_region_param_def) {\n-        let bd =\n-            TyDecoder::with_doc(tcx, cdata.cnum, p,\n-                                &mut |did| translate_def_id(cdata, did))\n-            .parse_region_param_def();\n-        regions.push(bd.space, bd);\n-    }\n-\n-    ty::Generics { types: types, regions: regions }\n+    let doc = reader::get_doc(base_doc, tag_item_generics);\n+    TyDecoder::with_doc(tcx, cdata.cnum, doc,\n+                        &mut |did| translate_def_id(cdata, did))\n+        .parse_generics()\n }\n \n fn doc_predicate<'a, 'tcx>(cdata: Cmd,\n@@ -1622,21 +1590,12 @@ fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n {\n     let doc = reader::get_doc(base_doc, tag);\n \n-    let mut predicates = subst::VecPerParamSpace::empty();\n-    for predicate_doc in reader::tagged_docs(doc, tag_type_predicate) {\n-        predicates.push(subst::TypeSpace,\n-                        doc_predicate(cdata, predicate_doc, tcx));\n-    }\n-    for predicate_doc in reader::tagged_docs(doc, tag_self_predicate) {\n-        predicates.push(subst::SelfSpace,\n-                        doc_predicate(cdata, predicate_doc, tcx));\n-    }\n-    for predicate_doc in reader::tagged_docs(doc, tag_fn_predicate) {\n-        predicates.push(subst::FnSpace,\n-                        doc_predicate(cdata, predicate_doc, tcx));\n+    ty::GenericPredicates {\n+        parent: item_parent_item(cdata, doc),\n+        predicates: reader::tagged_docs(doc, tag_predicate).map(|predicate_doc| {\n+            doc_predicate(cdata, predicate_doc, tcx)\n+        }).collect()\n     }\n-\n-    ty::GenericPredicates { predicates: predicates }\n }\n \n pub fn is_defaulted_trait(cdata: Cmd, trait_id: DefIndex) -> bool {"}, {"sha": "320ba3c8d9dc863c9344c800cc6228cf6a247097", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 51, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -26,7 +26,6 @@ use rustc::hir::def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n use rustc::dep_graph::{DepGraph, DepNode, DepTask};\n-use rustc::ty::subst;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n@@ -176,8 +175,7 @@ fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n                                     index: &mut CrateIndex<'a, 'tcx>,\n                                     scheme: &ty::TypeScheme<'tcx>,\n                                     predicates: &ty::GenericPredicates<'tcx>) {\n-    encode_generics(rbml_w, ecx, index,\n-                    &scheme.generics, &predicates, tag_item_generics);\n+    encode_generics(rbml_w, ecx, index, &scheme.generics, &predicates);\n     encode_type(ecx, rbml_w, scheme.ty);\n }\n \n@@ -511,56 +509,29 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n                              ecx: &EncodeContext<'a, 'tcx>,\n                              index: &mut CrateIndex<'a, 'tcx>,\n                              generics: &ty::Generics<'tcx>,\n-                             predicates: &ty::GenericPredicates<'tcx>,\n-                             tag: usize)\n+                             predicates: &ty::GenericPredicates<'tcx>)\n {\n-    rbml_w.start_tag(tag);\n-\n-    for param in &generics.types {\n-        rbml_w.start_tag(tag_type_param_def);\n-        tyencode::enc_type_param_def(rbml_w.writer, &ecx.ty_str_ctxt(), param);\n-        rbml_w.mark_stable_position();\n-        rbml_w.end_tag();\n-    }\n-\n-    // Region parameters\n-    for param in &generics.regions {\n-        rbml_w.start_tag(tag_region_param_def);\n-        tyencode::enc_region_param_def(rbml_w.writer, &ecx.ty_str_ctxt(), param);\n-        rbml_w.mark_stable_position();\n-        rbml_w.end_tag();\n-    }\n-\n-    encode_predicates_in_current_doc(rbml_w, ecx, index, predicates);\n-\n+    rbml_w.start_tag(tag_item_generics);\n+    tyencode::enc_generics(rbml_w.writer, &ecx.ty_str_ctxt(), generics);\n+    rbml_w.mark_stable_position();\n     rbml_w.end_tag();\n-}\n \n-fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n-                                             _ecx: &EncodeContext<'a,'tcx>,\n-                                             index: &mut CrateIndex<'a, 'tcx>,\n-                                             predicates: &ty::GenericPredicates<'tcx>)\n-{\n-    for (space, _, predicate) in predicates.predicates.iter_enumerated() {\n-        let tag = match space {\n-            subst::TypeSpace => tag_type_predicate,\n-            subst::SelfSpace => tag_self_predicate,\n-            subst::FnSpace => tag_fn_predicate\n-        };\n-\n-        rbml_w.wr_tagged_u32(tag,\n-            index.add_xref(XRef::Predicate(predicate.clone())));\n-    }\n+    encode_predicates(rbml_w, index, predicates, tag_item_predicates);\n }\n \n fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n-                              ecx: &EncodeContext<'a,'tcx>,\n                               index: &mut CrateIndex<'a, 'tcx>,\n                               predicates: &ty::GenericPredicates<'tcx>,\n                               tag: usize)\n {\n     rbml_w.start_tag(tag);\n-    encode_predicates_in_current_doc(rbml_w, ecx, index, predicates);\n+    if let Some(def_id) = predicates.parent {\n+        rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(def_id));\n+    }\n+    for predicate in &predicates.predicates {\n+        rbml_w.wr_tagged_u32(tag_predicate,\n+            index.add_xref(XRef::Predicate(predicate.clone())));\n+    }\n     rbml_w.end_tag();\n }\n \n@@ -571,8 +542,7 @@ fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_def_id_and_key(ecx, rbml_w, method_ty.def_id);\n     encode_name(rbml_w, method_ty.name);\n     encode_generics(rbml_w, ecx, index,\n-                    &method_ty.generics, &method_ty.predicates,\n-                    tag_method_ty_generics);\n+                    &method_ty.generics, &method_ty.predicates);\n     encode_visibility(rbml_w, method_ty.vis);\n     encode_explicit_self(rbml_w, &method_ty.explicit_self);\n     match method_ty.explicit_self {\n@@ -653,9 +623,9 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     if let Some(impl_item) = impl_item_opt {\n         if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n             encode_attributes(rbml_w, &impl_item.attrs);\n-            let scheme = ecx.tcx.lookup_item_type(m.def_id);\n-            let any_types = !scheme.generics.types.is_empty();\n-            let needs_inline = any_types || is_default_impl ||\n+            let generics = ecx.tcx.lookup_generics(m.def_id);\n+            let types = generics.parent_types as usize + generics.types.len();\n+            let needs_inline = types > 0 || is_default_impl ||\n                                attr::requests_inline(&impl_item.attrs);\n             if needs_inline || sig.constness == hir::Constness::Const {\n                 encode_inlined_item(ecx,\n@@ -702,7 +672,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &ii.attrs);\n         encode_defaultness(rbml_w, ii.defaultness);\n     } else {\n-        encode_predicates(rbml_w, ecx, index,\n+        encode_predicates(rbml_w, index,\n                           &ecx.tcx.lookup_predicates(associated_type.def_id),\n                           tag_item_generics);\n     }\n@@ -1141,9 +1111,8 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n         encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n         encode_generics(rbml_w, ecx, index,\n-                        &trait_def.generics, &trait_predicates,\n-                        tag_item_generics);\n-        encode_predicates(rbml_w, ecx, index,\n+                        &trait_def.generics, &trait_predicates);\n+        encode_predicates(rbml_w, index,\n                           &tcx.lookup_super_predicates(def_id),\n                           tag_item_super_predicates);\n         encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);"}, {"sha": "6e78cbcd28e731e663b698a6fc16d2068b041113", "filename": "src/librustc_metadata/tls_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Ftls_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Ftls_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftls_context.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx: 'a> tls::DecodingContext<'tcx> for DecodingContext<'a, 'tcx> {\n         ty\n     }\n \n-    fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> Substs<'tcx> {\n+    fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> &'tcx Substs<'tcx> {\n         let def_id_convert = &mut |did| {\n             decoder::translate_def_id(self.crate_metadata, did)\n         };"}, {"sha": "c76cf2363923741b12a2db7c2e1421fe2fe61c78", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 90, "deletions": 67, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -20,8 +20,7 @@ use rustc::hir;\n \n use rustc::hir::def_id::{DefId, DefIndex};\n use middle::region;\n-use rustc::ty::subst;\n-use rustc::ty::subst::VecPerParamSpace;\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n use rbml;\n@@ -129,24 +128,48 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    fn parse_vec_per_param_space<T, F>(&mut self, mut f: F) -> VecPerParamSpace<T> where\n-        F: FnMut(&mut TyDecoder<'a, 'tcx>) -> T,\n-    {\n-        let mut r = VecPerParamSpace::empty();\n-        for &space in &subst::ParamSpace::all() {\n-            assert_eq!(self.next(), '[');\n-            while self.peek() != ']' {\n-                r.push(space, f(self));\n-            }\n-            assert_eq!(self.next(), ']');\n+    pub fn parse_substs(&mut self) -> &'tcx Substs<'tcx> {\n+        let mut regions = vec![];\n+        let mut types = vec![];\n+        assert_eq!(self.next(), '[');\n+        while self.peek() != '|' {\n+            regions.push(self.parse_region());\n+        }\n+        assert_eq!(self.next(), '|');\n+        while self.peek() != ']' {\n+            types.push(self.parse_ty());\n         }\n-        r\n+        assert_eq!(self.next(), ']');\n+\n+        Substs::new(self.tcx, types, regions)\n     }\n \n-    pub fn parse_substs(&mut self) -> subst::Substs<'tcx> {\n-        let regions = self.parse_vec_per_param_space(|this| this.parse_region());\n-        let types = self.parse_vec_per_param_space(|this| this.parse_ty());\n-        subst::Substs { types: types, regions: regions }\n+    pub fn parse_generics(&mut self) -> &'tcx ty::Generics<'tcx> {\n+        let parent = self.parse_opt(|this| this.parse_def());\n+        let parent_regions = self.parse_u32();\n+        assert_eq!(self.next(), '|');\n+        let parent_types = self.parse_u32();\n+\n+        let mut regions = vec![];\n+        let mut types = vec![];\n+        assert_eq!(self.next(), '[');\n+        while self.peek() != '|' {\n+            regions.push(self.parse_region_param_def());\n+        }\n+        assert_eq!(self.next(), '|');\n+        while self.peek() != ']' {\n+            types.push(self.parse_type_param_def());\n+        }\n+        assert_eq!(self.next(), ']');\n+\n+        self.tcx.alloc_generics(ty::Generics {\n+            parent: parent,\n+            parent_regions: parent_regions,\n+            parent_types: parent_types,\n+            regions: regions,\n+            types: types,\n+            has_self: self.next() == 'S'\n+        })\n     }\n \n     fn parse_bound_region(&mut self) -> ty::BoundRegion {\n@@ -196,13 +219,10 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'B' => {\n                 assert_eq!(self.next(), '[');\n-                let space = self.parse_param_space();\n-                assert_eq!(self.next(), '|');\n                 let index = self.parse_u32();\n                 assert_eq!(self.next(), '|');\n                 let name = token::intern(&self.parse_str(']'));\n                 ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                    space: space,\n                     index: index,\n                     name: name\n                 })\n@@ -302,9 +322,17 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n     pub fn parse_trait_ref(&mut self) -> ty::TraitRef<'tcx> {\n-        let def = self.parse_def();\n-        let substs = self.tcx.mk_substs(self.parse_substs());\n-        ty::TraitRef {def_id: def, substs: substs}\n+        ty::TraitRef {\n+            def_id: self.parse_def(),\n+            substs: self.parse_substs()\n+        }\n+    }\n+\n+    pub fn parse_existential_trait_ref(&mut self) -> ty::ExistentialTraitRef<'tcx> {\n+        ty::ExistentialTraitRef {\n+            def_id: self.parse_def(),\n+            substs: self.parse_substs()\n+        }\n     }\n \n     pub fn parse_ty(&mut self) -> Ty<'tcx> {\n@@ -336,23 +364,41 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 let substs = self.parse_substs();\n                 assert_eq!(self.next(), ']');\n                 let def = self.tcx.lookup_adt_def(did);\n-                return tcx.mk_enum(def, self.tcx.mk_substs(substs));\n+                return tcx.mk_enum(def, substs);\n             }\n             'x' => {\n                 assert_eq!(self.next(), '[');\n-                let trait_ref = ty::Binder(self.parse_trait_ref());\n-                let bounds = self.parse_existential_bounds();\n+                let trait_ref = ty::Binder(self.parse_existential_trait_ref());\n+                let builtin_bounds = self.parse_builtin_bounds();\n+                let region_bound = self.parse_region();\n+                let mut projection_bounds = Vec::new();\n+\n+                loop {\n+                    match self.next() {\n+                        'P' => {\n+                            let bound = self.parse_existential_projection();\n+                            projection_bounds.push(ty::Binder(bound));\n+                        }\n+                        '.' => { break; }\n+                        c => {\n+                            bug!(\"parse_bounds: bad bounds ('{}')\", c)\n+                        }\n+                    }\n+                }\n                 assert_eq!(self.next(), ']');\n-                return tcx.mk_trait(trait_ref, bounds);\n+                return tcx.mk_trait(ty::TraitObject {\n+                    principal: trait_ref,\n+                    region_bound: region_bound,\n+                    builtin_bounds: builtin_bounds,\n+                    projection_bounds: projection_bounds\n+                });\n             }\n             'p' => {\n                 assert_eq!(self.next(), '[');\n                 let index = self.parse_u32();\n                 assert_eq!(self.next(), '|');\n-                let space = self.parse_param_space();\n-                assert_eq!(self.next(), '|');\n                 let name = token::intern(&self.parse_str(']'));\n-                return tcx.mk_param(space, index, name);\n+                return tcx.mk_param(index, name);\n             }\n             '~' => return tcx.mk_box(self.parse_ty()),\n             '*' => return tcx.mk_ptr(self.parse_mt()),\n@@ -380,7 +426,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'F' => {\n                 let def_id = self.parse_def();\n-                let substs = self.tcx.mk_substs(self.parse_substs());\n+                let substs = self.parse_substs();\n                 return tcx.mk_fn_def(def_id, substs, self.parse_bare_fn_ty());\n             }\n             'G' => {\n@@ -426,7 +472,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 let substs = self.parse_substs();\n                 assert_eq!(self.next(), ']');\n                 let def = self.tcx.lookup_adt_def(did);\n-                return self.tcx.mk_struct(def, self.tcx.mk_substs(substs));\n+                return self.tcx.mk_struct(def, substs);\n             }\n             'k' => {\n                 assert_eq!(self.next(), '[');\n@@ -438,7 +484,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 }\n                 assert_eq!(self.next(), '.');\n                 assert_eq!(self.next(), ']');\n-                return self.tcx.mk_closure(did, self.tcx.mk_substs(substs), tys);\n+                return self.tcx.mk_closure(did, substs, tys);\n             }\n             'P' => {\n                 assert_eq!(self.next(), '[');\n@@ -451,7 +497,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 let def_id = self.parse_def();\n                 let substs = self.parse_substs();\n                 assert_eq!(self.next(), ']');\n-                return self.tcx.mk_anon(def_id, self.tcx.mk_substs(substs));\n+                return self.tcx.mk_anon(def_id, substs);\n             }\n             'e' => {\n                 return tcx.types.err;\n@@ -495,10 +541,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         m\n     }\n \n-    fn parse_param_space(&mut self) -> subst::ParamSpace {\n-        subst::ParamSpace::from_uint(self.parse_uint())\n-    }\n-\n     fn parse_abi_set(&mut self) -> abi::Abi {\n         assert_eq!(self.next(), '[');\n         let bytes = self.scan(|c| c == ']');\n@@ -588,11 +630,17 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    pub fn parse_type_param_def(&mut self) -> ty::TypeParameterDef<'tcx> {\n+    fn parse_existential_projection(&mut self) -> ty::ExistentialProjection<'tcx> {\n+        ty::ExistentialProjection {\n+            trait_ref: self.parse_existential_trait_ref(),\n+            item_name: token::intern(&self.parse_str('|')),\n+            ty: self.parse_ty(),\n+        }\n+    }\n+\n+    fn parse_type_param_def(&mut self) -> ty::TypeParameterDef<'tcx> {\n         let name = self.parse_name(':');\n         let def_id = self.parse_def();\n-        let space = self.parse_param_space();\n-        assert_eq!(self.next(), '|');\n         let index = self.parse_u32();\n         assert_eq!(self.next(), '|');\n         let default_def_id = self.parse_def();\n@@ -602,19 +650,16 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         ty::TypeParameterDef {\n             name: name,\n             def_id: def_id,\n-            space: space,\n             index: index,\n             default_def_id: default_def_id,\n             default: default,\n             object_lifetime_default: object_lifetime_default,\n         }\n     }\n \n-    pub fn parse_region_param_def(&mut self) -> ty::RegionParameterDef {\n+    fn parse_region_param_def(&mut self) -> ty::RegionParameterDef {\n         let name = self.parse_name(':');\n         let def_id = self.parse_def();\n-        let space = self.parse_param_space();\n-        assert_eq!(self.next(), '|');\n         let index = self.parse_u32();\n         assert_eq!(self.next(), '|');\n         let mut bounds = vec![];\n@@ -630,7 +675,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         ty::RegionParameterDef {\n             name: name,\n             def_id: def_id,\n-            space: space,\n             index: index,\n             bounds: bounds,\n         }\n@@ -649,27 +693,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    pub fn parse_existential_bounds(&mut self) -> ty::ExistentialBounds<'tcx> {\n-        let builtin_bounds = self.parse_builtin_bounds();\n-        let region_bound = self.parse_region();\n-        let mut projection_bounds = Vec::new();\n-\n-        loop {\n-            match self.next() {\n-                'P' => {\n-                    projection_bounds.push(ty::Binder(self.parse_projection_predicate()));\n-                }\n-                '.' => { break; }\n-                c => {\n-                    bug!(\"parse_bounds: bad bounds ('{}')\", c)\n-                }\n-            }\n-        }\n-\n-        ty::ExistentialBounds::new(\n-            region_bound, builtin_bounds, projection_bounds)\n-    }\n-\n     fn parse_builtin_bounds(&mut self) -> ty::BuiltinBounds {\n         let mut builtin_bounds = ty::BuiltinBounds::empty();\n         loop {"}, {"sha": "90fd8a0eb2f654f2fa69e25c3b10ab5b426eb831", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 80, "deletions": 68, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -19,9 +19,7 @@ use std::io::prelude::*;\n \n use rustc::hir::def_id::DefId;\n use middle::region;\n-use rustc::ty::subst;\n-use rustc::ty::subst::VecPerParamSpace;\n-use rustc::ty::ParamTy;\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FnvHashMap;\n \n@@ -104,11 +102,26 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n             enc_substs(w, cx, substs);\n             write!(w, \"]\");\n         }\n-        ty::TyTrait(box ty::TraitTy { ref principal,\n-                                       ref bounds }) => {\n+        ty::TyTrait(ref obj) => {\n             write!(w, \"x[\");\n-            enc_trait_ref(w, cx, principal.0);\n-            enc_existential_bounds(w, cx, bounds);\n+            enc_existential_trait_ref(w, cx, obj.principal.0);\n+            enc_builtin_bounds(w, cx, &obj.builtin_bounds);\n+\n+            enc_region(w, cx, obj.region_bound);\n+\n+            // Encode projection_bounds in a stable order\n+            let mut projection_bounds: Vec<_> = obj.projection_bounds\n+                                                .iter()\n+                                                .map(|b| (b.item_name().as_str(), b))\n+                                                .collect();\n+            projection_bounds.sort_by_key(|&(ref name, _)| name.clone());\n+\n+            for tp in projection_bounds.iter().map(|&(_, tp)| tp) {\n+                write!(w, \"P\");\n+                enc_existential_projection(w, cx, &tp.0);\n+            }\n+\n+            write!(w, \".\");\n             write!(w, \"]\");\n         }\n         ty::TyTuple(ts) => {\n@@ -149,8 +162,8 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n         ty::TyInfer(_) => {\n             bug!(\"cannot encode inference variable types\");\n         }\n-        ty::TyParam(ParamTy {space, idx, name}) => {\n-            write!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), name);\n+        ty::TyParam(p) => {\n+            write!(w, \"p[{}|{}]\", p.idx, p.name);\n         }\n         ty::TyStruct(def, substs) => {\n             write!(w, \"a[{}|\", (cx.ds)(cx.tcx, def.did));\n@@ -235,27 +248,42 @@ fn enc_opt<T, F>(w: &mut Cursor<Vec<u8>>, t: Option<T>, enc_f: F) where\n     }\n }\n \n-fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut Cursor<Vec<u8>>,\n-                                           cx: &ctxt<'a, 'tcx>,\n-                                           v: &VecPerParamSpace<T>,\n-                                           mut op: F) where\n-    F: FnMut(&mut Cursor<Vec<u8>>, &ctxt<'a, 'tcx>, &T),\n-{\n-    for &space in &subst::ParamSpace::all() {\n-        write!(w, \"[\");\n-        for t in v.get_slice(space) {\n-            op(w, cx, t);\n-        }\n-        write!(w, \"]\");\n+pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n+                            substs: &Substs<'tcx>) {\n+    write!(w, \"[\");\n+    for &r in &substs.regions {\n+        enc_region(w, cx, r);\n+    }\n+    write!(w, \"|\");\n+    for &ty in &substs.types {\n+        enc_ty(w, cx, ty);\n     }\n+    write!(w, \"]\");\n }\n \n-pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                            substs: &subst::Substs<'tcx>) {\n-    enc_vec_per_param_space(w, cx, &substs.regions,\n-                            |w, cx, &r| enc_region(w, cx, r));\n-    enc_vec_per_param_space(w, cx, &substs.types,\n-                            |w, cx, &ty| enc_ty(w, cx, ty));\n+pub fn enc_generics<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n+                              generics: &ty::Generics<'tcx>) {\n+    enc_opt(w, generics.parent, |w, def_id| {\n+        write!(w, \"{}|\", (cx.ds)(cx.tcx, def_id));\n+    });\n+    write!(w, \"{}|{}[\",\n+           generics.parent_regions,\n+           generics.parent_types);\n+\n+    for r in &generics.regions {\n+        enc_region_param_def(w, cx, r)\n+    }\n+    write!(w, \"|\");\n+    for t in &generics.types {\n+        enc_type_param_def(w, cx, t);\n+    }\n+    write!(w, \"]\");\n+\n+    if generics.has_self {\n+        write!(w, \"S\");\n+    } else {\n+        write!(w, \"N\");\n+    }\n }\n \n pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: ty::Region) {\n@@ -266,8 +294,7 @@ pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: ty::Region) {\n             write!(w, \"]\");\n         }\n         ty::ReEarlyBound(ref data) => {\n-            write!(w, \"B[{}|{}|{}]\",\n-                   data.space.to_uint(),\n+            write!(w, \"B[{}|{}]\",\n                    data.index,\n                    data.name);\n         }\n@@ -344,6 +371,12 @@ pub fn enc_trait_ref<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n     enc_substs(w, cx, s.substs);\n }\n \n+fn enc_existential_trait_ref<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n+                                       s: ty::ExistentialTraitRef<'tcx>) {\n+    write!(w, \"{}|\", (cx.ds)(cx.tcx, s.def_id));\n+    enc_substs(w, cx, s.substs);\n+}\n+\n fn enc_unsafety(w: &mut Cursor<Vec<u8>>, p: hir::Unsafety) {\n     match p {\n         hir::Unsafety::Normal => write!(w, \"n\"),\n@@ -386,7 +419,7 @@ fn enc_fn_sig<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n     enc_ty(w, cx, fsig.0.output);\n }\n \n-pub fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n+fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n     for bound in bs {\n         match bound {\n             ty::BoundSend => write!(w, \"S\"),\n@@ -399,42 +432,19 @@ pub fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinB\n     write!(w, \".\");\n }\n \n-pub fn enc_existential_bounds<'a,'tcx>(w: &mut Cursor<Vec<u8>>,\n-                                       cx: &ctxt<'a,'tcx>,\n-                                       bs: &ty::ExistentialBounds<'tcx>) {\n-    enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n-\n-    enc_region(w, cx, bs.region_bound);\n-\n-    // Encode projection_bounds in a stable order\n-    let mut projection_bounds: Vec<_> = bs.projection_bounds\n-                                          .iter()\n-                                          .map(|b| (b.item_name().as_str(), b))\n-                                          .collect();\n-    projection_bounds.sort_by_key(|&(ref name, _)| name.clone());\n-\n-    for tp in projection_bounds.iter().map(|&(_, tp)| tp) {\n-        write!(w, \"P\");\n-        enc_projection_predicate(w, cx, &tp.0);\n-    }\n-\n-    write!(w, \".\");\n-}\n-\n-pub fn enc_type_param_def<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                                    v: &ty::TypeParameterDef<'tcx>) {\n-    write!(w, \"{}:{}|{}|{}|{}|\",\n-             v.name, (cx.ds)(cx.tcx, v.def_id),\n-             v.space.to_uint(), v.index, (cx.ds)(cx.tcx, v.default_def_id));\n+fn enc_type_param_def<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n+                                v: &ty::TypeParameterDef<'tcx>) {\n+    write!(w, \"{}:{}|{}|{}|\",\n+           v.name, (cx.ds)(cx.tcx, v.def_id),\n+           v.index, (cx.ds)(cx.tcx, v.default_def_id));\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n }\n \n-pub fn enc_region_param_def(w: &mut Cursor<Vec<u8>>, cx: &ctxt,\n-                            v: &ty::RegionParameterDef) {\n-    write!(w, \"{}:{}|{}|{}|\",\n-             v.name, (cx.ds)(cx.tcx, v.def_id),\n-             v.space.to_uint(), v.index);\n+fn enc_region_param_def(w: &mut Cursor<Vec<u8>>, cx: &ctxt,\n+                        v: &ty::RegionParameterDef) {\n+    write!(w, \"{}:{}|{}|\",\n+           v.name, (cx.ds)(cx.tcx, v.def_id), v.index);\n     for &r in &v.bounds {\n         write!(w, \"R\");\n         enc_region(w, cx, r);\n@@ -489,7 +499,9 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n         }\n         ty::Predicate::Projection(ty::Binder(ref data)) => {\n             write!(w, \"p\");\n-            enc_projection_predicate(w, cx, data);\n+            enc_trait_ref(w, cx, data.projection_ty.trait_ref);\n+            write!(w, \"{}|\", data.projection_ty.item_name);\n+            enc_ty(w, cx, data.ty);\n         }\n         ty::Predicate::WellFormed(data) => {\n             write!(w, \"w\");\n@@ -509,10 +521,10 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n     }\n }\n \n-fn enc_projection_predicate<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n-                                      cx: &ctxt<'a, 'tcx>,\n-                                      data: &ty::ProjectionPredicate<'tcx>) {\n-    enc_trait_ref(w, cx, data.projection_ty.trait_ref);\n-    write!(w, \"{}|\", data.projection_ty.item_name);\n+fn enc_existential_projection<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n+                                        cx: &ctxt<'a, 'tcx>,\n+                                        data: &ty::ExistentialProjection<'tcx>) {\n+    enc_existential_trait_ref(w, cx, data.trait_ref);\n+    write!(w, \"{}|\", data.item_name);\n     enc_ty(w, cx, data.ty);\n }"}, {"sha": "5e4053a82ad8a3ce22a7c6b093733073d08864e5", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -89,7 +89,7 @@ should go to.\n use build::{BlockAnd, BlockAndExtension, Builder, CFG, ScopeAuxiliary, ScopeId};\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::middle::lang_items;\n-use rustc::ty::subst::{Substs, Subst, VecPerParamSpace};\n+use rustc::ty::subst::{Substs, Subst};\n use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::repr::*;\n use syntax_pos::Span;\n@@ -750,10 +750,7 @@ fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                               -> TerminatorKind<'tcx> {\n     let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n                        .unwrap_or_else(|e| tcx.sess.fatal(&e));\n-    let substs = tcx.mk_substs(Substs::new(\n-        VecPerParamSpace::new(vec![], vec![], vec![data.item_ty]),\n-        VecPerParamSpace::new(vec![], vec![], vec![])\n-    ));\n+    let substs = Substs::new(tcx, vec![data.item_ty], vec![]);\n     TerminatorKind::Call {\n         func: Operand::Constant(Constant {\n             span: data.span,"}, {"sha": "972e7f5be7075ed339a7cba7754e5f5bfb42d692", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -147,16 +147,16 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         params: Vec<Ty<'tcx>>)\n                         -> (Ty<'tcx>, Literal<'tcx>) {\n         let method_name = token::intern(method_name);\n-        let substs = Substs::new_trait(params, vec![], self_ty);\n+        let substs = Substs::new_trait(self.tcx, params, vec![], self_ty);\n         for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n             match *trait_item {\n                 ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n                     if method.name == method_name {\n                         let method_ty = self.tcx.lookup_item_type(method.def_id);\n-                        let method_ty = method_ty.ty.subst(self.tcx, &substs);\n+                        let method_ty = method_ty.ty.subst(self.tcx, substs);\n                         return (method_ty, Literal::Item {\n                             def_id: method.def_id,\n-                            substs: self.tcx.mk_substs(substs),\n+                            substs: substs,\n                         });\n                     }\n                 }"}, {"sha": "823005e9c5388b9e61e5a0a3a0e4dd08430be4a8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -49,7 +49,6 @@ use rustc::lint;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n-use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n@@ -561,7 +560,7 @@ impl<'a> Visitor for Resolver<'a> {\n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         let type_parameters = match foreign_item.node {\n             ForeignItemKind::Fn(_, ref generics) => {\n-                HasTypeParameters(generics, FnSpace, ItemRibKind)\n+                HasTypeParameters(generics, ItemRibKind)\n             }\n             ForeignItemKind::Static(..) => NoTypeParameters,\n         };\n@@ -629,10 +628,6 @@ enum TypeParameters<'a, 'b> {\n     HasTypeParameters(// Type parameters.\n                       &'b Generics,\n \n-                      // Identifies the things that these parameters\n-                      // were declared on (type, fn, etc)\n-                      ParamSpace,\n-\n                       // The kind of the rib used for type parameters.\n                       RibKind<'a>),\n }\n@@ -1617,12 +1612,9 @@ impl<'a> Resolver<'a> {\n         match item.node {\n             ItemKind::Enum(_, ref generics) |\n             ItemKind::Ty(_, ref generics) |\n-            ItemKind::Struct(_, ref generics) => {\n-                self.with_type_parameter_rib(HasTypeParameters(generics, TypeSpace, ItemRibKind),\n-                                             |this| visit::walk_item(this, item));\n-            }\n+            ItemKind::Struct(_, ref generics) |\n             ItemKind::Fn(_, _, _, _, ref generics, _) => {\n-                self.with_type_parameter_rib(HasTypeParameters(generics, FnSpace, ItemRibKind),\n+                self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind),\n                                              |this| visit::walk_item(this, item));\n             }\n \n@@ -1638,10 +1630,7 @@ impl<'a> Resolver<'a> {\n \n             ItemKind::Trait(_, ref generics, ref bounds, ref trait_items) => {\n                 // Create a new rib for the trait-wide type parameters.\n-                self.with_type_parameter_rib(HasTypeParameters(generics,\n-                                                               TypeSpace,\n-                                                               ItemRibKind),\n-                                             |this| {\n+                self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n                     let local_def_id = this.definitions.local_def_id(item.id);\n                     this.with_self_rib(Def::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n@@ -1664,7 +1653,6 @@ impl<'a> Resolver<'a> {\n                                 TraitItemKind::Method(ref sig, _) => {\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n-                                                          FnSpace,\n                                                           MethodRibKind(!sig.decl.has_self()));\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n                                         visit::walk_trait_item(this, trait_item)\n@@ -1733,10 +1721,10 @@ impl<'a> Resolver<'a> {\n         where F: FnOnce(&mut Resolver)\n     {\n         match type_parameters {\n-            HasTypeParameters(generics, space, rib_kind) => {\n+            HasTypeParameters(generics, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = HashMap::new();\n-                for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n+                for type_parameter in &generics.ty_params {\n                     let name = type_parameter.ident.name;\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n@@ -1751,7 +1739,7 @@ impl<'a> Resolver<'a> {\n \n                     // plain insert (no renaming)\n                     let def_id = self.definitions.local_def_id(type_parameter.id);\n-                    let def = Def::TyParam(space, index as u32, def_id, name);\n+                    let def = Def::TyParam(def_id);\n                     function_type_rib.bindings.insert(ast::Ident::with_empty_ctxt(name), def);\n                     self.record_def(type_parameter.id, PathResolution::new(def));\n                 }\n@@ -1923,10 +1911,7 @@ impl<'a> Resolver<'a> {\n                               item_id: NodeId,\n                               impl_items: &[ImplItem]) {\n         // If applicable, create a rib for the type parameters.\n-        self.with_type_parameter_rib(HasTypeParameters(generics,\n-                                                       TypeSpace,\n-                                                       ItemRibKind),\n-                                     |this| {\n+        self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n             // Resolve the type parameters.\n             this.visit_generics(generics);\n \n@@ -1959,7 +1944,6 @@ impl<'a> Resolver<'a> {\n                                     // specific type parameters.\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n-                                                          FnSpace,\n                                                           MethodRibKind(!sig.decl.has_self()));\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n                                         visit::walk_impl_item(this, impl_item);"}, {"sha": "db535e22f194d1a9bd5e23401d2f8918cacbc3e9", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -299,8 +299,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             let mut result = String::from(\"<\");\n                             result.push_str(&rustc::hir::print::ty_to_string(&ty));\n \n-                            if let Some(def_id) = self.tcx\n-                                    .trait_of_item(self.tcx.map.local_def_id(id)) {\n+                            if let Some(def_id) = self.tcx.trait_id_of_impl(impl_id) {\n                                 result.push_str(\" as \");\n                                 result.push_str(&self.tcx.item_path_str(def_id));\n                             }\n@@ -491,7 +490,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Def::Enum(def_id) |\n             Def::TyAlias(def_id) |\n             Def::Trait(def_id) |\n-            Def::TyParam(_, _, def_id, _) => {\n+            Def::TyParam(def_id) => {\n                 Some(Data::TypeRefData(TypeRefData {\n                     span: sub_span.unwrap(),\n                     ref_id: Some(def_id),"}, {"sha": "d6866b27f98a56869da645060afa69fb7a84a6ab", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -895,7 +895,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                            &format!(\"comparison of `{}`\", rhs_t),\n                            StrEqFnLangItem);\n         let args = [lhs_data, lhs_len, rhs_data, rhs_len];\n-        Callee::def(bcx.ccx(), did, bcx.tcx().mk_substs(Substs::empty()))\n+        Callee::def(bcx.ccx(), did, Substs::empty(bcx.tcx()))\n             .call(bcx, debug_loc, ArgVals(&args), None)\n     }\n "}, {"sha": "d48ec98a20dfb3d308a0cfa73507d9569d879269", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -48,7 +48,7 @@ use std;\n use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n-use rustc::ty::subst;\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::attr;\n@@ -544,7 +544,7 @@ impl<'tcx> Case<'tcx> {\n \n fn get_cases<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        adt: ty::AdtDef<'tcx>,\n-                       substs: &subst::Substs<'tcx>)\n+                       substs: &Substs<'tcx>)\n                        -> Vec<Case<'tcx>> {\n     adt.variants.iter().map(|vi| {\n         let field_tys = vi.fields.iter().map(|field| {"}, {"sha": "25a1479c289488c43af1001a3b26db4556300efa", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n         // and should not matter anyhow.\n         let instance_ty = scx.tcx().erase_regions(&instance_ty.ty);\n \n-        let hash = get_symbol_hash(scx, &def_path, instance_ty, substs.types.as_slice());\n+        let hash = get_symbol_hash(scx, &def_path, instance_ty, &substs.types);\n \n         let mut buffer = SymbolPathBuffer {\n             names: Vec::with_capacity(def_path.data.len())"}, {"sha": "f190fbeb6feb9553d42e7cda76ceb1cf77620ac1", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -39,7 +39,7 @@ use rustc::cfg;\n use rustc::hir::def_id::DefId;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use rustc::hir::pat_util::simple_name;\n-use rustc::ty::subst::{self, Substs};\n+use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n@@ -218,7 +218,7 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Allocate space:\n     let def_id = require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem);\n-    let r = Callee::def(bcx.ccx(), def_id, bcx.tcx().mk_substs(Substs::empty()))\n+    let r = Callee::def(bcx.ccx(), def_id, Substs::empty(bcx.tcx()))\n         .call(bcx, debug_loc, ArgVals(&[size, align]), None);\n \n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n@@ -562,14 +562,9 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             // change to the vtable.\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n-        (_, &ty::TyTrait(box ty::TraitTy { ref principal, .. })) => {\n-            // Note that we preserve binding levels here:\n-            let substs = principal.0.substs.with_self_ty(source).erase_regions();\n-            let substs = ccx.tcx().mk_substs(substs);\n-            let trait_ref = ty::Binder(ty::TraitRef {\n-                def_id: principal.def_id(),\n-                substs: substs,\n-            });\n+        (_, &ty::TyTrait(ref data)) => {\n+            let trait_ref = data.principal.with_self_ty(ccx.tcx(), source);\n+            let trait_ref = ccx.tcx().erase_regions(&trait_ref);\n             consts::ptrcast(meth::get_vtable(ccx, trait_ref),\n                             Type::vtable_ptr(ccx))\n         }\n@@ -675,14 +670,9 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n                                              source_ty: Ty<'tcx>,\n                                              target_ty: Ty<'tcx>)\n                                              -> CustomCoerceUnsized {\n-    let trait_substs = Substs::new(subst::VecPerParamSpace::new(vec![target_ty],\n-                                                                vec![source_ty],\n-                                                                Vec::new()),\n-                                   subst::VecPerParamSpace::empty());\n-\n     let trait_ref = ty::Binder(ty::TraitRef {\n         def_id: scx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n-        substs: scx.tcx().mk_substs(trait_substs)\n+        substs: Substs::new_trait(scx.tcx(), vec![target_ty], vec![], source_ty)\n     });\n \n     match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n@@ -1418,7 +1408,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                 common::validate_substs(instance.substs);\n                 (instance.substs, Some(instance.def), Some(inlined_id))\n             }\n-            None => (ccx.tcx().mk_substs(Substs::empty()), None, None)\n+            None => (Substs::empty(ccx.tcx()), None, None)\n         };\n \n         let local_id = def_id.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n@@ -2183,7 +2173,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n                     Ok(id) => id,\n                     Err(s) => ccx.sess().fatal(&s)\n                 };\n-                let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n+                let empty_substs = Substs::empty(ccx.tcx());\n                 let start_fn = Callee::def(ccx, start_def_id, empty_substs).reify(ccx).val;\n                 let args = {\n                     let opaque_rust_main =\n@@ -2480,8 +2470,8 @@ pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n             hir_map::NodeImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(..), .. }) => {\n                 let def_id = tcx.map.local_def_id(id);\n-                let scheme = tcx.lookup_item_type(def_id);\n-                scheme.generics.types.is_empty()\n+                let generics = tcx.lookup_generics(def_id);\n+                generics.parent_types == 0 && generics.types.is_empty()\n             }\n \n             _ => false"}, {"sha": "d50959b5ab3023d9cfaf99bec87929f8580dc6e6", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -22,7 +22,7 @@ use back::symbol_names;\n use llvm::{self, ValueRef, get_params};\n use middle::cstore::LOCAL_CRATE;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst;\n+use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::hir::map as hir_map;\n use abi::{Abi, FnType};\n@@ -105,13 +105,12 @@ impl<'tcx> Callee<'tcx> {\n     /// Function or method definition.\n     pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>,\n                    def_id: DefId,\n-                   substs: &'tcx subst::Substs<'tcx>)\n+                   substs: &'tcx Substs<'tcx>)\n                    -> Callee<'tcx> {\n         let tcx = ccx.tcx();\n \n-        if substs.self_ty().is_some() {\n-            // Only trait methods can have a Self parameter.\n-            return Callee::trait_method(ccx, def_id, substs);\n+        if let Some(trait_id) = tcx.trait_of_item(def_id) {\n+            return Callee::trait_method(ccx, trait_id, def_id, substs);\n         }\n \n         let maybe_node_id = inline::get_local_instance(ccx, def_id)\n@@ -144,24 +143,21 @@ impl<'tcx> Callee<'tcx> {\n \n     /// Trait method, which has to be resolved to an impl method.\n     pub fn trait_method<'a>(ccx: &CrateContext<'a, 'tcx>,\n+                            trait_id: DefId,\n                             def_id: DefId,\n-                            substs: &'tcx subst::Substs<'tcx>)\n+                            substs: &'tcx Substs<'tcx>)\n                             -> Callee<'tcx> {\n         let tcx = ccx.tcx();\n \n-        let method_item = tcx.impl_or_trait_item(def_id);\n-        let trait_id = method_item.container().id();\n-        let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n-        let trait_ref = tcx.normalize_associated_type(&trait_ref);\n+        let trait_ref = ty::TraitRef::from_method(tcx, trait_id, substs);\n+        let trait_ref = tcx.normalize_associated_type(&ty::Binder(trait_ref));\n         match common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref) {\n             traits::VtableImpl(vtable_impl) => {\n                 let impl_did = vtable_impl.impl_def_id;\n                 let mname = tcx.item_name(def_id);\n                 // create a concatenated set of substitutions which includes\n                 // those from the impl and those from the method:\n-                let impl_substs = vtable_impl.substs.with_method_from(&substs);\n-                let substs = tcx.mk_substs(impl_substs);\n-                let mth = meth::get_impl_method(tcx, impl_did, substs, mname);\n+                let mth = meth::get_impl_method(tcx, substs, impl_did, vtable_impl.substs, mname);\n \n                 // Translate the function, bypassing Callee::def.\n                 // That is because default methods have the same ID as the\n@@ -275,7 +271,7 @@ impl<'tcx> Callee<'tcx> {\n /// Given a DefId and some Substs, produces the monomorphic item type.\n fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     def_id: DefId,\n-                    substs: &'tcx subst::Substs<'tcx>)\n+                    substs: &'tcx Substs<'tcx>)\n                     -> Ty<'tcx> {\n     let ty = tcx.lookup_item_type(def_id).ty;\n     monomorphize::apply_param_substs(tcx, substs, &ty)\n@@ -427,7 +423,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n /// - `substs`: values for each of the fn/method's parameters\n fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     def_id: DefId,\n-                    substs: &'tcx subst::Substs<'tcx>)\n+                    substs: &'tcx Substs<'tcx>)\n                     -> Datum<'tcx, Rvalue> {\n     let tcx = ccx.tcx();\n "}, {"sha": "76910304eebb0e40c43717fbe1c4f8cf1c3ad2ff", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 30, "deletions": 41, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -195,7 +195,7 @@ use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::{ExchangeFreeFnLangItem, ExchangeMallocFnLangItem};\n use rustc::traits;\n-use rustc::ty::subst::{self, Substs, Subst};\n+use rustc::ty::subst::{Substs, Subst};\n use rustc::ty::{self, TypeFoldable, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::repr as mir;\n@@ -732,7 +732,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             create_fn_trans_item(scx.tcx(),\n                                  exchange_free_fn_def_id,\n                                  fn_substs,\n-                                 scx.tcx().mk_substs(Substs::empty()));\n+                                 Substs::empty(scx.tcx()));\n \n         output.push(exchange_free_fn_trans_item);\n     }\n@@ -753,8 +753,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                    .drop_trait()\n                                    .unwrap();\n \n-        let self_type_substs = scx.tcx().mk_substs(\n-            Substs::empty().with_self_ty(ty));\n+        let self_type_substs = Substs::new_trait(scx.tcx(), vec![], vec![], ty);\n \n         let trait_ref = ty::TraitRef {\n             def_id: drop_trait_def_id,\n@@ -770,7 +769,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             let trans_item = create_fn_trans_item(scx.tcx(),\n                                                   destructor_did,\n                                                   substs,\n-                                                  scx.tcx().mk_substs(Substs::empty()));\n+                                                  Substs::empty(scx.tcx()));\n             output.push(trans_item);\n         }\n \n@@ -854,26 +853,15 @@ fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n            fn_substs,\n            param_substs);\n \n-    let is_trait_method = scx.tcx().trait_of_item(fn_def_id).is_some();\n-\n-    if is_trait_method {\n+    if let Some(trait_def_id) = scx.tcx().trait_of_item(fn_def_id) {\n         match scx.tcx().impl_or_trait_item(fn_def_id) {\n             ty::MethodTraitItem(ref method) => {\n-                match method.container {\n-                    ty::TraitContainer(trait_def_id) => {\n-                        debug!(\" => trait method, attempting to find impl\");\n-                        do_static_trait_method_dispatch(scx,\n-                                                        method,\n-                                                        trait_def_id,\n-                                                        fn_substs,\n-                                                        param_substs)\n-                    }\n-                    ty::ImplContainer(_) => {\n-                        // This is already a concrete implementation\n-                        debug!(\" => impl method\");\n-                        Some((fn_def_id, fn_substs))\n-                    }\n-                }\n+                debug!(\" => trait method, attempting to find impl\");\n+                do_static_trait_method_dispatch(scx,\n+                                                method,\n+                                                trait_def_id,\n+                                                fn_substs,\n+                                                param_substs)\n             }\n             _ => bug!()\n         }\n@@ -903,13 +891,12 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n            callee_substs,\n            param_substs);\n \n+\n     let rcvr_substs = monomorphize::apply_param_substs(tcx,\n                                                        param_substs,\n                                                        &callee_substs);\n-\n-    let trait_ref = ty::Binder(rcvr_substs.to_trait_ref(tcx, trait_id));\n-    let trait_ref = tcx.normalize_associated_type(&trait_ref);\n-    let vtbl = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n+    let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n+    let vtbl = fulfill_obligation(scx, DUMMY_SP, ty::Binder(trait_ref));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -919,10 +906,10 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             substs: impl_substs,\n             nested: _ }) =>\n         {\n-            let callee_substs = impl_substs.with_method_from(&rcvr_substs);\n             let impl_method = meth::get_impl_method(tcx,\n+                                                    rcvr_substs,\n                                                     impl_did,\n-                                                    tcx.mk_substs(callee_substs),\n+                                                    impl_substs,\n                                                     trait_method.name);\n             Some((impl_method.method.def_id, &impl_method.substs))\n         }\n@@ -1055,8 +1042,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n     assert!(!trait_ty.needs_subst() && !impl_ty.needs_subst());\n \n     if let ty::TyTrait(ref trait_ty) = trait_ty.sty {\n-        let poly_trait_ref = trait_ty.principal_trait_ref_with_self_ty(scx.tcx(),\n-                                                                       impl_ty);\n+        let poly_trait_ref = trait_ty.principal.with_self_ty(scx.tcx(), impl_ty);\n \n         // Walk all methods of the trait, including those of its supertraits\n         for trait_ref in traits::supertraits(scx.tcx(), poly_trait_ref) {\n@@ -1077,7 +1063,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                                 Some(create_fn_trans_item(scx.tcx(),\n                                     impl_method.method.def_id,\n                                     impl_method.substs,\n-                                    scx.tcx().mk_substs(Substs::empty())))\n+                                    Substs::empty(scx.tcx())))\n                             } else {\n                                 None\n                             }\n@@ -1233,38 +1219,41 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    def_id_to_string(tcx, impl_def_id));\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n-                let default_impls = tcx.provided_trait_methods(trait_ref.def_id);\n                 let callee_substs = tcx.erase_regions(&trait_ref.substs);\n                 let overridden_methods: FnvHashSet<_> = items.iter()\n                                                              .map(|item| item.name)\n                                                              .collect();\n-                for default_impl in default_impls {\n-                    if overridden_methods.contains(&default_impl.name) {\n+                for method in tcx.provided_trait_methods(trait_ref.def_id) {\n+                    if overridden_methods.contains(&method.name) {\n                         continue;\n                     }\n \n-                    if default_impl.generics.has_type_params(subst::FnSpace) {\n+                    if !method.generics.types.is_empty() {\n                         continue;\n                     }\n \n                     // The substitutions we have are on the impl, so we grab\n                     // the method type from the impl to substitute into.\n+                    let impl_substs = Substs::for_item(tcx, impl_def_id,\n+                                                       |_, _| ty::ReErased,\n+                                                       |_, _| tcx.types.err);\n                     let mth = meth::get_impl_method(tcx,\n-                                                    impl_def_id,\n                                                     callee_substs,\n-                                                    default_impl.name);\n+                                                    impl_def_id,\n+                                                    impl_substs,\n+                                                    method.name);\n \n                     assert!(mth.is_provided);\n \n                     let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n-                    if !normalize_and_test_predicates(tcx, predicates.into_vec()) {\n+                    if !normalize_and_test_predicates(tcx, predicates) {\n                         continue;\n                     }\n \n-                    if can_have_local_instance(tcx, default_impl.def_id) {\n+                    if can_have_local_instance(tcx, method.def_id) {\n                         let empty_substs = tcx.erase_regions(&mth.substs);\n                         let item = create_fn_trans_item(tcx,\n-                                                        default_impl.def_id,\n+                                                        method.def_id,\n                                                         callee_substs,\n                                                         empty_substs);\n                         output.push(item);"}, {"sha": "b1aaea7d984c9ee4d20b04927b1f04ba8b578ac0", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -523,7 +523,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         let tcx = ccx.tcx();\n         match tcx.lang_items.eh_personality() {\n             Some(def_id) if !base::wants_msvc_seh(ccx.sess()) => {\n-                Callee::def(ccx, def_id, tcx.mk_substs(Substs::empty())).reify(ccx).val\n+                Callee::def(ccx, def_id, Substs::empty(tcx)).reify(ccx).val\n             }\n             _ => {\n                 if let Some(llpersonality) = ccx.eh_personality().get() {\n@@ -550,7 +550,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         let tcx = ccx.tcx();\n         assert!(ccx.sess().target.target.options.custom_unwind_resume);\n         if let Some(def_id) = tcx.lang_items.eh_unwind_resume() {\n-            return Callee::def(ccx, def_id, tcx.mk_substs(Substs::empty()));\n+            return Callee::def(ccx, def_id, Substs::empty(tcx));\n         }\n \n         let ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {"}, {"sha": "0e9898896778c0a0b577b5f864694db6c1927493", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -208,7 +208,7 @@ fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let arg_ids = args.iter().map(|arg| arg.pat.id);\n     let fn_args = arg_ids.zip(arg_vals.iter().cloned()).collect();\n \n-    let substs = ccx.tcx().mk_substs(substs.clone().erase_regions());\n+    let substs = ccx.tcx().erase_regions(&substs);\n     let substs = monomorphize::apply_param_substs(ccx.tcx(),\n                                                   param_substs,\n                                                   &substs);\n@@ -222,7 +222,7 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> &'tcx hir::Expr {\n     let substs = ccx.tcx().node_id_item_substs(ref_expr.id).substs;\n-    let substs = ccx.tcx().mk_substs(substs.clone().erase_regions());\n+    let substs = ccx.tcx().erase_regions(&substs);\n     let substs = monomorphize::apply_param_substs(ccx.tcx(),\n                                                   param_substs,\n                                                   &substs);\n@@ -271,7 +271,7 @@ fn get_const_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                            param_substs: &'tcx Substs<'tcx>)\n                            -> Result<ValueRef, ConstEvalFailure> {\n     let expr = get_const_expr(ccx, def_id, ref_expr, param_substs);\n-    let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n+    let empty_substs = Substs::empty(ccx.tcx());\n     match get_const_expr_as_global(ccx, expr, ConstQualif::empty(), empty_substs, TrueConst::Yes) {\n         Err(Runtime(err)) => {\n             report_const_eval_err(ccx.tcx(), &err, expr.span, \"expression\").emit();\n@@ -1160,7 +1160,7 @@ pub fn trans_static(ccx: &CrateContext,\n         let v = if use_mir {\n             ::mir::trans_static_initializer(ccx, def_id)\n         } else {\n-            let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n+            let empty_substs = Substs::empty(ccx.tcx());\n             const_expr(ccx, expr, empty_substs, None, TrueConst::Yes)\n                 .map(|(v, _)| v)\n         }.map_err(|e| e.into_inner())?;"}, {"sha": "c31dbf8943e08972e2daee47d320e78d97c74a70", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -30,7 +30,7 @@ use monomorphize::Instance;\n use partitioning::CodegenUnit;\n use trans_item::TransItem;\n use type_::{Type, TypeNames};\n-use rustc::ty::subst::{Substs, VecPerParamSpace};\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use session::config::NoDebugInfo;\n use session::Session;\n@@ -571,16 +571,9 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        let scheme = self.tcx().lookup_item_type(item_def_id);\n-        self.empty_substs_for_scheme(&scheme)\n-    }\n-\n-    pub fn empty_substs_for_scheme(&self, scheme: &ty::TypeScheme<'tcx>)\n-                                   -> &'tcx Substs<'tcx> {\n-        assert!(scheme.generics.types.is_empty());\n-        self.tcx().mk_substs(\n-            Substs::new(VecPerParamSpace::empty(),\n-                        scheme.generics.regions.map(|_| ty::ReErased)))\n+        Substs::for_item(self.tcx(), item_def_id, |_, _| ty::ReErased, |_, _| {\n+            bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n+        })\n     }\n \n     pub fn symbol_hasher(&self) -> &RefCell<Sha256> {\n@@ -999,11 +992,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n         self.shared().empty_substs_for_def_id(item_def_id)\n     }\n-\n-    pub fn empty_substs_for_scheme(&self, scheme: &ty::TypeScheme<'tcx>)\n-                                   -> &'tcx Substs<'tcx> {\n-        self.shared().empty_substs_for_scheme(scheme)\n-    }\n }\n \n pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'tcx>);"}, {"sha": "8b3a8a2bfccfb87d1bff788c10f021dd08314e83", "filename": "src/librustc_trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontrolflow.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -401,7 +401,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let expr_file_line = consts::addr_of(ccx, expr_file_line_const, align, \"panic_loc\");\n     let args = vec!(expr_file_line);\n     let did = langcall(bcx.tcx(), Some(call_info.span), \"\", PanicFnLangItem);\n-    Callee::def(ccx, did, ccx.tcx().mk_substs(Substs::empty()))\n+    Callee::def(ccx, did, Substs::empty(ccx.tcx()))\n         .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n }\n \n@@ -429,6 +429,6 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let file_line = consts::addr_of(ccx, file_line_const, align, \"panic_bounds_check_loc\");\n     let args = vec!(file_line, index, len);\n     let did = langcall(bcx.tcx(), Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n-    Callee::def(ccx, did, ccx.tcx().mk_substs(Substs::empty()))\n+    Callee::def(ccx, did, Substs::empty(ccx.tcx()))\n         .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n }"}, {"sha": "f505efb1ab2f9aa18e994fbc2f2dbfd4d93acecc", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -27,7 +27,7 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util;\n-use rustc::ty::subst;\n+use rustc::ty::subst::Substs;\n use rustc::hir::map as hir_map;\n use rustc::hir::{self, PatKind};\n use {type_of, adt, machine, monomorphize};\n@@ -315,7 +315,7 @@ impl<'tcx> TypeMap<'tcx> {\n         fn from_def_id_and_substs<'a, 'tcx>(type_map: &mut TypeMap<'tcx>,\n                                             cx: &CrateContext<'a, 'tcx>,\n                                             def_id: DefId,\n-                                            substs: &subst::Substs<'tcx>,\n+                                            substs: &Substs<'tcx>,\n                                             output: &mut String) {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n@@ -346,7 +346,7 @@ impl<'tcx> TypeMap<'tcx> {\n             // Add the def-index as the second part\n             output.push_str(&format!(\"{:x}\", def_id.index.as_usize()));\n \n-            let tps = substs.types.get_slice(subst::TypeSpace);\n+            let tps = &substs.types;\n             if !tps.is_empty() {\n                 output.push('<');\n \n@@ -627,7 +627,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // But it does not describe the trait's methods.\n \n     let def_id = match trait_type.sty {\n-        ty::TyTrait(ref data) => data.principal_def_id(),\n+        ty::TyTrait(ref data) => data.principal.def_id(),\n         _ => {\n             bug!(\"debuginfo: Unexpected trait-object type in \\\n                   trait_pointer_metadata(): {:?}\",\n@@ -1086,7 +1086,7 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n // Creates MemberDescriptions for the fields of a struct\n struct StructMemberDescriptionFactory<'tcx> {\n     variant: ty::VariantDef<'tcx>,\n-    substs: &'tcx subst::Substs<'tcx>,\n+    substs: &'tcx Substs<'tcx>,\n     is_simd: bool,\n     span: Span,\n }"}, {"sha": "1ee000992b9c59cba899c758850ca1c5e47d1126", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -266,7 +266,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let generics = cx.tcx().lookup_item_type(fn_def_id).generics;\n+    let generics = cx.tcx().lookup_generics(fn_def_id);\n     let template_parameters = get_template_parameters(cx,\n                                                       &generics,\n                                                       instance.substs,\n@@ -358,7 +358,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                          name_to_append_suffix_to: &mut String)\n                                          -> DIArray\n     {\n-        let actual_types = param_substs.types.as_slice();\n+        let actual_types = &param_substs.types;\n \n         if actual_types.is_empty() {\n             return create_DIArray(DIB(cx), &[]);\n@@ -381,10 +381,11 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         // Again, only create type information if full debuginfo is enabled\n         let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n-            generics.types.as_slice().iter().enumerate().map(|(i, param)| {\n-                let actual_type = cx.tcx().normalize_associated_type(&actual_types[i]);\n+            let names = get_type_parameter_names(cx, generics);\n+            actual_types.iter().zip(names).map(|(ty, name)| {\n+                let actual_type = cx.tcx().normalize_associated_type(ty);\n                 let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n-                let name = CString::new(param.name.as_str().as_bytes()).unwrap();\n+                let name = CString::new(name.as_str().as_bytes()).unwrap();\n                 unsafe {\n                     llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n@@ -403,6 +404,16 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return create_DIArray(DIB(cx), &template_params[..]);\n     }\n \n+    fn get_type_parameter_names<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                          generics: &ty::Generics<'tcx>)\n+                                          -> Vec<ast::Name> {\n+        let mut names = generics.parent.map_or(vec![], |def_id| {\n+            get_type_parameter_names(cx, cx.tcx().lookup_generics(def_id))\n+        });\n+        names.extend(generics.types.iter().map(|param| param.name));\n+        names\n+    }\n+\n     fn get_containing_scope_and_span<'ccx, 'tcx>(cx: &CrateContext<'ccx, 'tcx>,\n                                                  instance: Instance<'tcx>)\n                                                  -> (DIScope, Span) {"}, {"sha": "2a996ca75a37e78597be98fafdf760ca2f0d291b", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -12,7 +12,7 @@\n \n use common::CrateContext;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst;\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n \n use rustc::hir;\n@@ -173,7 +173,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // would be possible but with inlining and LTO we have to use the least\n     // common denominator - otherwise we would run into conflicts.\n     fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                  substs: &subst::Substs<'tcx>,\n+                                  substs: &Substs<'tcx>,\n                                   output: &mut String) {\n         if substs.types.is_empty() {\n             return;"}, {"sha": "beb589c80bfc56f27a2d9f7d1aa74b1e2872aba6", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -175,7 +175,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 hir::ExprPath(..) => {\n                     match bcx.tcx().expect_def(expr.id) {\n                         Def::Const(did) | Def::AssociatedConst(did) => {\n-                            let empty_substs = bcx.tcx().mk_substs(Substs::empty());\n+                            let empty_substs = Substs::empty(bcx.tcx());\n                             let const_expr = consts::get_const_expr(bcx.ccx(), did, expr,\n                                                                     empty_substs);\n                             // Temporarily get cleanup scopes out of the way,"}, {"sha": "080844782f2051c31983602065c5afa43255a448", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -50,7 +50,7 @@ pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let def_id = langcall(bcx.tcx(), None, \"\", ExchangeFreeFnLangItem);\n     let args = [PointerCast(bcx, v, Type::i8p(bcx.ccx())), size, align];\n-    Callee::def(bcx.ccx(), def_id, bcx.tcx().mk_substs(Substs::empty()))\n+    Callee::def(bcx.ccx(), def_id, Substs::empty(bcx.tcx()))\n         .call(bcx, debug_loc, ArgVals(&args), None).bcx\n }\n \n@@ -356,7 +356,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let trait_ref = ty::Binder(ty::TraitRef {\n         def_id: tcx.lang_items.drop_trait().unwrap(),\n-        substs: tcx.mk_substs(Substs::empty().with_self_ty(t))\n+        substs: Substs::new_trait(tcx, vec![], vec![], t)\n     });\n     let vtbl = match fulfill_obligation(bcx.ccx().shared(), DUMMY_SP, trait_ref) {\n         traits::VtableImpl(data) => data,"}, {"sha": "ecee4705510595bc991844e1d79b48882acf5122", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -15,8 +15,7 @@ use intrinsics::{self, Intrinsic};\n use libc;\n use llvm;\n use llvm::{ValueRef, TypeKind};\n-use rustc::ty::subst;\n-use rustc::ty::subst::FnSpace;\n+use rustc::ty::subst::Substs;\n use abi::{Abi, FnType};\n use adt;\n use base::*;\n@@ -137,8 +136,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             callee::ArgExprs(arg_exprs) => {\n                 assert_eq!(arg_exprs.len(), 1);\n \n-                let (in_type, out_type) = (*substs.types.get(FnSpace, 0),\n-                                           *substs.types.get(FnSpace, 1));\n+                let (in_type, out_type) = (substs.types[0],\n+                                           substs.types[1]);\n                 let llintype = type_of::type_of(ccx, in_type);\n                 let llouttype = type_of::type_of(ccx, out_type);\n \n@@ -347,12 +346,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             Call(bcx, llfn, &[], call_debug_location)\n         }\n         (_, \"size_of\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n         }\n         (_, \"size_of_val\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             if !type_is_sized(tcx, tp_ty) {\n                 let (llsize, _) =\n                     glue::size_and_align_of_dst(&bcx.build(), tp_ty, llargs[1]);\n@@ -363,11 +362,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n         }\n         (_, \"min_align_of\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             C_uint(ccx, type_of::align_of(ccx, tp_ty))\n         }\n         (_, \"min_align_of_val\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             if !type_is_sized(tcx, tp_ty) {\n                 let (_, llalign) =\n                     glue::size_and_align_of_dst(&bcx.build(), tp_ty, llargs[1]);\n@@ -377,12 +376,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n         }\n         (_, \"pref_align_of\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty))\n         }\n         (_, \"drop_in_place\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             let ptr = if type_is_sized(tcx, tp_ty) {\n                 llargs[0]\n             } else {\n@@ -396,22 +395,22 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_nil(ccx)\n         }\n         (_, \"type_name\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             let ty_name = token::intern_and_get_ident(&tp_ty.to_string());\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {\n-            C_u64(ccx, ccx.tcx().type_id_hash(*substs.types.get(FnSpace, 0)))\n+            C_u64(ccx, ccx.tcx().type_id_hash(substs.types[0]))\n         }\n         (_, \"init_dropped\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             if !type_is_zero_size(ccx, tp_ty) {\n                 drop_done_fill_mem(bcx, llresult, tp_ty);\n             }\n             C_nil(ccx)\n         }\n         (_, \"init\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             if !type_is_zero_size(ccx, tp_ty) {\n                 // Just zero out the stack slot. (See comment on base::memzero for explanation)\n                 init_zero_mem(bcx, llresult, tp_ty);\n@@ -423,7 +422,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_nil(ccx)\n         }\n         (_, \"needs_drop\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n \n             C_bool(ccx, bcx.fcx.type_needs_drop(tp_ty))\n         }\n@@ -442,7 +441,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            false,\n                            false,\n-                           *substs.types.get(FnSpace, 0),\n+                           substs.types[0],\n                            llargs[1],\n                            llargs[0],\n                            llargs[2],\n@@ -452,7 +451,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            true,\n                            false,\n-                           *substs.types.get(FnSpace, 0),\n+                           substs.types[0],\n                            llargs[1],\n                            llargs[0],\n                            llargs[2],\n@@ -461,7 +460,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"write_bytes\") => {\n             memset_intrinsic(bcx,\n                              false,\n-                             *substs.types.get(FnSpace, 0),\n+                             substs.types[0],\n                              llargs[0],\n                              llargs[1],\n                              llargs[2],\n@@ -472,7 +471,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            false,\n                            true,\n-                           *substs.types.get(FnSpace, 0),\n+                           substs.types[0],\n                            llargs[0],\n                            llargs[1],\n                            llargs[2],\n@@ -482,7 +481,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             copy_intrinsic(bcx,\n                            true,\n                            true,\n-                           *substs.types.get(FnSpace, 0),\n+                           substs.types[0],\n                            llargs[0],\n                            llargs[1],\n                            llargs[2],\n@@ -491,14 +490,14 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"volatile_set_memory\") => {\n             memset_intrinsic(bcx,\n                              true,\n-                             *substs.types.get(FnSpace, 0),\n+                             substs.types[0],\n                              llargs[0],\n                              llargs[1],\n                              llargs[2],\n                              call_debug_location)\n         }\n         (_, \"volatile_load\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             let mut ptr = llargs[0];\n             if let Some(ty) = fn_ty.ret.cast {\n                 ptr = PointerCast(bcx, ptr, ty.ptr_to());\n@@ -510,7 +509,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             to_immediate(bcx, load, tp_ty)\n         },\n         (_, \"volatile_store\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let tp_ty = substs.types[0];\n             if type_is_fat_ptr(bcx.tcx(), tp_ty) {\n                 VolatileStore(bcx, llargs[1], expr::get_dataptr(bcx, llargs[0]));\n                 VolatileStore(bcx, llargs[2], expr::get_meta(bcx, llargs[0]));\n@@ -610,10 +609,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         },\n \n         (_, \"discriminant_value\") => {\n-            let val_ty = substs.types.get(FnSpace, 0);\n+            let val_ty = substs.types[0];\n             match val_ty.sty {\n                 ty::TyEnum(..) => {\n-                    let repr = adt::represent_type(ccx, *val_ty);\n+                    let repr = adt::represent_type(ccx, val_ty);\n                     adt::trans_get_discr(bcx, &repr, llargs[0],\n                                          Some(llret_ty), true)\n                 }\n@@ -664,7 +663,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n             match split[1] {\n                 \"cxchg\" | \"cxchgweak\" => {\n-                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    let sty = &substs.types[0].sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n                         let val = AtomicCmpXchg(bcx, llargs[0], llargs[1], llargs[2],\n@@ -683,7 +682,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"load\" => {\n-                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    let sty = &substs.types[0].sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         AtomicLoad(bcx, llargs[0], order)\n                     } else {\n@@ -696,7 +695,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"store\" => {\n-                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    let sty = &substs.types[0].sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         AtomicStore(bcx, llargs[1], llargs[0], order);\n                     } else {\n@@ -735,7 +734,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    let sty = &substs.types[0].sty;\n                     if int_type_width_signed(sty, ccx).is_some() {\n                         AtomicRMW(bcx, atom_op, llargs[0], llargs[1], order)\n                     } else {\n@@ -1284,7 +1283,7 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n     (bcx: Block<'blk, 'tcx>,\n      name: &str,\n-     substs: &'tcx subst::Substs<'tcx>,\n+     substs: &'tcx Substs<'tcx>,\n      callee_ty: Ty<'tcx>,\n      args: Option<&[P<hir::Expr>]>,\n      llargs: &[ValueRef],"}, {"sha": "b051028ebda6b6036f880752e352163c1f6b0c31", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -15,8 +15,7 @@ use arena::TypedArena;\n use back::symbol_names;\n use llvm::{ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::{FnSpace, Subst, Substs};\n-use rustc::ty::subst;\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, Reveal};\n use abi::FnType;\n use base::*;\n@@ -221,20 +220,20 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     impl_id: DefId,\n-                                    substs: &'tcx subst::Substs<'tcx>)\n+                                    substs: &'tcx Substs<'tcx>)\n                                     -> Vec<Option<ImplMethod<'tcx>>>\n {\n     debug!(\"get_vtable_methods(impl_id={:?}, substs={:?}\", impl_id, substs);\n \n-    let trt_id = match tcx.impl_trait_ref(impl_id) {\n+    let trait_id = match tcx.impl_trait_ref(impl_id) {\n         Some(t_id) => t_id.def_id,\n         None       => bug!(\"make_impl_vtable: don't know how to \\\n                             make a vtable for a type impl!\")\n     };\n \n-    tcx.populate_implementations_for_trait_if_necessary(trt_id);\n+    tcx.populate_implementations_for_trait_if_necessary(trait_id);\n \n-    let trait_item_def_ids = tcx.trait_item_def_ids(trt_id);\n+    let trait_item_def_ids = tcx.trait_item_def_ids(trait_id);\n     trait_item_def_ids\n         .iter()\n \n@@ -260,7 +259,7 @@ pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let name = trait_method_type.name;\n \n             // Some methods cannot be called on an object; skip those.\n-            if !tcx.is_vtable_safe_method(trt_id, &trait_method_type) {\n+            if !tcx.is_vtable_safe_method(trait_id, &trait_method_type) {\n                 debug!(\"get_vtable_methods: not vtable safe\");\n                 return None;\n             }\n@@ -270,15 +269,13 @@ pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             // the method may have some early-bound lifetimes, add\n             // regions for those\n-            let num_dummy_regions = trait_method_type.generics.regions.len(FnSpace);\n-            let dummy_regions = vec![ty::ReErased; num_dummy_regions];\n-            let method_substs = substs.clone()\n-                                      .with_method(vec![], dummy_regions);\n-            let method_substs = tcx.mk_substs(method_substs);\n+            let method_substs = Substs::for_item(tcx, trait_method_def_id,\n+                                                 |_, _| ty::ReErased,\n+                                                 |_, _| tcx.types.err);\n \n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n-            let mth = get_impl_method(tcx, impl_id, method_substs, name);\n+            let mth = get_impl_method(tcx, method_substs, impl_id, substs, name);\n \n             debug!(\"get_vtable_methods: mth={:?}\", mth);\n \n@@ -289,7 +286,7 @@ pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // try and trans it, in that case. Issue #23435.\n             if mth.is_provided {\n                 let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n-                if !normalize_and_test_predicates(tcx, predicates.into_vec()) {\n+                if !normalize_and_test_predicates(tcx, predicates) {\n                     debug!(\"get_vtable_methods: predicates do not hold\");\n                     return None;\n                 }\n@@ -309,8 +306,9 @@ pub struct ImplMethod<'tcx> {\n \n /// Locates the applicable definition of a method, given its name.\n pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 impl_def_id: DefId,\n                                  substs: &'tcx Substs<'tcx>,\n+                                 impl_def_id: DefId,\n+                                 impl_substs: &'tcx Substs<'tcx>,\n                                  name: Name)\n                                  -> ImplMethod<'tcx>\n {\n@@ -322,6 +320,7 @@ pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n         Some(node_item) => {\n             let substs = tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n+                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n                 let substs = traits::translate_substs(&infcx, impl_def_id,\n                                                       substs, node_item.node);\n                 tcx.lift(&substs).unwrap_or_else(|| {"}, {"sha": "4da973bb7f946ec2d5754d27b9aba4c7389857bd", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -232,12 +232,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                  args: IndexVec<mir::Arg, Const<'tcx>>)\n                  -> Result<Const<'tcx>, ConstEvalFailure> {\n         // Try to resolve associated constants.\n-        if instance.substs.self_ty().is_some() {\n-            // Only trait items can have a Self parameter.\n-            let trait_item = ccx.tcx().impl_or_trait_item(instance.def);\n-            let trait_id = trait_item.container().id();\n-            let substs = instance.substs;\n-            let trait_ref = ty::Binder(substs.to_trait_ref(ccx.tcx(), trait_id));\n+        if let Some(trait_id) = ccx.tcx().trait_of_item(instance.def) {\n+            let trait_ref = ty::TraitRef::new(trait_id, instance.substs);\n+            let trait_ref = ty::Binder(trait_ref);\n             let vtable = common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref);\n             if let traits::VtableImpl(vtable_impl) = vtable {\n                 let name = ccx.tcx().item_name(instance.def);"}, {"sha": "d1837883aaeb032cbb91328b4013d0f344c3cb92", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -12,7 +12,6 @@ use llvm::ValueRef;\n use llvm;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n-use rustc::ty::subst;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n use attributes;\n@@ -33,7 +32,7 @@ use trans_item::TransItem;\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: DefId,\n-                                psubsts: &'tcx subst::Substs<'tcx>)\n+                                psubsts: &'tcx Substs<'tcx>)\n                                 -> (ValueRef, Ty<'tcx>) {\n     debug!(\"monomorphic_fn(fn_id={:?}, real_substs={:?})\", fn_id, psubsts);\n     assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n@@ -174,7 +173,7 @@ pub struct Instance<'tcx> {\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ppaux::parameterized(f, &self.substs, self.def, ppaux::Ns::Value, &[], |_| None)\n+        ppaux::parameterized(f, &self.substs, self.def, ppaux::Ns::Value, &[])\n     }\n }\n "}, {"sha": "87d0ea0fe81f30d83b20ac75099a7c0ca098d1d9", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -486,7 +486,8 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // its self-type. If the self-type does not provide a characteristic\n             // DefId, we use the location of the impl after all.\n \n-            if let Some(self_ty) = instance.substs.self_ty() {\n+            if tcx.trait_of_item(instance.def).is_some() {\n+                let self_ty = instance.substs.types[0];\n                 // This is an implementation of a trait method.\n                 return characteristic_def_id_of_type(self_ty).or(Some(instance.def));\n             }"}, {"sha": "580882e31dd603248fba65ca64b4c96eb6dbefc4", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -28,7 +28,7 @@ use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::subst;\n+use rustc::ty::subst::Substs;\n use rustc_const_eval::fatal_const_eval_err;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n@@ -352,8 +352,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             },\n             TransItem::Static(node_id) => {\n                 let def_id = hir_map.local_def_id(node_id);\n-                let instance = Instance::new(def_id,\n-                                             tcx.mk_substs(subst::Substs::empty()));\n+                let instance = Instance::new(def_id, Substs::empty(tcx));\n                 to_string_internal(tcx, \"static \", instance)\n             },\n         };\n@@ -476,10 +475,10 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             output.push(']');\n         },\n         ty::TyTrait(ref trait_data) => {\n-            push_item_name(tcx, trait_data.principal.skip_binder().def_id, output);\n+            push_item_name(tcx, trait_data.principal.def_id(), output);\n             push_type_params(tcx,\n                              &trait_data.principal.skip_binder().substs.types,\n-                             &trait_data.bounds.projection_bounds,\n+                             &trait_data.projection_bounds,\n                              output);\n         },\n         ty::TyFnDef(_, _, &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n@@ -561,8 +560,8 @@ fn push_item_name(tcx: TyCtxt,\n }\n \n fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n-                              projections: &[ty::PolyProjectionPredicate<'tcx>],\n+                              types: &[Ty<'tcx>],\n+                              projections: &[ty::PolyExistentialProjection<'tcx>],\n                               output: &mut String) {\n     if types.is_empty() && projections.is_empty() {\n         return;\n@@ -577,7 +576,7 @@ fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     for projection in projections {\n         let projection = projection.skip_binder();\n-        let name = &projection.projection_ty.item_name.as_str();\n+        let name = &projection.item_name.as_str();\n         output.push_str(name);\n         output.push_str(\"=\");\n         push_unique_type_name(tcx, projection.ty, output);"}, {"sha": "6862002ed83b25a448e2319656cb7610d506b6be", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -11,7 +11,6 @@\n #![allow(non_camel_case_types)]\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst;\n use abi::FnType;\n use adt;\n use common::*;\n@@ -257,18 +256,13 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           // avoids creating more than one copy of the enum when one\n           // of the enum's variants refers to the enum itself.\n           let repr = adt::represent_type(cx, t);\n-          let tps = substs.types.get_slice(subst::TypeSpace);\n-          let name = llvm_type_name(cx, def.did, tps);\n+          let name = llvm_type_name(cx, def.did, &substs.types);\n           adt::incomplete_type_of(cx, &repr, &name[..])\n       }\n       ty::TyClosure(..) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache.\n           let repr = adt::represent_type(cx, t);\n-          // Unboxed closures can have substitutions in all spaces\n-          // inherited from their environment, so we use entire\n-          // contents of the VecPerParamSpace to construct the llvm\n-          // name\n           adt::incomplete_type_of(cx, &repr, \"closure\")\n       }\n \n@@ -336,8 +330,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n               // in *after* placing it into the type cache. This prevents\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n-              let tps = substs.types.get_slice(subst::TypeSpace);\n-              let name = llvm_type_name(cx, def.did, tps);\n+              let name = llvm_type_name(cx, def.did, &substs.types);\n               adt::incomplete_type_of(cx, &repr, &name[..])\n           }\n       }"}, {"sha": "f6984f42cab341301d52864b2b6e691d1e5217ac", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 390, "deletions": 515, "changes": 905, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -55,8 +55,7 @@ use hir::def_id::DefId;\n use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n use rustc::lint;\n-use rustc::ty::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n-use rustc::ty::subst::VecPerParamSpace;\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n@@ -82,6 +81,10 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// A cache used for the result of `ast_ty_to_ty_cache`\n     fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>>;\n \n+    /// Returns the generic type and lifetime parameters for an item.\n+    fn get_generics(&self, span: Span, id: DefId)\n+                    -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>;\n+\n     /// Identify the type scheme for an item with a type, like a type\n     /// alias, fn, or struct. This allows you to figure out the set of\n     /// type parameters defined on the item.\n@@ -116,11 +119,15 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn get_free_substs(&self) -> Option<&Substs<'tcx>>;\n \n     /// What type should we use when a type is omitted?\n-    fn ty_infer(&self,\n-                param_and_substs: Option<ty::TypeParameterDef<'tcx>>,\n-                substs: Option<&mut Substs<'tcx>>,\n-                space: Option<ParamSpace>,\n-                span: Span) -> Ty<'tcx>;\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n+\n+    /// Same as ty_infer, but with a known type parameter definition.\n+    fn ty_infer_for_def(&self,\n+                        _def: &ty::TypeParameterDef<'tcx>,\n+                        _substs: &Substs<'tcx>,\n+                        span: Span) -> Ty<'tcx> {\n+        self.ty_infer(span)\n+    }\n \n     /// Projecting an associated type from a (potentially)\n     /// higher-ranked trait reference is more complicated, because of\n@@ -166,6 +173,11 @@ struct ConvertedBinding<'tcx> {\n \n type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n \n+/// Dummy type used for the `Self` of a `TraitRef` created for converting\n+/// a trait object, and which gets removed in `ExistentialTraitRef`.\n+/// This type must not appear anywhere in other converted types.\n+const TRAIT_OBJECT_DUMMY_SELF: ty::TypeVariants<'static> = ty::TyInfer(ty::FreshTy(0));\n+\n pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n                             -> ty::Region {\n     let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n@@ -195,9 +207,8 @@ pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n                                                   issue_32330))\n         }\n \n-        Some(&rl::DefEarlyBoundRegion(space, index, _)) => {\n+        Some(&rl::DefEarlyBoundRegion(index, _)) => {\n             ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                space: space,\n                 index: index,\n                 name: lifetime.name\n             })\n@@ -340,66 +351,87 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         rscope: &RegionScope,\n         span: Span,\n         param_mode: PathParamMode,\n-        decl_generics: &ty::Generics<'tcx>,\n+        def_id: DefId,\n         item_segment: &hir::PathSegment)\n-        -> Substs<'tcx>\n+        -> &'tcx Substs<'tcx>\n     {\n         let tcx = self.tcx();\n \n-        // ast_path_substs() is only called to convert paths that are\n-        // known to refer to traits, types, or structs. In these cases,\n-        // all type parameters defined for the item being referenced will\n-        // be in the TypeSpace or SelfSpace.\n-        //\n-        // Note: in the case of traits, the self parameter is also\n-        // defined, but we don't currently create a `type_param_def` for\n-        // `Self` because it is implicit.\n-        assert!(decl_generics.regions.all(|d| d.space == TypeSpace));\n-        assert!(decl_generics.types.all(|d| d.space != FnSpace));\n-\n-        let (regions, types, assoc_bindings) = match item_segment.parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n-                self.convert_angle_bracketed_parameters(rscope, span, decl_generics, data)\n-            }\n+        match item_segment.parameters {\n+            hir::AngleBracketedParameters(_) => {}\n             hir::ParenthesizedParameters(..) => {\n                 struct_span_err!(tcx.sess, span, E0214,\n                           \"parenthesized parameters may only be used with a trait\")\n                     .span_label(span, &format!(\"only traits may use parentheses\"))\n                     .emit();\n \n-                let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n-                (Substs::empty(),\n-                 ty_param_defs.iter().map(|_| tcx.types.err).collect(),\n-                 vec![])\n+                return Substs::for_item(tcx, def_id, |_, _| {\n+                    ty::ReStatic\n+                }, |_, _| {\n+                    tcx.types.err\n+                });\n             }\n-        };\n+        }\n+\n+        let (substs, assoc_bindings) =\n+            self.create_substs_for_ast_path(rscope,\n+                                            span,\n+                                            param_mode,\n+                                            def_id,\n+                                            &item_segment.parameters,\n+                                            None);\n \n         assoc_bindings.first().map(|b| self.tcx().prohibit_projection(b.span));\n \n-        self.create_substs_for_ast_path(span,\n-                                        param_mode,\n-                                        decl_generics,\n-                                        None,\n-                                        types,\n-                                        regions)\n+        substs\n     }\n \n-    fn create_region_substs(&self,\n+    /// Given the type/region arguments provided to some path (along with\n+    /// an implicit Self, if this is a trait reference) returns the complete\n+    /// set of substitutions. This may involve applying defaulted type parameters.\n+    ///\n+    /// Note that the type listing given here is *exactly* what the user provided.\n+    fn create_substs_for_ast_path(&self,\n         rscope: &RegionScope,\n         span: Span,\n-        decl_generics: &ty::Generics<'tcx>,\n-        regions_provided: Vec<ty::Region>)\n-        -> Substs<'tcx>\n+        param_mode: PathParamMode,\n+        def_id: DefId,\n+        parameters: &hir::PathParameters,\n+        self_ty: Option<Ty<'tcx>>)\n+        -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n     {\n         let tcx = self.tcx();\n \n+        debug!(\"create_substs_for_ast_path(def_id={:?}, self_ty={:?}, \\\n+               parameters={:?})\",\n+               def_id, self_ty, parameters);\n+\n+        let (lifetimes, num_types_provided) = match *parameters {\n+            hir::AngleBracketedParameters(ref data) => {\n+                if param_mode == PathParamMode::Optional && data.types.is_empty() {\n+                    (&data.lifetimes[..], None)\n+                } else {\n+                    (&data.lifetimes[..], Some(data.types.len()))\n+                }\n+            }\n+            hir::ParenthesizedParameters(_) => (&[][..], Some(1))\n+        };\n+\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n-        let expected_num_region_params = decl_generics.regions.len(TypeSpace);\n-        let supplied_num_region_params = regions_provided.len();\n+        let decl_generics = match self.get_generics(span, def_id) {\n+            Ok(generics) => generics,\n+            Err(ErrorReported) => {\n+                // No convenient way to recover from a cycle here. Just bail. Sorry!\n+                self.tcx().sess.abort_if_errors();\n+                bug!(\"ErrorReported returned, but no errors reports?\")\n+            }\n+        };\n+        let expected_num_region_params = decl_generics.regions.len();\n+        let supplied_num_region_params = lifetimes.len();\n         let regions = if expected_num_region_params == supplied_num_region_params {\n-            regions_provided\n+            lifetimes.iter().map(|l| ast_region_to_region(tcx, l)).collect()\n         } else {\n             let anon_regions =\n                 rscope.anon_regions(span, expected_num_region_params);\n@@ -415,184 +447,112 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 Err(_) => (0..expected_num_region_params).map(|_| ty::ReStatic).collect()\n             }\n         };\n-        Substs::new_type(vec![], regions)\n-    }\n \n-    /// Given the type/region arguments provided to some path (along with\n-    /// an implicit Self, if this is a trait reference) returns the complete\n-    /// set of substitutions. This may involve applying defaulted type parameters.\n-    ///\n-    /// Note that the type listing given here is *exactly* what the user provided.\n-    ///\n-    /// The `region_substs` should be the result of `create_region_substs`\n-    /// -- that is, a substitution with no types but the correct number of\n-    /// regions.\n-    fn create_substs_for_ast_path(&self,\n-        span: Span,\n-        param_mode: PathParamMode,\n-        decl_generics: &ty::Generics<'tcx>,\n-        self_ty: Option<Ty<'tcx>>,\n-        types_provided: Vec<Ty<'tcx>>,\n-        region_substs: Substs<'tcx>)\n-        -> Substs<'tcx>\n-    {\n-        let tcx = self.tcx();\n+        // If a self-type was declared, one should be provided.\n+        assert_eq!(decl_generics.has_self, self_ty.is_some());\n \n-        debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}, \\\n-               types_provided={:?}, region_substs={:?})\",\n-               decl_generics, self_ty, types_provided,\n-               region_substs);\n-\n-        assert_eq!(region_substs.regions.len(TypeSpace), decl_generics.regions.len(TypeSpace));\n-        assert!(region_substs.types.is_empty());\n-\n-        // Convert the type parameters supplied by the user.\n-        let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n-        let formal_ty_param_count = ty_param_defs.len();\n-        let required_ty_param_count = ty_param_defs.iter()\n-                                                   .take_while(|x| x.default.is_none())\n-                                                   .count();\n-\n-        let mut type_substs = self.get_type_substs_for_defs(span,\n-                                                            types_provided,\n-                                                            param_mode,\n-                                                            ty_param_defs,\n-                                                            region_substs.clone(),\n-                                                            self_ty);\n-\n-        let supplied_ty_param_count = type_substs.len();\n-        check_type_argument_count(self.tcx(), span, supplied_ty_param_count,\n-                                  required_ty_param_count, formal_ty_param_count);\n-\n-        if supplied_ty_param_count < required_ty_param_count {\n-            while type_substs.len() < required_ty_param_count {\n-                type_substs.push(tcx.types.err);\n-            }\n-        } else if supplied_ty_param_count > formal_ty_param_count {\n-            type_substs.truncate(formal_ty_param_count);\n+        // Check the number of type parameters supplied by the user.\n+        if let Some(num_provided) = num_types_provided {\n+            let ty_param_defs = &decl_generics.types[self_ty.is_some() as usize..];\n+            check_type_argument_count(tcx, span, num_provided, ty_param_defs);\n         }\n-        assert!(type_substs.len() >= required_ty_param_count &&\n-                type_substs.len() <= formal_ty_param_count);\n-\n-        let mut substs = region_substs;\n-        substs.types.extend(TypeSpace, type_substs.into_iter());\n \n-        match self_ty {\n-            None => {\n-                // If no self-type is provided, it's still possible that\n-                // one was declared, because this could be an object type.\n+        let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n+        let default_needs_object_self = |p: &ty::TypeParameterDef<'tcx>| {\n+            if let Some(ref default) = p.default {\n+                if is_object && default.has_self_ty() {\n+                    // There is no suitable inference default for a type parameter\n+                    // that references self, in an object type.\n+                    return true;\n+                }\n             }\n-            Some(ty) => {\n-                // If a self-type is provided, one should have been\n-                // \"declared\" (in other words, this should be a\n-                // trait-ref).\n-                assert!(decl_generics.types.get_self().is_some());\n-                substs.types.push(SelfSpace, ty);\n+\n+            false\n+        };\n+\n+        let mut output_assoc_binding = None;\n+        let substs = Substs::for_item(tcx, def_id, |def, _| {\n+            regions[def.index as usize]\n+        }, |def, substs| {\n+            let i = def.index as usize;\n+\n+            // Handle Self first, so we can adjust the index to match the AST.\n+            if let (0, Some(ty)) = (i, self_ty) {\n+                return ty;\n             }\n-        }\n \n-        let actual_supplied_ty_param_count = substs.types.len(TypeSpace);\n-        for param in &ty_param_defs[actual_supplied_ty_param_count..] {\n-            if let Some(default) = param.default {\n+            let i = i - self_ty.is_some() as usize;\n+            if num_types_provided.map_or(false, |n| i < n) {\n+                // A provided type parameter.\n+                match *parameters {\n+                    hir::AngleBracketedParameters(ref data) => {\n+                        self.ast_ty_arg_to_ty(rscope, Some(def), substs, &data.types[i])\n+                    }\n+                    hir::ParenthesizedParameters(ref data) => {\n+                        assert_eq!(i, 0);\n+                        let (ty, assoc) =\n+                            self.convert_parenthesized_parameters(rscope, substs, data);\n+                        output_assoc_binding = Some(assoc);\n+                        ty\n+                    }\n+                }\n+            } else if num_types_provided.is_none() {\n+                // No type parameters were provided, we can infer all.\n+                let ty_var = if !default_needs_object_self(def) {\n+                    self.ty_infer_for_def(def, substs, span)\n+                } else {\n+                    self.ty_infer(span)\n+                };\n+                ty_var\n+            } else if let Some(default) = def.default {\n+                // No type parameter provided, but a default exists.\n+\n                 // If we are converting an object type, then the\n                 // `Self` parameter is unknown. However, some of the\n                 // other type parameters may reference `Self` in their\n                 // defaults. This will lead to an ICE if we are not\n                 // careful!\n-                if self_ty.is_none() && default.has_self_ty() {\n+                if default_needs_object_self(def) {\n                     span_err!(tcx.sess, span, E0393,\n                               \"the type parameter `{}` must be explicitly specified \\\n                                in an object type because its default value `{}` references \\\n                                the type `Self`\",\n-                              param.name,\n+                              def.name,\n                               default);\n-                    substs.types.push(TypeSpace, tcx.types.err);\n+                    tcx.types.err\n                 } else {\n                     // This is a default type parameter.\n-                    let default = default.subst_spanned(tcx,\n-                                                        &substs,\n-                                                        Some(span));\n-                    substs.types.push(TypeSpace, default);\n+                    default.subst_spanned(tcx, substs, Some(span))\n                 }\n             } else {\n-                span_bug!(span, \"extra parameter without default\");\n+                // We've already errored above about the mismatch.\n+                tcx.types.err\n             }\n-        }\n-\n-        debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}) -> {:?}\",\n-               decl_generics, self_ty, substs);\n+        });\n \n-        substs\n-    }\n-\n-    /// Returns types_provided if it is not empty, otherwise populating the\n-    /// type parameters with inference variables as appropriate.\n-    fn get_type_substs_for_defs(&self,\n-                                span: Span,\n-                                types_provided: Vec<Ty<'tcx>>,\n-                                param_mode: PathParamMode,\n-                                ty_param_defs: &[ty::TypeParameterDef<'tcx>],\n-                                mut substs: Substs<'tcx>,\n-                                self_ty: Option<Ty<'tcx>>)\n-                                -> Vec<Ty<'tcx>>\n-    {\n-        fn default_type_parameter<'tcx>(p: &ty::TypeParameterDef<'tcx>, self_ty: Option<Ty<'tcx>>)\n-                                        -> Option<ty::TypeParameterDef<'tcx>>\n-        {\n-            if let Some(ref default) = p.default {\n-                if self_ty.is_none() && default.has_self_ty() {\n-                    // There is no suitable inference default for a type parameter\n-                    // that references self with no self-type provided.\n-                    return None;\n-                }\n+        let assoc_bindings = match *parameters {\n+            hir::AngleBracketedParameters(ref data) => {\n+                data.bindings.iter().map(|b| {\n+                    ConvertedBinding {\n+                        item_name: b.name,\n+                        ty: self.ast_ty_to_ty(rscope, &b.ty),\n+                        span: b.span\n+                    }\n+                }).collect()\n             }\n+            hir::ParenthesizedParameters(ref data) => {\n+                vec![output_assoc_binding.unwrap_or_else(|| {\n+                    // This is an error condition, but we should\n+                    // get the associated type binding anyway.\n+                    self.convert_parenthesized_parameters(rscope, substs, data).1\n+                })]\n+            }\n+        };\n \n-            Some(p.clone())\n-        }\n-\n-        if param_mode == PathParamMode::Optional && types_provided.is_empty() {\n-            ty_param_defs\n-                .iter()\n-                .map(|p| self.ty_infer(default_type_parameter(p, self_ty), Some(&mut substs),\n-                                       Some(TypeSpace), span))\n-                .collect()\n-        } else {\n-            types_provided\n-        }\n-    }\n+        debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}) -> {:?}\",\n+               decl_generics, self_ty, substs);\n \n-    fn convert_angle_bracketed_parameters(&self,\n-                                          rscope: &RegionScope,\n-                                          span: Span,\n-                                          decl_generics: &ty::Generics<'tcx>,\n-                                          data: &hir::AngleBracketedParameterData)\n-                                          -> (Substs<'tcx>,\n-                                              Vec<Ty<'tcx>>,\n-                                              Vec<ConvertedBinding<'tcx>>)\n-    {\n-        let regions: Vec<_> =\n-            data.lifetimes.iter()\n-                          .map(|l| ast_region_to_region(self.tcx(), l))\n-                          .collect();\n-\n-        let region_substs =\n-            self.create_region_substs(rscope, span, decl_generics, regions);\n-\n-        let types: Vec<_> =\n-            data.types.iter()\n-                      .enumerate()\n-                      .map(|(i,t)| self.ast_ty_arg_to_ty(rscope, decl_generics,\n-                                                         i, &region_substs, t))\n-                      .collect();\n-\n-        let assoc_bindings: Vec<_> =\n-            data.bindings.iter()\n-                         .map(|b| ConvertedBinding { item_name: b.name,\n-                                                     ty: self.ast_ty_to_ty(rscope, &b.ty),\n-                                                     span: b.span })\n-                         .collect();\n-\n-        (region_substs, types, assoc_bindings)\n+        (substs, assoc_bindings)\n     }\n \n     /// Returns the appropriate lifetime to use for any output lifetimes\n@@ -657,29 +617,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     fn convert_parenthesized_parameters(&self,\n                                         rscope: &RegionScope,\n-                                        span: Span,\n-                                        decl_generics: &ty::Generics<'tcx>,\n+                                        region_substs: &Substs<'tcx>,\n                                         data: &hir::ParenthesizedParameterData)\n-                                        -> (Substs<'tcx>,\n-                                            Vec<Ty<'tcx>>,\n-                                            Vec<ConvertedBinding<'tcx>>)\n+                                        -> (Ty<'tcx>, ConvertedBinding<'tcx>)\n     {\n-        let region_substs =\n-            self.create_region_substs(rscope, span, decl_generics, Vec::new());\n-\n         let anon_scope = rscope.anon_type_scope();\n         let binding_rscope = MaybeWithAnonTypes::new(BindingRscope::new(), anon_scope);\n-        let inputs =\n-            data.inputs.iter()\n-                       .map(|a_t| self.ast_ty_arg_to_ty(&binding_rscope, decl_generics,\n-                                                        0, &region_substs, a_t))\n-                       .collect::<Vec<Ty<'tcx>>>();\n-\n+        let inputs: Vec<_> = data.inputs.iter().map(|a_t| {\n+            self.ast_ty_arg_to_ty(&binding_rscope, None, region_substs, a_t)\n+        }).collect();\n         let input_params = vec![String::new(); inputs.len()];\n         let implied_output_region = self.find_implied_output_region(&inputs, input_params);\n \n-        let input_ty = self.tcx().mk_tup(inputs);\n-\n         let (output, output_span) = match data.output {\n             Some(ref output_ty) => {\n                 (self.convert_ty_with_lifetime_elision(implied_output_region,\n@@ -698,13 +647,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             span: output_span\n         };\n \n-        (region_substs, vec![input_ty], vec![output_binding])\n+        (self.tcx().mk_tup(inputs), output_binding)\n     }\n \n     pub fn instantiate_poly_trait_ref(&self,\n         rscope: &RegionScope,\n         ast_trait_ref: &hir::PolyTraitRef,\n-        self_ty: Option<Ty<'tcx>>,\n+        self_ty: Ty<'tcx>,\n         poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n         -> ty::PolyTraitRef<'tcx>\n     {\n@@ -729,7 +678,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn instantiate_mono_trait_ref(&self,\n         rscope: &RegionScope,\n         trait_ref: &hir::TraitRef,\n-        self_ty: Option<Ty<'tcx>>)\n+        self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>\n     {\n         let trait_def_id = self.trait_def_id(trait_ref);\n@@ -755,32 +704,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    fn object_path_to_poly_trait_ref(&self,\n-        rscope: &RegionScope,\n-        span: Span,\n-        param_mode: PathParamMode,\n-        trait_def_id: DefId,\n-        trait_path_ref_id: ast::NodeId,\n-        trait_segment: &hir::PathSegment,\n-        mut projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n-        -> ty::PolyTraitRef<'tcx>\n-    {\n-        self.ast_path_to_poly_trait_ref(rscope,\n-                                        span,\n-                                        param_mode,\n-                                        trait_def_id,\n-                                        None,\n-                                        trait_path_ref_id,\n-                                        trait_segment,\n-                                        projections)\n-    }\n-\n     fn ast_path_to_poly_trait_ref(&self,\n         rscope: &RegionScope,\n         span: Span,\n         param_mode: PathParamMode,\n         trait_def_id: DefId,\n-        self_ty: Option<Ty<'tcx>>,\n+        self_ty: Ty<'tcx>,\n         path_id: ast::NodeId,\n         trait_segment: &hir::PathSegment,\n         poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n@@ -803,21 +732,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                  trait_segment);\n         let poly_trait_ref = ty::Binder(ty::TraitRef::new(trait_def_id, substs));\n \n-        {\n-            let converted_bindings =\n-                assoc_bindings\n-                .iter()\n-                .filter_map(|binding| {\n-                    // specify type to assert that error was already reported in Err case:\n-                    let predicate: Result<_, ErrorReported> =\n-                        self.ast_type_binding_to_poly_projection_predicate(path_id,\n-                                                                           poly_trait_ref.clone(),\n-                                                                           self_ty,\n-                                                                           binding);\n-                    predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n-                });\n-            poly_projections.extend(converted_bindings);\n-        }\n+        poly_projections.extend(assoc_bindings.iter().filter_map(|binding| {\n+            // specify type to assert that error was already reported in Err case:\n+            let predicate: Result<_, ErrorReported> =\n+                self.ast_type_binding_to_poly_projection_predicate(path_id,\n+                                                                   poly_trait_ref,\n+                                                                   binding);\n+            predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n+        }));\n \n         debug!(\"ast_path_to_poly_trait_ref(trait_segment={:?}, projections={:?}) -> {:?}\",\n                trait_segment, poly_projections, poly_trait_ref);\n@@ -829,7 +751,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                   span: Span,\n                                   param_mode: PathParamMode,\n                                   trait_def_id: DefId,\n-                                  self_ty: Option<Ty<'tcx>>,\n+                                  self_ty: Ty<'tcx>,\n                                   trait_segment: &hir::PathSegment)\n                                   -> ty::TraitRef<'tcx>\n     {\n@@ -849,7 +771,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                        span: Span,\n                                        param_mode: PathParamMode,\n                                        trait_def_id: DefId,\n-                                       self_ty: Option<Ty<'tcx>>,\n+                                       self_ty: Ty<'tcx>,\n                                        trait_segment: &hir::PathSegment)\n                                        -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n     {\n@@ -865,8 +787,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         };\n \n-        let (regions, types, assoc_bindings) = match trait_segment.parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n+        match trait_segment.parameters {\n+            hir::AngleBracketedParameters(_) => {\n                 // For now, require that parenthetical notation be used\n                 // only with `Fn()` etc.\n                 if !self.tcx().sess.features.borrow().unboxed_closures && trait_def.paren_sugar {\n@@ -877,10 +799,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         type parameters is subject to change. \\\n                         Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\");\n                 }\n-\n-                self.convert_angle_bracketed_parameters(rscope, span, &trait_def.generics, data)\n             }\n-            hir::ParenthesizedParameters(ref data) => {\n+            hir::ParenthesizedParameters(_) => {\n                 // For now, require that parenthetical notation be used\n                 // only with `Fn()` etc.\n                 if !self.tcx().sess.features.borrow().unboxed_closures && !trait_def.paren_sugar {\n@@ -889,26 +809,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                      \"\\\n                         parenthetical notation is only stable when used with `Fn`-family traits\");\n                 }\n-\n-                self.convert_parenthesized_parameters(rscope, span, &trait_def.generics, data)\n             }\n-        };\n-\n-        let substs = self.create_substs_for_ast_path(span,\n-                                                     param_mode,\n-                                                     &trait_def.generics,\n-                                                     self_ty,\n-                                                     types,\n-                                                     regions);\n+        }\n \n-        (self.tcx().mk_substs(substs), assoc_bindings)\n+        self.create_substs_for_ast_path(rscope,\n+                                        span,\n+                                        param_mode,\n+                                        trait_def_id,\n+                                        &trait_segment.parameters,\n+                                        Some(self_ty))\n     }\n \n     fn ast_type_binding_to_poly_projection_predicate(\n         &self,\n         path_id: ast::NodeId,\n-        mut trait_ref: ty::PolyTraitRef<'tcx>,\n-        self_ty: Option<Ty<'tcx>>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         binding: &ConvertedBinding<'tcx>)\n         -> Result<ty::PolyProjectionPredicate<'tcx>, ErrorReported>\n     {\n@@ -962,62 +877,39 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Simple case: X is defined in the current trait.\n         if self.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n-            return Ok(ty::Binder(ty::ProjectionPredicate {      // <-------------------+\n-                projection_ty: ty::ProjectionTy {               //                     |\n-                    trait_ref: trait_ref.skip_binder().clone(), // Binder moved here --+\n-                    item_name: binding.item_name,\n-                },\n-                ty: binding.ty,\n+            return Ok(trait_ref.map_bound(|trait_ref| {\n+                ty::ProjectionPredicate {\n+                    projection_ty: ty::ProjectionTy {\n+                        trait_ref: trait_ref,\n+                        item_name: binding.item_name,\n+                    },\n+                    ty: binding.ty,\n+                }\n             }));\n         }\n \n         // Otherwise, we have to walk through the supertraits to find\n-        // those that do.  This is complicated by the fact that, for an\n-        // object type, the `Self` type is not present in the\n-        // substitutions (after all, it's being constructed right now),\n-        // but the `supertraits` iterator really wants one. To handle\n-        // this, we currently insert a dummy type and then remove it\n-        // later. Yuck.\n-\n-        let dummy_self_ty = tcx.mk_infer(ty::FreshTy(0));\n-        if self_ty.is_none() { // if converting for an object type\n-            let mut dummy_substs = trait_ref.skip_binder().substs.clone(); // binder moved here -+\n-            assert!(dummy_substs.self_ty().is_none());                     //                    |\n-            dummy_substs.types.push(SelfSpace, dummy_self_ty);             //                    |\n-            trait_ref = ty::Binder(ty::TraitRef::new(trait_ref.def_id(),   // <------------+\n-                                                     tcx.mk_substs(dummy_substs)));\n-        }\n-\n+        // those that do.\n         self.ensure_super_predicates(binding.span, trait_ref.def_id())?;\n \n-        let mut candidates: Vec<ty::PolyTraitRef> =\n+        let candidates: Vec<ty::PolyTraitRef> =\n             traits::supertraits(tcx, trait_ref.clone())\n             .filter(|r| self.trait_defines_associated_type_named(r.def_id(), binding.item_name))\n             .collect();\n \n-        // If converting for an object type, then remove the dummy-ty from `Self` now.\n-        // Yuckety yuck.\n-        if self_ty.is_none() {\n-            for candidate in &mut candidates {\n-                let mut dummy_substs = candidate.0.substs.clone();\n-                assert!(dummy_substs.self_ty() == Some(dummy_self_ty));\n-                dummy_substs.types.pop(SelfSpace);\n-                *candidate = ty::Binder(ty::TraitRef::new(candidate.def_id(),\n-                                                          tcx.mk_substs(dummy_substs)));\n-            }\n-        }\n-\n         let candidate = self.one_bound_for_assoc_type(candidates,\n                                                       &trait_ref.to_string(),\n                                                       &binding.item_name.as_str(),\n                                                       binding.span)?;\n \n-        Ok(ty::Binder(ty::ProjectionPredicate {             // <-------------------------+\n-            projection_ty: ty::ProjectionTy {               //                           |\n-                trait_ref: candidate.skip_binder().clone(), // binder is moved up here --+\n-                item_name: binding.item_name,\n-            },\n-            ty: binding.ty,\n+        Ok(candidate.map_bound(|trait_ref| {\n+            ty::ProjectionPredicate {\n+                projection_ty: ty::ProjectionTy {\n+                    trait_ref: trait_ref,\n+                    item_name: binding.item_name,\n+                },\n+                ty: binding.ty,\n+            }\n         }))\n     }\n \n@@ -1030,10 +922,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         -> Ty<'tcx>\n     {\n         let tcx = self.tcx();\n-        let (generics, decl_ty) = match self.get_item_type_scheme(span, did) {\n-            Ok(ty::TypeScheme { generics,  ty: decl_ty }) => {\n-                (generics, decl_ty)\n-            }\n+        let decl_ty = match self.get_item_type_scheme(span, did) {\n+            Ok(type_scheme) => type_scheme.ty,\n             Err(ErrorReported) => {\n                 return tcx.types.err;\n             }\n@@ -1042,23 +932,24 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let substs = self.ast_path_substs_for_ty(rscope,\n                                                  span,\n                                                  param_mode,\n-                                                 &generics,\n+                                                 did,\n                                                  item_segment);\n \n         // FIXME(#12938): This is a hack until we have full support for DST.\n         if Some(did) == self.tcx().lang_items.owned_box() {\n-            assert_eq!(substs.types.len(TypeSpace), 1);\n-            return self.tcx().mk_box(*substs.types.get(TypeSpace, 0));\n+            assert_eq!(substs.types.len(), 1);\n+            return self.tcx().mk_box(substs.types[0]);\n         }\n \n-        decl_ty.subst(self.tcx(), &substs)\n+        decl_ty.subst(self.tcx(), substs)\n     }\n \n-    fn ast_ty_to_trait_ref(&self,\n-                           rscope: &RegionScope,\n-                           ty: &hir::Ty,\n-                           bounds: &[hir::TyParamBound])\n-                           -> Result<TraitAndProjections<'tcx>, ErrorReported>\n+    fn ast_ty_to_object_trait_ref(&self,\n+                                  rscope: &RegionScope,\n+                                  span: Span,\n+                                  ty: &hir::Ty,\n+                                  bounds: &[hir::TyParamBound])\n+                                  -> Ty<'tcx>\n     {\n         /*!\n          * In a type like `Foo + Send`, we want to wait to collect the\n@@ -1071,33 +962,32 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n          * name, and reports an error otherwise.\n          */\n \n+        let tcx = self.tcx();\n         match ty.node {\n             hir::TyPath(None, ref path) => {\n-                let resolution = self.tcx().expect_resolution(ty.id);\n+                let resolution = tcx.expect_resolution(ty.id);\n                 match resolution.base_def {\n                     Def::Trait(trait_def_id) if resolution.depth == 0 => {\n-                        let mut projection_bounds = Vec::new();\n-                        let trait_ref =\n-                            self.object_path_to_poly_trait_ref(rscope,\n-                                                               path.span,\n-                                                               PathParamMode::Explicit,\n-                                                               trait_def_id,\n-                                                               ty.id,\n-                                                               path.segments.last().unwrap(),\n-                                                               &mut projection_bounds);\n-                        Ok((trait_ref, projection_bounds))\n+                        self.trait_path_to_object_type(rscope,\n+                                                       path.span,\n+                                                       PathParamMode::Explicit,\n+                                                       trait_def_id,\n+                                                       ty.id,\n+                                                       path.segments.last().unwrap(),\n+                                                       span,\n+                                                       partition_bounds(tcx, span, bounds))\n                     }\n                     _ => {\n-                        struct_span_err!(self.tcx().sess, ty.span, E0172,\n+                        struct_span_err!(tcx.sess, ty.span, E0172,\n                                   \"expected a reference to a trait\")\n                             .span_label(ty.span, &format!(\"expected a trait\"))\n                             .emit();\n-                        Err(ErrorReported)\n+                        tcx.types.err\n                     }\n                 }\n             }\n             _ => {\n-                let mut err = struct_span_err!(self.tcx().sess, ty.span, E0178,\n+                let mut err = struct_span_err!(tcx.sess, ty.span, E0178,\n                                                \"expected a path on the left-hand side \\\n                                                 of `+`, not `{}`\",\n                                                pprust::ty_to_string(ty));\n@@ -1136,44 +1026,93 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     }\n                 }\n                 err.emit();\n-                Err(ErrorReported)\n+                tcx.types.err\n             }\n         }\n     }\n \n-    fn trait_ref_to_object_type(&self,\n-                                rscope: &RegionScope,\n-                                span: Span,\n-                                trait_ref: ty::PolyTraitRef<'tcx>,\n-                                projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n-                                bounds: &[hir::TyParamBound])\n-                                -> Ty<'tcx>\n-    {\n-        let existential_bounds = self.conv_existential_bounds(rscope,\n-                                                              span,\n-                                                              trait_ref.clone(),\n-                                                              projection_bounds,\n-                                                              bounds);\n-\n-        let result = self.make_object_type(span, trait_ref, existential_bounds);\n-        debug!(\"trait_ref_to_object_type: result={:?}\",\n-               result);\n-\n-        result\n+    /// Transform a PolyTraitRef into a PolyExistentialTraitRef by\n+    /// removing the dummy Self type (TRAIT_OBJECT_DUMMY_SELF).\n+    fn trait_ref_to_existential(&self, trait_ref: ty::TraitRef<'tcx>)\n+                                -> ty::ExistentialTraitRef<'tcx> {\n+        assert_eq!(trait_ref.self_ty().sty, TRAIT_OBJECT_DUMMY_SELF);\n+        ty::ExistentialTraitRef::erase_self_ty(self.tcx(), trait_ref)\n     }\n \n-    fn make_object_type(&self,\n-                        span: Span,\n-                        principal: ty::PolyTraitRef<'tcx>,\n-                        bounds: ty::ExistentialBounds<'tcx>)\n-                        -> Ty<'tcx> {\n+    fn trait_path_to_object_type(&self,\n+                                 rscope: &RegionScope,\n+                                 path_span: Span,\n+                                 param_mode: PathParamMode,\n+                                 trait_def_id: DefId,\n+                                 trait_path_ref_id: ast::NodeId,\n+                                 trait_segment: &hir::PathSegment,\n+                                 span: Span,\n+                                 partitioned_bounds: PartitionedBounds)\n+                                 -> Ty<'tcx> {\n         let tcx = self.tcx();\n-        let object = ty::TraitTy {\n-            principal: principal,\n-            bounds: bounds\n+\n+        let mut projection_bounds = vec![];\n+        let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n+        let principal = self.ast_path_to_poly_trait_ref(rscope,\n+                                                        path_span,\n+                                                        param_mode,\n+                                                        trait_def_id,\n+                                                        dummy_self,\n+                                                        trait_path_ref_id,\n+                                                        trait_segment,\n+                                                        &mut projection_bounds);\n+\n+        let PartitionedBounds { builtin_bounds,\n+                                trait_bounds,\n+                                region_bounds } =\n+            partitioned_bounds;\n+\n+        if !trait_bounds.is_empty() {\n+            let b = &trait_bounds[0];\n+            let span = b.trait_ref.path.span;\n+            struct_span_err!(self.tcx().sess, span, E0225,\n+                             \"only the builtin traits can be used as closure or object bounds\")\n+                .span_label(span, &format!(\"non-builtin trait used as bounds\"))\n+                .emit();\n+        }\n+\n+        // Erase the dummy_self (TRAIT_OBJECT_DUMMY_SELF) used above.\n+        let existential_principal = principal.map_bound(|trait_ref| {\n+            self.trait_ref_to_existential(trait_ref)\n+        });\n+        let existential_projections = projection_bounds.iter().map(|bound| {\n+            bound.map_bound(|b| {\n+                let p = b.projection_ty;\n+                ty::ExistentialProjection {\n+                    trait_ref: self.trait_ref_to_existential(p.trait_ref),\n+                    item_name: p.item_name,\n+                    ty: b.ty\n+                }\n+            })\n+        }).collect();\n+\n+        let region_bound =\n+            self.compute_object_lifetime_bound(span,\n+                                               &region_bounds,\n+                                               existential_principal,\n+                                               builtin_bounds);\n+\n+        let region_bound = match region_bound {\n+            Some(r) => r,\n+            None => {\n+                match rscope.object_lifetime_default(span) {\n+                    Some(r) => r,\n+                    None => {\n+                        span_err!(self.tcx().sess, span, E0228,\n+                                  \"the lifetime bound for this object type cannot be deduced \\\n+                                   from context; please supply an explicit bound\");\n+                        ty::ReStatic\n+                    }\n+                }\n+            }\n         };\n-        let object_trait_ref =\n-            object.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n+\n+        debug!(\"region_bound: {:?}\", region_bound);\n \n         // ensure the super predicates and stop if we encountered an error\n         if self.ensure_super_predicates(span, principal.def_id()).is_err() {\n@@ -1193,7 +1132,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n \n         let mut associated_types: FnvHashSet<(DefId, ast::Name)> =\n-            traits::supertraits(tcx, object_trait_ref)\n+            traits::supertraits(tcx, principal)\n             .flat_map(|tr| {\n                 let trait_def = tcx.lookup_trait_def(tr.def_id());\n                 trait_def.associated_type_names\n@@ -1203,7 +1142,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             })\n             .collect();\n \n-        for projection_bound in &object.bounds.projection_bounds {\n+        for projection_bound in &projection_bounds {\n             let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n                         projection_bound.0.projection_ty.item_name);\n             associated_types.remove(&pair);\n@@ -1219,7 +1158,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         .emit();\n         }\n \n-        tcx.mk_trait(object.principal, object.bounds)\n+        let ty = tcx.mk_trait(ty::TraitObject {\n+            principal: existential_principal,\n+            region_bound: region_bound,\n+            builtin_bounds: builtin_bounds,\n+            projection_bounds: existential_projections\n+        });\n+        debug!(\"trait_object_type: {:?}\", ty);\n+        ty\n     }\n \n     fn report_ambiguous_associated_type(&self,\n@@ -1379,8 +1325,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n-            (&ty::TyParam(_), Def::TyParam(_, _, param_did, param_name)) => {\n+            (&ty::TyParam(_), Def::TyParam(param_did)) => {\n                 let param_node_id = tcx.map.as_local_node_id(param_did).unwrap();\n+                let param_name = tcx.type_parameter_def(param_node_id).name;\n                 match self.find_bound_for_assoc_item(param_node_id,\n                                                      param_name,\n                                                      assoc_name,\n@@ -1390,10 +1337,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }\n             }\n             _ => {\n-                self.report_ambiguous_associated_type(span,\n-                                                      &ty.to_string(),\n-                                                      \"Trait\",\n-                                                      &assoc_name.as_str());\n+                // Don't print TyErr to the user.\n+                if !ty.references_error() {\n+                    self.report_ambiguous_associated_type(span,\n+                                                          &ty.to_string(),\n+                                                          \"Trait\",\n+                                                          &assoc_name.as_str());\n+                }\n                 return (tcx.types.err, Def::Err);\n             }\n         };\n@@ -1453,7 +1403,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                         span,\n                                                         param_mode,\n                                                         trait_def_id,\n-                                                        Some(self_ty),\n+                                                        self_ty,\n                                                         trait_segment);\n \n         debug!(\"qpath_to_ty: trait_ref={:?}\", trait_ref);\n@@ -1468,24 +1418,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     /// # Parameters\n     ///\n     /// * `this`, `rscope`: the surrounding context\n-    /// * `decl_generics`: the generics of the struct/enum/trait declaration being\n-    ///   referenced\n-    /// * `index`: the index of the type parameter being instantiated from the list\n-    ///   (we assume it is in the `TypeSpace`)\n+    /// * `def`: the type parameter being instantiated (if available)\n     /// * `region_substs`: a partial substitution consisting of\n     ///   only the region type parameters being supplied to this type.\n     /// * `ast_ty`: the ast representation of the type being supplied\n-    pub fn ast_ty_arg_to_ty(&self,\n-                            rscope: &RegionScope,\n-                            decl_generics: &ty::Generics<'tcx>,\n-                            index: usize,\n-                            region_substs: &Substs<'tcx>,\n-                            ast_ty: &hir::Ty)\n-                            -> Ty<'tcx>\n+    fn ast_ty_arg_to_ty(&self,\n+                        rscope: &RegionScope,\n+                        def: Option<&ty::TypeParameterDef<'tcx>>,\n+                        region_substs: &Substs<'tcx>,\n+                        ast_ty: &hir::Ty)\n+                        -> Ty<'tcx>\n     {\n         let tcx = self.tcx();\n \n-        if let Some(def) = decl_generics.types.opt_get(TypeSpace, index) {\n+        if let Some(def) = def {\n             let object_lifetime_default = def.object_lifetime_default.subst(tcx, region_substs);\n             let rscope1 = &ObjectLifetimeDefaultRscope::new(rscope, object_lifetime_default);\n             self.ast_ty_to_ty(rscope1, ast_ty)\n@@ -1515,23 +1461,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::Trait(trait_def_id) => {\n                 // N.B. this case overlaps somewhat with\n                 // TyObjectSum, see that fn for details\n-                let mut projection_bounds = Vec::new();\n-\n-                let trait_ref =\n-                    self.object_path_to_poly_trait_ref(rscope,\n-                                                       span,\n-                                                       param_mode,\n-                                                       trait_def_id,\n-                                                       base_path_ref_id,\n-                                                       base_segments.last().unwrap(),\n-                                                       &mut projection_bounds);\n \n                 tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n-                self.trait_ref_to_object_type(rscope,\n-                                              span,\n-                                              trait_ref,\n-                                              projection_bounds,\n-                                              &[])\n+\n+                self.trait_path_to_object_type(rscope,\n+                                               span,\n+                                               param_mode,\n+                                               trait_def_id,\n+                                               base_path_ref_id,\n+                                               base_segments.last().unwrap(),\n+                                               span,\n+                                               partition_bounds(tcx, span, &[]))\n             }\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n                 tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n@@ -1541,9 +1481,25 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                     did,\n                                     base_segments.last().unwrap())\n             }\n-            Def::TyParam(space, index, _, name) => {\n+            Def::TyParam(did) => {\n                 tcx.prohibit_type_params(base_segments);\n-                tcx.mk_param(space, index, name)\n+\n+                let node_id = tcx.map.as_local_node_id(did).unwrap();\n+                let param = tcx.ty_param_defs.borrow().get(&node_id)\n+                               .map(ty::ParamTy::for_def);\n+                if let Some(p) = param {\n+                    p.to_ty(tcx)\n+                } else {\n+                    // Only while computing defaults of earlier type\n+                    // parameters can a type parameter be missing its def.\n+                    struct_span_err!(tcx.sess, span, E0128,\n+                                     \"type parameters with a default cannot use \\\n+                                      forward declared identifiers\")\n+                        .span_label(span, &format!(\"defaulted type parameters \\\n+                                                    cannot be forward declared\"))\n+                        .emit();\n+                    tcx.types.err\n+                }\n             }\n             Def::SelfTy(_, Some(impl_id)) => {\n                 // Self in impl (we know the concrete type).\n@@ -1671,18 +1627,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 tcx.mk_slice(self.ast_ty_to_ty(rscope, &ty))\n             }\n             hir::TyObjectSum(ref ty, ref bounds) => {\n-                match self.ast_ty_to_trait_ref(rscope, &ty, bounds) {\n-                    Ok((trait_ref, projection_bounds)) => {\n-                        self.trait_ref_to_object_type(rscope,\n-                                                      ast_ty.span,\n-                                                      trait_ref,\n-                                                      projection_bounds,\n-                                                      bounds)\n-                    }\n-                    Err(ErrorReported) => {\n-                        self.tcx().types.err\n-                    }\n-                }\n+                self.ast_ty_to_object_trait_ref(rscope, ast_ty.span, ty, bounds)\n             }\n             hir::TyPtr(ref mt) => {\n                 tcx.mk_ptr(ty::TypeAndMut {\n@@ -1759,15 +1704,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 tcx.mk_fn_ptr(bare_fn_ty)\n             }\n             hir::TyPolyTraitRef(ref bounds) => {\n-                self.conv_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n+                self.conv_object_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n             }\n             hir::TyImplTrait(ref bounds) => {\n                 use collect::{compute_bounds, SizedByDefault};\n \n                 // Create the anonymized type.\n                 let def_id = tcx.map.local_def_id(ast_ty.id);\n                 if let Some(anon_scope) = rscope.anon_type_scope() {\n-                    let substs = anon_scope.fresh_substs(tcx);\n+                    let substs = anon_scope.fresh_substs(self, ast_ty.span);\n                     let ty = tcx.mk_anon(tcx.map.local_def_id(ast_ty.id), substs);\n \n                     // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n@@ -1778,7 +1723,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     let predicates = bounds.predicates(tcx, ty);\n                     let predicates = tcx.lift_to_global(&predicates).unwrap();\n                     tcx.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n-                        predicates: VecPerParamSpace::new(vec![], vec![], predicates)\n+                        parent: None,\n+                        predicates: predicates\n                     });\n \n                     ty\n@@ -1829,7 +1775,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // values in a ExprClosure, or as\n                 // the type of local variables. Both of these cases are\n                 // handled specially and will not descend into this routine.\n-                self.ty_infer(None, None, None, ast_ty.span)\n+                self.ty_infer(ast_ty.span)\n             }\n         };\n \n@@ -1846,7 +1792,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     {\n         match a.ty.node {\n             hir::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n-            hir::TyInfer => self.ty_infer(None, None, None, a.ty.span),\n+            hir::TyInfer => self.ty_infer(a.ty.span),\n             _ => self.ast_ty_to_ty(rscope, &a.ty),\n         }\n     }\n@@ -2068,8 +2014,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let output_ty = match decl.output {\n             _ if is_infer && expected_ret_ty.is_some() =>\n                 expected_ret_ty.unwrap(),\n-            _ if is_infer =>\n-                self.ty_infer(None, None, None, decl.output.span()),\n+            _ if is_infer => self.ty_infer(decl.output.span()),\n             hir::Return(ref output) =>\n                 self.ast_ty_to_ty(&rb, &output),\n             hir::DefaultReturn(..) => bug!(),\n@@ -2087,104 +2032,32 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    /// Given an existential type like `Foo+'a+Bar`, this routine converts\n-    /// the `'a` and `Bar` intos an `ExistentialBounds` struct.\n-    /// The `main_trait_refs` argument specifies the `Foo` -- it is absent\n-    /// for closures. Eventually this should all be normalized, I think,\n-    /// so that there is no \"main trait ref\" and instead we just have a flat\n-    /// list of bounds as the existential type.\n-    fn conv_existential_bounds(&self,\n-        rscope: &RegionScope,\n-        span: Span,\n-        principal_trait_ref: ty::PolyTraitRef<'tcx>,\n-        projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n-        ast_bounds: &[hir::TyParamBound])\n-        -> ty::ExistentialBounds<'tcx>\n-    {\n-        let partitioned_bounds =\n-            partition_bounds(self.tcx(), span, ast_bounds);\n-\n-        self.conv_existential_bounds_from_partitioned_bounds(\n-            rscope, span, principal_trait_ref, projection_bounds, partitioned_bounds)\n-    }\n-\n-    fn conv_ty_poly_trait_ref(&self,\n+    fn conv_object_ty_poly_trait_ref(&self,\n         rscope: &RegionScope,\n         span: Span,\n         ast_bounds: &[hir::TyParamBound])\n         -> Ty<'tcx>\n     {\n         let mut partitioned_bounds = partition_bounds(self.tcx(), span, &ast_bounds[..]);\n \n-        let mut projection_bounds = Vec::new();\n-        let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n-            let trait_bound = partitioned_bounds.trait_bounds.remove(0);\n-            self.instantiate_poly_trait_ref(rscope,\n-                                            trait_bound,\n-                                            None,\n-                                            &mut projection_bounds)\n+        let trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n+            partitioned_bounds.trait_bounds.remove(0)\n         } else {\n             span_err!(self.tcx().sess, span, E0224,\n                       \"at least one non-builtin trait is required for an object type\");\n             return self.tcx().types.err;\n         };\n \n-        let bounds =\n-            self.conv_existential_bounds_from_partitioned_bounds(rscope,\n-                                                                 span,\n-                                                                 main_trait_bound.clone(),\n-                                                                 projection_bounds,\n-                                                                 partitioned_bounds);\n-\n-        self.make_object_type(span, main_trait_bound, bounds)\n-    }\n-\n-    pub fn conv_existential_bounds_from_partitioned_bounds(&self,\n-        rscope: &RegionScope,\n-        span: Span,\n-        principal_trait_ref: ty::PolyTraitRef<'tcx>,\n-        projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>, // Empty for boxed closures\n-        partitioned_bounds: PartitionedBounds)\n-        -> ty::ExistentialBounds<'tcx>\n-    {\n-        let PartitionedBounds { builtin_bounds,\n-                                trait_bounds,\n-                                region_bounds } =\n-            partitioned_bounds;\n-\n-        if !trait_bounds.is_empty() {\n-            let b = &trait_bounds[0];\n-            let span = b.trait_ref.path.span;\n-            struct_span_err!(self.tcx().sess, span, E0225,\n-                             \"only the builtin traits can be used as closure or object bounds\")\n-                .span_label(span, &format!(\"non-builtin trait used as bounds\"))\n-                .emit();\n-        }\n-\n-        let region_bound =\n-            self.compute_object_lifetime_bound(span,\n-                                               &region_bounds,\n-                                               principal_trait_ref,\n-                                               builtin_bounds);\n-\n-        let region_bound = match region_bound {\n-            Some(r) => r,\n-            None => {\n-                match rscope.object_lifetime_default(span) {\n-                    Some(r) => r,\n-                    None => {\n-                        span_err!(self.tcx().sess, span, E0228,\n-                                  \"the lifetime bound for this object type cannot be deduced \\\n-                                   from context; please supply an explicit bound\");\n-                        ty::ReStatic\n-                    }\n-                }\n-            }\n-        };\n-\n-        debug!(\"region_bound: {:?}\", region_bound);\n-\n-        ty::ExistentialBounds::new(region_bound, builtin_bounds, projection_bounds)\n+        let trait_ref = &trait_bound.trait_ref;\n+        let trait_def_id = self.trait_def_id(trait_ref);\n+        self.trait_path_to_object_type(rscope,\n+                                       trait_ref.path.span,\n+                                       PathParamMode::Explicit,\n+                                       trait_def_id,\n+                                       trait_ref.ref_id,\n+                                       trait_ref.path.segments.last().unwrap(),\n+                                       span,\n+                                       partitioned_bounds)\n     }\n \n     /// Given the bounds on an object, determines what single region bound (if any) we can\n@@ -2195,7 +2068,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn compute_object_lifetime_bound(&self,\n         span: Span,\n         explicit_region_bounds: &[&hir::Lifetime],\n-        principal_trait_ref: ty::PolyTraitRef<'tcx>,\n+        principal_trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n         builtin_bounds: ty::BuiltinBounds)\n         -> Option<ty::Region> // if None, use the default\n     {\n@@ -2226,7 +2099,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // No explicit region bound specified. Therefore, examine trait\n         // bounds and see if we can derive region bounds from those.\n         let derived_region_bounds =\n-            object_region_bounds(tcx, &principal_trait_ref, builtin_bounds);\n+            object_region_bounds(tcx, principal_trait_ref, builtin_bounds);\n \n         // If there are no derived region bounds, then report back that we\n         // can find no region bound. The caller will use the default.\n@@ -2279,7 +2152,7 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                             let parameters = &segments[segments.len() - 1].parameters;\n                             if !parameters.types().is_empty() {\n                                 check_type_argument_count(tcx, b.trait_ref.path.span,\n-                                                          parameters.types().len(), 0, 0);\n+                                                          parameters.types().len(), &[]);\n                             }\n                             if !parameters.lifetimes().is_empty() {\n                                 report_lifetime_number_error(tcx, b.trait_ref.path.span,\n@@ -2310,7 +2183,9 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n }\n \n fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n-                             required: usize, accepted: usize) {\n+                             ty_param_defs: &[ty::TypeParameterDef]) {\n+    let accepted = ty_param_defs.len();\n+    let required = ty_param_defs.iter().take_while(|x| x.default.is_none()) .count();\n     if supplied < required {\n         let expected = if required < accepted {\n             \"expected at least\""}, {"sha": "af24a7b51176ccca97c67e3f167da966e33a44a4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -547,10 +547,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // Type check the path.\n-        let scheme = tcx.lookup_item_type(def.def_id());\n-        let predicates = tcx.lookup_predicates(def.def_id());\n-        let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n-                                                 opt_ty, def, pat.span, pat.id);\n+        let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n         self.demand_suptype(pat.span, expected, pat_ty);\n     }\n \n@@ -607,18 +604,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // Type check the path.\n-        let scheme = tcx.lookup_item_type(def.def_id());\n-        let scheme = if scheme.ty.is_fn() {\n+        let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n+\n+        let pat_ty = if pat_ty.is_fn() {\n             // Replace constructor type with constructed type for tuple struct patterns.\n-            let fn_ret = tcx.no_late_bound_regions(&scheme.ty.fn_ret()).unwrap();\n-            ty::TypeScheme { ty: fn_ret, generics: scheme.generics }\n+            tcx.no_late_bound_regions(&pat_ty.fn_ret()).unwrap()\n         } else {\n             // Leave the type as is for unit structs (backward compatibility).\n-            scheme\n+            pat_ty\n         };\n-        let predicates = tcx.lookup_predicates(def.def_id());\n-        let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n-                                                 opt_ty, def, pat.span, pat.id);\n+        self.write_ty(pat.id, pat_ty);\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns."}, {"sha": "9a3cbabe553314fd77bf3719a3686c8aba61bc62", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                 Some(f) => f,\n                 None => return None\n             },\n-            substs: tcx.mk_substs(Substs::new_trait(vec![], vec![], self.cur_ty))\n+            substs: Substs::new_trait(tcx, vec![], vec![], self.cur_ty)\n         };\n \n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);"}, {"sha": "fb78d3a37ca236404c5706916566637f1d3be83c", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn unsize_kind(&self, t: Ty<'tcx>) -> Option<UnsizeKind<'tcx>> {\n         match t.sty {\n             ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n-            ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal_def_id())),\n+            ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal.def_id())),\n             ty::TyStruct(def, substs) => {\n                 // FIXME(arielb1): do some kind of normalization\n                 match def.struct_variant().fields.last() {"}, {"sha": "377ca5eaebe302745e97093c011a20cb5ae1571f", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -13,7 +13,6 @@\n use super::{check_fn, Expectation, FnCtxt};\n \n use astconv::AstConv;\n-use rustc::ty::subst;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n use std::cmp;\n use syntax::abi::Abi;\n@@ -102,12 +101,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         match expected_ty.sty {\n             ty::TyTrait(ref object_type) => {\n-                let proj_bounds = object_type.projection_bounds_with_self_ty(self.tcx,\n-                                                                             self.tcx.types.err);\n-                let sig = proj_bounds.iter()\n-                                     .filter_map(|pb| self.deduce_sig_from_projection(pb))\n-                                     .next();\n-                let kind = self.tcx.lang_items.fn_trait_kind(object_type.principal_def_id());\n+                let sig = object_type.projection_bounds.iter().filter_map(|pb| {\n+                    let pb = pb.with_self_ty(self.tcx, self.tcx.types.err);\n+                    self.deduce_sig_from_projection(&pb)\n+                }).next();\n+                let kind = self.tcx.lang_items.fn_trait_kind(object_type.principal.def_id());\n                 (sig, kind)\n             }\n             ty::TyInfer(ty::TyVar(vid)) => {\n@@ -205,7 +203,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n+        let arg_param_ty = trait_ref.substs().types[1];\n         let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n         debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n "}, {"sha": "6bcf21563cb98c919e907e2e4f431660f6cb7b86", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -13,7 +13,7 @@ use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty;\n use rustc::traits::{self, Reveal};\n use rustc::ty::error::ExpectedFound;\n-use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::hir::map::Node;\n use rustc::hir::{ImplItemKind, TraitItem_};\n \n@@ -95,8 +95,8 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }\n \n-    let num_impl_m_type_params = impl_m.generics.types.len(subst::FnSpace);\n-    let num_trait_m_type_params = trait_m.generics.types.len(subst::FnSpace);\n+    let num_impl_m_type_params = impl_m.generics.types.len();\n+    let num_trait_m_type_params = trait_m.generics.types.len();\n     if num_impl_m_type_params != num_trait_m_type_params {\n         span_err!(tcx.sess, impl_m_span, E0049,\n             \"method `{}` has {} type parameter{} \\\n@@ -194,10 +194,8 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Create mapping from trait to skolemized.\n     let trait_to_skol_substs =\n-        trait_to_impl_substs\n-        .subst(tcx, impl_to_skol_substs).clone()\n-        .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n-                     impl_to_skol_substs.regions.get_slice(subst::FnSpace).to_vec());\n+        impl_to_skol_substs.rebase_onto(tcx, impl_m.container_id(),\n+                                        trait_to_impl_substs.subst(tcx, impl_to_skol_substs));\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n@@ -208,66 +206,57 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            impl_m,\n                                            &trait_m.generics,\n                                            &impl_m.generics,\n-                                           &trait_to_skol_substs,\n+                                           trait_to_skol_substs,\n                                            impl_to_skol_substs) {\n         return;\n     }\n \n     tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|mut infcx| {\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n-        // Normalize the associated types in the trait_bounds.\n-        let trait_bounds = trait_m.predicates.instantiate(tcx, &trait_to_skol_substs);\n-\n         // Create obligations for each predicate declared by the impl\n         // definition in the context of the trait's parameter\n         // environment. We can't just use `impl_env.caller_bounds`,\n         // however, because we want to replace all late-bound regions with\n         // region variables.\n-        let impl_bounds =\n-            impl_m.predicates.instantiate(tcx, impl_to_skol_substs);\n-\n-        debug!(\"compare_impl_method: impl_bounds={:?}\", impl_bounds);\n+        let impl_predicates = tcx.lookup_predicates(impl_m.predicates.parent.unwrap());\n+        let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n \n-        // Obtain the predicate split predicate sets for each.\n-        let trait_pred = trait_bounds.predicates.split();\n-        let impl_pred = impl_bounds.predicates.split();\n+        debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n \n         // This is the only tricky bit of the new way we check implementation methods\n-        // We need to build a set of predicates where only the FnSpace bounds\n+        // We need to build a set of predicates where only the method-level bounds\n         // are from the trait and we assume all other bounds from the implementation\n         // to be previously satisfied.\n         //\n         // We then register the obligations from the impl_m and check to see\n         // if all constraints hold.\n-        let hybrid_preds = VecPerParamSpace::new(\n-            impl_pred.types,\n-            impl_pred.selfs,\n-            trait_pred.fns\n-        );\n+        hybrid_preds.predicates.extend(\n+            trait_m.predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n \n         // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n         // The key step here is to update the caller_bounds's predicates to be\n         // the new hybrid bounds we computed.\n         let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n-        let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.into_vec());\n+        let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.predicates);\n         let trait_param_env = traits::normalize_param_env_or_error(tcx,\n                                                                    trait_param_env,\n                                                                    normalize_cause.clone());\n         // FIXME(@jroesch) this seems ugly, but is a temporary change\n         infcx.parameter_environment = trait_param_env;\n \n-        debug!(\"compare_impl_method: trait_bounds={:?}\",\n+        debug!(\"compare_impl_method: caller_bounds={:?}\",\n             infcx.parameter_environment.caller_bounds);\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n-        let (impl_pred_fns, _) =\n+        let impl_m_own_bounds = impl_m.predicates.instantiate_own(tcx, impl_to_skol_substs);\n+        let (impl_m_own_bounds, _) =\n             infcx.replace_late_bound_regions_with_fresh_var(\n                 impl_m_span,\n                 infer::HigherRankedType,\n-                &ty::Binder(impl_pred.fns));\n-        for predicate in impl_pred_fns {\n+                &ty::Binder(impl_m_own_bounds.predicates));\n+        for predicate in impl_m_own_bounds {\n             let traits::Normalized { value: predicate, .. } =\n                 traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n \n@@ -322,7 +311,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             infcx.parameter_environment.free_id_outlive,\n             &trait_m.fty.sig);\n         let trait_sig =\n-            trait_sig.subst(tcx, &trait_to_skol_substs);\n+            trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n             assoc::normalize_associated_types_in(&infcx,\n                                                  &mut fulfillment_cx,\n@@ -390,8 +379,8 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                     -> bool\n     {\n \n-        let trait_params = trait_generics.regions.get_slice(subst::FnSpace);\n-        let impl_params = impl_generics.regions.get_slice(subst::FnSpace);\n+        let trait_params = &trait_generics.regions[..];\n+        let impl_params = &impl_generics.regions[..];\n \n         debug!(\"check_region_bounds_on_impl_method: \\\n                trait_generics={:?} \\\n@@ -453,16 +442,14 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         // Create mapping from trait to skolemized.\n         let trait_to_skol_substs =\n-            trait_to_impl_substs\n-            .subst(tcx, impl_to_skol_substs).clone()\n-            .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n-                         impl_to_skol_substs.regions.get_slice(subst::FnSpace).to_vec());\n+            impl_to_skol_substs.rebase_onto(tcx, impl_c.container.id(),\n+                                            trait_to_impl_substs.subst(tcx, impl_to_skol_substs));\n         debug!(\"compare_const_impl: trait_to_skol_substs={:?}\",\n             trait_to_skol_substs);\n \n         // Compute skolemized form of impl and trait const tys.\n         let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n-        let trait_ty = trait_c.ty.subst(tcx, &trait_to_skol_substs);\n+        let trait_ty = trait_c.ty.subst(tcx, trait_to_skol_substs);\n         let mut origin = TypeOrigin::Misc(impl_c_span);\n \n         let err = infcx.commit_if_ok(|_| {"}, {"sha": "82545d564a20c807f69fd91e3e7b82d4f877cf2b", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -15,7 +15,7 @@ use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use rustc::infer;\n use middle::region;\n-use rustc::ty::subst::{self, Subst};\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, Reveal};\n use util::nodemap::FnvHashSet;\n@@ -41,16 +41,14 @@ use syntax_pos::{self, Span};\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n-    let ty::TypeScheme { generics: ref dtor_generics,\n-                         ty: dtor_self_type } = ccx.tcx.lookup_item_type(drop_impl_did);\n+    let dtor_self_type = ccx.tcx.lookup_item_type(drop_impl_did).ty;\n     let dtor_predicates = ccx.tcx.lookup_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyEnum(adt_def, self_to_impl_substs) |\n         ty::TyStruct(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(ccx,\n                                                           drop_impl_did,\n-                                                          dtor_generics,\n-                                                          &dtor_self_type,\n+                                                          dtor_self_type,\n                                                           adt_def.did)?;\n \n             ensure_drop_predicates_are_implied_by_item_defn(ccx,\n@@ -73,8 +71,7 @@ pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()>\n fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     ccx: &CrateCtxt<'a, 'tcx>,\n     drop_impl_did: DefId,\n-    drop_impl_generics: &ty::Generics<'tcx>,\n-    drop_impl_ty: &ty::Ty<'tcx>,\n+    drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId) -> Result<(), ()>\n {\n     let tcx = ccx.tcx;\n@@ -93,8 +90,8 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n         let drop_impl_span = tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n         let fresh_impl_substs =\n-            infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n-        let fresh_impl_self_ty = drop_impl_ty.subst(tcx, &fresh_impl_substs);\n+            infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n+        let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         if let Err(_) = infcx.eq_types(true, infer::TypeOrigin::Misc(drop_impl_span),\n                                        named_type, fresh_impl_self_ty) {\n@@ -131,7 +128,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     drop_impl_did: DefId,\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n     self_type_did: DefId,\n-    self_to_impl_substs: &subst::Substs<'tcx>) -> Result<(), ()> {\n+    self_to_impl_substs: &Substs<'tcx>) -> Result<(), ()> {\n \n     // Here is an example, analogous to that from\n     // `compare_impl_method`.\n@@ -179,21 +176,16 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     let generic_assumptions = tcx.lookup_predicates(self_type_did);\n \n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n-    assert!(assumptions_in_impl_context.predicates.is_empty_in(subst::SelfSpace));\n-    assert!(assumptions_in_impl_context.predicates.is_empty_in(subst::FnSpace));\n-    let assumptions_in_impl_context =\n-        assumptions_in_impl_context.predicates.get_slice(subst::TypeSpace);\n+    let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n \n     // An earlier version of this code attempted to do this checking\n     // via the traits::fulfill machinery. However, it ran into trouble\n     // since the fulfill machinery merely turns outlives-predicates\n     // 'a:'b and T:'b into region inference constraints. It is simpler\n     // just to look for all the predicates directly.\n \n-    assert!(dtor_predicates.predicates.is_empty_in(subst::SelfSpace));\n-    assert!(dtor_predicates.predicates.is_empty_in(subst::FnSpace));\n-    let predicates = dtor_predicates.predicates.get_slice(subst::TypeSpace);\n-    for predicate in predicates {\n+    assert_eq!(dtor_predicates.parent, None);\n+    for predicate in &dtor_predicates.predicates {\n         // (We do not need to worry about deep analysis of type\n         // expressions etc because the Drop impls are already forced\n         // to take on a structure that is roughly an alpha-renaming of\n@@ -446,7 +438,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n \n         ty::TyStruct(def, substs) if def.is_phantom_data() => {\n             // PhantomData<T> - behaves identically to T\n-            let ity = *substs.types.get(subst::TypeSpace, 0);\n+            let ity = substs.types[0];\n             iterate_over_potentially_unsafe_regions_in_type(\n                 cx, context, ity, depth+1)\n         }"}, {"sha": "b2873bf686578bed51c985eafd2d4a125a7fdab0", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -13,7 +13,7 @@\n \n use intrinsics;\n use rustc::infer::TypeOrigin;\n-use rustc::ty::subst::{self, Substs};\n+use rustc::ty::subst::Substs;\n use rustc::ty::FnSig;\n use rustc::ty::{self, Ty};\n use {CrateCtxt, require_same_types};\n@@ -36,11 +36,11 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let def_id = tcx.map.local_def_id(it.id);\n     let i_ty = tcx.lookup_item_type(def_id);\n \n-    let mut substs = Substs::empty();\n-    substs.types = i_ty.generics.types.map(|def| tcx.mk_param_from_def(def));\n+    let substs = Substs::for_item(tcx, def_id,\n+                                  |_, _| ty::ReErased,\n+                                  |def, _| tcx.mk_param_from_def(def));\n \n-    let fty = tcx.mk_fn_def(def_id, tcx.mk_substs(substs),\n-                            tcx.mk_bare_fn(ty::BareFnTy {\n+    let fty = tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n         abi: abi,\n         sig: ty::Binder(FnSig {\n@@ -49,7 +49,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             variadic: false,\n         }),\n     }));\n-    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n+    let i_n_tps = i_ty.generics.types.len();\n     if i_n_tps != n_tps {\n         struct_span_err!(tcx.sess, it.span, E0094,\n             \"intrinsic has wrong number of type \\\n@@ -70,7 +70,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n     fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n         let name = token::intern(&format!(\"P{}\", n));\n-        ccx.tcx.mk_param(subst::FnSpace, n, name)\n+        ccx.tcx.mk_param(n, name)\n     }\n \n     let tcx = ccx.tcx;\n@@ -316,12 +316,12 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                                      it: &hir::ForeignItem) {\n     let param = |n| {\n         let name = token::intern(&format!(\"P{}\", n));\n-        ccx.tcx.mk_param(subst::FnSpace, n, name)\n+        ccx.tcx.mk_param(n, name)\n     };\n \n     let tcx = ccx.tcx;\n     let i_ty = tcx.lookup_item_type(tcx.map.local_def_id(it.id));\n-    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n+    let i_n_tps = i_ty.generics.types.len();\n     let name = it.name.as_str();\n \n     let (n_tps, inputs, output) = match &*name {"}, {"sha": "9e0b38fd9fe517a163c9cffcdfce403b394f8b31", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 54, "deletions": 69, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -12,7 +12,7 @@ use super::probe;\n \n use check::{FnCtxt, callee};\n use hir::def_id::DefId;\n-use rustc::ty::subst::{self};\n+use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n@@ -42,10 +42,6 @@ struct InstantiatedMethodSig<'tcx> {\n     /// argument is the receiver.\n     method_sig: ty::FnSig<'tcx>,\n \n-    /// Substitutions for all types/early-bound-regions declared on\n-    /// the method.\n-    all_substs: subst::Substs<'tcx>,\n-\n     /// Generic bounds on the method's parameters which must be added\n     /// as pending obligations.\n     method_predicates: ty::InstantiatedPredicates<'tcx>,\n@@ -105,9 +101,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Create the final signature for the method, replacing late-bound regions.\n         let InstantiatedMethodSig {\n-            method_sig, all_substs, method_predicates\n+            method_sig, method_predicates\n         } = self.instantiate_method_sig(&pick, all_substs);\n-        let all_substs = self.tcx.mk_substs(all_substs);\n         let method_self_ty = method_sig.inputs[0];\n \n         // Unify the (adjusted) self type with what the method expects.\n@@ -198,7 +193,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn fresh_receiver_substs(&mut self,\n                              self_ty: Ty<'tcx>,\n                              pick: &probe::Pick<'tcx>)\n-                             -> subst::Substs<'tcx>\n+                             -> &'tcx Substs<'tcx>\n     {\n         match pick.kind {\n             probe::InherentImplPick => {\n@@ -210,7 +205,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n             probe::ObjectPick => {\n                 let trait_def_id = pick.item.container().id();\n-                self.extract_trait_ref(self_ty, |this, object_ty, data| {\n+                self.extract_existential_trait_ref(self_ty, |this, object_ty, principal| {\n                     // The object data has no entry for the Self\n                     // Type. For the purposes of this method call, we\n                     // substitute the object type itself. This\n@@ -222,16 +217,16 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     // been ruled out when we deemed the trait to be\n                     // \"object safe\".\n                     let original_poly_trait_ref =\n-                        data.principal_trait_ref_with_self_ty(this.tcx, object_ty);\n+                        principal.with_self_ty(this.tcx, object_ty);\n                     let upcast_poly_trait_ref =\n-                        this.upcast(original_poly_trait_ref.clone(), trait_def_id);\n+                        this.upcast(original_poly_trait_ref, trait_def_id);\n                     let upcast_trait_ref =\n                         this.replace_late_bound_regions_with_fresh_var(&upcast_poly_trait_ref);\n                     debug!(\"original_poly_trait_ref={:?} upcast_trait_ref={:?} target_trait={:?}\",\n                            original_poly_trait_ref,\n                            upcast_trait_ref,\n                            trait_def_id);\n-                    upcast_trait_ref.substs.clone()\n+                    upcast_trait_ref.substs\n                 })\n             }\n \n@@ -249,35 +244,36 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 let impl_trait_ref =\n                     self.instantiate_type_scheme(\n                         self.span,\n-                        &impl_polytype.substs,\n+                        impl_polytype.substs,\n                         &self.tcx.impl_trait_ref(impl_def_id).unwrap());\n-                impl_trait_ref.substs.clone()\n+                impl_trait_ref.substs\n             }\n \n             probe::TraitPick => {\n                 let trait_def_id = pick.item.container().id();\n-                let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n \n                 // Make a trait reference `$0 : Trait<$1...$n>`\n                 // consisting entirely of type variables. Later on in\n                 // the process we will unify the transformed-self-type\n                 // of the method with the actual type in order to\n                 // unify some of these variables.\n-                self.fresh_substs_for_trait(self.span,\n-                                            &trait_def.generics,\n-                                            self.next_ty_var())\n+                self.fresh_substs_for_item(self.span, trait_def_id)\n             }\n \n             probe::WhereClausePick(ref poly_trait_ref) => {\n                 // Where clauses can have bound regions in them. We need to instantiate\n                 // those to convert from a poly-trait-ref to a trait-ref.\n-                self.replace_late_bound_regions_with_fresh_var(&poly_trait_ref).substs.clone()\n+                self.replace_late_bound_regions_with_fresh_var(&poly_trait_ref).substs\n             }\n         }\n     }\n \n-    fn extract_trait_ref<R, F>(&mut self, self_ty: Ty<'tcx>, mut closure: F) -> R where\n-        F: FnMut(&mut ConfirmContext<'a, 'gcx, 'tcx>, Ty<'tcx>, &ty::TraitTy<'tcx>) -> R,\n+    fn extract_existential_trait_ref<R, F>(&mut self,\n+                                           self_ty: Ty<'tcx>,\n+                                           mut closure: F) -> R\n+        where F: FnMut(&mut ConfirmContext<'a, 'gcx, 'tcx>,\n+                       Ty<'tcx>,\n+                       ty::PolyExistentialTraitRef<'tcx>) -> R,\n     {\n         // If we specified that this is an object method, then the\n         // self-type ought to be something that can be dereferenced to\n@@ -288,7 +284,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         self.fcx.autoderef(self.span, self_ty)\n             .filter_map(|(ty, _)| {\n                 match ty.sty {\n-                    ty::TyTrait(ref data) => Some(closure(self, ty, &data)),\n+                    ty::TyTrait(ref data) => Some(closure(self, ty, data.principal)),\n                     _ => None,\n                 }\n             })\n@@ -303,59 +299,49 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n     fn instantiate_method_substs(&mut self,\n                                  pick: &probe::Pick<'tcx>,\n-                                 supplied_method_types: Vec<Ty<'tcx>>,\n-                                 substs: subst::Substs<'tcx>)\n-                                 -> subst::Substs<'tcx>\n+                                 mut supplied_method_types: Vec<Ty<'tcx>>,\n+                                 substs: &Substs<'tcx>)\n+                                 -> &'tcx Substs<'tcx>\n     {\n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n         let method = pick.item.as_opt_method().unwrap();\n-        let method_types = method.generics.types.get_slice(subst::FnSpace);\n-        let num_method_types = method_types.len();\n-\n+        let num_method_types = method.generics.types.len();\n+\n+        if num_supplied_types > 0 && num_supplied_types != num_method_types {\n+            if num_method_types == 0 {\n+                span_err!(self.tcx.sess, self.span, E0035,\n+                    \"does not take type parameters\");\n+            } else {\n+                span_err!(self.tcx.sess, self.span, E0036,\n+                    \"incorrect number of type parameters given for this method: \\\n+                     expected {}, found {}\",\n+                    num_method_types, num_supplied_types);\n+            }\n+            supplied_method_types = vec![self.tcx.types.err; num_method_types];\n+        }\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method.\n         //\n         // FIXME -- permit users to manually specify lifetimes\n-        let method_regions =\n-            self.region_vars_for_defs(\n-                self.span,\n-                pick.item.as_opt_method().unwrap()\n-                    .generics.regions.get_slice(subst::FnSpace));\n-\n-        let subst::Substs { types, regions } = substs;\n-        let regions = regions.with_slice(subst::FnSpace, &method_regions);\n-        let mut final_substs = subst::Substs { types: types, regions: regions };\n-\n-        if num_supplied_types == 0 {\n-            self.type_vars_for_defs(\n-                self.span,\n-                subst::FnSpace,\n-                &mut final_substs,\n-                method_types);\n-        } else if num_method_types == 0 {\n-            span_err!(self.tcx.sess, self.span, E0035,\n-                \"does not take type parameters\");\n-            self.type_vars_for_defs(\n-                self.span,\n-                subst::FnSpace,\n-                &mut final_substs,\n-                method_types);\n-        } else if num_supplied_types != num_method_types {\n-            span_err!(self.tcx.sess, self.span, E0036,\n-                \"incorrect number of type parameters given for this method: expected {}, found {}\",\n-                num_method_types, num_supplied_types);\n-            final_substs.types.replace(\n-                subst::FnSpace,\n-                vec![self.tcx.types.err; num_method_types]);\n-        } else {\n-            final_substs.types.replace(subst::FnSpace, supplied_method_types);\n-        }\n-\n-        return final_substs;\n+        Substs::for_item(self.tcx, method.def_id, |def, _| {\n+            if let Some(&r) = substs.regions.get(def.index as usize) {\n+                r\n+            } else {\n+                self.region_var_for_def(self.span, def)\n+            }\n+        }, |def, cur_substs| {\n+            if let Some(&ty) = substs.types.get(def.index as usize) {\n+                ty\n+            } else if supplied_method_types.is_empty() {\n+                self.type_var_for_def(self.span, def, cur_substs)\n+            } else {\n+                supplied_method_types[def.index as usize - substs.types.len()]\n+            }\n+        })\n     }\n \n     fn unify_receivers(&mut self,\n@@ -382,7 +368,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n     fn instantiate_method_sig(&mut self,\n                               pick: &probe::Pick<'tcx>,\n-                              all_substs: subst::Substs<'tcx>)\n+                              all_substs: &'tcx Substs<'tcx>)\n                               -> InstantiatedMethodSig<'tcx>\n     {\n         debug!(\"instantiate_method_sig(pick={:?}, all_substs={:?})\",\n@@ -393,7 +379,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n         let method_predicates = pick.item.as_opt_method().unwrap()\n-                                    .predicates.instantiate(self.tcx, &all_substs);\n+                                    .predicates.instantiate(self.tcx, all_substs);\n         let method_predicates = self.normalize_associated_types_in(self.span,\n                                                                    &method_predicates);\n \n@@ -411,20 +397,19 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={:?}\",\n                method_sig);\n \n-        let method_sig = self.instantiate_type_scheme(self.span, &all_substs, &method_sig);\n+        let method_sig = self.instantiate_type_scheme(self.span, all_substs, &method_sig);\n         debug!(\"type scheme substituted, method_sig={:?}\",\n                method_sig);\n \n         InstantiatedMethodSig {\n             method_sig: method_sig,\n-            all_substs: all_substs,\n             method_predicates: method_predicates,\n         }\n     }\n \n     fn add_obligations(&mut self,\n                        fty: Ty<'tcx>,\n-                       all_substs: &subst::Substs<'tcx>,\n+                       all_substs: &Substs<'tcx>,\n                        method_predicates: &ty::InstantiatedPredicates<'tcx>) {\n         debug!(\"add_obligations: fty={:?} all_substs={:?} method_predicates={:?}\",\n                fty,"}, {"sha": "bcb410e1b8d0132b284ce0932e43cec3f366b85b", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -13,7 +13,7 @@\n use check::FnCtxt;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use rustc::ty::subst;\n+use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n@@ -182,31 +182,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n \n-        let type_parameter_defs = trait_def.generics.types.get_slice(subst::TypeSpace);\n-        let expected_number_of_input_types = type_parameter_defs.len();\n-\n-        assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n+        if let Some(ref input_types) = opt_input_types {\n+            assert_eq!(trait_def.generics.types.len() - 1, input_types.len());\n+        }\n         assert!(trait_def.generics.regions.is_empty());\n \n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n-        let mut substs = subst::Substs::new_trait(Vec::new(), Vec::new(), self_ty);\n-\n-        match opt_input_types {\n-            Some(input_types) => {\n-                assert_eq!(expected_number_of_input_types, input_types.len());\n-                substs.types.replace(subst::ParamSpace::TypeSpace, input_types);\n+        let substs = Substs::for_item(self.tcx, trait_def_id, |def, _| {\n+            self.region_var_for_def(span, def)\n+        }, |def, substs| {\n+            if def.index == 0 {\n+                self_ty\n+            } else if let Some(ref input_types) = opt_input_types {\n+                input_types[def.index as usize - 1]\n+            } else {\n+                self.type_var_for_def(span, def, substs)\n             }\n+        });\n \n-            None => {\n-                self.type_vars_for_defs(\n-                    span,\n-                    subst::ParamSpace::TypeSpace,\n-                    &mut substs,\n-                    type_parameter_defs);\n-            }\n-        }\n-\n-        let trait_ref = ty::TraitRef::new(trait_def_id, self.tcx.mk_substs(substs));\n+        let trait_ref = ty::TraitRef::new(trait_def_id, substs);\n \n         // Construct an obligation\n         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n@@ -226,8 +220,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let method_item = self.trait_item(trait_def_id, m_name).unwrap();\n         let method_ty = method_item.as_opt_method().unwrap();\n-        assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n-        assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n+        assert_eq!(method_ty.generics.types.len(), 0);\n+        assert_eq!(method_ty.generics.regions.len(), 0);\n \n         debug!(\"lookup_in_trait_adjusted: method_item={:?} method_ty={:?}\",\n                method_item, method_ty);"}, {"sha": "c306463ec1de0795b7352e6a01cf89a90462543c", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 55, "deletions": 67, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -16,8 +16,7 @@ use super::suggest;\n use check::{FnCtxt};\n use hir::def_id::DefId;\n use hir::def::Def;\n-use rustc::ty::subst;\n-use rustc::ty::subst::Subst;\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::infer::{InferOk, TypeOrigin};\n@@ -80,9 +79,9 @@ struct Candidate<'tcx> {\n \n #[derive(Debug)]\n enum CandidateKind<'tcx> {\n-    InherentImplCandidate(subst::Substs<'tcx>,\n+    InherentImplCandidate(&'tcx Substs<'tcx>,\n                           /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n-    ExtensionImplCandidate(/* Impl */ DefId, subst::Substs<'tcx>,\n+    ExtensionImplCandidate(/* Impl */ DefId, &'tcx Substs<'tcx>,\n                            /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n     ObjectCandidate,\n     TraitCandidate,\n@@ -290,8 +289,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         match self_ty.sty {\n             ty::TyTrait(box ref data) => {\n-                self.assemble_inherent_candidates_from_object(self_ty, data);\n-                self.assemble_inherent_impl_candidates_for_type(data.principal_def_id());\n+                self.assemble_inherent_candidates_from_object(self_ty, data.principal);\n+                self.assemble_inherent_impl_candidates_for_type(data.principal.def_id());\n             }\n             ty::TyEnum(def, _) |\n             ty::TyStruct(def, _) => {\n@@ -421,10 +420,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         }\n \n         let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n-        let impl_ty = impl_ty.subst(self.tcx, &impl_substs);\n+        let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n \n         // Determine the receiver type that the method itself expects.\n-        let xform_self_ty = self.xform_self_ty(&item, impl_ty, &impl_substs);\n+        let xform_self_ty = self.xform_self_ty(&item, impl_ty, impl_substs);\n \n         // We can't use normalize_associated_types_in as it will pollute the\n         // fcx's fulfillment context after this probe is over.\n@@ -445,7 +444,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_inherent_candidates_from_object(&mut self,\n                                                 self_ty: Ty<'tcx>,\n-                                                data: &ty::TraitTy<'tcx>) {\n+                                                principal: ty::PolyExistentialTraitRef<'tcx>) {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={:?})\",\n                self_ty);\n \n@@ -456,7 +455,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // a substitution that replaces `Self` with the object type\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n-        let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx, self_ty);\n+        let trait_ref = principal.with_self_ty(self.tcx, self_ty);\n         self.elaborate_bounds(&[trait_ref], |this, new_trait_ref, item| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n@@ -519,14 +518,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                        trait_ref,\n                        trait_ref.substs,\n                        m);\n-                assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n-                           trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n-                assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n-                           trait_ref.substs.regions.get_slice(subst::TypeSpace).len());\n-                assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n-                           trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n-                assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n-                           trait_ref.substs.regions.get_slice(subst::SelfSpace).len());\n+                assert_eq!(m.generics.parent_types as usize,\n+                           trait_ref.substs.types.len());\n+                assert_eq!(m.generics.parent_regions as usize,\n+                           trait_ref.substs.regions.len());\n             }\n \n             // Because this trait derives from a where-clause, it\n@@ -665,7 +660,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let impl_trait_ref =\n                 self.tcx.impl_trait_ref(impl_def_id)\n                 .unwrap() // we know this is a trait impl\n-                .subst(self.tcx, &impl_substs);\n+                .subst(self.tcx, impl_substs);\n \n             debug!(\"impl_trait_ref={:?}\", impl_trait_ref);\n \n@@ -753,14 +748,19 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // for the purposes of our method lookup, we only take\n             // receiver type into account, so we can just substitute\n             // fresh types here to use during substitution and subtyping.\n-            let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n-            let substs = self.fresh_substs_for_trait(self.span,\n-                                                     &trait_def.generics,\n-                                                     step.self_ty);\n+            let substs = Substs::for_item(self.tcx, trait_def_id, |def, _| {\n+                self.region_var_for_def(self.span, def)\n+            }, |def, substs| {\n+                if def.index == 0 {\n+                    step.self_ty\n+                } else {\n+                    self.type_var_for_def(self.span, def, substs)\n+                }\n+            });\n \n             let xform_self_ty = self.xform_self_ty(&item,\n                                                    step.self_ty,\n-                                                   &substs);\n+                                                   substs);\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n@@ -799,7 +799,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             let trait_predicates = self.tcx.lookup_predicates(def_id);\n             let bounds = trait_predicates.instantiate(self.tcx, substs);\n-            let predicates = bounds.predicates.into_vec();\n+            let predicates = bounds.predicates;\n             debug!(\"assemble_projection_candidates: predicates={:?}\",\n                    predicates);\n             for poly_bound in\n@@ -1192,7 +1192,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn xform_self_ty(&self,\n                      item: &ty::ImplOrTraitItem<'tcx>,\n                      impl_ty: Ty<'tcx>,\n-                     substs: &subst::Substs<'tcx>)\n+                     substs: &Substs<'tcx>)\n                      -> Ty<'tcx>\n     {\n         match item.as_opt_method() {\n@@ -1205,7 +1205,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn xform_method_self_ty(&self,\n                             method: &Rc<ty::Method<'tcx>>,\n                             impl_ty: Ty<'tcx>,\n-                            substs: &subst::Substs<'tcx>)\n+                            substs: &Substs<'tcx>)\n                             -> Ty<'tcx>\n     {\n         debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n@@ -1220,64 +1220,52 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // are given do not include type/lifetime parameters for the\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n-        assert_eq!(substs.types.len(subst::FnSpace), 0);\n-        assert_eq!(substs.regions.len(subst::FnSpace), 0);\n+        assert_eq!(substs.types.len(), method.generics.parent_types as usize);\n+        assert_eq!(substs.regions.len(), method.generics.parent_regions as usize);\n \n         if self.mode == Mode::Path {\n             return impl_ty;\n         }\n \n-        let mut placeholder;\n-        let mut substs = substs;\n-        if\n-            !method.generics.types.is_empty_in(subst::FnSpace) ||\n-            !method.generics.regions.is_empty_in(subst::FnSpace)\n-        {\n-            // In general, during probe we erase regions. See\n-            // `impl_self_ty()` for an explanation.\n-            let method_regions =\n-                method.generics.regions.get_slice(subst::FnSpace)\n-                .iter()\n-                .map(|_| ty::ReErased)\n-                .collect();\n-\n-            placeholder = (*substs).clone().with_method(Vec::new(), method_regions);\n-\n-            self.type_vars_for_defs(\n-                self.span,\n-                subst::FnSpace,\n-                &mut placeholder,\n-                method.generics.types.get_slice(subst::FnSpace));\n-\n-            substs = &placeholder;\n-        }\n-\n         // Erase any late-bound regions from the method and substitute\n         // in the values from the substitution.\n         let xform_self_ty = method.fty.sig.input(0);\n         let xform_self_ty = self.erase_late_bound_regions(&xform_self_ty);\n-        let xform_self_ty = xform_self_ty.subst(self.tcx, substs);\n \n-        xform_self_ty\n+        if method.generics.types.is_empty() && method.generics.regions.is_empty() {\n+            xform_self_ty.subst(self.tcx, substs)\n+        } else {\n+            let substs = Substs::for_item(self.tcx, method.def_id, |def, _| {\n+                if let Some(&r) = substs.regions.get(def.index as usize) {\n+                    r\n+                } else {\n+                    // In general, during probe we erase regions. See\n+                    // `impl_self_ty()` for an explanation.\n+                    ty::ReErased\n+                }\n+            }, |def, cur_substs| {\n+                if let Some(&ty) = substs.types.get(def.index as usize) {\n+                    ty\n+                } else {\n+                    self.type_var_for_def(self.span, def, cur_substs)\n+                }\n+            });\n+            xform_self_ty.subst(self.tcx, substs)\n+        }\n     }\n \n     /// Get the type of an impl and generate substitutions with placeholders.\n     fn impl_ty_and_substs(&self,\n                           impl_def_id: DefId)\n-                          -> (Ty<'tcx>, subst::Substs<'tcx>)\n+                          -> (Ty<'tcx>, &'tcx Substs<'tcx>)\n     {\n-        let impl_pty = self.tcx.lookup_item_type(impl_def_id);\n-\n-        let type_vars =\n-            impl_pty.generics.types.map(\n-                |_| self.next_ty_var());\n+        let impl_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n \n-        let region_placeholders =\n-            impl_pty.generics.regions.map(\n-                |_| ty::ReErased); // see erase_late_bound_regions() for an expl of why 'erased\n+        let substs = Substs::for_item(self.tcx, impl_def_id,\n+                                      |_, _| ty::ReErased,\n+                                      |_, _| self.next_ty_var());\n \n-        let substs = subst::Substs::new(type_vars, region_placeholders);\n-        (impl_pty.ty, substs)\n+        (impl_ty, substs)\n     }\n \n     /// Replace late-bound-regions bound by `value` with `'static` using"}, {"sha": "573dae46456baa2f3b78146e3bab014e63112671", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -54,10 +54,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 self.autoderef(span, ty).any(|(ty, _)| self.probe(|_| {\n                     let fn_once_substs =\n-                        Substs::new_trait(vec![self.next_ty_var()], vec![], ty);\n-                    let trait_ref =\n-                        ty::TraitRef::new(fn_once,\n-                                          tcx.mk_substs(fn_once_substs));\n+                        Substs::new_trait(tcx, vec![self.next_ty_var()], vec![], ty);\n+                    let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                     let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                     let obligation = Obligation::misc(span,\n                                                       self.body_id,\n@@ -358,7 +356,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match ty.sty {\n                 ty::TyEnum(def, _) | ty::TyStruct(def, _) => def.did.is_local(),\n \n-                ty::TyTrait(ref tr) => tr.principal_def_id().is_local(),\n+                ty::TyTrait(ref tr) => tr.principal.def_id().is_local(),\n \n                 ty::TyParam(_) => true,\n "}, {"sha": "e573655b8c9847ffd045a7e07110e0e7109c1130", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 241, "deletions": 422, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -88,9 +88,8 @@ use hir::def::{Def, PathResolution};\n use hir::def_id::DefId;\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n-use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, Reveal};\n-use rustc::ty::{GenericPredicates, TypeScheme};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n@@ -745,26 +744,20 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n           let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n           match ccx.tcx.impl_trait_ref(impl_def_id) {\n               Some(impl_trait_ref) => {\n-                  let trait_def_id = impl_trait_ref.def_id;\n-\n                   check_impl_items_against_trait(ccx,\n                                                  it.span,\n                                                  impl_def_id,\n                                                  &impl_trait_ref,\n                                                  impl_items);\n-                  check_on_unimplemented(\n-                      ccx,\n-                      &ccx.tcx.lookup_trait_def(trait_def_id).generics,\n-                      it,\n-                      ccx.tcx.item_name(trait_def_id));\n+                  let trait_def_id = impl_trait_ref.def_id;\n+                  check_on_unimplemented(ccx, trait_def_id, it);\n               }\n               None => { }\n           }\n       }\n       hir::ItemTrait(..) => {\n         let def_id = ccx.tcx.map.local_def_id(it.id);\n-        let generics = &ccx.tcx.lookup_trait_def(def_id).generics;\n-        check_on_unimplemented(ccx, generics, it, it.name);\n+        check_on_unimplemented(ccx, def_id, it);\n       }\n       hir::ItemStruct(..) => {\n         check_struct(ccx, it.id, it.span);\n@@ -872,9 +865,9 @@ fn check_trait_fn_not_const<'a,'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                    generics: &ty::Generics,\n-                                    item: &hir::Item,\n-                                    name: ast::Name) {\n+                                    def_id: DefId,\n+                                    item: &hir::Item) {\n+    let generics = ccx.tcx.lookup_generics(def_id);\n     if let Some(ref attr) = item.attrs.iter().find(|a| {\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n@@ -893,6 +886,7 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         }) {\n                             Some(_) => (),\n                             None => {\n+                                let name = ccx.tcx.item_name(def_id);\n                                 span_err!(ccx.tcx.sess, attr.span, E0230,\n                                                  \"there is no type parameter \\\n                                                           {} on trait {}\",\n@@ -1300,6 +1294,12 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         &self.ast_ty_to_ty_cache\n     }\n \n+    fn get_generics(&self, _: Span, id: DefId)\n+                    -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>\n+    {\n+        Ok(self.tcx().lookup_generics(id))\n+    }\n+\n     fn get_item_type_scheme(&self, _: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n     {\n@@ -1333,7 +1333,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n                                   .filter_map(|predicate| {\n                                       match *predicate {\n                                           ty::Predicate::Trait(ref data) => {\n-                                              if data.0.self_ty().is_param(def.space, def.index) {\n+                                              if data.0.self_ty().is_param(def.index) {\n                                                   Some(data.to_poly_trait_ref())\n                                               } else {\n                                                   None\n@@ -1357,27 +1357,15 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         trait_def.associated_type_names.contains(&assoc_name)\n     }\n \n-    fn ty_infer(&self,\n-                ty_param_def: Option<ty::TypeParameterDef<'tcx>>,\n-                substs: Option<&mut subst::Substs<'tcx>>,\n-                space: Option<subst::ParamSpace>,\n-                span: Span) -> Ty<'tcx> {\n-        // Grab the default doing subsitution\n-        let default = ty_param_def.and_then(|def| {\n-            def.default.map(|ty| type_variable::Default {\n-                ty: ty.subst_spanned(self.tcx(), substs.as_ref().unwrap(), Some(span)),\n-                origin_span: span,\n-                def_id: def.default_def_id\n-            })\n-        });\n-\n-        let ty_var = self.next_ty_var_with_default(default);\n+    fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n+        self.next_ty_var()\n+    }\n \n-        // Finally we add the type variable to the substs\n-        match substs {\n-            None => ty_var,\n-            Some(substs) => { substs.types.push(space.unwrap(), ty_var); ty_var }\n-        }\n+    fn ty_infer_for_def(&self,\n+                        ty_param_def: &ty::TypeParameterDef<'tcx>,\n+                        substs: &Substs<'tcx>,\n+                        span: Span) -> Ty<'tcx> {\n+        self.type_var_for_def(span, ty_param_def, substs)\n     }\n \n     fn projected_ty_from_poly_trait_ref(&self,\n@@ -1624,8 +1612,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           bounds: &ty::GenericPredicates<'tcx>)\n                           -> ty::InstantiatedPredicates<'tcx>\n     {\n+        let result = bounds.instantiate(self.tcx, substs);\n+        let result = self.normalize_associated_types_in(span, &result.predicates);\n+        debug!(\"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}\",\n+               bounds,\n+               substs,\n+               result);\n         ty::InstantiatedPredicates {\n-            predicates: self.instantiate_type_scheme(span, substs, &bounds.predicates)\n+            predicates: result\n         }\n     }\n \n@@ -1701,26 +1695,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  node_id: ast::NodeId)\n                                  -> Ty<'tcx> {\n         debug!(\"instantiate_type_path(did={:?}, path={:?})\", did, path);\n-        let mut type_scheme = self.tcx.lookup_item_type(did);\n-        if type_scheme.ty.is_fn() {\n+        let mut ty = self.tcx.lookup_item_type(did).ty;\n+        if ty.is_fn() {\n             // Tuple variants have fn type even in type namespace, extract true variant type from it\n-            let fn_ret = self.tcx.no_late_bound_regions(&type_scheme.ty.fn_ret()).unwrap();\n-            type_scheme = ty::TypeScheme { ty: fn_ret, generics: type_scheme.generics }\n+            ty = self.tcx.no_late_bound_regions(&ty.fn_ret()).unwrap();\n         }\n         let type_predicates = self.tcx.lookup_predicates(did);\n         let substs = AstConv::ast_path_substs_for_ty(self, self,\n                                                      path.span,\n                                                      PathParamMode::Optional,\n-                                                     &type_scheme.generics,\n+                                                     did,\n                                                      path.segments.last().unwrap());\n-        let substs = self.tcx.mk_substs(substs);\n-        debug!(\"instantiate_type_path: ty={:?} substs={:?}\", &type_scheme.ty, substs);\n+        debug!(\"instantiate_type_path: ty={:?} substs={:?}\", ty, substs);\n         let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);\n         let cause = traits::ObligationCause::new(path.span, self.body_id,\n                                                  traits::ItemObligation(did));\n         self.add_obligations_for_parameters(cause, &bounds);\n \n-        let ty_substituted = self.instantiate_type_scheme(path.span, substs, &type_scheme.ty);\n+        let ty_substituted = self.instantiate_type_scheme(path.span, substs, &ty);\n         self.write_ty(node_id, ty_substituted);\n         self.write_substs(node_id, ty::ItemSubsts {\n             substs: substs\n@@ -2784,22 +2776,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         span: Span, // (potential) receiver for this impl\n                         did: DefId)\n                         -> TypeAndSubsts<'tcx> {\n-        let tcx = self.tcx;\n+        let ity = self.tcx.lookup_item_type(did);\n+        debug!(\"impl_self_ty: ity={:?}\", ity);\n \n-        let ity = tcx.lookup_item_type(did);\n-        let (tps, rps, raw_ty) =\n-            (ity.generics.types.get_slice(subst::TypeSpace),\n-             ity.generics.regions.get_slice(subst::TypeSpace),\n-             ity.ty);\n-\n-        debug!(\"impl_self_ty: tps={:?} rps={:?} raw_ty={:?}\", tps, rps, raw_ty);\n-\n-        let rps = self.region_vars_for_defs(span, rps);\n-        let mut substs = subst::Substs::new(\n-            VecPerParamSpace::empty(),\n-            VecPerParamSpace::new(rps, Vec::new(), Vec::new()));\n-        self.type_vars_for_defs(span, ParamSpace::TypeSpace, &mut substs, tps);\n-        let substd_ty = self.instantiate_type_scheme(span, &substs, &raw_ty);\n+        let substs = self.fresh_substs_for_item(span, did);\n+        let substd_ty = self.instantiate_type_scheme(span, &substs, &ity.ty);\n \n         TypeAndSubsts { substs: substs, ty: substd_ty }\n     }\n@@ -3246,28 +3227,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.set_tainted_by_errors();\n                 return None;\n             }\n-            Def::Variant(..) | Def::Struct(..) => {\n-                Some(self.tcx.expect_variant_def(def))\n+            Def::Variant(type_did, _) | Def::Struct(type_did) => {\n+                Some((type_did, self.tcx.expect_variant_def(def)))\n             }\n-            Def::TyAlias(did) | Def::AssociatedTy(_, did) => {\n+            Def::TyAlias(did) => {\n                 if let Some(&ty::TyStruct(adt, _)) = self.tcx.opt_lookup_item_type(did)\n                                                              .map(|scheme| &scheme.ty.sty) {\n-                    Some(adt.struct_variant())\n+                    Some((did, adt.struct_variant()))\n                 } else {\n                     None\n                 }\n             }\n             _ => None\n         };\n \n-        if let Some(variant) = variant {\n+        if let Some((def_id, variant)) = variant {\n             if variant.kind == ty::VariantKind::Tuple &&\n                     !self.tcx.sess.features.borrow().relaxed_adts {\n                 emit_feature_err(&self.tcx.sess.parse_sess.span_diagnostic,\n                                  \"relaxed_adts\", span, GateIssue::Language,\n                                  \"tuple structs and variants in struct patterns are unstable\");\n             }\n-            let ty = self.instantiate_type_path(def.def_id(), path, node_id);\n+            let ty = self.instantiate_type_path(def_id, path, node_id);\n             Some((variant, ty))\n         } else {\n             struct_span_err!(self.tcx.sess, path.span, E0071,\n@@ -3466,10 +3447,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n                                                                          expr.id, expr.span);\n               if def != Def::Err {\n-                  let (scheme, predicates) = self.type_scheme_and_predicates_for_def(expr.span,\n-                                                                                     def);\n-                  self.instantiate_value_path(segments, scheme, &predicates,\n-                                              opt_ty, def, expr.span, id);\n+                  self.instantiate_value_path(segments, opt_ty, def, expr.span, id);\n               } else {\n                   self.set_tainted_by_errors();\n                   self.write_error(id);\n@@ -4059,54 +4037,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         *self.ps.borrow_mut() = prev;\n     }\n \n-    // Returns the type parameter count and the type for the given definition.\n-    fn type_scheme_and_predicates_for_def(&self,\n-                                          sp: Span,\n-                                          defn: Def)\n-                                          -> (TypeScheme<'tcx>, GenericPredicates<'tcx>) {\n-        match defn {\n-            Def::Local(_, nid) | Def::Upvar(_, nid, _, _) => {\n-                let typ = self.local_ty(sp, nid);\n-                (ty::TypeScheme { generics: ty::Generics::empty(), ty: typ },\n-                 ty::GenericPredicates::empty())\n-            }\n-            Def::Fn(id) | Def::Method(id) |\n-            Def::Static(id, _) | Def::Variant(_, id) |\n-            Def::Struct(id) | Def::Const(id) | Def::AssociatedConst(id) => {\n-                (self.tcx.lookup_item_type(id), self.tcx.lookup_predicates(id))\n-            }\n-            Def::Trait(_) |\n-            Def::Enum(..) |\n-            Def::TyAlias(..) |\n-            Def::AssociatedTy(..) |\n-            Def::PrimTy(_) |\n-            Def::TyParam(..) |\n-            Def::Mod(..) |\n-            Def::ForeignMod(..) |\n-            Def::Label(..) |\n-            Def::SelfTy(..) |\n-            Def::Err => {\n-                span_bug!(sp, \"expected value, found {:?}\", defn);\n-            }\n-        }\n-    }\n-\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     pub fn instantiate_value_path(&self,\n                                   segments: &[hir::PathSegment],\n-                                  type_scheme: TypeScheme<'tcx>,\n-                                  type_predicates: &ty::GenericPredicates<'tcx>,\n                                   opt_self_ty: Option<Ty<'tcx>>,\n                                   def: Def,\n                                   span: Span,\n                                   node_id: ast::NodeId)\n                                   -> Ty<'tcx> {\n-        debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n+        debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={})\",\n                segments,\n                def,\n-               node_id,\n-               type_scheme);\n+               node_id);\n \n         // We need to extract the type parameters supplied by the user in\n         // the path `path`. Due to the current setup, this is a bit of a\n@@ -4180,54 +4123,37 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(!segments.is_empty());\n \n         let mut ufcs_associated = None;\n-        let mut segment_spaces: Vec<_>;\n+        let mut type_segment = None;\n+        let mut fn_segment = None;\n         match def {\n             // Case 1 and 1b. Reference to a *type* or *enum variant*.\n-            Def::SelfTy(..) |\n-            Def::Struct(..) |\n-            Def::Variant(..) |\n-            Def::Enum(..) |\n-            Def::TyAlias(..) |\n-            Def::AssociatedTy(..) |\n-            Def::Trait(..) |\n-            Def::PrimTy(..) |\n-            Def::TyParam(..) => {\n+            Def::Struct(def_id) |\n+            Def::Variant(_, def_id) |\n+            Def::Enum(def_id) |\n+            Def::TyAlias(def_id) |\n+            Def::AssociatedTy(_, def_id) |\n+            Def::Trait(def_id) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n-                segment_spaces = vec![None; segments.len() - 1];\n-                segment_spaces.push(Some(subst::TypeSpace));\n+                let mut generics = self.tcx.lookup_generics(def_id);\n+                if let Some(def_id) = generics.parent {\n+                    // Variant and struct constructors use the\n+                    // generics of their parent type definition.\n+                    generics = self.tcx.lookup_generics(def_id);\n+                }\n+                type_segment = Some((segments.last().unwrap(), generics));\n             }\n \n             // Case 2. Reference to a top-level value.\n-            Def::Fn(..) |\n-            Def::Const(..) |\n-            Def::Static(..) => {\n-                segment_spaces = vec![None; segments.len() - 1];\n-                segment_spaces.push(Some(subst::FnSpace));\n-            }\n-\n-            // Case 3. Reference to a method.\n-            Def::Method(def_id) => {\n-                let container = self.tcx.impl_or_trait_item(def_id).container();\n-                match container {\n-                    ty::TraitContainer(trait_did) => {\n-                        callee::check_legal_trait_for_method_call(self.ccx, span, trait_did)\n-                    }\n-                    ty::ImplContainer(_) => {}\n-                }\n-\n-                if segments.len() >= 2 {\n-                    segment_spaces = vec![None; segments.len() - 2];\n-                    segment_spaces.push(Some(subst::TypeSpace));\n-                    segment_spaces.push(Some(subst::FnSpace));\n-                } else {\n-                    // `<T>::method` will end up here, and so can `T::method`.\n-                    let self_ty = opt_self_ty.expect(\"UFCS sugared method missing Self\");\n-                    segment_spaces = vec![Some(subst::FnSpace)];\n-                    ufcs_associated = Some((container, self_ty));\n-                }\n+            Def::Fn(def_id) |\n+            Def::Const(def_id) |\n+            Def::Static(def_id, _) => {\n+                fn_segment = Some((segments.last().unwrap(),\n+                                   self.tcx.lookup_generics(def_id)));\n             }\n \n+            // Case 3. Reference to a method or associated const.\n+            Def::Method(def_id) |\n             Def::AssociatedConst(def_id) => {\n                 let container = self.tcx.impl_or_trait_item(def_id).container();\n                 match container {\n@@ -4237,69 +4163,58 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::ImplContainer(_) => {}\n                 }\n \n+                let generics = self.tcx.lookup_generics(def_id);\n                 if segments.len() >= 2 {\n-                    segment_spaces = vec![None; segments.len() - 2];\n-                    segment_spaces.push(Some(subst::TypeSpace));\n-                    segment_spaces.push(None);\n+                    let parent_generics = self.tcx.lookup_generics(generics.parent.unwrap());\n+                    type_segment = Some((&segments[segments.len() - 2], parent_generics));\n                 } else {\n-                    // `<T>::CONST` will end up here, and so can `T::CONST`.\n-                    let self_ty = opt_self_ty.expect(\"UFCS sugared const missing Self\");\n-                    segment_spaces = vec![None];\n+                    // `<T>::assoc` will end up here, and so can `T::assoc`.\n+                    let self_ty = opt_self_ty.expect(\"UFCS sugared assoc missing Self\");\n                     ufcs_associated = Some((container, self_ty));\n                 }\n+                fn_segment = Some((segments.last().unwrap(), generics));\n             }\n \n             // Other cases. Various nonsense that really shouldn't show up\n             // here. If they do, an error will have been reported\n             // elsewhere. (I hope)\n             Def::Mod(..) |\n             Def::ForeignMod(..) |\n+            Def::PrimTy(..) |\n+            Def::SelfTy(..) |\n+            Def::TyParam(..) |\n             Def::Local(..) |\n             Def::Label(..) |\n-            Def::Upvar(..) => {\n-                segment_spaces = vec![None; segments.len()];\n-            }\n-\n-            Def::Err => {\n-                self.set_tainted_by_errors();\n-                segment_spaces = vec![None; segments.len()];\n-            }\n+            Def::Upvar(..) |\n+            Def::Err => {}\n         }\n-        assert_eq!(segment_spaces.len(), segments.len());\n \n         // In `<T as Trait<A, B>>::method`, `A` and `B` are mandatory, but\n         // `opt_self_ty` can also be Some for `Foo::method`, where Foo's\n         // type parameters are not mandatory.\n         let require_type_space = opt_self_ty.is_some() && ufcs_associated.is_none();\n \n-        debug!(\"segment_spaces={:?}\", segment_spaces);\n-\n-        // Next, examine the definition, and determine how many type\n-        // parameters we expect from each space.\n-        let type_defs = &type_scheme.generics.types;\n-        let region_defs = &type_scheme.generics.regions;\n+        debug!(\"type_segment={:?} fn_segment={:?}\", type_segment, fn_segment);\n \n         // Now that we have categorized what space the parameters for each\n         // segment belong to, let's sort out the parameters that the user\n         // provided (if any) into their appropriate spaces. We'll also report\n         // errors if type parameters are provided in an inappropriate place.\n-        let mut substs = Substs::empty();\n-        for (&opt_space, segment) in segment_spaces.iter().zip(segments) {\n-            if let Some(space) = opt_space {\n-                self.push_explicit_parameters_from_segment_to_substs(space,\n-                                                                     span,\n-                                                                     type_defs,\n-                                                                     region_defs,\n-                                                                     segment,\n-                                                                     &mut substs);\n-            } else {\n-                self.tcx.prohibit_type_params(slice::ref_slice(segment));\n-            }\n-        }\n-        if let Some(self_ty) = opt_self_ty {\n-            if type_defs.len(subst::SelfSpace) == 1 {\n-                substs.types.push(subst::SelfSpace, self_ty);\n+        let poly_segments = type_segment.is_some() as usize +\n+                            fn_segment.is_some() as usize;\n+        self.tcx.prohibit_type_params(&segments[..segments.len() - poly_segments]);\n+\n+        match def {\n+            Def::Local(_, nid) | Def::Upvar(_, nid, _, _) => {\n+                let ty = self.local_ty(span, nid);\n+                let ty = self.normalize_associated_types_in(span, &ty);\n+                self.write_ty(node_id, ty);\n+                self.write_substs(node_id, ty::ItemSubsts {\n+                    substs: Substs::empty(self.tcx)\n+                });\n+                return ty;\n             }\n+            _ => {}\n         }\n \n         // Now we have to compare the types that the user *actually*\n@@ -4308,20 +4223,88 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // variables. If the user provided some types, we may still need\n         // to add defaults. If the user provided *too many* types, that's\n         // a problem.\n-        for &space in &[subst::SelfSpace, subst::TypeSpace, subst::FnSpace] {\n-            self.adjust_type_parameters(span, space, type_defs,\n-                                        require_type_space, &mut substs);\n-            assert_eq!(substs.types.len(space), type_defs.len(space));\n+        self.check_path_parameter_count(span, !require_type_space, &mut type_segment);\n+        self.check_path_parameter_count(span, true, &mut fn_segment);\n+\n+        let substs = Substs::for_item(self.tcx, def.def_id(), |def, _| {\n+            let mut i = def.index as usize;\n+            let type_regions = match (type_segment, fn_segment) {\n+                (_, Some((_, generics))) => generics.parent_regions as usize,\n+                (Some((_, generics)), None) => generics.regions.len(),\n+                (None, None) => 0\n+            };\n \n-            self.adjust_region_parameters(span, space, region_defs, &mut substs);\n-            assert_eq!(substs.regions.len(space), region_defs.len(space));\n-        }\n+            let segment = if i < type_regions {\n+                type_segment\n+            } else {\n+                i -= type_regions;\n+                fn_segment\n+            };\n+            let lifetimes = match segment.map(|(s, _)| &s.parameters) {\n+                Some(&hir::AngleBracketedParameters(ref data)) => &data.lifetimes[..],\n+                Some(&hir::ParenthesizedParameters(_)) => bug!(),\n+                None => &[]\n+            };\n+\n+            if let Some(ast_lifetime) = lifetimes.get(i) {\n+                ast_region_to_region(self.tcx, ast_lifetime)\n+            } else {\n+                self.region_var_for_def(span, def)\n+            }\n+        }, |def, substs| {\n+            let mut i = def.index as usize;\n+            let (type_types, has_self) = match (type_segment, fn_segment) {\n+                (_, Some((_, generics))) => {\n+                    (generics.parent_types as usize, generics.has_self)\n+                }\n+                (Some((_, generics)), None) => {\n+                    (generics.types.len(), generics.has_self)\n+                }\n+                (None, None) => (0, false)\n+            };\n+\n+            let can_omit = i >= type_types || !require_type_space;\n+            let segment = if i < type_types {\n+                // Handle Self first, so we can adjust the index to match the AST.\n+                if has_self && i == 0 {\n+                    return opt_self_ty.unwrap_or_else(|| {\n+                        self.type_var_for_def(span, def, substs)\n+                    });\n+                }\n+                i -= has_self as usize;\n+                type_segment\n+            } else {\n+                i -= type_types;\n+                fn_segment\n+            };\n+            let types = match segment.map(|(s, _)| &s.parameters) {\n+                Some(&hir::AngleBracketedParameters(ref data)) => &data.types[..],\n+                Some(&hir::ParenthesizedParameters(_)) => bug!(),\n+                None => &[]\n+            };\n+\n+            let omitted = can_omit && types.is_empty();\n+            if let Some(ast_ty) = types.get(i) {\n+                // A provided type parameter.\n+                self.to_ty(ast_ty)\n+            } else if let (false, Some(default)) = (omitted, def.default) {\n+                // No type parameter provided, but a default exists.\n+                default.subst_spanned(self.tcx, substs, Some(span))\n+            } else {\n+                // No type parameters were provided, we can infer all.\n+                // This can also be reached in some error cases:\n+                // We prefer to use inference variables instead of\n+                // TyError to let type inference recover somewhat.\n+                self.type_var_for_def(span, def, substs)\n+            }\n+        });\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n-        let substs = self.tcx.mk_substs(substs);\n-        assert!(!substs.has_regions_escaping_depth(0));\n-        assert!(!type_scheme.has_escaping_regions());\n+        let scheme = self.tcx.lookup_item_type(def.def_id());\n+        let type_predicates = self.tcx.lookup_predicates(def.def_id());\n+        assert!(!substs.has_escaping_regions());\n+        assert!(!scheme.ty.has_escaping_regions());\n \n         // Add all the obligations that are required, substituting and\n         // normalized appropriately.\n@@ -4332,7 +4315,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Substitute the values for the type parameters into the type of\n         // the referenced item.\n-        let ty_substituted = self.instantiate_type_scheme(span, &substs, &type_scheme.ty);\n+        let ty_substituted = self.instantiate_type_scheme(span, &substs, &scheme.ty);\n \n \n         if let Some((ty::ImplContainer(impl_def_id), self_ty)) = ufcs_associated {\n@@ -4341,10 +4324,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // type parameters, which we can infer by unifying the provided `Self`\n             // with the substituted impl type.\n             let impl_scheme = self.tcx.lookup_item_type(impl_def_id);\n-            assert_eq!(substs.types.len(subst::TypeSpace),\n-                       impl_scheme.generics.types.len(subst::TypeSpace));\n-            assert_eq!(substs.regions.len(subst::TypeSpace),\n-                       impl_scheme.generics.regions.len(subst::TypeSpace));\n \n             let impl_ty = self.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n             match self.sub_types(false, TypeOrigin::Misc(span), self_ty, impl_ty) {\n@@ -4371,243 +4350,83 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty_substituted\n     }\n \n-    /// Finds the parameters that the user provided and adds them to `substs`. If too many\n-    /// parameters are provided, then reports an error and clears the output vector.\n-    ///\n-    /// We clear the output vector because that will cause the `adjust_XXX_parameters()` later to\n-    /// use inference variables. This seems less likely to lead to derived errors.\n-    ///\n-    /// Note that we *do not* check for *too few* parameters here. Due to the presence of defaults\n-    /// etc that is more complicated. I wanted however to do the reporting of *too many* parameters\n-    /// here because we can easily use the precise span of the N+1'th parameter.\n-    fn push_explicit_parameters_from_segment_to_substs(&self,\n-        space: subst::ParamSpace,\n-        span: Span,\n-        type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n-        region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n-        segment: &hir::PathSegment,\n-        substs: &mut Substs<'tcx>)\n-    {\n-        match segment.parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n-                self.push_explicit_angle_bracketed_parameters_from_segment_to_substs(\n-                    space, type_defs, region_defs, data, substs);\n+    /// Report errors if the provided parameters are too few or too many.\n+    fn check_path_parameter_count(&self,\n+                                  span: Span,\n+                                  can_omit: bool,\n+                                  segment: &mut Option<(&hir::PathSegment, &ty::Generics)>) {\n+        let (lifetimes, types, bindings) = match segment.map(|(s, _)| &s.parameters) {\n+            Some(&hir::AngleBracketedParameters(ref data)) => {\n+                (&data.lifetimes[..], &data.types[..], &data.bindings[..])\n             }\n-\n-            hir::ParenthesizedParameters(ref data) => {\n-                span_err!(self.tcx.sess, span, E0238,\n-                    \"parenthesized parameters may only be used with a trait\");\n-                self.push_explicit_parenthesized_parameters_from_segment_to_substs(\n-                    space, span, type_defs, data, substs);\n+            Some(&hir::ParenthesizedParameters(_)) => {\n+                span_bug!(span, \"parenthesized parameters cannot appear in ExprPath\");\n             }\n-        }\n-    }\n+            None => (&[][..], &[][..], &[][..])\n+        };\n \n-    fn push_explicit_angle_bracketed_parameters_from_segment_to_substs(&self,\n-        space: subst::ParamSpace,\n-        type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n-        region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n-        data: &hir::AngleBracketedParameterData,\n-        substs: &mut Substs<'tcx>)\n-    {\n-        {\n-            let type_count = type_defs.len(space);\n-            assert_eq!(substs.types.len(space), 0);\n-            for (i, typ) in data.types.iter().enumerate() {\n-                let t = self.to_ty(&typ);\n-                if i < type_count {\n-                    substs.types.push(space, t);\n-                } else if i == type_count {\n-                    struct_span_err!(self.tcx.sess, typ.span, E0087,\n-                                     \"too many type parameters provided: \\\n-                                      expected at most {} parameter{}, \\\n-                                      found {} parameter{}\",\n-                                     type_count,\n-                                     if type_count == 1 {\"\"} else {\"s\"},\n-                                     data.types.len(),\n-                                     if data.types.len() == 1 {\"\"} else {\"s\"})\n-                        .span_label(typ.span , &format!(\"expected {} parameter{}\",\n-                                    type_count,\n-                                    if type_count == 1 {\"\"} else {\"s\"})).emit();\n-                    substs.types.truncate(space, 0);\n-                    break;\n-                }\n-            }\n-        }\n+        let count = |n| {\n+            format!(\"{} parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n+        };\n \n-        if !data.bindings.is_empty() {\n-            span_err!(self.tcx.sess, data.bindings[0].span, E0182,\n-                      \"unexpected binding of associated item in expression path \\\n-                       (only allowed in type paths)\");\n+        // Check provided lifetime parameters.\n+        let lifetime_defs = segment.map_or(&[][..], |(_, generics)| &generics.regions);\n+        if lifetimes.len() > lifetime_defs.len() {\n+            let span = lifetimes[lifetime_defs.len()].span;\n+            span_err!(self.tcx.sess, span, E0088,\n+                      \"too many lifetime parameters provided: \\\n+                       expected {}, found {}\",\n+                      count(lifetime_defs.len()),\n+                      count(lifetimes.len()));\n+        } else if lifetimes.len() > 0 && lifetimes.len() < lifetime_defs.len() {\n+            span_err!(self.tcx.sess, span, E0090,\n+                      \"too few lifetime parameters provided: \\\n+                       expected {}, found {}\",\n+                      count(lifetime_defs.len()),\n+                      count(lifetimes.len()));\n         }\n \n-        {\n-            let region_count = region_defs.len(space);\n-            assert_eq!(substs.regions.len(space), 0);\n-            for (i, lifetime) in data.lifetimes.iter().enumerate() {\n-                let r = ast_region_to_region(self.tcx, lifetime);\n-                if i < region_count {\n-                    substs.regions.push(space, r);\n-                } else if i == region_count {\n-                    span_err!(self.tcx.sess, lifetime.span, E0088,\n-                        \"too many lifetime parameters provided: \\\n-                         expected {} parameter{}, found {} parameter{}\",\n-                        region_count,\n-                        if region_count == 1 {\"\"} else {\"s\"},\n-                        data.lifetimes.len(),\n-                        if data.lifetimes.len() == 1 {\"\"} else {\"s\"});\n-                    substs.regions.truncate(space, 0);\n-                    break;\n-                }\n+        // Check provided type parameters.\n+        let type_defs = segment.map_or(&[][..], |(_, generics)| {\n+            if generics.parent.is_none() {\n+                &generics.types[generics.has_self as usize..]\n+            } else {\n+                &generics.types\n             }\n-        }\n-    }\n-\n-    /// As with\n-    /// `push_explicit_angle_bracketed_parameters_from_segment_to_substs`,\n-    /// but intended for `Foo(A,B) -> C` form. This expands to\n-    /// roughly the same thing as `Foo<(A,B),C>`. One important\n-    /// difference has to do with the treatment of anonymous\n-    /// regions, which are translated into bound regions (NYI).\n-    fn push_explicit_parenthesized_parameters_from_segment_to_substs(&self,\n-        space: subst::ParamSpace,\n-        span: Span,\n-        type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n-        data: &hir::ParenthesizedParameterData,\n-        substs: &mut Substs<'tcx>)\n-    {\n-        let type_count = type_defs.len(space);\n-        if type_count < 2 {\n-            span_err!(self.tcx.sess, span, E0167,\n-                      \"parenthesized form always supplies 2 type parameters, \\\n-                      but only {} parameter(s) were expected\",\n-                      type_count);\n-        }\n-\n-        let input_tys: Vec<Ty> =\n-            data.inputs.iter().map(|ty| self.to_ty(&ty)).collect();\n-\n-        let tuple_ty = self.tcx.mk_tup(input_tys);\n-\n-        if type_count >= 1 {\n-            substs.types.push(space, tuple_ty);\n-        }\n-\n-        let output_ty: Option<Ty> =\n-            data.output.as_ref().map(|ty| self.to_ty(&ty));\n-\n-        let output_ty =\n-            output_ty.unwrap_or(self.tcx.mk_nil());\n-\n-        if type_count >= 2 {\n-            substs.types.push(space, output_ty);\n-        }\n-    }\n-\n-    fn adjust_type_parameters(&self,\n-        span: Span,\n-        space: ParamSpace,\n-        defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n-        require_type_space: bool,\n-        substs: &mut Substs<'tcx>)\n-    {\n-        let provided_len = substs.types.len(space);\n-        let desired = defs.get_slice(space);\n-        let required_len = desired.iter()\n-                              .take_while(|d| d.default.is_none())\n-                              .count();\n-\n-        debug!(\"adjust_type_parameters(space={:?}, \\\n-               provided_len={}, \\\n-               desired_len={}, \\\n-               required_len={})\",\n-               space,\n-               provided_len,\n-               desired.len(),\n-               required_len);\n-\n-        // Enforced by `push_explicit_parameters_from_segment_to_substs()`.\n-        assert!(provided_len <= desired.len());\n-\n-        // Nothing specified at all: supply inference variables for\n-        // everything.\n-        if provided_len == 0 && !(require_type_space && space == subst::TypeSpace) {\n-            substs.types.replace(space, Vec::new());\n-            self.type_vars_for_defs(span, space, substs, &desired[..]);\n-            return;\n-        }\n-\n-        // Too few parameters specified: report an error and use Err\n-        // for everything.\n-        if provided_len < required_len {\n+        });\n+        let required_len = type_defs.iter()\n+                                    .take_while(|d| d.default.is_none())\n+                                    .count();\n+        if types.len() > type_defs.len() {\n+            let span = types[type_defs.len()].span;\n+            struct_span_err!(self.tcx.sess, span, E0087,\n+                             \"too many type parameters provided: \\\n+                              expected at most {}, found {}\",\n+                             count(type_defs.len()),\n+                             count(types.len()))\n+                .span_label(span, &format!(\"expected {}\",\n+                            count(type_defs.len()))).emit();\n+\n+            // To prevent derived errors to accumulate due to extra\n+            // type parameters, we force instantiate_value_path to\n+            // use inference variables instead of the provided types.\n+            *segment = None;\n+        } else if !(can_omit && types.len() == 0) && types.len() < required_len {\n             let qualifier =\n-                if desired.len() != required_len { \"at least \" } else { \"\" };\n+                if type_defs.len() != required_len { \"at least \" } else { \"\" };\n             span_err!(self.tcx.sess, span, E0089,\n-                \"too few type parameters provided: expected {}{} parameter{}, \\\n-                 found {} parameter{}\",\n-                qualifier, required_len,\n-                if required_len == 1 {\"\"} else {\"s\"},\n-                provided_len,\n-                if provided_len == 1 {\"\"} else {\"s\"});\n-            substs.types.replace(space, vec![self.tcx.types.err; desired.len()]);\n-            return;\n-        }\n-\n-        // Otherwise, add in any optional parameters that the user\n-        // omitted. The case of *too many* parameters is handled\n-        // already by\n-        // push_explicit_parameters_from_segment_to_substs(). Note\n-        // that the *default* type are expressed in terms of all prior\n-        // parameters, so we have to substitute as we go with the\n-        // partial substitution that we have built up.\n-        for i in provided_len..desired.len() {\n-            let default = desired[i].default.unwrap();\n-            let default = default.subst_spanned(self.tcx, substs, Some(span));\n-            substs.types.push(space, default);\n+                      \"too few type parameters provided: \\\n+                       expected {}{}, found {}\",\n+                      qualifier,\n+                      count(required_len),\n+                      count(types.len()));\n         }\n-        assert_eq!(substs.types.len(space), desired.len());\n-\n-        debug!(\"Final substs: {:?}\", substs);\n-    }\n-\n-    fn adjust_region_parameters(&self,\n-        span: Span,\n-        space: ParamSpace,\n-        defs: &VecPerParamSpace<ty::RegionParameterDef>,\n-        substs: &mut Substs)\n-    {\n-        let provided_len = substs.regions.len(space);\n-        let desired = defs.get_slice(space);\n \n-        // Enforced by `push_explicit_parameters_from_segment_to_substs()`.\n-        assert!(provided_len <= desired.len());\n-\n-        // If nothing was provided, just use inference variables.\n-        if provided_len == 0 {\n-            substs.regions.replace(\n-                space,\n-                self.region_vars_for_defs(span, desired));\n-            return;\n-        }\n-\n-        // If just the right number were provided, everybody is happy.\n-        if provided_len == desired.len() {\n-            return;\n+        if !bindings.is_empty() {\n+            span_err!(self.tcx.sess, bindings[0].span, E0182,\n+                      \"unexpected binding of associated item in expression path \\\n+                       (only allowed in type paths)\");\n         }\n-\n-        // Otherwise, too few were provided. Report an error and then\n-        // use inference variables.\n-        span_err!(self.tcx.sess, span, E0090,\n-            \"too few lifetime parameters provided: expected {} parameter{}, \\\n-             found {} parameter{}\",\n-            desired.len(),\n-            if desired.len() == 1 {\"\"} else {\"s\"},\n-            provided_len,\n-            if provided_len == 1 {\"\"} else {\"s\"});\n-\n-        substs.regions.replace(\n-            space,\n-            self.region_vars_for_defs(span, desired));\n     }\n \n     fn structurally_resolve_type_or_else<F>(&self, sp: Span, ty: Ty<'tcx>, f: F)"}, {"sha": "859d5ff0543d01bcf6f56d0c55bd60c0ad7ea620", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -824,11 +824,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             /*From:*/ (_,\n-            /*To:  */  &ty::TyTrait(box ty::TraitTy { ref bounds, .. })) => {\n+            /*To:  */  &ty::TyTrait(ref obj)) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n                 self.type_must_outlive(infer::RelateObjectBound(cast_expr.span),\n-                                       from_ty, bounds.region_bound);\n+                                       from_ty, obj.region_bound);\n             }\n \n             /*From:*/ (&ty::TyBox(from_referent_ty),\n@@ -1571,10 +1571,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // the problem is to add `T: 'r`, which isn't true. So, if there are no\n         // inference variables, we use a verify constraint instead of adding\n         // edges, which winds up enforcing the same condition.\n-        let needs_infer = {\n-            projection_ty.trait_ref.substs.types.iter().any(|t| t.needs_infer()) ||\n-                projection_ty.trait_ref.substs.regions.iter().any(|r| r.needs_infer())\n-        };\n+        let needs_infer = projection_ty.trait_ref.needs_infer();\n         if env_bounds.is_empty() && needs_infer {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n@@ -1757,6 +1754,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         //\n         // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n         let trait_predicates = self.tcx.lookup_predicates(projection_ty.trait_ref.def_id);\n+        assert_eq!(trait_predicates.parent, None);\n         let predicates = trait_predicates.predicates.as_slice().to_vec();\n         traits::elaborate_predicates(self.tcx, predicates)\n             .filter_map(|predicate| {"}, {"sha": "7ed4b2bcb1918f3ab01e060395877a339515c8f5", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -14,13 +14,11 @@ use CrateCtxt;\n use hir::def_id::DefId;\n use middle::region::{CodeExtent};\n use rustc::infer::TypeOrigin;\n-use rustc::ty::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n \n use std::collections::HashSet;\n use syntax::ast;\n-use syntax::parse::token::keywords;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n \n@@ -455,67 +453,45 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n         let item_def_id = self.tcx().map.local_def_id(item.id);\n         let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n+        assert_eq!(ty_predicates.parent, None);\n         let variances = self.tcx().item_variances(item_def_id);\n \n         let mut constrained_parameters: HashSet<_> =\n             variances.types\n-                     .iter_enumerated()\n-                     .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n-                     .map(|(space, index, _)| self.param_ty(ast_generics, space, index))\n+                     .iter().enumerate()\n+                     .filter(|&(_, &variance)| variance != ty::Bivariant)\n+                     .map(|(index, _)| self.param_ty(ast_generics, index))\n                      .map(|p| Parameter::Type(p))\n                      .collect();\n \n         identify_constrained_type_params(ty_predicates.predicates.as_slice(),\n                                          None,\n                                          &mut constrained_parameters);\n \n-        for (space, index, _) in variances.types.iter_enumerated() {\n-            let param_ty = self.param_ty(ast_generics, space, index);\n+        for (index, _) in variances.types.iter().enumerate() {\n+            let param_ty = self.param_ty(ast_generics, index);\n             if constrained_parameters.contains(&Parameter::Type(param_ty)) {\n                 continue;\n             }\n-            let span = self.ty_param_span(ast_generics, item, space, index);\n+            let span = ast_generics.ty_params[index].span;\n             self.report_bivariance(span, param_ty.name);\n         }\n \n-        for (space, index, &variance) in variances.regions.iter_enumerated() {\n+        for (index, &variance) in variances.regions.iter().enumerate() {\n             if variance != ty::Bivariant {\n                 continue;\n             }\n \n-            assert_eq!(space, TypeSpace);\n             let span = ast_generics.lifetimes[index].lifetime.span;\n             let name = ast_generics.lifetimes[index].lifetime.name;\n             self.report_bivariance(span, name);\n         }\n     }\n \n-    fn param_ty(&self,\n-                ast_generics: &hir::Generics,\n-                space: ParamSpace,\n-                index: usize)\n-                -> ty::ParamTy\n-    {\n-        let name = match space {\n-            TypeSpace => ast_generics.ty_params[index].name,\n-            SelfSpace => keywords::SelfType.name(),\n-            FnSpace => bug!(\"Fn space occupied?\"),\n-        };\n-\n-        ty::ParamTy { space: space, idx: index as u32, name: name }\n-    }\n-\n-    fn ty_param_span(&self,\n-                     ast_generics: &hir::Generics,\n-                     item: &hir::Item,\n-                     space: ParamSpace,\n-                     index: usize)\n-                     -> Span\n-    {\n-        match space {\n-            TypeSpace => ast_generics.ty_params[index].span,\n-            SelfSpace => item.span,\n-            FnSpace => span_bug!(item.span, \"Fn space occupied?\"),\n+    fn param_ty(&self, ast_generics: &hir::Generics, index: usize) -> ty::ParamTy {\n+        ty::ParamTy {\n+            idx: index as u32,\n+            name: ast_generics.ty_params[index].name\n         }\n     }\n \n@@ -542,10 +518,10 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n }\n \n fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, generics: &ty::Generics) {\n-    let impl_params = generics.types.get_slice(subst::TypeSpace).iter()\n-        .map(|tp| tp.name).collect::<HashSet<_>>();\n+    let parent = tcx.lookup_generics(generics.parent.unwrap());\n+    let impl_params: HashSet<_> = parent.types.iter().map(|tp| tp.name).collect();\n \n-    for method_param in generics.types.get_slice(subst::FnSpace) {\n+    for method_param in &generics.types {\n         if impl_params.contains(&method_param.name) {\n             error_194(tcx, span, method_param.name);\n         }\n@@ -621,7 +597,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Trait impl: take implied bounds from all types that\n                 // appear in the trait reference.\n                 let trait_ref = self.instantiate_type_scheme(span, free_substs, trait_ref);\n-                trait_ref.substs.types.as_slice().to_vec()\n+                trait_ref.substs.types.to_vec()\n             }\n \n             None => {"}, {"sha": "cfc1292c34b78af0275585300c5acb9bd5f36d1e", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -18,7 +18,6 @@ use hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n-use rustc::ty::subst::ParamSpace;\n use rustc::infer::{InferCtxt, FixupError};\n use rustc::util::nodemap::DefIdMap;\n use write_substs_to_tcx;\n@@ -68,7 +67,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n-        wbcx.visit_anon_types();\n+        wbcx.visit_anon_types(item_id);\n         wbcx.visit_deferred_obligations(item_id);\n     }\n }\n@@ -104,22 +103,19 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n \n         let free_substs = fcx.parameter_environment.free_substs;\n-        for &space in &ParamSpace::all() {\n-            for (i, r) in free_substs.regions.get_slice(space).iter().enumerate() {\n-                match *r {\n-                    ty::ReFree(ty::FreeRegion {\n-                        bound_region: ty::BoundRegion::BrNamed(def_id, name, _), ..\n-                    }) => {\n-                        let bound_region = ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                            space: space,\n-                            index: i as u32,\n-                            name: name,\n-                        });\n-                        wbcx.free_to_bound_regions.insert(def_id, bound_region);\n-                    }\n-                    _ => {\n-                        bug!(\"{:?} is not a free region for an early-bound lifetime\", r);\n-                    }\n+        for (i, r) in free_substs.regions.iter().enumerate() {\n+            match *r {\n+                ty::ReFree(ty::FreeRegion {\n+                    bound_region: ty::BoundRegion::BrNamed(def_id, name, _), ..\n+                }) => {\n+                    let bound_region = ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                        index: i as u32,\n+                        name: name,\n+                    });\n+                    wbcx.free_to_bound_regions.insert(def_id, bound_region);\n+                }\n+                _ => {\n+                    bug!(\"{:?} is not a free region for an early-bound lifetime\", r);\n                 }\n             }\n         }\n@@ -300,11 +296,13 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_anon_types(&self) {\n+    fn visit_anon_types(&self, item_id: ast::NodeId) {\n         if self.fcx.writeback_errors.get() {\n             return\n         }\n \n+        let item_def_id = self.fcx.tcx.map.local_def_id(item_id);\n+\n         let gcx = self.tcx().global_tcx();\n         for (&def_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n             let reason = ResolvingAnonTy(def_id);\n@@ -345,9 +343,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             });\n \n-            gcx.tcache.borrow_mut().insert(def_id, ty::TypeScheme {\n+            gcx.register_item_type(def_id, ty::TypeScheme {\n                 ty: outside_ty,\n-                generics: ty::Generics::empty()\n+                generics: gcx.lookup_generics(item_def_id)\n             });\n         }\n     }"}, {"sha": "4a1e401f9820f7d40948c25feb761b4eaf6b4766", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -17,7 +17,7 @@\n \n use hir::def_id::DefId;\n use middle::lang_items::UnsizeTraitLangItem;\n-use rustc::ty::subst::{self, Subst};\n+use rustc::ty::subst::Subst;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::traits::{self, Reveal};\n use rustc::ty::{ImplOrTraitItemId, ConstTraitItemId};\n@@ -75,7 +75,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             }\n \n             TyTrait(ref t) => {\n-                Some(t.principal_def_id())\n+                Some(t.principal.def_id())\n             }\n \n             TyBox(_) => {\n@@ -386,7 +386,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n             let source = tcx.lookup_item_type(impl_did).ty;\n             let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n-            let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n+            let target = trait_ref.substs.types[1];\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n                    source, target);\n "}, {"sha": "97aed4d5e82f9f1fb583046d97ab01bf5ed38ceb", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -80,7 +80,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                         self.check_def_id(item, def.did);\n                     }\n                     ty::TyTrait(ref data) => {\n-                        self.check_def_id(item, data.principal_def_id());\n+                        self.check_def_id(item, data.principal.def_id());\n                     }\n                     ty::TyBox(..) => {\n                         match self.tcx.lang_items.require_owned_box() {"}, {"sha": "f60fb9583a66113a6ca8970350d358e18f30b965", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -168,14 +168,14 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                     // This is something like impl Trait1 for Trait2. Illegal\n                     // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n-                    if !self.tcx.is_object_safe(data.principal_def_id()) {\n+                    if !self.tcx.is_object_safe(data.principal.def_id()) {\n                         // This is an error, but it will be\n                         // reported by wfcheck.  Ignore it\n                         // here. This is tested by\n                         // `coherence-impl-trait-for-trait-object-safe.rs`.\n                     } else {\n                         let mut supertrait_def_ids =\n-                            traits::supertrait_def_ids(self.tcx, data.principal_def_id());\n+                            traits::supertrait_def_ids(self.tcx, data.principal.def_id());\n                         if supertrait_def_ids.any(|d| d == trait_def_id) {\n                             span_err!(self.tcx.sess, item.span, E0371,\n                                       \"the object type `{}` automatically \\"}, {"sha": "ed406b9379e353fecc9dc5ec006cc520e822ba69", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 435, "deletions": 520, "changes": 955, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -65,7 +65,7 @@ use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n-use rustc::ty::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n+use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n use rustc::ty::{VariantKind};\n@@ -85,7 +85,6 @@ use std::rc::Rc;\n \n use syntax::{abi, ast, attr};\n use syntax::parse::token::keywords;\n-use syntax::ptr::P;\n use syntax_pos::Span;\n \n use rustc::hir::{self, intravisit, map as hir_map, print as pprust};\n@@ -120,6 +119,7 @@ struct ItemCtxt<'a,'tcx:'a> {\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum AstConvRequest {\n+    GetGenerics(DefId),\n     GetItemTypeScheme(DefId),\n     GetTraitDef(DefId),\n     EnsureSuperPredicates(DefId),\n@@ -187,6 +187,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         err.span_label(span, &format!(\"cyclic reference\"));\n \n         match cycle[0] {\n+            AstConvRequest::GetGenerics(def_id) |\n             AstConvRequest::GetItemTypeScheme(def_id) |\n             AstConvRequest::GetTraitDef(def_id) => {\n                 err.note(\n@@ -209,6 +210,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n         for request in &cycle[1..] {\n             match *request {\n+                AstConvRequest::GetGenerics(def_id) |\n                 AstConvRequest::GetItemTypeScheme(def_id) |\n                 AstConvRequest::GetTraitDef(def_id) => {\n                     err.note(\n@@ -231,6 +233,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         }\n \n         match cycle[0] {\n+            AstConvRequest::GetGenerics(def_id) |\n             AstConvRequest::GetItemTypeScheme(def_id) |\n             AstConvRequest::GetTraitDef(def_id) => {\n                 err.note(\n@@ -303,6 +306,14 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         &self.ccx.ast_ty_to_ty_cache\n     }\n \n+    fn get_generics(&self, span: Span, id: DefId)\n+                    -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>\n+    {\n+        self.ccx.cycle_check(span, AstConvRequest::GetGenerics(id), || {\n+            Ok(generics_of_def_id(self.ccx, id))\n+        })\n+    }\n+\n     fn get_item_type_scheme(&self, span: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n     {\n@@ -362,11 +373,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         None\n     }\n \n-    fn ty_infer(&self,\n-                _ty_param_def: Option<ty::TypeParameterDef<'tcx>>,\n-                _substs: Option<&mut Substs<'tcx>>,\n-                _space: Option<ParamSpace>,\n-                span: Span) -> Ty<'tcx> {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         struct_span_err!(\n             self.tcx().sess,\n             span,\n@@ -452,35 +459,38 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for () {\n impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n     fn get_type_parameter_bounds(&self,\n                                  astconv: &AstConv<'tcx, 'tcx>,\n-                                 _span: Span,\n+                                 span: Span,\n                                  node_id: ast::NodeId)\n                                  -> Vec<ty::Predicate<'tcx>>\n     {\n         let def = astconv.tcx().type_parameter_def(node_id);\n \n-        self.predicates\n-            .iter()\n-            .filter(|predicate| {\n-                match **predicate {\n-                    ty::Predicate::Trait(ref data) => {\n-                        data.skip_binder().self_ty().is_param(def.space, def.index)\n-                    }\n-                    ty::Predicate::TypeOutlives(ref data) => {\n-                        data.skip_binder().0.is_param(def.space, def.index)\n-                    }\n-                    ty::Predicate::Rfc1592(..) |\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::RegionOutlives(..) |\n-                    ty::Predicate::WellFormed(..) |\n-                    ty::Predicate::ObjectSafe(..) |\n-                    ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::Projection(..) => {\n-                        false\n-                    }\n+        let mut results = self.parent.map_or(vec![], |def_id| {\n+            let parent = astconv.tcx().lookup_predicates(def_id);\n+            parent.get_type_parameter_bounds(astconv, span, node_id)\n+        });\n+\n+        results.extend(self.predicates.iter().filter(|predicate| {\n+            match **predicate {\n+                ty::Predicate::Trait(ref data) => {\n+                    data.skip_binder().self_ty().is_param(def.index)\n                 }\n-            })\n-            .cloned()\n-            .collect()\n+                ty::Predicate::TypeOutlives(ref data) => {\n+                    data.skip_binder().0.is_param(def.index)\n+                }\n+                ty::Predicate::Rfc1592(..) |\n+                ty::Predicate::Equate(..) |\n+                ty::Predicate::RegionOutlives(..) |\n+                ty::Predicate::WellFormed(..) |\n+                ty::Predicate::ObjectSafe(..) |\n+                ty::Predicate::ClosureKind(..) |\n+                ty::Predicate::Projection(..) => {\n+                    false\n+                }\n+            }\n+        }).cloned());\n+\n+        results\n     }\n }\n \n@@ -538,7 +548,7 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let path_res = tcx.expect_resolution(ast_ty.id);\n         match path_res.base_def {\n             Def::SelfTy(Some(def_id), None) |\n-            Def::TyParam(_, _, def_id, _) if path_res.depth == 0 => {\n+            Def::TyParam(def_id) if path_res.depth == 0 => {\n                 def_id == tcx.map.local_def_id(param_id)\n             }\n             _ => false\n@@ -548,7 +558,6 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-\n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: ImplOrTraitItemContainer,\n                             name: ast::Name,\n@@ -557,25 +566,22 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             sig: &hir::MethodSig,\n                             defaultness: hir::Defaultness,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n-                            rcvr_ty_generics: &ty::Generics<'tcx>,\n                             rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n-    let ty_generics = ty_generics_for_fn(ccx, &sig.generics, rcvr_ty_generics);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    let ty_generics = generics_of_def_id(ccx, def_id);\n \n     let ty_generic_predicates =\n-        ty_generic_predicates_for_fn(ccx, &sig.generics, rcvr_ty_predicates);\n+        ty_generic_predicates(ccx, &sig.generics, ty_generics.parent, vec![], false);\n \n     let (fty, explicit_self_category) = {\n         let anon_scope = match container {\n-            ImplContainer(_) => Some(AnonTypeScope::new(&ty_generics)),\n+            ImplContainer(_) => Some(AnonTypeScope::new(def_id)),\n             TraitContainer(_) => None\n         };\n         AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                               sig, untransformed_rcvr_ty, anon_scope)\n     };\n \n-    let def_id = ccx.tcx.map.local_def_id(id);\n-    let substs = mk_item_substs(ccx.tcx, &ty_generics);\n-\n     let ty_method = ty::Method::new(name,\n                                     ty_generics,\n                                     ty_generic_predicates,\n@@ -586,16 +592,14 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     def_id,\n                                     container);\n \n+    let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n+                                ccx.tcx.map.span(id), def_id);\n     let fty = ccx.tcx.mk_fn_def(def_id, substs, ty_method.fty);\n     debug!(\"method {} (id {}) has type {:?}\",\n             name, id, fty);\n-    ccx.tcx.register_item_type(def_id, TypeScheme {\n-        generics: ty_method.generics.clone(),\n-        ty: fty\n-    });\n-    ccx.tcx.predicates.borrow_mut().insert(def_id, ty_method.predicates.clone());\n-\n+    ccx.tcx.tcache.borrow_mut().insert(def_id, fty);\n     write_ty_to_tcx(ccx, id, fty);\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, ty_method.predicates.clone());\n \n     debug!(\"writing method type: def_id={:?} mty={:?}\",\n             def_id, ty_method);\n@@ -605,7 +609,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                           struct_generics: &ty::Generics<'tcx>,\n+                           struct_generics: &'tcx ty::Generics<'tcx>,\n                            struct_predicates: &ty::GenericPredicates<'tcx>,\n                            field: &hir::StructField,\n                            ty_f: ty::FieldDefMaster<'tcx>)\n@@ -617,7 +621,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     /* add the field to the tcache */\n     ccx.tcx.register_item_type(ccx.tcx.map.local_def_id(field.id),\n                                ty::TypeScheme {\n-                                   generics: struct_generics.clone(),\n+                                   generics: struct_generics,\n                                    ty: tt\n                                });\n     ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(field.id),\n@@ -633,8 +637,12 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                       ty: ty::Ty<'tcx>,\n                                       has_value: bool)\n {\n+    let predicates = ty::GenericPredicates {\n+        parent: Some(container.id()),\n+        predicates: vec![]\n+    };\n     ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(id),\n-                                           ty::GenericPredicates::empty());\n+                                           predicates);\n \n     write_ty_to_tcx(ccx, id, ty);\n \n@@ -713,8 +721,9 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n-            let (scheme, predicates) = convert_typed_item(ccx, it);\n-            write_ty_to_tcx(ccx, it.id, scheme.ty);\n+            let def_id = ccx.tcx.map.local_def_id(it.id);\n+            let scheme = type_scheme_of_def_id(ccx, def_id);\n+            let predicates = predicates_of_item(ccx, it);\n             convert_enum_variant_types(ccx,\n                                        tcx.lookup_adt_def_master(ccx.tcx.map.local_def_id(it.id)),\n                                        scheme,\n@@ -726,7 +735,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&()),\n                                                     &ExplicitRscope,\n                                                     ast_trait_ref,\n-                                                    None);\n+                                                    tcx.mk_self_type());\n \n             tcx.record_trait_has_default_impl(trait_ref.def_id);\n \n@@ -741,22 +750,23 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             // Create generics from the generics specified in the impl head.\n             debug!(\"convert: ast_generics={:?}\", generics);\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let ty_generics = ty_generics_for_impl(ccx, generics);\n-            let mut ty_predicates = ty_generic_predicates_for_type_or_impl(ccx, generics);\n+            let ty_generics = generics_of_def_id(ccx, def_id);\n+            let mut ty_predicates =\n+                ty_generic_predicates(ccx, generics, None, vec![], false);\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n             let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &selfty);\n             write_ty_to_tcx(ccx, it.id, selfty);\n \n             tcx.register_item_type(def_id,\n-                                   TypeScheme { generics: ty_generics.clone(),\n+                                   TypeScheme { generics: ty_generics,\n                                                 ty: selfty });\n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n                                                     &ExplicitRscope,\n                                                     ast_trait_ref,\n-                                                    Some(selfty))\n+                                                    selfty)\n             });\n             tcx.impl_trait_refs.borrow_mut().insert(def_id, trait_ref);\n \n@@ -791,11 +801,13 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 }\n \n                 if let hir::ImplItemKind::Const(ref ty, _) = impl_item.node {\n+                    let const_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n+                    let ty_generics = generics_of_def_id(ccx, const_def_id);\n                     let ty = ccx.icx(&ty_predicates)\n                                 .to_ty(&ExplicitRscope, &ty);\n-                    tcx.register_item_type(ccx.tcx.map.local_def_id(impl_item.id),\n+                    tcx.register_item_type(const_def_id,\n                                            TypeScheme {\n-                                               generics: ty_generics.clone(),\n+                                               generics: ty_generics,\n                                                ty: ty,\n                                            });\n                     // Trait-associated constants are always public.\n@@ -833,7 +845,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     convert_method(ccx, ImplContainer(def_id),\n                                    impl_item.name, impl_item.id, method_vis,\n-                                   sig, impl_item.defaultness, selfty, &ty_generics,\n+                                   sig, impl_item.defaultness, selfty,\n                                    &ty_predicates);\n                 }\n             }\n@@ -856,11 +868,13 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             // Convert all the associated constants.\n             for trait_item in trait_items {\n                 if let hir::ConstTraitItem(ref ty, ref default) = trait_item.node {\n+                    let const_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n+                    let ty_generics = generics_of_def_id(ccx, const_def_id);\n                     let ty = ccx.icx(&trait_predicates)\n                         .to_ty(&ExplicitRscope, ty);\n-                    tcx.register_item_type(ccx.tcx.map.local_def_id(trait_item.id),\n+                    tcx.register_item_type(const_def_id,\n                                            TypeScheme {\n-                                               generics: trait_def.generics.clone(),\n+                                               generics: ty_generics,\n                                                ty: ty,\n                                            });\n                     convert_associated_const(ccx,\n@@ -902,7 +916,6 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                    sig,\n                                    hir::Defaultness::Default,\n                                    tcx.mk_self_type(),\n-                                   &trait_def.generics,\n                                    &trait_predicates);\n \n                 }\n@@ -921,11 +934,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                        trait_item_def_ids);\n         },\n         hir::ItemStruct(ref struct_def, _) => {\n-            let (scheme, predicates) = convert_typed_item(ccx, it);\n-            write_ty_to_tcx(ccx, it.id, scheme.ty);\n+            let def_id = ccx.tcx.map.local_def_id(it.id);\n+            let scheme = type_scheme_of_def_id(ccx, def_id);\n+            let predicates = predicates_of_item(ccx, it);\n \n-            let it_def_id = ccx.tcx.map.local_def_id(it.id);\n-            let variant = tcx.lookup_adt_def_master(it_def_id).struct_variant();\n+            let variant = tcx.lookup_adt_def_master(def_id).struct_variant();\n \n             for (f, ty_f) in struct_def.fields().iter().zip(variant.fields.iter()) {\n                 convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n@@ -937,15 +950,14 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         },\n         hir::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n-            let (scheme, _) = convert_typed_item(ccx, it);\n-            write_ty_to_tcx(ccx, it.id, scheme.ty);\n+            let def_id = ccx.tcx.map.local_def_id(it.id);\n+            type_scheme_of_def_id(ccx, def_id);\n+            predicates_of_item(ccx, it);\n         },\n         _ => {\n-            // This call populates the type cache with the converted type\n-            // of the item in passing. All we have to do here is to write\n-            // it into the node type table.\n-            let (scheme, _) = convert_typed_item(ccx, it);\n-            write_ty_to_tcx(ccx, it.id, scheme.ty);\n+            let def_id = ccx.tcx.map.local_def_id(it.id);\n+            type_scheme_of_def_id(ccx, def_id);\n+            predicates_of_item(ccx, it);\n         },\n     }\n }\n@@ -956,6 +968,8 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   scheme: ty::TypeScheme<'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n     let tcx = ccx.tcx;\n+    let def_id = tcx.map.local_def_id(ctor_id);\n+    generics_of_def_id(ccx, def_id);\n     let ctor_ty = match variant.kind {\n         VariantKind::Unit | VariantKind::Struct => scheme.ty,\n         VariantKind::Tuple => {\n@@ -964,8 +978,8 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 .iter()\n                 .map(|field| field.unsubst_ty())\n                 .collect();\n-            let def_id = tcx.map.local_def_id(ctor_id);\n-            let substs = mk_item_substs(tcx, &scheme.generics);\n+            let substs = mk_item_substs(&ccx.icx(&predicates),\n+                                        ccx.tcx.map.span(ctor_id), def_id);\n             tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Abi::Rust,\n@@ -978,12 +992,8 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n     write_ty_to_tcx(ccx, ctor_id, ctor_ty);\n+    tcx.tcache.borrow_mut().insert(def_id, ctor_ty);\n     tcx.predicates.borrow_mut().insert(tcx.map.local_def_id(ctor_id), predicates);\n-    tcx.register_item_type(tcx.map.local_def_id(ctor_id),\n-                           TypeScheme {\n-                               generics: scheme.generics,\n-                               ty: ctor_ty\n-                           });\n }\n \n fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -1185,9 +1195,8 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         // generic types:\n         let trait_def = trait_def_of_item(ccx, item);\n         let self_predicate = ty::GenericPredicates {\n-            predicates: VecPerParamSpace::new(vec![],\n-                                              vec![trait_def.trait_ref.to_predicate()],\n-                                              vec![])\n+            parent: None,\n+            predicates: vec![trait_def.trait_ref.to_predicate()]\n         };\n         let scope = &(generics, &self_predicate);\n \n@@ -1209,7 +1218,8 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         // Combine the two lists to form the complete set of superbounds:\n         let superbounds = superbounds1.into_iter().chain(superbounds2).collect();\n         let superpredicates = ty::GenericPredicates {\n-            predicates: VecPerParamSpace::new(superbounds, vec![], vec![])\n+            parent: None,\n+            predicates: superbounds\n         };\n         debug!(\"superpredicates for trait {:?} = {:?}\",\n                tcx.map.local_def_id(item.id),\n@@ -1243,7 +1253,9 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n \n     let (unsafety, generics, items) = match it.node {\n-        hir::ItemTrait(unsafety, ref generics, _, ref items) => (unsafety, generics, items),\n+        hir::ItemTrait(unsafety, ref generics, _, ref items) => {\n+            (unsafety, generics, items)\n+        }\n         _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n@@ -1259,9 +1271,8 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         err.emit();\n     }\n \n-    let substs = ccx.tcx.mk_substs(mk_trait_substs(ccx, generics));\n-\n-    let ty_generics = ty_generics_for_trait(ccx, it.id, substs, generics);\n+    let ty_generics = generics_of_def_id(ccx, def_id);\n+    let substs = mk_item_substs(&ccx.icx(generics), it.span, def_id);\n \n     let associated_type_names: Vec<_> = items.iter().filter_map(|trait_item| {\n         match trait_item.node {\n@@ -1270,51 +1281,14 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }).collect();\n \n-    let trait_ref = ty::TraitRef {\n-        def_id: def_id,\n-        substs: substs,\n-    };\n-\n+    let trait_ref = ty::TraitRef::new(def_id, substs);\n     let trait_def = ty::TraitDef::new(unsafety,\n                                       paren_sugar,\n                                       ty_generics,\n                                       trait_ref,\n                                       associated_type_names);\n \n-    return tcx.intern_trait_def(trait_def);\n-\n-    fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                 generics: &hir::Generics)\n-                                 -> Substs<'tcx>\n-    {\n-        let tcx = ccx.tcx;\n-\n-        // Creates a no-op substitution for the trait's type parameters.\n-        let regions =\n-            generics.lifetimes\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, def)| ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        space: TypeSpace,\n-                        index: i as u32,\n-                        name: def.lifetime.name\n-                    }))\n-                    .collect();\n-\n-        // Start with the generics in the type parameters...\n-        let types: Vec<_> =\n-            generics.ty_params\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, def)| tcx.mk_param(TypeSpace,\n-                                                 i as u32, def.name))\n-                    .collect();\n-\n-        // ...and also create the `Self` parameter.\n-        let self_ty = tcx.mk_self_type();\n-\n-        Substs::new_trait(types, regions, self_ty)\n-    }\n+    tcx.intern_trait_def(trait_def)\n }\n \n fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n@@ -1363,23 +1337,23 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n     // but to get the full set of predicates on a trait we need to add\n     // in the supertrait bounds and anything declared on the\n     // associated types.\n-    let mut base_predicates = super_predicates;\n+    let mut base_predicates = super_predicates.predicates;\n \n     // Add in a predicate that `Self:Trait` (where `Trait` is the\n     // current trait).  This is needed for builtin bounds.\n     let self_predicate = trait_def.trait_ref.to_poly_trait_ref().to_predicate();\n-    base_predicates.predicates.push(SelfSpace, self_predicate);\n+    base_predicates.push(self_predicate);\n \n     // add in the explicit where-clauses\n     let mut trait_predicates =\n-        ty_generic_predicates(ccx, TypeSpace, generics, &base_predicates);\n+        ty_generic_predicates(ccx, generics, None, base_predicates, true);\n \n     let assoc_predicates = predicates_for_associated_types(ccx,\n                                                            generics,\n                                                            &trait_predicates,\n                                                            trait_def.trait_ref,\n                                                            items);\n-    trait_predicates.predicates.extend(TypeSpace, assoc_predicates.into_iter());\n+    trait_predicates.predicates.extend(assoc_predicates);\n \n     let prev_predicates = tcx.predicates.borrow_mut().insert(def_id, trait_predicates);\n     assert!(prev_predicates.is_none());\n@@ -1416,192 +1390,262 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n     }\n }\n \n-fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                  def_id: DefId)\n-                                  -> ty::TypeScheme<'tcx>\n-{\n-    if let Some(node_id) = ccx.tcx.map.as_local_node_id(def_id) {\n-        match ccx.tcx.map.find(node_id) {\n-            Some(hir_map::NodeItem(item)) => {\n-                type_scheme_of_item(ccx, &item)\n+fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                def_id: DefId)\n+                                -> &'tcx ty::Generics<'tcx> {\n+    let tcx = ccx.tcx;\n+    let node_id = if let Some(id) = tcx.map.as_local_node_id(def_id) {\n+        id\n+    } else {\n+        return tcx.lookup_generics(def_id);\n+    };\n+    tcx.generics.memoize(def_id, || {\n+        use rustc::hir::map::*;\n+        use rustc::hir::*;\n+\n+        let node = tcx.map.get(node_id);\n+        let parent_def_id = match node {\n+            NodeImplItem(_) |\n+            NodeTraitItem(_) |\n+            NodeVariant(_) |\n+            NodeStructCtor(_) => {\n+                let parent_id = tcx.map.get_parent(node_id);\n+                Some(tcx.map.local_def_id(parent_id))\n             }\n-            Some(hir_map::NodeForeignItem(foreign_item)) => {\n-                let abi = ccx.tcx.map.get_foreign_abi(node_id);\n-                type_scheme_of_foreign_item(ccx, &foreign_item, abi)\n+            _ => None\n+        };\n+\n+        let mut opt_self = None;\n+        let mut allow_defaults = false;\n+\n+        let no_generics = hir::Generics::empty();\n+        let ast_generics = match node {\n+            NodeTraitItem(item) => {\n+                match item.node {\n+                    MethodTraitItem(ref sig, _) => &sig.generics,\n+                    _ => &no_generics\n+                }\n             }\n-            x => {\n-                bug!(\"unexpected sort of node in get_item_type_scheme(): {:?}\",\n-                     x);\n+\n+            NodeImplItem(item) => {\n+                match item.node {\n+                    ImplItemKind::Method(ref sig, _) => &sig.generics,\n+                    _ => &no_generics\n+                }\n             }\n+\n+            NodeItem(item) => {\n+                match item.node {\n+                    ItemFn(_, _, _, _, ref generics, _) |\n+                    ItemImpl(_, _, ref generics, _, _, _) => generics,\n+\n+                    ItemTy(_, ref generics) |\n+                    ItemEnum(_, ref generics) |\n+                    ItemStruct(_, ref generics) => {\n+                        allow_defaults = true;\n+                        generics\n+                    }\n+\n+                    ItemTrait(_, ref generics, _, _) => {\n+                        // Add in the self type parameter.\n+                        //\n+                        // Something of a hack: use the node id for the trait, also as\n+                        // the node id for the Self type parameter.\n+                        let param_id = item.id;\n+\n+                        let parent = ccx.tcx.map.get_parent(param_id);\n+\n+                        let def = ty::TypeParameterDef {\n+                            index: 0,\n+                            name: keywords::SelfType.name(),\n+                            def_id: tcx.map.local_def_id(param_id),\n+                            default_def_id: tcx.map.local_def_id(parent),\n+                            default: None,\n+                            object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n+                        };\n+                        tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n+                        opt_self = Some(def);\n+\n+                        allow_defaults = true;\n+                        generics\n+                    }\n+\n+                    _ => &no_generics\n+                }\n+            }\n+\n+            NodeForeignItem(item) => {\n+                match item.node {\n+                    ForeignItemStatic(..) => &no_generics,\n+                    ForeignItemFn(_, ref generics) => generics\n+                }\n+            }\n+\n+            _ => &no_generics\n+        };\n+\n+        let has_self = opt_self.is_some();\n+        let mut parent_has_self = false;\n+        let (parent_regions, parent_types) = parent_def_id.map_or((0, 0), |def_id| {\n+            let generics = generics_of_def_id(ccx, def_id);\n+            assert_eq!(generics.parent, None);\n+            assert_eq!(generics.parent_regions, 0);\n+            assert_eq!(generics.parent_types, 0);\n+            assert_eq!(has_self, false);\n+            parent_has_self = generics.has_self;\n+            (generics.regions.len() as u32, generics.types.len() as u32)\n+        });\n+\n+        let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n+        let regions = early_lifetimes.iter().enumerate().map(|(i, l)| {\n+            ty::RegionParameterDef {\n+                name: l.lifetime.name,\n+                index: parent_regions + i as u32,\n+                def_id: tcx.map.local_def_id(l.lifetime.id),\n+                bounds: l.bounds.iter().map(|l| {\n+                    ast_region_to_region(tcx, l)\n+                }).collect()\n+            }\n+        }).collect();\n+\n+        // Now create the real type parameters.\n+        let types = ast_generics.ty_params.iter().enumerate().map(|(i, p)| {\n+            let i = parent_types + has_self as u32 + i as u32;\n+            get_or_create_type_parameter_def(ccx, ast_generics, i, p, allow_defaults)\n+        });\n+        let types: Vec<_> = opt_self.into_iter().chain(types).collect();\n+\n+        // Debugging aid.\n+        if tcx.has_attr(def_id, \"rustc_object_lifetime_default\") {\n+            let object_lifetime_default_reprs: String =\n+                types.iter().map(|t| {\n+                    match t.object_lifetime_default {\n+                        ty::ObjectLifetimeDefault::Specific(r) => r.to_string(),\n+                        d => format!(\"{:?}\", d),\n+                    }\n+                }).collect::<Vec<String>>().join(\",\");\n+            tcx.sess.span_err(tcx.map.span(node_id), &object_lifetime_default_reprs);\n         }\n-    } else {\n-        ccx.tcx.lookup_item_type(def_id)\n-    }\n+\n+        tcx.alloc_generics(ty::Generics {\n+            parent: parent_def_id,\n+            parent_regions: parent_regions as u32,\n+            parent_types: parent_types as u32,\n+            regions: regions,\n+            types: types,\n+            has_self: has_self || parent_has_self\n+        })\n+    })\n }\n \n-fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                item: &hir::Item)\n-                                -> ty::TypeScheme<'tcx>\n-{\n-    let item_def_id = ccx.tcx.map.local_def_id(item.id);\n-    ccx.tcx.tcache.memoize(item_def_id, || {\n-        // NB. Since the `memoized` function enters a new task, and we\n-        // are giving this task access to the item `item`, we must\n-        // register a read.\n-        assert!(!ccx.tcx.map.is_inlined_def_id(item_def_id));\n-        ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n-        compute_type_scheme_of_item(ccx, item)\n+fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                            def_id: DefId)\n+                            -> Ty<'tcx> {\n+    let node_id = if let Some(id) = ccx.tcx.map.as_local_node_id(def_id) {\n+        id\n+    } else {\n+        return ccx.tcx.lookup_item_type(def_id).ty;\n+    };\n+    ccx.tcx.tcache.memoize(def_id, || {\n+        use rustc::hir::map::*;\n+        use rustc::hir::*;\n+\n+        let ty = match ccx.tcx.map.get(node_id) {\n+            NodeItem(item) => {\n+                match item.node {\n+                    ItemStatic(ref t, _, _) | ItemConst(ref t, _) => {\n+                        ccx.icx(&()).to_ty(&ExplicitRscope, &t)\n+                    }\n+                    ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n+                        let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl,\n+                                                          Some(AnonTypeScope::new(def_id)));\n+                        let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n+                        ccx.tcx.mk_fn_def(def_id, substs, tofd)\n+                    }\n+                    ItemTy(ref t, ref generics) => {\n+                        ccx.icx(generics).to_ty(&ExplicitRscope, &t)\n+                    }\n+                    ItemEnum(ref ei, ref generics) => {\n+                        let def = convert_enum_def(ccx, item, ei);\n+                        let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n+                        ccx.tcx.mk_enum(def, substs)\n+                    }\n+                    ItemStruct(ref si, ref generics) => {\n+                        let def = convert_struct_def(ccx, item, si);\n+                        let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n+                        ccx.tcx.mk_struct(def, substs)\n+                    }\n+                    ItemDefaultImpl(..) |\n+                    ItemTrait(..) |\n+                    ItemImpl(..) |\n+                    ItemMod(..) |\n+                    ItemForeignMod(..) |\n+                    ItemExternCrate(..) |\n+                    ItemUse(..) => {\n+                        span_bug!(\n+                            item.span,\n+                            \"compute_type_of_item: unexpected item type: {:?}\",\n+                            item.node);\n+                    }\n+                }\n+            }\n+            NodeForeignItem(foreign_item) => {\n+                let abi = ccx.tcx.map.get_foreign_abi(node_id);\n+\n+                match foreign_item.node {\n+                    ForeignItemFn(ref fn_decl, ref generics) => {\n+                        compute_type_of_foreign_fn_decl(\n+                            ccx, ccx.tcx.map.local_def_id(foreign_item.id),\n+                            fn_decl, generics, abi)\n+                    }\n+                    ForeignItemStatic(ref t, _) => {\n+                        ccx.icx(&()).to_ty(&ExplicitRscope, t)\n+                    }\n+                }\n+            }\n+            x => {\n+                bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n+            }\n+        };\n+\n+        write_ty_to_tcx(ccx, node_id, ty);\n+        ty\n     })\n }\n \n-fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                        it: &hir::Item)\n-                                        -> ty::TypeScheme<'tcx>\n-{\n-    let tcx = ccx.tcx;\n-    match it.node {\n-        hir::ItemStatic(ref t, _, _) | hir::ItemConst(ref t, _) => {\n-            let ty = ccx.icx(&()).to_ty(&ExplicitRscope, &t);\n-            ty::TypeScheme { ty: ty, generics: ty::Generics::empty() }\n-        }\n-        hir::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n-            let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n-            let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl,\n-                                              Some(AnonTypeScope::new(&ty_generics)));\n-            let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let substs = mk_item_substs(tcx, &ty_generics);\n-            let ty = tcx.mk_fn_def(def_id, substs, tofd);\n-            ty::TypeScheme { ty: ty, generics: ty_generics }\n-        }\n-        hir::ItemTy(ref t, ref generics) => {\n-            let ty_generics = ty_generics_for_type(ccx, generics);\n-            let ty = ccx.icx(generics).to_ty(&ExplicitRscope, &t);\n-            ty::TypeScheme { ty: ty, generics: ty_generics }\n-        }\n-        hir::ItemEnum(ref ei, ref generics) => {\n-            let def = convert_enum_def(ccx, it, ei);\n-            let ty_generics = ty_generics_for_type(ccx, generics);\n-            let substs = mk_item_substs(tcx, &ty_generics);\n-            let t = tcx.mk_enum(def, substs);\n-            ty::TypeScheme { ty: t, generics: ty_generics }\n-        }\n-        hir::ItemStruct(ref si, ref generics) => {\n-            let def = convert_struct_def(ccx, it, si);\n-            let ty_generics = ty_generics_for_type(ccx, generics);\n-            let substs = mk_item_substs(tcx, &ty_generics);\n-            let t = tcx.mk_struct(def, substs);\n-            ty::TypeScheme { ty: t, generics: ty_generics }\n-        }\n-        hir::ItemDefaultImpl(..) |\n-        hir::ItemTrait(..) |\n-        hir::ItemImpl(..) |\n-        hir::ItemMod(..) |\n-        hir::ItemForeignMod(..) |\n-        hir::ItemExternCrate(..) |\n-        hir::ItemUse(..) => {\n-            span_bug!(\n-                it.span,\n-                \"compute_type_scheme_of_item: unexpected item type: {:?}\",\n-                it.node);\n+fn type_scheme_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                   def_id: DefId)\n+                                   -> ty::TypeScheme<'tcx> {\n+    if def_id.is_local() {\n+        ty::TypeScheme {\n+            generics: generics_of_def_id(ccx, def_id),\n+            ty: type_of_def_id(ccx, def_id)\n         }\n+    } else {\n+        ccx.tcx.lookup_item_type(def_id)\n     }\n }\n \n-fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn predicates_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 it: &hir::Item)\n-                                -> (ty::TypeScheme<'tcx>, ty::GenericPredicates<'tcx>)\n-{\n-    let tcx = ccx.tcx;\n+                                -> ty::GenericPredicates<'tcx> {\n+    let def_id = ccx.tcx.map.local_def_id(it.id);\n \n-    let tag = type_scheme_of_item(ccx, it);\n-    let scheme = TypeScheme { generics: tag.generics, ty: tag.ty };\n-    let predicates = match it.node {\n-        hir::ItemStatic(..) | hir::ItemConst(..) => {\n-            ty::GenericPredicates::empty()\n-        }\n-        hir::ItemFn(_, _, _, _, ref ast_generics, _) => {\n-            ty_generic_predicates_for_fn(ccx, ast_generics, &ty::GenericPredicates::empty())\n-        }\n-        hir::ItemTy(_, ref generics) => {\n-            ty_generic_predicates_for_type_or_impl(ccx, generics)\n-        }\n-        hir::ItemEnum(_, ref generics) => {\n-            ty_generic_predicates_for_type_or_impl(ccx, generics)\n-        }\n-        hir::ItemStruct(_, ref generics) => {\n-            ty_generic_predicates_for_type_or_impl(ccx, generics)\n-        }\n-        hir::ItemDefaultImpl(..) |\n-        hir::ItemTrait(..) |\n-        hir::ItemExternCrate(..) |\n-        hir::ItemUse(..) |\n-        hir::ItemImpl(..) |\n-        hir::ItemMod(..) |\n-        hir::ItemForeignMod(..) => {\n-            span_bug!(\n-                it.span,\n-                \"compute_type_scheme_of_item: unexpected item type: {:?}\",\n-                it.node);\n-        }\n+    let no_generics = hir::Generics::empty();\n+    let generics = match it.node {\n+        hir::ItemFn(_, _, _, _, ref generics, _) |\n+        hir::ItemTy(_, ref generics) |\n+        hir::ItemEnum(_, ref generics) |\n+        hir::ItemStruct(_, ref generics) => generics,\n+        _ => &no_generics\n     };\n \n-    let prev_predicates = tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n-                                                             predicates.clone());\n+    let predicates = ty_generic_predicates(ccx, generics, None, vec![], false);\n+    let prev_predicates = ccx.tcx.predicates.borrow_mut().insert(def_id,\n+                                                                 predicates.clone());\n     assert!(prev_predicates.is_none());\n \n-    // Debugging aid.\n-    if tcx.has_attr(ccx.tcx.map.local_def_id(it.id), \"rustc_object_lifetime_default\") {\n-        let object_lifetime_default_reprs: String =\n-            scheme.generics.types.iter()\n-                                 .map(|t| match t.object_lifetime_default {\n-                                     ty::ObjectLifetimeDefault::Specific(r) => r.to_string(),\n-                                     d => format!(\"{:?}\", d),\n-                                 })\n-                                 .collect::<Vec<String>>()\n-                                 .join(\",\");\n-\n-        tcx.sess.span_err(it.span, &object_lifetime_default_reprs);\n-    }\n-\n-    return (scheme, predicates);\n-}\n-\n-fn type_scheme_of_foreign_item<'a, 'tcx>(\n-    ccx: &CrateCtxt<'a, 'tcx>,\n-    item: &hir::ForeignItem,\n-    abi: abi::Abi)\n-    -> ty::TypeScheme<'tcx>\n-{\n-    let item_def_id = ccx.tcx.map.local_def_id(item.id);\n-    ccx.tcx.tcache.memoize(item_def_id, || {\n-        // NB. Since the `memoized` function enters a new task, and we\n-        // are giving this task access to the item `item`, we must\n-        // register a read.\n-        assert!(!ccx.tcx.map.is_inlined_def_id(item_def_id));\n-        ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n-        compute_type_scheme_of_foreign_item(ccx, item, abi)\n-    })\n-}\n-\n-fn compute_type_scheme_of_foreign_item<'a, 'tcx>(\n-    ccx: &CrateCtxt<'a, 'tcx>,\n-    it: &hir::ForeignItem,\n-    abi: abi::Abi)\n-    -> ty::TypeScheme<'tcx>\n-{\n-    match it.node {\n-        hir::ForeignItemFn(ref fn_decl, ref generics) => {\n-            compute_type_scheme_of_foreign_fn_decl(\n-                ccx, ccx.tcx.map.local_def_id(it.id),\n-                fn_decl, generics, abi)\n-        }\n-        hir::ForeignItemStatic(ref t, _) => {\n-            ty::TypeScheme {\n-                generics: ty::Generics::empty(),\n-                ty: AstConv::ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, t)\n-            }\n-        }\n-    }\n+    predicates\n }\n \n fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -1611,95 +1655,20 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // map, and I regard each time that I use it as a personal and\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n-    let tcx = ccx.tcx;\n-    let abi = tcx.map.get_foreign_abi(it.id);\n-\n-    let scheme = type_scheme_of_foreign_item(ccx, it, abi);\n-    write_ty_to_tcx(ccx, it.id, scheme.ty);\n+    let def_id = ccx.tcx.map.local_def_id(it.id);\n+    type_scheme_of_def_id(ccx, def_id);\n \n-    let predicates = match it.node {\n-        hir::ForeignItemFn(_, ref generics) => {\n-            ty_generic_predicates_for_fn(ccx, generics, &ty::GenericPredicates::empty())\n-        }\n-        hir::ForeignItemStatic(..) => {\n-            ty::GenericPredicates::empty()\n-        }\n+    let no_generics = hir::Generics::empty();\n+    let generics = match it.node {\n+        hir::ForeignItemFn(_, ref generics) => generics,\n+        hir::ForeignItemStatic(..) => &no_generics\n     };\n \n-    let prev_predicates = tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n-                                                             predicates);\n+    let predicates = ty_generic_predicates(ccx, generics, None, vec![], false);\n+    let prev_predicates = ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n     assert!(prev_predicates.is_none());\n }\n \n-fn ty_generics_for_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, generics: &hir::Generics)\n-                                  -> ty::Generics<'tcx> {\n-    ty_generics(ccx, TypeSpace, generics, &ty::Generics::empty(), true)\n-}\n-\n-fn ty_generics_for_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, generics: &hir::Generics)\n-                                  -> ty::Generics<'tcx> {\n-    ty_generics(ccx, TypeSpace, generics, &ty::Generics::empty(), false)\n-}\n-\n-fn ty_generic_predicates_for_type_or_impl<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                                   generics: &hir::Generics)\n-                                                   -> ty::GenericPredicates<'tcx>\n-{\n-    ty_generic_predicates(ccx, TypeSpace, generics, &ty::GenericPredicates::empty())\n-}\n-\n-fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                   trait_id: ast::NodeId,\n-                                   substs: &'tcx Substs<'tcx>,\n-                                   ast_generics: &hir::Generics)\n-                                   -> ty::Generics<'tcx>\n-{\n-    debug!(\"ty_generics_for_trait(trait_id={:?}, substs={:?})\",\n-           ccx.tcx.map.local_def_id(trait_id), substs);\n-\n-    let mut generics = ty_generics_for_type(ccx, ast_generics);\n-\n-    // Add in the self type parameter.\n-    //\n-    // Something of a hack: use the node id for the trait, also as\n-    // the node id for the Self type parameter.\n-    let param_id = trait_id;\n-\n-    let parent = ccx.tcx.map.get_parent(param_id);\n-\n-    let def = ty::TypeParameterDef {\n-        space: SelfSpace,\n-        index: 0,\n-        name: keywords::SelfType.name(),\n-        def_id: ccx.tcx.map.local_def_id(param_id),\n-        default_def_id: ccx.tcx.map.local_def_id(parent),\n-        default: None,\n-        object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n-    };\n-\n-    ccx.tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n-\n-    generics.types.push(SelfSpace, def);\n-\n-    return generics;\n-}\n-\n-fn ty_generics_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                               generics: &hir::Generics,\n-                               base_generics: &ty::Generics<'tcx>)\n-                               -> ty::Generics<'tcx>\n-{\n-    ty_generics(ccx, FnSpace, generics, base_generics, false)\n-}\n-\n-fn ty_generic_predicates_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                         generics: &hir::Generics,\n-                                         base_predicates: &ty::GenericPredicates<'tcx>)\n-                                         -> ty::GenericPredicates<'tcx>\n-{\n-    ty_generic_predicates(ccx, FnSpace, generics, base_predicates)\n-}\n-\n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                        bounds: &mut ty::BuiltinBounds,\n@@ -1765,45 +1734,63 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx, 'hir>(\n }\n \n fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                  space: ParamSpace,\n                                   ast_generics: &hir::Generics,\n-                                  base_predicates: &ty::GenericPredicates<'tcx>)\n+                                  parent: Option<DefId>,\n+                                  super_predicates: Vec<ty::Predicate<'tcx>>,\n+                                  has_self: bool)\n                                   -> ty::GenericPredicates<'tcx>\n {\n     let tcx = ccx.tcx;\n-    let mut result = base_predicates.clone();\n+    let (parent_regions, parent_types) = parent.map_or((0, 0), |def_id| {\n+        let generics = generics_of_def_id(ccx, def_id);\n+        assert_eq!(generics.parent, None);\n+        assert_eq!(generics.parent_regions, 0);\n+        assert_eq!(generics.parent_types, 0);\n+        (generics.regions.len() as u32, generics.types.len() as u32)\n+    });\n+    let ref base_predicates = match parent {\n+        Some(def_id) => {\n+            assert_eq!(super_predicates, vec![]);\n+            tcx.lookup_predicates(def_id)\n+        }\n+        None => {\n+            ty::GenericPredicates {\n+                parent: None,\n+                predicates: super_predicates.clone()\n+            }\n+        }\n+    };\n+    let mut predicates = super_predicates;\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n     for (index, param) in ast_generics.ty_params.iter().enumerate() {\n-        let index = index as u32;\n-        let param_ty = ty::ParamTy::new(space, index, param.name).to_ty(ccx.tcx);\n+        let index = parent_types + has_self as u32 + index as u32;\n+        let param_ty = ty::ParamTy::new(index, param.name).to_ty(ccx.tcx);\n         let bounds = compute_bounds(&ccx.icx(&(base_predicates, ast_generics)),\n                                     param_ty,\n                                     &param.bounds,\n                                     SizedByDefault::Yes,\n                                     None,\n                                     param.span);\n-        let predicates = bounds.predicates(ccx.tcx, param_ty);\n-        result.predicates.extend(space, predicates.into_iter());\n+        predicates.extend(bounds.predicates(ccx.tcx, param_ty));\n     }\n \n     // Collect the region predicates that were declared inline as\n     // well. In the case of parameters declared on a fn or method, we\n     // have to be careful to only iterate over early-bound regions.\n     let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n     for (index, param) in early_lifetimes.iter().enumerate() {\n-        let index = index as u32;\n+        let index = parent_regions + index as u32;\n         let region =\n             ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                space: space,\n                 index: index,\n                 name: param.lifetime.name\n             });\n         for bound in &param.bounds {\n             let bound_region = ast_region_to_region(ccx.tcx, bound);\n             let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n-            result.predicates.push(space, outlives.to_predicate());\n+            predicates.push(outlives.to_predicate());\n         }\n     }\n \n@@ -1822,22 +1809,24 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                             let mut projections = Vec::new();\n \n                             let trait_ref =\n-                                conv_poly_trait_ref(&ccx.icx(&(base_predicates, ast_generics)),\n-                                                    ty,\n-                                                    poly_trait_ref,\n-                                                    &mut projections);\n+                                AstConv::instantiate_poly_trait_ref(&ccx.icx(&(base_predicates,\n+                                                                               ast_generics)),\n+                                                                    &ExplicitRscope,\n+                                                                    poly_trait_ref,\n+                                                                    ty,\n+                                                                    &mut projections);\n \n-                            result.predicates.push(space, trait_ref.to_predicate());\n+                            predicates.push(trait_ref.to_predicate());\n \n                             for projection in &projections {\n-                                result.predicates.push(space, projection.to_predicate());\n+                                predicates.push(projection.to_predicate());\n                             }\n                         }\n \n                         &hir::TyParamBound::RegionTyParamBound(ref lifetime) => {\n                             let region = ast_region_to_region(tcx, lifetime);\n                             let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n-                            result.predicates.push(space, ty::Predicate::TypeOutlives(pred))\n+                            predicates.push(ty::Predicate::TypeOutlives(pred))\n                         }\n                     }\n                 }\n@@ -1848,7 +1837,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 for bound in &region_pred.bounds {\n                     let r2 = ast_region_to_region(tcx, bound);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n-                    result.predicates.push(space, ty::Predicate::RegionOutlives(pred))\n+                    predicates.push(ty::Predicate::RegionOutlives(pred))\n                 }\n             }\n \n@@ -1861,89 +1850,27 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n     }\n \n-    return result;\n-}\n-\n-fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                        space: ParamSpace,\n-                        ast_generics: &hir::Generics,\n-                        base_generics: &ty::Generics<'tcx>,\n-                        allow_defaults: bool)\n-                        -> ty::Generics<'tcx>\n-{\n-    let tcx = ccx.tcx;\n-    let mut result = base_generics.clone();\n-\n-    let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n-    for (i, l) in early_lifetimes.iter().enumerate() {\n-        let bounds = l.bounds.iter()\n-                             .map(|l| ast_region_to_region(tcx, l))\n-                             .collect();\n-        let def = ty::RegionParameterDef { name: l.lifetime.name,\n-                                           space: space,\n-                                           index: i as u32,\n-                                           def_id: ccx.tcx.map.local_def_id(l.lifetime.id),\n-                                           bounds: bounds };\n-        result.regions.push(space, def);\n+    ty::GenericPredicates {\n+        parent: parent,\n+        predicates: predicates\n     }\n-\n-    assert!(result.types.is_empty_in(space));\n-\n-    // Now create the real type parameters.\n-    for i in 0..ast_generics.ty_params.len() {\n-        let def =\n-            get_or_create_type_parameter_def(ccx, ast_generics, space, i as u32, allow_defaults);\n-        debug!(\"ty_generics: def for type param: {:?}, {:?}\", def, space);\n-        result.types.push(space, def);\n-    }\n-\n-    result\n-}\n-\n-fn convert_default_type_parameter<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                            path: &P<hir::Ty>,\n-                                            space: ParamSpace,\n-                                            index: u32)\n-                                            -> Ty<'tcx>\n-{\n-    let ty = AstConv::ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, &path);\n-\n-    for leaf_ty in ty.walk() {\n-        if let ty::TyParam(p) = leaf_ty.sty {\n-            if p.space == space && p.idx >= index {\n-                struct_span_err!(ccx.tcx.sess, path.span, E0128,\n-                                 \"type parameters with a default cannot use \\\n-                                 forward declared identifiers\")\n-                    .span_label(path.span, &format!(\"defaulted type parameters \\\n-                                                    cannot be forward declared\"))\n-                    .emit();\n-\n-                return ccx.tcx.types.err\n-            }\n-        }\n-    }\n-\n-    ty\n }\n \n fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                              ast_generics: &hir::Generics,\n-                                             space: ParamSpace,\n                                              index: u32,\n+                                             param: &hir::TyParam,\n                                              allow_defaults: bool)\n                                              -> ty::TypeParameterDef<'tcx>\n {\n-    let param = &ast_generics.ty_params[index as usize];\n-\n     let tcx = ccx.tcx;\n     match tcx.ty_param_defs.borrow().get(&param.id) {\n         Some(d) => { return d.clone(); }\n         None => { }\n     }\n \n-    let default = param.default.as_ref().map(\n-        |def| convert_default_type_parameter(ccx, def, space, index)\n-    );\n+    let default =\n+        param.default.as_ref().map(|def| ccx.icx(&()).to_ty(&ExplicitRscope, def));\n \n     let object_lifetime_default =\n         compute_object_lifetime_default(ccx, param.id,\n@@ -1963,7 +1890,6 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n \n     let def = ty::TypeParameterDef {\n-        space: space,\n         index: index,\n         name: param.name,\n         def_id: ccx.tcx.map.local_def_id(param.id),\n@@ -1972,8 +1898,14 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         object_lifetime_default: object_lifetime_default,\n     };\n \n+    if def.name == keywords::SelfType.name() {\n+        span_bug!(param.span, \"`Self` should not be the name of a regular parameter\");\n+    }\n+\n     tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n \n+    debug!(\"get_or_create_type_parameter_def: def for type param: {:?}\", def);\n+\n     def\n }\n \n@@ -2076,7 +2008,7 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n     let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n         astconv.instantiate_poly_trait_ref(&rscope,\n                                            bound,\n-                                           Some(param_ty),\n+                                           param_ty,\n                                            &mut projection_bounds)\n     }).collect();\n \n@@ -2107,7 +2039,10 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     match *bound {\n         hir::TraitTyParamBound(ref tr, hir::TraitBoundModifier::None) => {\n             let mut projections = Vec::new();\n-            let pred = conv_poly_trait_ref(astconv, param_ty, tr, &mut projections);\n+            let pred = astconv.instantiate_poly_trait_ref(&ExplicitRscope,\n+                                                          tr,\n+                                                          param_ty,\n+                                                          &mut projections);\n             projections.into_iter()\n                        .map(|p| p.to_predicate())\n                        .chain(Some(pred.to_predicate()))\n@@ -2124,29 +2059,14 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     }\n }\n \n-fn conv_poly_trait_ref<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n-                                         param_ty: Ty<'tcx>,\n-                                         trait_ref: &hir::PolyTraitRef,\n-                                         projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                                         -> ty::PolyTraitRef<'tcx>\n-{\n-    AstConv::instantiate_poly_trait_ref(astconv,\n-                                        &ExplicitRscope,\n-                                        trait_ref,\n-                                        Some(param_ty),\n-                                        projections)\n-}\n-\n-fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n+fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n     ccx: &CrateCtxt<'a, 'tcx>,\n-    id: DefId,\n+    def_id: DefId,\n     decl: &hir::FnDecl,\n     ast_generics: &hir::Generics,\n     abi: abi::Abi)\n-    -> ty::TypeScheme<'tcx>\n+    -> Ty<'tcx>\n {\n-    let ty_generics = ty_generics_for_fn(ccx, ast_generics, &ty::Generics::empty());\n-\n     let rb = BindingRscope::new();\n     let input_tys = decl.inputs\n                         .iter()\n@@ -2182,48 +2102,43 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let substs = mk_item_substs(ccx.tcx, &ty_generics);\n-    let t_fn = ccx.tcx.mk_fn_def(id, substs, ccx.tcx.mk_bare_fn(ty::BareFnTy {\n+    let id = ccx.tcx.map.as_local_node_id(def_id).unwrap();\n+    let substs = mk_item_substs(&ccx.icx(ast_generics), ccx.tcx.map.span(id), def_id);\n+    ccx.tcx.mk_fn_def(def_id, substs, ccx.tcx.mk_bare_fn(ty::BareFnTy {\n         abi: abi,\n         unsafety: hir::Unsafety::Unsafe,\n         sig: ty::Binder(ty::FnSig {inputs: input_tys,\n                                     output: output,\n                                     variadic: decl.variadic}),\n-    }));\n-\n-    ty::TypeScheme {\n-        generics: ty_generics,\n-        ty: t_fn\n-    }\n+    }))\n }\n \n-pub fn mk_item_substs<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                      ty_generics: &ty::Generics)\n-                                      -> &'tcx Substs<'tcx>\n-{\n-    let types =\n-        ty_generics.types.map(\n-            |def| tcx.mk_param_from_def(def));\n-\n-    let regions =\n-        ty_generics.regions.map(\n-            |def| def.to_early_bound_region());\n+pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n+                                        span: Span,\n+                                        def_id: DefId)\n+                                        -> &'tcx Substs<'tcx> {\n+    let tcx = astconv.tcx();\n+    // FIXME(eddyb) Do this request from Substs::for_item in librustc.\n+    if let Err(ErrorReported) = astconv.get_generics(span, def_id) {\n+        // No convenient way to recover from a cycle here. Just bail. Sorry!\n+        tcx.sess.abort_if_errors();\n+        bug!(\"ErrorReported returned, but no errors reports?\")\n+    }\n \n-    tcx.mk_substs(Substs::new(types, regions))\n+    Substs::for_item(tcx, def_id,\n+                     |def, _| def.to_early_bound_region(),\n+                     |def, _| tcx.mk_param_from_def(def))\n }\n \n /// Checks that all the type parameters on an impl\n fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                 ast_generics: &hir::Generics,\n+                                                 generics: &hir::Generics,\n                                                  impl_predicates: &mut ty::GenericPredicates<'tcx>,\n                                                  impl_def_id: DefId)\n {\n     let impl_scheme = ccx.tcx.lookup_item_type(impl_def_id);\n     let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n-    assert!(impl_predicates.predicates.is_empty_in(FnSpace));\n-    assert!(impl_predicates.predicates.is_empty_in(SelfSpace));\n-\n     // The trait reference is an input, so find all type parameters\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n@@ -2233,16 +2148,15 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n     }\n \n-    ctp::setup_constraining_predicates(impl_predicates.predicates.get_mut_slice(TypeSpace),\n+    ctp::setup_constraining_predicates(&mut impl_predicates.predicates,\n                                        impl_trait_ref,\n                                        &mut input_parameters);\n \n-    for (index, ty_param) in ast_generics.ty_params.iter().enumerate() {\n-        let param_ty = ty::ParamTy { space: TypeSpace,\n-                                     idx: index as u32,\n-                                     name: ty_param.name };\n+    let ty_generics = generics_of_def_id(ccx, impl_def_id);\n+    for (ty_param, param) in ty_generics.types.iter().zip(&generics.ty_params) {\n+        let param_ty = ty::ParamTy::for_def(ty_param);\n         if !input_parameters.contains(&ctp::Parameter::Type(param_ty)) {\n-            report_unused_parameter(ccx, ty_param.span, \"type\", &param_ty.to_string());\n+            report_unused_parameter(ccx, param.span, \"type\", &param_ty.to_string());\n         }\n     }\n }\n@@ -2279,9 +2193,10 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         .collect();\n \n     for (index, lifetime_def) in ast_generics.lifetimes.iter().enumerate() {\n-        let region = ty::EarlyBoundRegion { space: TypeSpace,\n-                                            index: index as u32,\n-                                            name: lifetime_def.lifetime.name };\n+        let region = ty::EarlyBoundRegion {\n+            index: index as u32,\n+            name: lifetime_def.lifetime.name\n+        };\n         if\n             lifetimes_in_associated_types.contains(&region) && // (*)\n             !input_parameters.contains(&ctp::Parameter::Region(region))"}, {"sha": "fe1cb3d6badcd06dc97ba5f9f834ed5fa73d02ee", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -4018,7 +4018,7 @@ register_diagnostics! {\n //  E0141,\n //  E0159, // use of trait `{}` as struct constructor\n //  E0163, // merged into E0071\n-    E0167,\n+//  E0167,\n //  E0168,\n //  E0173, // manual implementations of unboxed closure traits are experimental\n //  E0174,\n@@ -4053,7 +4053,7 @@ register_diagnostics! {\n //  E0235, // structure constructor specifies a structure of type but\n //  E0236, // no lang item for range syntax\n //  E0237, // no lang item for range syntax\n-    E0238, // parenthesized parameters may only be used with a trait\n+//  E0238, // parenthesized parameters may only be used with a trait\n //  E0239, // `next` method of `Iterator` trait has unexpected type\n //  E0240,\n //  E0241,"}, {"sha": "8a8232535c77592ae9936d6545899bc1e257ad58", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -132,7 +132,7 @@ pub mod coherence;\n pub mod variance;\n \n pub struct TypeAndSubsts<'tcx> {\n-    pub substs: Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n     pub ty: Ty<'tcx>,\n }\n \n@@ -231,7 +231,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n             let main_def_id = tcx.map.local_def_id(main_id);\n-            let substs = tcx.mk_substs(Substs::empty());\n+            let substs = Substs::empty(tcx);\n             let se_ty = tcx.mk_fn_def(main_def_id, substs,\n                                       tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n@@ -284,7 +284,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             }\n \n             let start_def_id = ccx.tcx.map.local_def_id(start_id);\n-            let substs = tcx.mk_substs(Substs::empty());\n+            let substs = Substs::empty(tcx);\n             let se_ty = tcx.mk_fn_def(start_def_id, substs,\n                                       tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,"}, {"sha": "9aca779dd89c4f7ee01758eee09ae012eefff077", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -8,10 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use rustc::ty::{self, TyCtxt};\n+use rustc::hir::def_id::DefId;\n+use rustc::ty;\n use rustc::ty::subst::Substs;\n \n+use astconv::AstConv;\n+\n use std::cell::Cell;\n use syntax_pos::Span;\n \n@@ -71,41 +73,42 @@ pub trait RegionScope {\n }\n \n #[derive(Copy, Clone)]\n-pub struct AnonTypeScope<'a> {\n-    generics: &'a ty::Generics<'a>\n+pub struct AnonTypeScope {\n+    enclosing_item: DefId\n }\n \n-impl<'a, 'b, 'gcx, 'tcx> AnonTypeScope<'a> {\n-    pub fn new(generics: &'a ty::Generics<'a>) -> AnonTypeScope<'a> {\n+impl<'gcx: 'tcx, 'tcx> AnonTypeScope {\n+    pub fn new(enclosing_item: DefId) -> AnonTypeScope {\n         AnonTypeScope {\n-            generics: generics\n+            enclosing_item: enclosing_item\n         }\n     }\n \n-    pub fn fresh_substs(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx Substs<'tcx> {\n+    pub fn fresh_substs(&self, astconv: &AstConv<'gcx, 'tcx>, span: Span)\n+                        -> &'tcx Substs<'tcx> {\n         use collect::mk_item_substs;\n \n-        mk_item_substs(tcx, self.generics)\n+        mk_item_substs(astconv, span, self.enclosing_item)\n     }\n }\n \n /// A scope wrapper which optionally allows anonymized types.\n #[derive(Copy, Clone)]\n-pub struct MaybeWithAnonTypes<'a, R> {\n+pub struct MaybeWithAnonTypes<R> {\n     base_scope: R,\n-    anon_scope: Option<AnonTypeScope<'a>>\n+    anon_scope: Option<AnonTypeScope>\n }\n \n-impl<'a, R: RegionScope> MaybeWithAnonTypes<'a, R>  {\n-    pub fn new(base_scope: R, anon_scope: Option<AnonTypeScope<'a>>) -> Self {\n+impl<R: RegionScope> MaybeWithAnonTypes<R>  {\n+    pub fn new(base_scope: R, anon_scope: Option<AnonTypeScope>) -> Self {\n         MaybeWithAnonTypes {\n             base_scope: base_scope,\n             anon_scope: anon_scope\n         }\n     }\n }\n \n-impl<'a, R: RegionScope> RegionScope for MaybeWithAnonTypes<'a, R> {\n+impl<R: RegionScope> RegionScope for MaybeWithAnonTypes<R> {\n     fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n         self.base_scope.object_lifetime_default(span)\n     }"}, {"sha": "536fa629fd611837154ddb733c386f7a09da7af2", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -16,8 +16,7 @@\n use dep_graph::DepTrackingMapConfig;\n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n-use rustc::ty::subst;\n-use rustc::ty::subst::ParamSpace;\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::ItemVariances;\n use rustc::hir::map as hir_map;\n@@ -145,7 +144,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         let tcx = self.terms_cx.tcx;\n         assert!(is_lifetime(&tcx.map, param_id));\n         match tcx.named_region_map.defs.get(&param_id) {\n-            Some(&rl::DefEarlyBoundRegion(_, _, lifetime_decl_id))\n+            Some(&rl::DefEarlyBoundRegion(_, lifetime_decl_id))\n                 => lifetime_decl_id,\n             Some(_) => bug!(\"should not encounter non early-bound cases\"),\n \n@@ -211,7 +210,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                          param_def_id: DefId,\n                          item_def_id: DefId,\n                          kind: ParamKind,\n-                         space: ParamSpace,\n                          index: usize)\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n@@ -227,8 +225,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             // variance already inferred, just look it up.\n             let variances = self.tcx().item_variances(item_def_id);\n             let variance = match kind {\n-                TypeParam => *variances.types.get(space, index),\n-                RegionParam => *variances.regions.get(space, index),\n+                TypeParam => variances.types[index],\n+                RegionParam => variances.regions[index],\n             };\n             self.constant_term(variance)\n         }\n@@ -302,8 +300,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         self.add_constraints_from_substs(\n             generics,\n             trait_ref.def_id,\n-            trait_def.generics.types.as_slice(),\n-            trait_def.generics.regions.as_slice(),\n+            &trait_def.generics.types,\n+            &trait_def.generics.regions,\n             trait_ref.substs,\n             variance);\n     }\n@@ -360,18 +358,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // README.md for a discussion on dep-graph management.\n                 self.tcx().dep_graph.read(ItemVariances::to_dep_node(&def.did));\n \n-                // All type parameters on enums and structs should be\n-                // in the TypeSpace.\n-                assert!(item_type.generics.types.is_empty_in(subst::SelfSpace));\n-                assert!(item_type.generics.types.is_empty_in(subst::FnSpace));\n-                assert!(item_type.generics.regions.is_empty_in(subst::SelfSpace));\n-                assert!(item_type.generics.regions.is_empty_in(subst::FnSpace));\n-\n                 self.add_constraints_from_substs(\n                     generics,\n                     def.did,\n-                    item_type.generics.types.get_slice(subst::TypeSpace),\n-                    item_type.generics.regions.get_slice(subst::TypeSpace),\n+                    &item_type.generics.types,\n+                    &item_type.generics.regions,\n                     substs,\n                     variance);\n             }\n@@ -388,33 +379,30 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_substs(\n                     generics,\n                     trait_ref.def_id,\n-                    trait_def.generics.types.as_slice(),\n-                    trait_def.generics.regions.as_slice(),\n+                    &trait_def.generics.types,\n+                    &trait_def.generics.regions,\n                     trait_ref.substs,\n                     variance);\n             }\n \n             ty::TyTrait(ref data) => {\n-                let poly_trait_ref =\n-                    data.principal_trait_ref_with_self_ty(self.tcx(),\n-                                                          self.tcx().types.err);\n-\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, data.bounds.region_bound, contra);\n+                self.add_constraints_from_region(generics, data.region_bound, contra);\n \n-                // Ignore the SelfSpace, it is erased.\n+                let poly_trait_ref =\n+                    data.principal.with_self_ty(self.tcx(), self.tcx().types.err);\n                 self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n \n-                let projections = data.projection_bounds_with_self_ty(self.tcx(),\n-                                                                      self.tcx().types.err);\n-                for projection in &projections {\n+                for projection in &data.projection_bounds {\n                     self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n                 }\n             }\n \n             ty::TyParam(ref data) => {\n-                let def_id = generics.types.get(data.space, data.idx as usize).def_id;\n+                assert_eq!(generics.parent, None);\n+                assert!((data.idx as usize) < generics.types.len());\n+                let def_id = generics.types[data.idx as usize].def_id;\n                 let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 match self.terms_cx.inferred_map.get(&node_id) {\n                     Some(&index) => {\n@@ -452,7 +440,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    def_id: DefId,\n                                    type_param_defs: &[ty::TypeParameterDef<'tcx>],\n                                    region_param_defs: &[ty::RegionParameterDef],\n-                                   substs: &subst::Substs<'tcx>,\n+                                   substs: &Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={:?}, substs={:?}, variance={:?})\",\n                def_id,\n@@ -461,21 +449,19 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         for p in type_param_defs {\n             let variance_decl =\n-                self.declared_variance(p.def_id, def_id, TypeParam,\n-                                       p.space, p.index as usize);\n+                self.declared_variance(p.def_id, def_id, TypeParam, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_ty = *substs.types.get(p.space, p.index as usize);\n+            let substs_ty = substs.type_for_def(p);\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl, variance_i);\n             self.add_constraints_from_ty(generics, substs_ty, variance_i);\n         }\n \n         for p in region_param_defs {\n             let variance_decl =\n-                self.declared_variance(p.def_id, def_id,\n-                                       RegionParam, p.space, p.index as usize);\n+                self.declared_variance(p.def_id, def_id, RegionParam, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_r = *substs.regions.get(p.space, p.index as usize);\n+            let substs_r = substs.region_for_def(p);\n             self.add_constraints_from_region(generics, substs_r, variance_i);\n         }\n     }\n@@ -501,8 +487,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    variance: VarianceTermPtr<'a>) {\n         match region {\n             ty::ReEarlyBound(ref data) => {\n-                let def_id =\n-                    generics.regions.get(data.space, data.index as usize).def_id;\n+                assert_eq!(generics.parent, None);\n+                assert!((data.index as usize) < generics.regions.len());\n+                let def_id = generics.regions[data.index as usize].def_id;\n                 let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {\n                     let index = self.inferred_index(node_id);"}, {"sha": "d3b63119bcb324fad45016f1ea72e4b2ea98eae7", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -15,7 +15,6 @@\n //! optimal solution to the constraints. The final variance for each\n //! inferred is then written into the `variance_map` in the tcx.\n \n-use rustc::ty::subst::VecPerParamSpace;\n use rustc::ty;\n use std::rc::Rc;\n \n@@ -109,26 +108,28 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         let num_inferred = self.terms_cx.num_inferred();\n         while index < num_inferred {\n             let item_id = inferred_infos[index].item_id;\n-            let mut types = VecPerParamSpace::empty();\n-            let mut regions = VecPerParamSpace::empty();\n+\n+            let mut item_variances = ty::ItemVariances::empty();\n \n             while index < num_inferred && inferred_infos[index].item_id == item_id {\n                 let info = &inferred_infos[index];\n                 let variance = solutions[index];\n-                debug!(\"Index {} Info {} / {:?} / {:?} Variance {:?}\",\n-                       index, info.index, info.kind, info.space, variance);\n+                debug!(\"Index {} Info {} / {:?} Variance {:?}\",\n+                       index, info.index, info.kind, variance);\n                 match info.kind {\n-                    TypeParam => { types.push(info.space, variance); }\n-                    RegionParam => { regions.push(info.space, variance); }\n+                    TypeParam => {\n+                        assert_eq!(item_variances.types.len(), info.index);\n+                        item_variances.types.push(variance);\n+                    }\n+                    RegionParam => {\n+                        assert_eq!(item_variances.regions.len(), info.index);\n+                        item_variances.regions.push(variance);\n+                    }\n                 }\n \n                 index += 1;\n             }\n \n-            let item_variances = ty::ItemVariances {\n-                types: types,\n-                regions: regions\n-            };\n             debug!(\"item_id={} item_variances={:?}\",\n                     item_id,\n                     item_variances);"}, {"sha": "d30cbc8f117cf03c98668f4409789aad0e660e91", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -21,7 +21,6 @@\n \n use arena::TypedArena;\n use dep_graph::DepTrackingMapConfig;\n-use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace};\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::ItemVariances;\n use std::fmt;\n@@ -86,7 +85,6 @@ pub enum ParamKind {\n pub struct InferredInfo<'a> {\n     pub item_id: ast::NodeId,\n     pub kind: ParamKind,\n-    pub space: ParamSpace,\n     pub index: usize,\n     pub param_id: ast::NodeId,\n     pub term: VarianceTermPtr<'a>,\n@@ -112,10 +110,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n \n         // cache and share the variance struct used for items with\n         // no type/region parameters\n-        empty_variances: Rc::new(ty::ItemVariances {\n-            types: VecPerParamSpace::empty(),\n-            regions: VecPerParamSpace::empty()\n-        })\n+        empty_variances: Rc::new(ty::ItemVariances::empty())\n     };\n \n     // See README.md for a discussion on dep-graph management.\n@@ -167,17 +162,17 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n         let inferreds_on_entry = self.num_inferred();\n \n-        if has_self {\n-            self.add_inferred(item_id, TypeParam, SelfSpace, 0, item_id);\n-        }\n-\n         for (i, p) in generics.lifetimes.iter().enumerate() {\n             let id = p.lifetime.id;\n-            self.add_inferred(item_id, RegionParam, TypeSpace, i, id);\n+            self.add_inferred(item_id, RegionParam, i, id);\n         }\n \n+        if has_self {\n+            self.add_inferred(item_id, TypeParam, 0, item_id);\n+        }\n         for (i, p) in generics.ty_params.iter().enumerate() {\n-            self.add_inferred(item_id, TypeParam, TypeSpace, i, p.id);\n+            let i = has_self as usize + i;\n+            self.add_inferred(item_id, TypeParam, i, p.id);\n         }\n \n         // If this item has no type or lifetime parameters,\n@@ -200,15 +195,13 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn add_inferred(&mut self,\n                     item_id: ast::NodeId,\n                     kind: ParamKind,\n-                    space: ParamSpace,\n                     index: usize,\n                     param_id: ast::NodeId) {\n         let inf_index = InferredIndex(self.inferred_infos.len());\n         let term = self.arena.alloc(InferredTerm(inf_index));\n-        let initial_variance = self.pick_initial_variance(item_id, space, index);\n+        let initial_variance = self.pick_initial_variance(item_id, index);\n         self.inferred_infos.push(InferredInfo { item_id: item_id,\n                                                 kind: kind,\n-                                                space: space,\n                                                 index: index,\n                                                 param_id: param_id,\n                                                 term: term,\n@@ -219,33 +212,23 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         debug!(\"add_inferred(item_path={}, \\\n                 item_id={}, \\\n                 kind={:?}, \\\n-                space={:?}, \\\n                 index={}, \\\n                 param_id={}, \\\n                 inf_index={:?}, \\\n                 initial_variance={:?})\",\n                self.tcx.item_path_str(self.tcx.map.local_def_id(item_id)),\n-               item_id, kind, space, index, param_id, inf_index,\n+               item_id, kind, index, param_id, inf_index,\n                initial_variance);\n     }\n \n     fn pick_initial_variance(&self,\n                              item_id: ast::NodeId,\n-                             space: ParamSpace,\n                              index: usize)\n                              -> ty::Variance\n     {\n-        match space {\n-            SelfSpace | FnSpace => {\n-                ty::Bivariant\n-            }\n-\n-            TypeSpace => {\n-                match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n-                    Some(&(_, ref variances)) => variances[index],\n-                    None => ty::Bivariant\n-                }\n-            }\n+        match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n+            Some(&(_, ref variances)) => variances[index],\n+            None => ty::Bivariant\n         }\n     }\n "}, {"sha": "013433336a1d5396e08f90bf0e37d3c2d2f4e9f9", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -21,7 +21,6 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::subst;\n \n use rustc_const_eval::lookup_const_by_id;\n \n@@ -161,7 +160,7 @@ pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tc\n     let def = tcx.lookup_trait_def(did);\n     let trait_items = tcx.trait_items(did).clean(cx);\n     let predicates = tcx.lookup_predicates(did);\n-    let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n+    let generics = (def.generics, &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n     clean::Trait {\n@@ -189,7 +188,7 @@ fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx\n     let predicates = tcx.lookup_predicates(did);\n     clean::Function {\n         decl: decl,\n-        generics: (&t.generics, &predicates, subst::FnSpace).clean(cx),\n+        generics: (t.generics, &predicates).clean(cx),\n         unsafety: style,\n         constness: constness,\n         abi: abi,\n@@ -209,7 +208,7 @@ fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             &[..] if variant.kind == ty::VariantKind::Tuple => doctree::Tuple,\n             _ => doctree::Plain,\n         },\n-        generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n+        generics: (t.generics, &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n@@ -222,7 +221,7 @@ fn build_type<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match t.ty.sty {\n         ty::TyEnum(edef, _) if !tcx.sess.cstore.is_typedef(did) => {\n             return clean::EnumItem(clean::Enum {\n-                generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n+                generics: (t.generics, &predicates).clean(cx),\n                 variants_stripped: false,\n                 variants: edef.variants.clean(cx),\n             })\n@@ -232,7 +231,7 @@ fn build_type<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     clean::TypedefItem(clean::Typedef {\n         type_: t.ty.clean(cx),\n-        generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n+        generics: (t.generics, &predicates).clean(cx),\n     }, false)\n }\n \n@@ -389,14 +388,14 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             }\n             ty::TypeTraitItem(ref assoc_ty) => {\n                 let did = assoc_ty.def_id;\n-                let type_scheme = ty::TypeScheme {\n-                    ty: assoc_ty.ty.unwrap(),\n-                    generics: ty::Generics::empty()\n+                let typedef = clean::Typedef {\n+                    type_: assoc_ty.ty.unwrap().clean(cx),\n+                    generics: clean::Generics {\n+                        lifetimes: vec![],\n+                        type_params: vec![],\n+                        where_predicates: vec![]\n+                    }\n                 };\n-                // Not sure the choice of ParamSpace actually matters here,\n-                // because an associated type won't have generics on the LHS\n-                let typedef = (type_scheme, ty::GenericPredicates::empty(),\n-                               subst::ParamSpace::TypeSpace).clean(cx);\n                 Some(clean::Item {\n                     name: Some(assoc_ty.name.clean(cx)),\n                     inner: clean::TypedefItem(typedef, true),\n@@ -434,7 +433,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             provided_trait_methods: provided,\n             trait_: trait_,\n             for_: for_,\n-            generics: (&ty.generics, &predicates, subst::TypeSpace).clean(cx),\n+            generics: (ty.generics, &predicates).clean(cx),\n             items: trait_items,\n             polarity: polarity.map(|p| { p.clean(cx) }),\n         }),\n@@ -512,20 +511,41 @@ fn build_static<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// its associated types as well. We specifically move these clauses to the\n /// associated types instead when displaying, so when we're genering the\n /// generics for the trait itself we need to be sure to remove them.\n+/// We also need to remove the implied \"recursive\" Self: Trait bound.\n ///\n /// The inverse of this filtering logic can be found in the `Clean`\n /// implementation for `AssociatedType`\n fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics)\n                              -> clean::Generics {\n+    for pred in &mut g.where_predicates {\n+        match *pred {\n+            clean::WherePredicate::BoundPredicate {\n+                ty: clean::Generic(ref s),\n+                ref mut bounds\n+            } if *s == \"Self\" => {\n+                bounds.retain(|bound| {\n+                    match *bound {\n+                        clean::TyParamBound::TraitBound(clean::PolyTrait {\n+                            trait_: clean::ResolvedPath { did, .. },\n+                            ..\n+                        }, _) => did != trait_did,\n+                        _ => true\n+                    }\n+                });\n+            }\n+            _ => {}\n+        }\n+    }\n+\n     g.where_predicates.retain(|pred| {\n         match *pred {\n             clean::WherePredicate::BoundPredicate {\n                 ty: clean::QPath {\n                     self_type: box clean::Generic(ref s),\n                     trait_: box clean::ResolvedPath { did, .. },\n                     name: ref _name,\n-                }, ..\n-            } => *s != \"Self\" || did != trait_did,\n+                }, ref bounds\n+            } => !(*s == \"Self\" && did == trait_did) && !bounds.is_empty(),\n             _ => true,\n         }\n     });"}, {"sha": "75d21399f05e69d28f59a2aa35b0d9d6fb12c8e8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 55, "deletions": 79, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -41,7 +41,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::fold::Folder;\n use rustc::hir::print as pprust;\n-use rustc::ty::subst::{self, ParamSpace, VecPerParamSpace};\n+use rustc::ty::subst::Substs;\n use rustc::ty;\n use rustc::middle::stability;\n \n@@ -82,12 +82,6 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<VecPerParamSpace<U>> for VecPerParamSpace<T> {\n-    fn clean(&self, cx: &DocContext) -> VecPerParamSpace<U> {\n-        self.map(|x| x.clean(cx))\n-    }\n-}\n-\n impl<T: Clean<U>, U> Clean<U> for P<T> {\n     fn clean(&self, cx: &DocContext) -> U {\n         (**self).clean(cx)\n@@ -630,33 +624,10 @@ impl Clean<TyParamBound> for hir::TyParamBound {\n     }\n }\n \n-impl<'tcx> Clean<(Vec<TyParamBound>, Vec<TypeBinding>)> for ty::ExistentialBounds<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> (Vec<TyParamBound>, Vec<TypeBinding>) {\n-        let mut tp_bounds = vec![];\n-        self.region_bound.clean(cx).map(|b| tp_bounds.push(RegionBound(b)));\n-        for bb in &self.builtin_bounds {\n-            tp_bounds.push(bb.clean(cx));\n-        }\n-\n-        let mut bindings = vec![];\n-        for &ty::Binder(ref pb) in &self.projection_bounds {\n-            bindings.push(TypeBinding {\n-                name: pb.projection_ty.item_name.clean(cx),\n-                ty: pb.ty.clean(cx)\n-            });\n-        }\n-\n-        (tp_bounds, bindings)\n-    }\n-}\n-\n-fn external_path_params(cx: &DocContext, trait_did: Option<DefId>,\n-                        bindings: Vec<TypeBinding>, substs: &subst::Substs) -> PathParameters {\n-    let lifetimes = substs.regions.get_slice(subst::TypeSpace)\n-                    .iter()\n-                    .filter_map(|v| v.clean(cx))\n-                    .collect();\n-    let types = substs.types.get_slice(subst::TypeSpace).to_vec();\n+fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: bool,\n+                        bindings: Vec<TypeBinding>, substs: &Substs) -> PathParameters {\n+    let lifetimes = substs.regions.iter().filter_map(|v| v.clean(cx)).collect();\n+    let types = substs.types[has_self as usize..].to_vec();\n \n     match (trait_did, cx.tcx_opt()) {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n@@ -695,13 +666,13 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>,\n \n // trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n // from Fn<(A, B,), C> to Fn(A, B) -> C\n-fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>,\n-                 bindings: Vec<TypeBinding>, substs: &subst::Substs) -> Path {\n+fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self: bool,\n+                 bindings: Vec<TypeBinding>, substs: &Substs) -> Path {\n     Path {\n         global: false,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n-            params: external_path_params(cx, trait_did, bindings, substs)\n+            params: external_path_params(cx, trait_did, has_self, bindings, substs)\n         }],\n     }\n }\n@@ -712,20 +683,20 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n             Some(tcx) => tcx,\n             None => return RegionBound(Lifetime::statik())\n         };\n-        let empty = subst::Substs::empty();\n+        let empty = Substs::empty(tcx);\n         let (did, path) = match *self {\n             ty::BoundSend =>\n                 (tcx.lang_items.send_trait().unwrap(),\n-                 external_path(cx, \"Send\", None, vec![], &empty)),\n+                 external_path(cx, \"Send\", None, false, vec![], empty)),\n             ty::BoundSized =>\n                 (tcx.lang_items.sized_trait().unwrap(),\n-                 external_path(cx, \"Sized\", None, vec![], &empty)),\n+                 external_path(cx, \"Sized\", None, false, vec![], empty)),\n             ty::BoundCopy =>\n                 (tcx.lang_items.copy_trait().unwrap(),\n-                 external_path(cx, \"Copy\", None, vec![], &empty)),\n+                 external_path(cx, \"Copy\", None, false, vec![], empty)),\n             ty::BoundSync =>\n                 (tcx.lang_items.sync_trait().unwrap(),\n-                 external_path(cx, \"Sync\", None, vec![], &empty)),\n+                 external_path(cx, \"Sync\", None, false, vec![], empty)),\n         };\n         inline::record_extern_fqn(cx, did, TypeTrait);\n         TraitBound(PolyTrait {\n@@ -748,14 +719,14 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n         };\n         inline::record_extern_fqn(cx, self.def_id, TypeTrait);\n         let path = external_path(cx, &tcx.item_name(self.def_id).as_str(),\n-                                 Some(self.def_id), vec![], self.substs);\n+                                 Some(self.def_id), true, vec![], self.substs);\n \n-        debug!(\"ty::TraitRef\\n  substs.types(TypeSpace): {:?}\\n\",\n-               self.substs.types.get_slice(ParamSpace::TypeSpace));\n+        debug!(\"ty::TraitRef\\n  substs.types: {:?}\\n\",\n+               &self.input_types()[1..]);\n \n         // collect any late bound regions\n         let mut late_bounds = vec![];\n-        for &ty_s in self.substs.types.get_slice(ParamSpace::TypeSpace) {\n+        for &ty_s in &self.input_types()[1..] {\n             if let ty::TyTuple(ts) = ty_s.sty {\n                 for &ty_s in ts {\n                     if let ty::TyRef(ref reg, _) = ty_s.sty {\n@@ -785,10 +756,11 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<Option<Vec<TyParamBound>>> for subst::Substs<'tcx> {\n+impl<'tcx> Clean<Option<Vec<TyParamBound>>> for Substs<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Option<Vec<TyParamBound>> {\n         let mut v = Vec::new();\n-        v.extend(self.regions.iter().filter_map(|r| r.clean(cx)).map(RegionBound));\n+        v.extend(self.regions.iter().filter_map(|r| r.clean(cx))\n+                     .map(RegionBound));\n         v.extend(self.types.iter().map(|t| TraitBound(PolyTrait {\n             trait_: t.clean(cx),\n             lifetimes: vec![]\n@@ -910,7 +882,7 @@ impl<'a> Clean<WherePredicate> for ty::Predicate<'a> {\n impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         WherePredicate::BoundPredicate {\n-            ty: self.trait_ref.substs.self_ty().clean(cx).unwrap(),\n+            ty: self.trait_ref.self_ty().clean(cx),\n             bounds: vec![self.trait_ref.clean(cx)]\n         }\n     }\n@@ -991,27 +963,30 @@ impl Clean<Generics> for hir::Generics {\n }\n \n impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n-                                    &'a ty::GenericPredicates<'tcx>,\n-                                    subst::ParamSpace) {\n+                                    &'a ty::GenericPredicates<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n         use self::WherePredicate as WP;\n \n-        let (gens, preds, space) = *self;\n+        let (gens, preds) = *self;\n \n         // Bounds in the type_params and lifetimes fields are repeated in the\n         // predicates field (see rustc_typeck::collect::ty_generics), so remove\n         // them.\n-        let stripped_typarams = gens.types.get_slice(space).iter().map(|tp| {\n-            tp.clean(cx)\n+        let stripped_typarams = gens.types.iter().filter_map(|tp| {\n+            if tp.name == keywords::SelfType.name() {\n+                assert_eq!(tp.index, 0);\n+                None\n+            } else {\n+                Some(tp.clean(cx))\n+            }\n         }).collect::<Vec<_>>();\n-        let stripped_lifetimes = gens.regions.get_slice(space).iter().map(|rp| {\n+        let stripped_lifetimes = gens.regions.iter().map(|rp| {\n             let mut srp = rp.clone();\n             srp.bounds = Vec::new();\n             srp.clean(cx)\n         }).collect::<Vec<_>>();\n \n-        let mut where_predicates = preds.predicates.get_slice(space)\n-                                                   .to_vec().clean(cx);\n+        let mut where_predicates = preds.predicates.to_vec().clean(cx);\n \n         // Type parameters and have a Sized bound by default unless removed with\n         // ?Sized.  Scan through the predicates and mark any type parameter with\n@@ -1363,8 +1338,7 @@ impl Clean<Item> for hir::ImplItem {\n \n impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        let generics = (&self.generics, &self.predicates,\n-                        subst::FnSpace).clean(cx);\n+        let generics = (self.generics, &self.predicates).clean(cx);\n         let mut decl = (self.def_id, &self.fty.sig).clean(cx);\n         match self.explicit_self {\n             ty::ExplicitSelfCategory::ByValue => {\n@@ -1653,7 +1627,7 @@ impl<'a, 'tcx: 'a, 'b: 'tcx> Folder for SubstAlias<'a, 'tcx> {\n     fn fold_lifetime(&mut self, lt: hir::Lifetime) -> hir::Lifetime {\n         let def = self.tcx.named_region_map.defs.get(&lt.id).cloned();\n         match def {\n-            Some(DefEarlyBoundRegion(_, _, node_id)) |\n+            Some(DefEarlyBoundRegion(_, node_id)) |\n             Some(DefLateBoundRegion(_, node_id)) |\n             Some(DefFreeRegion(_, node_id)) => {\n                 if let Some(lt) = self.lt_substs.get(&node_id).cloned() {\n@@ -1830,20 +1804,34 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n                 let path = external_path(cx, &cx.tcx().item_name(did).as_str(),\n-                                         None, vec![], substs);\n+                                         None, false, vec![], substs);\n                 ResolvedPath {\n                     path: path,\n                     typarams: None,\n                     did: did,\n                     is_generic: false,\n                 }\n             }\n-            ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n-                let did = principal.def_id();\n+            ty::TyTrait(ref obj) => {\n+                let did = obj.principal.def_id();\n                 inline::record_extern_fqn(cx, did, TypeTrait);\n-                let (typarams, bindings) = bounds.clean(cx);\n+\n+                let mut typarams = vec![];\n+                obj.region_bound.clean(cx).map(|b| typarams.push(RegionBound(b)));\n+                for bb in &obj.builtin_bounds {\n+                    typarams.push(bb.clean(cx));\n+                }\n+\n+                let mut bindings = vec![];\n+                for &ty::Binder(ref pb) in &obj.projection_bounds {\n+                    bindings.push(TypeBinding {\n+                        name: pb.item_name.clean(cx),\n+                        ty: pb.ty.clean(cx)\n+                    });\n+                }\n+\n                 let path = external_path(cx, &cx.tcx().item_name(did).as_str(),\n-                                         Some(did), bindings, principal.substs());\n+                                         Some(did), false, bindings, obj.principal.0.substs);\n                 ResolvedPath {\n                     path: path,\n                     typarams: Some(typarams),\n@@ -1863,8 +1851,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 let item_predicates = cx.tcx().lookup_predicates(def_id);\n                 let substs = cx.tcx().lift(&substs).unwrap();\n                 let bounds = item_predicates.instantiate(cx.tcx(), substs);\n-                let predicates = bounds.predicates.into_vec();\n-                ImplTrait(predicates.into_iter().filter_map(|predicate| {\n+                ImplTrait(bounds.predicates.into_iter().filter_map(|predicate| {\n                     predicate.to_opt_poly_trait_ref().clean(cx)\n                 }).collect())\n             }\n@@ -2920,7 +2907,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n             // applied to this associated type in question.\n             let def = cx.tcx().lookup_trait_def(did);\n             let predicates = cx.tcx().lookup_predicates(did);\n-            let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n+            let generics = (def.generics, &predicates).clean(cx);\n             generics.where_predicates.iter().filter_map(|pred| {\n                 let (name, self_type, trait_, bounds) = match *pred {\n                     WherePredicate::BoundPredicate {\n@@ -2967,17 +2954,6 @@ impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n     }\n }\n \n-impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ty::GenericPredicates<'a>,\n-                             ParamSpace) {\n-    fn clean(&self, cx: &DocContext) -> Typedef {\n-        let (ref ty_scheme, ref predicates, ps) = *self;\n-        Typedef {\n-            type_: ty_scheme.ty.clean(cx),\n-            generics: (&ty_scheme.generics, predicates, ps).clean(cx)\n-        }\n-    }\n-}\n-\n fn lang_struct(cx: &DocContext, did: Option<DefId>,\n                t: ty::Ty, name: &str,\n                fallback: fn(Box<Type>) -> Type) -> Type {"}, {"sha": "7ae177439064f9c19d642c82009068b0ded9391c", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -30,11 +30,11 @@ use std::mem;\n use std::collections::BTreeMap;\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst;\n+use rustc::ty;\n \n use clean::PathParameters as PP;\n use clean::WherePredicate as WP;\n-use clean::{self, Clean};\n+use clean;\n use core::DocContext;\n \n pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n@@ -153,27 +153,16 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n     if child == trait_ {\n         return true\n     }\n-    let def = cx.tcx().lookup_trait_def(child);\n-    let predicates = cx.tcx().lookup_predicates(child);\n-    let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n-    generics.where_predicates.iter().filter_map(|pred| {\n-        match *pred {\n-            clean::WherePredicate::BoundPredicate {\n-                ty: clean::Generic(ref s),\n-                ref bounds\n-            } if *s == \"Self\" => Some(bounds),\n-            _ => None,\n-        }\n-    }).flat_map(|bounds| bounds).any(|bound| {\n-        let poly_trait = match *bound {\n-            clean::TraitBound(ref t, _) => t,\n-            _ => return false,\n-        };\n-        match poly_trait.trait_ {\n-            clean::ResolvedPath { did, .. } => {\n-                trait_is_same_or_supertrait(cx, did, trait_)\n+    let predicates = cx.tcx().lookup_super_predicates(child).predicates;\n+    predicates.iter().filter_map(|pred| {\n+        if let ty::Predicate::Trait(ref pred) = *pred {\n+            if pred.0.trait_ref.self_ty().is_self() {\n+                Some(pred.def_id())\n+            } else {\n+                None\n             }\n-            _ => false,\n+        } else {\n+            None\n         }\n-    })\n+    }).any(|did| trait_is_same_or_supertrait(cx, did, trait_))\n }"}, {"sha": "f8b852074dd2b1a3180107e1c8523de9cb7eb6db", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -326,7 +326,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n             url.push_str(\"/index.html\");\n         }\n         _ => {\n-            url.push_str(shortty.to_static_str());\n+            url.push_str(shortty.css_class());\n             url.push_str(\".\");\n             url.push_str(fqp.last().unwrap());\n             url.push_str(\".html\");"}, {"sha": "6b462a76f04ed4a7dc03a31622b1ea02cf0d68eb", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -42,6 +42,14 @@ pub enum ItemType {\n     AssociatedConst = 18,\n }\n \n+\n+#[derive(Copy, Eq, PartialEq, Clone)]\n+pub enum NameSpace {\n+    Type,\n+    Value,\n+    Macro,\n+}\n+\n impl ItemType {\n     pub fn from_item(item: &clean::Item) -> ItemType {\n         let inner = match item.inner {\n@@ -90,7 +98,7 @@ impl ItemType {\n         }\n     }\n \n-    pub fn to_static_str(&self) -> &'static str {\n+    pub fn css_class(&self) -> &'static str {\n         match *self {\n             ItemType::Module          => \"mod\",\n             ItemType::ExternCrate     => \"externcrate\",\n@@ -113,9 +121,55 @@ impl ItemType {\n             ItemType::AssociatedConst => \"associatedconstant\",\n         }\n     }\n+\n+    pub fn name_space(&self) -> NameSpace {\n+        match *self {\n+            ItemType::Struct |\n+            ItemType::Enum |\n+            ItemType::Module |\n+            ItemType::Typedef |\n+            ItemType::Trait |\n+            ItemType::Primitive |\n+            ItemType::AssociatedType => NameSpace::Type,\n+\n+            ItemType::ExternCrate |\n+            ItemType::Import |\n+            ItemType::Function |\n+            ItemType::Static |\n+            ItemType::Impl |\n+            ItemType::TyMethod |\n+            ItemType::Method |\n+            ItemType::StructField |\n+            ItemType::Variant |\n+            ItemType::Constant |\n+            ItemType::AssociatedConst => NameSpace::Value,\n+\n+            ItemType::Macro => NameSpace::Macro,\n+        }\n+    }\n }\n \n impl fmt::Display for ItemType {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.css_class().fmt(f)\n+    }\n+}\n+\n+pub const NAMESPACE_TYPE: &'static str = \"t\";\n+pub const NAMESPACE_VALUE: &'static str = \"v\";\n+pub const NAMESPACE_MACRO: &'static str = \"m\";\n+\n+impl NameSpace {\n+    pub fn to_static_str(&self) -> &'static str {\n+        match *self {\n+            NameSpace::Type => NAMESPACE_TYPE,\n+            NameSpace::Value => NAMESPACE_VALUE,\n+            NameSpace::Macro => NAMESPACE_MACRO,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for NameSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.to_static_str().fmt(f)\n     }"}, {"sha": "151e138efefbf0a3a09595d0c4fa13f9441fb6a8", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -24,7 +24,7 @@ pub struct Layout {\n \n pub struct Page<'a> {\n     pub title: &'a str,\n-    pub ty: &'a str,\n+    pub css_class: &'a str,\n     pub root_path: &'a str,\n     pub description: &'a str,\n     pub keywords: &'a str,\n@@ -80,7 +80,7 @@ r##\"<!DOCTYPE html>\n         </form>\n     </nav>\n \n-    <section id='main' class=\"content {ty}\">{content}</section>\n+    <section id='main' class=\"content {css_class}\">{content}</section>\n     <section id='search' class=\"content hidden\"></section>\n \n     <section class=\"footer\"></section>\n@@ -152,7 +152,7 @@ r##\"<!DOCTYPE html>\n     },\n     content   = *t,\n     root_path = page.root_path,\n-    ty        = page.ty,\n+    css_class = page.css_class,\n     logo      = if layout.logo.is_empty() {\n         \"\".to_string()\n     } else {"}, {"sha": "d654429146d83738d9a39888cbe785f0592c84d0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 185, "deletions": 129, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -41,7 +41,7 @@ use std::collections::{BTreeMap, HashMap, HashSet};\n use std::default::Default;\n use std::error;\n use std::fmt::{self, Display, Formatter};\n-use std::fs::{self, File};\n+use std::fs::{self, File, OpenOptions};\n use std::io::prelude::*;\n use std::io::{self, BufWriter, BufReader};\n use std::iter::repeat;\n@@ -587,7 +587,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     for &(did, ref item) in orphan_methods {\n         if let Some(&(ref fqp, _)) = paths.get(&did) {\n             search_index.push(IndexItem {\n-                ty: shortty(item),\n+                ty: item_type(item),\n                 name: item.name.clone().unwrap(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n                 desc: Escape(&shorter(item.doc_value())).to_string(),\n@@ -714,10 +714,10 @@ fn write_shared(cx: &Context,\n             for line in BufReader::new(File::open(path)?).lines() {\n                 let line = line?;\n                 if !line.starts_with(key) {\n-                    continue\n+                    continue;\n                 }\n                 if line.starts_with(&format!(r#\"{}[\"{}\"]\"#, key, krate)) {\n-                    continue\n+                    continue;\n                 }\n                 ret.push(line.to_string());\n             }\n@@ -761,7 +761,7 @@ fn write_shared(cx: &Context,\n             try_err!(mkdir(&mydst), &mydst);\n         }\n         mydst.push(&format!(\"{}.{}.js\",\n-                            remote_item_type.to_static_str(),\n+                            remote_item_type.css_class(),\n                             remote_path[remote_path.len() - 1]));\n         let all_implementors = try_err!(collect(&mydst, &krate.name,\n                                                 \"implementors\"),\n@@ -832,7 +832,7 @@ fn mkdir(path: &Path) -> io::Result<()> {\n }\n \n /// Returns a documentation-level item type from the item.\n-fn shortty(item: &clean::Item) -> ItemType {\n+fn item_type(item: &clean::Item) -> ItemType {\n     ItemType::from_item(item)\n }\n \n@@ -952,7 +952,7 @@ impl<'a> SourceCollector<'a> {\n         let mut fname = p.file_name().expect(\"source has no filename\")\n                          .to_os_string();\n         fname.push(\".html\");\n-        cur.push(&fname[..]);\n+        cur.push(&fname);\n         href.push_str(&fname.to_string_lossy());\n \n         let mut w = BufWriter::new(File::create(&cur)?);\n@@ -961,7 +961,7 @@ impl<'a> SourceCollector<'a> {\n         let desc = format!(\"Source to the Rust file `{}`.\", filename);\n         let page = layout::Page {\n             title: &title,\n-            ty: \"source\",\n+            css_class: \"source\",\n             root_path: &root_path,\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n@@ -1080,7 +1080,7 @@ impl DocFolder for Cache {\n                     // inserted later on when serializing the search-index.\n                     if item.def_id.index != CRATE_DEF_INDEX {\n                         self.search_index.push(IndexItem {\n-                            ty: shortty(&item),\n+                            ty: item_type(&item),\n                             name: s.to_string(),\n                             path: path.join(\"::\").to_string(),\n                             desc: Escape(&shorter(item.doc_value())).to_string(),\n@@ -1126,7 +1126,7 @@ impl DocFolder for Cache {\n                     self.access_levels.is_public(item.def_id)\n                 {\n                     self.paths.insert(item.def_id,\n-                                      (self.stack.clone(), shortty(&item)));\n+                                      (self.stack.clone(), item_type(&item)));\n                 }\n             }\n             // link variants to their parent enum because pages aren't emitted\n@@ -1139,7 +1139,7 @@ impl DocFolder for Cache {\n \n             clean::PrimitiveItem(..) if item.visibility.is_some() => {\n                 self.paths.insert(item.def_id, (self.stack.clone(),\n-                                                shortty(&item)));\n+                                                item_type(&item)));\n             }\n \n             _ => {}\n@@ -1283,74 +1283,77 @@ impl Context {\n         Ok(())\n     }\n \n-    /// Non-parallelized version of rendering an item. This will take the input\n-    /// item, render its contents, and then invoke the specified closure with\n-    /// all sub-items which need to be rendered.\n-    ///\n-    /// The rendering driver uses this closure to queue up more work.\n-    fn item<F>(&mut self, item: clean::Item, mut f: F) -> Result<(), Error> where\n-        F: FnMut(&mut Context, clean::Item),\n-    {\n-        fn render(writer: &mut io::Write, cx: &Context, it: &clean::Item,\n-                  pushname: bool) -> io::Result<()> {\n-            // A little unfortunate that this is done like this, but it sure\n-            // does make formatting *a lot* nicer.\n-            CURRENT_LOCATION_KEY.with(|slot| {\n-                *slot.borrow_mut() = cx.current.clone();\n-            });\n+    fn render_item(&self,\n+                   writer: &mut io::Write,\n+                   it: &clean::Item,\n+                   pushname: bool)\n+                   -> io::Result<()> {\n+        // A little unfortunate that this is done like this, but it sure\n+        // does make formatting *a lot* nicer.\n+        CURRENT_LOCATION_KEY.with(|slot| {\n+            *slot.borrow_mut() = self.current.clone();\n+        });\n \n-            let mut title = if it.is_primitive() {\n-                // No need to include the namespace for primitive types\n-                String::new()\n-            } else {\n-                cx.current.join(\"::\")\n-            };\n-            if pushname {\n-                if !title.is_empty() {\n-                    title.push_str(\"::\");\n-                }\n-                title.push_str(it.name.as_ref().unwrap());\n+        let mut title = if it.is_primitive() {\n+            // No need to include the namespace for primitive types\n+            String::new()\n+        } else {\n+            self.current.join(\"::\")\n+        };\n+        if pushname {\n+            if !title.is_empty() {\n+                title.push_str(\"::\");\n             }\n-            title.push_str(\" - Rust\");\n-            let tyname = shortty(it).to_static_str();\n-            let desc = if it.is_crate() {\n-                format!(\"API documentation for the Rust `{}` crate.\",\n-                        cx.shared.layout.krate)\n-            } else {\n-                format!(\"API documentation for the Rust `{}` {} in crate `{}`.\",\n-                        it.name.as_ref().unwrap(), tyname, cx.shared.layout.krate)\n-            };\n-            let keywords = make_item_keywords(it);\n-            let page = layout::Page {\n-                ty: tyname,\n-                root_path: &cx.root_path,\n-                title: &title,\n-                description: &desc,\n-                keywords: &keywords,\n-            };\n+            title.push_str(it.name.as_ref().unwrap());\n+        }\n+        title.push_str(\" - Rust\");\n+        let tyname = item_type(it).css_class();\n+        let desc = if it.is_crate() {\n+            format!(\"API documentation for the Rust `{}` crate.\",\n+                    self.shared.layout.krate)\n+        } else {\n+            format!(\"API documentation for the Rust `{}` {} in crate `{}`.\",\n+                    it.name.as_ref().unwrap(), tyname, self.shared.layout.krate)\n+        };\n+        let keywords = make_item_keywords(it);\n+        let page = layout::Page {\n+            css_class: tyname,\n+            root_path: &self.root_path,\n+            title: &title,\n+            description: &desc,\n+            keywords: &keywords,\n+        };\n \n-            reset_ids(true);\n+        reset_ids(true);\n \n-            if !cx.render_redirect_pages {\n-                layout::render(writer, &cx.shared.layout, &page,\n-                               &Sidebar{ cx: cx, item: it },\n-                               &Item{ cx: cx, item: it },\n-                               cx.shared.css_file_extension.is_some())?;\n-            } else {\n-                let mut url = repeat(\"../\").take(cx.current.len())\n-                                           .collect::<String>();\n-                if let Some(&(ref names, ty)) = cache().paths.get(&it.def_id) {\n-                    for name in &names[..names.len() - 1] {\n-                        url.push_str(name);\n-                        url.push_str(\"/\");\n-                    }\n-                    url.push_str(&item_path(ty, names.last().unwrap()));\n-                    layout::redirect(writer, &url)?;\n+        if !self.render_redirect_pages {\n+            layout::render(writer, &self.shared.layout, &page,\n+                           &Sidebar{ cx: self, item: it },\n+                           &Item{ cx: self, item: it },\n+                           self.shared.css_file_extension.is_some())?;\n+        } else {\n+            let mut url = repeat(\"../\").take(self.current.len())\n+                                       .collect::<String>();\n+            if let Some(&(ref names, ty)) = cache().paths.get(&it.def_id) {\n+                for name in &names[..names.len() - 1] {\n+                    url.push_str(name);\n+                    url.push_str(\"/\");\n                 }\n+                url.push_str(&item_path(ty, names.last().unwrap()));\n+                layout::redirect(writer, &url)?;\n             }\n-            Ok(())\n         }\n+        Ok(())\n+    }\n \n+    /// Non-parallelized version of rendering an item. This will take the input\n+    /// item, render its contents, and then invoke the specified closure with\n+    /// all sub-items which need to be rendered.\n+    ///\n+    /// The rendering driver uses this closure to queue up more work.\n+    fn item<F>(&mut self, item: clean::Item, mut f: F) -> Result<(), Error> where\n+        F: FnMut(&mut Context, clean::Item),\n+    {\n         // Stripped modules survive the rustdoc passes (i.e. `strip-private`)\n         // if they contain impls for public types. These modules can also\n         // contain items such as publicly reexported structures.\n@@ -1371,7 +1374,7 @@ impl Context {\n                 let item = item.take().unwrap();\n \n                 let mut buf = Vec::new();\n-                render(&mut buf, this, &item, false).unwrap();\n+                this.render_item(&mut buf, &item, false).unwrap();\n                 // buf will be empty if the module is stripped and there is no redirect for it\n                 if !buf.is_empty() {\n                     let joint_dst = this.dst.join(\"index.html\");\n@@ -1386,7 +1389,7 @@ impl Context {\n                     _ => unreachable!()\n                 };\n \n-                // render sidebar-items.js used throughout this module\n+                // Render sidebar-items.js used throughout this module.\n                 if !this.render_redirect_pages {\n                     let items = this.build_sidebar_items(&m);\n                     let js_dst = this.dst.join(\"sidebar-items.js\");\n@@ -1398,23 +1401,34 @@ impl Context {\n                 for item in m.items {\n                     f(this,item);\n                 }\n+\n                 Ok(())\n-            })\n+            })?;\n         } else if item.name.is_some() {\n             let mut buf = Vec::new();\n-            render(&mut buf, self, &item, true).unwrap();\n+            self.render_item(&mut buf, &item, true).unwrap();\n             // buf will be empty if the item is stripped and there is no redirect for it\n             if !buf.is_empty() {\n-                let joint_dst = self.dst.join(&item_path(shortty(&item),\n-                                                         item.name.as_ref().unwrap()));\n+                let name = item.name.as_ref().unwrap();\n+                let item_type = item_type(&item);\n+                let file_name = &item_path(item_type, name);\n+                let joint_dst = self.dst.join(file_name);\n                 try_err!(fs::create_dir_all(&self.dst), &self.dst);\n                 let mut dst = try_err!(File::create(&joint_dst), &joint_dst);\n                 try_err!(dst.write_all(&buf), &joint_dst);\n+\n+                // Redirect from a sane URL using the namespace to Rustdoc's\n+                // URL for the page.\n+                let redir_name = format!(\"{}.{}.html\", name, item_type.name_space());\n+                let redir_dst = self.dst.join(redir_name);\n+                if let Ok(mut redirect_out) = OpenOptions::new().create_new(true)\n+                                                                .write(true)\n+                                                                .open(&redir_dst) {\n+                    try_err!(layout::redirect(&mut redirect_out, file_name), &redir_dst);\n+                }\n             }\n-            Ok(())\n-        } else {\n-            Ok(())\n         }\n+        Ok(())\n     }\n \n     fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n@@ -1423,7 +1437,7 @@ impl Context {\n         for item in &m.items {\n             if self.maybe_ignore_item(item) { continue }\n \n-            let short = shortty(item).to_static_str();\n+            let short = item_type(item).css_class();\n             let myname = match item.name {\n                 None => continue,\n                 Some(ref s) => s.to_string(),\n@@ -1531,7 +1545,7 @@ impl<'a> Item<'a> {\n             }\n             Some(format!(\"{path}{file}?gotosrc={goto}\",\n                          path = path,\n-                         file = item_path(shortty(self.item), external_path.last().unwrap()),\n+                         file = item_path(item_type(self.item), external_path.last().unwrap()),\n                          goto = self.item.def_id.index.as_usize()))\n         }\n     }\n@@ -1566,7 +1580,7 @@ impl<'a> fmt::Display for Item<'a> {\n             }\n         }\n         write!(fmt, \"<a class='{}' href=''>{}</a>\",\n-               shortty(self.item), self.item.name.as_ref().unwrap())?;\n+               item_type(self.item), self.item.name.as_ref().unwrap())?;\n \n         write!(fmt, \"</span>\")?; // in-band\n         write!(fmt, \"<span class='out-of-band'>\")?;\n@@ -1622,7 +1636,7 @@ impl<'a> fmt::Display for Item<'a> {\n fn item_path(ty: ItemType, name: &str) -> String {\n     match ty {\n         ItemType::Module => format!(\"{}/index.html\", name),\n-        _ => format!(\"{}.{}.html\", ty.to_static_str(), name),\n+        _ => format!(\"{}.{}.html\", ty.css_class(), name),\n     }\n }\n \n@@ -1714,8 +1728,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     }\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: usize, idx2: usize) -> Ordering {\n-        let ty1 = shortty(i1);\n-        let ty2 = shortty(i2);\n+        let ty1 = item_type(i1);\n+        let ty2 = item_type(i2);\n         if ty1 != ty2 {\n             return (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2))\n         }\n@@ -1739,7 +1753,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             continue;\n         }\n \n-        let myty = Some(shortty(myitem));\n+        let myty = Some(item_type(myitem));\n         if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n             // Put `extern crate` and `use` re-exports in the same section.\n             curty = myty;\n@@ -1825,9 +1839,9 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n                        docs = shorter(Some(&Markdown(doc_value).to_string())),\n-                       class = shortty(myitem),\n+                       class = item_type(myitem),\n                        stab = myitem.stability_class(),\n-                       href = item_path(shortty(myitem), myitem.name.as_ref().unwrap()),\n+                       href = item_path(item_type(myitem), myitem.name.as_ref().unwrap()),\n                        title = full_path(cx, myitem))?;\n             }\n         }\n@@ -2022,14 +2036,18 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     fn trait_item(w: &mut fmt::Formatter, cx: &Context, m: &clean::Item, t: &clean::Item)\n                   -> fmt::Result {\n         let name = m.name.as_ref().unwrap();\n-        let id = derive_id(format!(\"{}.{}\", shortty(m), name));\n-        write!(w, \"<h3 id='{id}' class='method stab {stab}'><code>\",\n+        let item_type = item_type(m);\n+        let id = derive_id(format!(\"{}.{}\", item_type, name));\n+        let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+        write!(w, \"<h3 id='{id}' class='method stab {stab}'>\\\n+                   <span id='{ns_id}' class='invisible'><code>\",\n                id = id,\n-               stab = m.stability_class())?;\n+               stab = m.stability_class(),\n+               ns_id = ns_id)?;\n         render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)))?;\n         write!(w, \"</code>\")?;\n         render_stability_since(w, m, t)?;\n-        write!(w, \"</h3>\")?;\n+        write!(w, \"</span></h3>\")?;\n         document(w, cx, m)?;\n         Ok(())\n     }\n@@ -2104,7 +2122,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                let (ref path, _) = cache.external_paths[&it.def_id];\n                path[..path.len() - 1].join(\"/\")\n            },\n-           ty = shortty(it).to_static_str(),\n+           ty = item_type(it).css_class(),\n            name = *it.name.as_ref().unwrap())?;\n     Ok(())\n }\n@@ -2113,7 +2131,7 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n     use html::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n-    let ty = match shortty(it) {\n+    let ty = match item_type(it) {\n         Typedef | AssociatedType => AssociatedType,\n         s@_ => s,\n     };\n@@ -2191,7 +2209,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n               link: AssocItemLink)\n               -> fmt::Result {\n         let name = meth.name.as_ref().unwrap();\n-        let anchor = format!(\"#{}.{}\", shortty(meth), name);\n+        let anchor = format!(\"#{}.{}\", item_type(meth), name);\n         let href = match link {\n             AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n             AssocItemLink::Anchor(None) => anchor,\n@@ -2268,9 +2286,19 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         if fields.peek().is_some() {\n             write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n             for (field, ty) in fields {\n-                write!(w, \"<span id='{shortty}.{name}' class='{shortty}'><code>{name}: {ty}</code>\n-                           </span><span class='stab {stab}'></span>\",\n-                       shortty = ItemType::StructField,\n+                let id = derive_id(format!(\"{}.{}\",\n+                                           ItemType::StructField,\n+                                           field.name.as_ref().unwrap()));\n+                let ns_id = derive_id(format!(\"{}.{}\",\n+                                              field.name.as_ref().unwrap(),\n+                                              ItemType::StructField.name_space()));\n+                write!(w, \"<span id='{id}' class='{item_type}'>\n+                           <span id='{ns_id}' class='invisible'>\n+                           <code>{name}: {ty}</code>\n+                           </span></span><span class='stab {stab}'></span>\",\n+                       item_type = ItemType::StructField,\n+                       id = id,\n+                       ns_id = ns_id,\n                        stab = field.stability_class(),\n                        name = field.name.as_ref().unwrap(),\n                        ty = ty)?;\n@@ -2339,8 +2367,16 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     if !e.variants.is_empty() {\n         write!(w, \"<h2 class='variants'>Variants</h2>\\n\")?;\n         for variant in &e.variants {\n-            write!(w, \"<span id='{shortty}.{name}' class='variant'><code>{name}\",\n-                   shortty = ItemType::Variant,\n+            let id = derive_id(format!(\"{}.{}\",\n+                                       ItemType::Variant,\n+                                       variant.name.as_ref().unwrap()));\n+            let ns_id = derive_id(format!(\"{}.{}\",\n+                                          variant.name.as_ref().unwrap(),\n+                                          ItemType::Variant.name_space()));\n+            write!(w, \"<span id='{id}' class='variant'>\\\n+                       <span id='{ns_id}' class='invisible'><code>{name}\",\n+                   id = id,\n+                   ns_id = ns_id,\n                    name = variant.name.as_ref().unwrap())?;\n             if let clean::VariantItem(ref var) = variant.inner {\n                 if let clean::TupleVariant(ref tys) = var.kind {\n@@ -2354,7 +2390,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                     write!(w, \")\")?;\n                 }\n             }\n-            write!(w, \"</code></span>\")?;\n+            write!(w, \"</code></span></span>\")?;\n             document(w, cx, variant)?;\n \n             use clean::{Variant, StructVariant};\n@@ -2364,10 +2400,20 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 for field in &s.fields {\n                     use clean::StructFieldItem;\n                     if let StructFieldItem(ref ty) = field.inner {\n+                        let id = derive_id(format!(\"variant.{}.field.{}\",\n+                                                   variant.name.as_ref().unwrap(),\n+                                                   field.name.as_ref().unwrap()));\n+                        let ns_id = derive_id(format!(\"{}.{}.{}.{}\",\n+                                                      variant.name.as_ref().unwrap(),\n+                                                      ItemType::Variant.name_space(),\n+                                                      field.name.as_ref().unwrap(),\n+                                                      ItemType::StructField.name_space()));\n                         write!(w, \"<tr><td \\\n-                                   id='variant.{v}.field.{f}'>\\\n-                                   <code>{f}:&nbsp;{t}</code></td><td>\",\n-                               v = variant.name.as_ref().unwrap(),\n+                                   id='{id}'>\\\n+                                   <span id='{ns_id}' class='invisible'>\\\n+                                   <code>{f}:&nbsp;{t}</code></span></td><td>\",\n+                               id = id,\n+                               ns_id = ns_id,\n                                f = field.name.as_ref().unwrap(),\n                                t = *ty)?;\n                         document(w, cx, field)?;\n@@ -2584,11 +2630,11 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         }\n     }\n \n-    fn doctraititem(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n-                    link: AssocItemLink, render_static: bool,\n-                    is_default_item: bool, outer_version: Option<&str>,\n-                    trait_: Option<&clean::Trait>) -> fmt::Result {\n-        let shortty = shortty(item);\n+    fn doc_impl_item(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n+                     link: AssocItemLink, render_static: bool,\n+                     is_default_item: bool, outer_version: Option<&str>,\n+                     trait_: Option<&clean::Trait>) -> fmt::Result {\n+        let item_type = item_type(item);\n         let name = item.name.as_ref().unwrap();\n \n         let is_static = match item.inner {\n@@ -2601,38 +2647,48 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 // Only render when the method is not static or we allow static methods\n                 if !is_static || render_static {\n-                    let id = derive_id(format!(\"{}.{}\", shortty, name));\n-                    write!(w, \"<h4 id='{}' class='{}'>\", id, shortty)?;\n+                    let id = derive_id(format!(\"{}.{}\", item_type, name));\n+                    let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                    write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                    write!(w, \"<span id='{}' class='invisible'>\", ns_id)?;\n                     write!(w, \"<code>\")?;\n                     render_assoc_item(w, item, link.anchor(&id))?;\n                     write!(w, \"</code>\")?;\n                     render_stability_since_raw(w, item.stable_since(), outer_version)?;\n-                    write!(w, \"</h4>\\n\")?;\n+                    write!(w, \"</span></h4>\\n\")?;\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n                 let id = derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id))?;\n-                write!(w, \"</code></h4>\\n\")?;\n+                write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n-                let id = derive_id(format!(\"{}.{}\", shortty, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                let id = derive_id(format!(\"{}.{}\", item_type, name));\n+                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id))?;\n-                write!(w, \"</code></h4>\\n\")?;\n+                write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::ConstantItem(ref c) => {\n-                let id = derive_id(format!(\"{}.{}\", shortty, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                let id = derive_id(format!(\"{}.{}\", item_type, name));\n+                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, &c.type_, Some(&c.expr), link.anchor(&id))?;\n-                write!(w, \"</code></h4>\\n\")?;\n+                write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n-                let id = derive_id(format!(\"{}.{}\", shortty, name));\n-                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty)?;\n+                let id = derive_id(format!(\"{}.{}\", item_type, name));\n+                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id))?;\n-                write!(w, \"</code></h4>\\n\")?;\n+                write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::StrippedItem(..) => return Ok(()),\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n@@ -2671,8 +2727,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n     write!(w, \"<div class='impl-items'>\")?;\n     for trait_item in &i.inner_impl().items {\n-        doctraititem(w, cx, trait_item, link, render_header,\n-                     false, outer_version, trait_)?;\n+        doc_impl_item(w, cx, trait_item, link, render_header,\n+                      false, outer_version, trait_)?;\n     }\n \n     fn render_default_items(w: &mut fmt::Formatter,\n@@ -2689,8 +2745,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             let did = i.trait_.as_ref().unwrap().def_id().unwrap();\n             let assoc_link = AssocItemLink::GotoSource(did, &i.provided_trait_methods);\n \n-            doctraititem(w, cx, trait_item, assoc_link, render_static, true,\n-                         outer_version, None)?;\n+            doc_impl_item(w, cx, trait_item, assoc_link, render_static, true,\n+                          outer_version, None)?;\n         }\n         Ok(())\n     }\n@@ -2749,7 +2805,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                    relpath: '{path}'\\\n                 }};</script>\",\n                name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n-               ty = shortty(it).to_static_str(),\n+               ty = item_type(it).css_class(),\n                path = relpath)?;\n         if parentlen == 0 {\n             // there is no sidebar-items.js beyond the crate root path"}, {"sha": "c97cacd10c3814f74109324409d2e825bb61a2ee", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -284,14 +284,20 @@ h3.impl > .out-of-band {\n     font-size: 21px;\n }\n \n-h4 > code, h3 > code {\n+h4 > code, h3 > code, invisible > code {\n     position: inherit;\n }\n \n .in-band, code {\n     z-index: 5;\n }\n \n+.invisible {\n+    background: rgba(0, 0, 0, 0);\n+    width: 100%;\n+    display: inline-block;\n+}\n+\n .content .in-band {\n     margin: 0px;\n     padding: 0px;\n@@ -660,6 +666,7 @@ span.since {\n \n :target > code {\n    background: #FDFFD3;\n+   opacity: 1;\n }\n \n /* Media Queries */"}, {"sha": "c64fb1b67f3d74dd130d9fc0589515f22fba0ed8", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -26,7 +26,7 @@ h1.fqn {\n h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n     border-bottom-color: #DDDDDD;\n }\n-.in-band, code {\n+.in-band {\n     background-color: white;\n }\n "}, {"sha": "fa37e9b54e4574d04c94088680b3738269f6b72c", "filename": "src/libsyntax/ext/proc_macro_shim.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This is a shim file to ease the transition to the final procedural macro interface for\n+//! Macros 2.0. It currently exposes the `libsyntax` operations that the quasiquoter's\n+//! output needs to compile correctly, along with the following operators:\n+//!\n+//! - `build_block_emitter`, which produces a `block` output macro result from the\n+//!   provided TokenStream.\n+\n+use ast;\n+use codemap::Span;\n+use parse::parser::Parser;\n+use ptr::P;\n+use tokenstream::TokenStream;\n+use ext::base::*;\n+\n+/// Take a `ExtCtxt`, `Span`, and `TokenStream`, and produce a Macro Result that parses\n+/// the TokenStream as a block and returns it as an `Expr`.\n+pub fn build_block_emitter<'cx>(cx: &'cx mut ExtCtxt, sp: Span, output: TokenStream)\n+                                -> Box<MacResult + 'cx> {\n+    let parser = cx.new_parser_from_tts(&output.to_tts());\n+\n+    struct Result<'a> {\n+        prsr: Parser<'a>,\n+        span: Span,\n+    }; //FIXME is this the right lifetime\n+\n+    impl<'a> Result<'a> {\n+        fn block(&mut self) -> P<ast::Block> {\n+            let res = self.prsr.parse_block().unwrap();\n+            res\n+        }\n+    }\n+\n+    impl<'a> MacResult for Result<'a> {\n+        fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n+            let mut me = *self;\n+            Some(P(ast::Expr {\n+                id: ast::DUMMY_NODE_ID,\n+                node: ast::ExprKind::Block(me.block()),\n+                span: me.span,\n+                attrs: ast::ThinVec::new(),\n+            }))\n+\n+        }\n+    }\n+\n+    Box::new(Result {\n+        prsr: parser,\n+        span: sp,\n+    })\n+}\n+\n+pub mod prelude {\n+    pub use ext::proc_macro_shim::build_block_emitter;\n+    pub use ast::Ident;\n+    pub use codemap::{DUMMY_SP, Span};\n+    pub use ext::base::{ExtCtxt, MacResult};\n+    pub use parse::token::{self, Token, DelimToken, keywords, str_to_ident};\n+    pub use tokenstream::{TokenTree, TokenStream};\n+}"}, {"sha": "b4311fc007d3db1b72cfbf05ddb9ca87fc922b71", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -128,6 +128,7 @@ pub mod ext {\n     pub mod build;\n     pub mod expand;\n     pub mod hygiene;\n+    pub mod proc_macro_shim;\n     pub mod quote;\n     pub mod source_util;\n "}, {"sha": "7b1df6f0e97bebcabf8c9970a14053c6b5533040", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -589,6 +589,12 @@ impl TokenStream {\n         TokenStream::mk_leaf(Rc::new(trees), span)\n     }\n \n+    /// Convert a vector of Tokens into a TokenStream.\n+    pub fn from_tokens(tokens: Vec<Token>) -> TokenStream {\n+        // FIXME do something nicer with the spans\n+        TokenStream::from_tts(tokens.into_iter().map(|t| TokenTree::Token(DUMMY_SP, t)).collect())\n+    }\n+\n     /// Manually change a TokenStream's span.\n     pub fn respan(self, span: Span) -> TokenStream {\n         match self.ts {"}, {"sha": "4f78519e13aa860096998f43bf8c0c30a1937dc9", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -40,6 +40,16 @@ version = \"0.0.0\"\n name = \"log\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"proc_macro\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc_plugin 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n [[package]]\n name = \"rbml\"\n version = \"0.0.0\"\n@@ -136,6 +146,7 @@ dependencies = [\n  \"flate 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"log 0.0.0\",\n+ \"proc_macro 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_borrowck 0.0.0\","}, {"sha": "47892781902ea8491fbdb9063236bfc30d14166c", "filename": "src/test/codegen-units/item-collection/trait-method-default-impl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-default-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-default-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftrait-method-default-impl.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -37,7 +37,7 @@ impl SomeGenericTrait<u64> for i32 {\n \n     // For the non-generic foo(), we should generate a codegen-item even if it\n     // is not called anywhere\n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::foo[0]<u64, i32>\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::foo[0]<i32, u64>\n }\n \n // Non-generic impl of generic trait\n@@ -54,16 +54,16 @@ fn main() {\n     //~ TRANS_ITEM fn trait_method_default_impl::SomeTrait[0]::bar[0]<i8, &str>\n     let _ = 2i8.bar(\"&str\");\n \n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<u64, i32, char>\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<i32, u64, char>\n     0i32.bar(0u64, 'c');\n \n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<u64, i32, &str>\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<i32, u64, &str>\n     0i32.bar(0u64, \"&str\");\n \n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<i8, u32, &[char; 1]>\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<u32, i8, &[char; 1]>\n     0u32.bar(0i8, &['c']);\n \n-    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<i16, u32, ()>\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<u32, i16, ()>\n     0u32.bar(0i16, ());\n }\n "}, {"sha": "ddf16a2278e5bd140cca704c6992e27dafb09f8e", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -25,7 +25,8 @@ impl Foo for Def {\n }\n \n pub fn test<A: Foo, B: Foo>() {\n-    let _array: [u32; <A as Foo>::Y]; //~ error: the parameter type\n+    let _array: [u32; <A as Foo>::Y];\n+    //~^ ERROR the trait bound `A: Foo` is not satisfied\n }\n \n fn main() {"}, {"sha": "2591d7bcbaef4e2cc73e50bc17ff70ae97d4f000", "filename": "src/test/compile-fail/issue-26548.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: overflow representing the type `S`\n+// error-pattern: overflow representing the type\n \n-#![feature(rustc_attrs)]\n \n trait Mirror { type It: ?Sized; }\n impl<T: ?Sized> Mirror for T { type It = Self; }\n struct S(Option<<S as Mirror>::It>);\n \n-#[rustc_no_mir] // FIXME #27840 MIR tries to represent `std::option::Option<S>` first.\n fn main() {\n     let _s = S(None);\n }"}, {"sha": "1dd008810788b0fb4a56bdd9bb35a609b3af2ec3", "filename": "src/test/compile-fail/issue-26812.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fissue-26812.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fissue-26812.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26812.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -10,5 +10,7 @@\n \n #![feature(default_type_parameter_fallback)]\n \n-fn avg<T=T::Item>(_: T) {} //~ ERROR associated type `Item` not found for `T`\n+fn avg<T=T::Item>(_: T) {}\n+//~^ ERROR type parameters with a default cannot use forward declared identifiers\n+\n fn main() {}"}, {"sha": "5539a26d2a1702df997d0457a511c76c9ea8ae67", "filename": "src/test/compile-fail/variance-associated-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -20,12 +20,12 @@ trait Trait<'a> {\n }\n \n #[rustc_variance]\n-struct Foo<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[[+];[];[]], regions=[[-];[];[]])\n+struct Foo<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[+], regions=[-])\n     field: (T, &'a ())\n }\n \n #[rustc_variance]\n-struct Bar<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[[o];[];[]], regions=[[o];[];[]])\n+struct Bar<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[o], regions=[o])\n     field: <T as Trait<'a>>::Type\n }\n "}, {"sha": "2f422bfd38cc7fcb340f3068b8a109e6faf3221e", "filename": "src/test/compile-fail/variance-object-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -18,7 +18,7 @@ use std::cell::Cell;\n // For better or worse, associated types are invariant, and hence we\n // get an invariant result for `'a`.\n #[rustc_variance]\n-struct Foo<'a> { //~ ERROR regions=[[o];[];[]]\n+struct Foo<'a> { //~ ERROR regions=[o]\n     x: Box<Fn(i32) -> &'a i32 + 'static>\n }\n "}, {"sha": "99416057b25408341ea5b60582dbaf79de2376b2", "filename": "src/test/compile-fail/variance-region-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -13,11 +13,11 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-trait Foo: 'static { //~ ERROR types=[[];[o];[]]\n+trait Foo: 'static { //~ ERROR types=[o]\n }\n \n #[rustc_variance]\n-trait Bar<T> { //~ ERROR types=[[o];[o];[]]\n+trait Bar<T> { //~ ERROR types=[o, o]\n     fn do_it(&self)\n         where T: 'static;\n }"}, {"sha": "78591063de8abc4db2094b6a42a1c1dd63562bd1", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -16,7 +16,7 @@\n // Regions that just appear in normal spots are contravariant:\n \n #[rustc_variance]\n-struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[]]\n+struct Test2<'a, 'b, 'c> { //~ ERROR regions=[-, -, -]\n     x: &'a isize,\n     y: &'b [isize],\n     c: &'c str\n@@ -25,7 +25,7 @@ struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[]]\n // Those same annotations in function arguments become covariant:\n \n #[rustc_variance]\n-struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[]]\n+struct Test3<'a, 'b, 'c> { //~ ERROR regions=[+, +, +]\n     x: extern \"Rust\" fn(&'a isize),\n     y: extern \"Rust\" fn(&'b [isize]),\n     c: extern \"Rust\" fn(&'c str),\n@@ -34,15 +34,15 @@ struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[]]\n // Mutability induces invariance:\n \n #[rustc_variance]\n-struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[]]\n+struct Test4<'a, 'b:'a> { //~ ERROR regions=[-, o]\n     x: &'a mut &'b isize,\n }\n \n // Mutability induces invariance, even when in a\n // contravariant context:\n \n #[rustc_variance]\n-struct Test5<'a, 'b:'a> { //~ ERROR regions=[[+, o];[];[]]\n+struct Test5<'a, 'b:'a> { //~ ERROR regions=[+, o]\n     x: extern \"Rust\" fn(&'a mut &'b isize),\n }\n \n@@ -52,22 +52,22 @@ struct Test5<'a, 'b:'a> { //~ ERROR regions=[[+, o];[];[]]\n // argument list occurs in an invariant context.\n \n #[rustc_variance]\n-struct Test6<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[]]\n+struct Test6<'a, 'b:'a> { //~ ERROR regions=[-, o]\n     x: &'a mut extern \"Rust\" fn(&'b isize),\n }\n \n // No uses at all is bivariant:\n \n #[rustc_variance]\n-struct Test7<'a> { //~ ERROR regions=[[*];[];[]]\n+struct Test7<'a> { //~ ERROR regions=[*]\n     //~^ ERROR parameter `'a` is never used\n     x: isize\n }\n \n // Try enums too.\n \n #[rustc_variance]\n-enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[]]\n+enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[+, -, o]\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),"}, {"sha": "d8af30da163bf8a735550357ce20257c5d865525", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -15,33 +15,33 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[];[]]\n+enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[+, -, o, *]\n     //~^ ERROR parameter `'d` is never used\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n-struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[]]\n+struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[*, o, -, +]\n     //~^ ERROR parameter `'w` is never used\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n-struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[];[]]\n+struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[o, o, *]\n     //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n-struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[]]\n+struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[o, -, *]\n     //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'b, 'a, 'c>\n }\n \n #[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n-struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[]]\n+struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[+, -, o]\n     f: Base<'a, 'b, 'c, 'a>\n }\n "}, {"sha": "150a1aa56fe721e956614328416e07c1b0eff0ca", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -15,48 +15,48 @@\n // influence variance.\n \n #[rustc_variance]\n-trait Getter<T> { //~ ERROR types=[[o];[o];[]]\n+trait Getter<T> { //~ ERROR types=[o, o]\n     fn get(&self) -> T;\n }\n \n #[rustc_variance]\n-trait Setter<T> { //~ ERROR types=[[o];[o];[]]\n+trait Setter<T> { //~ ERROR types=[o, o]\n     fn get(&self, T);\n }\n \n #[rustc_variance]\n-struct TestStruct<U,T:Setter<U>> { //~ ERROR types=[[+, +];[];[]]\n+struct TestStruct<U,T:Setter<U>> { //~ ERROR types=[+, +]\n     t: T, u: U\n }\n \n #[rustc_variance]\n-enum TestEnum<U,T:Setter<U>> {//~ ERROR types=[[*, +];[];[]]\n+enum TestEnum<U,T:Setter<U>> {//~ ERROR types=[*, +]\n     //~^ ERROR parameter `U` is never used\n     Foo(T)\n }\n \n #[rustc_variance]\n-trait TestTrait<U,T:Setter<U>> { //~ ERROR types=[[o, o];[o];[]]\n+trait TestTrait<U,T:Setter<U>> { //~ ERROR types=[o, o, o]\n     fn getter(&self, u: U) -> T;\n }\n \n #[rustc_variance]\n-trait TestTrait2<U> : Getter<U> { //~ ERROR types=[[o];[o];[]]\n+trait TestTrait2<U> : Getter<U> { //~ ERROR types=[o, o]\n }\n \n #[rustc_variance]\n-trait TestTrait3<U> { //~ ERROR types=[[o];[o];[]]\n+trait TestTrait3<U> { //~ ERROR types=[o, o]\n     fn getter<T:Getter<U>>(&self);\n }\n \n #[rustc_variance]\n-struct TestContraStruct<U,T:Setter<U>> { //~ ERROR types=[[*, +];[];[]]\n+struct TestContraStruct<U,T:Setter<U>> { //~ ERROR types=[*, +]\n     //~^ ERROR parameter `U` is never used\n     t: T\n }\n \n #[rustc_variance]\n-struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR types=[[*, +];[];[]]\n+struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR types=[*, +]\n     //~^ ERROR parameter `U` is never used\n     t: T\n }"}, {"sha": "4244b0e1d8b8b27104150a40cd03449694e724b0", "filename": "src/test/compile-fail/variance-trait-object-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -21,7 +21,7 @@ use std::mem;\n trait T { fn foo(&self); }\n \n #[rustc_variance]\n-struct TOption<'a> { //~ ERROR regions=[[-];[];[]]\n+struct TOption<'a> { //~ ERROR regions=[-]\n     v: Option<Box<T + 'a>>,\n }\n "}, {"sha": "c47710d6d376d0e2bcdf1354fd62cf2c7411687e", "filename": "src/test/compile-fail/variance-types-bounds.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -14,46 +14,46 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-struct TestImm<A, B> { //~ ERROR types=[[+, +];[];[]]\n+struct TestImm<A, B> { //~ ERROR types=[+, +]\n     x: A,\n     y: B,\n }\n \n #[rustc_variance]\n-struct TestMut<A, B:'static> { //~ ERROR types=[[+, o];[];[]]\n+struct TestMut<A, B:'static> { //~ ERROR types=[+, o]\n     x: A,\n     y: &'static mut B,\n }\n \n #[rustc_variance]\n-struct TestIndirect<A:'static, B:'static> { //~ ERROR types=[[+, o];[];[]]\n+struct TestIndirect<A:'static, B:'static> { //~ ERROR types=[+, o]\n     m: TestMut<A, B>\n }\n \n #[rustc_variance]\n-struct TestIndirect2<A:'static, B:'static> { //~ ERROR types=[[o, o];[];[]]\n+struct TestIndirect2<A:'static, B:'static> { //~ ERROR types=[o, o]\n     n: TestMut<A, B>,\n     m: TestMut<B, A>\n }\n \n #[rustc_variance]\n-trait Getter<A> { //~ ERROR types=[[o];[o];[]]\n+trait Getter<A> { //~ ERROR types=[o, o]\n     fn get(&self) -> A;\n }\n \n #[rustc_variance]\n-trait Setter<A> { //~ ERROR types=[[o];[o];[]]\n+trait Setter<A> { //~ ERROR types=[o, o]\n     fn set(&mut self, a: A);\n }\n \n #[rustc_variance]\n-trait GetterSetter<A> { //~ ERROR types=[[o];[o];[]]\n+trait GetterSetter<A> { //~ ERROR types=[o, o]\n     fn get(&self) -> A;\n     fn set(&mut self, a: A);\n }\n \n #[rustc_variance]\n-trait GetterInTypeBound<A> { //~ ERROR types=[[o];[o];[]]\n+trait GetterInTypeBound<A> { //~ ERROR types=[o, o]\n     // Here, the use of `A` in the method bound *does* affect\n     // variance.  Think of it as if the method requested a dictionary\n     // for `T:Getter<A>`.  Since this dictionary is an input, it is\n@@ -63,12 +63,12 @@ trait GetterInTypeBound<A> { //~ ERROR types=[[o];[o];[]]\n }\n \n #[rustc_variance]\n-trait SetterInTypeBound<A> { //~ ERROR types=[[o];[o];[]]\n+trait SetterInTypeBound<A> { //~ ERROR types=[o, o]\n     fn do_it<T:Setter<A>>(&self);\n }\n \n #[rustc_variance]\n-struct TestObject<A, R> { //~ ERROR types=[[o, o];[];[]]\n+struct TestObject<A, R> { //~ ERROR types=[o, o]\n     n: Box<Setter<A>+Send>,\n     m: Box<Getter<R>+Send>,\n }"}, {"sha": "d5164412358fc4dbba312b0e7dab4858ee6f61d5", "filename": "src/test/compile-fail/variance-types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -17,32 +17,32 @@ use std::cell::Cell;\n // not considered bivariant.\n \n #[rustc_variance]\n-struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR types=[[o, o];[];[]], regions=[[-];[];[]]\n+struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR types=[o, o], regions=[-]\n     t: &'a mut (A,B)\n }\n \n #[rustc_variance]\n-struct InvariantCell<A> { //~ ERROR types=[[o];[];[]]\n+struct InvariantCell<A> { //~ ERROR types=[o]\n     t: Cell<A>\n }\n \n #[rustc_variance]\n-struct InvariantIndirect<A> { //~ ERROR types=[[o];[];[]]\n+struct InvariantIndirect<A> { //~ ERROR types=[o]\n     t: InvariantCell<A>\n }\n \n #[rustc_variance]\n-struct Covariant<A> { //~ ERROR types=[[+];[];[]]\n+struct Covariant<A> { //~ ERROR types=[+]\n     t: A, u: fn() -> A\n }\n \n #[rustc_variance]\n-struct Contravariant<A> { //~ ERROR types=[[-];[];[]]\n+struct Contravariant<A> { //~ ERROR types=[-]\n     t: fn(A)\n }\n \n #[rustc_variance]\n-enum Enum<A,B,C> { //~ ERROR types=[[+, -, o];[];[]]\n+enum Enum<A,B,C> { //~ ERROR types=[+, -, o]\n     Foo(Covariant<A>),\n     Bar(Contravariant<B>),\n     Zed(Covariant<C>,Contravariant<C>)"}, {"sha": "f93447b642a2050b5aa5a98a5d53207624812547", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n fn main() {\n     let a = 0;\n     {\n@@ -25,7 +27,7 @@ fn main() {\n //         StorageLive(tmp1);               // scope 1 at storage_ranges.rs:14:18: 14:25\n //         StorageLive(tmp2);               // scope 1 at storage_ranges.rs:14:23: 14:24\n //         tmp2 = var0;                     // scope 1 at storage_ranges.rs:14:23: 14:24\n-//         tmp1 = std::prelude::v1::Some<i32>(tmp2,); // scope 1 at storage_ranges.rs:14:18: 14:25\n+//         tmp1 = std::option::Option<i32>::Some(tmp2,); // scope 1 at storage_ranges.rs:14:18: 14:25\n //         var1 = &tmp1;                    // scope 1 at storage_ranges.rs:14:17: 14:25\n //         StorageDead(tmp2);               // scope 1 at storage_ranges.rs:14:23: 14:24\n //         tmp0 = ();                       // scope 2 at storage_ranges.rs:13:5: 15:6"}, {"sha": "6aee63e2858e282bc1ca5890648face5cad1178d", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_noprelude_plugin.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_parens)]\n+#![feature(plugin)]\n+#![feature(plugin_registrar)]\n+#![feature(rustc_private)]\n+#![plugin(proc_macro)]\n+\n+extern crate rustc_plugin;\n+extern crate proc_macro;\n+extern crate syntax;\n+\n+use proc_macro::build::ident_eq;\n+\n+use syntax::ext::base::{ExtCtxt, MacResult};\n+use syntax::ext::proc_macro_shim::build_block_emitter;\n+use syntax::tokenstream::{TokenTree, TokenStream};\n+use syntax::parse::token::str_to_ident;\n+use syntax::codemap::Span;\n+\n+use rustc_plugin::Registry;\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_macro(\"cond\", cond);\n+}\n+\n+fn cond<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult + 'cx> {\n+    let output = cond_rec(TokenStream::from_tts(tts.clone().to_owned()));\n+    build_block_emitter(cx, sp, output)\n+}\n+\n+fn cond_rec(input: TokenStream) -> TokenStream {\n+  if input.is_empty() {\n+      return qquote!();\n+  }\n+\n+  let next = input.slice(0..1);\n+  let rest = input.slice_from(1..);\n+\n+  let clause : TokenStream = match next.maybe_delimited() {\n+    Some(ts) => ts,\n+    _ => panic!(\"Invalid input\"),\n+  };\n+\n+  // clause is ([test]) [rhs]\n+  if clause.len() < 2 { panic!(\"Invalid macro usage in cond: {:?}\", clause) }\n+\n+  let test: TokenStream = clause.slice(0..1);\n+  let rhs: TokenStream = clause.slice_from(1..);\n+\n+  if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+    qquote!({unquote(rhs)})\n+  } else {\n+    qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })\n+  }\n+}"}, {"sha": "8291c8a1e41c631971142edccb8372ead0ffadcd", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_plugin.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_parens)]\n+#![feature(plugin)]\n+#![feature(plugin_registrar)]\n+#![feature(rustc_private)]\n+#![plugin(proc_macro)]\n+\n+extern crate rustc_plugin;\n+extern crate proc_macro;\n+extern crate syntax;\n+\n+use proc_macro::prelude::*;\n+\n+use rustc_plugin::Registry;\n+\n+use syntax::ast::Ident;\n+use syntax::codemap::{DUMMY_SP, Span};\n+use syntax::ext::proc_macro_shim::build_block_emitter;\n+use syntax::ext::base::{ExtCtxt, MacResult};\n+use syntax::parse::token::{self, Token, DelimToken, keywords, str_to_ident};\n+use syntax::tokenstream::{TokenTree, TokenStream};\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_macro(\"cond\", cond);\n+}\n+\n+fn cond<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult + 'cx> {\n+    let output = cond_rec(TokenStream::from_tts(tts.clone().to_owned()));\n+    build_block_emitter(cx, sp, output)\n+}\n+\n+fn cond_rec(input: TokenStream) -> TokenStream {\n+  if input.is_empty() {\n+      return qquote!();\n+  }\n+\n+  let next = input.slice(0..1);\n+  let rest = input.slice_from(1..);\n+\n+  let clause : TokenStream = match next.maybe_delimited() {\n+    Some(ts) => ts,\n+    _ => panic!(\"Invalid input\"),\n+  };\n+\n+  // clause is ([test]) [rhs]\n+  if clause.len() < 2 { panic!(\"Invalid macro usage in cond: {:?}\", clause) }\n+\n+  let test: TokenStream = clause.slice(0..1);\n+  let rhs: TokenStream = clause.slice_from(1..);\n+\n+  if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+    qquote!({unquote(rhs)})\n+  } else {\n+    qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })\n+  }\n+}"}, {"sha": "2d92a0ef18199bac9162d96c9d7f534b248d15a7", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_prelude_plugin.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_parens)]\n+#![feature(plugin)]\n+#![feature(plugin_registrar)]\n+#![feature(rustc_private)]\n+#![plugin(proc_macro)]\n+\n+extern crate rustc_plugin;\n+extern crate proc_macro;\n+extern crate syntax;\n+\n+use syntax::ext::proc_macro_shim::prelude::*;\n+use proc_macro::prelude::*;\n+\n+use rustc_plugin::Registry;\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_macro(\"cond\", cond);\n+}\n+\n+fn cond<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult + 'cx> {\n+    let output = cond_rec(TokenStream::from_tts(tts.clone().to_owned()));\n+    build_block_emitter(cx, sp, output)\n+}\n+\n+fn cond_rec(input: TokenStream) -> TokenStream {\n+  if input.is_empty() {\n+      return qquote!();\n+  }\n+\n+  let next = input.slice(0..1);\n+  let rest = input.slice_from(1..);\n+\n+  let clause : TokenStream = match next.maybe_delimited() {\n+    Some(ts) => ts,\n+    _ => panic!(\"Invalid input\"),\n+  };\n+\n+  // clause is ([test]) [rhs]\n+  if clause.len() < 2 { panic!(\"Invalid macro usage in cond: {:?}\", clause) }\n+\n+  let test: TokenStream = clause.slice(0..1);\n+  let rhs: TokenStream = clause.slice_from(1..);\n+\n+  if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+    qquote!({unquote(rhs)})\n+  } else {\n+    qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })\n+  }\n+}"}, {"sha": "4ee775dec0cefc39dc17021a6e41080fe309406f", "filename": "src/test/run-pass-fulldeps/macro-quote-1.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage1\n+\n+#![feature(plugin)]\n+#![feature(rustc_private)]\n+#![plugin(proc_macro)]\n+\n+extern crate proc_macro;\n+use proc_macro::prelude::*;\n+\n+extern crate syntax;\n+use syntax::ast::Ident;\n+use syntax::codemap::DUMMY_SP;\n+use syntax::parse::token::{self, Token, keywords, str_to_ident};\n+\n+fn main() {\n+    let lex_true = lex(\"true\");\n+    assert_eq!(qquote!(true).eq_unspanned(&lex_true), true);\n+}"}, {"sha": "fa969b6a087cf1a40994a729d3c52dd1b6820d21", "filename": "src/test/run-pass-fulldeps/macro-quote-cond.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-cond.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:cond_plugin.rs\n+// ignore-stage1\n+\n+#![feature(plugin)]\n+#![feature(rustc_private)]\n+#![plugin(cond_plugin)]\n+\n+fn fact(n : i64) -> i64 {\n+    if n == 0 {\n+        1\n+    } else {\n+        n * fact(n - 1)\n+    }\n+}\n+\n+fn fact_cond(n : i64) -> i64 {\n+  cond!(\n+    ((n == 0) 1)\n+    (else (n * fact_cond(n-1)))\n+  )\n+}\n+\n+fn fib(n : i64) -> i64 {\n+  if n == 0 || n == 1 {\n+      1\n+  } else {\n+      fib(n-1) + fib(n-2)\n+  }\n+}\n+\n+fn fib_cond(n : i64) -> i64 {\n+  cond!(\n+    ((n == 0) 1)\n+    ((n == 1) 1)\n+    (else (fib_cond(n-1) + fib_cond(n-2)))\n+  )\n+}\n+\n+fn main() {\n+    assert_eq!(fact(3), fact_cond(3));\n+    assert_eq!(fact(5), fact_cond(5));\n+    assert_eq!(fib(5), fib_cond(5));\n+    assert_eq!(fib(8), fib_cond(8));\n+}"}, {"sha": "4184ca7be372f94f59b111c82dc6347fe2b3a92d", "filename": "src/test/run-pass-fulldeps/macro-quote-noprelude.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-noprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-noprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-noprelude.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:cond_noprelude_plugin.rs\n+// ignore-stage1\n+\n+#![feature(plugin)]\n+#![feature(rustc_private)]\n+#![plugin(cond_noprelude_plugin)]\n+\n+fn fact(n : i64) -> i64 {\n+    if n == 0 {\n+        1\n+    } else {\n+        n * fact(n - 1)\n+    }\n+}\n+\n+fn fact_cond(n : i64) -> i64 {\n+  cond!(\n+    ((n == 0) 1)\n+    (else (n * fact_cond(n-1)))\n+  )\n+}\n+\n+fn fib(n : i64) -> i64 {\n+  if n == 0 || n == 1 {\n+      1\n+  } else {\n+      fib(n-1) + fib(n-2)\n+  }\n+}\n+\n+fn fib_cond(n : i64) -> i64 {\n+  cond!(\n+    ((n == 0) 1)\n+    ((n == 1) 1)\n+    (else (fib_cond(n-1) + fib_cond(n-2)))\n+  )\n+}\n+\n+fn main() {\n+    assert_eq!(fact(3), fact_cond(3));\n+    assert_eq!(fact(5), fact_cond(5));\n+    assert_eq!(fib(5), fib_cond(5));\n+    assert_eq!(fib(8), fib_cond(8));\n+}"}, {"sha": "5b703a5bc2668a2a76c6155ce9a123bb82323179", "filename": "src/test/run-pass-fulldeps/macro-quote-prelude.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-prelude.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:cond_prelude_plugin.rs\n+// ignore-stage1\n+\n+#![feature(plugin)]\n+#![feature(rustc_private)]\n+#![plugin(cond_prelude_plugin)]\n+\n+fn fact(n : i64) -> i64 {\n+    if n == 0 {\n+        1\n+    } else {\n+        n * fact(n - 1)\n+    }\n+}\n+\n+fn fact_cond(n : i64) -> i64 {\n+  cond!(\n+    ((n == 0) 1)\n+    (else (n * fact_cond(n-1)))\n+  )\n+}\n+\n+fn fib(n : i64) -> i64 {\n+  if n == 0 || n == 1 {\n+      1\n+  } else {\n+      fib(n-1) + fib(n-2)\n+  }\n+}\n+\n+fn fib_cond(n : i64) -> i64 {\n+  cond!(\n+    ((n == 0) 1)\n+    ((n == 1) 1)\n+    (else (fib_cond(n-1) + fib_cond(n-2)))\n+  )\n+}\n+\n+fn main() {\n+    assert_eq!(fact(3), fact_cond(3));\n+    assert_eq!(fact(5), fact_cond(5));\n+    assert_eq!(fib(5), fib_cond(5));\n+    assert_eq!(fib(8), fib_cond(8));\n+}"}, {"sha": "e5485c356c2924867e2bbd0a8843b7e2bff8fe80", "filename": "src/test/rustdoc/assoc-types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frustdoc%2Fassoc-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frustdoc%2Fassoc-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-types.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -13,7 +13,9 @@\n // @has assoc_types/trait.Index.html\n pub trait Index<I: ?Sized> {\n     // @has - '//*[@id=\"associatedtype.Output\"]//code' 'type Output: ?Sized'\n+    // @has - '//*[@id=\"Output.t\"]//code' 'type Output: ?Sized'\n     type Output: ?Sized;\n+    // @has - '//*[@id=\"index.v\"]//code' 'fn index'\n     // @has - '//*[@id=\"tymethod.index\"]//code' \\\n     //      \"fn index<'a>(&'a self, index: I) -> &'a Self::Output\"\n     fn index<'a>(&'a self, index: I) -> &'a Self::Output;"}, {"sha": "15f7528b4ba21c234936a1f099d24f5129401c9f", "filename": "src/test/rustdoc/issue-19190.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frustdoc%2Fissue-19190.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frustdoc%2Fissue-19190.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-19190.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -23,6 +23,9 @@ impl Deref for Bar {\n     fn deref(&self) -> &Foo { loop {} }\n }\n \n+// @has issue_19190/Bar.t.html\n // @has issue_19190/struct.Bar.html\n+// @has - '//*[@id=\"foo.v\"]' 'fn foo(&self)'\n // @has - '//*[@id=\"method.foo\"]' 'fn foo(&self)'\n+// @!has - '//*[@id=\"static_foo.v\"]' 'fn static_foo()'\n // @!has - '//*[@id=\"method.static_foo\"]' 'fn static_foo()'"}, {"sha": "8c5bda7584c9f8bd54666ad7e436ffd9d005df29", "filename": "src/test/rustdoc/issue-21092.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frustdoc%2Fissue-21092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frustdoc%2Fissue-21092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-21092.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -13,6 +13,7 @@\n \n extern crate issue_21092;\n \n+// @has issue_21092/Bar.t.html\n // @has issue_21092/struct.Bar.html\n // @has - '//*[@id=\"associatedtype.Bar\"]' 'type Bar = i32'\n pub use issue_21092::{Foo, Bar};"}, {"sha": "0b6a8104661afa88186ef752e39e22f42e676068", "filename": "src/test/rustdoc/issue-25001.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frustdoc%2Fissue-25001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frustdoc%2Fissue-25001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-25001.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -19,14 +19,17 @@ pub trait Bar {\n \n impl Foo<u8> {\n     // @has - '//*[@id=\"method.pass\"]//code' 'fn pass()'\n+    // @has - '//*[@id=\"pass.v\"]//code' 'fn pass()'\n     pub fn pass() {}\n }\n impl Foo<u16> {\n     // @has - '//*[@id=\"method.pass-1\"]//code' 'fn pass() -> usize'\n+    // @has - '//*[@id=\"pass.v-1\"]//code' 'fn pass() -> usize'\n     pub fn pass() -> usize { 42 }\n }\n impl Foo<u32> {\n     // @has - '//*[@id=\"method.pass-2\"]//code' 'fn pass() -> isize'\n+    // @has - '//*[@id=\"pass.v-2\"]//code' 'fn pass() -> isize'\n     pub fn pass() -> isize { 42 }\n }\n "}, {"sha": "e946e2423167acb101a38f45b79ad9ba7864e714", "filename": "src/test/rustdoc/src-links.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frustdoc%2Fsrc-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frustdoc%2Fsrc-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsrc-links.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -24,11 +24,13 @@ pub mod bar {\n     // @has foo/bar/baz/index.html '//a/@href' '../../../src/foo/src-links.rs.html'\n     pub mod baz {\n         /// Dox\n+        // @has foo/bar/baz/baz.v.html\n         // @has foo/bar/baz/fn.baz.html '//a/@href' '../../../src/foo/src-links.rs.html'\n         pub fn baz() { }\n     }\n \n     /// Dox\n+    // @has foo/bar/Foobar.t.html\n     // @has foo/bar/trait.Foobar.html '//a/@href' '../../src/foo/src-links.rs.html'\n     pub trait Foobar { fn dummy(&self) { } }\n "}, {"sha": "c0bfe3ffe3cf9ee576832eb096b878b0351bd47f", "filename": "src/test/rustdoc/structfields.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frustdoc%2Fstructfields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftest%2Frustdoc%2Fstructfields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstructfields.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// @has structfields/Foo.t.html\n+// @has - struct.Foo.html\n // @has structfields/struct.Foo.html\n pub struct Foo {\n     // @has - //pre \"pub a: ()\"\n@@ -22,13 +24,17 @@ pub struct Foo {\n     pub d: usize,\n }\n \n+// @has structfields/Bar.t.html\n+// @has - struct.Bar.html\n // @has structfields/struct.Bar.html\n pub struct Bar {\n     // @has - //pre \"pub a: ()\"\n     pub a: (),\n     // @!has - //pre \"// some fields omitted\"\n }\n \n+// @has structfields/Qux.t.html\n+// @has - enum.Qux.html\n // @has structfields/enum.Qux.html\n pub enum Qux {\n     Quz {"}, {"sha": "4932fd5147afa8ba2a9f023cb71e6278f9509344", "filename": "src/tools/tidy/src/cargo.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1efbd08ed10595ba2a9ac942be23bfb84d977f/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs?ref=6a1efbd08ed10595ba2a9ac942be23bfb84d977f", "patch": "@@ -88,6 +88,12 @@ fn verify(tomlfile: &Path, libfile: &Path, bad: &mut bool) {\n             continue\n         }\n \n+        // We want the compiler to depend on the proc_macro crate so that it is built and\n+        // included in the end, but we don't want to actually use it in the compiler.\n+        if toml.contains(\"name = \\\"rustc_driver\\\"\") && krate == \"proc_macro\" {\n+            continue\n+        }\n+\n         if !librs.contains(&format!(\"extern crate {}\", krate)) {\n             println!(\"{} doesn't have `extern crate {}`, but Cargo.toml \\\n                       depends on it\", libfile.display(), krate);"}]}