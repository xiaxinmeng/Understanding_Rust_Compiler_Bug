{"sha": "4b4eabad3c3ce45812b08692b78d5c0d2e0d4dc2", "node_id": "C_kwDOAAsO6NoAKDRiNGVhYmFkM2MzY2U0NTgxMmIwODY5MmI3OGQ1YzBkMmUwZDRkYzI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-27T10:25:34Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-27T10:25:34Z"}, "message": "Record method resolution for try expressions", "tree": {"sha": "5723e5b94dc8b33f947ed3ab62a2444c0a7b9ffd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5723e5b94dc8b33f947ed3ab62a2444c0a7b9ffd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b4eabad3c3ce45812b08692b78d5c0d2e0d4dc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b4eabad3c3ce45812b08692b78d5c0d2e0d4dc2", "html_url": "https://github.com/rust-lang/rust/commit/4b4eabad3c3ce45812b08692b78d5c0d2e0d4dc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b4eabad3c3ce45812b08692b78d5c0d2e0d4dc2/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7f81e3cdcdd65077893b170378179ec89eab347", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f81e3cdcdd65077893b170378179ec89eab347", "html_url": "https://github.com/rust-lang/rust/commit/a7f81e3cdcdd65077893b170378179ec89eab347"}], "stats": {"total": 46, "additions": 29, "deletions": 17}, "files": [{"sha": "571b3e9686317005727bc1f41c1c543863579c8b", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4b4eabad3c3ce45812b08692b78d5c0d2e0d4dc2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b4eabad3c3ce45812b08692b78d5c0d2e0d4dc2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=4b4eabad3c3ce45812b08692b78d5c0d2e0d4dc2", "patch": "@@ -938,19 +938,24 @@ impl<'a> InferenceContext<'a> {\n         self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n-    fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(LangItem::Try)?.as_trait()?;\n+    fn resolve_output_on(&self, trait_: TraitId) -> Option<TypeAliasId> {\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n+    fn resolve_lang_trait(&self, lang: LangItem) -> Option<TraitId> {\n+        self.resolve_lang_item(lang)?.as_trait()\n+    }\n+\n+    fn resolve_ops_try_output(&self) -> Option<TypeAliasId> {\n+        self.resolve_output_on(self.resolve_lang_trait(LangItem::Try)?)\n+    }\n+\n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(LangItem::Neg)?.as_trait()?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n+        self.resolve_output_on(self.resolve_lang_trait(LangItem::Neg)?)\n     }\n \n     fn resolve_ops_not_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(LangItem::Not)?.as_trait()?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n+        self.resolve_output_on(self.resolve_lang_trait(LangItem::Not)?)\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n@@ -960,7 +965,7 @@ impl<'a> InferenceContext<'a> {\n             .lookup(self.db.upcast())\n             .container\n         else { return None };\n-        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n+        self.resolve_output_on(trait_)\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n@@ -998,13 +1003,8 @@ impl<'a> InferenceContext<'a> {\n         Some(struct_.into())\n     }\n \n-    fn resolve_ops_index(&self) -> Option<TraitId> {\n-        self.resolve_lang_item(LangItem::Index)?.as_trait()\n-    }\n-\n     fn resolve_ops_index_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_ops_index()?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n+        self.resolve_output_on(self.resolve_lang_trait(LangItem::Index)?)\n     }\n \n     fn resolve_va_list(&self) -> Option<AdtId> {"}, {"sha": "7b9bf0c5cf3deb7d6e6abfbb2bb4867f315ee321", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b4eabad3c3ce45812b08692b78d5c0d2e0d4dc2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b4eabad3c3ce45812b08692b78d5c0d2e0d4dc2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=4b4eabad3c3ce45812b08692b78d5c0d2e0d4dc2", "patch": "@@ -13,6 +13,7 @@ use hir_def::{\n         ArithOp, Array, BinaryOp, ClosureKind, Expr, ExprId, LabelId, Literal, Statement, UnaryOp,\n     },\n     generics::TypeOrConstParamData,\n+    lang_item::LangItem,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n     ConstParamId, FieldId, ItemContainerId, Lookup,\n@@ -157,7 +158,8 @@ impl<'a> InferenceContext<'a> {\n                 }\n \n                 // The ok-ish type that is expected from the last expression\n-                let ok_ty = self.resolve_associated_type(try_ty.clone(), self.resolve_ops_try_ok());\n+                let ok_ty =\n+                    self.resolve_associated_type(try_ty.clone(), self.resolve_ops_try_output());\n \n                 self.with_breakable_ctx(BreakableKind::Block, ok_ty.clone(), None, |this| {\n                     this.infer_expr(*body, &Expectation::has_type(ok_ty));\n@@ -593,9 +595,19 @@ impl<'a> InferenceContext<'a> {\n                 self.resolve_associated_type(inner_ty, self.resolve_future_future_output())\n             }\n             Expr::Try { expr } => {\n-                // FIXME: Note down method resolution her\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                self.resolve_associated_type(inner_ty, self.resolve_ops_try_ok())\n+                if let Some(trait_) = self.resolve_lang_trait(LangItem::Try) {\n+                    if let Some(func) = self.db.trait_data(trait_).method_by_name(&name!(branch)) {\n+                        let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n+                            .push(inner_ty.clone())\n+                            .build();\n+                        self.write_method_resolution(tgt_expr, func, subst.clone());\n+                    }\n+                    let try_output = self.resolve_output_on(trait_);\n+                    self.resolve_associated_type(inner_ty, try_output)\n+                } else {\n+                    self.err_ty()\n+                }\n             }\n             Expr::Cast { expr, type_ref } => {\n                 // FIXME: propagate the \"castable to\" expectation (and find a test case that shows this is necessary)\n@@ -744,7 +756,7 @@ impl<'a> InferenceContext<'a> {\n                 let base_ty = self.infer_expr_inner(*base, &Expectation::none());\n                 let index_ty = self.infer_expr(*index, &Expectation::none());\n \n-                if let Some(index_trait) = self.resolve_ops_index() {\n+                if let Some(index_trait) = self.resolve_lang_trait(LangItem::Index) {\n                     let canonicalized = self.canonicalize(base_ty.clone());\n                     let receiver_adjustments = method_resolution::resolve_indexing_op(\n                         self.db,"}]}