{"sha": "201cab84e8f12ec73131ac4908e6779b277449a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMWNhYjg0ZThmMTJlYzczMTMxYWM0OTA4ZTY3NzliMjc3NDQ5YTI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-22T22:13:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-29T15:39:22Z"}, "message": "Move rust's uv implementation to its own crate\n\nThere are a few reasons that this is a desirable move to take:\n\n1. Proof of concept that a third party event loop is possible\n2. Clear separation of responsibility between rt::io and the uv-backend\n3. Enforce in the future that the event loop is \"pluggable\" and replacable\n\nHere's a quick summary of the points of this pull request which make this\npossible:\n\n* Two new lang items were introduced: event_loop, and event_loop_factory.\n  The idea of a \"factory\" is to define a function which can be called with no\n  arguments and will return the new event loop as a trait object. This factory\n  is emitted to the crate map when building an executable. The factory doesn't\n  have to exist, and when it doesn't then an empty slot is in the crate map and\n  a basic event loop with no I/O support is provided to the runtime.\n\n* When building an executable, then the rustuv crate will be linked by default\n  (providing a default implementation of the event loop) via a similar method to\n  injecting a dependency on libstd. This is currently the only location where\n  the rustuv crate is ever linked.\n\n* There is a new #[no_uv] attribute (implied by #[no_std]) which denies\n  implicitly linking to rustuv by default\n\nCloses #5019", "tree": {"sha": "2312f91c2280a1463c179753fe6123b27a77ae9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2312f91c2280a1463c179753fe6123b27a77ae9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/201cab84e8f12ec73131ac4908e6779b277449a2", "comment_count": 11, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/201cab84e8f12ec73131ac4908e6779b277449a2", "html_url": "https://github.com/rust-lang/rust/commit/201cab84e8f12ec73131ac4908e6779b277449a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/201cab84e8f12ec73131ac4908e6779b277449a2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dd1583c57fbee9a07ac1111858871c241a24c50", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd1583c57fbee9a07ac1111858871c241a24c50", "html_url": "https://github.com/rust-lang/rust/commit/5dd1583c57fbee9a07ac1111858871c241a24c50"}], "stats": {"total": 7266, "additions": 7105, "deletions": 161}, "files": [{"sha": "e4b08b2546ae8fd8b7aa1246beb02ac61a37f7a8", "filename": "Makefile.in", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -221,19 +221,22 @@ CFG_LIBRUSTC_$(1) :=$(call CFG_LIB_NAME_$(1),rustc)\n CFG_LIBSYNTAX_$(1) :=$(call CFG_LIB_NAME_$(1),syntax)\n CFG_LIBRUSTPKG_$(1) :=$(call CFG_LIB_NAME_$(1),rustpkg)\n CFG_LIBRUSTDOC_$(1) :=$(call CFG_LIB_NAME_$(1),rustdoc)\n+CFG_LIBRUSTUV_$(1) :=$(call CFG_LIB_NAME_$(1),rustuv)\n \n EXTRALIB_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),extra)\n STDLIB_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),std)\n LIBRUSTC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustc)\n LIBSYNTAX_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),syntax)\n LIBRUSTPKG_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustpkg)\n LIBRUSTDOC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustdoc)\n+LIBRUSTUV_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustuv)\n EXTRALIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),extra)\n STDLIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),std)\n LIBRUSTC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustc)\n LIBSYNTAX_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),syntax)\n LIBRUSTPKG_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustpkg)\n LIBRUSTDOC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustdoc)\n+LIBRUSTUV_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustuv)\n \n endef\n \n@@ -289,6 +292,14 @@ EXTRALIB_CRATE := $(S)src/libextra/extra.rs\n EXTRALIB_INPUTS := $(wildcard $(addprefix $(S)src/libextra/,          \\\n                                           *.rs */*.rs))\n \n+######################################################################\n+# Rust UV library variables\n+######################################################################\n+\n+LIBRUSTUV_CRATE := $(S)src/librustuv/rustuv.rs\n+LIBRUSTUV_INPUTS := $(wildcard $(addprefix $(S)src/librustuv/,          \\\n+                                          *.rs */*.rs))\n+\n ######################################################################\n # rustc crate variables\n ######################################################################\n@@ -410,6 +421,11 @@ else\n     $$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTC_$(3))\n   TLIBRUSTC_DEFAULT$(1)_T_$(2)_H_$(3) = \\\n     $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2))\n+\n+  HLIBRUSTUV_DEFAULT$(1)_H_$(3) = \\\n+    $$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTUV_$(3))\n+  TLIBRUSTUV_DEFAULT$(1)_T_$(2)_H_$(3) = \\\n+    $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTUV_$(2))\n endif\n \n # Preqrequisites for using the stageN compiler\n@@ -421,6 +437,7 @@ HSREQ$(1)_H_$(3) = \\\n \t$$(HEXTRALIB_DEFAULT$(1)_H_$(3)) \\\n \t$$(HLIBSYNTAX_DEFAULT$(1)_H_$(3)) \\\n \t$$(HLIBRUSTC_DEFAULT$(1)_H_$(3)) \\\n+\t$$(HLIBRUSTUV_DEFAULT$(1)_H_$(3)) \\\n \t$$(MKFILE_DEPS)\n \n # Prerequisites for using the stageN compiler to build target artifacts\n@@ -433,7 +450,8 @@ TSREQ$(1)_T_$(2)_H_$(3) = \\\n SREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2))\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2)) \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTUV_$(2))\n \n # Prerequisites for a working stageN compiler and libraries, for a specific target\n CSREQ$(1)_T_$(2)_H_$(3) = \\\n@@ -447,7 +465,8 @@ CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(2))  \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2))\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2)) \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTUV_$(2))\n \n ifeq ($(1),0)\n # Don't run the the stage0 compiler under valgrind - that ship has sailed"}, {"sha": "a46e7fa4f3ff808526950c0af5de7f6f25786b23", "filename": "mk/clean.mk", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -73,6 +73,7 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_RUNTIME_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_STDLIB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_EXTRALIB_$(2))\n+\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTUV_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTC_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBSYNTAX_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(STDLIB_GLOB_$(2))\n@@ -103,10 +104,12 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUNTIME_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2))\n+\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTUV_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(STDLIB_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(EXTRALIB_GLOB_$(2))\n+\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTUV_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTC_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBSYNTAX_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTPKG_GLOB_$(2))"}, {"sha": "537e737a29af6e10c48959eef38130e75c9f6946", "filename": "mk/host.mk", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Fhost.mk", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Fhost.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fhost.mk?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -30,6 +30,7 @@ $$(HBIN$(2)_H_$(4))/rustc$$(X_$(4)): \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4)) \\\n \t$$(HSTDLIB_DEFAULT$(2)_H_$(4)) \\\n \t$$(HEXTRALIB_DEFAULT$(2)_H_$(4)) \\\n+\t$$(HLIBRUSTUV_DEFAULT$(2)_H_$(4)) \\\n \t| $$(HBIN$(2)_H_$(4))/\n \n \t@$$(call E, cp: $$@)\n@@ -42,6 +43,7 @@ $$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4)): \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_RUSTLLVM_$(4)) \\\n \t$$(HSTDLIB_DEFAULT$(2)_H_$(4)) \\\n \t$$(HEXTRALIB_DEFAULT$(2)_H_$(4)) \\\n+\t$$(HLIBRUSTUV_DEFAULT$(2)_H_$(4)) \\\n \t| $$(HLIB$(2)_H_$(4))/\n \n \t@$$(call E, cp: $$@)\n@@ -58,6 +60,7 @@ $$(HLIB$(2)_H_$(4))/$(CFG_LIBSYNTAX_$(4)): \\\n \t$$(HLIB$(2)_H_$(4))/$(CFG_RUSTLLVM_$(4)) \\\n \t$$(HSTDLIB_DEFAULT$(2)_H_$(4)) \\\n \t$$(HEXTRALIB_DEFAULT$(2)_H_$(4)) \\\n+\t$$(HLIBRUSTUV_DEFAULT$(2)_H_$(4)) \\\n \t| $$(HLIB$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBSYNTAX_GLOB_$(4)),$$(notdir $$@))\n@@ -80,7 +83,7 @@ $$(HLIB$(2)_H_$(4))/$(CFG_STDLIB_$(4)): \\\n \t@$$(call E, cp: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(STDLIB_GLOB_$(4)),$$(notdir $$@))\n \t$$(Q)cp $$< $$@\n-# Subtle: We do not let the shell expand $(STDLIB_DSYM_GLOB) directly rather\n+# Subtle: We do not let the shell expand $$(STDLIB_DSYM_GLOB) directly rather\n # we use Make's $$(wildcard) facility. The reason is that, on mac, when using\n # USE_SNAPSHOT_STDLIB, we copy the std.dylib file out of the snapshot.\n # In that case, there is no .dSYM file.  Annoyingly, bash then refuses to expand\n@@ -105,6 +108,19 @@ $$(HLIB$(2)_H_$(4))/$(CFG_EXTRALIB_$(4)): \\\n \t        $$(HLIB$(2)_H_$(4))\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(EXTRALIB_GLOB_$(4)),$$(notdir $$@))\n \n+$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTUV_$(4)): \\\n+\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTUV_$(4)) \\\n+\t$$(HLIB$(2)_H_$(4))/$(CFG_STDLIB_$(4)) \\\n+\t$$(HLIB$(2)_H_$(4))/$(CFG_RUNTIME_$(4)) \\\n+\t| $$(HLIB$(2)_H_$(4))/\n+\t@$$(call E, cp: $$@)\n+\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(4)),$$(notdir $$@))\n+\t$$(Q)cp $$< $$@\n+\t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBRUSTUV_GLOB_$(4)) \\\n+\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBRUSTUV_DSYM_GLOB_$(4))) \\\n+\t        $$(HLIB$(2)_H_$(4))\n+\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(4)),$$(notdir $$@))\n+\n $$(HLIB$(2)_H_$(4))/libstd.rlib: \\\n \t$$(TLIB$(1)_T_$(4)_H_$(3))/libstd.rlib \\\n \t$$(HLIB$(2)_H_$(4))/$$(CFG_RUNTIME_$(4)) \\"}, {"sha": "16af433e57518a87df5968a9799c2cab43dd79c6", "filename": "mk/install.mk", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -91,6 +91,7 @@ install-target-$(1)-host-$(2): $$(TSREQ$$(ISTAGE)_T_$(1)_H_$(2)) $$(SREQ$$(ISTAG\n \t$$(Q)$$(call INSTALL_LIB,$$(CFG_RUNTIME_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(STDLIB_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(EXTRALIB_GLOB_$(1)))\n+\t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTUV_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,libmorestack.a)\n \n endef\n@@ -104,6 +105,7 @@ install-target-$(1)-host-$(2): $$(CSREQ$$(ISTAGE)_T_$(1)_H_$(2))\n \t$$(Q)$$(call INSTALL_LIB,$$(CFG_RUSTLLVM_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(STDLIB_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(EXTRALIB_GLOB_$(1)))\n+\t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTUV_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTC_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBSYNTAX_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTPKG_GLOB_$(1)))\n@@ -143,6 +145,7 @@ install-host: $(CSREQ$(ISTAGE)_T_$(CFG_BUILD_TRIPLE)_H_$(CFG_BUILD_TRIPLE))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustdoc$(X_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(STDLIB_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(EXTRALIB_GLOB_$(CFG_BUILD_TRIPLE)))\n+\t$(Q)$(call INSTALL_LIB,$(LIBRUSTUV_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTC_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBSYNTAX_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTPKG_GLOB_$(CFG_BUILD_TRIPLE)))\n@@ -168,6 +171,7 @@ uninstall:\n \t$(Q)for i in \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(STDLIB_GLOB_$(CFG_BUILD_TRIPLE))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(EXTRALIB_GLOB_$(CFG_BUILD_TRIPLE))) \\\n+          $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTUV_GLOB_$(CFG_BUILD_TRIPLE))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTC_GLOB_$(CFG_BUILD_TRIPLE))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBSYNTAX_GLOB_$(CFG_BUILD_TRIPLE))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTPKG_GLOB_$(CFG_BUILD_TRIPLE))) \\\n@@ -230,6 +234,7 @@ install-runtime-target-$(1)-host-$(2): $$(TSREQ$$(ISTAGE)_T_$(1)_H_$(2)) $$(SREQ\n \t$(Q)$(call ADB_PUSH,$$(TL$(1)$(2))/$$(CFG_RUNTIME_$(1)),$(CFG_RUNTIME_PUSH_DIR))\n \t$(Q)$(call ADB_PUSH,$$(TL$(1)$(2))/$$(STDLIB_GLOB_$(1)),$(CFG_RUNTIME_PUSH_DIR))\n \t$(Q)$(call ADB_PUSH,$$(TL$(1)$(2))/$$(EXTRALIB_GLOB_$(1)),$(CFG_RUNTIME_PUSH_DIR))\n+\t$(Q)$(call ADB_PUSH,$$(TL$(1)$(2))/$$(LIBRUSTUV_GLOB_$(1)),$(CFG_RUNTIME_PUSH_DIR))\n endef\n \n define INSTALL_RUNTIME_TARGET_CLEANUP_N\n@@ -238,6 +243,7 @@ install-runtime-target-$(1)-cleanup:\n \t$(Q)$(call ADB_SHELL,rm,$(CFG_RUNTIME_PUSH_DIR)/$(CFG_RUNTIME_$(1)))\n \t$(Q)$(call ADB_SHELL,rm,$(CFG_RUNTIME_PUSH_DIR)/$(STDLIB_GLOB_$(1)))\n \t$(Q)$(call ADB_SHELL,rm,$(CFG_RUNTIME_PUSH_DIR)/$(EXTRALIB_GLOB_$(1)))\n+\t$(Q)$(call ADB_SHELL,rm,$(CFG_RUNTIME_PUSH_DIR)/$(LIBRUSTUV_GLOB_$(1)))\n endef\n \n $(eval $(call INSTALL_RUNTIME_TARGET_N,arm-linux-androideabi,$(CFG_BUILD_TRIPLE)))"}, {"sha": "c919509cbab7284bba58b3f886fee7ce21e0b704", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -148,7 +148,7 @@ $$(RT_BUILD_DIR_$(1)_$(2))/$(CFG_RUNTIME_$(1)): $$(RUNTIME_OBJS_$(1)_$(2)) $$(MK\n \n # These could go in rt.mk or rustllvm.mk, they're needed for both.\n \n-# This regexp has a single $, escaped twice\n+# This regexp has a single $$ escaped twice\n $(1)/%.bsd.def:    %.def.in $$(MKFILE_DEPS)\n \t@$$(call E, def: $$@)\n \t$$(Q)echo \"{\" > $$@"}, {"sha": "a3d3446298b5156471b61fe3a7fa586081faadaf", "filename": "mk/stage0.mk", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Fstage0.mk", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Fstage0.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage0.mk?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -42,6 +42,11 @@ $(HLIB0_H_$(CFG_BUILD_TRIPLE))/$(CFG_EXTRALIB_$(CFG_BUILD_TRIPLE)): \\\n \t\t| $(HLIB0_H_$(CFG_BUILD_TRIPLE))/\n \t$(Q)touch $@\n \n+$(HLIB0_H_$(CFG_BUILD_TRIPLE))/$(CFG_LIBRUSTUV_$(CFG_BUILD_TRIPLE)): \\\n+\t\t$(HBIN0_H_$(CFG_BUILD_TRIPLE))/rustc$(X_$(CFG_BUILD_TRIPLE)) \\\n+\t\t| $(HLIB0_H_$(CFG_BUILD_TRIPLE))/\n+\t$(Q)touch $@\n+\n $(HLIB0_H_$(CFG_BUILD_TRIPLE))/$(CFG_LIBRUSTC_$(CFG_BUILD_TRIPLE)): \\\n \t\t$(HBIN0_H_$(CFG_BUILD_TRIPLE))/rustc$(X_$(CFG_BUILD_TRIPLE)) \\\n \t\t| $(HLIB0_H_$(CFG_BUILD_TRIPLE))/\n@@ -81,9 +86,9 @@ $$(HLIB0_H_$(1))/$(CFG_STDLIB_$(1)): \\\n \t\t$$(TLIB$(2)_T_$(1)_H_$(3))/$(CFG_STDLIB_$(1)) \\\n \t\t| $(HLIB0_H_$(1))/\n \t@$$(call E, cp: $$@)\n-\t$$(call CHECK_FOR_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(EXTRALIB_GLOB_$(4)),$$(notdir $$@))\n+\t$$(call CHECK_FOR_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(STDLIB_GLOB_$(4)),$$(notdir $$@))\n \t$$(Q)cp $$(TLIB$(2)_T_$(1)_H_$(3))/$(STDLIB_GLOB_$(1)) $$@\n-\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(EXTRALIB_GLOB_$(4)),$$(notdir $$@))\n+\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(STDLIB_GLOB_$(4)),$$(notdir $$@))\n \n $$(HLIB0_H_$(1))/$(CFG_EXTRALIB_$(1)): \\\n \t\t$$(TLIB$(2)_T_$(1)_H_$(3))/$(CFG_EXTRALIB_$(1)) \\\n@@ -93,6 +98,18 @@ $$(HLIB0_H_$(1))/$(CFG_EXTRALIB_$(1)): \\\n \t$$(Q)cp $$(TLIB$(2)_T_$(1)_H_$(3))/$(EXTRALIB_GLOB_$(1)) $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(EXTRALIB_GLOB_$(4)),$$(notdir $$@))\n \n+$$(HLIB0_H_$(1))/$(CFG_LIBRUSTUV_$(1)):\n+\ttouch $$@\n+# NOTE: this should get uncommented after a snapshot and the rule above this can\n+#\tget deleted, right now we're not expecting a librustuv in a snapshot.\n+# $$(HLIB0_H_$(1))/$(CFG_LIBRUSTUV_$(1)): \\\n+# \t\t$$(TLIB$(2)_T_$(1)_H_$(3))/$(CFG_LIBRUSTUV_$(1)) \\\n+# \t\t| $(HLIB0_H_$(1))/\n+# \t@$$(call E, cp: $$@)\n+# \t$$(call CHECK_FOR_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(4)),$$(notdir $$@))\n+# \t$$(Q)cp $$(TLIB$(2)_T_$(1)_H_$(3))/$(LIBRUSTUV_GLOB_$(1)) $$@\n+# \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(4)),$$(notdir $$@))\n+\n $$(HLIB0_H_$(1))/$(CFG_LIBRUSTC_$(1)): \\\n \t\t$$(TLIB$(2)_T_$(1)_H_$(3))/$(CFG_LIBRUSTC_$(1)) \\\n \t\t| $(HLIB0_H_$(1))/"}, {"sha": "e71ca152e9a8134b53049167999dc662ef678135", "filename": "mk/target.mk", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -73,11 +73,22 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2)): \\\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) $$(WFLAGS_ST$(1)) --out-dir $$(@D) $$< && touch $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(EXTRALIB_GLOB_$(2)),$$(notdir $$@))\n \n+$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTUV_$(2)): \\\n+\t\t$$(LIBRUSTUV_CRATE) $$(LIBRUSTUV_INPUTS) \\\n+\t        $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)) \\\n+\t\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n+\t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(2)),$$(notdir $$@))\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) $$(WFLAGS_ST$(1)) --out-dir $$(@D) $$< && touch $$@\n+\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTUV_GLOB_$(2)),$$(notdir $$@))\n+\n $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(3)): \\\n                 $$(LIBSYNTAX_CRATE) $$(LIBSYNTAX_INPUTS) \\\n \t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\t\t\t\\\n \t\t$$(TSTDLIB_DEFAULT$(1)_T_$(2)_H_$(3))      \\\n \t\t$$(TEXTRALIB_DEFAULT$(1)_T_$(2)_H_$(3)) \\\n+\t\t$$(TLIBRUSTUV_DEFAULT$(1)_T_$(2)_H_$(3)) \\\n \t\t| $$(TLIB$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBSYNTAX_GLOB_$(2)),$$(notdir $$@))"}, {"sha": "6aec4b81d0a49907289b1803512b0460854d738e", "filename": "mk/tests.mk", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -14,7 +14,7 @@\n ######################################################################\n \n # The names of crates that must be tested\n-TEST_TARGET_CRATES = std extra\n+TEST_TARGET_CRATES = std extra rustuv\n TEST_HOST_CRATES = rustpkg rustc rustdoc syntax\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n@@ -164,6 +164,8 @@ $(info check: android device test dir $(CFG_ADB_TEST_DIR) ready \\\n                   $(CFG_ADB_TEST_DIR)) \\\n  $(shell adb push $(TLIB2_T_arm-linux-androideabi_H_$(CFG_BUILD_TRIPLE))/$(EXTRALIB_GLOB_arm-linux-androideabi) \\\n                   $(CFG_ADB_TEST_DIR)) \\\n+ $(shell adb push $(TLIB2_T_arm-linux-androideabi_H_$(CFG_BUILD_TRIPLE))/$(LIBRUSTUV_GLOB_arm-linux-androideabi) \\\n+                  $(CFG_ADB_TEST_DIR)) \\\n  )\n else\n CFG_ADB_TEST_DIR=\n@@ -189,6 +191,7 @@ check-test: cleantestlibs cleantmptestlogs all check-stage2-rfail\n \n check-lite: cleantestlibs cleantmptestlogs \\\n \tcheck-stage2-std check-stage2-extra check-stage2-rpass \\\n+\tcheck-stage2-rustuv \\\n \tcheck-stage2-rustpkg \\\n \tcheck-stage2-rfail check-stage2-cfail\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n@@ -333,7 +336,8 @@ define TEST_RUNNER\n # test crates without rebuilding std and extra first\n ifeq ($(NO_REBUILD),)\n STDTESTDEP_$(1)_$(2)_$(3) = $$(SREQ$(1)_T_$(2)_H_$(3)) \\\n-                            $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_EXTRALIB_$(2))\n+                            $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_EXTRALIB_$(2)) \\\n+                            $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTUV_$(2))\n else\n STDTESTDEP_$(1)_$(2)_$(3) =\n endif\n@@ -350,6 +354,12 @@ $(3)/stage$(1)/test/extratest-$(2)$$(X_$(2)):\t\t\t\\\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n \n+$(3)/stage$(1)/test/rustuvtest-$(2)$$(X_$(2)):\t\t\t\\\n+\t\t$$(LIBRUSTUV_CRATE) $$(LIBRUSTUV_INPUTS)\t\\\n+\t\t$$(STDTESTDEP_$(1)_$(2)_$(3))\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n+\n $(3)/stage$(1)/test/syntaxtest-$(2)$$(X_$(2)):\t\t\t\\\n \t\t$$(LIBSYNTAX_CRATE) $$(LIBSYNTAX_INPUTS)\t\\\n \t\t$$(STDTESTDEP_$(1)_$(2)_$(3))"}, {"sha": "e7057defd7750951a85e7f662811818d3900c1e5", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -30,27 +30,31 @@ def scrub(b):\n               \"lib/libextra-*.so\",\n               \"lib/librustc-*.so\",\n               \"lib/libsyntax-*.so\",\n+              \"lib/librustuv-*.so\",\n               \"lib/librustrt.so\",\n               \"lib/librustllvm.so\"],\n     \"macos\": [\"bin/rustc\",\n               \"lib/libstd-*.dylib\",\n               \"lib/libextra-*.dylib\",\n               \"lib/librustc-*.dylib\",\n               \"lib/libsyntax-*.dylib\",\n+              \"lib/librustuv-*.dylib\",\n               \"lib/librustrt.dylib\",\n               \"lib/librustllvm.dylib\"],\n     \"winnt\": [\"bin/rustc.exe\",\n               \"bin/std-*.dll\",\n               \"bin/extra-*.dll\",\n               \"bin/rustc-*.dll\",\n               \"bin/syntax-*.dll\",\n+              \"bin/rustuv-*.dll\",\n               \"bin/rustrt.dll\",\n               \"bin/rustllvm.dll\"],\n     \"freebsd\": [\"bin/rustc\",\n                 \"lib/libstd-*.so\",\n                 \"lib/libextra-*.so\",\n                 \"lib/librustc-*.so\",\n                 \"lib/libsyntax-*.so\",\n+                \"lib/librustuv-*.so\",\n                 \"lib/librustrt.so\",\n                 \"lib/librustllvm.so\"]\n     }"}, {"sha": "b34829bf47fc1e0a2003f0b7c988e7c33b089e25", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -35,6 +35,10 @@ fn use_std(crate: &ast::Crate) -> bool {\n     !attr::contains_name(crate.attrs, \"no_std\")\n }\n \n+fn use_uv(crate: &ast::Crate) -> bool {\n+    !attr::contains_name(crate.attrs, \"no_uv\")\n+}\n+\n fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"no_implicit_prelude\")\n }\n@@ -53,19 +57,30 @@ struct StandardLibraryInjector {\n impl fold::ast_fold for StandardLibraryInjector {\n     fn fold_crate(&self, crate: ast::Crate) -> ast::Crate {\n         let version = STD_VERSION.to_managed();\n-        let vi1 = ast::view_item {\n+        let vers_item = attr::mk_name_value_item_str(@\"vers\", version);\n+        let mut vis = ~[ast::view_item {\n             node: ast::view_item_extern_mod(self.sess.ident_of(\"std\"),\n                                             None,\n-                                            ~[],\n+                                            ~[vers_item.clone()],\n                                             ast::DUMMY_NODE_ID),\n-            attrs: ~[\n-                attr::mk_attr(attr::mk_name_value_item_str(@\"vers\", version))\n-            ],\n+            attrs: ~[],\n             vis: ast::private,\n             span: dummy_sp()\n-        };\n+        }];\n+\n+        if use_uv(&crate) && !*self.sess.building_library {\n+            vis.push(ast::view_item {\n+                node: ast::view_item_extern_mod(self.sess.ident_of(\"rustuv\"),\n+                                                None,\n+                                                ~[vers_item],\n+                                                ast::DUMMY_NODE_ID),\n+                attrs: ~[],\n+                vis: ast::private,\n+                span: dummy_sp()\n+            });\n+        }\n \n-        let vis = vec::append(~[vi1], crate.module.view_items);\n+        vis.push_all(crate.module.view_items);\n         let mut new_module = ast::_mod {\n             view_items: vis,\n             ..crate.module.clone()"}, {"sha": "e8d6a7267dfb61f2b36173d14eaa4b85d0db316b", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 92, "deletions": 107, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -24,10 +24,9 @@ use driver::session::Session;\n use metadata::csearch::each_lang_item;\n use metadata::cstore::iter_crate_data;\n use middle::ty::{BuiltinBound, BoundFreeze, BoundSend, BoundSized};\n-use syntax::ast::{Crate, DefId, MetaItem};\n+use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n-use syntax::ast::{item};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -81,20 +80,22 @@ pub enum LangItem {\n     TyDescStructLangItem,              // 36\n     TyVisitorTraitLangItem,            // 37\n     OpaqueStructLangItem,              // 38\n+\n+    EventLoopFactoryLangItem,          // 39\n }\n \n pub struct LanguageItems {\n-    items: [Option<DefId>, ..39]\n+    items: [Option<ast::DefId>, ..40]\n }\n \n impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         LanguageItems {\n-            items: [ None, ..39 ]\n+            items: [ None, ..40 ]\n         }\n     }\n \n-    pub fn items<'a>(&'a self) -> Enumerate<vec::VecIterator<'a, Option<DefId>>> {\n+    pub fn items<'a>(&'a self) -> Enumerate<vec::VecIterator<'a, Option<ast::DefId>>> {\n         self.items.iter().enumerate()\n     }\n \n@@ -145,21 +146,23 @@ impl LanguageItems {\n             37 => \"ty_visitor\",\n             38 => \"opaque\",\n \n+            39 => \"event_loop_factory\",\n+\n             _ => \"???\"\n         }\n     }\n \n     // FIXME #4621: Method macros sure would be nice here.\n \n-    pub fn require(&self, it: LangItem) -> Result<DefId, ~str> {\n+    pub fn require(&self, it: LangItem) -> Result<ast::DefId, ~str> {\n         match self.items[it as uint] {\n             Some(id) => Ok(id),\n             None => Err(format!(\"requires `{}` lang_item\",\n                              LanguageItems::item_name(it as uint)))\n         }\n     }\n \n-    pub fn to_builtin_kind(&self, id: DefId) -> Option<BuiltinBound> {\n+    pub fn to_builtin_kind(&self, id: ast::DefId) -> Option<BuiltinBound> {\n         if Some(id) == self.freeze_trait() {\n             Some(BoundFreeze)\n         } else if Some(id) == self.send_trait() {\n@@ -171,162 +174,166 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn freeze_trait(&self) -> Option<DefId> {\n+    pub fn freeze_trait(&self) -> Option<ast::DefId> {\n         self.items[FreezeTraitLangItem as uint]\n     }\n-    pub fn send_trait(&self) -> Option<DefId> {\n+    pub fn send_trait(&self) -> Option<ast::DefId> {\n         self.items[SendTraitLangItem as uint]\n     }\n-    pub fn sized_trait(&self) -> Option<DefId> {\n+    pub fn sized_trait(&self) -> Option<ast::DefId> {\n         self.items[SizedTraitLangItem as uint]\n     }\n \n-    pub fn drop_trait(&self) -> Option<DefId> {\n+    pub fn drop_trait(&self) -> Option<ast::DefId> {\n         self.items[DropTraitLangItem as uint]\n     }\n \n-    pub fn add_trait(&self) -> Option<DefId> {\n+    pub fn add_trait(&self) -> Option<ast::DefId> {\n         self.items[AddTraitLangItem as uint]\n     }\n-    pub fn sub_trait(&self) -> Option<DefId> {\n+    pub fn sub_trait(&self) -> Option<ast::DefId> {\n         self.items[SubTraitLangItem as uint]\n     }\n-    pub fn mul_trait(&self) -> Option<DefId> {\n+    pub fn mul_trait(&self) -> Option<ast::DefId> {\n         self.items[MulTraitLangItem as uint]\n     }\n-    pub fn div_trait(&self) -> Option<DefId> {\n+    pub fn div_trait(&self) -> Option<ast::DefId> {\n         self.items[DivTraitLangItem as uint]\n     }\n-    pub fn rem_trait(&self) -> Option<DefId> {\n+    pub fn rem_trait(&self) -> Option<ast::DefId> {\n         self.items[RemTraitLangItem as uint]\n     }\n-    pub fn neg_trait(&self) -> Option<DefId> {\n+    pub fn neg_trait(&self) -> Option<ast::DefId> {\n         self.items[NegTraitLangItem as uint]\n     }\n-    pub fn not_trait(&self) -> Option<DefId> {\n+    pub fn not_trait(&self) -> Option<ast::DefId> {\n         self.items[NotTraitLangItem as uint]\n     }\n-    pub fn bitxor_trait(&self) -> Option<DefId> {\n+    pub fn bitxor_trait(&self) -> Option<ast::DefId> {\n         self.items[BitXorTraitLangItem as uint]\n     }\n-    pub fn bitand_trait(&self) -> Option<DefId> {\n+    pub fn bitand_trait(&self) -> Option<ast::DefId> {\n         self.items[BitAndTraitLangItem as uint]\n     }\n-    pub fn bitor_trait(&self) -> Option<DefId> {\n+    pub fn bitor_trait(&self) -> Option<ast::DefId> {\n         self.items[BitOrTraitLangItem as uint]\n     }\n-    pub fn shl_trait(&self) -> Option<DefId> {\n+    pub fn shl_trait(&self) -> Option<ast::DefId> {\n         self.items[ShlTraitLangItem as uint]\n     }\n-    pub fn shr_trait(&self) -> Option<DefId> {\n+    pub fn shr_trait(&self) -> Option<ast::DefId> {\n         self.items[ShrTraitLangItem as uint]\n     }\n-    pub fn index_trait(&self) -> Option<DefId> {\n+    pub fn index_trait(&self) -> Option<ast::DefId> {\n         self.items[IndexTraitLangItem as uint]\n     }\n \n-    pub fn eq_trait(&self) -> Option<DefId> {\n+    pub fn eq_trait(&self) -> Option<ast::DefId> {\n         self.items[EqTraitLangItem as uint]\n     }\n-    pub fn ord_trait(&self) -> Option<DefId> {\n+    pub fn ord_trait(&self) -> Option<ast::DefId> {\n         self.items[OrdTraitLangItem as uint]\n     }\n \n-    pub fn str_eq_fn(&self) -> Option<DefId> {\n+    pub fn str_eq_fn(&self) -> Option<ast::DefId> {\n         self.items[StrEqFnLangItem as uint]\n     }\n-    pub fn uniq_str_eq_fn(&self) -> Option<DefId> {\n+    pub fn uniq_str_eq_fn(&self) -> Option<ast::DefId> {\n         self.items[UniqStrEqFnLangItem as uint]\n     }\n-    pub fn fail_fn(&self) -> Option<DefId> {\n+    pub fn fail_fn(&self) -> Option<ast::DefId> {\n         self.items[FailFnLangItem as uint]\n     }\n-    pub fn fail_bounds_check_fn(&self) -> Option<DefId> {\n+    pub fn fail_bounds_check_fn(&self) -> Option<ast::DefId> {\n         self.items[FailBoundsCheckFnLangItem as uint]\n     }\n-    pub fn exchange_malloc_fn(&self) -> Option<DefId> {\n+    pub fn exchange_malloc_fn(&self) -> Option<ast::DefId> {\n         self.items[ExchangeMallocFnLangItem as uint]\n     }\n-    pub fn closure_exchange_malloc_fn(&self) -> Option<DefId> {\n+    pub fn closure_exchange_malloc_fn(&self) -> Option<ast::DefId> {\n         self.items[ClosureExchangeMallocFnLangItem as uint]\n     }\n-    pub fn exchange_free_fn(&self) -> Option<DefId> {\n+    pub fn exchange_free_fn(&self) -> Option<ast::DefId> {\n         self.items[ExchangeFreeFnLangItem as uint]\n     }\n-    pub fn malloc_fn(&self) -> Option<DefId> {\n+    pub fn malloc_fn(&self) -> Option<ast::DefId> {\n         self.items[MallocFnLangItem as uint]\n     }\n-    pub fn free_fn(&self) -> Option<DefId> {\n+    pub fn free_fn(&self) -> Option<ast::DefId> {\n         self.items[FreeFnLangItem as uint]\n     }\n-    pub fn borrow_as_imm_fn(&self) -> Option<DefId> {\n+    pub fn borrow_as_imm_fn(&self) -> Option<ast::DefId> {\n         self.items[BorrowAsImmFnLangItem as uint]\n     }\n-    pub fn borrow_as_mut_fn(&self) -> Option<DefId> {\n+    pub fn borrow_as_mut_fn(&self) -> Option<ast::DefId> {\n         self.items[BorrowAsMutFnLangItem as uint]\n     }\n-    pub fn return_to_mut_fn(&self) -> Option<DefId> {\n+    pub fn return_to_mut_fn(&self) -> Option<ast::DefId> {\n         self.items[ReturnToMutFnLangItem as uint]\n     }\n-    pub fn check_not_borrowed_fn(&self) -> Option<DefId> {\n+    pub fn check_not_borrowed_fn(&self) -> Option<ast::DefId> {\n         self.items[CheckNotBorrowedFnLangItem as uint]\n     }\n-    pub fn strdup_uniq_fn(&self) -> Option<DefId> {\n+    pub fn strdup_uniq_fn(&self) -> Option<ast::DefId> {\n         self.items[StrDupUniqFnLangItem as uint]\n     }\n-    pub fn record_borrow_fn(&self) -> Option<DefId> {\n+    pub fn record_borrow_fn(&self) -> Option<ast::DefId> {\n         self.items[RecordBorrowFnLangItem as uint]\n     }\n-    pub fn unrecord_borrow_fn(&self) -> Option<DefId> {\n+    pub fn unrecord_borrow_fn(&self) -> Option<ast::DefId> {\n         self.items[UnrecordBorrowFnLangItem as uint]\n     }\n-    pub fn start_fn(&self) -> Option<DefId> {\n+    pub fn start_fn(&self) -> Option<ast::DefId> {\n         self.items[StartFnLangItem as uint]\n     }\n-    pub fn ty_desc(&self) -> Option<DefId> {\n+    pub fn ty_desc(&self) -> Option<ast::DefId> {\n         self.items[TyDescStructLangItem as uint]\n     }\n-    pub fn ty_visitor(&self) -> Option<DefId> {\n+    pub fn ty_visitor(&self) -> Option<ast::DefId> {\n         self.items[TyVisitorTraitLangItem as uint]\n     }\n-    pub fn opaque(&self) -> Option<DefId> {\n+    pub fn opaque(&self) -> Option<ast::DefId> {\n         self.items[OpaqueStructLangItem as uint]\n     }\n+    pub fn event_loop_factory(&self) -> Option<ast::DefId> {\n+        self.items[EventLoopFactoryLangItem as uint]\n+    }\n }\n \n-struct LanguageItemCollector<'self> {\n+struct LanguageItemCollector {\n     items: LanguageItems,\n \n-    crate: &'self Crate,\n     session: Session,\n \n     item_refs: HashMap<&'static str, uint>,\n }\n \n struct LanguageItemVisitor<'self> {\n-    this: *mut LanguageItemCollector<'self>,\n+    this: &'self mut LanguageItemCollector,\n }\n \n impl<'self> Visitor<()> for LanguageItemVisitor<'self> {\n-\n-    fn visit_item(&mut self, item:@item, _:()) {\n-\n-                for attribute in item.attrs.iter() {\n-                    unsafe {\n-                        (*self.this).match_and_collect_meta_item(\n-                            local_def(item.id),\n-                            attribute.node.value\n-                        );\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        match extract(item.attrs) {\n+            Some(value) => {\n+                let item_index = self.this.item_refs.find_equiv(&value).map(|x| *x);\n+\n+                match item_index {\n+                    Some(item_index) => {\n+                        self.this.collect_item(item_index, local_def(item.id))\n                     }\n+                    None => {}\n                 }\n+            }\n+            None => {}\n+        }\n \n         visit::walk_item(self, item, ());\n     }\n }\n \n-impl<'self> LanguageItemCollector<'self> {\n-    pub fn new<'a>(crate: &'a Crate, session: Session)\n-                   -> LanguageItemCollector<'a> {\n+impl LanguageItemCollector {\n+    pub fn new(session: Session) -> LanguageItemCollector {\n         let mut item_refs = HashMap::new();\n \n         item_refs.insert(\"freeze\", FreezeTraitLangItem as uint);\n@@ -374,27 +381,16 @@ impl<'self> LanguageItemCollector<'self> {\n         item_refs.insert(\"ty_desc\", TyDescStructLangItem as uint);\n         item_refs.insert(\"ty_visitor\", TyVisitorTraitLangItem as uint);\n         item_refs.insert(\"opaque\", OpaqueStructLangItem as uint);\n+        item_refs.insert(\"event_loop_factory\", EventLoopFactoryLangItem as uint);\n \n         LanguageItemCollector {\n-            crate: crate,\n             session: session,\n             items: LanguageItems::new(),\n             item_refs: item_refs\n         }\n     }\n \n-    pub fn match_and_collect_meta_item(&mut self,\n-                                       item_def_id: DefId,\n-                                       meta_item: &MetaItem) {\n-        match meta_item.name_str_pair() {\n-            Some((key, value)) => {\n-                self.match_and_collect_item(item_def_id, key, value);\n-            }\n-            None => {} // skip\n-        }\n-    }\n-\n-    pub fn collect_item(&mut self, item_index: uint, item_def_id: DefId) {\n+    pub fn collect_item(&mut self, item_index: uint, item_def_id: ast::DefId) {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n@@ -410,58 +406,47 @@ impl<'self> LanguageItemCollector<'self> {\n         self.items.items[item_index] = Some(item_def_id);\n     }\n \n-    pub fn match_and_collect_item(&mut self,\n-                                  item_def_id: DefId,\n-                                  key: &str,\n-                                  value: @str) {\n-        if \"lang\" != key {\n-            return;    // Didn't match.\n-        }\n-\n-        let item_index = self.item_refs.find_equiv(&value).map(|x| *x);\n-        // prevent borrow checker from considering         ^~~~~~~~~~~\n-        // self to be borrowed (annoying)\n-\n-        match item_index {\n-            Some(item_index) => {\n-                self.collect_item(item_index, item_def_id);\n-            }\n-            None => {\n-                // Didn't match.\n-                return;\n-            }\n-        }\n-    }\n-\n-    pub fn collect_local_language_items(&mut self) {\n-        let this: *mut LanguageItemCollector = &mut *self;\n-        let mut v = LanguageItemVisitor { this: this };\n-        visit::walk_crate(&mut v, self.crate, ());\n+    pub fn collect_local_language_items(&mut self, crate: &ast::Crate) {\n+        let mut v = LanguageItemVisitor { this: self };\n+        visit::walk_crate(&mut v, crate, ());\n     }\n \n     pub fn collect_external_language_items(&mut self) {\n         let crate_store = self.session.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n             do each_lang_item(crate_store, crate_number)\n                     |node_id, item_index| {\n-                let def_id = DefId { crate: crate_number, node: node_id };\n+                let def_id = ast::DefId { crate: crate_number, node: node_id };\n                 self.collect_item(item_index, def_id);\n                 true\n             };\n         }\n     }\n \n-    pub fn collect(&mut self) {\n-        self.collect_local_language_items();\n+    pub fn collect(&mut self, crate: &ast::Crate) {\n+        self.collect_local_language_items(crate);\n         self.collect_external_language_items();\n     }\n }\n \n-pub fn collect_language_items(crate: &Crate,\n+pub fn extract(attrs: &[ast::Attribute]) -> Option<@str> {\n+    for attribute in attrs.iter() {\n+        match attribute.name_str_pair() {\n+            Some((key, value)) if \"lang\" == key => {\n+                return Some(value);\n+            }\n+            Some(*) | None => {}\n+        }\n+    }\n+\n+    return None;\n+}\n+\n+pub fn collect_language_items(crate: &ast::Crate,\n                               session: Session)\n                            -> LanguageItems {\n-    let mut collector = LanguageItemCollector::new(crate, session);\n-    collector.collect();\n+    let mut collector = LanguageItemCollector::new(session);\n+    collector.collect(crate);\n     let LanguageItemCollector { items, _ } = collector;\n     session.abort_if_errors();\n     items"}, {"sha": "665aaad5f47e0feec5a367713c45377dacf78be9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 51, "deletions": 11, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -2596,16 +2596,36 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             foreign::register_foreign_item_fn(ccx, abis, &path, ni)\n                         }\n                         ast::foreign_item_static(*) => {\n-                            let ident = foreign::link_name(ccx, ni);\n-                            unsafe {\n-                                let g = do ident.with_c_str |buf| {\n-                                    let ty = type_of(ccx, ty);\n-                                    llvm::LLVMAddGlobal(ccx.llmod, ty.to_ref(), buf)\n-                                };\n-                                if attr::contains_name(ni.attrs, \"weak_linkage\") {\n-                                    lib::llvm::SetLinkage(g, lib::llvm::ExternalWeakLinkage);\n+                            // Treat the crate map static specially in order to\n+                            // a weak-linkage-like functionality where it's\n+                            // dynamically resolved at runtime. If we're\n+                            // building a library, then we declare the static\n+                            // with weak linkage, but if we're building a\n+                            // library then we've already declared the crate map\n+                            // so use that instead.\n+                            if attr::contains_name(ni.attrs, \"crate_map\") {\n+                                if *ccx.sess.building_library {\n+                                    let s = \"_rust_crate_map_toplevel\";\n+                                    let g = unsafe { do s.with_c_str |buf| {\n+                                        let ty = type_of(ccx, ty);\n+                                        llvm::LLVMAddGlobal(ccx.llmod,\n+                                                            ty.to_ref(), buf)\n+                                    } };\n+                                    lib::llvm::SetLinkage(g,\n+                                        lib::llvm::ExternalWeakLinkage);\n+                                    g\n+                                } else {\n+                                    ccx.crate_map\n+                                }\n+                            } else {\n+                                let ident = foreign::link_name(ccx, ni);\n+                                unsafe {\n+                                    do ident.with_c_str |buf| {\n+                                        let ty = type_of(ccx, ty);\n+                                        llvm::LLVMAddGlobal(ccx.llmod,\n+                                                            ty.to_ref(), buf)\n+                                    }\n                                 }\n-                                g\n                             }\n                         }\n                     }\n@@ -2929,7 +2949,12 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n \n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n     let slicetype = Type::struct_([int_type, int_type], false);\n-    let maptype = Type::struct_([Type::i32(), slicetype, slicetype], false);\n+    let maptype = Type::struct_([\n+        Type::i32(),        // version\n+        slicetype,          // child modules\n+        slicetype,          // sub crate-maps\n+        int_type.ptr_to(),  // event loop factory\n+    ], false);\n     let map = do sym_name.with_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n@@ -2964,6 +2989,20 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n         subcrates.push(p2i(ccx, cr));\n         i += 1;\n     }\n+    let event_loop_factory = if !*ccx.sess.building_library {\n+        match ccx.tcx.lang_items.event_loop_factory() {\n+            Some(did) => unsafe {\n+                let name = csearch::get_symbol(ccx.sess.cstore, did);\n+                let global = do name.with_c_str |buf| {\n+                    llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n+                };\n+                global\n+            },\n+            None => C_null(ccx.int_type.ptr_to())\n+        }\n+    } else {\n+        C_null(ccx.int_type.ptr_to())\n+    };\n     unsafe {\n         let maptype = Type::array(&ccx.int_type, subcrates.len() as u64);\n         let vec_elements = do \"_crate_map_child_vectors\".with_c_str |buf| {\n@@ -2983,7 +3022,8 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n              C_struct([\n                 p2i(ccx, vec_elements),\n                 C_uint(ccx, subcrates.len())\n-             ], false)\n+             ], false),\n+            event_loop_factory,\n         ], false));\n     }\n }"}, {"sha": "09736749997bef31a04420bd04fa70c99151f4b8", "filename": "src/librustuv/addrinfo.rs", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,273 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cast::transmute;\n+use std::cell::Cell;\n+use std::libc::{c_int, c_void};\n+use std::ptr::null;\n+use ai = std::rt::io::net::addrinfo;\n+\n+use uvll;\n+use uvll::UV_GETADDRINFO;\n+use super::{Loop, UvError, NativeHandle, status_to_maybe_uv_error};\n+use net;\n+\n+type GetAddrInfoCallback = ~fn(GetAddrInfoRequest, &net::UvAddrInfo, Option<UvError>);\n+\n+pub struct GetAddrInfoRequest(*uvll::uv_getaddrinfo_t);\n+\n+pub struct RequestData {\n+    priv getaddrinfo_cb: Option<GetAddrInfoCallback>,\n+}\n+\n+impl GetAddrInfoRequest {\n+    pub fn new() -> GetAddrInfoRequest {\n+        let req = unsafe { uvll::malloc_req(UV_GETADDRINFO) };\n+        assert!(req.is_not_null());\n+        let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n+        req.install_req_data();\n+        return req;\n+    }\n+\n+    pub fn getaddrinfo(&mut self, loop_: &Loop, node: Option<&str>,\n+                       service: Option<&str>, hints: Option<ai::Hint>,\n+                       cb: GetAddrInfoCallback) {\n+\n+        assert!(node.is_some() || service.is_some());\n+\n+        let (c_node, c_node_ptr) = match node {\n+            Some(n) => {\n+                let c_node = n.to_c_str();\n+                let c_node_ptr = c_node.with_ref(|r| r);\n+                (Some(c_node), c_node_ptr)\n+            }\n+            None => (None, null())\n+        };\n+\n+        let (c_service, c_service_ptr) = match service {\n+            Some(s) => {\n+                let c_service = s.to_c_str();\n+                let c_service_ptr = c_service.with_ref(|r| r);\n+                (Some(c_service), c_service_ptr)\n+            }\n+            None => (None, null())\n+        };\n+\n+        let cb = Cell::new(cb);\n+        let wrapper_cb: GetAddrInfoCallback = |req, addrinfo, err| {\n+            // Capture some heap values that need to stay alive for the\n+            // getaddrinfo call\n+            let _ = &c_node;\n+            let _ = &c_service;\n+\n+            let cb = cb.take();\n+            cb(req, addrinfo, err)\n+        };\n+\n+        let hint = hints.map(|hint| {\n+            let mut flags = 0;\n+            do each_ai_flag |cval, aival| {\n+                if hint.flags & (aival as uint) != 0 {\n+                    flags |= cval as i32;\n+                }\n+            }\n+            /* XXX: do we really want to support these?\n+            let socktype = match hint.socktype {\n+                Some(ai::Stream) => uvll::rust_SOCK_STREAM(),\n+                Some(ai::Datagram) => uvll::rust_SOCK_DGRAM(),\n+                Some(ai::Raw) => uvll::rust_SOCK_RAW(),\n+                None => 0,\n+            };\n+            let protocol = match hint.protocol {\n+                Some(ai::UDP) => uvll::rust_IPPROTO_UDP(),\n+                Some(ai::TCP) => uvll::rust_IPPROTO_TCP(),\n+                _ => 0,\n+            };\n+            */\n+            let socktype = 0;\n+            let protocol = 0;\n+\n+            uvll::addrinfo {\n+                ai_flags: flags,\n+                ai_family: hint.family as c_int,\n+                ai_socktype: socktype,\n+                ai_protocol: protocol,\n+                ai_addrlen: 0,\n+                ai_canonname: null(),\n+                ai_addr: null(),\n+                ai_next: null(),\n+            }\n+        });\n+        let hint_ptr = hint.as_ref().map_default(null(), |x| x as *uvll::addrinfo);\n+\n+        self.get_req_data().getaddrinfo_cb = Some(wrapper_cb);\n+\n+        unsafe {\n+            assert!(0 == uvll::getaddrinfo(loop_.native_handle(),\n+                                           self.native_handle(),\n+                                           getaddrinfo_cb,\n+                                           c_node_ptr,\n+                                           c_service_ptr,\n+                                           hint_ptr));\n+        }\n+\n+        extern \"C\" fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,\n+                                     status: c_int,\n+                                     res: *uvll::addrinfo) {\n+            let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n+            let err = status_to_maybe_uv_error(status);\n+            let addrinfo = net::UvAddrInfo(res);\n+            let data = req.get_req_data();\n+            (*data.getaddrinfo_cb.get_ref())(req, &addrinfo, err);\n+            unsafe {\n+                uvll::freeaddrinfo(res);\n+            }\n+        }\n+    }\n+\n+    fn get_loop(&self) -> Loop {\n+        unsafe {\n+            Loop {\n+                handle: uvll::get_loop_from_fs_req(self.native_handle())\n+            }\n+        }\n+    }\n+\n+    fn install_req_data(&mut self) {\n+        let req = self.native_handle() as *uvll::uv_getaddrinfo_t;\n+        let data = ~RequestData {\n+            getaddrinfo_cb: None\n+        };\n+        unsafe {\n+            let data = transmute::<~RequestData, *c_void>(data);\n+            uvll::set_data_for_req(req, data);\n+        }\n+    }\n+\n+    fn get_req_data<'r>(&'r mut self) -> &'r mut RequestData {\n+        unsafe {\n+            let data = uvll::get_data_for_req(self.native_handle());\n+            let data = transmute::<&*c_void, &mut ~RequestData>(&data);\n+            return &mut **data;\n+        }\n+    }\n+\n+    fn delete(self) {\n+        unsafe {\n+            let data = uvll::get_data_for_req(self.native_handle());\n+            let _data = transmute::<*c_void, ~RequestData>(data);\n+            uvll::set_data_for_req(self.native_handle(), null::<()>());\n+            uvll::free_req(self.native_handle());\n+        }\n+    }\n+}\n+\n+fn each_ai_flag(_f: &fn(c_int, ai::Flag)) {\n+    /* XXX: do we really want to support these?\n+    unsafe {\n+        f(uvll::rust_AI_ADDRCONFIG(), ai::AddrConfig);\n+        f(uvll::rust_AI_ALL(), ai::All);\n+        f(uvll::rust_AI_CANONNAME(), ai::CanonName);\n+        f(uvll::rust_AI_NUMERICHOST(), ai::NumericHost);\n+        f(uvll::rust_AI_NUMERICSERV(), ai::NumericServ);\n+        f(uvll::rust_AI_PASSIVE(), ai::Passive);\n+        f(uvll::rust_AI_V4MAPPED(), ai::V4Mapped);\n+    }\n+    */\n+}\n+\n+// Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n+pub fn accum_addrinfo(addr: &net::UvAddrInfo) -> ~[ai::Info] {\n+    unsafe {\n+        let &net::UvAddrInfo(addr) = addr;\n+        let mut addr = addr;\n+\n+        let mut addrs = ~[];\n+        loop {\n+            let uvaddr = net::sockaddr_to_UvSocketAddr((*addr).ai_addr);\n+            let rustaddr = net::uv_socket_addr_to_socket_addr(uvaddr);\n+\n+            let mut flags = 0;\n+            do each_ai_flag |cval, aival| {\n+                if (*addr).ai_flags & cval != 0 {\n+                    flags |= aival as uint;\n+                }\n+            }\n+\n+            /* XXX: do we really want to support these\n+            let protocol = match (*addr).ai_protocol {\n+                p if p == uvll::rust_IPPROTO_UDP() => Some(ai::UDP),\n+                p if p == uvll::rust_IPPROTO_TCP() => Some(ai::TCP),\n+                _ => None,\n+            };\n+            let socktype = match (*addr).ai_socktype {\n+                p if p == uvll::rust_SOCK_STREAM() => Some(ai::Stream),\n+                p if p == uvll::rust_SOCK_DGRAM() => Some(ai::Datagram),\n+                p if p == uvll::rust_SOCK_RAW() => Some(ai::Raw),\n+                _ => None,\n+            };\n+            */\n+            let protocol = None;\n+            let socktype = None;\n+\n+            addrs.push(ai::Info {\n+                address: rustaddr,\n+                family: (*addr).ai_family as uint,\n+                socktype: socktype,\n+                protocol: protocol,\n+                flags: flags,\n+            });\n+            if (*addr).ai_next.is_not_null() {\n+                addr = (*addr).ai_next;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        return addrs;\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_getaddrinfo_t> for GetAddrInfoRequest {\n+    fn from_native_handle(handle: *uvll::uv_getaddrinfo_t) -> GetAddrInfoRequest {\n+        GetAddrInfoRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_getaddrinfo_t {\n+        match self { &GetAddrInfoRequest(ptr) => ptr }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use Loop;\n+    use std::rt::io::net::ip::{SocketAddr, Ipv4Addr};\n+    use super::*;\n+\n+    #[test]\n+    fn getaddrinfo_test() {\n+        let mut loop_ = Loop::new();\n+        let mut req = GetAddrInfoRequest::new();\n+        do req.getaddrinfo(&loop_, Some(\"localhost\"), None, None) |_, addrinfo, _| {\n+            let sockaddrs = accum_addrinfo(addrinfo);\n+            let mut found_local = false;\n+            let local_addr = &SocketAddr {\n+                ip: Ipv4Addr(127, 0, 0, 1),\n+                port: 0\n+            };\n+            for addr in sockaddrs.iter() {\n+                found_local = found_local || addr.address == *local_addr;\n+            }\n+            assert!(found_local);\n+        }\n+        loop_.run();\n+        loop_.close();\n+        req.delete();\n+    }\n+}"}, {"sha": "4a1858ee03672b0bb7248d4a893b09343ba9fd6a", "filename": "src/librustuv/async.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::libc::c_int;\n+\n+use uvll;\n+use super::{Watcher, Loop, NativeHandle, AsyncCallback, WatcherInterop};\n+use super::status_to_maybe_uv_error;\n+\n+pub struct AsyncWatcher(*uvll::uv_async_t);\n+impl Watcher for AsyncWatcher { }\n+\n+impl AsyncWatcher {\n+    pub fn new(loop_: &mut Loop, cb: AsyncCallback) -> AsyncWatcher {\n+        unsafe {\n+            let handle = uvll::malloc_handle(uvll::UV_ASYNC);\n+            assert!(handle.is_not_null());\n+            let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            let data = watcher.get_watcher_data();\n+            data.async_cb = Some(cb);\n+            assert_eq!(0, uvll::async_init(loop_.native_handle(), handle, async_cb));\n+            return watcher;\n+        }\n+\n+        extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n+            let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n+            let status = status_to_maybe_uv_error(status);\n+            let data = watcher.get_watcher_data();\n+            let cb = data.async_cb.get_ref();\n+            (*cb)(watcher, status);\n+        }\n+    }\n+\n+    pub fn send(&mut self) {\n+        unsafe {\n+            let handle = self.native_handle();\n+            uvll::async_send(handle);\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_async_t> for AsyncWatcher {\n+    fn from_native_handle(handle: *uvll::uv_async_t) -> AsyncWatcher {\n+        AsyncWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_async_t {\n+        match self { &AsyncWatcher(ptr) => ptr }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+\n+    use super::*;\n+    use Loop;\n+    use std::unstable::run_in_bare_thread;\n+    use std::rt::thread::Thread;\n+    use std::cell::Cell;\n+\n+    #[test]\n+    fn smoke_test() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let watcher = AsyncWatcher::new(&mut loop_, |w, _| w.close(||()) );\n+            let watcher_cell = Cell::new(watcher);\n+            let thread = do Thread::start {\n+                let mut watcher = watcher_cell.take();\n+                watcher.send();\n+            };\n+            loop_.run();\n+            loop_.close();\n+            thread.join();\n+        }\n+    }\n+}"}, {"sha": "575226f79028b8d5f72741c03f5a741f4d8c6c60", "filename": "src/librustuv/file.rs", "status": "added", "additions": 647, "deletions": 0, "changes": 647, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,647 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ptr::null;\n+use std::c_str;\n+use std::c_str::CString;\n+use std::libc::c_void;\n+use std::cast::transmute;\n+use std::libc;\n+use std::libc::{c_int};\n+\n+use super::{Request, NativeHandle, Loop, FsCallback, Buf,\n+            status_to_maybe_uv_error, UvError};\n+use uvll;\n+use uvll::*;\n+\n+pub struct FsRequest(*uvll::uv_fs_t);\n+impl Request for FsRequest {}\n+\n+pub struct RequestData {\n+    priv complete_cb: Option<FsCallback>\n+}\n+\n+impl FsRequest {\n+    pub fn new() -> FsRequest {\n+        let fs_req = unsafe { malloc_req(UV_FS) };\n+        assert!(fs_req.is_not_null());\n+        let fs_req: FsRequest = NativeHandle::from_native_handle(fs_req);\n+        fs_req\n+    }\n+\n+    pub fn open(self, loop_: &Loop, path: &CString, flags: int, mode: int,\n+                cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::fs_open(loop_.native_handle(),\n+                          self.native_handle(), p, flags, mode, complete_cb_ptr)\n+        });\n+        assert_eq!(ret, 0);\n+    }\n+\n+    pub fn open_sync(self, loop_: &Loop, path: &CString,\n+                     flags: int, mode: int) -> Result<c_int, UvError> {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(None)\n+        };\n+        let result = path.with_ref(|p| unsafe {\n+            uvll::fs_open(loop_.native_handle(),\n+                    self.native_handle(), p, flags, mode, complete_cb_ptr)\n+        });\n+        self.sync_cleanup(result)\n+    }\n+\n+    pub fn unlink(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::fs_unlink(loop_.native_handle(),\n+                          self.native_handle(), p, complete_cb_ptr)\n+        });\n+        assert_eq!(ret, 0);\n+    }\n+\n+    pub fn unlink_sync(self, loop_: &Loop, path: &CString)\n+      -> Result<c_int, UvError> {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(None)\n+        };\n+        let result = path.with_ref(|p| unsafe {\n+            uvll::fs_unlink(loop_.native_handle(),\n+                          self.native_handle(), p, complete_cb_ptr)\n+        });\n+        self.sync_cleanup(result)\n+    }\n+\n+    pub fn stat(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::fs_stat(loop_.native_handle(),\n+                          self.native_handle(), p, complete_cb_ptr)\n+        });\n+        assert_eq!(ret, 0);\n+    }\n+\n+    pub fn write(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let base_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        let ret = unsafe {\n+            uvll::fs_write(loop_.native_handle(), self.native_handle(),\n+                           fd, base_ptr,\n+                           len, offset, complete_cb_ptr)\n+        };\n+        assert_eq!(ret, 0);\n+    }\n+    pub fn write_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n+          -> Result<c_int, UvError> {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(None)\n+        };\n+        let base_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        let result = unsafe {\n+            uvll::fs_write(loop_.native_handle(), self.native_handle(),\n+                           fd, base_ptr,\n+                           len, offset, complete_cb_ptr)\n+        };\n+        self.sync_cleanup(result)\n+    }\n+\n+    pub fn read(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let buf_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        let ret = unsafe {\n+            uvll::fs_read(loop_.native_handle(), self.native_handle(),\n+                           fd, buf_ptr,\n+                           len, offset, complete_cb_ptr)\n+        };\n+        assert_eq!(ret, 0);\n+    }\n+    pub fn read_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n+          -> Result<c_int, UvError> {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(None)\n+        };\n+        let buf_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        let result = unsafe {\n+            uvll::fs_read(loop_.native_handle(), self.native_handle(),\n+                           fd, buf_ptr,\n+                           len, offset, complete_cb_ptr)\n+        };\n+        self.sync_cleanup(result)\n+    }\n+\n+    pub fn close(self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let ret = unsafe {\n+            uvll::fs_close(loop_.native_handle(), self.native_handle(),\n+                           fd, complete_cb_ptr)\n+        };\n+        assert_eq!(ret, 0);\n+    }\n+    pub fn close_sync(self, loop_: &Loop, fd: c_int) -> Result<c_int, UvError> {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(None)\n+        };\n+        let result = unsafe {\n+            uvll::fs_close(loop_.native_handle(), self.native_handle(),\n+                           fd, complete_cb_ptr)\n+        };\n+        self.sync_cleanup(result)\n+    }\n+\n+    pub fn mkdir(self, loop_: &Loop, path: &CString, mode: int, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::fs_mkdir(loop_.native_handle(),\n+                           self.native_handle(), p, mode, complete_cb_ptr)\n+        });\n+        assert_eq!(ret, 0);\n+    }\n+\n+    pub fn rmdir(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::fs_rmdir(loop_.native_handle(),\n+                           self.native_handle(), p, complete_cb_ptr)\n+        });\n+        assert_eq!(ret, 0);\n+    }\n+\n+    pub fn readdir(self, loop_: &Loop, path: &CString,\n+                   flags: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::fs_readdir(loop_.native_handle(),\n+                             self.native_handle(), p, flags, complete_cb_ptr)\n+        });\n+        assert_eq!(ret, 0);\n+    }\n+\n+    // accessors/utility funcs\n+    fn sync_cleanup(self, result: c_int)\n+          -> Result<c_int, UvError> {\n+        self.cleanup_and_delete();\n+        match status_to_maybe_uv_error(result as i32) {\n+            Some(err) => Err(err),\n+            None => Ok(result)\n+        }\n+    }\n+    fn req_boilerplate(&mut self, cb: Option<FsCallback>) -> *u8 {\n+        let result = match cb {\n+            Some(_) => {\n+                compl_cb as *u8\n+            },\n+            None => 0 as *u8\n+        };\n+        self.install_req_data(cb);\n+        result\n+    }\n+    pub fn install_req_data(&mut self, cb: Option<FsCallback>) {\n+        let fs_req = (self.native_handle()) as *uvll::uv_write_t;\n+        let data = ~RequestData {\n+            complete_cb: cb\n+        };\n+        unsafe {\n+            let data = transmute::<~RequestData, *c_void>(data);\n+            uvll::set_data_for_req(fs_req, data);\n+        }\n+    }\n+\n+    fn get_req_data<'r>(&'r mut self) -> &'r mut RequestData {\n+        unsafe {\n+            let data = uvll::get_data_for_req((self.native_handle()));\n+            let data = transmute::<&*c_void, &mut ~RequestData>(&data);\n+            &mut **data\n+        }\n+    }\n+\n+    pub fn get_result(&mut self) -> c_int {\n+        unsafe {\n+            uvll::get_result_from_fs_req(self.native_handle())\n+        }\n+    }\n+\n+    pub fn get_loop(&self) -> Loop {\n+        unsafe { Loop{handle:uvll::get_loop_from_fs_req(self.native_handle())} }\n+    }\n+\n+    pub fn get_stat(&self) -> uv_stat_t {\n+        let stat = uv_stat_t::new();\n+        unsafe { uvll::populate_stat(self.native_handle(), &stat); }\n+        stat\n+    }\n+\n+    pub fn get_ptr(&self) -> *libc::c_void {\n+        unsafe {\n+            uvll::get_ptr_from_fs_req(self.native_handle())\n+        }\n+    }\n+\n+    pub fn each_path(&mut self, f: &fn(&CString)) {\n+        let ptr = self.get_ptr();\n+        match self.get_result() {\n+            n if (n <= 0) => {}\n+            n => {\n+                let n_len = n as uint;\n+                // we pass in the len that uv tells us is there\n+                // for the entries and we don't continue past that..\n+                // it appears that sometimes the multistring isn't\n+                // correctly delimited and we stray into garbage memory?\n+                // in any case, passing Some(n_len) fixes it and ensures\n+                // good results\n+                unsafe {\n+                    c_str::from_c_multistring(ptr as *libc::c_char,\n+                                              Some(n_len), f);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn cleanup_and_delete(self) {\n+        unsafe {\n+            let data = uvll::get_data_for_req(self.native_handle());\n+            let _data = transmute::<*c_void, ~RequestData>(data);\n+            uvll::set_data_for_req(self.native_handle(), null::<()>());\n+            uvll::fs_req_cleanup(self.native_handle());\n+            free_req(self.native_handle() as *c_void)\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n+    fn from_native_handle(handle: *uvll:: uv_fs_t) -> FsRequest {\n+        FsRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_fs_t {\n+        match self { &FsRequest(ptr) => ptr }\n+    }\n+}\n+\n+fn sync_cleanup(result: int)\n+    -> Result<int, UvError> {\n+    match status_to_maybe_uv_error(result as i32) {\n+        Some(err) => Err(err),\n+        None => Ok(result)\n+    }\n+}\n+\n+extern fn compl_cb(req: *uv_fs_t) {\n+    let mut req: FsRequest = NativeHandle::from_native_handle(req);\n+    // pull the user cb out of the req data\n+    let cb = {\n+        let data = req.get_req_data();\n+        assert!(data.complete_cb.is_some());\n+        // option dance, option dance. oooooh yeah.\n+        data.complete_cb.take_unwrap()\n+    };\n+    // in uv_fs_open calls, the result will be the fd in the\n+    // case of success, otherwise it's -1 indicating an error\n+    let result = req.get_result();\n+    let status = status_to_maybe_uv_error(result);\n+    // we have a req and status, call the user cb..\n+    // only giving the user a ref to the FsRequest, as we\n+    // have to clean it up, afterwards (and they aren't really\n+    // reusable, anyways\n+    cb(&mut req, status);\n+    // clean up the req (and its data!) after calling the user cb\n+    req.cleanup_and_delete();\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    //use std::rt::test::*;\n+    use std::libc::{STDOUT_FILENO};\n+    use std::vec;\n+    use std::str;\n+    use std::unstable::run_in_bare_thread;\n+    use super::super::{Loop, Buf, slice_to_uv_buf};\n+    use std::libc::{O_CREAT, O_RDWR, O_RDONLY, S_IWUSR, S_IRUSR};\n+\n+    #[test]\n+    fn file_test_full_simple() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let create_flags = O_RDWR | O_CREAT;\n+            let read_flags = O_RDONLY;\n+            // 0644 BZZT! WRONG! 0600! See below.\n+            let mode = S_IWUSR |S_IRUSR;\n+                // these aren't defined in std::libc :(\n+                //map_mode(S_IRGRP) |\n+                //map_mode(S_IROTH);\n+            let path_str = \"./tmp/file_full_simple.txt\";\n+            let write_val = \"hello\".as_bytes().to_owned();\n+            let write_buf  = slice_to_uv_buf(write_val);\n+            let write_buf_ptr: *Buf = &write_buf;\n+            let read_buf_len = 1028;\n+            let read_mem = vec::from_elem(read_buf_len, 0u8);\n+            let read_buf = slice_to_uv_buf(read_mem);\n+            let read_buf_ptr: *Buf = &read_buf;\n+            let open_req = FsRequest::new();\n+            do open_req.open(&loop_, &path_str.to_c_str(), create_flags as int,\n+                             mode as int) |req, uverr| {\n+                assert!(uverr.is_none());\n+                let fd = req.get_result();\n+                let buf = unsafe { *write_buf_ptr };\n+                let write_req = FsRequest::new();\n+                do write_req.write(&req.get_loop(), fd, buf, -1) |req, uverr| {\n+                    let close_req = FsRequest::new();\n+                    do close_req.close(&req.get_loop(), fd) |req, _| {\n+                        assert!(uverr.is_none());\n+                        let loop_ = req.get_loop();\n+                        let open_req = FsRequest::new();\n+                        do open_req.open(&loop_, &path_str.to_c_str(),\n+                                         read_flags as int,0) |req, uverr| {\n+                            assert!(uverr.is_none());\n+                            let loop_ = req.get_loop();\n+                            let fd = req.get_result();\n+                            let read_buf = unsafe { *read_buf_ptr };\n+                            let read_req = FsRequest::new();\n+                            do read_req.read(&loop_, fd, read_buf, 0) |req, uverr| {\n+                                assert!(uverr.is_none());\n+                                let loop_ = req.get_loop();\n+                                // we know nread >=0 because uverr is none..\n+                                let nread = req.get_result() as uint;\n+                                // nread == 0 would be EOF\n+                                if nread > 0 {\n+                                    let read_str = unsafe {\n+                                        let read_buf = *read_buf_ptr;\n+                                        str::from_utf8(\n+                                            vec::from_buf(\n+                                                read_buf.base, nread))\n+                                    };\n+                                    assert!(read_str == ~\"hello\");\n+                                    let close_req = FsRequest::new();\n+                                    do close_req.close(&loop_, fd) |req,uverr| {\n+                                        assert!(uverr.is_none());\n+                                        let loop_ = &req.get_loop();\n+                                        let unlink_req = FsRequest::new();\n+                                        do unlink_req.unlink(loop_,\n+                                                             &path_str.to_c_str())\n+                                        |_,uverr| {\n+                                            assert!(uverr.is_none());\n+                                        };\n+                                    };\n+                                };\n+                            };\n+                        };\n+                    };\n+                };\n+            };\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn file_test_full_simple_sync() {\n+        do run_in_bare_thread {\n+            // setup\n+            let mut loop_ = Loop::new();\n+            let create_flags = O_RDWR |\n+                O_CREAT;\n+            let read_flags = O_RDONLY;\n+            // 0644\n+            let mode = S_IWUSR |\n+                S_IRUSR;\n+                //S_IRGRP |\n+                //S_IROTH;\n+            let path_str = \"./tmp/file_full_simple_sync.txt\";\n+            let write_val = \"hello\".as_bytes().to_owned();\n+            let write_buf = slice_to_uv_buf(write_val);\n+            // open/create\n+            let open_req = FsRequest::new();\n+            let result = open_req.open_sync(&loop_, &path_str.to_c_str(),\n+                                            create_flags as int, mode as int);\n+            assert!(result.is_ok());\n+            let fd = result.unwrap();\n+            // write\n+            let write_req = FsRequest::new();\n+            let result = write_req.write_sync(&loop_, fd, write_buf, -1);\n+            assert!(result.is_ok());\n+            // close\n+            let close_req = FsRequest::new();\n+            let result = close_req.close_sync(&loop_, fd);\n+            assert!(result.is_ok());\n+            // re-open\n+            let open_req = FsRequest::new();\n+            let result = open_req.open_sync(&loop_, &path_str.to_c_str(),\n+                                                   read_flags as int,0);\n+            assert!(result.is_ok());\n+            let len = 1028;\n+            let fd = result.unwrap();\n+            // read\n+            let read_mem: ~[u8] = vec::from_elem(len, 0u8);\n+            let buf = slice_to_uv_buf(read_mem);\n+            let read_req = FsRequest::new();\n+            let result = read_req.read_sync(&loop_, fd, buf, 0);\n+            assert!(result.is_ok());\n+            let nread = result.unwrap();\n+            // nread == 0 would be EOF.. we know it's >= zero because otherwise\n+            // the above assert would fail\n+            if nread > 0 {\n+                let read_str = str::from_utf8(\n+                    read_mem.slice(0, nread as uint));\n+                assert!(read_str == ~\"hello\");\n+                // close\n+                let close_req = FsRequest::new();\n+                let result = close_req.close_sync(&loop_, fd);\n+                assert!(result.is_ok());\n+                // unlink\n+                let unlink_req = FsRequest::new();\n+                let result = unlink_req.unlink_sync(&loop_, &path_str.to_c_str());\n+                assert!(result.is_ok());\n+            } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n+            loop_.close();\n+        }\n+    }\n+\n+    fn naive_print(loop_: &Loop, input: &str) {\n+        let write_val = input.as_bytes();\n+        let write_buf = slice_to_uv_buf(write_val);\n+        let write_req = FsRequest::new();\n+        write_req.write_sync(loop_, STDOUT_FILENO, write_buf, -1);\n+    }\n+\n+    #[test]\n+    fn file_test_write_to_stdout() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            naive_print(&loop_, \"zanzibar!\\n\");\n+            loop_.run();\n+            loop_.close();\n+        };\n+    }\n+    #[test]\n+    fn file_test_stat_simple() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let path = \"./tmp/file_test_stat_simple.txt\";\n+            let create_flags = O_RDWR |\n+                O_CREAT;\n+            let mode = S_IWUSR |\n+                S_IRUSR;\n+            let write_val = \"hello\".as_bytes().to_owned();\n+            let write_buf  = slice_to_uv_buf(write_val);\n+            let write_buf_ptr: *Buf = &write_buf;\n+            let open_req = FsRequest::new();\n+            do open_req.open(&loop_, &path.to_c_str(), create_flags as int,\n+                             mode as int) |req, uverr| {\n+                assert!(uverr.is_none());\n+                let fd = req.get_result();\n+                let buf = unsafe { *write_buf_ptr };\n+                let write_req = FsRequest::new();\n+                do write_req.write(&req.get_loop(), fd, buf, 0) |req, uverr| {\n+                    assert!(uverr.is_none());\n+                    let loop_ = req.get_loop();\n+                    let stat_req = FsRequest::new();\n+                    do stat_req.stat(&loop_, &path.to_c_str()) |req, uverr| {\n+                        assert!(uverr.is_none());\n+                        let loop_ = req.get_loop();\n+                        let stat = req.get_stat();\n+                        let sz: uint = stat.st_size as uint;\n+                        assert!(sz > 0);\n+                        let close_req = FsRequest::new();\n+                        do close_req.close(&loop_, fd) |req, uverr| {\n+                            assert!(uverr.is_none());\n+                            let loop_ = req.get_loop();\n+                            let unlink_req = FsRequest::new();\n+                            do unlink_req.unlink(&loop_,\n+                                                 &path.to_c_str()) |req,uverr| {\n+                                assert!(uverr.is_none());\n+                                let loop_ = req.get_loop();\n+                                let stat_req = FsRequest::new();\n+                                do stat_req.stat(&loop_,\n+                                                 &path.to_c_str()) |_, uverr| {\n+                                    // should cause an error because the\n+                                    // file doesn't exist anymore\n+                                    assert!(uverr.is_some());\n+                                };\n+                            };\n+                        };\n+                    };\n+                };\n+            };\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn file_test_mk_rm_dir() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let path = \"./tmp/mk_rm_dir\";\n+            let mode = S_IWUSR |\n+                S_IRUSR;\n+            let mkdir_req = FsRequest::new();\n+            do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n+                               mode as int) |req,uverr| {\n+                assert!(uverr.is_none());\n+                let loop_ = req.get_loop();\n+                let stat_req = FsRequest::new();\n+                do stat_req.stat(&loop_, &path.to_c_str()) |req, uverr| {\n+                    assert!(uverr.is_none());\n+                    let loop_ = req.get_loop();\n+                    let stat = req.get_stat();\n+                    naive_print(&loop_, format!(\"{:?}\", stat));\n+                    assert!(stat.is_dir());\n+                    let rmdir_req = FsRequest::new();\n+                    do rmdir_req.rmdir(&loop_, &path.to_c_str()) |req,uverr| {\n+                        assert!(uverr.is_none());\n+                        let loop_ = req.get_loop();\n+                        let stat_req = FsRequest::new();\n+                        do stat_req.stat(&loop_, &path.to_c_str()) |_req, uverr| {\n+                            assert!(uverr.is_some());\n+                        }\n+                    }\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+    #[test]\n+    fn file_test_mkdir_chokes_on_double_create() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let path = \"./tmp/double_create_dir\";\n+            let mode = S_IWUSR |\n+                S_IRUSR;\n+            let mkdir_req = FsRequest::new();\n+            do mkdir_req.mkdir(&loop_, &path.to_c_str(), mode as int) |req,uverr| {\n+                assert!(uverr.is_none());\n+                let loop_ = req.get_loop();\n+                let mkdir_req = FsRequest::new();\n+                do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n+                                   mode as int) |req,uverr| {\n+                    assert!(uverr.is_some());\n+                    let loop_ = req.get_loop();\n+                    let _stat = req.get_stat();\n+                    let rmdir_req = FsRequest::new();\n+                    do rmdir_req.rmdir(&loop_, &path.to_c_str()) |req,uverr| {\n+                        assert!(uverr.is_none());\n+                        let _loop = req.get_loop();\n+                    }\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+    #[test]\n+    fn file_test_rmdir_chokes_on_nonexistant_path() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let path = \"./tmp/never_existed_dir\";\n+            let rmdir_req = FsRequest::new();\n+            do rmdir_req.rmdir(&loop_, &path.to_c_str()) |_req, uverr| {\n+                assert!(uverr.is_some());\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+}"}, {"sha": "4f606b5f01f8a439ef63987737abb82da034bc91", "filename": "src/librustuv/idle.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::libc::c_int;\n+\n+use uvll;\n+use super::{Watcher, Loop, NativeHandle, IdleCallback, status_to_maybe_uv_error};\n+\n+pub struct IdleWatcher(*uvll::uv_idle_t);\n+impl Watcher for IdleWatcher { }\n+\n+impl IdleWatcher {\n+    pub fn new(loop_: &mut Loop) -> IdleWatcher {\n+        unsafe {\n+            let handle = uvll::malloc_handle(uvll::UV_IDLE);\n+            assert!(handle.is_not_null());\n+            assert_eq!(uvll::idle_init(loop_.native_handle(), handle), 0);\n+            let mut watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher\n+        }\n+    }\n+\n+    pub fn start(&mut self, cb: IdleCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            data.idle_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            assert_eq!(uvll::idle_start(self.native_handle(), idle_cb), 0)\n+        }\n+    }\n+\n+    pub fn restart(&mut self) {\n+        unsafe {\n+            assert!(self.get_watcher_data().idle_cb.is_some());\n+            assert_eq!(uvll::idle_start(self.native_handle(), idle_cb), 0)\n+        }\n+    }\n+\n+    pub fn stop(&mut self) {\n+        // NB: Not resetting the Rust idle_cb to None here because `stop` is\n+        // likely called from *within* the idle callback, causing a use after\n+        // free\n+\n+        unsafe {\n+            assert_eq!(uvll::idle_stop(self.native_handle()), 0);\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n+    fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n+        IdleWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_idle_t {\n+        match self { &IdleWatcher(ptr) => ptr }\n+    }\n+}\n+\n+extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+    let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+    let data = idle_watcher.get_watcher_data();\n+    let cb: &IdleCallback = data.idle_cb.get_ref();\n+    let status = status_to_maybe_uv_error(status);\n+    (*cb)(idle_watcher, status);\n+}\n+\n+#[cfg(test)]\n+mod test {\n+\n+    use Loop;\n+    use super::*;\n+    use std::unstable::run_in_bare_thread;\n+\n+    #[test]\n+    #[ignore(reason = \"valgrind - loop destroyed before watcher?\")]\n+    fn idle_new_then_close() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let idle_watcher = { IdleWatcher::new(&mut loop_) };\n+            idle_watcher.close(||());\n+        }\n+    }\n+\n+    #[test]\n+    fn idle_smoke_test() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n+            let mut count = 10;\n+            let count_ptr: *mut int = &mut count;\n+            do idle_watcher.start |idle_watcher, status| {\n+                let mut idle_watcher = idle_watcher;\n+                assert!(status.is_none());\n+                if unsafe { *count_ptr == 10 } {\n+                    idle_watcher.stop();\n+                    idle_watcher.close(||());\n+                } else {\n+                    unsafe { *count_ptr = *count_ptr + 1; }\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert_eq!(count, 10);\n+        }\n+    }\n+\n+    #[test]\n+    fn idle_start_stop_start() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n+            do idle_watcher.start |idle_watcher, status| {\n+                let mut idle_watcher = idle_watcher;\n+                assert!(status.is_none());\n+                idle_watcher.stop();\n+                do idle_watcher.start |idle_watcher, status| {\n+                    assert!(status.is_none());\n+                    let mut idle_watcher = idle_watcher;\n+                    idle_watcher.stop();\n+                    idle_watcher.close(||());\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+}"}, {"sha": "cbbed316d83df571fa228e892a679db09c89bb95", "filename": "src/librustuv/macros.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_escape];\n+\n+use std::fmt;\n+\n+macro_rules! uverrln (\n+    ($($arg:tt)*) => ( {\n+        format_args!(::macros::dumb_println, $($arg)*)\n+    } )\n+)\n+\n+// Some basic logging. Enabled by passing `--cfg uvdebug` to the libstd build.\n+macro_rules! uvdebug (\n+    ($($arg:tt)*) => ( {\n+        if cfg!(uvdebug) {\n+            uverrln!($($arg)*)\n+        }\n+    })\n+)\n+\n+pub fn dumb_println(args: &fmt::Arguments) {\n+    use std::rt::io::native::stdio::stderr;\n+    use std::rt::io::Writer;\n+\n+    let mut out = stderr();\n+    fmt::writeln(&mut out as &mut Writer, args);\n+}"}, {"sha": "0aaa931c9475e0ea7e52592fd5666ae0482621c6", "filename": "src/librustuv/net.rs", "status": "added", "additions": 851, "deletions": 0, "changes": 851, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,851 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::libc::{size_t, ssize_t, c_int, c_void, c_uint};\n+use std::vec;\n+use std::str;\n+use std::rt::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n+\n+use uvll;\n+use uvll::*;\n+use super::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback,\n+            UdpSendCallback, Loop, Watcher, Request, UvError, Buf, NativeHandle,\n+            status_to_maybe_uv_error, empty_buf};\n+\n+pub struct UvAddrInfo(*uvll::addrinfo);\n+\n+pub enum UvSocketAddr {\n+    UvIpv4SocketAddr(*sockaddr_in),\n+    UvIpv6SocketAddr(*sockaddr_in6),\n+}\n+\n+pub fn sockaddr_to_UvSocketAddr(addr: *uvll::sockaddr) -> UvSocketAddr {\n+    unsafe {\n+        assert!((is_ip4_addr(addr) || is_ip6_addr(addr)));\n+        assert!(!(is_ip4_addr(addr) && is_ip6_addr(addr)));\n+        match addr {\n+            _ if is_ip4_addr(addr) => UvIpv4SocketAddr(addr as *uvll::sockaddr_in),\n+            _ if is_ip6_addr(addr) => UvIpv6SocketAddr(addr as *uvll::sockaddr_in6),\n+            _ => fail!(),\n+        }\n+    }\n+}\n+\n+fn socket_addr_as_uv_socket_addr<T>(addr: SocketAddr, f: &fn(UvSocketAddr) -> T) -> T {\n+    let malloc = match addr.ip {\n+        Ipv4Addr(*) => malloc_ip4_addr,\n+        Ipv6Addr(*) => malloc_ip6_addr,\n+    };\n+    let wrap = match addr.ip {\n+        Ipv4Addr(*) => UvIpv4SocketAddr,\n+        Ipv6Addr(*) => UvIpv6SocketAddr,\n+    };\n+    let free = match addr.ip {\n+        Ipv4Addr(*) => free_ip4_addr,\n+        Ipv6Addr(*) => free_ip6_addr,\n+    };\n+\n+    let addr = unsafe { malloc(addr.ip.to_str(), addr.port as int) };\n+    do (|| {\n+        f(wrap(addr))\n+    }).finally {\n+        unsafe { free(addr) };\n+    }\n+}\n+\n+fn uv_socket_addr_as_socket_addr<T>(addr: UvSocketAddr, f: &fn(SocketAddr) -> T) -> T {\n+    let ip_size = match addr {\n+        UvIpv4SocketAddr(*) => 4/*groups of*/ * 3/*digits separated by*/ + 3/*periods*/,\n+        UvIpv6SocketAddr(*) => 8/*groups of*/ * 4/*hex digits separated by*/ + 7 /*colons*/,\n+    };\n+    let ip_name = {\n+        let buf = vec::from_elem(ip_size + 1 /*null terminated*/, 0u8);\n+        unsafe {\n+            let buf_ptr = vec::raw::to_ptr(buf);\n+            match addr {\n+                UvIpv4SocketAddr(addr) => uvll::ip4_name(addr, buf_ptr, ip_size as size_t),\n+                UvIpv6SocketAddr(addr) => uvll::ip6_name(addr, buf_ptr, ip_size as size_t),\n+            }\n+        };\n+        buf\n+    };\n+    let ip_port = unsafe {\n+        let port = match addr {\n+            UvIpv4SocketAddr(addr) => uvll::ip4_port(addr),\n+            UvIpv6SocketAddr(addr) => uvll::ip6_port(addr),\n+        };\n+        port as u16\n+    };\n+    let ip_str = str::from_utf8_slice(ip_name).trim_right_chars(&'\\x00');\n+    let ip_addr = FromStr::from_str(ip_str).unwrap();\n+\n+    // finally run the closure\n+    f(SocketAddr { ip: ip_addr, port: ip_port })\n+}\n+\n+pub fn uv_socket_addr_to_socket_addr(addr: UvSocketAddr) -> SocketAddr {\n+    use std::util;\n+    uv_socket_addr_as_socket_addr(addr, util::id)\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_ip4_conversion() {\n+    use std::rt;\n+    let ip4 = rt::test::next_test_ip4();\n+    assert_eq!(ip4, socket_addr_as_uv_socket_addr(ip4, uv_socket_addr_to_socket_addr));\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_ip6_conversion() {\n+    use std::rt;\n+    let ip6 = rt::test::next_test_ip6();\n+    assert_eq!(ip6, socket_addr_as_uv_socket_addr(ip6, uv_socket_addr_to_socket_addr));\n+}\n+\n+// uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n+// and uv_file_t\n+pub struct StreamWatcher(*uvll::uv_stream_t);\n+impl Watcher for StreamWatcher { }\n+\n+impl StreamWatcher {\n+    pub fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n+        unsafe {\n+            match uvll::read_start(self.native_handle(), alloc_cb, read_cb) {\n+                0 => {\n+                    let data = self.get_watcher_data();\n+                    data.alloc_cb = Some(alloc);\n+                    data.read_cb = Some(cb);\n+                }\n+                n => {\n+                    cb(*self, 0, empty_buf(), Some(UvError(n)))\n+                }\n+            }\n+        }\n+\n+        extern fn alloc_cb(stream: *uvll::uv_stream_t, suggested_size: size_t) -> Buf {\n+            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n+            let alloc_cb = stream_watcher.get_watcher_data().alloc_cb.get_ref();\n+            return (*alloc_cb)(suggested_size as uint);\n+        }\n+\n+        extern fn read_cb(stream: *uvll::uv_stream_t, nread: ssize_t, buf: Buf) {\n+            uvdebug!(\"buf addr: {}\", buf.base);\n+            uvdebug!(\"buf len: {}\", buf.len);\n+            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n+            let cb = stream_watcher.get_watcher_data().read_cb.get_ref();\n+            let status = status_to_maybe_uv_error(nread as c_int);\n+            (*cb)(stream_watcher, nread as int, buf, status);\n+        }\n+    }\n+\n+    pub fn read_stop(&mut self) {\n+        // It would be nice to drop the alloc and read callbacks here,\n+        // but read_stop may be called from inside one of them and we\n+        // would end up freeing the in-use environment\n+        let handle = self.native_handle();\n+        unsafe { assert_eq!(uvll::read_stop(handle), 0); }\n+    }\n+\n+    pub fn write(&mut self, buf: Buf, cb: ConnectionCallback) {\n+        let req = WriteRequest::new();\n+        return unsafe {\n+            match uvll::write(req.native_handle(), self.native_handle(),\n+                              [buf], write_cb) {\n+                0 => {\n+                    let data = self.get_watcher_data();\n+                    assert!(data.write_cb.is_none());\n+                    data.write_cb = Some(cb);\n+                }\n+                n => {\n+                    req.delete();\n+                    cb(*self, Some(UvError(n)))\n+                }\n+            }\n+        };\n+\n+        extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n+            let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n+            let mut stream_watcher = write_request.stream();\n+            write_request.delete();\n+            let cb = stream_watcher.get_watcher_data().write_cb.take_unwrap();\n+            let status = status_to_maybe_uv_error(status);\n+            cb(stream_watcher, status);\n+        }\n+    }\n+\n+\n+    pub fn listen(&mut self, cb: ConnectionCallback) -> Result<(), UvError> {\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.connect_cb.is_none());\n+            data.connect_cb = Some(cb);\n+        }\n+\n+        return unsafe {\n+            static BACKLOG: c_int = 128; // XXX should be configurable\n+            match uvll::listen(self.native_handle(), BACKLOG, connection_cb) {\n+                0 => Ok(()),\n+                n => Err(UvError(n))\n+            }\n+        };\n+\n+        extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n+            uvdebug!(\"connection_cb\");\n+            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n+            let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n+            let status = status_to_maybe_uv_error(status);\n+            (*cb)(stream_watcher, status);\n+        }\n+    }\n+\n+    pub fn accept(&mut self, stream: StreamWatcher) {\n+        let self_handle = self.native_handle() as *c_void;\n+        let stream_handle = stream.native_handle() as *c_void;\n+        assert_eq!(0, unsafe { uvll::accept(self_handle, stream_handle) } );\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n+    fn from_native_handle(handle: *uvll::uv_stream_t) -> StreamWatcher {\n+        StreamWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_stream_t {\n+        match self { &StreamWatcher(ptr) => ptr }\n+    }\n+}\n+\n+pub struct TcpWatcher(*uvll::uv_tcp_t);\n+impl Watcher for TcpWatcher { }\n+\n+impl TcpWatcher {\n+    pub fn new(loop_: &Loop) -> TcpWatcher {\n+        unsafe {\n+            let handle = malloc_handle(UV_TCP);\n+            assert!(handle.is_not_null());\n+            assert_eq!(0, uvll::tcp_init(loop_.native_handle(), handle));\n+            let mut watcher: TcpWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher;\n+        }\n+    }\n+\n+    pub fn bind(&mut self, address: SocketAddr) -> Result<(), UvError> {\n+        do socket_addr_as_uv_socket_addr(address) |addr| {\n+            let result = unsafe {\n+                match addr {\n+                    UvIpv4SocketAddr(addr) => uvll::tcp_bind(self.native_handle(), addr),\n+                    UvIpv6SocketAddr(addr) => uvll::tcp_bind6(self.native_handle(), addr),\n+                }\n+            };\n+            match result {\n+                0 => Ok(()),\n+                _ => Err(UvError(result)),\n+            }\n+        }\n+    }\n+\n+    pub fn connect(&mut self, address: SocketAddr, cb: ConnectionCallback) {\n+        unsafe {\n+            assert!(self.get_watcher_data().connect_cb.is_none());\n+            self.get_watcher_data().connect_cb = Some(cb);\n+\n+            let connect_handle = ConnectRequest::new().native_handle();\n+            uvdebug!(\"connect_t: {}\", connect_handle);\n+            do socket_addr_as_uv_socket_addr(address) |addr| {\n+                let result = match addr {\n+                    UvIpv4SocketAddr(addr) => uvll::tcp_connect(connect_handle,\n+                                                      self.native_handle(), addr, connect_cb),\n+                    UvIpv6SocketAddr(addr) => uvll::tcp_connect6(connect_handle,\n+                                                       self.native_handle(), addr, connect_cb),\n+                };\n+                assert_eq!(0, result);\n+            }\n+\n+            extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n+                uvdebug!(\"connect_t: {}\", req);\n+                let connect_request: ConnectRequest = NativeHandle::from_native_handle(req);\n+                let mut stream_watcher = connect_request.stream();\n+                connect_request.delete();\n+                let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n+                let status = status_to_maybe_uv_error(status);\n+                cb(stream_watcher, status);\n+            }\n+        }\n+    }\n+\n+    pub fn as_stream(&self) -> StreamWatcher {\n+        NativeHandle::from_native_handle(self.native_handle() as *uvll::uv_stream_t)\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n+    fn from_native_handle(handle: *uvll::uv_tcp_t) -> TcpWatcher {\n+        TcpWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_tcp_t {\n+        match self { &TcpWatcher(ptr) => ptr }\n+    }\n+}\n+\n+pub struct UdpWatcher(*uvll::uv_udp_t);\n+impl Watcher for UdpWatcher { }\n+\n+impl UdpWatcher {\n+    pub fn new(loop_: &Loop) -> UdpWatcher {\n+        unsafe {\n+            let handle = malloc_handle(UV_UDP);\n+            assert!(handle.is_not_null());\n+            assert_eq!(0, uvll::udp_init(loop_.native_handle(), handle));\n+            let mut watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher;\n+        }\n+    }\n+\n+    pub fn bind(&mut self, address: SocketAddr) -> Result<(), UvError> {\n+        do socket_addr_as_uv_socket_addr(address) |addr| {\n+            let result = unsafe {\n+                match addr {\n+                    UvIpv4SocketAddr(addr) => uvll::udp_bind(self.native_handle(), addr, 0u32),\n+                    UvIpv6SocketAddr(addr) => uvll::udp_bind6(self.native_handle(), addr, 0u32),\n+                }\n+            };\n+            match result {\n+                0 => Ok(()),\n+                _ => Err(UvError(result)),\n+            }\n+        }\n+    }\n+\n+    pub fn recv_start(&mut self, alloc: AllocCallback, cb: UdpReceiveCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            data.alloc_cb = Some(alloc);\n+            data.udp_recv_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::udp_recv_start(self.native_handle(), alloc_cb, recv_cb); }\n+\n+        extern fn alloc_cb(handle: *uvll::uv_udp_t, suggested_size: size_t) -> Buf {\n+            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n+            let alloc_cb = udp_watcher.get_watcher_data().alloc_cb.get_ref();\n+            return (*alloc_cb)(suggested_size as uint);\n+        }\n+\n+        extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: Buf,\n+                          addr: *uvll::sockaddr, flags: c_uint) {\n+            // When there's no data to read the recv callback can be a no-op.\n+            // This can happen if read returns EAGAIN/EWOULDBLOCK. By ignoring\n+            // this we just drop back to kqueue and wait for the next callback.\n+            if nread == 0 {\n+                return;\n+            }\n+\n+            uvdebug!(\"buf addr: {}\", buf.base);\n+            uvdebug!(\"buf len: {}\", buf.len);\n+            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n+            let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n+            let status = status_to_maybe_uv_error(nread as c_int);\n+            let addr = uv_socket_addr_to_socket_addr(sockaddr_to_UvSocketAddr(addr));\n+            (*cb)(udp_watcher, nread as int, buf, addr, flags as uint, status);\n+        }\n+    }\n+\n+    pub fn recv_stop(&mut self) {\n+        unsafe { uvll::udp_recv_stop(self.native_handle()); }\n+    }\n+\n+    pub fn send(&mut self, buf: Buf, address: SocketAddr, cb: UdpSendCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.udp_send_cb.is_none());\n+            data.udp_send_cb = Some(cb);\n+        }\n+\n+        let req = UdpSendRequest::new();\n+        do socket_addr_as_uv_socket_addr(address) |addr| {\n+            let result = unsafe {\n+                match addr {\n+                    UvIpv4SocketAddr(addr) => uvll::udp_send(req.native_handle(),\n+                                                   self.native_handle(), [buf], addr, send_cb),\n+                    UvIpv6SocketAddr(addr) => uvll::udp_send6(req.native_handle(),\n+                                                    self.native_handle(), [buf], addr, send_cb),\n+                }\n+            };\n+            assert_eq!(0, result);\n+        }\n+\n+        extern fn send_cb(req: *uvll::uv_udp_send_t, status: c_int) {\n+            let send_request: UdpSendRequest = NativeHandle::from_native_handle(req);\n+            let mut udp_watcher = send_request.handle();\n+            send_request.delete();\n+            let cb = udp_watcher.get_watcher_data().udp_send_cb.take_unwrap();\n+            let status = status_to_maybe_uv_error(status);\n+            cb(udp_watcher, status);\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_udp_t> for UdpWatcher {\n+    fn from_native_handle(handle: *uvll::uv_udp_t) -> UdpWatcher {\n+        UdpWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_udp_t {\n+        match self { &UdpWatcher(ptr) => ptr }\n+    }\n+}\n+\n+// uv_connect_t is a subclass of uv_req_t\n+pub struct ConnectRequest(*uvll::uv_connect_t);\n+impl Request for ConnectRequest { }\n+\n+impl ConnectRequest {\n+\n+    pub fn new() -> ConnectRequest {\n+        let connect_handle = unsafe { malloc_req(UV_CONNECT) };\n+        assert!(connect_handle.is_not_null());\n+        ConnectRequest(connect_handle as *uvll::uv_connect_t)\n+    }\n+\n+    fn stream(&self) -> StreamWatcher {\n+        unsafe {\n+            let stream_handle = uvll::get_stream_handle_from_connect_req(self.native_handle());\n+            NativeHandle::from_native_handle(stream_handle)\n+        }\n+    }\n+\n+    fn delete(self) {\n+        unsafe { free_req(self.native_handle() as *c_void) }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_connect_t> for ConnectRequest {\n+    fn from_native_handle(handle: *uvll:: uv_connect_t) -> ConnectRequest {\n+        ConnectRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_connect_t {\n+        match self { &ConnectRequest(ptr) => ptr }\n+    }\n+}\n+\n+pub struct WriteRequest(*uvll::uv_write_t);\n+\n+impl Request for WriteRequest { }\n+\n+impl WriteRequest {\n+    pub fn new() -> WriteRequest {\n+        let write_handle = unsafe { malloc_req(UV_WRITE) };\n+        assert!(write_handle.is_not_null());\n+        WriteRequest(write_handle as *uvll::uv_write_t)\n+    }\n+\n+    pub fn stream(&self) -> StreamWatcher {\n+        unsafe {\n+            let stream_handle = uvll::get_stream_handle_from_write_req(self.native_handle());\n+            NativeHandle::from_native_handle(stream_handle)\n+        }\n+    }\n+\n+    pub fn delete(self) {\n+        unsafe { free_req(self.native_handle() as *c_void) }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n+    fn from_native_handle(handle: *uvll:: uv_write_t) -> WriteRequest {\n+        WriteRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_write_t {\n+        match self { &WriteRequest(ptr) => ptr }\n+    }\n+}\n+\n+pub struct UdpSendRequest(*uvll::uv_udp_send_t);\n+impl Request for UdpSendRequest { }\n+\n+impl UdpSendRequest {\n+    pub fn new() -> UdpSendRequest {\n+        let send_handle = unsafe { malloc_req(UV_UDP_SEND) };\n+        assert!(send_handle.is_not_null());\n+        UdpSendRequest(send_handle as *uvll::uv_udp_send_t)\n+    }\n+\n+    pub fn handle(&self) -> UdpWatcher {\n+        let send_request_handle = unsafe {\n+            uvll::get_udp_handle_from_send_req(self.native_handle())\n+        };\n+        NativeHandle::from_native_handle(send_request_handle)\n+    }\n+\n+    pub fn delete(self) {\n+        unsafe { free_req(self.native_handle() as *c_void) }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_udp_send_t> for UdpSendRequest {\n+    fn from_native_handle(handle: *uvll::uv_udp_send_t) -> UdpSendRequest {\n+        UdpSendRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_udp_send_t {\n+        match self { &UdpSendRequest(ptr) => ptr }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use std::util::ignore;\n+    use std::cell::Cell;\n+    use std::vec;\n+    use std::unstable::run_in_bare_thread;\n+    use std::rt::thread::Thread;\n+    use std::rt::test::*;\n+    use super::super::{Loop, AllocCallback};\n+    use super::super::{vec_from_uv_buf, vec_to_uv_buf, slice_to_uv_buf};\n+\n+    #[test]\n+    fn connect_close_ip4() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            // Connect to a port where nobody is listening\n+            let addr = next_test_ip4();\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                uvdebug!(\"tcp_watcher.connect!\");\n+                assert!(status.is_some());\n+                assert_eq!(status.unwrap().name(), ~\"ECONNREFUSED\");\n+                stream_watcher.close(||());\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn connect_close_ip6() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            // Connect to a port where nobody is listening\n+            let addr = next_test_ip6();\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                uvdebug!(\"tcp_watcher.connect!\");\n+                assert!(status.is_some());\n+                assert_eq!(status.unwrap().name(), ~\"ECONNREFUSED\");\n+                stream_watcher.close(||());\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn udp_bind_close_ip4() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let mut udp_watcher = { UdpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip4();\n+            udp_watcher.bind(addr);\n+            udp_watcher.close(||());\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn udp_bind_close_ip6() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let mut udp_watcher = { UdpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip6();\n+            udp_watcher.bind(addr);\n+            udp_watcher.close(||());\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn listen_ip4() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip4();\n+            server_tcp_watcher.bind(addr);\n+            let loop_ = loop_;\n+            uvdebug!(\"listening\");\n+            let mut stream = server_tcp_watcher.as_stream();\n+            let res = do stream.listen |mut server_stream_watcher, status| {\n+                uvdebug!(\"listened!\");\n+                assert!(status.is_none());\n+                let mut loop_ = loop_;\n+                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                let count_cell = Cell::new(0);\n+                let server_stream_watcher = server_stream_watcher;\n+                uvdebug!(\"starting read\");\n+                let alloc: AllocCallback = |size| {\n+                    vec_to_uv_buf(vec::from_elem(size, 0u8))\n+                };\n+                do client_tcp_watcher.read_start(alloc) |stream_watcher, nread, buf, status| {\n+\n+                    uvdebug!(\"i'm reading!\");\n+                    let buf = vec_from_uv_buf(buf);\n+                    let mut count = count_cell.take();\n+                    if status.is_none() {\n+                        uvdebug!(\"got {} bytes\", nread);\n+                        let buf = buf.unwrap();\n+                        for byte in buf.slice(0, nread as uint).iter() {\n+                            assert!(*byte == count as u8);\n+                            uvdebug!(\"{}\", *byte as uint);\n+                            count += 1;\n+                        }\n+                    } else {\n+                        assert_eq!(count, MAX);\n+                        do stream_watcher.close {\n+                            server_stream_watcher.close(||());\n+                        }\n+                    }\n+                    count_cell.put_back(count);\n+                }\n+            };\n+\n+            assert!(res.is_ok());\n+\n+            let client_thread = do Thread::start {\n+                uvdebug!(\"starting client thread\");\n+                let mut loop_ = Loop::new();\n+                let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+                do tcp_watcher.connect(addr) |mut stream_watcher, status| {\n+                    uvdebug!(\"connecting\");\n+                    assert!(status.is_none());\n+                    let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n+                    let buf = slice_to_uv_buf(msg);\n+                    let msg_cell = Cell::new(msg);\n+                    do stream_watcher.write(buf) |stream_watcher, status| {\n+                        uvdebug!(\"writing\");\n+                        assert!(status.is_none());\n+                        let msg_cell = Cell::new(msg_cell.take());\n+                        stream_watcher.close(||ignore(msg_cell.take()));\n+                    }\n+                }\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            let mut loop_ = loop_;\n+            loop_.run();\n+            loop_.close();\n+            client_thread.join();\n+        };\n+    }\n+\n+    #[test]\n+    fn listen_ip6() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip6();\n+            server_tcp_watcher.bind(addr);\n+            let loop_ = loop_;\n+            uvdebug!(\"listening\");\n+            let mut stream = server_tcp_watcher.as_stream();\n+            let res = do stream.listen |mut server_stream_watcher, status| {\n+                uvdebug!(\"listened!\");\n+                assert!(status.is_none());\n+                let mut loop_ = loop_;\n+                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                let count_cell = Cell::new(0);\n+                let server_stream_watcher = server_stream_watcher;\n+                uvdebug!(\"starting read\");\n+                let alloc: AllocCallback = |size| {\n+                    vec_to_uv_buf(vec::from_elem(size, 0u8))\n+                };\n+                do client_tcp_watcher.read_start(alloc)\n+                    |stream_watcher, nread, buf, status| {\n+\n+                    uvdebug!(\"i'm reading!\");\n+                    let buf = vec_from_uv_buf(buf);\n+                    let mut count = count_cell.take();\n+                    if status.is_none() {\n+                        uvdebug!(\"got {} bytes\", nread);\n+                        let buf = buf.unwrap();\n+                        let r = buf.slice(0, nread as uint);\n+                        for byte in r.iter() {\n+                            assert!(*byte == count as u8);\n+                            uvdebug!(\"{}\", *byte as uint);\n+                            count += 1;\n+                        }\n+                    } else {\n+                        assert_eq!(count, MAX);\n+                        do stream_watcher.close {\n+                            server_stream_watcher.close(||());\n+                        }\n+                    }\n+                    count_cell.put_back(count);\n+                }\n+            };\n+            assert!(res.is_ok());\n+\n+            let client_thread = do Thread::start {\n+                uvdebug!(\"starting client thread\");\n+                let mut loop_ = Loop::new();\n+                let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+                do tcp_watcher.connect(addr) |mut stream_watcher, status| {\n+                    uvdebug!(\"connecting\");\n+                    assert!(status.is_none());\n+                    let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n+                    let buf = slice_to_uv_buf(msg);\n+                    let msg_cell = Cell::new(msg);\n+                    do stream_watcher.write(buf) |stream_watcher, status| {\n+                        uvdebug!(\"writing\");\n+                        assert!(status.is_none());\n+                        let msg_cell = Cell::new(msg_cell.take());\n+                        stream_watcher.close(||ignore(msg_cell.take()));\n+                    }\n+                }\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            let mut loop_ = loop_;\n+            loop_.run();\n+            loop_.close();\n+            client_thread.join();\n+        }\n+    }\n+\n+    #[test]\n+    fn udp_recv_ip4() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let server_addr = next_test_ip4();\n+            let client_addr = next_test_ip4();\n+\n+            let mut server = UdpWatcher::new(&loop_);\n+            assert!(server.bind(server_addr).is_ok());\n+\n+            uvdebug!(\"starting read\");\n+            let alloc: AllocCallback = |size| {\n+                vec_to_uv_buf(vec::from_elem(size, 0u8))\n+            };\n+\n+            do server.recv_start(alloc) |mut server, nread, buf, src, flags, status| {\n+                server.recv_stop();\n+                uvdebug!(\"i'm reading!\");\n+                assert!(status.is_none());\n+                assert_eq!(flags, 0);\n+                assert_eq!(src, client_addr);\n+\n+                let buf = vec_from_uv_buf(buf);\n+                let mut count = 0;\n+                uvdebug!(\"got {} bytes\", nread);\n+\n+                let buf = buf.unwrap();\n+                for &byte in buf.slice(0, nread as uint).iter() {\n+                    assert!(byte == count as u8);\n+                    uvdebug!(\"{}\", byte as uint);\n+                    count += 1;\n+                }\n+                assert_eq!(count, MAX);\n+\n+                server.close(||{});\n+            }\n+\n+            let thread = do Thread::start {\n+                let mut loop_ = Loop::new();\n+                let mut client = UdpWatcher::new(&loop_);\n+                assert!(client.bind(client_addr).is_ok());\n+                let msg = ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+                let buf = slice_to_uv_buf(msg);\n+                do client.send(buf, server_addr) |client, status| {\n+                    uvdebug!(\"writing\");\n+                    assert!(status.is_none());\n+                    client.close(||{});\n+                }\n+\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            loop_.run();\n+            loop_.close();\n+            thread.join();\n+        }\n+    }\n+\n+    #[test]\n+    fn udp_recv_ip6() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let server_addr = next_test_ip6();\n+            let client_addr = next_test_ip6();\n+\n+            let mut server = UdpWatcher::new(&loop_);\n+            assert!(server.bind(server_addr).is_ok());\n+\n+            uvdebug!(\"starting read\");\n+            let alloc: AllocCallback = |size| {\n+                vec_to_uv_buf(vec::from_elem(size, 0u8))\n+            };\n+\n+            do server.recv_start(alloc) |mut server, nread, buf, src, flags, status| {\n+                server.recv_stop();\n+                uvdebug!(\"i'm reading!\");\n+                assert!(status.is_none());\n+                assert_eq!(flags, 0);\n+                assert_eq!(src, client_addr);\n+\n+                let buf = vec_from_uv_buf(buf);\n+                let mut count = 0;\n+                uvdebug!(\"got {} bytes\", nread);\n+\n+                let buf = buf.unwrap();\n+                for &byte in buf.slice(0, nread as uint).iter() {\n+                    assert!(byte == count as u8);\n+                    uvdebug!(\"{}\", byte as uint);\n+                    count += 1;\n+                }\n+                assert_eq!(count, MAX);\n+\n+                server.close(||{});\n+            }\n+\n+            let thread = do Thread::start {\n+                let mut loop_ = Loop::new();\n+                let mut client = UdpWatcher::new(&loop_);\n+                assert!(client.bind(client_addr).is_ok());\n+                let msg = ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+                let buf = slice_to_uv_buf(msg);\n+                do client.send(buf, server_addr) |client, status| {\n+                    uvdebug!(\"writing\");\n+                    assert!(status.is_none());\n+                    client.close(||{});\n+                }\n+\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            loop_.run();\n+            loop_.close();\n+            thread.join();\n+        }\n+    }\n+}"}, {"sha": "b453da0cc9ea2ab2adec9121d25e1f565b30ad73", "filename": "src/librustuv/pipe.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::libc;\n+use std::c_str::CString;\n+\n+use super::{Loop, UvError, Watcher, NativeHandle, status_to_maybe_uv_error};\n+use super::ConnectionCallback;\n+use net;\n+use uvll;\n+\n+pub struct Pipe(*uvll::uv_pipe_t);\n+\n+impl Watcher for Pipe {}\n+\n+impl Pipe {\n+    pub fn new(loop_: &Loop, ipc: bool) -> Pipe {\n+        unsafe {\n+            let handle = uvll::malloc_handle(uvll::UV_NAMED_PIPE);\n+            assert!(handle.is_not_null());\n+            let ipc = ipc as libc::c_int;\n+            assert_eq!(uvll::pipe_init(loop_.native_handle(), handle, ipc), 0);\n+            let mut ret: Pipe =\n+                    NativeHandle::from_native_handle(handle);\n+            ret.install_watcher_data();\n+            ret\n+        }\n+    }\n+\n+    pub fn as_stream(&self) -> net::StreamWatcher {\n+        net::StreamWatcher(**self as *uvll::uv_stream_t)\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn open(&mut self, file: libc::c_int) -> Result<(), UvError> {\n+        match unsafe { uvll::pipe_open(self.native_handle(), file) } {\n+            0 => Ok(()),\n+            n => Err(UvError(n))\n+        }\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn bind(&mut self, name: &CString) -> Result<(), UvError> {\n+        do name.with_ref |name| {\n+            match unsafe { uvll::pipe_bind(self.native_handle(), name) } {\n+                0 => Ok(()),\n+                n => Err(UvError(n))\n+            }\n+        }\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn connect(&mut self, name: &CString, cb: ConnectionCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.connect_cb.is_none());\n+            data.connect_cb = Some(cb);\n+        }\n+\n+        let connect = net::ConnectRequest::new();\n+        let name = do name.with_ref |p| { p };\n+\n+        unsafe {\n+            uvll::pipe_connect(connect.native_handle(),\n+                               self.native_handle(),\n+                               name,\n+                               connect_cb)\n+        }\n+\n+        extern \"C\" fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {\n+            let connect_request: net::ConnectRequest =\n+                    NativeHandle::from_native_handle(req);\n+            let mut stream_watcher = connect_request.stream();\n+            connect_request.delete();\n+\n+            let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n+            let status = status_to_maybe_uv_error(status);\n+            cb(stream_watcher, status);\n+        }\n+    }\n+\n+}\n+\n+impl NativeHandle<*uvll::uv_pipe_t> for Pipe {\n+    fn from_native_handle(handle: *uvll::uv_pipe_t) -> Pipe {\n+        Pipe(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_pipe_t {\n+        match self { &Pipe(ptr) => ptr }\n+    }\n+}"}, {"sha": "2d746e329f44ae1953b604291e26a93389742575", "filename": "src/librustuv/process.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,202 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::Cell;\n+use std::libc;\n+use std::ptr;\n+use std::vec;\n+use std::rt::io::process::*;\n+\n+use super::{Watcher, Loop, NativeHandle, UvError};\n+use super::{status_to_maybe_uv_error, ExitCallback};\n+use uvio::{UvPipeStream, UvUnboundPipe};\n+use uvll;\n+\n+/// A process wraps the handle of the underlying uv_process_t.\n+pub struct Process(*uvll::uv_process_t);\n+\n+impl Watcher for Process {}\n+\n+impl Process {\n+    /// Creates a new process, ready to spawn inside an event loop\n+    pub fn new() -> Process {\n+        let handle = unsafe { uvll::malloc_handle(uvll::UV_PROCESS) };\n+        assert!(handle.is_not_null());\n+        let mut ret: Process = NativeHandle::from_native_handle(handle);\n+        ret.install_watcher_data();\n+        return ret;\n+    }\n+\n+    /// Spawn a new process inside the specified event loop.\n+    ///\n+    /// The `config` variable will be passed down to libuv, and the `exit_cb`\n+    /// will be run only once, when the process exits.\n+    ///\n+    /// Returns either the corresponding process object or an error which\n+    /// occurred.\n+    pub fn spawn(&mut self, loop_: &Loop, config: ProcessConfig,\n+                 exit_cb: ExitCallback)\n+                    -> Result<~[Option<~UvPipeStream>], UvError>\n+    {\n+        let cwd = config.cwd.map(|s| s.to_c_str());\n+\n+        extern fn on_exit(p: *uvll::uv_process_t,\n+                          exit_status: libc::c_int,\n+                          term_signal: libc::c_int) {\n+            let mut p: Process = NativeHandle::from_native_handle(p);\n+            let err = match exit_status {\n+                0 => None,\n+                _ => status_to_maybe_uv_error(-1)\n+            };\n+            p.get_watcher_data().exit_cb.take_unwrap()(p,\n+                                                       exit_status as int,\n+                                                       term_signal as int,\n+                                                       err);\n+        }\n+\n+        let io = config.io;\n+        let mut stdio = vec::with_capacity::<uvll::uv_stdio_container_t>(io.len());\n+        let mut ret_io = vec::with_capacity(io.len());\n+        unsafe {\n+            vec::raw::set_len(&mut stdio, io.len());\n+            for (slot, other) in stdio.iter().zip(io.iter()) {\n+                let io = set_stdio(slot as *uvll::uv_stdio_container_t, other,\n+                                   loop_);\n+                ret_io.push(io);\n+            }\n+        }\n+\n+        let exit_cb = Cell::new(exit_cb);\n+        let ret_io = Cell::new(ret_io);\n+        do with_argv(config.program, config.args) |argv| {\n+            do with_env(config.env) |envp| {\n+                let options = uvll::uv_process_options_t {\n+                    exit_cb: on_exit,\n+                    file: unsafe { *argv },\n+                    args: argv,\n+                    env: envp,\n+                    cwd: match cwd {\n+                        Some(ref cwd) => cwd.with_ref(|p| p),\n+                        None => ptr::null(),\n+                    },\n+                    flags: 0,\n+                    stdio_count: stdio.len() as libc::c_int,\n+                    stdio: stdio.as_imm_buf(|p, _| p),\n+                    uid: 0,\n+                    gid: 0,\n+                };\n+\n+                match unsafe {\n+                    uvll::spawn(loop_.native_handle(), **self, options)\n+                } {\n+                    0 => {\n+                        (*self).get_watcher_data().exit_cb = Some(exit_cb.take());\n+                        Ok(ret_io.take())\n+                    }\n+                    err => Err(UvError(err))\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Sends a signal to this process.\n+    ///\n+    /// This is a wrapper around `uv_process_kill`\n+    pub fn kill(&self, signum: int) -> Result<(), UvError> {\n+        match unsafe {\n+            uvll::process_kill(self.native_handle(), signum as libc::c_int)\n+        } {\n+            0 => Ok(()),\n+            err => Err(UvError(err))\n+        }\n+    }\n+\n+    /// Returns the process id of a spawned process\n+    pub fn pid(&self) -> libc::pid_t {\n+        unsafe { uvll::process_pid(**self) as libc::pid_t }\n+    }\n+}\n+\n+unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n+                    io: &StdioContainer,\n+                    loop_: &Loop) -> Option<~UvPipeStream> {\n+    match *io {\n+        Ignored => {\n+            uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE);\n+            None\n+        }\n+        InheritFd(fd) => {\n+            uvll::set_stdio_container_flags(dst, uvll::STDIO_INHERIT_FD);\n+            uvll::set_stdio_container_fd(dst, fd);\n+            None\n+        }\n+        CreatePipe(readable, writable) => {\n+            let mut flags = uvll::STDIO_CREATE_PIPE as libc::c_int;\n+            if readable {\n+                flags |= uvll::STDIO_READABLE_PIPE as libc::c_int;\n+            }\n+            if writable {\n+                flags |= uvll::STDIO_WRITABLE_PIPE as libc::c_int;\n+            }\n+            let pipe = UvUnboundPipe::new(loop_);\n+            let handle = pipe.pipe.as_stream().native_handle();\n+            uvll::set_stdio_container_flags(dst, flags);\n+            uvll::set_stdio_container_stream(dst, handle);\n+            Some(~UvPipeStream::new(pipe))\n+        }\n+    }\n+}\n+\n+/// Converts the program and arguments to the argv array expected by libuv\n+fn with_argv<T>(prog: &str, args: &[~str], f: &fn(**libc::c_char) -> T) -> T {\n+    // First, allocation space to put all the C-strings (we need to have\n+    // ownership of them somewhere\n+    let mut c_strs = vec::with_capacity(args.len() + 1);\n+    c_strs.push(prog.to_c_str());\n+    for arg in args.iter() {\n+        c_strs.push(arg.to_c_str());\n+    }\n+\n+    // Next, create the char** array\n+    let mut c_args = vec::with_capacity(c_strs.len() + 1);\n+    for s in c_strs.iter() {\n+        c_args.push(s.with_ref(|p| p));\n+    }\n+    c_args.push(ptr::null());\n+    c_args.as_imm_buf(|buf, _| f(buf))\n+}\n+\n+/// Converts the environment to the env array expected by libuv\n+fn with_env<T>(env: Option<&[(~str, ~str)]>, f: &fn(**libc::c_char) -> T) -> T {\n+    let env = match env {\n+        Some(s) => s,\n+        None => { return f(ptr::null()); }\n+    };\n+    // As with argv, create some temporary storage and then the actual array\n+    let mut envp = vec::with_capacity(env.len());\n+    for &(ref key, ref value) in env.iter() {\n+        envp.push(format!(\"{}={}\", *key, *value).to_c_str());\n+    }\n+    let mut c_envp = vec::with_capacity(envp.len() + 1);\n+    for s in envp.iter() {\n+        c_envp.push(s.with_ref(|p| p));\n+    }\n+    c_envp.push(ptr::null());\n+    c_envp.as_imm_buf(|buf, _| f(buf))\n+}\n+\n+impl NativeHandle<*uvll::uv_process_t> for Process {\n+    fn from_native_handle(handle: *uvll::uv_process_t) -> Process {\n+        Process(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_process_t {\n+        match self { &Process(ptr) => ptr }\n+    }\n+}"}, {"sha": "f483cfb0c658d23610b8bfdfe5659dd5f534f0b3", "filename": "src/librustuv/rustuv.rs", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Frustuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Frustuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Frustuv.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,424 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Bindings to libuv, along with the default implementation of `std::rt::rtio`.\n+\n+UV types consist of the event loop (Loop), Watchers, Requests and\n+Callbacks.\n+\n+Watchers and Requests encapsulate pointers to uv *handles*, which have\n+subtyping relationships with each other.  This subtyping is reflected\n+in the bindings with explicit or implicit coercions. For example, an\n+upcast from TcpWatcher to StreamWatcher is done with\n+`tcp_watcher.as_stream()`. In other cases a callback on a specific\n+type of watcher will be passed a watcher of a supertype.\n+\n+Currently all use of Request types (connect/write requests) are\n+encapsulated in the bindings and don't need to be dealt with by the\n+caller.\n+\n+# Safety note\n+\n+Due to the complex lifecycle of uv handles, as well as compiler bugs,\n+this module is not memory safe and requires explicit memory management,\n+via `close` and `delete` methods.\n+\n+*/\n+\n+#[link(name = \"rustuv\",\n+       vers = \"0.9-pre\",\n+       uuid = \"f3719011-0459-9b86-b11c-29265c0d0864\",\n+       url = \"https://github.com/mozilla/rust/tree/master/src/librustuv\")];\n+\n+#[license = \"MIT/ASL2\"];\n+#[crate_type = \"lib\"];\n+\n+#[feature(macro_rules, globs)];\n+\n+use std::str::raw::from_c_str;\n+use std::vec;\n+use std::ptr;\n+use std::str;\n+use std::libc::{c_void, c_int, size_t, malloc, free};\n+use std::cast::transmute;\n+use std::ptr::null;\n+use std::unstable::finally::Finally;\n+use std::rt::io::net::ip::SocketAddr;\n+use std::rt::io::signal::Signum;\n+\n+use std::rt::io::IoError;\n+\n+//#[cfg(test)] use unstable::run_in_bare_thread;\n+\n+pub use self::file::{FsRequest};\n+pub use self::net::{StreamWatcher, TcpWatcher, UdpWatcher};\n+pub use self::idle::IdleWatcher;\n+pub use self::timer::TimerWatcher;\n+pub use self::async::AsyncWatcher;\n+pub use self::process::Process;\n+pub use self::pipe::Pipe;\n+pub use self::signal::SignalWatcher;\n+\n+mod macros;\n+\n+/// The implementation of `rtio` for libuv\n+pub mod uvio;\n+\n+/// C bindings to libuv\n+pub mod uvll;\n+\n+pub mod file;\n+pub mod net;\n+pub mod idle;\n+pub mod timer;\n+pub mod async;\n+pub mod addrinfo;\n+pub mod process;\n+pub mod pipe;\n+pub mod tty;\n+pub mod signal;\n+\n+/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n+/// with dtors may not be destructured, but tuple structs can,\n+/// but the results are not correct.\n+pub struct Loop {\n+    priv handle: *uvll::uv_loop_t\n+}\n+\n+pub struct Handle(*uvll::uv_handle_t);\n+\n+impl Watcher for Handle {}\n+impl NativeHandle<*uvll::uv_handle_t> for Handle {\n+    fn from_native_handle(h: *uvll::uv_handle_t) -> Handle { Handle(h) }\n+    fn native_handle(&self) -> *uvll::uv_handle_t { **self }\n+}\n+\n+/// The trait implemented by uv 'watchers' (handles). Watchers are\n+/// non-owning wrappers around the uv handles and are not completely\n+/// safe - there may be multiple instances for a single underlying\n+/// handle.  Watchers are generally created, then `start`ed, `stop`ed\n+/// and `close`ed, but due to their complex life cycle may not be\n+/// entirely memory safe if used in unanticipated patterns.\n+pub trait Watcher { }\n+\n+pub trait Request { }\n+\n+/// A type that wraps a native handle\n+pub trait NativeHandle<T> {\n+    fn from_native_handle(T) -> Self;\n+    fn native_handle(&self) -> T;\n+}\n+\n+impl Loop {\n+    pub fn new() -> Loop {\n+        let handle = unsafe { uvll::loop_new() };\n+        assert!(handle.is_not_null());\n+        NativeHandle::from_native_handle(handle)\n+    }\n+\n+    pub fn run(&mut self) {\n+        unsafe { uvll::run(self.native_handle()) };\n+    }\n+\n+    pub fn close(&mut self) {\n+        unsafe { uvll::loop_delete(self.native_handle()) };\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_loop_t> for Loop {\n+    fn from_native_handle(handle: *uvll::uv_loop_t) -> Loop {\n+        Loop { handle: handle }\n+    }\n+    fn native_handle(&self) -> *uvll::uv_loop_t {\n+        self.handle\n+    }\n+}\n+\n+// XXX: The uv alloc callback also has a *uv_handle_t arg\n+pub type AllocCallback = ~fn(uint) -> Buf;\n+pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n+pub type NullCallback = ~fn();\n+pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n+pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n+pub type FsCallback = ~fn(&mut FsRequest, Option<UvError>);\n+// first int is exit_status, second is term_signal\n+pub type ExitCallback = ~fn(Process, int, int, Option<UvError>);\n+pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n+pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n+pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n+pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n+pub type SignalCallback = ~fn(SignalWatcher, Signum);\n+\n+\n+/// Callbacks used by StreamWatchers, set as custom data on the foreign handle.\n+/// XXX: Would be better not to have all watchers allocate room for all callback types.\n+struct WatcherData {\n+    read_cb: Option<ReadCallback>,\n+    write_cb: Option<ConnectionCallback>,\n+    connect_cb: Option<ConnectionCallback>,\n+    close_cb: Option<NullCallback>,\n+    alloc_cb: Option<AllocCallback>,\n+    idle_cb: Option<IdleCallback>,\n+    timer_cb: Option<TimerCallback>,\n+    async_cb: Option<AsyncCallback>,\n+    udp_recv_cb: Option<UdpReceiveCallback>,\n+    udp_send_cb: Option<UdpSendCallback>,\n+    exit_cb: Option<ExitCallback>,\n+    signal_cb: Option<SignalCallback>,\n+}\n+\n+pub trait WatcherInterop {\n+    fn event_loop(&self) -> Loop;\n+    fn install_watcher_data(&mut self);\n+    fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData;\n+    fn drop_watcher_data(&mut self);\n+    fn close(self, cb: NullCallback);\n+    fn close_async(self);\n+}\n+\n+impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n+    /// Get the uv event loop from a Watcher\n+    fn event_loop(&self) -> Loop {\n+        unsafe {\n+            let handle = self.native_handle();\n+            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            NativeHandle::from_native_handle(loop_)\n+        }\n+    }\n+\n+    fn install_watcher_data(&mut self) {\n+        unsafe {\n+            let data = ~WatcherData {\n+                read_cb: None,\n+                write_cb: None,\n+                connect_cb: None,\n+                close_cb: None,\n+                alloc_cb: None,\n+                idle_cb: None,\n+                timer_cb: None,\n+                async_cb: None,\n+                udp_recv_cb: None,\n+                udp_send_cb: None,\n+                exit_cb: None,\n+                signal_cb: None,\n+            };\n+            let data = transmute::<~WatcherData, *c_void>(data);\n+            uvll::set_data_for_uv_handle(self.native_handle(), data);\n+        }\n+    }\n+\n+    fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData {\n+        unsafe {\n+            let data = uvll::get_data_for_uv_handle(self.native_handle());\n+            let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n+            return &mut **data;\n+        }\n+    }\n+\n+    fn drop_watcher_data(&mut self) {\n+        unsafe {\n+            let data = uvll::get_data_for_uv_handle(self.native_handle());\n+            let _data = transmute::<*c_void, ~WatcherData>(data);\n+            uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n+        }\n+    }\n+\n+    fn close(self, cb: NullCallback) {\n+        let mut this = self;\n+        {\n+            let data = this.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(this.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+            let mut h: Handle = NativeHandle::from_native_handle(handle);\n+            h.get_watcher_data().close_cb.take_unwrap()();\n+            h.drop_watcher_data();\n+            unsafe { uvll::free_handle(handle as *c_void) }\n+        }\n+    }\n+\n+    fn close_async(self) {\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+            let mut h: Handle = NativeHandle::from_native_handle(handle);\n+            h.drop_watcher_data();\n+            unsafe { uvll::free_handle(handle as *c_void) }\n+        }\n+    }\n+}\n+\n+// XXX: Need to define the error constants like EOF so they can be\n+// compared to the UvError type\n+\n+pub struct UvError(c_int);\n+\n+impl UvError {\n+    pub fn name(&self) -> ~str {\n+        unsafe {\n+            let inner = match self { &UvError(a) => a };\n+            let name_str = uvll::err_name(inner);\n+            assert!(name_str.is_not_null());\n+            from_c_str(name_str)\n+        }\n+    }\n+\n+    pub fn desc(&self) -> ~str {\n+        unsafe {\n+            let inner = match self { &UvError(a) => a };\n+            let desc_str = uvll::strerror(inner);\n+            assert!(desc_str.is_not_null());\n+            from_c_str(desc_str)\n+        }\n+    }\n+\n+    pub fn is_eof(&self) -> bool {\n+        **self == uvll::EOF\n+    }\n+}\n+\n+impl ToStr for UvError {\n+    fn to_str(&self) -> ~str {\n+        format!(\"{}: {}\", self.name(), self.desc())\n+    }\n+}\n+\n+#[test]\n+fn error_smoke_test() {\n+    let err: UvError = UvError(uvll::EOF);\n+    assert_eq!(err.to_str(), ~\"EOF: end of file\");\n+}\n+\n+pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n+    unsafe {\n+        // Importing error constants\n+        use uvll::*;\n+        use std::rt::io::*;\n+\n+        // uv error descriptions are static\n+        let c_desc = uvll::strerror(*uverr);\n+        let desc = str::raw::c_str_to_static_slice(c_desc);\n+\n+        let kind = match *uverr {\n+            UNKNOWN => OtherIoError,\n+            OK => OtherIoError,\n+            EOF => EndOfFile,\n+            EACCES => PermissionDenied,\n+            ECONNREFUSED => ConnectionRefused,\n+            ECONNRESET => ConnectionReset,\n+            ENOTCONN => NotConnected,\n+            EPIPE => BrokenPipe,\n+            ECONNABORTED => ConnectionAborted,\n+            err => {\n+                uvdebug!(\"uverr.code {}\", err as int);\n+                // XXX: Need to map remaining uv error types\n+                OtherIoError\n+            }\n+        };\n+\n+        IoError {\n+            kind: kind,\n+            desc: desc,\n+            detail: None\n+        }\n+    }\n+}\n+\n+/// Given a uv handle, convert a callback status to a UvError\n+pub fn status_to_maybe_uv_error(status: c_int) -> Option<UvError>\n+{\n+    if status >= 0 {\n+        None\n+    } else {\n+        Some(UvError(status))\n+    }\n+}\n+\n+/// The uv buffer type\n+pub type Buf = uvll::uv_buf_t;\n+\n+pub fn empty_buf() -> Buf {\n+    uvll::uv_buf_t {\n+        base: null(),\n+        len: 0,\n+    }\n+}\n+\n+/// Borrow a slice to a Buf\n+pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n+    let data = vec::raw::to_ptr(v);\n+    unsafe { uvll::buf_init(data, v.len()) }\n+}\n+\n+// XXX: Do these conversions without copying\n+\n+/// Transmute an owned vector to a Buf\n+pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    unsafe {\n+        let data = malloc(v.len() as size_t) as *u8;\n+        assert!(data.is_not_null());\n+        do v.as_imm_buf |b, l| {\n+            let data = data as *mut u8;\n+            ptr::copy_memory(data, b, l)\n+        }\n+        uvll::buf_init(data, v.len())\n+    }\n+}\n+\n+/// Transmute a Buf that was once a ~[u8] back to ~[u8]\n+pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    if !(buf.len == 0 && buf.base.is_null()) {\n+        let v = unsafe { vec::from_buf(buf.base, buf.len as uint) };\n+        unsafe { free(buf.base as *c_void) };\n+        return Some(v);\n+    } else {\n+        // No buffer\n+        uvdebug!(\"No buffer!\");\n+        return None;\n+    }\n+}\n+/*\n+#[test]\n+fn test_slice_to_uv_buf() {\n+    let slice = [0, .. 20];\n+    let buf = slice_to_uv_buf(slice);\n+\n+    assert!(buf.len == 20);\n+\n+    unsafe {\n+        let base = transmute::<*u8, *mut u8>(buf.base);\n+        (*base) = 1;\n+        (*ptr::mut_offset(base, 1)) = 2;\n+    }\n+\n+    assert!(slice[0] == 1);\n+    assert!(slice[1] == 2);\n+}\n+\n+\n+#[test]\n+fn loop_smoke_test() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        loop_.run();\n+        loop_.close();\n+    }\n+}\n+*/"}, {"sha": "3fcf449959dba277a6f0c2cb7aabe5c40d8a51de", "filename": "src/librustuv/signal.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cast;\n+use std::libc::c_int;\n+use std::rt::io::signal::Signum;\n+\n+use super::{Loop, NativeHandle, SignalCallback, UvError, Watcher};\n+use uvll;\n+\n+pub struct SignalWatcher(*uvll::uv_signal_t);\n+\n+impl Watcher for SignalWatcher { }\n+\n+impl SignalWatcher {\n+    pub fn new(loop_: &mut Loop) -> SignalWatcher {\n+        unsafe {\n+            let handle = uvll::malloc_handle(uvll::UV_SIGNAL);\n+            assert!(handle.is_not_null());\n+            assert!(0 == uvll::signal_init(loop_.native_handle(), handle));\n+            let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher;\n+        }\n+    }\n+\n+    pub fn start(&mut self, signum: Signum, callback: SignalCallback)\n+            -> Result<(), UvError>\n+    {\n+        return unsafe {\n+            match uvll::signal_start(self.native_handle(), signal_cb,\n+                                     signum as c_int) {\n+                0 => {\n+                    let data = self.get_watcher_data();\n+                    data.signal_cb = Some(callback);\n+                    Ok(())\n+                }\n+                n => Err(UvError(n)),\n+            }\n+        };\n+\n+        extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n+            let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n+            let data = watcher.get_watcher_data();\n+            let cb = data.signal_cb.get_ref();\n+            (*cb)(watcher, unsafe { cast::transmute(signum as int) });\n+        }\n+    }\n+\n+    pub fn stop(&mut self) {\n+        unsafe {\n+            uvll::signal_stop(self.native_handle());\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_signal_t> for SignalWatcher {\n+    fn from_native_handle(handle: *uvll::uv_signal_t) -> SignalWatcher {\n+        SignalWatcher(handle)\n+    }\n+\n+    fn native_handle(&self) -> *uvll::uv_signal_t {\n+        match self { &SignalWatcher(ptr) => ptr }\n+    }\n+}"}, {"sha": "9a693f6a27d358e94ee214fbd15c32be0ad2ce00", "filename": "src/librustuv/timer.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::libc::c_int;\n+\n+use uvll;\n+use super::{Watcher, Loop, NativeHandle, TimerCallback, status_to_maybe_uv_error};\n+\n+pub struct TimerWatcher(*uvll::uv_timer_t);\n+impl Watcher for TimerWatcher { }\n+\n+impl TimerWatcher {\n+    pub fn new(loop_: &mut Loop) -> TimerWatcher {\n+        unsafe {\n+            let handle = uvll::malloc_handle(uvll::UV_TIMER);\n+            assert!(handle.is_not_null());\n+            assert!(0 == uvll::timer_init(loop_.native_handle(), handle));\n+            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher;\n+        }\n+    }\n+\n+    pub fn start(&mut self, timeout: u64, repeat: u64, cb: TimerCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            data.timer_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            uvll::timer_start(self.native_handle(), timer_cb, timeout, repeat);\n+        }\n+\n+        extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n+            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n+            let data = watcher.get_watcher_data();\n+            let cb = data.timer_cb.get_ref();\n+            let status = status_to_maybe_uv_error(status);\n+            (*cb)(watcher, status);\n+        }\n+    }\n+\n+    pub fn stop(&mut self) {\n+        unsafe {\n+            uvll::timer_stop(self.native_handle());\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_timer_t> for TimerWatcher {\n+    fn from_native_handle(handle: *uvll::uv_timer_t) -> TimerWatcher {\n+        TimerWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_idle_t {\n+        match self { &TimerWatcher(ptr) => ptr }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use Loop;\n+    use std::unstable::run_in_bare_thread;\n+\n+    #[test]\n+    fn smoke_test() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+            let mut loop_ = Loop::new();\n+            let mut timer = TimerWatcher::new(&mut loop_);\n+            do timer.start(10, 0) |timer, status| {\n+                assert!(status.is_none());\n+                unsafe { *count_ptr += 1 };\n+                timer.close(||());\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert!(count == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn start_twice() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+            let mut loop_ = Loop::new();\n+            let mut timer = TimerWatcher::new(&mut loop_);\n+            do timer.start(10, 0) |timer, status| {\n+                let mut timer = timer;\n+                assert!(status.is_none());\n+                unsafe { *count_ptr += 1 };\n+                do timer.start(10, 0) |timer, status| {\n+                    assert!(status.is_none());\n+                    unsafe { *count_ptr += 1 };\n+                    timer.close(||());\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert!(count == 2);\n+        }\n+    }\n+\n+    #[test]\n+    fn repeat_stop() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+            let mut loop_ = Loop::new();\n+            let mut timer = TimerWatcher::new(&mut loop_);\n+            do timer.start(1, 2) |timer, status| {\n+                assert!(status.is_none());\n+                unsafe {\n+                    *count_ptr += 1;\n+\n+                    if *count_ptr == 10 {\n+\n+                        // Stop the timer and do something else\n+                        let mut timer = timer;\n+                        timer.stop();\n+                        // Freeze timer so it can be captured\n+                        let timer = timer;\n+\n+                        let mut loop_ = timer.event_loop();\n+                        let mut timer2 = TimerWatcher::new(&mut loop_);\n+                        do timer2.start(10, 0) |timer2, _| {\n+\n+                            *count_ptr += 1;\n+\n+                            timer2.close(||());\n+\n+                            // Restart the original timer\n+                            let mut timer = timer;\n+                            do timer.start(1, 0) |timer, _| {\n+                                *count_ptr += 1;\n+                                timer.close(||());\n+                            }\n+                        }\n+                    }\n+                };\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert!(count == 12);\n+        }\n+    }\n+\n+}"}, {"sha": "65ba09376c14d747a1f7dc4a35e2ac46ef523441", "filename": "src/librustuv/tty.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::libc;\n+\n+use super::{Watcher, Loop, NativeHandle, UvError};\n+use net;\n+use uvll;\n+\n+/// A process wraps the handle of the underlying uv_process_t.\n+pub struct TTY(*uvll::uv_tty_t);\n+\n+impl Watcher for TTY {}\n+\n+impl TTY {\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn new(loop_: &Loop, fd: libc::c_int, readable: bool) ->\n+            Result<TTY, UvError>\n+    {\n+        let handle = unsafe { uvll::malloc_handle(uvll::UV_TTY) };\n+        assert!(handle.is_not_null());\n+\n+        let ret = unsafe {\n+            uvll::tty_init(loop_.native_handle(), handle, fd as libc::c_int,\n+                           readable as libc::c_int)\n+        };\n+        match ret {\n+            0 => {\n+                let mut ret: TTY = NativeHandle::from_native_handle(handle);\n+                ret.install_watcher_data();\n+                Ok(ret)\n+            }\n+            n => {\n+                unsafe { uvll::free_handle(handle); }\n+                Err(UvError(n))\n+            }\n+        }\n+    }\n+\n+    pub fn as_stream(&self) -> net::StreamWatcher {\n+        net::StreamWatcher(**self as *uvll::uv_stream_t)\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn set_mode(&self, raw: bool) -> Result<(), UvError> {\n+        let raw = raw as libc::c_int;\n+        match unsafe { uvll::tty_set_mode(self.native_handle(), raw) } {\n+            0 => Ok(()),\n+            n => Err(UvError(n))\n+        }\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)] #[allow(unused_mut)]\n+    pub fn get_winsize(&self) -> Result<(int, int), UvError> {\n+        let mut width: libc::c_int = 0;\n+        let mut height: libc::c_int = 0;\n+        let widthptr: *libc::c_int = &width;\n+        let heightptr: *libc::c_int = &width;\n+\n+        match unsafe { uvll::tty_get_winsize(self.native_handle(),\n+                                             widthptr, heightptr) } {\n+            0 => Ok((width as int, height as int)),\n+            n => Err(UvError(n))\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_tty_t> for TTY {\n+    fn from_native_handle(handle: *uvll::uv_tty_t) -> TTY {\n+        TTY(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_tty_t {\n+        match self { &TTY(ptr) => ptr }\n+    }\n+}\n+"}, {"sha": "8b80a24a1b48f6ec2f29f3ccf0fcaca8a4a6b7ee", "filename": "src/librustuv/uvio.rs", "status": "added", "additions": 2526, "deletions": 0, "changes": 2526, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,2526 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::c_str::{ToCStr, CString};\n+use std::cast::transmute;\n+use std::cast;\n+use std::cell::Cell;\n+use std::clone::Clone;\n+use std::comm::{SendDeferred, SharedChan, Port, PortOne, GenericChan};\n+use std::libc::{c_int, c_uint, c_void, pid_t};\n+use std::ops::Drop;\n+use std::option::*;\n+use std::ptr;\n+use std::str;\n+use std::result::*;\n+use std::rt::io::IoError;\n+use std::rt::io::net::ip::{SocketAddr, IpAddr};\n+use std::rt::io::{standard_error, OtherIoError, SeekStyle, SeekSet, SeekCur,\n+                  SeekEnd};\n+use std::rt::io::process::ProcessConfig;\n+use std::rt::BlockedTask;\n+use std::rt::local::Local;\n+use std::rt::rtio::*;\n+use std::rt::sched::{Scheduler, SchedHandle};\n+use std::rt::tube::Tube;\n+use std::rt::task::Task;\n+use std::unstable::sync::Exclusive;\n+use std::path::{GenericPath, Path};\n+use std::libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY,\n+                O_WRONLY, S_IRUSR, S_IWUSR, S_IRWXU};\n+use std::rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n+                  CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n+                  FileStat};\n+use std::rt::io::signal::Signum;\n+use std::task;\n+use ai = std::rt::io::net::addrinfo;\n+\n+#[cfg(test)] use std::container::Container;\n+#[cfg(test)] use std::unstable::run_in_bare_thread;\n+#[cfg(test)] use std::rt::test::{spawntask,\n+                                 next_test_ip4,\n+                                 run_in_mt_newsched_task};\n+#[cfg(test)] use std::iter::{Iterator, range};\n+#[cfg(test)] use std::rt::comm::oneshot;\n+\n+use super::*;\n+use idle::IdleWatcher;\n+use net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n+use addrinfo::{GetAddrInfoRequest, accum_addrinfo};\n+\n+// XXX we should not be calling uvll functions in here.\n+\n+trait HomingIO {\n+\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle;\n+\n+    /// This function will move tasks to run on their home I/O scheduler. Note\n+    /// that this function does *not* pin the task to the I/O scheduler, but\n+    /// rather it simply moves it to running on the I/O scheduler.\n+    fn go_to_IO_home(&mut self) -> uint {\n+        use std::rt::sched::RunOnce;\n+\n+        let current_sched_id = do Local::borrow |sched: &mut Scheduler| {\n+            sched.sched_id()\n+        };\n+\n+        // Only need to invoke a context switch if we're not on the right\n+        // scheduler.\n+        if current_sched_id != self.home().sched_id {\n+            do task::unkillable { // FIXME(#8674)\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    /* FIXME(#8674) if the task was already killed then wake\n+                     * will return None. In that case, the home pointer will\n+                     * never be set.\n+                     *\n+                     * RESOLUTION IDEA: Since the task is dead, we should\n+                     * just abort the IO action.\n+                     */\n+                    do task.wake().map |task| {\n+                        self.home().send(RunOnce(task));\n+                    };\n+                }\n+            }\n+        }\n+\n+        self.home().sched_id\n+    }\n+\n+    // XXX: dummy self parameter\n+    fn restore_original_home(_: Option<Self>, io_home: uint) {\n+        // It would truly be a sad day if we had moved off the home I/O\n+        // scheduler while we were doing I/O.\n+        assert_eq!(Local::borrow(|sched: &mut Scheduler| sched.sched_id()),\n+                   io_home);\n+\n+        // If we were a homed task, then we must send ourselves back to the\n+        // original scheduler. Otherwise, we can just return and keep running\n+        if !Task::on_appropriate_sched() {\n+            do task::unkillable { // FIXME(#8674)\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    do task.wake().map |task| {\n+                        Scheduler::run_task(task);\n+                    };\n+                }\n+            }\n+        }\n+    }\n+\n+    fn home_for_io<A>(&mut self, io: &fn(&mut Self) -> A) -> A {\n+        let home = self.go_to_IO_home();\n+        let a = io(self); // do IO\n+        HomingIO::restore_original_home(None::<Self>, home);\n+        a // return the result of the IO\n+    }\n+\n+    fn home_for_io_consume<A>(self, io: &fn(Self) -> A) -> A {\n+        let mut this = self;\n+        let home = this.go_to_IO_home();\n+        let a = io(this); // do IO\n+        HomingIO::restore_original_home(None::<Self>, home);\n+        a // return the result of the IO\n+    }\n+\n+    fn home_for_io_with_sched<A>(&mut self, io_sched: &fn(&mut Self, ~Scheduler) -> A) -> A {\n+        let home = self.go_to_IO_home();\n+        let a = do task::unkillable { // FIXME(#8674)\n+            let scheduler: ~Scheduler = Local::take();\n+            io_sched(self, scheduler) // do IO and scheduling action\n+        };\n+        HomingIO::restore_original_home(None::<Self>, home);\n+        a // return result of IO\n+    }\n+}\n+\n+// get a handle for the current scheduler\n+macro_rules! get_handle_to_current_scheduler(\n+    () => (do Local::borrow |sched: &mut Scheduler| { sched.make_handle() })\n+)\n+\n+enum SocketNameKind {\n+    TcpPeer,\n+    Tcp,\n+    Udp\n+}\n+\n+fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n+                                                 handle: U) -> Result<SocketAddr, IoError> {\n+    let getsockname = match sk {\n+        TcpPeer => uvll::tcp_getpeername,\n+        Tcp     => uvll::tcp_getsockname,\n+        Udp     => uvll::udp_getsockname,\n+    };\n+\n+    // Allocate a sockaddr_storage\n+    // since we don't know if it's ipv4 or ipv6\n+    let r_addr = unsafe { uvll::malloc_sockaddr_storage() };\n+\n+    let r = unsafe {\n+        getsockname(handle.native_handle() as *c_void, r_addr as *uvll::sockaddr_storage)\n+    };\n+\n+    if r != 0 {\n+        let status = status_to_maybe_uv_error(r);\n+        return Err(uv_error_to_io_error(status.unwrap()));\n+    }\n+\n+    let addr = unsafe {\n+        if uvll::is_ip6_addr(r_addr as *uvll::sockaddr) {\n+            net::uv_socket_addr_to_socket_addr(UvIpv6SocketAddr(r_addr as *uvll::sockaddr_in6))\n+        } else {\n+            net::uv_socket_addr_to_socket_addr(UvIpv4SocketAddr(r_addr as *uvll::sockaddr_in))\n+        }\n+    };\n+\n+    unsafe { uvll::free_sockaddr_storage(r_addr); }\n+\n+    Ok(addr)\n+\n+}\n+\n+// Obviously an Event Loop is always home.\n+pub struct UvEventLoop {\n+    priv uvio: UvIoFactory\n+}\n+\n+impl UvEventLoop {\n+    pub fn new() -> UvEventLoop {\n+        UvEventLoop {\n+            uvio: UvIoFactory(Loop::new())\n+        }\n+    }\n+}\n+\n+impl Drop for UvEventLoop {\n+    fn drop(&mut self) {\n+        self.uvio.uv_loop().close();\n+    }\n+}\n+\n+impl EventLoop for UvEventLoop {\n+    fn run(&mut self) {\n+        self.uvio.uv_loop().run();\n+    }\n+\n+    fn callback(&mut self, f: ~fn()) {\n+        let mut idle_watcher =  IdleWatcher::new(self.uvio.uv_loop());\n+        do idle_watcher.start |mut idle_watcher, status| {\n+            assert!(status.is_none());\n+            idle_watcher.stop();\n+            idle_watcher.close(||());\n+            f();\n+        }\n+    }\n+\n+    fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback {\n+        let idle_watcher = IdleWatcher::new(self.uvio.uv_loop());\n+        ~UvPausibleIdleCallback {\n+            watcher: idle_watcher,\n+            idle_flag: false,\n+            closed: false\n+        } as ~PausibleIdleCallback\n+    }\n+\n+    fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallback {\n+        ~UvRemoteCallback::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n+    }\n+\n+    fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory)) {\n+        f(&mut self.uvio as &mut IoFactory)\n+    }\n+}\n+\n+#[cfg(not(stage0), not(test))]\n+#[lang = \"event_loop_factory\"]\n+pub extern \"C\" fn new_loop() -> ~EventLoop {\n+    ~UvEventLoop::new() as ~EventLoop\n+}\n+\n+pub struct UvPausibleIdleCallback {\n+    priv watcher: IdleWatcher,\n+    priv idle_flag: bool,\n+    priv closed: bool\n+}\n+\n+impl PausibleIdleCallback for UvPausibleIdleCallback {\n+    #[inline]\n+    fn start(&mut self, f: ~fn()) {\n+        do self.watcher.start |_idle_watcher, _status| {\n+            f();\n+        };\n+        self.idle_flag = true;\n+    }\n+    #[inline]\n+    fn pause(&mut self) {\n+        if self.idle_flag == true {\n+            self.watcher.stop();\n+            self.idle_flag = false;\n+        }\n+    }\n+    #[inline]\n+    fn resume(&mut self) {\n+        if self.idle_flag == false {\n+            self.watcher.restart();\n+            self.idle_flag = true;\n+        }\n+    }\n+    #[inline]\n+    fn close(&mut self) {\n+        self.pause();\n+        if !self.closed {\n+            self.closed = true;\n+            self.watcher.close(||{});\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_callback_run_once() {\n+    do run_in_bare_thread {\n+        let mut event_loop = UvEventLoop::new();\n+        let mut count = 0;\n+        let count_ptr: *mut int = &mut count;\n+        do event_loop.callback {\n+            unsafe { *count_ptr += 1 }\n+        }\n+        event_loop.run();\n+        assert_eq!(count, 1);\n+    }\n+}\n+\n+// The entire point of async is to call into a loop from other threads so it does not need to home.\n+pub struct UvRemoteCallback {\n+    // The uv async handle for triggering the callback\n+    priv async: AsyncWatcher,\n+    // A flag to tell the callback to exit, set from the dtor. This is\n+    // almost never contested - only in rare races with the dtor.\n+    priv exit_flag: Exclusive<bool>\n+}\n+\n+impl UvRemoteCallback {\n+    pub fn new(loop_: &mut Loop, f: ~fn()) -> UvRemoteCallback {\n+        let exit_flag = Exclusive::new(false);\n+        let exit_flag_clone = exit_flag.clone();\n+        let async = do AsyncWatcher::new(loop_) |watcher, status| {\n+            assert!(status.is_none());\n+\n+            // The synchronization logic here is subtle. To review,\n+            // the uv async handle type promises that, after it is\n+            // triggered the remote callback is definitely called at\n+            // least once. UvRemoteCallback needs to maintain those\n+            // semantics while also shutting down cleanly from the\n+            // dtor. In our case that means that, when the\n+            // UvRemoteCallback dtor calls `async.send()`, here `f` is\n+            // always called later.\n+\n+            // In the dtor both the exit flag is set and the async\n+            // callback fired under a lock.  Here, before calling `f`,\n+            // we take the lock and check the flag. Because we are\n+            // checking the flag before calling `f`, and the flag is\n+            // set under the same lock as the send, then if the flag\n+            // is set then we're guaranteed to call `f` after the\n+            // final send.\n+\n+            // If the check was done after `f()` then there would be a\n+            // period between that call and the check where the dtor\n+            // could be called in the other thread, missing the final\n+            // callback while still destroying the handle.\n+\n+            let should_exit = unsafe {\n+                exit_flag_clone.with_imm(|&should_exit| should_exit)\n+            };\n+\n+            f();\n+\n+            if should_exit {\n+                watcher.close(||());\n+            }\n+\n+        };\n+        UvRemoteCallback {\n+            async: async,\n+            exit_flag: exit_flag\n+        }\n+    }\n+}\n+\n+impl RemoteCallback for UvRemoteCallback {\n+    fn fire(&mut self) { self.async.send() }\n+}\n+\n+impl Drop for UvRemoteCallback {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let this: &mut UvRemoteCallback = cast::transmute_mut(self);\n+            do this.exit_flag.with |should_exit| {\n+                // NB: These two things need to happen atomically. Otherwise\n+                // the event handler could wake up due to a *previous*\n+                // signal and see the exit flag, destroying the handle\n+                // before the final send.\n+                *should_exit = true;\n+                this.async.send();\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test_remote {\n+    use std::cell::Cell;\n+    use std::rt::test::*;\n+    use std::rt::thread::Thread;\n+    use std::rt::tube::Tube;\n+    use std::rt::rtio::EventLoop;\n+    use std::rt::local::Local;\n+    use std::rt::sched::Scheduler;\n+\n+    #[test]\n+    fn test_uv_remote() {\n+        do run_in_mt_newsched_task {\n+            let mut tube = Tube::new();\n+            let tube_clone = tube.clone();\n+            let remote_cell = Cell::new_empty();\n+            do Local::borrow |sched: &mut Scheduler| {\n+                let tube_clone = tube_clone.clone();\n+                let tube_clone_cell = Cell::new(tube_clone);\n+                let remote = do sched.event_loop.remote_callback {\n+                    // This could be called multiple times\n+                    if !tube_clone_cell.is_empty() {\n+                        tube_clone_cell.take().send(1);\n+                    }\n+                };\n+                remote_cell.put_back(remote);\n+            }\n+            let thread = do Thread::start {\n+                remote_cell.take().fire();\n+            };\n+\n+            assert!(tube.recv() == 1);\n+            thread.join();\n+        }\n+    }\n+}\n+\n+pub struct UvIoFactory(Loop);\n+\n+impl UvIoFactory {\n+    pub fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n+        match self { &UvIoFactory(ref mut ptr) => ptr }\n+    }\n+}\n+\n+/// Helper for a variety of simple uv_fs_* functions that\n+/// have no ret val\n+fn uv_fs_helper(loop_: &mut Loop, path: &CString,\n+                cb: ~fn(&mut FsRequest, &mut Loop, &CString,\n+                        ~fn(&FsRequest, Option<UvError>)))\n+        -> Result<(), IoError> {\n+    let result_cell = Cell::new_empty();\n+    let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+    let path_cell = Cell::new(path);\n+    do task::unkillable { // FIXME(#8674)\n+        let scheduler: ~Scheduler = Local::take();\n+        let mut new_req = FsRequest::new();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            let path = path_cell.take();\n+            do cb(&mut new_req, loop_, path) |_, err| {\n+                let res = match err {\n+                    None => Ok(()),\n+                    Some(err) => Err(uv_error_to_io_error(err))\n+                };\n+                unsafe { (*result_cell_ptr).put_back(res); }\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            };\n+        }\n+    }\n+    assert!(!result_cell.is_empty());\n+    return result_cell.take();\n+}\n+\n+impl IoFactory for UvIoFactory {\n+    // Connect to an address and return a new stream\n+    // NB: This blocks the task waiting on the connection.\n+    // It would probably be better to return a future\n+    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStream, IoError> {\n+        // Create a cell in the task to hold the result. We will fill\n+        // the cell before resuming the task.\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~RtioTcpStream, IoError>> = &result_cell;\n+\n+        // Block this task and take ownership, switch to scheduler context\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+\n+                let mut tcp = TcpWatcher::new(self.uv_loop());\n+                let task_cell = Cell::new(task);\n+\n+                // Wait for a connection\n+                do tcp.connect(addr) |stream, status| {\n+                    match status {\n+                        None => {\n+                            let tcp = NativeHandle::from_native_handle(stream.native_handle());\n+                            let home = get_handle_to_current_scheduler!();\n+                            let res = Ok(~UvTcpStream { watcher: tcp, home: home }\n+                                                as ~RtioTcpStream);\n+\n+                            // Store the stream in the task's stack\n+                            unsafe { (*result_cell_ptr).put_back(res); }\n+\n+                            // Context switch\n+                            let scheduler: ~Scheduler = Local::take();\n+                            scheduler.resume_blocked_task_immediately(task_cell.take());\n+                        }\n+                        Some(_) => {\n+                            let task_cell = Cell::new(task_cell.take());\n+                            do stream.close {\n+                                let res = Err(uv_error_to_io_error(status.unwrap()));\n+                                unsafe { (*result_cell_ptr).put_back(res); }\n+                                let scheduler: ~Scheduler = Local::take();\n+                                scheduler.resume_blocked_task_immediately(task_cell.take());\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListener, IoError> {\n+        let mut watcher = TcpWatcher::new(self.uv_loop());\n+        match watcher.bind(addr) {\n+            Ok(_) => {\n+                let home = get_handle_to_current_scheduler!();\n+                Ok(~UvTcpListener::new(watcher, home) as ~RtioTcpListener)\n+            }\n+            Err(uverr) => {\n+                do task::unkillable { // FIXME(#8674)\n+                    let scheduler: ~Scheduler = Local::take();\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        let task_cell = Cell::new(task);\n+                        do watcher.as_stream().close {\n+                            let scheduler: ~Scheduler = Local::take();\n+                            scheduler.resume_blocked_task_immediately(task_cell.take());\n+                        }\n+                    }\n+                    Err(uv_error_to_io_error(uverr))\n+                }\n+            }\n+        }\n+    }\n+\n+    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError> {\n+        let mut watcher = UdpWatcher::new(self.uv_loop());\n+        match watcher.bind(addr) {\n+            Ok(_) => {\n+                let home = get_handle_to_current_scheduler!();\n+                Ok(~UvUdpSocket { watcher: watcher, home: home } as ~RtioUdpSocket)\n+            }\n+            Err(uverr) => {\n+                do task::unkillable { // FIXME(#8674)\n+                    let scheduler: ~Scheduler = Local::take();\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        let task_cell = Cell::new(task);\n+                        do watcher.close {\n+                            let scheduler: ~Scheduler = Local::take();\n+                            scheduler.resume_blocked_task_immediately(task_cell.take());\n+                        }\n+                    }\n+                    Err(uv_error_to_io_error(uverr))\n+                }\n+            }\n+        }\n+    }\n+\n+    fn timer_init(&mut self) -> Result<~RtioTimer, IoError> {\n+        let watcher = TimerWatcher::new(self.uv_loop());\n+        let home = get_handle_to_current_scheduler!();\n+        Ok(~UvTimer::new(watcher, home) as ~RtioTimer)\n+    }\n+\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream {\n+        let loop_ = Loop {handle: self.uv_loop().native_handle()};\n+        let home = get_handle_to_current_scheduler!();\n+        ~UvFileStream::new(loop_, fd, close, home) as ~RtioFileStream\n+    }\n+\n+    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n+        -> Result<~RtioFileStream, IoError> {\n+        let mut flags = match fm {\n+            Open => 0,\n+            Create => O_CREAT,\n+            OpenOrCreate => O_CREAT,\n+            Append => O_APPEND,\n+            Truncate => O_TRUNC,\n+            CreateOrTruncate => O_TRUNC | O_CREAT\n+        };\n+        flags = match fa {\n+            Read => flags | O_RDONLY,\n+            Write => flags | O_WRONLY,\n+            ReadWrite => flags | O_RDWR\n+        };\n+        let create_mode = match fm {\n+            Create|OpenOrCreate|CreateOrTruncate =>\n+                S_IRUSR | S_IWUSR,\n+            _ => 0\n+        };\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~RtioFileStream,\n+                                           IoError>> = &result_cell;\n+        let path_cell = Cell::new(path);\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler: ~Scheduler = Local::take();\n+            let open_req = file::FsRequest::new();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let path = path_cell.take();\n+                do open_req.open(self.uv_loop(), path, flags as int, create_mode as int)\n+                      |req,err| {\n+                    if err.is_none() {\n+                        let loop_ = Loop {handle: req.get_loop().native_handle()};\n+                        let home = get_handle_to_current_scheduler!();\n+                        let fd = req.get_result() as c_int;\n+                        let fs = ~UvFileStream::new(\n+                            loop_, fd, CloseSynchronously, home) as ~RtioFileStream;\n+                        let res = Ok(fs);\n+                        unsafe { (*result_cell_ptr).put_back(res); }\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    } else {\n+                        let res = Err(uv_error_to_io_error(err.unwrap()));\n+                        unsafe { (*result_cell_ptr).put_back(res); }\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    }\n+                };\n+            };\n+        };\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), path) |unlink_req, l, p, cb| {\n+            do unlink_req.unlink(l, p) |req, err| {\n+                cb(req, err)\n+            };\n+        }\n+    }\n+    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n+        use str::StrSlice;\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<FileStat,\n+                                           IoError>> = &result_cell;\n+        let path_cell = Cell::new(path);\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler: ~Scheduler = Local::take();\n+            let stat_req = file::FsRequest::new();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let path = path_cell.take();\n+                // Don't pick up the null byte\n+                let slice = path.as_bytes().slice(0, path.len());\n+                let path_instance = Cell::new(Path::new(slice));\n+                do stat_req.stat(self.uv_loop(), path) |req,err| {\n+                    let res = match err {\n+                        None => {\n+                            let stat = req.get_stat();\n+                            Ok(FileStat {\n+                                path: path_instance.take(),\n+                                is_file: stat.is_file(),\n+                                is_dir: stat.is_dir(),\n+                                device: stat.st_dev,\n+                                mode: stat.st_mode,\n+                                inode: stat.st_ino,\n+                                size: stat.st_size,\n+                                created: stat.st_ctim.tv_sec as u64,\n+                                modified: stat.st_mtim.tv_sec as u64,\n+                                accessed: stat.st_atim.tv_sec as u64\n+                            })\n+                        },\n+                        Some(e) => {\n+                            Err(uv_error_to_io_error(e))\n+                        }\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                };\n+            };\n+        };\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n+                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~[ai::Info], IoError>> = &result_cell;\n+        let host_ptr: *Option<&str> = &host;\n+        let servname_ptr: *Option<&str> = &servname;\n+        let hint_ptr: *Option<ai::Hint> = &hint;\n+        let addrinfo_req = GetAddrInfoRequest::new();\n+        let addrinfo_req_cell = Cell::new(addrinfo_req);\n+\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let mut addrinfo_req = addrinfo_req_cell.take();\n+                unsafe {\n+                    do addrinfo_req.getaddrinfo(self.uv_loop(),\n+                                                *host_ptr, *servname_ptr,\n+                                                *hint_ptr) |_, addrinfo, err| {\n+                        let res = match err {\n+                            None => Ok(accum_addrinfo(addrinfo)),\n+                            Some(err) => Err(uv_error_to_io_error(err))\n+                        };\n+                        (*result_cell_ptr).put_back(res);\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    }\n+                }\n+            }\n+        }\n+        addrinfo_req.delete();\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+    fn fs_mkdir(&mut self, path: &CString) -> Result<(), IoError> {\n+        let mode = S_IRWXU as int;\n+        do uv_fs_helper(self.uv_loop(), path) |mkdir_req, l, p, cb| {\n+            do mkdir_req.mkdir(l, p, mode as int) |req, err| {\n+                cb(req, err)\n+            };\n+        }\n+    }\n+    fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), path) |rmdir_req, l, p, cb| {\n+            do rmdir_req.rmdir(l, p) |req, err| {\n+                cb(req, err)\n+            };\n+        }\n+    }\n+    fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n+        Result<~[Path], IoError> {\n+        use str::StrSlice;\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~[Path],\n+                                           IoError>> = &result_cell;\n+        let path_cell = Cell::new(path);\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler: ~Scheduler = Local::take();\n+            let stat_req = file::FsRequest::new();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let path = path_cell.take();\n+                // Don't pick up the null byte\n+                let slice = path.as_bytes().slice(0, path.len());\n+                let path_parent = Cell::new(Path::new(slice));\n+                do stat_req.readdir(self.uv_loop(), path, flags) |req,err| {\n+                    let parent = path_parent.take();\n+                    let res = match err {\n+                        None => {\n+                            let mut paths = ~[];\n+                            do req.each_path |rel_path| {\n+                                let p = rel_path.as_bytes();\n+                                paths.push(parent.join(p.slice_to(rel_path.len())));\n+                            }\n+                            Ok(paths)\n+                        },\n+                        Some(e) => {\n+                            Err(uv_error_to_io_error(e))\n+                        }\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                };\n+            };\n+        };\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn spawn(&mut self, config: ProcessConfig)\n+            -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>\n+    {\n+        // Sadly, we must create the UvProcess before we actually call uv_spawn\n+        // so that the exit_cb can close over it and notify it when the process\n+        // has exited.\n+        let mut ret = ~UvProcess {\n+            process: Process::new(),\n+            home: None,\n+            exit_status: None,\n+            term_signal: None,\n+            exit_error: None,\n+            descheduled: None,\n+        };\n+        let ret_ptr = unsafe {\n+            *cast::transmute::<&~UvProcess, &*mut UvProcess>(&ret)\n+        };\n+\n+        // The purpose of this exit callback is to record the data about the\n+        // exit and then wake up the task which may be waiting for the process\n+        // to exit. This is all performed in the current io-loop, and the\n+        // implementation of UvProcess ensures that reading these fields always\n+        // occurs on the current io-loop.\n+        let exit_cb: ExitCallback = |_, exit_status, term_signal, error| {\n+            unsafe {\n+                assert!((*ret_ptr).exit_status.is_none());\n+                (*ret_ptr).exit_status = Some(exit_status);\n+                (*ret_ptr).term_signal = Some(term_signal);\n+                (*ret_ptr).exit_error = error;\n+                match (*ret_ptr).descheduled.take() {\n+                    Some(task) => {\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(task);\n+                    }\n+                    None => {}\n+                }\n+            }\n+        };\n+\n+        match ret.process.spawn(self.uv_loop(), config, exit_cb) {\n+            Ok(io) => {\n+                // Only now do we actually get a handle to this scheduler.\n+                ret.home = Some(get_handle_to_current_scheduler!());\n+                Ok((ret as ~RtioProcess,\n+                    io.move_iter().map(|p| p.map(|p| p as ~RtioPipe)).collect()))\n+            }\n+            Err(uverr) => {\n+                // We still need to close the process handle we created, but\n+                // that's taken care for us in the destructor of UvProcess\n+                Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n+    }\n+\n+    fn unix_bind(&mut self, path: &CString) ->\n+        Result<~RtioUnixListener, IoError> {\n+        let mut pipe = UvUnboundPipe::new(self.uv_loop());\n+        match pipe.pipe.bind(path) {\n+            Ok(()) => Ok(~UvUnixListener::new(pipe) as ~RtioUnixListener),\n+            Err(e) => Err(uv_error_to_io_error(e)),\n+        }\n+    }\n+\n+    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError> {\n+        let pipe = UvUnboundPipe::new(self.uv_loop());\n+        let mut rawpipe = pipe.pipe;\n+\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~RtioPipe, IoError>> = &result_cell;\n+        let pipe_cell = Cell::new(pipe);\n+        let pipe_cell_ptr: *Cell<UvUnboundPipe> = &pipe_cell;\n+\n+        let scheduler: ~Scheduler = Local::take();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            do rawpipe.connect(path) |_stream, err| {\n+                let res = match err {\n+                    None => {\n+                        let pipe = unsafe { (*pipe_cell_ptr).take() };\n+                        Ok(~UvPipeStream::new(pipe) as ~RtioPipe)\n+                    }\n+                    Some(e) => Err(uv_error_to_io_error(e)),\n+                };\n+                unsafe { (*result_cell_ptr).put_back(res); }\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            }\n+        }\n+\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn tty_open(&mut self, fd: c_int, readable: bool)\n+            -> Result<~RtioTTY, IoError> {\n+        match tty::TTY::new(self.uv_loop(), fd, readable) {\n+            Ok(tty) => Ok(~UvTTY {\n+                home: get_handle_to_current_scheduler!(),\n+                tty: tty,\n+                fd: fd,\n+            } as ~RtioTTY),\n+            Err(e) => Err(uv_error_to_io_error(e))\n+        }\n+    }\n+\n+    fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError> {\n+        let mut pipe = UvUnboundPipe::new(self.uv_loop());\n+        match pipe.pipe.open(fd) {\n+            Ok(()) => Ok(~UvPipeStream::new(pipe) as ~RtioPipe),\n+            Err(e) => Err(uv_error_to_io_error(e))\n+        }\n+    }\n+\n+    fn signal(&mut self, signum: Signum, channel: SharedChan<Signum>)\n+        -> Result<~RtioSignal, IoError> {\n+        let watcher = SignalWatcher::new(self.uv_loop());\n+        let home = get_handle_to_current_scheduler!();\n+        let mut signal = ~UvSignal::new(watcher, home);\n+        match signal.watcher.start(signum, |_, _| channel.send_deferred(signum)) {\n+            Ok(()) => Ok(signal as ~RtioSignal),\n+            Err(e) => Err(uv_error_to_io_error(e)),\n+        }\n+    }\n+}\n+\n+pub struct UvTcpListener {\n+    priv watcher : TcpWatcher,\n+    priv home: SchedHandle,\n+}\n+\n+impl HomingIO for UvTcpListener {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl UvTcpListener {\n+    fn new(watcher: TcpWatcher, home: SchedHandle) -> UvTcpListener {\n+        UvTcpListener { watcher: watcher, home: home }\n+    }\n+}\n+\n+impl Drop for UvTcpListener {\n+    fn drop(&mut self) {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task = Cell::new(task);\n+                do self_.watcher.as_stream().close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task.take());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioSocket for UvTcpListener {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+        do self.home_for_io |self_| {\n+            socket_name(Tcp, self_.watcher)\n+        }\n+    }\n+}\n+\n+impl RtioTcpListener for UvTcpListener {\n+    fn listen(~self) -> Result<~RtioTcpAcceptor, IoError> {\n+        do self.home_for_io_consume |self_| {\n+            let acceptor = ~UvTcpAcceptor::new(self_);\n+            let incoming = Cell::new(acceptor.incoming.clone());\n+            let mut stream = acceptor.listener.watcher.as_stream();\n+            let res = do stream.listen |mut server, status| {\n+                do incoming.with_mut_ref |incoming| {\n+                    let inc = match status {\n+                        Some(_) => Err(standard_error(OtherIoError)),\n+                        None => {\n+                            let inc = TcpWatcher::new(&server.event_loop());\n+                            // first accept call in the callback guarenteed to succeed\n+                            server.accept(inc.as_stream());\n+                            let home = get_handle_to_current_scheduler!();\n+                            Ok(~UvTcpStream { watcher: inc, home: home }\n+                                    as ~RtioTcpStream)\n+                        }\n+                    };\n+                    incoming.send(inc);\n+                }\n+            };\n+            match res {\n+                Ok(()) => Ok(acceptor as ~RtioTcpAcceptor),\n+                Err(e) => Err(uv_error_to_io_error(e)),\n+            }\n+        }\n+    }\n+}\n+\n+pub struct UvTcpAcceptor {\n+    priv listener: UvTcpListener,\n+    priv incoming: Tube<Result<~RtioTcpStream, IoError>>,\n+}\n+\n+impl HomingIO for UvTcpAcceptor {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n+}\n+\n+impl UvTcpAcceptor {\n+    fn new(listener: UvTcpListener) -> UvTcpAcceptor {\n+        UvTcpAcceptor { listener: listener, incoming: Tube::new() }\n+    }\n+}\n+\n+impl RtioSocket for UvTcpAcceptor {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+        do self.home_for_io |self_| {\n+            socket_name(Tcp, self_.listener.watcher)\n+        }\n+    }\n+}\n+\n+fn accept_simultaneously(stream: StreamWatcher, a: int) -> Result<(), IoError> {\n+    let r = unsafe {\n+        uvll::tcp_simultaneous_accepts(stream.native_handle(), a as c_int)\n+    };\n+\n+    match status_to_maybe_uv_error(r) {\n+        Some(err) => Err(uv_error_to_io_error(err)),\n+        None => Ok(())\n+    }\n+}\n+\n+impl RtioTcpAcceptor for UvTcpAcceptor {\n+    fn accept(&mut self) -> Result<~RtioTcpStream, IoError> {\n+        do self.home_for_io |self_| {\n+            self_.incoming.recv()\n+        }\n+    }\n+\n+    fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            accept_simultaneously(self_.listener.watcher.as_stream(), 1)\n+        }\n+    }\n+\n+    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            accept_simultaneously(self_.listener.watcher.as_stream(), 0)\n+        }\n+    }\n+}\n+\n+fn read_stream(mut watcher: StreamWatcher,\n+               scheduler: ~Scheduler,\n+               buf: &mut [u8]) -> Result<uint, IoError> {\n+    let result_cell = Cell::new_empty();\n+    let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n+\n+    let buf_ptr: *&mut [u8] = &buf;\n+    do scheduler.deschedule_running_task_and_then |_sched, task| {\n+        let task_cell = Cell::new(task);\n+        // XXX: We shouldn't reallocate these callbacks every\n+        // call to read\n+        let alloc: AllocCallback = |_| unsafe {\n+            slice_to_uv_buf(*buf_ptr)\n+        };\n+        do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n+\n+            // Stop reading so that no read callbacks are\n+            // triggered before the user calls `read` again.\n+            // XXX: Is there a performance impact to calling\n+            // stop here?\n+            watcher.read_stop();\n+\n+            let result = if status.is_none() {\n+                assert!(nread >= 0);\n+                Ok(nread as uint)\n+            } else {\n+                Err(uv_error_to_io_error(status.unwrap()))\n+            };\n+\n+            unsafe { (*result_cell_ptr).put_back(result); }\n+\n+            let scheduler: ~Scheduler = Local::take();\n+            scheduler.resume_blocked_task_immediately(task_cell.take());\n+        }\n+    }\n+\n+    assert!(!result_cell.is_empty());\n+    result_cell.take()\n+}\n+\n+fn write_stream(mut watcher: StreamWatcher,\n+                scheduler: ~Scheduler,\n+                buf: &[u8]) -> Result<(), IoError> {\n+    let result_cell = Cell::new_empty();\n+    let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+    let buf_ptr: *&[u8] = &buf;\n+    do scheduler.deschedule_running_task_and_then |_, task| {\n+        let task_cell = Cell::new(task);\n+        let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+        do watcher.write(buf) |_watcher, status| {\n+            let result = if status.is_none() {\n+                Ok(())\n+            } else {\n+                Err(uv_error_to_io_error(status.unwrap()))\n+            };\n+\n+            unsafe { (*result_cell_ptr).put_back(result); }\n+\n+            let scheduler: ~Scheduler = Local::take();\n+            scheduler.resume_blocked_task_immediately(task_cell.take());\n+        }\n+    }\n+\n+    assert!(!result_cell.is_empty());\n+    result_cell.take()\n+}\n+\n+pub struct UvUnboundPipe {\n+    pipe: Pipe,\n+    priv home: SchedHandle,\n+}\n+\n+impl UvUnboundPipe {\n+    /// Creates a new unbound pipe homed to the current scheduler, placed on the\n+    /// specified event loop\n+    pub fn new(loop_: &Loop) -> UvUnboundPipe {\n+        UvUnboundPipe {\n+            pipe: Pipe::new(loop_, false),\n+            home: get_handle_to_current_scheduler!(),\n+        }\n+    }\n+}\n+\n+impl HomingIO for UvUnboundPipe {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl Drop for UvUnboundPipe {\n+    fn drop(&mut self) {\n+        do self.home_for_io |self_| {\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.pipe.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub struct UvPipeStream {\n+    priv inner: UvUnboundPipe,\n+}\n+\n+impl UvPipeStream {\n+    pub fn new(inner: UvUnboundPipe) -> UvPipeStream {\n+        UvPipeStream { inner: inner }\n+    }\n+}\n+\n+impl RtioPipe for UvPipeStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        do self.inner.home_for_io_with_sched |self_, scheduler| {\n+            read_stream(self_.pipe.as_stream(), scheduler, buf)\n+        }\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        do self.inner.home_for_io_with_sched |self_, scheduler| {\n+            write_stream(self_.pipe.as_stream(), scheduler, buf)\n+        }\n+    }\n+}\n+\n+pub struct UvTcpStream {\n+    priv watcher: TcpWatcher,\n+    priv home: SchedHandle,\n+}\n+\n+impl HomingIO for UvTcpStream {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl Drop for UvTcpStream {\n+    fn drop(&mut self) {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.as_stream().close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioSocket for UvTcpStream {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+        do self.home_for_io |self_| {\n+            socket_name(Tcp, self_.watcher)\n+        }\n+    }\n+}\n+\n+impl RtioTcpStream for UvTcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            read_stream(self_.watcher.as_stream(), scheduler, buf)\n+        }\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            write_stream(self_.watcher.as_stream(), scheduler, buf)\n+        }\n+    }\n+\n+    fn peer_name(&mut self) -> Result<SocketAddr, IoError> {\n+        do self.home_for_io |self_| {\n+            socket_name(TcpPeer, self_.watcher)\n+        }\n+    }\n+\n+    fn control_congestion(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 0 as c_int) };\n+\n+            match status_to_maybe_uv_error(r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+\n+    fn nodelay(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 1 as c_int) };\n+\n+            match status_to_maybe_uv_error(r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+\n+    fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                uvll::tcp_keepalive(self_.watcher.native_handle(), 1 as c_int,\n+                                    delay_in_seconds as c_uint)\n+            };\n+\n+            match status_to_maybe_uv_error(r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+\n+    fn letdie(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                uvll::tcp_keepalive(self_.watcher.native_handle(), 0 as c_int, 0 as c_uint)\n+            };\n+\n+            match status_to_maybe_uv_error(r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+}\n+\n+pub struct UvUdpSocket {\n+    priv watcher: UdpWatcher,\n+    priv home: SchedHandle,\n+}\n+\n+impl HomingIO for UvUdpSocket {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl Drop for UvUdpSocket {\n+    fn drop(&mut self) {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioSocket for UvUdpSocket {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+        do self.home_for_io |self_| {\n+            socket_name(Udp, self_.watcher)\n+        }\n+    }\n+}\n+\n+impl RtioUdpSocket for UvUdpSocket {\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, SocketAddr), IoError> {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            let result_cell = Cell::new_empty();\n+            let result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n+\n+            let buf_ptr: *&mut [u8] = &buf;\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n+                do self_.watcher.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n+                    let _ = flags; // /XXX add handling for partials?\n+\n+                    watcher.recv_stop();\n+\n+                    let result = match status {\n+                        None => {\n+                            assert!(nread >= 0);\n+                            Ok((nread as uint, addr))\n+                        }\n+                        Some(err) => Err(uv_error_to_io_error(err)),\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+\n+            assert!(!result_cell.is_empty());\n+            result_cell.take()\n+        }\n+    }\n+\n+    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            let result_cell = Cell::new_empty();\n+            let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+            let buf_ptr: *&[u8] = &buf;\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+                do self_.watcher.send(buf, dst) |_watcher, status| {\n+\n+                    let result = match status {\n+                        None => Ok(()),\n+                        Some(err) => Err(uv_error_to_io_error(err)),\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+\n+            assert!(!result_cell.is_empty());\n+            result_cell.take()\n+        }\n+    }\n+\n+    fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                do multi.to_str().with_c_str |m_addr| {\n+                    uvll::udp_set_membership(self_.watcher.native_handle(), m_addr,\n+                                             ptr::null(), uvll::UV_JOIN_GROUP)\n+                }\n+            };\n+\n+            match status_to_maybe_uv_error(r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+\n+    fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                do multi.to_str().with_c_str |m_addr| {\n+                    uvll::udp_set_membership(self_.watcher.native_handle(), m_addr,\n+                                             ptr::null(), uvll::UV_LEAVE_GROUP)\n+                }\n+            };\n+\n+            match status_to_maybe_uv_error(r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+\n+    fn loop_multicast_locally(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+\n+            let r = unsafe {\n+                uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 1 as c_int)\n+            };\n+\n+            match status_to_maybe_uv_error(r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+\n+    fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+\n+            let r = unsafe {\n+                uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 0 as c_int)\n+            };\n+\n+            match status_to_maybe_uv_error(r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+\n+    fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+\n+            let r = unsafe {\n+                uvll::udp_set_multicast_ttl(self_.watcher.native_handle(), ttl as c_int)\n+            };\n+\n+            match status_to_maybe_uv_error(r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+\n+    fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+\n+            let r = unsafe {\n+                uvll::udp_set_ttl(self_.watcher.native_handle(), ttl as c_int)\n+            };\n+\n+            match status_to_maybe_uv_error(r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+\n+    fn hear_broadcasts(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+\n+            let r = unsafe {\n+                uvll::udp_set_broadcast(self_.watcher.native_handle(), 1 as c_int)\n+            };\n+\n+            match status_to_maybe_uv_error(r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+\n+    fn ignore_broadcasts(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+\n+            let r = unsafe {\n+                uvll::udp_set_broadcast(self_.watcher.native_handle(), 0 as c_int)\n+            };\n+\n+            match status_to_maybe_uv_error(r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n+        }\n+    }\n+}\n+\n+pub struct UvTimer {\n+    priv watcher: timer::TimerWatcher,\n+    priv home: SchedHandle,\n+}\n+\n+impl HomingIO for UvTimer {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl UvTimer {\n+    fn new(w: timer::TimerWatcher, home: SchedHandle) -> UvTimer {\n+        UvTimer { watcher: w, home: home }\n+    }\n+}\n+\n+impl Drop for UvTimer {\n+    fn drop(&mut self) {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            uvdebug!(\"closing UvTimer\");\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioTimer for UvTimer {\n+    fn sleep(&mut self, msecs: u64) {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            do scheduler.deschedule_running_task_and_then |_sched, task| {\n+                uvdebug!(\"sleep: entered scheduler context\");\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.start(msecs, 0) |_, status| {\n+                    assert!(status.is_none());\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+            self_.watcher.stop();\n+        }\n+    }\n+\n+    fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n+        use std::comm::oneshot;\n+\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n+        do self.home_for_io |self_| {\n+            let chan = Cell::new(chan.take());\n+            do self_.watcher.start(msecs, 0) |_, status| {\n+                assert!(status.is_none());\n+                assert!(!chan.is_empty());\n+                chan.take().send_deferred(());\n+            }\n+        }\n+\n+        return port;\n+    }\n+\n+    fn period(&mut self, msecs: u64) -> Port<()> {\n+        use std::comm::stream;\n+\n+        let (port, chan) = stream();\n+        let chan = Cell::new(chan);\n+        do self.home_for_io |self_| {\n+            let chan = Cell::new(chan.take());\n+            do self_.watcher.start(msecs, msecs) |_, status| {\n+                assert!(status.is_none());\n+                do chan.with_ref |chan| {\n+                    chan.send_deferred(());\n+                }\n+            }\n+        }\n+\n+        return port;\n+    }\n+}\n+\n+pub struct UvFileStream {\n+    priv loop_: Loop,\n+    priv fd: c_int,\n+    priv close: CloseBehavior,\n+    priv home: SchedHandle,\n+}\n+\n+impl HomingIO for UvFileStream {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl UvFileStream {\n+    fn new(loop_: Loop, fd: c_int, close: CloseBehavior,\n+           home: SchedHandle) -> UvFileStream {\n+        UvFileStream {\n+            loop_: loop_,\n+            fd: fd,\n+            close: close,\n+            home: home,\n+        }\n+    }\n+    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<int, IoError>> = &result_cell;\n+        let buf_ptr: *&mut [u8] = &buf;\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+                let task_cell = Cell::new(task);\n+                let read_req = file::FsRequest::new();\n+                do read_req.read(&self_.loop_, self_.fd, buf, offset) |req, uverr| {\n+                    let res = match uverr  {\n+                        None => Ok(req.get_result() as int),\n+                        Some(err) => Err(uv_error_to_io_error(err))\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+        result_cell.take()\n+    }\n+    fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        let buf_ptr: *&[u8] = &buf;\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+                let task_cell = Cell::new(task);\n+                let write_req = file::FsRequest::new();\n+                do write_req.write(&self_.loop_, self_.fd, buf, offset) |_, uverr| {\n+                    let res = match uverr  {\n+                        None => Ok(()),\n+                        Some(err) => Err(uv_error_to_io_error(err))\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+        result_cell.take()\n+    }\n+    fn seek_common(&mut self, pos: i64, whence: c_int) ->\n+        Result<u64, IoError>{\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            match lseek(self.fd, pos as off_t, whence) {\n+                -1 => {\n+                    Err(IoError {\n+                        kind: OtherIoError,\n+                        desc: \"Failed to lseek.\",\n+                        detail: None\n+                    })\n+                },\n+                n => Ok(n as u64)\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for UvFileStream {\n+    fn drop(&mut self) {\n+        match self.close {\n+            DontClose => {}\n+            CloseAsynchronously => {\n+                let close_req = file::FsRequest::new();\n+                do close_req.close(&self.loop_, self.fd) |_,_| {}\n+            }\n+            CloseSynchronously => {\n+                do self.home_for_io_with_sched |self_, scheduler| {\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        let task_cell = Cell::new(task);\n+                        let close_req = file::FsRequest::new();\n+                        do close_req.close(&self_.loop_, self_.fd) |_,_| {\n+                            let scheduler: ~Scheduler = Local::take();\n+                            scheduler.resume_blocked_task_immediately(task_cell.take());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioFileStream for UvFileStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+        self.base_read(buf, -1)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.base_write(buf, -1)\n+    }\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+        self.base_read(buf, offset as i64)\n+    }\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+        self.base_write(buf, offset as i64)\n+    }\n+    fn seek(&mut self, pos: i64, whence: SeekStyle) -> Result<u64, IoError> {\n+        use std::libc::{SEEK_SET, SEEK_CUR, SEEK_END};\n+        let whence = match whence {\n+            SeekSet => SEEK_SET,\n+            SeekCur => SEEK_CUR,\n+            SeekEnd => SEEK_END\n+        };\n+        self.seek_common(pos, whence)\n+    }\n+    fn tell(&self) -> Result<u64, IoError> {\n+        use std::libc::SEEK_CUR;\n+        // this is temporary\n+        let self_ = unsafe { cast::transmute::<&UvFileStream, &mut UvFileStream>(self) };\n+        self_.seek_common(0, SEEK_CUR)\n+    }\n+    fn flush(&mut self) -> Result<(), IoError> {\n+        Ok(())\n+    }\n+}\n+\n+pub struct UvProcess {\n+    priv process: process::Process,\n+\n+    // Sadly, this structure must be created before we return it, so in that\n+    // brief interim the `home` is None.\n+    priv home: Option<SchedHandle>,\n+\n+    // All None until the process exits (exit_error may stay None)\n+    priv exit_status: Option<int>,\n+    priv term_signal: Option<int>,\n+    priv exit_error: Option<UvError>,\n+\n+    // Used to store which task to wake up from the exit_cb\n+    priv descheduled: Option<BlockedTask>,\n+}\n+\n+impl HomingIO for UvProcess {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.home.get_mut_ref() }\n+}\n+\n+impl Drop for UvProcess {\n+    fn drop(&mut self) {\n+        let close = |self_: &mut UvProcess| {\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task = Cell::new(task);\n+                do self_.process.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task.take());\n+                }\n+            }\n+        };\n+\n+        // If home is none, then this process never actually successfully\n+        // spawned, so there's no need to switch event loops\n+        if self.home.is_none() {\n+            close(self)\n+        } else {\n+            self.home_for_io(close)\n+        }\n+    }\n+}\n+\n+impl RtioProcess for UvProcess {\n+    fn id(&self) -> pid_t {\n+        self.process.pid()\n+    }\n+\n+    fn kill(&mut self, signal: int) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            match self_.process.kill(signal) {\n+                Ok(()) => Ok(()),\n+                Err(uverr) => Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n+    }\n+\n+    fn wait(&mut self) -> int {\n+        // Make sure (on the home scheduler) that we have an exit status listed\n+        do self.home_for_io |self_| {\n+            match self_.exit_status {\n+                Some(*) => {}\n+                None => {\n+                    // If there's no exit code previously listed, then the\n+                    // process's exit callback has yet to be invoked. We just\n+                    // need to deschedule ourselves and wait to be reawoken.\n+                    let scheduler: ~Scheduler = Local::take();\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        assert!(self_.descheduled.is_none());\n+                        self_.descheduled = Some(task);\n+                    }\n+                    assert!(self_.exit_status.is_some());\n+                }\n+            }\n+        }\n+\n+        self.exit_status.unwrap()\n+    }\n+}\n+\n+pub struct UvUnixListener {\n+    priv inner: UvUnboundPipe\n+}\n+\n+impl HomingIO for UvUnixListener {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.inner.home() }\n+}\n+\n+impl UvUnixListener {\n+    fn new(pipe: UvUnboundPipe) -> UvUnixListener {\n+        UvUnixListener { inner: pipe }\n+    }\n+}\n+\n+impl RtioUnixListener for UvUnixListener {\n+    fn listen(~self) -> Result<~RtioUnixAcceptor, IoError> {\n+        do self.home_for_io_consume |self_| {\n+            let acceptor = ~UvUnixAcceptor::new(self_);\n+            let incoming = Cell::new(acceptor.incoming.clone());\n+            let mut stream = acceptor.listener.inner.pipe.as_stream();\n+            let res = do stream.listen |mut server, status| {\n+                do incoming.with_mut_ref |incoming| {\n+                    let inc = match status {\n+                        Some(e) => Err(uv_error_to_io_error(e)),\n+                        None => {\n+                            let pipe = UvUnboundPipe::new(&server.event_loop());\n+                            server.accept(pipe.pipe.as_stream());\n+                            Ok(~UvPipeStream::new(pipe) as ~RtioPipe)\n+                        }\n+                    };\n+                    incoming.send(inc);\n+                }\n+            };\n+            match res {\n+                Ok(()) => Ok(acceptor as ~RtioUnixAcceptor),\n+                Err(e) => Err(uv_error_to_io_error(e)),\n+            }\n+        }\n+    }\n+}\n+\n+pub struct UvTTY {\n+    tty: tty::TTY,\n+    home: SchedHandle,\n+    fd: c_int,\n+}\n+\n+impl HomingIO for UvTTY {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl Drop for UvTTY {\n+    fn drop(&mut self) {\n+        // TTY handles are used for the logger in a task, so this destructor is\n+        // run when a task is destroyed. When a task is being destroyed, a local\n+        // scheduler isn't available, so we can't do the normal \"take the\n+        // scheduler and resume once close is done\". Instead close operations on\n+        // a TTY are asynchronous.\n+        self.tty.close_async();\n+    }\n+}\n+\n+impl RtioTTY for UvTTY {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            read_stream(self_.tty.as_stream(), scheduler, buf)\n+        }\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            write_stream(self_.tty.as_stream(), scheduler, buf)\n+        }\n+    }\n+\n+    fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            match self_.tty.set_mode(raw) {\n+                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n+            }\n+        }\n+    }\n+\n+    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+        do self.home_for_io |self_| {\n+            match self_.tty.get_winsize() {\n+                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n+            }\n+        }\n+    }\n+\n+    fn isatty(&self) -> bool {\n+        unsafe { uvll::guess_handle(self.fd) == uvll::UV_TTY as c_int }\n+    }\n+}\n+\n+pub struct UvUnixAcceptor {\n+    listener: UvUnixListener,\n+    incoming: Tube<Result<~RtioPipe, IoError>>,\n+}\n+\n+impl HomingIO for UvUnixAcceptor {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n+}\n+\n+impl UvUnixAcceptor {\n+    fn new(listener: UvUnixListener) -> UvUnixAcceptor {\n+        UvUnixAcceptor { listener: listener, incoming: Tube::new() }\n+    }\n+}\n+\n+impl RtioUnixAcceptor for UvUnixAcceptor {\n+    fn accept(&mut self) -> Result<~RtioPipe, IoError> {\n+        do self.home_for_io |self_| {\n+            self_.incoming.recv()\n+        }\n+    }\n+\n+    fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            accept_simultaneously(self_.listener.inner.pipe.as_stream(), 1)\n+        }\n+    }\n+\n+    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            accept_simultaneously(self_.listener.inner.pipe.as_stream(), 0)\n+        }\n+    }\n+}\n+\n+pub struct UvSignal {\n+    watcher: signal::SignalWatcher,\n+    home: SchedHandle,\n+}\n+\n+impl HomingIO for UvSignal {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl UvSignal {\n+    fn new(w: signal::SignalWatcher, home: SchedHandle) -> UvSignal {\n+        UvSignal { watcher: w, home: home }\n+    }\n+}\n+\n+impl RtioSignal for UvSignal {}\n+\n+impl Drop for UvSignal {\n+    fn drop(&mut self) {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            uvdebug!(\"closing UvSignal\");\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// this function is full of lies\n+unsafe fn local_io() -> &'static mut IoFactory {\n+    do Local::borrow |sched: &mut Scheduler| {\n+        let mut io = None;\n+        sched.event_loop.io(|i| io = Some(i));\n+        cast::transmute(io.unwrap())\n+    }\n+}\n+\n+#[test]\n+fn test_simple_io_no_connect() {\n+    do run_in_mt_newsched_task {\n+        unsafe {\n+            let io = local_io();\n+            let addr = next_test_ip4();\n+            let maybe_chan = io.tcp_connect(addr);\n+            assert!(maybe_chan.is_err());\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_simple_udp_io_bind_only() {\n+    do run_in_mt_newsched_task {\n+        unsafe {\n+            let io = local_io();\n+            let addr = next_test_ip4();\n+            let maybe_socket = io.udp_bind(addr);\n+            assert!(maybe_socket.is_ok());\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n+    use std::rt::sleeper_list::SleeperList;\n+    use std::rt::work_queue::WorkQueue;\n+    use std::rt::thread::Thread;\n+    use std::rt::task::Task;\n+    use std::rt::sched::{Shutdown, TaskFromFriend};\n+    use std::rt::task::UnwindResult;\n+    do run_in_bare_thread {\n+        let sleepers = SleeperList::new();\n+        let work_queue1 = WorkQueue::new();\n+        let work_queue2 = WorkQueue::new();\n+        let queues = ~[work_queue1.clone(), work_queue2.clone()];\n+\n+        let loop1 = ~UvEventLoop::new() as ~EventLoop;\n+        let mut sched1 = ~Scheduler::new(loop1, work_queue1, queues.clone(),\n+                                         sleepers.clone());\n+        let loop2 = ~UvEventLoop::new() as ~EventLoop;\n+        let mut sched2 = ~Scheduler::new(loop2, work_queue2, queues.clone(),\n+                                         sleepers.clone());\n+\n+        let handle1 = Cell::new(sched1.make_handle());\n+        let handle2 = Cell::new(sched2.make_handle());\n+        let tasksFriendHandle = Cell::new(sched2.make_handle());\n+\n+        let on_exit: ~fn(UnwindResult) = |exit_status| {\n+            handle1.take().send(Shutdown);\n+            handle2.take().send(Shutdown);\n+            assert!(exit_status.is_success());\n+        };\n+\n+        let test_function: ~fn() = || {\n+            let io = unsafe { local_io() };\n+            let addr = next_test_ip4();\n+            let maybe_socket = io.udp_bind(addr);\n+            // this socket is bound to this event loop\n+            assert!(maybe_socket.is_ok());\n+\n+            // block self on sched1\n+            do task::unkillable { // FIXME(#8674)\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    // unblock task\n+                    do task.wake().map |task| {\n+                      // send self to sched2\n+                      tasksFriendHandle.take().send(TaskFromFriend(task));\n+                    };\n+                    // sched1 should now sleep since it has nothing else to do\n+                }\n+            }\n+            // sched2 will wake up and get the task\n+            // as we do nothing else, the function ends and the socket goes out of scope\n+            // sched2 will start to run the destructor\n+            // the destructor will first block the task, set it's home as sched1, then enqueue it\n+            // sched2 will dequeue the task, see that it has a home, and send it to sched1\n+            // sched1 will wake up, exec the close function on the correct loop, and then we're done\n+        };\n+\n+        let mut main_task = ~Task::new_root(&mut sched1.stack_pool, None, test_function);\n+        main_task.death.on_exit = Some(on_exit);\n+        let main_task = Cell::new(main_task);\n+\n+        let null_task = Cell::new(~do Task::new_root(&mut sched2.stack_pool, None) || {});\n+\n+        let sched1 = Cell::new(sched1);\n+        let sched2 = Cell::new(sched2);\n+\n+        let thread1 = do Thread::start {\n+            sched1.take().bootstrap(main_task.take());\n+        };\n+        let thread2 = do Thread::start {\n+            sched2.take().bootstrap(null_task.take());\n+        };\n+\n+        thread1.join();\n+        thread2.join();\n+    }\n+}\n+\n+#[test]\n+fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n+    use std::rt::sleeper_list::SleeperList;\n+    use std::rt::work_queue::WorkQueue;\n+    use std::rt::thread::Thread;\n+    use std::rt::task::Task;\n+    use std::rt::comm::oneshot;\n+    use std::rt::sched::Shutdown;\n+    use std::rt::task::UnwindResult;\n+    do run_in_bare_thread {\n+        let sleepers = SleeperList::new();\n+        let work_queue1 = WorkQueue::new();\n+        let work_queue2 = WorkQueue::new();\n+        let queues = ~[work_queue1.clone(), work_queue2.clone()];\n+\n+        let loop1 = ~UvEventLoop::new() as ~EventLoop;\n+        let mut sched1 = ~Scheduler::new(loop1, work_queue1, queues.clone(),\n+                                         sleepers.clone());\n+        let loop2 = ~UvEventLoop::new() as ~EventLoop;\n+        let mut sched2 = ~Scheduler::new(loop2, work_queue2, queues.clone(),\n+                                         sleepers.clone());\n+\n+        let handle1 = Cell::new(sched1.make_handle());\n+        let handle2 = Cell::new(sched2.make_handle());\n+\n+        let (port, chan) = oneshot();\n+        let port = Cell::new(port);\n+        let chan = Cell::new(chan);\n+\n+        let body1: ~fn() = || {\n+            let io = unsafe { local_io() };\n+            let addr = next_test_ip4();\n+            let socket = io.udp_bind(addr);\n+            assert!(socket.is_ok());\n+            chan.take().send(socket);\n+        };\n+\n+        let body2: ~fn() = || {\n+            let socket = port.take().recv();\n+            assert!(socket.is_ok());\n+            /* The socket goes out of scope and the destructor is called.\n+             * The destructor:\n+             *  - sends itself back to sched1\n+             *  - frees the socket\n+             *  - resets the home of the task to whatever it was previously\n+             */\n+        };\n+\n+        let on_exit: ~fn(UnwindResult) = |exit| {\n+            handle1.take().send(Shutdown);\n+            handle2.take().send(Shutdown);\n+            assert!(exit.is_success());\n+        };\n+\n+        let task1 = Cell::new(~Task::new_root(&mut sched1.stack_pool, None, body1));\n+\n+        let mut task2 = ~Task::new_root(&mut sched2.stack_pool, None, body2);\n+        task2.death.on_exit = Some(on_exit);\n+        let task2 = Cell::new(task2);\n+\n+        let sched1 = Cell::new(sched1);\n+        let sched2 = Cell::new(sched2);\n+\n+        let thread1 = do Thread::start {\n+            sched1.take().bootstrap(task1.take());\n+        };\n+        let thread2 = do Thread::start {\n+            sched2.take().bootstrap(task2.take());\n+        };\n+\n+        thread1.join();\n+        thread2.join();\n+    }\n+}\n+\n+#[test]\n+fn test_simple_tcp_server_and_client() {\n+    do run_in_mt_newsched_task {\n+        let addr = next_test_ip4();\n+        let (port, chan) = oneshot();\n+        let port = Cell::new(port);\n+        let chan = Cell::new(chan);\n+\n+        // Start the server first so it's listening when we connect\n+        do spawntask {\n+            unsafe {\n+                let io = local_io();\n+                let listener = io.tcp_bind(addr).unwrap();\n+                let mut acceptor = listener.listen().unwrap();\n+                chan.take().send(());\n+                let mut stream = acceptor.accept().unwrap();\n+                let mut buf = [0, .. 2048];\n+                let nread = stream.read(buf).unwrap();\n+                assert_eq!(nread, 8);\n+                for i in range(0u, nread) {\n+                    uvdebug!(\"{}\", buf[i]);\n+                    assert_eq!(buf[i], i as u8);\n+                }\n+            }\n+        }\n+\n+        do spawntask {\n+            unsafe {\n+                port.take().recv();\n+                let io = local_io();\n+                let mut stream = io.tcp_connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_simple_tcp_server_and_client_on_diff_threads() {\n+    use std::rt::sleeper_list::SleeperList;\n+    use std::rt::work_queue::WorkQueue;\n+    use std::rt::thread::Thread;\n+    use std::rt::task::Task;\n+    use std::rt::sched::{Shutdown};\n+    use std::rt::task::UnwindResult;\n+    do run_in_bare_thread {\n+        let sleepers = SleeperList::new();\n+\n+        let server_addr = next_test_ip4();\n+        let client_addr = server_addr.clone();\n+\n+        let server_work_queue = WorkQueue::new();\n+        let client_work_queue = WorkQueue::new();\n+        let queues = ~[server_work_queue.clone(), client_work_queue.clone()];\n+\n+        let sloop = ~UvEventLoop::new() as ~EventLoop;\n+        let mut server_sched = ~Scheduler::new(sloop, server_work_queue,\n+                                               queues.clone(), sleepers.clone());\n+        let cloop = ~UvEventLoop::new() as ~EventLoop;\n+        let mut client_sched = ~Scheduler::new(cloop, client_work_queue,\n+                                               queues.clone(), sleepers.clone());\n+\n+        let server_handle = Cell::new(server_sched.make_handle());\n+        let client_handle = Cell::new(client_sched.make_handle());\n+\n+        let server_on_exit: ~fn(UnwindResult) = |exit_status| {\n+            server_handle.take().send(Shutdown);\n+            assert!(exit_status.is_success());\n+        };\n+\n+        let client_on_exit: ~fn(UnwindResult) = |exit_status| {\n+            client_handle.take().send(Shutdown);\n+            assert!(exit_status.is_success());\n+        };\n+\n+        let server_fn: ~fn() = || {\n+            let io = unsafe { local_io() };\n+            let listener = io.tcp_bind(server_addr).unwrap();\n+            let mut acceptor = listener.listen().unwrap();\n+            let mut stream = acceptor.accept().unwrap();\n+            let mut buf = [0, .. 2048];\n+            let nread = stream.read(buf).unwrap();\n+            assert_eq!(nread, 8);\n+            for i in range(0u, nread) {\n+                assert_eq!(buf[i], i as u8);\n+            }\n+        };\n+\n+        let client_fn: ~fn() = || {\n+            let io = unsafe { local_io() };\n+            let mut stream = io.tcp_connect(client_addr);\n+            while stream.is_err() {\n+                stream = io.tcp_connect(client_addr);\n+            }\n+            stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n+        };\n+\n+        let mut server_task = ~Task::new_root(&mut server_sched.stack_pool, None, server_fn);\n+        server_task.death.on_exit = Some(server_on_exit);\n+        let server_task = Cell::new(server_task);\n+\n+        let mut client_task = ~Task::new_root(&mut client_sched.stack_pool, None, client_fn);\n+        client_task.death.on_exit = Some(client_on_exit);\n+        let client_task = Cell::new(client_task);\n+\n+        let server_sched = Cell::new(server_sched);\n+        let client_sched = Cell::new(client_sched);\n+\n+        let server_thread = do Thread::start {\n+            server_sched.take().bootstrap(server_task.take());\n+        };\n+        let client_thread = do Thread::start {\n+            client_sched.take().bootstrap(client_task.take());\n+        };\n+\n+        server_thread.join();\n+        client_thread.join();\n+    }\n+}\n+\n+#[test]\n+fn test_simple_udp_server_and_client() {\n+    do run_in_mt_newsched_task {\n+        let server_addr = next_test_ip4();\n+        let client_addr = next_test_ip4();\n+        let (port, chan) = oneshot();\n+        let port = Cell::new(port);\n+        let chan = Cell::new(chan);\n+\n+        do spawntask {\n+            unsafe {\n+                let io = local_io();\n+                let mut server_socket = io.udp_bind(server_addr).unwrap();\n+                chan.take().send(());\n+                let mut buf = [0, .. 2048];\n+                let (nread,src) = server_socket.recvfrom(buf).unwrap();\n+                assert_eq!(nread, 8);\n+                for i in range(0u, nread) {\n+                    uvdebug!(\"{}\", buf[i]);\n+                    assert_eq!(buf[i], i as u8);\n+                }\n+                assert_eq!(src, client_addr);\n+            }\n+        }\n+\n+        do spawntask {\n+            unsafe {\n+                let io = local_io();\n+                let mut client_socket = io.udp_bind(client_addr).unwrap();\n+                port.take().recv();\n+                client_socket.sendto([0, 1, 2, 3, 4, 5, 6, 7], server_addr);\n+            }\n+        }\n+    }\n+}\n+\n+#[test] #[ignore(reason = \"busted\")]\n+fn test_read_and_block() {\n+    do run_in_mt_newsched_task {\n+        let addr = next_test_ip4();\n+        let (port, chan) = oneshot();\n+        let port = Cell::new(port);\n+        let chan = Cell::new(chan);\n+\n+        do spawntask {\n+            let io = unsafe { local_io() };\n+            let listener = io.tcp_bind(addr).unwrap();\n+            let mut acceptor = listener.listen().unwrap();\n+            chan.take().send(());\n+            let mut stream = acceptor.accept().unwrap();\n+            let mut buf = [0, .. 2048];\n+\n+            let expected = 32;\n+            let mut current = 0;\n+            let mut reads = 0;\n+\n+            while current < expected {\n+                let nread = stream.read(buf).unwrap();\n+                for i in range(0u, nread) {\n+                    let val = buf[i] as uint;\n+                    assert_eq!(val, current % 8);\n+                    current += 1;\n+                }\n+                reads += 1;\n+\n+                do task::unkillable { // FIXME(#8674)\n+                    let scheduler: ~Scheduler = Local::take();\n+                    // Yield to the other task in hopes that it\n+                    // will trigger a read callback while we are\n+                    // not ready for it\n+                    do scheduler.deschedule_running_task_and_then |sched, task| {\n+                        let task = Cell::new(task);\n+                        sched.enqueue_blocked_task(task.take());\n+                    }\n+                }\n+            }\n+\n+            // Make sure we had multiple reads\n+            assert!(reads > 1);\n+        }\n+\n+        do spawntask {\n+            unsafe {\n+                port.take().recv();\n+                let io = local_io();\n+                let mut stream = io.tcp_connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            }\n+        }\n+\n+    }\n+}\n+\n+#[test]\n+fn test_read_read_read() {\n+    do run_in_mt_newsched_task {\n+        let addr = next_test_ip4();\n+        static MAX: uint = 500000;\n+        let (port, chan) = oneshot();\n+        let port = Cell::new(port);\n+        let chan = Cell::new(chan);\n+\n+        do spawntask {\n+            unsafe {\n+                let io = local_io();\n+                let listener = io.tcp_bind(addr).unwrap();\n+                let mut acceptor = listener.listen().unwrap();\n+                chan.take().send(());\n+                let mut stream = acceptor.accept().unwrap();\n+                let buf = [1, .. 2048];\n+                let mut total_bytes_written = 0;\n+                while total_bytes_written < MAX {\n+                    stream.write(buf);\n+                    total_bytes_written += buf.len();\n+                }\n+            }\n+        }\n+\n+        do spawntask {\n+            unsafe {\n+                port.take().recv();\n+                let io = local_io();\n+                let mut stream = io.tcp_connect(addr).unwrap();\n+                let mut buf = [0, .. 2048];\n+                let mut total_bytes_read = 0;\n+                while total_bytes_read < MAX {\n+                    let nread = stream.read(buf).unwrap();\n+                    uvdebug!(\"read {} bytes\", nread);\n+                    total_bytes_read += nread;\n+                    for i in range(0u, nread) {\n+                        assert_eq!(buf[i], 1);\n+                    }\n+                }\n+                uvdebug!(\"read {} bytes total\", total_bytes_read);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+#[ignore(cfg(windows))] // FIXME(#10102) the server never sees the second send\n+fn test_udp_twice() {\n+    do run_in_mt_newsched_task {\n+        let server_addr = next_test_ip4();\n+        let client_addr = next_test_ip4();\n+        let (port, chan) = oneshot();\n+        let port = Cell::new(port);\n+        let chan = Cell::new(chan);\n+\n+        do spawntask {\n+            unsafe {\n+                let io = local_io();\n+                let mut client = io.udp_bind(client_addr).unwrap();\n+                port.take().recv();\n+                assert!(client.sendto([1], server_addr).is_ok());\n+                assert!(client.sendto([2], server_addr).is_ok());\n+            }\n+        }\n+\n+        do spawntask {\n+            unsafe {\n+                let io = local_io();\n+                let mut server = io.udp_bind(server_addr).unwrap();\n+                chan.take().send(());\n+                let mut buf1 = [0];\n+                let mut buf2 = [0];\n+                let (nread1, src1) = server.recvfrom(buf1).unwrap();\n+                let (nread2, src2) = server.recvfrom(buf2).unwrap();\n+                assert_eq!(nread1, 1);\n+                assert_eq!(nread2, 1);\n+                assert_eq!(src1, client_addr);\n+                assert_eq!(src2, client_addr);\n+                assert_eq!(buf1[0], 1);\n+                assert_eq!(buf2[0], 2);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_udp_many_read() {\n+    do run_in_mt_newsched_task {\n+        let server_out_addr = next_test_ip4();\n+        let server_in_addr = next_test_ip4();\n+        let client_out_addr = next_test_ip4();\n+        let client_in_addr = next_test_ip4();\n+        static MAX: uint = 500_000;\n+\n+        let (p1, c1) = oneshot();\n+        let (p2, c2) = oneshot();\n+\n+        let first = Cell::new((p1, c2));\n+        let second = Cell::new((p2, c1));\n+\n+        do spawntask {\n+            unsafe {\n+                let io = local_io();\n+                let mut server_out = io.udp_bind(server_out_addr).unwrap();\n+                let mut server_in = io.udp_bind(server_in_addr).unwrap();\n+                let (port, chan) = first.take();\n+                chan.send(());\n+                port.recv();\n+                let msg = [1, .. 2048];\n+                let mut total_bytes_sent = 0;\n+                let mut buf = [1];\n+                while buf[0] == 1 {\n+                    // send more data\n+                    assert!(server_out.sendto(msg, client_in_addr).is_ok());\n+                    total_bytes_sent += msg.len();\n+                    // check if the client has received enough\n+                    let res = server_in.recvfrom(buf);\n+                    assert!(res.is_ok());\n+                    let (nread, src) = res.unwrap();\n+                    assert_eq!(nread, 1);\n+                    assert_eq!(src, client_out_addr);\n+                }\n+                assert!(total_bytes_sent >= MAX);\n+            }\n+        }\n+\n+        do spawntask {\n+            unsafe {\n+                let io = local_io();\n+                let mut client_out = io.udp_bind(client_out_addr).unwrap();\n+                let mut client_in = io.udp_bind(client_in_addr).unwrap();\n+                let (port, chan) = second.take();\n+                port.recv();\n+                chan.send(());\n+                let mut total_bytes_recv = 0;\n+                let mut buf = [0, .. 2048];\n+                while total_bytes_recv < MAX {\n+                    // ask for more\n+                    assert!(client_out.sendto([1], server_in_addr).is_ok());\n+                    // wait for data\n+                    let res = client_in.recvfrom(buf);\n+                    assert!(res.is_ok());\n+                    let (nread, src) = res.unwrap();\n+                    assert_eq!(src, server_out_addr);\n+                    total_bytes_recv += nread;\n+                    for i in range(0u, nread) {\n+                        assert_eq!(buf[i], 1);\n+                    }\n+                }\n+                // tell the server we're done\n+                assert!(client_out.sendto([0], server_in_addr).is_ok());\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_timer_sleep_simple() {\n+    do run_in_mt_newsched_task {\n+        unsafe {\n+            let io = local_io();\n+            let timer = io.timer_init();\n+            do timer.map_move |mut t| { t.sleep(1) };\n+        }\n+    }\n+}\n+\n+fn file_test_uvio_full_simple_impl() {\n+    use std::rt::io::{Open, Create, ReadWrite, Read};\n+    unsafe {\n+        let io = local_io();\n+        let write_val = \"hello uvio!\";\n+        let path = \"./tmp/file_test_uvio_full.txt\";\n+        {\n+            let create_fm = Create;\n+            let create_fa = ReadWrite;\n+            let mut fd = io.fs_open(&path.to_c_str(), create_fm, create_fa).unwrap();\n+            let write_buf = write_val.as_bytes();\n+            fd.write(write_buf);\n+        }\n+        {\n+            let ro_fm = Open;\n+            let ro_fa = Read;\n+            let mut fd = io.fs_open(&path.to_c_str(), ro_fm, ro_fa).unwrap();\n+            let mut read_vec = [0, .. 1028];\n+            let nread = fd.read(read_vec).unwrap();\n+            let read_val = str::from_utf8(read_vec.slice(0, nread as uint));\n+            assert!(read_val == write_val.to_owned());\n+        }\n+        io.fs_unlink(&path.to_c_str());\n+    }\n+}\n+\n+#[test]\n+fn file_test_uvio_full_simple() {\n+    do run_in_mt_newsched_task {\n+        file_test_uvio_full_simple_impl();\n+    }\n+}\n+\n+fn uvio_naive_print(input: &str) {\n+    unsafe {\n+        use std::libc::{STDOUT_FILENO};\n+        let io = local_io();\n+        {\n+            let mut fd = io.fs_from_raw_fd(STDOUT_FILENO, DontClose);\n+            let write_buf = input.as_bytes();\n+            fd.write(write_buf);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn file_test_uvio_write_to_stdout() {\n+    do run_in_mt_newsched_task {\n+        uvio_naive_print(\"jubilation\\n\");\n+    }\n+}"}, {"sha": "f80178cfa4c620b84287d16bf6c1ce71ee1d5c0a", "filename": "src/librustuv/uvll.rs", "status": "added", "additions": 1174, "deletions": 0, "changes": 1174, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -0,0 +1,1174 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Low-level bindings to the libuv library.\n+ *\n+ * This module contains a set of direct, 'bare-metal' wrappers around\n+ * the libuv C-API.\n+ *\n+ * We're not bothering yet to redefine uv's structs as Rust structs\n+ * because they are quite large and change often between versions.\n+ * The maintenance burden is just too high. Instead we use the uv's\n+ * `uv_handle_size` and `uv_req_size` to find the correct size of the\n+ * structs and allocate them on the heap. This can be revisited later.\n+ *\n+ * There are also a collection of helper functions to ease interacting\n+ * with the low-level API.\n+ *\n+ * As new functionality, existent in uv.h, is added to the rust stdlib,\n+ * the mappings should be added in this module.\n+ */\n+\n+#[allow(non_camel_case_types)]; // C types\n+\n+use std::libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n+use std::libc::ssize_t;\n+use std::libc::{malloc, free};\n+use std::libc;\n+use std::ptr;\n+use std::vec;\n+\n+pub use self::errors::*;\n+\n+pub static OK: c_int = 0;\n+pub static EOF: c_int = -4095;\n+pub static UNKNOWN: c_int = -4094;\n+\n+// uv-errno.h redefines error codes for windows, but not for unix...\n+\n+#[cfg(windows)]\n+pub mod errors {\n+    use std::libc::c_int;\n+\n+    pub static EACCES: c_int = -4093;\n+    pub static ECONNREFUSED: c_int = -4079;\n+    pub static ECONNRESET: c_int = -4078;\n+    pub static ENOTCONN: c_int = -4054;\n+    pub static EPIPE: c_int = -4048;\n+    pub static ECONNABORTED: c_int = -4080;\n+}\n+#[cfg(not(windows))]\n+pub mod errors {\n+    use std::libc;\n+    use std::libc::c_int;\n+\n+    pub static EACCES: c_int = -libc::EACCES;\n+    pub static ECONNREFUSED: c_int = -libc::ECONNREFUSED;\n+    pub static ECONNRESET: c_int = -libc::ECONNRESET;\n+    pub static ENOTCONN: c_int = -libc::ENOTCONN;\n+    pub static EPIPE: c_int = -libc::EPIPE;\n+    pub static ECONNABORTED: c_int = -libc::ECONNABORTED;\n+}\n+\n+pub static PROCESS_SETUID: c_int = 1 << 0;\n+pub static PROCESS_SETGID: c_int = 1 << 1;\n+pub static PROCESS_WINDOWS_VERBATIM_ARGUMENTS: c_int = 1 << 2;\n+pub static PROCESS_DETACHED: c_int = 1 << 3;\n+pub static PROCESS_WINDOWS_HIDE: c_int = 1 << 4;\n+\n+pub static STDIO_IGNORE: c_int = 0x00;\n+pub static STDIO_CREATE_PIPE: c_int = 0x01;\n+pub static STDIO_INHERIT_FD: c_int = 0x02;\n+pub static STDIO_INHERIT_STREAM: c_int = 0x04;\n+pub static STDIO_READABLE_PIPE: c_int = 0x10;\n+pub static STDIO_WRITABLE_PIPE: c_int = 0x20;\n+\n+// see libuv/include/uv-unix.h\n+#[cfg(unix)]\n+pub struct uv_buf_t {\n+    base: *u8,\n+    len: libc::size_t,\n+}\n+\n+// see libuv/include/uv-win.h\n+#[cfg(windows)]\n+pub struct uv_buf_t {\n+    len: u32,\n+    base: *u8,\n+}\n+\n+pub struct uv_process_options_t {\n+    exit_cb: uv_exit_cb,\n+    file: *libc::c_char,\n+    args: **libc::c_char,\n+    env: **libc::c_char,\n+    cwd: *libc::c_char,\n+    flags: libc::c_uint,\n+    stdio_count: libc::c_int,\n+    stdio: *uv_stdio_container_t,\n+    uid: uv_uid_t,\n+    gid: uv_gid_t,\n+}\n+\n+// These fields are private because they must be interfaced with through the\n+// functions below.\n+pub struct uv_stdio_container_t {\n+    priv flags: libc::c_int,\n+    priv stream: *uv_stream_t,\n+}\n+\n+pub type uv_handle_t = c_void;\n+pub type uv_loop_t = c_void;\n+pub type uv_idle_t = c_void;\n+pub type uv_tcp_t = c_void;\n+pub type uv_udp_t = c_void;\n+pub type uv_connect_t = c_void;\n+pub type uv_connection_t = c_void;\n+pub type uv_write_t = c_void;\n+pub type uv_async_t = c_void;\n+pub type uv_timer_t = c_void;\n+pub type uv_stream_t = c_void;\n+pub type uv_fs_t = c_void;\n+pub type uv_udp_send_t = c_void;\n+pub type uv_getaddrinfo_t = c_void;\n+pub type uv_process_t = c_void;\n+pub type uv_pipe_t = c_void;\n+pub type uv_tty_t = c_void;\n+pub type uv_signal_t = c_void;\n+\n+pub struct uv_timespec_t {\n+    tv_sec: libc::c_long,\n+    tv_nsec: libc::c_long\n+}\n+\n+pub struct uv_stat_t {\n+    st_dev: libc::uint64_t,\n+    st_mode: libc::uint64_t,\n+    st_nlink: libc::uint64_t,\n+    st_uid: libc::uint64_t,\n+    st_gid: libc::uint64_t,\n+    st_rdev: libc::uint64_t,\n+    st_ino: libc::uint64_t,\n+    st_size: libc::uint64_t,\n+    st_blksize: libc::uint64_t,\n+    st_blocks: libc::uint64_t,\n+    st_flags: libc::uint64_t,\n+    st_gen: libc::uint64_t,\n+    st_atim: uv_timespec_t,\n+    st_mtim: uv_timespec_t,\n+    st_ctim: uv_timespec_t,\n+    st_birthtim: uv_timespec_t\n+}\n+\n+impl uv_stat_t {\n+    pub fn new() -> uv_stat_t {\n+        uv_stat_t {\n+            st_dev: 0,\n+            st_mode: 0,\n+            st_nlink: 0,\n+            st_uid: 0,\n+            st_gid: 0,\n+            st_rdev: 0,\n+            st_ino: 0,\n+            st_size: 0,\n+            st_blksize: 0,\n+            st_blocks: 0,\n+            st_flags: 0,\n+            st_gen: 0,\n+            st_atim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n+            st_mtim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n+            st_ctim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n+            st_birthtim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 }\n+        }\n+    }\n+    pub fn is_file(&self) -> bool {\n+        ((self.st_mode) & libc::S_IFMT as libc::uint64_t) == libc::S_IFREG as libc::uint64_t\n+    }\n+    pub fn is_dir(&self) -> bool {\n+        ((self.st_mode) & libc::S_IFMT as libc::uint64_t) == libc::S_IFDIR as libc::uint64_t\n+    }\n+}\n+\n+pub type uv_idle_cb = extern \"C\" fn(handle: *uv_idle_t,\n+                                    status: c_int);\n+pub type uv_alloc_cb = extern \"C\" fn(stream: *uv_stream_t,\n+                                     suggested_size: size_t) -> uv_buf_t;\n+pub type uv_read_cb = extern \"C\" fn(stream: *uv_stream_t,\n+                                    nread: ssize_t,\n+                                    buf: uv_buf_t);\n+pub type uv_udp_send_cb = extern \"C\" fn(req: *uv_udp_send_t,\n+                                        status: c_int);\n+pub type uv_udp_recv_cb = extern \"C\" fn(handle: *uv_udp_t,\n+                                        nread: ssize_t,\n+                                        buf: uv_buf_t,\n+                                        addr: *sockaddr,\n+                                        flags: c_uint);\n+pub type uv_close_cb = extern \"C\" fn(handle: *uv_handle_t);\n+pub type uv_walk_cb = extern \"C\" fn(handle: *uv_handle_t,\n+                                    arg: *c_void);\n+pub type uv_async_cb = extern \"C\" fn(handle: *uv_async_t,\n+                                     status: c_int);\n+pub type uv_connect_cb = extern \"C\" fn(handle: *uv_connect_t,\n+                                       status: c_int);\n+pub type uv_connection_cb = extern \"C\" fn(handle: *uv_connection_t,\n+                                          status: c_int);\n+pub type uv_timer_cb = extern \"C\" fn(handle: *uv_timer_t,\n+                                     status: c_int);\n+pub type uv_write_cb = extern \"C\" fn(handle: *uv_write_t,\n+                                     status: c_int);\n+pub type uv_getaddrinfo_cb = extern \"C\" fn(req: *uv_getaddrinfo_t,\n+                                           status: c_int,\n+                                           res: *addrinfo);\n+pub type uv_exit_cb = extern \"C\" fn(handle: *uv_process_t,\n+                                    exit_status: c_int,\n+                                    term_signal: c_int);\n+pub type uv_signal_cb = extern \"C\" fn(handle: *uv_signal_t,\n+                                      signum: c_int);\n+\n+pub type sockaddr = c_void;\n+pub type sockaddr_in = c_void;\n+pub type sockaddr_in6 = c_void;\n+pub type sockaddr_storage = c_void;\n+\n+#[cfg(unix)]\n+pub type socklen_t = c_int;\n+\n+// XXX: This is a standard C type. Could probably be defined in libc\n+#[cfg(target_os = \"android\")]\n+#[cfg(target_os = \"linux\")]\n+pub struct addrinfo {\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: socklen_t,\n+    ai_addr: *sockaddr,\n+    ai_canonname: *char,\n+    ai_next: *addrinfo\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+pub struct addrinfo {\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: socklen_t,\n+    ai_canonname: *char,\n+    ai_addr: *sockaddr,\n+    ai_next: *addrinfo\n+}\n+\n+#[cfg(windows)]\n+pub struct addrinfo {\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: size_t,\n+    ai_canonname: *char,\n+    ai_addr: *sockaddr,\n+    ai_next: *addrinfo\n+}\n+\n+#[cfg(unix)] pub type uv_uid_t = libc::types::os::arch::posix88::uid_t;\n+#[cfg(unix)] pub type uv_gid_t = libc::types::os::arch::posix88::gid_t;\n+#[cfg(windows)] pub type uv_uid_t = libc::c_uchar;\n+#[cfg(windows)] pub type uv_gid_t = libc::c_uchar;\n+\n+#[deriving(Eq)]\n+pub enum uv_handle_type {\n+    UV_UNKNOWN_HANDLE,\n+    UV_ASYNC,\n+    UV_CHECK,\n+    UV_FS_EVENT,\n+    UV_FS_POLL,\n+    UV_HANDLE,\n+    UV_IDLE,\n+    UV_NAMED_PIPE,\n+    UV_POLL,\n+    UV_PREPARE,\n+    UV_PROCESS,\n+    UV_STREAM,\n+    UV_TCP,\n+    UV_TIMER,\n+    UV_TTY,\n+    UV_UDP,\n+    UV_SIGNAL,\n+    UV_FILE,\n+    UV_HANDLE_TYPE_MAX\n+}\n+\n+#[cfg(unix)]\n+#[deriving(Eq)]\n+pub enum uv_req_type {\n+    UV_UNKNOWN_REQ,\n+    UV_REQ,\n+    UV_CONNECT,\n+    UV_WRITE,\n+    UV_SHUTDOWN,\n+    UV_UDP_SEND,\n+    UV_FS,\n+    UV_WORK,\n+    UV_GETADDRINFO,\n+    UV_REQ_TYPE_MAX\n+}\n+\n+// uv_req_type may have additional fields defined by UV_REQ_TYPE_PRIVATE.\n+// See UV_REQ_TYPE_PRIVATE at libuv/include/uv-win.h\n+#[cfg(windows)]\n+#[deriving(Eq)]\n+pub enum uv_req_type {\n+    UV_UNKNOWN_REQ,\n+    UV_REQ,\n+    UV_CONNECT,\n+    UV_WRITE,\n+    UV_SHUTDOWN,\n+    UV_UDP_SEND,\n+    UV_FS,\n+    UV_WORK,\n+    UV_GETADDRINFO,\n+    UV_ACCEPT,\n+    UV_FS_EVENT_REQ,\n+    UV_POLL_REQ,\n+    UV_PROCESS_EXIT,\n+    UV_READ,\n+    UV_UDP_RECV,\n+    UV_WAKEUP,\n+    UV_SIGNAL_REQ,\n+    UV_REQ_TYPE_MAX\n+}\n+\n+#[deriving(Eq)]\n+pub enum uv_membership {\n+    UV_LEAVE_GROUP,\n+    UV_JOIN_GROUP\n+}\n+\n+pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n+    let size = rust_uv_handle_size(handle as uint);\n+    let p = malloc(size);\n+    assert!(p.is_not_null());\n+    return p;\n+}\n+\n+pub unsafe fn free_handle(v: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    free(v)\n+}\n+\n+pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n+    let size = rust_uv_req_size(req as uint);\n+    let p = malloc(size);\n+    assert!(p.is_not_null());\n+    return p;\n+}\n+\n+pub unsafe fn free_req(v: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    free(v)\n+}\n+\n+#[test]\n+fn handle_sanity_check() {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    unsafe {\n+        assert_eq!(UV_HANDLE_TYPE_MAX as uint, rust_uv_handle_type_max());\n+    }\n+}\n+\n+#[test]\n+fn request_sanity_check() {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    unsafe {\n+        assert_eq!(UV_REQ_TYPE_MAX as uint, rust_uv_req_type_max());\n+    }\n+}\n+\n+// XXX Event loops ignore SIGPIPE by default.\n+pub unsafe fn loop_new() -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_loop_new();\n+}\n+\n+pub unsafe fn loop_delete(loop_handle: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_loop_delete(loop_handle);\n+}\n+\n+pub unsafe fn run(loop_handle: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_run(loop_handle);\n+}\n+\n+pub unsafe fn close<T>(handle: *T, cb: uv_close_cb) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_close(handle as *c_void, cb);\n+}\n+\n+pub unsafe fn walk(loop_handle: *c_void, cb: uv_walk_cb, arg: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_walk(loop_handle, cb, arg);\n+}\n+\n+pub unsafe fn idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_idle_init(loop_handle, handle)\n+}\n+\n+pub unsafe fn idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_idle_start(handle, cb)\n+}\n+\n+pub unsafe fn idle_stop(handle: *uv_idle_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_idle_stop(handle)\n+}\n+\n+pub unsafe fn udp_init(loop_handle: *uv_loop_t, handle: *uv_udp_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_udp_init(loop_handle, handle);\n+}\n+\n+pub unsafe fn udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_udp_bind(server, addr, flags);\n+}\n+\n+pub unsafe fn udp_bind6(server: *uv_udp_t, addr: *sockaddr_in6, flags: c_uint) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_udp_bind6(server, addr, flags);\n+}\n+\n+pub unsafe fn udp_send<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n+                          addr: *sockaddr_in, cb: uv_udp_send_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_cnt = buf_in.len() as i32;\n+    return rust_uv_udp_send(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n+}\n+\n+pub unsafe fn udp_send6<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n+                          addr: *sockaddr_in6, cb: uv_udp_send_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_cnt = buf_in.len() as i32;\n+    return rust_uv_udp_send6(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n+}\n+\n+pub unsafe fn udp_recv_start(server: *uv_udp_t, on_alloc: uv_alloc_cb,\n+                             on_recv: uv_udp_recv_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_udp_recv_start(server, on_alloc, on_recv);\n+}\n+\n+pub unsafe fn udp_recv_stop(server: *uv_udp_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_udp_recv_stop(server);\n+}\n+\n+pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_get_udp_handle_from_send_req(send_req);\n+}\n+\n+pub unsafe fn udp_getsockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_udp_getsockname(handle, name);\n+}\n+\n+pub unsafe fn udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n+                                 interface_addr: *c_char, membership: uv_membership) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_udp_set_membership(handle, multicast_addr, interface_addr, membership as c_int);\n+}\n+\n+pub unsafe fn udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_udp_set_multicast_loop(handle, on);\n+}\n+\n+pub unsafe fn udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_udp_set_multicast_ttl(handle, ttl);\n+}\n+\n+pub unsafe fn udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_udp_set_ttl(handle, ttl);\n+}\n+\n+pub unsafe fn udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_udp_set_broadcast(handle, on);\n+}\n+\n+pub unsafe fn tcp_init(loop_handle: *c_void, handle: *uv_tcp_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_tcp_init(loop_handle, handle);\n+}\n+\n+pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n+                          addr_ptr: *sockaddr_in, after_connect_cb: uv_connect_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr, after_connect_cb, addr_ptr);\n+}\n+\n+pub unsafe fn tcp_connect6(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n+                           addr_ptr: *sockaddr_in6, after_connect_cb: uv_connect_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_tcp_connect6(connect_ptr, tcp_handle_ptr, after_connect_cb, addr_ptr);\n+}\n+\n+pub unsafe fn tcp_bind(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_tcp_bind(tcp_server_ptr, addr_ptr);\n+}\n+\n+pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in6) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_tcp_bind6(tcp_server_ptr, addr_ptr);\n+}\n+\n+pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n+}\n+\n+pub unsafe fn tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_tcp_getsockname(handle, name);\n+}\n+\n+pub unsafe fn tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_tcp_nodelay(handle, enable);\n+}\n+\n+pub unsafe fn tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_tcp_keepalive(handle, enable, delay);\n+}\n+\n+pub unsafe fn tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_tcp_simultaneous_accepts(handle, enable);\n+}\n+\n+pub unsafe fn listen<T>(stream: *T, backlog: c_int,\n+                        cb: uv_connection_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_listen(stream as *c_void, backlog, cb);\n+}\n+\n+pub unsafe fn accept(server: *c_void, client: *c_void) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_accept(server as *c_void, client as *c_void);\n+}\n+\n+pub unsafe fn write<T>(req: *uv_write_t,\n+                       stream: *T,\n+                       buf_in: &[uv_buf_t],\n+                       cb: uv_write_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_cnt = buf_in.len() as i32;\n+    return rust_uv_write(req as *c_void, stream as *c_void, buf_ptr, buf_cnt, cb);\n+}\n+pub unsafe fn read_start(stream: *uv_stream_t,\n+                         on_alloc: uv_alloc_cb,\n+                         on_read: uv_read_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_read_start(stream as *c_void, on_alloc, on_read);\n+}\n+\n+pub unsafe fn read_stop(stream: *uv_stream_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_read_stop(stream as *c_void);\n+}\n+\n+pub unsafe fn strerror(err: c_int) -> *c_char {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_strerror(err);\n+}\n+pub unsafe fn err_name(err: c_int) -> *c_char {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_err_name(err);\n+}\n+\n+pub unsafe fn async_init(loop_handle: *c_void,\n+                         async_handle: *uv_async_t,\n+                         cb: uv_async_cb) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_async_init(loop_handle, async_handle, cb);\n+}\n+\n+pub unsafe fn async_send(async_handle: *uv_async_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_async_send(async_handle);\n+}\n+pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    let out_buf = uv_buf_t { base: ptr::null(), len: 0 as size_t };\n+    let out_buf_ptr = ptr::to_unsafe_ptr(&out_buf);\n+    rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n+    return out_buf;\n+}\n+\n+pub unsafe fn timer_init(loop_ptr: *c_void, timer_ptr: *uv_timer_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_timer_init(loop_ptr, timer_ptr);\n+}\n+pub unsafe fn timer_start(timer_ptr: *uv_timer_t,\n+                          cb: uv_timer_cb, timeout: u64,\n+                          repeat: u64) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_timer_start(timer_ptr, cb, timeout, repeat);\n+}\n+pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_timer_stop(timer_ptr);\n+}\n+\n+pub unsafe fn is_ip4_addr(addr: *sockaddr) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    match rust_uv_is_ipv4_sockaddr(addr) { 0 => false, _ => true }\n+}\n+\n+pub unsafe fn is_ip6_addr(addr: *sockaddr) -> bool {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    match rust_uv_is_ipv6_sockaddr(addr) { 0 => false, _ => true }\n+}\n+\n+pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    do ip.with_c_str |ip_buf| {\n+        rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n+    }\n+}\n+pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    do ip.with_c_str |ip_buf| {\n+        rust_uv_ip6_addrp(ip_buf as *u8, port as libc::c_int)\n+    }\n+}\n+\n+pub unsafe fn malloc_sockaddr_storage() -> *sockaddr_storage {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_malloc_sockaddr_storage()\n+}\n+\n+pub unsafe fn free_sockaddr_storage(ss: *sockaddr_storage) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_free_sockaddr_storage(ss);\n+}\n+\n+pub unsafe fn free_ip4_addr(addr: *sockaddr_in) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_free_ip4_addr(addr);\n+}\n+\n+pub unsafe fn free_ip6_addr(addr: *sockaddr_in6) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_free_ip6_addr(addr);\n+}\n+\n+pub unsafe fn ip4_name(addr: *sockaddr_in, dst: *u8, size: size_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_ip4_name(addr, dst, size);\n+}\n+\n+pub unsafe fn ip6_name(addr: *sockaddr_in6, dst: *u8, size: size_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_ip6_name(addr, dst, size);\n+}\n+\n+pub unsafe fn ip4_port(addr: *sockaddr_in) -> c_uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+   return rust_uv_ip4_port(addr);\n+}\n+\n+pub unsafe fn ip6_port(addr: *sockaddr_in6) -> c_uint {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_ip6_port(addr);\n+}\n+\n+pub unsafe fn fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, flags: int, mode: int,\n+                cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_open(loop_ptr, req, path, flags as c_int, mode as c_int, cb)\n+}\n+\n+pub unsafe fn fs_unlink(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_unlink(loop_ptr, req, path, cb)\n+}\n+pub unsafe fn fs_write(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n+                       len: uint, offset: i64, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_write(loop_ptr, req, fd, buf, len as c_uint, offset, cb)\n+}\n+pub unsafe fn fs_read(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n+                       len: uint, offset: i64, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_read(loop_ptr, req, fd, buf, len as c_uint, offset, cb)\n+}\n+pub unsafe fn fs_close(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n+                cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_close(loop_ptr, req, fd, cb)\n+}\n+pub unsafe fn fs_stat(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_stat(loop_ptr, req, path, cb)\n+}\n+pub unsafe fn fs_fstat(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_fstat(loop_ptr, req, fd, cb)\n+}\n+pub unsafe fn fs_mkdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, mode: int,\n+                cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_mkdir(loop_ptr, req, path, mode as c_int, cb)\n+}\n+pub unsafe fn fs_rmdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_rmdir(loop_ptr, req, path, cb)\n+}\n+pub unsafe fn fs_readdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                flags: c_int, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_readdir(loop_ptr, req, path, flags, cb)\n+}\n+pub unsafe fn populate_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_populate_uv_stat(req_in, stat_out)\n+}\n+pub unsafe fn fs_req_cleanup(req: *uv_fs_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_req_cleanup(req);\n+}\n+\n+pub unsafe fn spawn(loop_ptr: *c_void, result: *uv_process_t,\n+                    options: uv_process_options_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_spawn(loop_ptr, result, options);\n+}\n+\n+pub unsafe fn process_kill(p: *uv_process_t, signum: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_process_kill(p, signum);\n+}\n+\n+pub unsafe fn process_pid(p: *uv_process_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_process_pid(p);\n+}\n+\n+pub unsafe fn set_stdio_container_flags(c: *uv_stdio_container_t,\n+                                        flags: libc::c_int) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_set_stdio_container_flags(c, flags);\n+}\n+\n+pub unsafe fn set_stdio_container_fd(c: *uv_stdio_container_t,\n+                                     fd: libc::c_int) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_set_stdio_container_fd(c, fd);\n+}\n+\n+pub unsafe fn set_stdio_container_stream(c: *uv_stdio_container_t,\n+                                         stream: *uv_stream_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_set_stdio_container_stream(c, stream);\n+}\n+\n+pub unsafe fn pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_pipe_init(loop_ptr, p, ipc)\n+}\n+\n+// data access helpers\n+pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_result_from_fs_req(req)\n+}\n+pub unsafe fn get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_ptr_from_fs_req(req)\n+}\n+pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_loop_from_fs_req(req)\n+}\n+pub unsafe fn get_loop_from_getaddrinfo_req(req: *uv_getaddrinfo_t) -> *uv_loop_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_loop_from_getaddrinfo_req(req)\n+}\n+pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_get_loop_for_uv_handle(handle as *c_void);\n+}\n+pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t) -> *uv_stream_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_get_stream_handle_from_connect_req(connect);\n+}\n+pub unsafe fn get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_get_stream_handle_from_write_req(write_req);\n+}\n+pub unsafe fn get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_data_for_uv_loop(loop_ptr)\n+}\n+pub unsafe fn set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_set_data_for_uv_loop(loop_ptr, data);\n+}\n+pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_get_data_for_uv_handle(handle as *c_void);\n+}\n+pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_set_data_for_uv_handle(handle as *c_void, data as *c_void);\n+}\n+pub unsafe fn get_data_for_req<T>(req: *T) -> *c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_get_data_for_req(req as *c_void);\n+}\n+pub unsafe fn set_data_for_req<T, U>(req: *T, data: *U) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_set_data_for_req(req as *c_void, data as *c_void);\n+}\n+pub unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_get_base_from_buf(buf);\n+}\n+pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_get_len_from_buf(buf);\n+}\n+pub unsafe fn getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n+               getaddrinfo_cb: uv_getaddrinfo_cb,\n+               node: *c_char, service: *c_char,\n+               hints: *addrinfo) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_getaddrinfo(loop_, req, getaddrinfo_cb, node, service, hints);\n+}\n+pub unsafe fn freeaddrinfo(ai: *addrinfo) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_freeaddrinfo(ai);\n+}\n+pub unsafe fn pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_pipe_open(pipe, file)\n+}\n+pub unsafe fn pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_pipe_bind(pipe, name)\n+}\n+pub unsafe fn pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n+                           name: *c_char, cb: uv_connect_cb) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_pipe_connect(req, handle, name, cb)\n+}\n+pub unsafe fn tty_init(loop_ptr: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n+                       readable: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_tty_init(loop_ptr, tty, fd, readable)\n+}\n+pub unsafe fn tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_tty_set_mode(tty, mode)\n+}\n+pub unsafe fn tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n+                              height: *c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_tty_get_winsize(tty, width, height)\n+}\n+// FIXME(#9613) this should return uv_handle_type, not a c_int\n+pub unsafe fn guess_handle(fd: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_guess_handle(fd)\n+}\n+\n+pub unsafe fn signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_signal_init(loop_, handle);\n+}\n+pub unsafe fn signal_start(handle: *uv_signal_t,\n+                           signal_cb: uv_signal_cb,\n+                           signum: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_signal_start(handle, signal_cb, signum);\n+}\n+pub unsafe fn signal_stop(handle: *uv_signal_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_signal_stop(handle);\n+}\n+\n+pub struct uv_err_data {\n+    err_name: ~str,\n+    err_msg: ~str,\n+}\n+\n+extern {\n+\n+    fn rust_uv_handle_size(type_: uintptr_t) -> size_t;\n+    fn rust_uv_req_size(type_: uintptr_t) -> size_t;\n+    fn rust_uv_handle_type_max() -> uintptr_t;\n+    fn rust_uv_req_type_max() -> uintptr_t;\n+\n+    // libuv public API\n+    fn rust_uv_loop_new() -> *c_void;\n+    fn rust_uv_loop_delete(lp: *c_void);\n+    fn rust_uv_run(loop_handle: *c_void);\n+    fn rust_uv_close(handle: *c_void, cb: uv_close_cb);\n+    fn rust_uv_walk(loop_handle: *c_void, cb: uv_walk_cb, arg: *c_void);\n+\n+    fn rust_uv_idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int;\n+    fn rust_uv_idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int;\n+    fn rust_uv_idle_stop(handle: *uv_idle_t) -> c_int;\n+\n+    fn rust_uv_async_send(handle: *uv_async_t);\n+    fn rust_uv_async_init(loop_handle: *c_void,\n+                          async_handle: *uv_async_t,\n+                          cb: uv_async_cb) -> c_int;\n+    fn rust_uv_tcp_init(loop_handle: *c_void, handle_ptr: *uv_tcp_t) -> c_int;\n+    fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8, len: size_t);\n+    fn rust_uv_strerror(err: c_int) -> *c_char;\n+    fn rust_uv_err_name(err: c_int) -> *c_char;\n+    fn rust_uv_ip4_addrp(ip: *u8, port: c_int) -> *sockaddr_in;\n+    fn rust_uv_ip6_addrp(ip: *u8, port: c_int) -> *sockaddr_in6;\n+    fn rust_uv_free_ip4_addr(addr: *sockaddr_in);\n+    fn rust_uv_free_ip6_addr(addr: *sockaddr_in6);\n+    fn rust_uv_ip4_name(src: *sockaddr_in, dst: *u8, size: size_t) -> c_int;\n+    fn rust_uv_ip6_name(src: *sockaddr_in6, dst: *u8, size: size_t) -> c_int;\n+    fn rust_uv_ip4_port(src: *sockaddr_in) -> c_uint;\n+    fn rust_uv_ip6_port(src: *sockaddr_in6) -> c_uint;\n+    fn rust_uv_tcp_connect(req: *uv_connect_t, handle: *uv_tcp_t,\n+                           cb: uv_connect_cb,\n+                           addr: *sockaddr_in) -> c_int;\n+    fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t, addr: *sockaddr_in) -> c_int;\n+    fn rust_uv_tcp_connect6(req: *uv_connect_t, handle: *uv_tcp_t,\n+                            cb: uv_connect_cb,\n+                            addr: *sockaddr_in6) -> c_int;\n+    fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, addr: *sockaddr_in6) -> c_int;\n+    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int;\n+    fn rust_uv_tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int;\n+    fn rust_uv_tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int;\n+    fn rust_uv_tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int;\n+    fn rust_uv_tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int;\n+\n+    fn rust_uv_udp_init(loop_handle: *uv_loop_t, handle_ptr: *uv_udp_t) -> c_int;\n+    fn rust_uv_udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int;\n+    fn rust_uv_udp_bind6(server: *uv_udp_t, addr: *sockaddr_in6, flags: c_uint) -> c_int;\n+    fn rust_uv_udp_send(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t,\n+                        buf_cnt: c_int, addr: *sockaddr_in, cb: uv_udp_send_cb) -> c_int;\n+    fn rust_uv_udp_send6(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t,\n+                         buf_cnt: c_int, addr: *sockaddr_in6, cb: uv_udp_send_cb) -> c_int;\n+    fn rust_uv_udp_recv_start(server: *uv_udp_t,\n+                              on_alloc: uv_alloc_cb,\n+                              on_recv: uv_udp_recv_cb) -> c_int;\n+    fn rust_uv_udp_recv_stop(server: *uv_udp_t) -> c_int;\n+    fn rust_uv_get_udp_handle_from_send_req(req: *uv_udp_send_t) -> *uv_udp_t;\n+    fn rust_uv_udp_getsockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int;\n+    fn rust_uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n+                                  interface_addr: *c_char, membership: c_int) -> c_int;\n+    fn rust_uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int;\n+    fn rust_uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n+    fn rust_uv_udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n+    fn rust_uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int;\n+\n+    fn rust_uv_is_ipv4_sockaddr(addr: *sockaddr) -> c_int;\n+    fn rust_uv_is_ipv6_sockaddr(addr: *sockaddr) -> c_int;\n+    fn rust_uv_malloc_sockaddr_storage() -> *sockaddr_storage;\n+    fn rust_uv_free_sockaddr_storage(ss: *sockaddr_storage);\n+\n+    fn rust_uv_listen(stream: *c_void, backlog: c_int,\n+                      cb: uv_connection_cb) -> c_int;\n+    fn rust_uv_accept(server: *c_void, client: *c_void) -> c_int;\n+    fn rust_uv_write(req: *c_void, stream: *c_void, buf_in: *uv_buf_t, buf_cnt: c_int,\n+                     cb: uv_write_cb) -> c_int;\n+    fn rust_uv_read_start(stream: *c_void,\n+                          on_alloc: uv_alloc_cb,\n+                          on_read: uv_read_cb) -> c_int;\n+    fn rust_uv_read_stop(stream: *c_void) -> c_int;\n+    fn rust_uv_timer_init(loop_handle: *c_void, timer_handle: *uv_timer_t) -> c_int;\n+    fn rust_uv_timer_start(timer_handle: *uv_timer_t, cb: uv_timer_cb, timeout: libc::uint64_t,\n+                           repeat: libc::uint64_t) -> c_int;\n+    fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n+    fn rust_uv_fs_open(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                       flags: c_int, mode: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_fs_unlink(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                       cb: *u8) -> c_int;\n+    fn rust_uv_fs_write(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n+                       buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n+    fn rust_uv_fs_read(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n+                       buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n+    fn rust_uv_fs_close(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n+                        cb: *u8) -> c_int;\n+    fn rust_uv_fs_stat(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char, cb: *u8) -> c_int;\n+    fn rust_uv_fs_fstat(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_fs_mkdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                        mode: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_fs_rmdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                        cb: *u8) -> c_int;\n+    fn rust_uv_fs_readdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                        flags: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n+    fn rust_uv_populate_uv_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t);\n+    fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n+    fn rust_uv_get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void;\n+    fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n+    fn rust_uv_get_loop_from_getaddrinfo_req(req: *uv_fs_t) -> *uv_loop_t;\n+\n+    fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n+    fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;\n+    fn rust_uv_get_loop_for_uv_handle(handle: *c_void) -> *c_void;\n+    fn rust_uv_get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void;\n+    fn rust_uv_set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void);\n+    fn rust_uv_get_data_for_uv_handle(handle: *c_void) -> *c_void;\n+    fn rust_uv_set_data_for_uv_handle(handle: *c_void, data: *c_void);\n+    fn rust_uv_get_data_for_req(req: *c_void) -> *c_void;\n+    fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n+    fn rust_uv_get_base_from_buf(buf: uv_buf_t) -> *u8;\n+    fn rust_uv_get_len_from_buf(buf: uv_buf_t) -> size_t;\n+    fn rust_uv_getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n+                           getaddrinfo_cb: uv_getaddrinfo_cb,\n+                           node: *c_char, service: *c_char,\n+                           hints: *addrinfo) -> c_int;\n+    fn rust_uv_freeaddrinfo(ai: *addrinfo);\n+    fn rust_uv_spawn(loop_ptr: *c_void, outptr: *uv_process_t,\n+                     options: uv_process_options_t) -> c_int;\n+    fn rust_uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int;\n+    fn rust_uv_process_pid(p: *uv_process_t) -> c_int;\n+    fn rust_set_stdio_container_flags(c: *uv_stdio_container_t, flags: c_int);\n+    fn rust_set_stdio_container_fd(c: *uv_stdio_container_t, fd: c_int);\n+    fn rust_set_stdio_container_stream(c: *uv_stdio_container_t,\n+                                       stream: *uv_stream_t);\n+    fn rust_uv_pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int;\n+\n+    fn rust_uv_pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int;\n+    fn rust_uv_pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int;\n+    fn rust_uv_pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n+                            name: *c_char, cb: uv_connect_cb);\n+    fn rust_uv_tty_init(loop_ptr: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n+                        readable: c_int) -> c_int;\n+    fn rust_uv_tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int;\n+    fn rust_uv_tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n+                               height: *c_int) -> c_int;\n+    fn rust_uv_guess_handle(fd: c_int) -> c_int;\n+\n+    // XXX: see comments in addrinfo.rs\n+    // These should all really be constants...\n+    //#[rust_stack] pub fn rust_SOCK_STREAM() -> c_int;\n+    //#[rust_stack] pub fn rust_SOCK_DGRAM() -> c_int;\n+    //#[rust_stack] pub fn rust_SOCK_RAW() -> c_int;\n+    //#[rust_stack] pub fn rust_IPPROTO_UDP() -> c_int;\n+    //#[rust_stack] pub fn rust_IPPROTO_TCP() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_ADDRCONFIG() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_ALL() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_CANONNAME() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_NUMERICHOST() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_NUMERICSERV() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_PASSIVE() -> c_int;\n+    //#[rust_stack] pub fn rust_AI_V4MAPPED() -> c_int;\n+\n+    fn rust_uv_signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int;\n+    fn rust_uv_signal_start(handle: *uv_signal_t,\n+                            signal_cb: uv_signal_cb,\n+                            signum: c_int) -> c_int;\n+    fn rust_uv_signal_stop(handle: *uv_signal_t) -> c_int;\n+}"}, {"sha": "16b41276788a00e3515a6610557341194c6237d4", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -12,6 +12,8 @@ use container::MutableSet;\n use hashmap::HashSet;\n use option::{Some, None, Option};\n use vec::ImmutableVector;\n+#[cfg(not(stage0))]\n+use rt::rtio::EventLoop;\n \n // Need to tell the linker on OS X to not barf on undefined symbols\n // and instead look them up at runtime, which we need to resolve\n@@ -25,18 +27,32 @@ pub struct ModEntry<'self> {\n     log_level: *mut u32\n }\n \n+#[cfg(stage0)]\n pub struct CrateMap<'self> {\n-     priv version: i32,\n-     priv entries: &'self [ModEntry<'self>],\n-     priv children: &'self [&'self CrateMap<'self>]\n+    version: i32,\n+    entries: &'self [ModEntry<'self>],\n+    children: &'self [&'self CrateMap<'self>]\n+}\n+\n+#[cfg(not(stage0))]\n+pub struct CrateMap<'self> {\n+    version: i32,\n+    entries: &'self [ModEntry<'self>],\n+    children: &'self [&'self CrateMap<'self>],\n+    event_loop_factory: Option<extern \"C\" fn() -> ~EventLoop>,\n }\n \n #[cfg(not(windows))]\n pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n     extern {\n+        #[cfg(stage0)]\n         #[weak_linkage]\n         #[link_name = \"_rust_crate_map_toplevel\"]\n         static CRATE_MAP: CrateMap<'static>;\n+\n+        #[cfg(not(stage0))]\n+        #[crate_map]\n+        static CRATE_MAP: CrateMap<'static>;\n     }\n \n     let ptr: (*CrateMap) = &'static CRATE_MAP;\n@@ -108,6 +124,7 @@ pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry)) {\n \n #[cfg(test)]\n mod tests {\n+    use option::None;\n     use rt::crate_map::{CrateMap, ModEntry, iter_crate_map};\n \n     #[test]\n@@ -121,13 +138,15 @@ mod tests {\n         let child_crate = CrateMap {\n             version: 2,\n             entries: entries,\n-            children: []\n+            children: [],\n+            event_loop_factory: None,\n         };\n \n         let root_crate = CrateMap {\n             version: 2,\n             entries: [],\n-            children: [&child_crate, &child_crate]\n+            children: [&child_crate, &child_crate],\n+            event_loop_factory: None,\n         };\n \n         let mut cnt = 0;\n@@ -150,23 +169,26 @@ mod tests {\n                 ModEntry { name: \"c::m1\", log_level: &mut level2},\n                 ModEntry { name: \"c::m2\", log_level: &mut level3},\n             ],\n-            children: []\n+            children: [],\n+            event_loop_factory: None,\n         };\n \n         let child_crate1 = CrateMap {\n             version: 2,\n             entries: [\n                 ModEntry { name: \"t::f1\", log_level: &mut 1},\n             ],\n-            children: [&child_crate2]\n+            children: [&child_crate2],\n+            event_loop_factory: None,\n         };\n \n         let root_crate = CrateMap {\n             version: 2,\n             entries: [\n                 ModEntry { name: \"t::f2\", log_level: &mut 0},\n             ],\n-            children: [&child_crate1]\n+            children: [&child_crate1],\n+            event_loop_factory: None,\n         };\n \n         let mut cnt = 0;"}, {"sha": "fb7c6766fd84c420ad7895c50edabc10ce442b14", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -383,7 +383,8 @@ mod test {\n                         //     on windows\n                         assert!(e.kind == ConnectionReset ||\n                                 e.kind == BrokenPipe ||\n-                                e.kind == ConnectionAborted);\n+                                e.kind == ConnectionAborted,\n+                                \"unknown error: {:?}\", e);\n                         stop = true;\n                     }).inside {\n                         stream.write(buf);\n@@ -420,7 +421,8 @@ mod test {\n                         //     on windows\n                         assert!(e.kind == ConnectionReset ||\n                                 e.kind == BrokenPipe ||\n-                                e.kind == ConnectionAborted);\n+                                e.kind == ConnectionAborted,\n+                                \"unknown error: {:?}\", e);\n                         stop = true;\n                     }).inside {\n                         stream.write(buf);"}, {"sha": "d8d07f140217dc968d02208aeb071b61edeeb159", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -68,7 +68,6 @@ use rt::sched::{Scheduler, Shutdown};\n use rt::sleeper_list::SleeperList;\n use rt::task::UnwindResult;\n use rt::task::{Task, SchedTask, GreenTask, Sched};\n-use rt::uv::uvio::UvEventLoop;\n use unstable::atomics::{AtomicInt, AtomicBool, SeqCst};\n use unstable::sync::UnsafeArc;\n use vec::{OwnedVector, MutableVector, ImmutableVector};\n@@ -123,6 +122,7 @@ pub mod io;\n pub mod rtio;\n \n /// libuv and default rtio implementation.\n+#[cfg(stage0)]\n pub mod uv;\n \n /// The Local trait for types that are accessible via thread-local\n@@ -287,7 +287,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         rtdebug!(\"inserting a regular scheduler\");\n \n         // Every scheduler is driven by an I/O event loop.\n-        let loop_ = ~UvEventLoop::new() as ~rtio::EventLoop;\n+        let loop_ = new_event_loop();\n         let mut sched = ~Scheduler::new(loop_,\n                                         work_queue.clone(),\n                                         work_queues.clone(),\n@@ -311,7 +311,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         // set.\n         let work_queue = WorkQueue::new();\n \n-        let main_loop = ~UvEventLoop::new() as ~rtio::EventLoop;\n+        let main_loop = new_event_loop();\n         let mut main_sched = ~Scheduler::new_special(main_loop,\n                                                      work_queue,\n                                                      work_queues.clone(),\n@@ -462,3 +462,29 @@ pub fn in_green_task_context() -> bool {\n         }\n     }\n }\n+\n+#[cfg(stage0)]\n+pub fn new_event_loop() -> ~rtio::EventLoop {\n+    use rt::uv::uvio::UvEventLoop;\n+    ~UvEventLoop::new() as ~rtio::EventLoop\n+}\n+\n+#[cfg(not(stage0))]\n+pub fn new_event_loop() -> ~rtio::EventLoop {\n+    #[fixed_stack_segment]; #[allow(cstack)];\n+\n+    match crate_map::get_crate_map() {\n+        None => {}\n+        Some(map) => {\n+            match map.event_loop_factory {\n+                None => {}\n+                Some(factory) => return factory()\n+            }\n+        }\n+    }\n+\n+    // If the crate map didn't specify a factory to create an event loop, then\n+    // instead just use a basic event loop missing all I/O services to at least\n+    // get the scheduler running.\n+    return basic::event_loop();\n+}"}, {"sha": "4b0333634024b52df4efca81f71972e84d051bfc", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -1013,7 +1013,6 @@ mod test {\n \n     #[test]\n     fn test_schedule_home_states() {\n-\n         use rt::sleeper_list::SleeperList;\n         use rt::work_queue::WorkQueue;\n         use rt::sched::Shutdown;"}, {"sha": "55a8db89d3c059fe5ec2209968eb6417478117ec", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -24,13 +24,12 @@ use rand;\n use result::{Result, Ok, Err};\n use rt::basic;\n use rt::comm::oneshot;\n-use rt::rtio::EventLoop;\n+use rt::new_event_loop;\n use rt::sched::Scheduler;\n use rt::sleeper_list::SleeperList;\n use rt::task::Task;\n use rt::task::UnwindResult;\n use rt::thread::Thread;\n-use rt::uv::uvio::UvEventLoop;\n use rt::work_queue::WorkQueue;\n use unstable::{run_in_bare_thread};\n use vec::{OwnedVector, MutableVector, ImmutableVector};\n@@ -40,7 +39,7 @@ pub fn new_test_uv_sched() -> Scheduler {\n     let queue = WorkQueue::new();\n     let queues = ~[queue.clone()];\n \n-    let mut sched = Scheduler::new(~UvEventLoop::new() as ~EventLoop,\n+    let mut sched = Scheduler::new(new_event_loop(),\n                                    queue,\n                                    queues,\n                                    SleeperList::new());\n@@ -237,7 +236,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         }\n \n         for i in range(0u, nthreads) {\n-            let loop_ = ~UvEventLoop::new() as ~EventLoop;\n+            let loop_ = new_event_loop();\n             let mut sched = ~Scheduler::new(loop_,\n                                             work_queues[i].clone(),\n                                             work_queues.clone(),"}, {"sha": "497d790b4a9c937024d01cb957eeef14d3442ce0", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -237,6 +237,12 @@ impl EventLoop for UvEventLoop {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[lang = \"event_loop_factory\"]\n+pub extern \"C\" fn new_loop() -> ~EventLoop {\n+    ~UvEventLoop::new() as ~EventLoop\n+}\n+\n pub struct UvPausibleIdleCallback {\n     priv watcher: IdleWatcher,\n     priv idle_flag: bool,"}, {"sha": "3a96cfb11718d24a6b961ffc28d560a6f274d314", "filename": "src/libstd/std.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -69,8 +69,13 @@ they contained the following prologue:\n #[deny(non_camel_case_types)];\n #[deny(missing_doc)];\n \n+// When testing libstd, bring in libuv as the I/O backend so tests can print\n+// things and all of the std::rt::io tests have an I/O interface to run on top\n+// of\n+#[cfg(test)] extern mod rustuv(vers = \"0.9-pre\");\n+\n // Make extra accessible for benchmarking\n-#[cfg(test)] extern mod extra(vers=\"0.9-pre\");\n+#[cfg(test)] extern mod extra(vers = \"0.9-pre\");\n \n // Make std testable by not duplicating lang items. See #2912\n #[cfg(test)] extern mod realstd(name = \"std\");"}, {"sha": "a08bf8f3147b86e81970791d3d32d9e5f7566059", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201cab84e8f12ec73131ac4908e6779b277449a2/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=201cab84e8f12ec73131ac4908e6779b277449a2", "patch": "@@ -80,17 +80,14 @@ use comm::{Chan, GenericChan, oneshot};\n use container::MutableMap;\n use hashmap::{HashSet, HashSetMoveIterator};\n use local_data;\n-use rt::in_green_task_context;\n use rt::local::Local;\n-use rt::sched::Scheduler;\n-use rt::KillHandle;\n-use rt::work_queue::WorkQueue;\n-use rt::rtio::EventLoop;\n-use rt::thread::Thread;\n+use rt::sched::{Scheduler, Shutdown, TaskFromFriend};\n use rt::task::{Task, Sched};\n use rt::task::{UnwindReasonLinked, UnwindReasonStr};\n use rt::task::{UnwindResult, Success, Failure};\n-use rt::uv::uvio::UvEventLoop;\n+use rt::thread::Thread;\n+use rt::work_queue::WorkQueue;\n+use rt::{in_green_task_context, new_event_loop, KillHandle};\n use send_str::IntoSendStr;\n use task::SingleThreaded;\n use task::TaskOpts;\n@@ -621,8 +618,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n             let work_queue = WorkQueue::new();\n \n             // Create a new scheduler to hold the new task\n-            let new_loop = ~UvEventLoop::new() as ~EventLoop;\n-            let mut new_sched = ~Scheduler::new_special(new_loop,\n+            let mut new_sched = ~Scheduler::new_special(new_event_loop(),\n                                                         work_queue,\n                                                         (*sched).work_queues.clone(),\n                                                         (*sched).sleeper_list.clone(),"}]}