{"sha": "7052371e39268c08067048654a4e115ac86cc51b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNTIzNzFlMzkyNjhjMDgwNjcwNDg2NTRhNGUxMTVhYzg2Y2M1MWI=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-10T13:27:14Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-11T13:54:35Z"}, "message": "extra: Rename deque::Deque to ringbuf::RingBuf and impl trait Deque\n\nLet RingBuf have a logical name for a concrete type, and Deque is\nused for the Deque trait (implemented by RingBuf and dlist).", "tree": {"sha": "e2accf4ef19df24c7c6e439a8f0fce8550cf960d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2accf4ef19df24c7c6e439a8f0fce8550cf960d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7052371e39268c08067048654a4e115ac86cc51b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7052371e39268c08067048654a4e115ac86cc51b", "html_url": "https://github.com/rust-lang/rust/commit/7052371e39268c08067048654a4e115ac86cc51b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7052371e39268c08067048654a4e115ac86cc51b/comments", "author": null, "committer": null, "parents": [{"sha": "6a95e49fc5bad1367f597bf0eeab7197c9ca226a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a95e49fc5bad1367f597bf0eeab7197c9ca226a", "html_url": "https://github.com/rust-lang/rust/commit/6a95e49fc5bad1367f597bf0eeab7197c9ca226a"}], "stats": {"total": 450, "additions": 237, "deletions": 213}, "files": [{"sha": "66ee52f53db312bee2b77273aa411fe4d9877926", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7052371e39268c08067048654a4e115ac86cc51b/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7052371e39268c08067048654a4e115ac86cc51b/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=7052371e39268c08067048654a4e115ac86cc51b", "patch": "@@ -69,9 +69,9 @@ pub mod flatpipes;\n \n pub mod container;\n pub mod bitv;\n-pub mod deque;\n pub mod fun_treemap;\n pub mod list;\n+pub mod ringbuf;\n pub mod priority_queue;\n pub mod smallintmap;\n "}, {"sha": "28eab9d9012b9689b7a024013978d36e6d2f9299", "filename": "src/libextra/ringbuf.rs", "status": "renamed", "additions": 219, "deletions": 198, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/7052371e39268c08067048654a4e115ac86cc51b/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7052371e39268c08067048654a4e115ac86cc51b/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=7052371e39268c08067048654a4e115ac86cc51b", "patch": "@@ -11,100 +11,85 @@\n //! A double-ended queue implemented as a circular buffer\n \n use std::num;\n+use std::util;\n use std::uint;\n use std::vec;\n use std::iterator::FromIterator;\n \n+use container::Deque;\n+\n static INITIAL_CAPACITY: uint = 8u; // 2^3\n static MINIMUM_CAPACITY: uint = 2u;\n \n #[allow(missing_doc)]\n #[deriving(Clone)]\n-pub struct Deque<T> {\n+pub struct RingBuf<T> {\n     priv nelts: uint,\n     priv lo: uint,\n     priv elts: ~[Option<T>]\n }\n \n-impl<T> Container for Deque<T> {\n-    /// Return the number of elements in the deque\n+impl<T> Container for RingBuf<T> {\n+    /// Return the number of elements in the RingBuf\n     fn len(&self) -> uint { self.nelts }\n \n-    /// Return true if the deque contains no elements\n+    /// Return true if the RingBufcontains no elements\n     fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n-impl<T> Mutable for Deque<T> {\n-    /// Clear the deque, removing all values.\n+impl<T> Mutable for RingBuf<T> {\n+    /// Clear the RingBuf, removing all values.\n     fn clear(&mut self) {\n         for self.elts.mut_iter().advance |x| { *x = None }\n         self.nelts = 0;\n         self.lo = 0;\n     }\n }\n \n-impl<T> Deque<T> {\n-    /// Create an empty Deque\n-    pub fn new() -> Deque<T> {\n-        Deque::with_capacity(INITIAL_CAPACITY)\n+impl<T> Deque<T> for RingBuf<T> {\n+    /// Return a reference to the first element in the RingBuf\n+    fn front<'a>(&'a self) -> Option<&'a T> {\n+        if self.nelts > 0 { Some(self.get(0)) } else { None }\n     }\n \n-    /// Create an empty Deque with space for at least `n` elements.\n-    pub fn with_capacity(n: uint) -> Deque<T> {\n-        Deque{nelts: 0, lo: 0,\n-              elts: vec::from_fn(num::max(MINIMUM_CAPACITY, n), |_| None)}\n+    /// Return a mutable reference to the first element in the RingBuf\n+    fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        if self.nelts > 0 { Some(self.get_mut(0)) } else { None }\n     }\n \n-    /// Return a reference to the first element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    pub fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.raw_index(0)) }\n-\n-    /// Return a reference to the last element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    pub fn peek_back<'a>(&'a self) -> &'a T {\n-        if self.nelts > 0 {\n-            get(self.elts, self.raw_index(self.nelts - 1))\n-        } else {\n-            fail!(\"peek_back: empty deque\");\n-        }\n+    /// Return a reference to the last element in the RingBuf\n+    fn back<'a>(&'a self) -> Option<&'a T> {\n+        if self.nelts > 0 { Some(self.get(self.nelts - 1)) } else { None }\n     }\n \n-    /// Retrieve an element in the deque by index\n-    ///\n-    /// Fails if there is no element with the given index\n-    pub fn get<'a>(&'a self, i: int) -> &'a T {\n-        let idx = (self.lo + (i as uint)) % self.elts.len();\n-        get(self.elts, idx)\n+    /// Return a mutable reference to the last element in the RingBuf\n+    fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        if self.nelts > 0 { Some(self.get_mut(self.nelts - 1)) } else { None }\n     }\n \n-    /// Remove and return the first element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    pub fn pop_front(&mut self) -> T {\n-        let result = self.elts[self.lo].swap_unwrap();\n-        self.lo = (self.lo + 1u) % self.elts.len();\n-        self.nelts -= 1u;\n+    /// Remove and return the first element in the RingBuf, or None if it is empty\n+    fn pop_front(&mut self) -> Option<T> {\n+        let result = util::replace(&mut self.elts[self.lo], None);\n+        if result.is_some() {\n+            self.lo = (self.lo + 1u) % self.elts.len();\n+            self.nelts -= 1u;\n+        }\n         result\n     }\n \n-    /// Return index in underlying vec for a given logical element index\n-    fn raw_index(&self, idx: uint) -> uint {\n-        raw_index(self.lo, self.elts.len(), idx)\n-    }\n-\n-    /// Remove and return the last element in the deque\n-    ///\n-    /// Fails if the deque is empty\n-    pub fn pop_back(&mut self) -> T {\n-        self.nelts -= 1;\n-        let hi = self.raw_index(self.nelts);\n-        self.elts[hi].swap_unwrap()\n+    /// Remove and return the last element in the RingBuf, or None if it is empty\n+    fn pop_back(&mut self) -> Option<T> {\n+        if self.nelts > 0 {\n+            self.nelts -= 1;\n+            let hi = self.raw_index(self.nelts);\n+            util::replace(&mut self.elts[hi], None)\n+        } else {\n+            None\n+        }\n     }\n \n-    /// Prepend an element to the deque\n-    pub fn add_front(&mut self, t: T) {\n+    /// Prepend an element to the RingBuf\n+    fn push_front(&mut self, t: T) {\n         if self.nelts == self.elts.len() {\n             grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n@@ -115,17 +100,57 @@ impl<T> Deque<T> {\n         self.nelts += 1u;\n     }\n \n-    /// Append an element to the deque\n-    pub fn add_back(&mut self, t: T) {\n+    /// Append an element to the RingBuf\n+    fn push_back(&mut self, t: T) {\n         if self.nelts == self.elts.len() {\n             grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n         let hi = self.raw_index(self.nelts);\n         self.elts[hi] = Some(t);\n         self.nelts += 1u;\n     }\n+}\n \n-    /// Reserve capacity for exactly `n` elements in the given deque,\n+impl<T> RingBuf<T> {\n+    /// Create an empty RingBuf\n+    pub fn new() -> RingBuf<T> {\n+        RingBuf::with_capacity(INITIAL_CAPACITY)\n+    }\n+\n+    /// Create an empty RingBuf with space for at least `n` elements.\n+    pub fn with_capacity(n: uint) -> RingBuf<T> {\n+        RingBuf{nelts: 0, lo: 0,\n+              elts: vec::from_fn(num::max(MINIMUM_CAPACITY, n), |_| None)}\n+    }\n+\n+    /// Retrieve an element in the RingBuf by index\n+    ///\n+    /// Fails if there is no element with the given index\n+    pub fn get<'a>(&'a self, i: uint) -> &'a T {\n+        let idx = self.raw_index(i);\n+        match self.elts[idx] {\n+            None => fail!(),\n+            Some(ref v) => v\n+        }\n+    }\n+\n+    /// Retrieve an element in the RingBuf by index\n+    ///\n+    /// Fails if there is no element with the given index\n+    pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T {\n+        let idx = self.raw_index(i);\n+        match self.elts[idx] {\n+            None => fail!(),\n+            Some(ref mut v) => v\n+        }\n+    }\n+\n+    /// Return index in underlying vec for a given logical element index\n+    fn raw_index(&self, idx: uint) -> uint {\n+        raw_index(self.lo, self.elts.len(), idx)\n+    }\n+\n+    /// Reserve capacity for exactly `n` elements in the given RingBuf,\n     /// doing nothing if `self`'s capacity is already equal to or greater\n     /// than the requested capacity\n     ///\n@@ -136,7 +161,7 @@ impl<T> Deque<T> {\n         self.elts.reserve(n);\n     }\n \n-    /// Reserve capacity for at least `n` elements in the given deque,\n+    /// Reserve capacity for at least `n` elements in the given RingBuf,\n     /// over-allocating in case the caller needs to reserve additional\n     /// space.\n     ///\n@@ -151,24 +176,24 @@ impl<T> Deque<T> {\n     }\n \n     /// Front-to-back iterator.\n-    pub fn iter<'a>(&'a self) -> DequeIterator<'a, T> {\n-        DequeIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n+    pub fn iter<'a>(&'a self) -> RingBufIterator<'a, T> {\n+        RingBufIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n     }\n \n     /// Front-to-back iterator which returns mutable values.\n-    pub fn mut_iter<'a>(&'a mut self) -> DequeMutIterator<'a, T> {\n-        DequeMutIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n+    pub fn mut_iter<'a>(&'a mut self) -> RingBufMutIterator<'a, T> {\n+        RingBufMutIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n     }\n \n     /// Back-to-front iterator.\n-    pub fn rev_iter<'a>(&'a self) -> DequeRevIterator<'a, T> {\n-        DequeRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n+    pub fn rev_iter<'a>(&'a self) -> RingBufRevIterator<'a, T> {\n+        RingBufRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n                          lo: self.lo}\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> DequeMutRevIterator<'a, T> {\n-        DequeMutRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> RingBufMutRevIterator<'a, T> {\n+        RingBufMutRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n                             lo: self.lo}\n     }\n }\n@@ -190,41 +215,41 @@ macro_rules! iterator {\n     }\n }\n \n-/// Deque iterator\n-pub struct DequeIterator<'self, T> {\n+/// RingBuf iterator\n+pub struct RingBufIterator<'self, T> {\n     priv lo: uint,\n     priv nelts: uint,\n     priv index: uint,\n     priv elts: &'self [Option<T>],\n }\n-iterator!{impl DequeIterator -> &'self T, get_ref, 1}\n+iterator!{impl RingBufIterator -> &'self T, get_ref, 1}\n \n-/// Deque reverse iterator\n-pub struct DequeRevIterator<'self, T> {\n+/// RingBuf reverse iterator\n+pub struct RingBufRevIterator<'self, T> {\n     priv lo: uint,\n     priv nelts: uint,\n     priv index: uint,\n     priv elts: &'self [Option<T>],\n }\n-iterator!{impl DequeRevIterator -> &'self T, get_ref, -1}\n+iterator!{impl RingBufRevIterator -> &'self T, get_ref, -1}\n \n-/// Deque mutable iterator\n-pub struct DequeMutIterator<'self, T> {\n+/// RingBuf mutable iterator\n+pub struct RingBufMutIterator<'self, T> {\n     priv lo: uint,\n     priv nelts: uint,\n     priv index: uint,\n     priv elts: &'self mut [Option<T>],\n }\n-iterator!{impl DequeMutIterator -> &'self mut T, get_mut_ref, 1}\n+iterator!{impl RingBufMutIterator -> &'self mut T, get_mut_ref, 1}\n \n-/// Deque mutable reverse iterator\n-pub struct DequeMutRevIterator<'self, T> {\n+/// RingBuf mutable reverse iterator\n+pub struct RingBufMutRevIterator<'self, T> {\n     priv lo: uint,\n     priv nelts: uint,\n     priv index: uint,\n     priv elts: &'self mut [Option<T>],\n }\n-iterator!{impl DequeMutRevIterator -> &'self mut T, get_mut_ref, -1}\n+iterator!{impl RingBufMutRevIterator -> &'self mut T, get_mut_ref, -1}\n \n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n@@ -261,10 +286,6 @@ fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut ~[Option<T>]) {\n     }\n }\n \n-fn get<'r, T>(elts: &'r [Option<T>], i: uint) -> &'r T {\n-    match elts[i] { Some(ref t) => t, _ => fail!() }\n-}\n-\n /// Return index in underlying vec for a given logical element index\n fn raw_index(lo: uint, len: uint, index: uint) -> uint {\n     if lo >= len - index {\n@@ -274,21 +295,21 @@ fn raw_index(lo: uint, len: uint, index: uint) -> uint {\n     }\n }\n \n-impl<A: Eq> Eq for Deque<A> {\n-    fn eq(&self, other: &Deque<A>) -> bool {\n+impl<A: Eq> Eq for RingBuf<A> {\n+    fn eq(&self, other: &RingBuf<A>) -> bool {\n         self.nelts == other.nelts &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n-    fn ne(&self, other: &Deque<A>) -> bool {\n+    fn ne(&self, other: &RingBuf<A>) -> bool {\n         !self.eq(other)\n     }\n }\n \n-impl<A, T: Iterator<A>> FromIterator<A, T> for Deque<A> {\n-    fn from_iterator(iterator: &mut T) -> Deque<A> {\n-        let mut deq = Deque::new();\n+impl<A, T: Iterator<A>> FromIterator<A, T> for RingBuf<A> {\n+    fn from_iterator(iterator: &mut T) -> RingBuf<A> {\n+        let mut deq = RingBuf::new();\n         for iterator.advance |elt| {\n-            deq.add_back(elt);\n+            deq.push_back(elt);\n         }\n         deq\n     }\n@@ -304,38 +325,38 @@ mod tests {\n \n     #[test]\n     fn test_simple() {\n-        let mut d = Deque::new();\n+        let mut d = RingBuf::new();\n         assert_eq!(d.len(), 0u);\n-        d.add_front(17);\n-        d.add_front(42);\n-        d.add_back(137);\n+        d.push_front(17);\n+        d.push_front(42);\n+        d.push_back(137);\n         assert_eq!(d.len(), 3u);\n-        d.add_back(137);\n+        d.push_back(137);\n         assert_eq!(d.len(), 4u);\n-        debug!(d.peek_front());\n-        assert_eq!(*d.peek_front(), 42);\n-        debug!(d.peek_back());\n-        assert_eq!(*d.peek_back(), 137);\n-        let mut i: int = d.pop_front();\n+        debug!(d.front());\n+        assert_eq!(*d.front().unwrap(), 42);\n+        debug!(d.back());\n+        assert_eq!(*d.back().unwrap(), 137);\n+        let mut i = d.pop_front();\n         debug!(i);\n-        assert_eq!(i, 42);\n+        assert_eq!(i, Some(42));\n         i = d.pop_back();\n         debug!(i);\n-        assert_eq!(i, 137);\n+        assert_eq!(i, Some(137));\n         i = d.pop_back();\n         debug!(i);\n-        assert_eq!(i, 137);\n+        assert_eq!(i, Some(137));\n         i = d.pop_back();\n         debug!(i);\n-        assert_eq!(i, 17);\n+        assert_eq!(i, Some(17));\n         assert_eq!(d.len(), 0u);\n-        d.add_back(3);\n+        d.push_back(3);\n         assert_eq!(d.len(), 1u);\n-        d.add_front(2);\n+        d.push_front(2);\n         assert_eq!(d.len(), 2u);\n-        d.add_back(4);\n+        d.push_back(4);\n         assert_eq!(d.len(), 3u);\n-        d.add_front(1);\n+        d.push_front(1);\n         assert_eq!(d.len(), 4u);\n         debug!(d.get(0));\n         debug!(d.get(1));\n@@ -354,28 +375,28 @@ mod tests {\n         let c: @int = @64;\n         let d: @int = @175;\n \n-        let mut deq = Deque::new();\n+        let mut deq = RingBuf::new();\n         assert_eq!(deq.len(), 0);\n-        deq.add_front(a);\n-        deq.add_front(b);\n-        deq.add_back(c);\n+        deq.push_front(a);\n+        deq.push_front(b);\n+        deq.push_back(c);\n         assert_eq!(deq.len(), 3);\n-        deq.add_back(d);\n+        deq.push_back(d);\n         assert_eq!(deq.len(), 4);\n-        assert_eq!(*deq.peek_front(), b);\n-        assert_eq!(*deq.peek_back(), d);\n-        assert_eq!(deq.pop_front(), b);\n-        assert_eq!(deq.pop_back(), d);\n-        assert_eq!(deq.pop_back(), c);\n-        assert_eq!(deq.pop_back(), a);\n+        assert_eq!(deq.front(), Some(&b));\n+        assert_eq!(deq.back(), Some(&d));\n+        assert_eq!(deq.pop_front(), Some(b));\n+        assert_eq!(deq.pop_back(), Some(d));\n+        assert_eq!(deq.pop_back(), Some(c));\n+        assert_eq!(deq.pop_back(), Some(a));\n         assert_eq!(deq.len(), 0);\n-        deq.add_back(c);\n+        deq.push_back(c);\n         assert_eq!(deq.len(), 1);\n-        deq.add_front(b);\n+        deq.push_front(b);\n         assert_eq!(deq.len(), 2);\n-        deq.add_back(d);\n+        deq.push_back(d);\n         assert_eq!(deq.len(), 3);\n-        deq.add_front(a);\n+        deq.push_front(a);\n         assert_eq!(deq.len(), 4);\n         assert_eq!(*deq.get(0), a);\n         assert_eq!(*deq.get(1), b);\n@@ -385,28 +406,28 @@ mod tests {\n \n     #[cfg(test)]\n     fn test_parameterized<T:Copy + Eq>(a: T, b: T, c: T, d: T) {\n-        let mut deq = Deque::new();\n+        let mut deq = RingBuf::new();\n         assert_eq!(deq.len(), 0);\n-        deq.add_front(copy a);\n-        deq.add_front(copy b);\n-        deq.add_back(copy c);\n+        deq.push_front(copy a);\n+        deq.push_front(copy b);\n+        deq.push_back(copy c);\n         assert_eq!(deq.len(), 3);\n-        deq.add_back(copy d);\n+        deq.push_back(copy d);\n         assert_eq!(deq.len(), 4);\n-        assert_eq!(copy *deq.peek_front(), copy b);\n-        assert_eq!(copy *deq.peek_back(), copy d);\n-        assert_eq!(deq.pop_front(), copy b);\n-        assert_eq!(deq.pop_back(), copy d);\n-        assert_eq!(deq.pop_back(), copy c);\n-        assert_eq!(deq.pop_back(), copy a);\n+        assert_eq!(deq.front(), Some(&b));\n+        assert_eq!(deq.back(), Some(&d));\n+        assert_eq!(deq.pop_front(), Some(copy b));\n+        assert_eq!(deq.pop_back(), Some(copy d));\n+        assert_eq!(deq.pop_back(), Some(copy c));\n+        assert_eq!(deq.pop_back(), Some(copy a));\n         assert_eq!(deq.len(), 0);\n-        deq.add_back(copy c);\n+        deq.push_back(copy c);\n         assert_eq!(deq.len(), 1);\n-        deq.add_front(copy b);\n+        deq.push_front(copy b);\n         assert_eq!(deq.len(), 2);\n-        deq.add_back(copy d);\n+        deq.push_back(copy d);\n         assert_eq!(deq.len(), 3);\n-        deq.add_front(copy a);\n+        deq.push_front(copy a);\n         assert_eq!(deq.len(), 4);\n         assert_eq!(copy *deq.get(0), copy a);\n         assert_eq!(copy *deq.get(1), copy b);\n@@ -415,56 +436,56 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_add_front_grow() {\n-        let mut deq = Deque::new();\n-        for int::range(0, 66) |i| {\n-            deq.add_front(i);\n+    fn test_push_front_grow() {\n+        let mut deq = RingBuf::new();\n+        for uint::range(0, 66) |i| {\n+            deq.push_front(i);\n         }\n         assert_eq!(deq.len(), 66);\n \n-        for int::range(0, 66) |i| {\n+        for uint::range(0, 66) |i| {\n             assert_eq!(*deq.get(i), 65 - i);\n         }\n \n-        let mut deq = Deque::new();\n-        for int::range(0, 66) |i| {\n-            deq.add_back(i);\n+        let mut deq = RingBuf::new();\n+        for uint::range(0, 66) |i| {\n+            deq.push_back(i);\n         }\n \n-        for int::range(0, 66) |i| {\n+        for uint::range(0, 66) |i| {\n             assert_eq!(*deq.get(i), i);\n         }\n     }\n \n     #[bench]\n     fn bench_new(b: &mut test::BenchHarness) {\n         do b.iter {\n-            let _ = Deque::new::<u64>();\n+            let _ = RingBuf::new::<u64>();\n         }\n     }\n \n     #[bench]\n-    fn bench_add_back(b: &mut test::BenchHarness) {\n-        let mut deq = Deque::new();\n+    fn bench_push_back(b: &mut test::BenchHarness) {\n+        let mut deq = RingBuf::new();\n         do b.iter {\n-            deq.add_back(0);\n+            deq.push_back(0);\n         }\n     }\n \n     #[bench]\n-    fn bench_add_front(b: &mut test::BenchHarness) {\n-        let mut deq = Deque::new();\n+    fn bench_push_front(b: &mut test::BenchHarness) {\n+        let mut deq = RingBuf::new();\n         do b.iter {\n-            deq.add_front(0);\n+            deq.push_front(0);\n         }\n     }\n \n     #[bench]\n     fn bench_grow(b: &mut test::BenchHarness) {\n-        let mut deq = Deque::new();\n+        let mut deq = RingBuf::new();\n         do b.iter {\n             for 65.times {\n-                deq.add_front(1);\n+                deq.push_front(1);\n             }\n         }\n     }\n@@ -518,77 +539,77 @@ mod tests {\n \n     #[test]\n     fn test_with_capacity() {\n-        let mut d = Deque::with_capacity(0);\n-        d.add_back(1);\n+        let mut d = RingBuf::with_capacity(0);\n+        d.push_back(1);\n         assert_eq!(d.len(), 1);\n-        let mut d = Deque::with_capacity(50);\n-        d.add_back(1);\n+        let mut d = RingBuf::with_capacity(50);\n+        d.push_back(1);\n         assert_eq!(d.len(), 1);\n     }\n \n     #[test]\n     fn test_reserve() {\n-        let mut d = Deque::new();\n-        d.add_back(0u64);\n+        let mut d = RingBuf::new();\n+        d.push_back(0u64);\n         d.reserve(50);\n         assert_eq!(d.elts.capacity(), 50);\n-        let mut d = Deque::new();\n-        d.add_back(0u32);\n+        let mut d = RingBuf::new();\n+        d.push_back(0u32);\n         d.reserve(50);\n         assert_eq!(d.elts.capacity(), 50);\n     }\n \n     #[test]\n     fn test_reserve_at_least() {\n-        let mut d = Deque::new();\n-        d.add_back(0u64);\n+        let mut d = RingBuf::new();\n+        d.push_back(0u64);\n         d.reserve_at_least(50);\n         assert_eq!(d.elts.capacity(), 64);\n-        let mut d = Deque::new();\n-        d.add_back(0u32);\n+        let mut d = RingBuf::new();\n+        d.push_back(0u32);\n         d.reserve_at_least(50);\n         assert_eq!(d.elts.capacity(), 64);\n     }\n \n     #[test]\n     fn test_iter() {\n-        let mut d = Deque::new();\n+        let mut d = RingBuf::new();\n         assert_eq!(d.iter().next(), None);\n \n         for int::range(0,5) |i| {\n-            d.add_back(i);\n+            d.push_back(i);\n         }\n         assert_eq!(d.iter().collect::<~[&int]>(), ~[&0,&1,&2,&3,&4]);\n \n         for int::range(6,9) |i| {\n-            d.add_front(i);\n+            d.push_front(i);\n         }\n         assert_eq!(d.iter().collect::<~[&int]>(), ~[&8,&7,&6,&0,&1,&2,&3,&4]);\n     }\n \n     #[test]\n     fn test_rev_iter() {\n-        let mut d = Deque::new();\n+        let mut d = RingBuf::new();\n         assert_eq!(d.rev_iter().next(), None);\n \n         for int::range(0,5) |i| {\n-            d.add_back(i);\n+            d.push_back(i);\n         }\n         assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0]);\n \n         for int::range(6,9) |i| {\n-            d.add_front(i);\n+            d.push_front(i);\n         }\n         assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0,&6,&7,&8]);\n     }\n \n     #[test]\n     fn test_mut_iter() {\n-        let mut d = Deque::new();\n+        let mut d = RingBuf::new();\n         assert!(d.mut_iter().next().is_none());\n \n         for uint::range(0,3) |i| {\n-            d.add_front(i);\n+            d.push_front(i);\n         }\n \n         for d.mut_iter().enumerate().advance |(i, elt)| {\n@@ -607,11 +628,11 @@ mod tests {\n \n     #[test]\n     fn test_mut_rev_iter() {\n-        let mut d = Deque::new();\n+        let mut d = RingBuf::new();\n         assert!(d.mut_rev_iter().next().is_none());\n \n         for uint::range(0,3) |i| {\n-            d.add_front(i);\n+            d.push_front(i);\n         }\n \n         for d.mut_rev_iter().enumerate().advance |(i, elt)| {\n@@ -632,12 +653,12 @@ mod tests {\n     fn test_from_iterator() {\n         use std::iterator;\n         let v = ~[1,2,3,4,5,6,7];\n-        let deq: Deque<int> = v.iter().transform(|&x| x).collect();\n+        let deq: RingBuf<int> = v.iter().transform(|&x| x).collect();\n         let u: ~[int] = deq.iter().transform(|&x| x).collect();\n         assert_eq!(u, v);\n \n         let mut seq = iterator::Counter::new(0u, 2).take_(256);\n-        let deq: Deque<uint> = seq.collect();\n+        let deq: RingBuf<uint> = seq.collect();\n         for deq.iter().enumerate().advance |(i, &x)| {\n             assert_eq!(2*i, x);\n         }\n@@ -646,11 +667,11 @@ mod tests {\n \n     #[test]\n     fn test_clone() {\n-        let mut d = Deque::new();\n-        d.add_front(17);\n-        d.add_front(42);\n-        d.add_back(137);\n-        d.add_back(137);\n+        let mut d = RingBuf::new();\n+        d.push_front(17);\n+        d.push_front(42);\n+        d.push_back(137);\n+        d.push_back(137);\n         assert_eq!(d.len(), 4u);\n         let mut e = d.clone();\n         assert_eq!(e.len(), 4u);\n@@ -663,22 +684,22 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        let mut d = Deque::new();\n-        assert_eq!(&d, &Deque::with_capacity(0));\n-        d.add_front(137);\n-        d.add_front(17);\n-        d.add_front(42);\n-        d.add_back(137);\n-        let mut e = Deque::with_capacity(0);\n-        e.add_back(42);\n-        e.add_back(17);\n-        e.add_back(137);\n-        e.add_back(137);\n+        let mut d = RingBuf::new();\n+        assert_eq!(&d, &RingBuf::with_capacity(0));\n+        d.push_front(137);\n+        d.push_front(17);\n+        d.push_front(42);\n+        d.push_back(137);\n+        let mut e = RingBuf::with_capacity(0);\n+        e.push_back(42);\n+        e.push_back(17);\n+        e.push_back(137);\n+        e.push_back(137);\n         assert_eq!(&e, &d);\n         e.pop_back();\n-        e.add_back(0);\n+        e.push_back(0);\n         assert!(e != d);\n         e.clear();\n-        assert_eq!(e, Deque::new());\n+        assert_eq!(e, RingBuf::new());\n     }\n }", "previous_filename": "src/libextra/deque.rs"}, {"sha": "f185f7d732142d24849a68304042248ff3740bb1", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7052371e39268c08067048654a4e115ac86cc51b/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7052371e39268c08067048654a4e115ac86cc51b/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=7052371e39268c08067048654a4e115ac86cc51b", "patch": "@@ -23,7 +23,8 @@ use std::hashmap::{HashMap, HashSet};\n use std::trie::{TrieMap, TrieSet};\n use std::uint;\n use std::vec;\n-use deque::Deque;\n+use ringbuf::RingBuf;\n+use container::Deque;\n use dlist::List;\n use treemap::{TreeMap, TreeSet};\n \n@@ -679,7 +680,7 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for List<T> {\n impl<\n     S: Encoder,\n     T: Encodable<S>\n-> Encodable<S> for Deque<T> {\n+> Encodable<S> for RingBuf<T> {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             for self.iter().enumerate().advance |(i, e)| {\n@@ -689,12 +690,12 @@ impl<\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for Deque<T> {\n-    fn decode(d: &mut D) -> Deque<T> {\n-        let mut deque = Deque::new();\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for RingBuf<T> {\n+    fn decode(d: &mut D) -> RingBuf<T> {\n+        let mut deque = RingBuf::new();\n         do d.read_seq |d, len| {\n             for uint::range(0, len) |i| {\n-                deque.add_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+                deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n         }\n         deque"}, {"sha": "f0ffa3237b5cfda33dfc96b90e0a3bc753868e32", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7052371e39268c08067048654a4e115ac86cc51b/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7052371e39268c08067048654a4e115ac86cc51b/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=7052371e39268c08067048654a4e115ac86cc51b", "patch": "@@ -19,7 +19,8 @@ An implementation of the Graph500 Breadth First Search problem in Rust.\n extern mod extra;\n use extra::arc;\n use extra::time;\n-use extra::deque::Deque;\n+use extra::ringbuf::RingBuf;\n+use extra::container::Deque;\n use extra::par;\n use std::hashmap::HashSet;\n use std::num::abs;\n@@ -133,18 +134,18 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n     let mut marks : ~[node_id]\n         = vec::from_elem(graph.len(), -1i64);\n \n-    let mut q = Deque::new();\n+    let mut q = RingBuf::new();\n \n-    q.add_back(key);\n+    q.push_back(key);\n     marks[key] = key;\n \n     while !q.is_empty() {\n-        let t = q.pop_front();\n+        let t = q.pop_front().unwrap();\n \n         do graph[t].iter().advance |k| {\n             if marks[*k] == -1i64 {\n                 marks[*k] = t;\n-                q.add_back(*k);\n+                q.push_back(*k);\n             }\n             true\n         };"}, {"sha": "0314c7fed02cc7b7af1f5bc67ecaf0297efe9deb", "filename": "src/test/run-pass/issue-2383.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7052371e39268c08067048654a4e115ac86cc51b/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7052371e39268c08067048654a4e115ac86cc51b/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2383.rs?ref=7052371e39268c08067048654a4e115ac86cc51b", "patch": "@@ -11,9 +11,10 @@\n // except according to those terms.\n \n extern mod extra;\n-use extra::deque::Deque;\n+use extra::ringbuf::RingBuf;\n+use extra::container::Deque;\n \n pub fn main() {\n-    let mut q = Deque::new();\n-    q.add_back(10);\n+    let mut q = RingBuf::new();\n+    q.push_back(10);\n }"}]}