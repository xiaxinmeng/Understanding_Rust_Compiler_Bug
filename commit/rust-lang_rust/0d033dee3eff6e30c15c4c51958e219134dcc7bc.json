{"sha": "0d033dee3eff6e30c15c4c51958e219134dcc7bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMDMzZGVlM2VmZjZlMzBjMTVjNGM1MTk1OGUyMTkxMzRkY2M3YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-30T22:53:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-30T22:53:55Z"}, "message": "Auto merge of #78182 - LeSeulArtichaut:ty-visitor-contolflow, r=lcnr,oli-obk\n\nTypeVisitor: use `std::ops::ControlFlow` instead of `bool`\n\nImplements MCP rust-lang/compiler-team#374.\n\nBlocked on FCP in rust-lang/compiler-team#374.\nr? `@lcnr` cc `@jonas-schievink`", "tree": {"sha": "2294a94918fe0d8a356c0097b22b4eea81f7a65c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2294a94918fe0d8a356c0097b22b4eea81f7a65c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d033dee3eff6e30c15c4c51958e219134dcc7bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d033dee3eff6e30c15c4c51958e219134dcc7bc", "html_url": "https://github.com/rust-lang/rust/commit/0d033dee3eff6e30c15c4c51958e219134dcc7bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d033dee3eff6e30c15c4c51958e219134dcc7bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffe52882ed79be67344dd6085559e308241e7f60", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffe52882ed79be67344dd6085559e308241e7f60", "html_url": "https://github.com/rust-lang/rust/commit/ffe52882ed79be67344dd6085559e308241e7f60"}, {"sha": "9433eb83fefab6e18fe9d963d1005bd9924e8323", "url": "https://api.github.com/repos/rust-lang/rust/commits/9433eb83fefab6e18fe9d963d1005bd9924e8323", "html_url": "https://github.com/rust-lang/rust/commit/9433eb83fefab6e18fe9d963d1005bd9924e8323"}], "stats": {"total": 897, "additions": 522, "deletions": 375}, "files": [{"sha": "524efd04cfce95a7c4e12ee3357fc13e6ef05bdb", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -71,6 +71,7 @@ use rustc_middle::ty::{\n };\n use rustc_span::{BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n+use std::ops::ControlFlow;\n use std::{cmp, fmt};\n \n mod note;\n@@ -1497,7 +1498,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for OpaqueTypesVisitor<'tcx> {\n-            fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<()> {\n                 if let Some((kind, def_id)) = TyCategory::from_ty(t) {\n                     let span = self.tcx.def_span(def_id);\n                     // Avoid cluttering the output when the \"found\" and error span overlap:"}, {"sha": "df3dbfca01d7a498731729823eaa8bacc5fad6c0", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -15,6 +15,8 @@ use rustc_middle::ty::{self, AssocItemContainer, RegionKind, Ty, TypeFoldable, T\n use rustc_span::symbol::Ident;\n use rustc_span::{MultiSpan, Span};\n \n+use std::ops::ControlFlow;\n+\n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static `impl Trait`,\n     /// `dyn Trait` or if a method call on a trait object introduces a static requirement.\n@@ -472,13 +474,13 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n struct TraitObjectVisitor(Vec<DefId>);\n \n impl TypeVisitor<'_> for TraitObjectVisitor {\n-    fn visit_ty(&mut self, t: Ty<'_>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'_>) -> ControlFlow<()> {\n         match t.kind() {\n             ty::Dynamic(preds, RegionKind::ReStatic) => {\n                 if let Some(def_id) = preds.principal_def_id() {\n                     self.0.push(def_id);\n                 }\n-                false\n+                ControlFlow::CONTINUE\n             }\n             _ => t.super_visit_with(self),\n         }"}, {"sha": "9b2ffc7a920b027c266985b7cefb30469f8d0a4d", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -30,6 +30,7 @@ use rustc_middle::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n use std::fmt::Debug;\n+use std::ops::ControlFlow;\n \n #[derive(PartialEq)]\n pub enum NormalizationStrategy {\n@@ -740,15 +741,15 @@ struct ScopeInstantiator<'me, 'tcx> {\n }\n \n impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ControlFlow<()> {\n         self.target_index.shift_in(1);\n         t.super_visit_with(self);\n         self.target_index.shift_out(1);\n \n-        false\n+        ControlFlow::CONTINUE\n     }\n \n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<()> {\n         let ScopeInstantiator { bound_region_scope, next_region, .. } = self;\n \n         match r {\n@@ -759,7 +760,7 @@ impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n             _ => {}\n         }\n \n-        false\n+        ControlFlow::CONTINUE\n     }\n }\n "}, {"sha": "fe4ba5aa4e820600fbdc03b77a02f03842d855fb", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -3,6 +3,8 @@ use super::{FixupError, FixupResult, InferCtxt, Span};\n use rustc_middle::ty::fold::{TypeFolder, TypeVisitor};\n use rustc_middle::ty::{self, Const, InferConst, Ty, TyCtxt, TypeFoldable};\n \n+use std::ops::ControlFlow;\n+\n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC VAR RESOLVER\n \n@@ -121,7 +123,7 @@ impl<'a, 'tcx> UnresolvedTypeFinder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<()> {\n         let t = self.infcx.shallow_resolve(t);\n         if t.has_infer_types() {\n             if let ty::Infer(infer_ty) = *t.kind() {\n@@ -143,15 +145,15 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n                     None\n                 };\n                 self.first_unresolved = Some((t, ty_var_span));\n-                true // Halt visiting.\n+                ControlFlow::BREAK\n             } else {\n                 // Otherwise, visit its contents.\n                 t.super_visit_with(self)\n             }\n         } else {\n             // All type variables in inference types must already be resolved,\n             // - no need to visit the contents, continue visiting.\n-            false\n+            ControlFlow::CONTINUE\n         }\n     }\n }"}, {"sha": "3690a88c0d9730eb0660273896ce83a988facb68", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -22,6 +22,7 @@\n #![feature(never_type)]\n #![feature(or_patterns)]\n #![feature(in_band_lifetimes)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "1a1c2637a6fa696cb87697683073d2ad481e5f83", "filename": "compiler/rustc_infer/src/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -4,6 +4,7 @@ use rustc_middle::ty;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::fmt;\n+use std::ops::ControlFlow;\n \n // Structural impls for the structs in `traits`.\n \n@@ -68,7 +69,7 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n         }\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         self.predicate.visit_with(visitor)\n     }\n }"}, {"sha": "7297a6de4204645766e85dec9456159d1122b38b", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -37,6 +37,7 @@\n #![feature(or_patterns)]\n #![feature(half_open_range_patterns)]\n #![feature(exclusive_range_pattern)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "428cd453dd5a21e02edf4526366cd26c00090815", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -18,6 +18,7 @@ use rustc_target::abi::{Integer, LayoutOf, TagEncoding, VariantIdx, Variants};\n use rustc_target::spec::abi::Abi as SpecAbi;\n \n use std::cmp;\n+use std::ops::ControlFlow;\n use tracing::debug;\n \n declare_lint! {\n@@ -1135,11 +1136,11 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         };\n \n         impl<'a, 'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueTypes<'a, 'tcx> {\n-            fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+            fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<()> {\n                 match ty.kind() {\n                     ty::Opaque(..) => {\n                         self.ty = Some(ty);\n-                        true\n+                        ControlFlow::BREAK\n                     }\n                     // Consider opaque types within projections FFI-safe if they do not normalize\n                     // to more opaque types.\n@@ -1148,7 +1149,11 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                         // If `ty` is a opaque type directly then `super_visit_with` won't invoke\n                         // this function again.\n-                        if ty.has_opaque_types() { self.visit_ty(ty) } else { false }\n+                        if ty.has_opaque_types() {\n+                            self.visit_ty(ty)\n+                        } else {\n+                            ControlFlow::CONTINUE\n+                        }\n                     }\n                     _ => ty.super_visit_with(self),\n                 }"}, {"sha": "b16e22e8d77e8aeee01f32ca8da0434d3c551682", "filename": "compiler/rustc_macros/src/type_foldable.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -15,8 +15,12 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n             }\n         })\n     });\n-    let body_visit = s.fold(false, |acc, bind| {\n-        quote! { #acc || ::rustc_middle::ty::fold::TypeFoldable::visit_with(#bind, __folder) }\n+\n+    let body_visit = s.fold(quote!(), |acc, bind| {\n+        quote! {\n+            #acc\n+            ::rustc_middle::ty::fold::TypeFoldable::visit_with(#bind, __folder)?;\n+        }\n     });\n \n     s.bound_impl(\n@@ -32,8 +36,9 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n             fn super_visit_with<__F: ::rustc_middle::ty::fold::TypeVisitor<'tcx>>(\n                 &self,\n                 __folder: &mut __F\n-            ) -> bool {\n+            ) -> ::std::ops::ControlFlow<()> {\n                 match *self { #body_visit }\n+                ::std::ops::ControlFlow::CONTINUE\n             }\n         },\n     )"}, {"sha": "4b915fe020fc396b9ff3f97547e380e06c2ac8c4", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -49,6 +49,7 @@\n #![feature(int_error_matching)]\n #![feature(half_open_range_patterns)]\n #![feature(exclusive_range_pattern)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"]\n \n #[macro_use]"}, {"sha": "921086366bea25406d0ec09305e44695ebc5f0e2", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -62,9 +62,9 @@ macro_rules! CloneTypeFoldableImpls {\n                 fn super_visit_with<F: $crate::ty::fold::TypeVisitor<$tcx>>(\n                     &self,\n                     _: &mut F)\n-                    -> bool\n+                    -> ::std::ops::ControlFlow<()>\n                 {\n-                    false\n+                    ::std::ops::ControlFlow::CONTINUE\n                 }\n             }\n         )+\n@@ -105,7 +105,7 @@ macro_rules! EnumTypeFoldableImpl {\n             fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n                 &self,\n                 visitor: &mut V,\n-            ) -> bool {\n+            ) -> ::std::ops::ControlFlow<()> {\n                 EnumTypeFoldableImpl!(@VisitVariants(self, visitor) input($($variants)*) output())\n             }\n         }\n@@ -179,9 +179,10 @@ macro_rules! EnumTypeFoldableImpl {\n                 input($($input)*)\n                 output(\n                     $variant ( $($variant_arg),* ) => {\n-                        false $(|| $crate::ty::fold::TypeFoldable::visit_with(\n+                        $($crate::ty::fold::TypeFoldable::visit_with(\n                             $variant_arg, $visitor\n-                        ))*\n+                        )?;)*\n+                        ::std::ops::ControlFlow::CONTINUE\n                     }\n                     $($output)*\n                 )\n@@ -196,9 +197,10 @@ macro_rules! EnumTypeFoldableImpl {\n                 input($($input)*)\n                 output(\n                     $variant { $($variant_arg),* } => {\n-                        false $(|| $crate::ty::fold::TypeFoldable::visit_with(\n+                        $($crate::ty::fold::TypeFoldable::visit_with(\n                             $variant_arg, $visitor\n-                        ))*\n+                        )?;)*\n+                        ::std::ops::ControlFlow::CONTINUE\n                     }\n                     $($output)*\n                 )\n@@ -212,7 +214,7 @@ macro_rules! EnumTypeFoldableImpl {\n             @VisitVariants($this, $visitor)\n                 input($($input)*)\n                 output(\n-                    $variant => { false }\n+                    $variant => { ::std::ops::ControlFlow::CONTINUE }\n                     $($output)*\n                 )\n         )"}, {"sha": "b6b6c968501a34eb2af4b30d31b6bb2263227380", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -32,7 +32,7 @@ use rustc_target::abi;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n-use std::ops::{Index, IndexMut};\n+use std::ops::{ControlFlow, Index, IndexMut};\n use std::slice;\n use std::{iter, mem, option};\n \n@@ -2489,7 +2489,7 @@ impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection {\n         UserTypeProjection { base, projs }\n     }\n \n-    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n+    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> ControlFlow<()> {\n         self.base.visit_with(visitor)\n         // Note: there's nothing in `self.proj` to visit.\n     }"}, {"sha": "391bd8be7e4c59502f80a7236d37e30658d32ad4", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 62, "deletions": 41, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -87,41 +87,46 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n         Terminator { source_info: self.source_info, kind }\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         use crate::mir::TerminatorKind::*;\n \n         match self.kind {\n             SwitchInt { ref discr, switch_ty, .. } => {\n-                discr.visit_with(visitor) || switch_ty.visit_with(visitor)\n+                discr.visit_with(visitor)?;\n+                switch_ty.visit_with(visitor)\n             }\n             Drop { ref place, .. } => place.visit_with(visitor),\n             DropAndReplace { ref place, ref value, .. } => {\n-                place.visit_with(visitor) || value.visit_with(visitor)\n+                place.visit_with(visitor)?;\n+                value.visit_with(visitor)\n             }\n             Yield { ref value, .. } => value.visit_with(visitor),\n             Call { ref func, ref args, ref destination, .. } => {\n-                let dest = if let Some((ref loc, _)) = *destination {\n-                    loc.visit_with(visitor)\n-                } else {\n-                    false\n+                if let Some((ref loc, _)) = *destination {\n+                    loc.visit_with(visitor)?;\n                 };\n-                dest || func.visit_with(visitor) || args.visit_with(visitor)\n+                func.visit_with(visitor)?;\n+                args.visit_with(visitor)\n             }\n             Assert { ref cond, ref msg, .. } => {\n-                if cond.visit_with(visitor) {\n+                if cond.visit_with(visitor).is_break() {\n                     use AssertKind::*;\n                     match msg {\n                         BoundsCheck { ref len, ref index } => {\n-                            len.visit_with(visitor) || index.visit_with(visitor)\n+                            len.visit_with(visitor)?;\n+                            index.visit_with(visitor)\n+                        }\n+                        Overflow(_, l, r) => {\n+                            l.visit_with(visitor)?;\n+                            r.visit_with(visitor)\n                         }\n-                        Overflow(_, l, r) => l.visit_with(visitor) || r.visit_with(visitor),\n                         OverflowNeg(op) | DivisionByZero(op) | RemainderByZero(op) => {\n                             op.visit_with(visitor)\n                         }\n-                        ResumedAfterReturn(_) | ResumedAfterPanic(_) => false,\n+                        ResumedAfterReturn(_) | ResumedAfterPanic(_) => ControlFlow::CONTINUE,\n                     }\n                 } else {\n-                    false\n+                    ControlFlow::CONTINUE\n                 }\n             }\n             InlineAsm { ref operands, .. } => operands.visit_with(visitor),\n@@ -132,7 +137,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             | GeneratorDrop\n             | Unreachable\n             | FalseEdge { .. }\n-            | FalseUnwind { .. } => false,\n+            | FalseUnwind { .. } => ControlFlow::CONTINUE,\n         }\n     }\n }\n@@ -142,8 +147,8 @@ impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n         *self\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<()> {\n+        ControlFlow::CONTINUE\n     }\n }\n \n@@ -152,8 +157,9 @@ impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n         Place { local: self.local.fold_with(folder), projection: self.projection.fold_with(folder) }\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.local.visit_with(visitor) || self.projection.visit_with(visitor)\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.local.visit_with(visitor)?;\n+        self.projection.visit_with(visitor)\n     }\n }\n \n@@ -163,8 +169,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n         folder.tcx().intern_place_elems(&v)\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n     }\n }\n \n@@ -213,32 +219,47 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n         }\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         use crate::mir::Rvalue::*;\n         match *self {\n             Use(ref op) => op.visit_with(visitor),\n             Repeat(ref op, _) => op.visit_with(visitor),\n             ThreadLocalRef(did) => did.visit_with(visitor),\n-            Ref(region, _, ref place) => region.visit_with(visitor) || place.visit_with(visitor),\n+            Ref(region, _, ref place) => {\n+                region.visit_with(visitor)?;\n+                place.visit_with(visitor)\n+            }\n             AddressOf(_, ref place) => place.visit_with(visitor),\n             Len(ref place) => place.visit_with(visitor),\n-            Cast(_, ref op, ty) => op.visit_with(visitor) || ty.visit_with(visitor),\n+            Cast(_, ref op, ty) => {\n+                op.visit_with(visitor)?;\n+                ty.visit_with(visitor)\n+            }\n             BinaryOp(_, ref rhs, ref lhs) | CheckedBinaryOp(_, ref rhs, ref lhs) => {\n-                rhs.visit_with(visitor) || lhs.visit_with(visitor)\n+                rhs.visit_with(visitor)?;\n+                lhs.visit_with(visitor)\n             }\n             UnaryOp(_, ref val) => val.visit_with(visitor),\n             Discriminant(ref place) => place.visit_with(visitor),\n             NullaryOp(_, ty) => ty.visit_with(visitor),\n             Aggregate(ref kind, ref fields) => {\n-                (match **kind {\n-                    AggregateKind::Array(ty) => ty.visit_with(visitor),\n-                    AggregateKind::Tuple => false,\n+                match **kind {\n+                    AggregateKind::Array(ty) => {\n+                        ty.visit_with(visitor)?;\n+                    }\n+                    AggregateKind::Tuple => {}\n                     AggregateKind::Adt(_, _, substs, user_ty, _) => {\n-                        substs.visit_with(visitor) || user_ty.visit_with(visitor)\n+                        substs.visit_with(visitor)?;\n+                        user_ty.visit_with(visitor)?;\n+                    }\n+                    AggregateKind::Closure(_, substs) => {\n+                        substs.visit_with(visitor)?;\n                     }\n-                    AggregateKind::Closure(_, substs) => substs.visit_with(visitor),\n-                    AggregateKind::Generator(_, substs, _) => substs.visit_with(visitor),\n-                }) || fields.visit_with(visitor)\n+                    AggregateKind::Generator(_, substs, _) => {\n+                        substs.visit_with(visitor)?;\n+                    }\n+                }\n+                fields.visit_with(visitor)\n             }\n         }\n     }\n@@ -253,7 +274,7 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n         }\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         match *self {\n             Operand::Copy(ref place) | Operand::Move(ref place) => place.visit_with(visitor),\n             Operand::Constant(ref c) => c.visit_with(visitor),\n@@ -277,13 +298,13 @@ impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n         }\n     }\n \n-    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n+    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> ControlFlow<()> {\n         use crate::mir::ProjectionElem::*;\n \n         match self {\n             Field(_, ty) => ty.visit_with(visitor),\n             Index(v) => v.visit_with(visitor),\n-            _ => false,\n+            _ => ControlFlow::CONTINUE,\n         }\n     }\n }\n@@ -292,26 +313,26 @@ impl<'tcx> TypeFoldable<'tcx> for Field {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n         *self\n     }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<()> {\n+        ControlFlow::CONTINUE\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n         *self\n     }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<()> {\n+        ControlFlow::CONTINUE\n     }\n }\n \n impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n         self.clone()\n     }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<()> {\n+        ControlFlow::CONTINUE\n     }\n }\n \n@@ -323,7 +344,7 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n             literal: self.literal.fold_with(folder),\n         }\n     }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         self.literal.visit_with(visitor)\n     }\n }"}, {"sha": "70a8157c04ac7e5041ef3aafd146f3d072a4a498", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 70, "deletions": 47, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -37,6 +37,7 @@ use rustc_hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashSet;\n use std::collections::BTreeMap;\n use std::fmt;\n+use std::ops::ControlFlow;\n \n /// This trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in `TypeFolder`.\n@@ -48,8 +49,8 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.super_fold_with(folder)\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool;\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()>;\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         self.super_visit_with(visitor)\n     }\n \n@@ -58,7 +59,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     /// If `binder` is `ty::INNERMOST`, this indicates whether\n     /// there are any late-bound regions that appear free.\n     fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n-        self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder })\n+        self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder }).is_break()\n     }\n \n     /// Returns `true` if this `self` has any regions that escape `binder` (and\n@@ -72,7 +73,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     }\n \n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.visit_with(&mut HasTypeFlagsVisitor { flags })\n+        self.visit_with(&mut HasTypeFlagsVisitor { flags }).is_break()\n     }\n     fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n@@ -143,11 +144,11 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     }\n \n     /// A visitor that does not recurse into types, works like `fn walk_shallow` in `Ty`.\n-    fn visit_tys_shallow(&self, visit: impl FnMut(Ty<'tcx>) -> bool) -> bool {\n+    fn visit_tys_shallow(&self, visit: impl FnMut(Ty<'tcx>) -> ControlFlow<()>) -> ControlFlow<()> {\n         pub struct Visitor<F>(F);\n \n-        impl<'tcx, F: FnMut(Ty<'tcx>) -> bool> TypeVisitor<'tcx> for Visitor<F> {\n-            fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        impl<'tcx, F: FnMut(Ty<'tcx>) -> ControlFlow<()>> TypeVisitor<'tcx> for Visitor<F> {\n+            fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<()> {\n                 self.0(ty)\n             }\n         }\n@@ -160,8 +161,8 @@ impl TypeFoldable<'tcx> for hir::Constness {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n         *self\n     }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<()> {\n+        ControlFlow::CONTINUE\n     }\n }\n \n@@ -194,23 +195,23 @@ pub trait TypeFolder<'tcx>: Sized {\n }\n \n pub trait TypeVisitor<'tcx>: Sized {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<()> {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<()> {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<()> {\n         r.super_visit_with(self)\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<()> {\n         c.super_visit_with(self)\n     }\n \n-    fn visit_predicate(&mut self, p: ty::Predicate<'tcx>) -> bool {\n+    fn visit_predicate(&mut self, p: ty::Predicate<'tcx>) -> ControlFlow<()> {\n         p.super_visit_with(self)\n     }\n }\n@@ -302,8 +303,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         value: &impl TypeFoldable<'tcx>,\n         callback: impl FnMut(ty::Region<'tcx>) -> bool,\n     ) -> bool {\n-        return value.visit_with(&mut RegionVisitor { outer_index: ty::INNERMOST, callback });\n-\n         struct RegionVisitor<F> {\n             /// The index of a binder *just outside* the things we have\n             /// traversed. If we encounter a bound region bound by this\n@@ -330,31 +329,39 @@ impl<'tcx> TyCtxt<'tcx> {\n         where\n             F: FnMut(ty::Region<'tcx>) -> bool,\n         {\n-            fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n+            fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<()> {\n                 self.outer_index.shift_in(1);\n                 let result = t.as_ref().skip_binder().visit_with(self);\n                 self.outer_index.shift_out(1);\n                 result\n             }\n \n-            fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+            fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<()> {\n                 match *r {\n                     ty::ReLateBound(debruijn, _) if debruijn < self.outer_index => {\n-                        false // ignore bound regions, keep visiting\n+                        ControlFlow::CONTINUE\n+                    }\n+                    _ => {\n+                        if (self.callback)(r) {\n+                            ControlFlow::BREAK\n+                        } else {\n+                            ControlFlow::CONTINUE\n+                        }\n                     }\n-                    _ => (self.callback)(r),\n                 }\n             }\n \n-            fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+            fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<()> {\n                 // We're only interested in types involving regions\n                 if ty.flags().intersects(TypeFlags::HAS_FREE_REGIONS) {\n                     ty.super_visit_with(self)\n                 } else {\n-                    false // keep visiting\n+                    ControlFlow::CONTINUE\n                 }\n             }\n         }\n+\n+        value.visit_with(&mut RegionVisitor { outer_index: ty::INNERMOST, callback }).is_break()\n     }\n }\n \n@@ -670,7 +677,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     {\n         let mut collector = LateBoundRegionsCollector::new(just_constraint);\n         let result = value.as_ref().skip_binder().visit_with(&mut collector);\n-        assert!(!result); // should never have stopped early\n+        assert!(result.is_continue()); // should never have stopped early\n         collector.regions\n     }\n \n@@ -837,43 +844,55 @@ struct HasEscapingVarsVisitor {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<()> {\n         self.outer_index.shift_in(1);\n         let result = t.super_visit_with(self);\n         self.outer_index.shift_out(1);\n         result\n     }\n \n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<()> {\n         // If the outer-exclusive-binder is *strictly greater* than\n         // `outer_index`, that means that `t` contains some content\n         // bound at `outer_index` or above (because\n         // `outer_exclusive_binder` is always 1 higher than the\n         // content in `t`). Therefore, `t` has some escaping vars.\n-        t.outer_exclusive_binder > self.outer_index\n+        if t.outer_exclusive_binder > self.outer_index {\n+            ControlFlow::BREAK\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n     }\n \n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<()> {\n         // If the region is bound by `outer_index` or anything outside\n         // of outer index, then it escapes the binders we have\n         // visited.\n-        r.bound_at_or_above_binder(self.outer_index)\n+        if r.bound_at_or_above_binder(self.outer_index) {\n+            ControlFlow::BREAK\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n     }\n \n-    fn visit_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> bool {\n+    fn visit_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> ControlFlow<()> {\n         // we don't have a `visit_infer_const` callback, so we have to\n         // hook in here to catch this case (annoying...), but\n         // otherwise we do want to remember to visit the rest of the\n         // const, as it has types/regions embedded in a lot of other\n         // places.\n         match ct.val {\n-            ty::ConstKind::Bound(debruijn, _) if debruijn >= self.outer_index => true,\n+            ty::ConstKind::Bound(debruijn, _) if debruijn >= self.outer_index => ControlFlow::BREAK,\n             _ => ct.super_visit_with(self),\n         }\n     }\n \n-    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n-        predicate.inner.outer_exclusive_binder > self.outer_index\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<()> {\n+        if predicate.inner.outer_exclusive_binder > self.outer_index {\n+            ControlFlow::BREAK\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n     }\n }\n \n@@ -883,34 +902,38 @@ struct HasTypeFlagsVisitor {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n-    fn visit_ty(&mut self, t: Ty<'_>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'_>) -> ControlFlow<()> {\n         debug!(\n             \"HasTypeFlagsVisitor: t={:?} t.flags={:?} self.flags={:?}\",\n             t,\n             t.flags(),\n             self.flags\n         );\n-        t.flags().intersects(self.flags)\n+        if t.flags().intersects(self.flags) { ControlFlow::BREAK } else { ControlFlow::CONTINUE }\n     }\n \n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<()> {\n         let flags = r.type_flags();\n         debug!(\"HasTypeFlagsVisitor: r={:?} r.flags={:?} self.flags={:?}\", r, flags, self.flags);\n-        flags.intersects(self.flags)\n+        if flags.intersects(self.flags) { ControlFlow::BREAK } else { ControlFlow::CONTINUE }\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<()> {\n         let flags = FlagComputation::for_const(c);\n         debug!(\"HasTypeFlagsVisitor: c={:?} c.flags={:?} self.flags={:?}\", c, flags, self.flags);\n-        flags.intersects(self.flags)\n+        if flags.intersects(self.flags) { ControlFlow::BREAK } else { ControlFlow::CONTINUE }\n     }\n \n-    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<()> {\n         debug!(\n             \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\",\n             predicate, predicate.inner.flags, self.flags\n         );\n-        predicate.inner.flags.intersects(self.flags)\n+        if predicate.inner.flags.intersects(self.flags) {\n+            ControlFlow::BREAK\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n     }\n }\n \n@@ -941,45 +964,45 @@ impl LateBoundRegionsCollector {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<()> {\n         self.current_index.shift_in(1);\n         let result = t.super_visit_with(self);\n         self.current_index.shift_out(1);\n         result\n     }\n \n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<()> {\n         // if we are only looking for \"constrained\" region, we have to\n         // ignore the inputs to a projection, as they may not appear\n         // in the normalized form\n         if self.just_constrained {\n             if let ty::Projection(..) | ty::Opaque(..) = t.kind() {\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n         }\n \n         t.super_visit_with(self)\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<()> {\n         // if we are only looking for \"constrained\" region, we have to\n         // ignore the inputs of an unevaluated const, as they may not appear\n         // in the normalized form\n         if self.just_constrained {\n             if let ty::ConstKind::Unevaluated(..) = c.val {\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n         }\n \n         c.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<()> {\n         if let ty::ReLateBound(debruijn, br) = *r {\n             if debruijn == self.current_index {\n                 self.regions.insert(br);\n             }\n         }\n-        false\n+        ControlFlow::CONTINUE\n     }\n }"}, {"sha": "096c53ca9964cb94e769f6f949c0df9538673aad", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -46,7 +46,7 @@ use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n-use std::ops::Range;\n+use std::ops::{ControlFlow, Range};\n use std::ptr;\n use std::str;\n \n@@ -1776,8 +1776,9 @@ impl<'tcx> TypeFoldable<'tcx> for ParamEnv<'tcx> {\n         ParamEnv::new(self.caller_bounds().fold_with(folder), self.reveal().fold_with(folder))\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.caller_bounds().visit_with(visitor) || self.reveal().visit_with(visitor)\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.caller_bounds().visit_with(visitor)?;\n+        self.reveal().visit_with(visitor)\n     }\n }\n "}, {"sha": "fa38bddcae2c53e1b0845339eb08527fca75ea3e", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -22,7 +22,7 @@ use std::cell::Cell;\n use std::char;\n use std::collections::BTreeMap;\n use std::fmt::{self, Write as _};\n-use std::ops::{Deref, DerefMut};\n+use std::ops::{ControlFlow, Deref, DerefMut};\n \n // `pretty` is a separate module only for organization.\n use super::*;\n@@ -1803,7 +1803,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n     {\n         struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<Symbol>);\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_> {\n-            fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+            fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<()> {\n                 if let ty::ReLateBound(_, ty::BrNamed(_, name)) = *r {\n                     self.0.insert(name);\n                 }"}, {"sha": "431225e2767517f07d50e099df48435bf4e556d7", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 72, "deletions": 56, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -14,6 +14,7 @@ use rustc_index::vec::{Idx, IndexVec};\n \n use smallvec::SmallVec;\n use std::fmt;\n+use std::ops::ControlFlow;\n use std::rc::Rc;\n use std::sync::Arc;\n \n@@ -727,8 +728,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n         *self\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        false\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<()> {\n+        ControlFlow::CONTINUE\n     }\n }\n \n@@ -737,8 +738,9 @@ impl<'tcx, T: TypeFoldable<'tcx>, U: TypeFoldable<'tcx>> TypeFoldable<'tcx> for\n         (self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.0.visit_with(visitor) || self.1.visit_with(visitor)\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.0.visit_with(visitor)?;\n+        self.1.visit_with(visitor)\n     }\n }\n \n@@ -749,8 +751,10 @@ impl<'tcx, A: TypeFoldable<'tcx>, B: TypeFoldable<'tcx>, C: TypeFoldable<'tcx>>\n         (self.0.fold_with(folder), self.1.fold_with(folder), self.2.fold_with(folder))\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.0.visit_with(visitor) || self.1.visit_with(visitor) || self.2.visit_with(visitor)\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.0.visit_with(visitor)?;\n+        self.1.visit_with(visitor)?;\n+        self.2.visit_with(visitor)\n     }\n }\n \n@@ -773,7 +777,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n         Rc::new((**self).fold_with(folder))\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         (**self).visit_with(visitor)\n     }\n }\n@@ -783,7 +787,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n         Arc::new((**self).fold_with(folder))\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         (**self).visit_with(visitor)\n     }\n }\n@@ -794,7 +798,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n         box content\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         (**self).visit_with(visitor)\n     }\n }\n@@ -804,8 +808,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n     }\n }\n \n@@ -814,8 +818,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n         self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>().into_boxed_slice()\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n     }\n }\n \n@@ -828,11 +832,11 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n         folder.fold_binder(self)\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         self.as_ref().skip_binder().visit_with(visitor)\n     }\n \n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         visitor.visit_binder(self)\n     }\n }\n@@ -842,8 +846,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>>\n         fold_list(*self, folder, |tcx, v| tcx.intern_existential_predicates(v))\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|p| p.visit_with(visitor))\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.iter().try_for_each(|p| p.visit_with(visitor))\n     }\n }\n \n@@ -852,8 +856,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n         fold_list(*self, folder, |tcx, v| tcx.intern_type_list(v))\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n     }\n }\n \n@@ -862,8 +866,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n         fold_list(*self, folder, |tcx, v| tcx.intern_projs(v))\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n     }\n }\n \n@@ -888,20 +892,24 @@ impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n         }\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         use crate::ty::InstanceDef::*;\n-        self.substs.visit_with(visitor)\n-            || match self.def {\n-                Item(def) => def.visit_with(visitor),\n-                VtableShim(did) | ReifyShim(did) | Intrinsic(did) | Virtual(did, _) => {\n-                    did.visit_with(visitor)\n-                }\n-                FnPtrShim(did, ty) | CloneShim(did, ty) => {\n-                    did.visit_with(visitor) || ty.visit_with(visitor)\n-                }\n-                DropGlue(did, ty) => did.visit_with(visitor) || ty.visit_with(visitor),\n-                ClosureOnceShim { call_once } => call_once.visit_with(visitor),\n+        self.substs.visit_with(visitor)?;\n+        match self.def {\n+            Item(def) => def.visit_with(visitor),\n+            VtableShim(did) | ReifyShim(did) | Intrinsic(did) | Virtual(did, _) => {\n+                did.visit_with(visitor)\n+            }\n+            FnPtrShim(did, ty) | CloneShim(did, ty) => {\n+                did.visit_with(visitor)?;\n+                ty.visit_with(visitor)\n+            }\n+            DropGlue(did, ty) => {\n+                did.visit_with(visitor)?;\n+                ty.visit_with(visitor)\n             }\n+            ClosureOnceShim { call_once } => call_once.visit_with(visitor),\n+        }\n     }\n }\n \n@@ -910,7 +918,7 @@ impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n         Self { instance: self.instance.fold_with(folder), promoted: self.promoted }\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         self.instance.visit_with(visitor)\n     }\n }\n@@ -959,19 +967,26 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n         folder.fold_ty(*self)\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         match self.kind() {\n             ty::RawPtr(ref tm) => tm.visit_with(visitor),\n-            ty::Array(typ, sz) => typ.visit_with(visitor) || sz.visit_with(visitor),\n+            ty::Array(typ, sz) => {\n+                typ.visit_with(visitor)?;\n+                sz.visit_with(visitor)\n+            }\n             ty::Slice(typ) => typ.visit_with(visitor),\n             ty::Adt(_, substs) => substs.visit_with(visitor),\n             ty::Dynamic(ref trait_ty, ref reg) => {\n-                trait_ty.visit_with(visitor) || reg.visit_with(visitor)\n+                trait_ty.visit_with(visitor)?;\n+                reg.visit_with(visitor)\n             }\n             ty::Tuple(ts) => ts.visit_with(visitor),\n             ty::FnDef(_, substs) => substs.visit_with(visitor),\n             ty::FnPtr(ref f) => f.visit_with(visitor),\n-            ty::Ref(r, ty, _) => r.visit_with(visitor) || ty.visit_with(visitor),\n+            ty::Ref(r, ty, _) => {\n+                r.visit_with(visitor)?;\n+                ty.visit_with(visitor)\n+            }\n             ty::Generator(_did, ref substs, _) => substs.visit_with(visitor),\n             ty::GeneratorWitness(ref types) => types.visit_with(visitor),\n             ty::Closure(_did, ref substs) => substs.visit_with(visitor),\n@@ -990,11 +1005,11 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             | ty::Placeholder(..)\n             | ty::Param(..)\n             | ty::Never\n-            | ty::Foreign(..) => false,\n+            | ty::Foreign(..) => ControlFlow::CONTINUE,\n         }\n     }\n \n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         visitor.visit_ty(self)\n     }\n }\n@@ -1008,11 +1023,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n         folder.fold_region(*self)\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        false\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<()> {\n+        ControlFlow::CONTINUE\n     }\n \n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         visitor.visit_region(*self)\n     }\n }\n@@ -1023,11 +1038,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n         folder.tcx().reuse_or_mk_predicate(*self, new)\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         ty::PredicateKind::super_visit_with(&self.inner.kind, visitor)\n     }\n \n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         visitor.visit_predicate(*self)\n     }\n \n@@ -1045,8 +1060,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n         fold_list(*self, folder, |tcx, v| tcx.intern_predicates(v))\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|p| p.visit_with(visitor))\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.iter().try_for_each(|p| p.visit_with(visitor))\n     }\n }\n \n@@ -1055,8 +1070,8 @@ impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T>\n         self.iter().map(|x| x.fold_with(folder)).collect()\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n     }\n }\n \n@@ -1075,11 +1090,12 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n         folder.fold_const(*self)\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.ty.visit_with(visitor) || self.val.visit_with(visitor)\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.ty.visit_with(visitor)?;\n+        self.val.visit_with(visitor)\n     }\n \n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         visitor.visit_const(self)\n     }\n }\n@@ -1099,15 +1115,15 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n         }\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         match *self {\n             ty::ConstKind::Infer(ic) => ic.visit_with(visitor),\n             ty::ConstKind::Param(p) => p.visit_with(visitor),\n             ty::ConstKind::Unevaluated(_, substs, _) => substs.visit_with(visitor),\n             ty::ConstKind::Value(_)\n             | ty::ConstKind::Bound(..)\n             | ty::ConstKind::Placeholder(_)\n-            | ty::ConstKind::Error(_) => false,\n+            | ty::ConstKind::Error(_) => ControlFlow::CONTINUE,\n         }\n     }\n }\n@@ -1117,8 +1133,8 @@ impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n         *self\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        false\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<()> {\n+        ControlFlow::CONTINUE\n     }\n }\n "}, {"sha": "07f775cf8b1e528cc1597a9b7679d3f7a3073d8a", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -17,6 +17,7 @@ use std::fmt;\n use std::marker::PhantomData;\n use std::mem;\n use std::num::NonZeroUsize;\n+use std::ops::ControlFlow;\n \n /// An entity in the Rust type system, which can be one of\n /// several kinds (types, lifetimes, and consts).\n@@ -159,7 +160,7 @@ impl<'tcx> TypeFoldable<'tcx> for GenericArg<'tcx> {\n         }\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n         match self.unpack() {\n             GenericArgKind::Lifetime(lt) => lt.visit_with(visitor),\n             GenericArgKind::Type(ty) => ty.visit_with(visitor),\n@@ -391,8 +392,8 @@ impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n         }\n     }\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<()> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n     }\n }\n "}, {"sha": "fce5553c99314dfc7f2f87e11512d0677369b259", "filename": "compiler/rustc_mir/src/interpret/util.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -1,6 +1,7 @@\n use rustc_middle::mir::interpret::InterpResult;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use std::convert::TryInto;\n+use std::ops::ControlFlow;\n \n /// Returns `true` if a used generic parameter requires substitution.\n crate fn ensure_monomorphic_enough<'tcx, T>(tcx: TyCtxt<'tcx>, ty: T) -> InterpResult<'tcx>\n@@ -17,24 +18,24 @@ where\n     };\n \n     impl<'tcx> TypeVisitor<'tcx> for UsedParamsNeedSubstVisitor<'tcx> {\n-        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<()> {\n             if !c.needs_subst() {\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n \n             match c.val {\n-                ty::ConstKind::Param(..) => true,\n+                ty::ConstKind::Param(..) => ControlFlow::BREAK,\n                 _ => c.super_visit_with(self),\n             }\n         }\n \n-        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<()> {\n             if !ty.needs_subst() {\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n \n             match *ty.kind() {\n-                ty::Param(_) => true,\n+                ty::Param(_) => ControlFlow::BREAK,\n                 ty::Closure(def_id, substs)\n                 | ty::Generator(def_id, substs, ..)\n                 | ty::FnDef(def_id, substs) => {\n@@ -50,11 +51,7 @@ where\n                         match (is_used, subst.needs_subst()) {\n                             // Just in case there are closures or generators within this subst,\n                             // recurse.\n-                            (true, true) if subst.super_visit_with(self) => {\n-                                // Only return when we find a parameter so the remaining substs\n-                                // are not skipped.\n-                                return true;\n-                            }\n+                            (true, true) => return subst.super_visit_with(self),\n                             // Confirm that polymorphization replaced the parameter with\n                             // `ty::Param`/`ty::ConstKind::Param`.\n                             (false, true) if cfg!(debug_assertions) => match subst.unpack() {\n@@ -69,15 +66,15 @@ where\n                             _ => {}\n                         }\n                     }\n-                    false\n+                    ControlFlow::CONTINUE\n                 }\n                 _ => ty.super_visit_with(self),\n             }\n         }\n     }\n \n     let mut vis = UsedParamsNeedSubstVisitor { tcx };\n-    if ty.visit_with(&mut vis) {\n+    if ty.visit_with(&mut vis).is_break() {\n         throw_inval!(TooGeneric);\n     } else {\n         Ok(())"}, {"sha": "2ed115b12971c38b998665b027aaa54977f24022", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -27,6 +27,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(option_expect_none)]\n #![feature(or_patterns)]\n #![feature(once_cell)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "c2ebc954a22c053f7eb44a6aa5ece71f43891d07", "filename": "compiler/rustc_mir/src/monomorphize/polymorphize.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::ty::{\n };\n use rustc_span::symbol::sym;\n use std::convert::TryInto;\n+use std::ops::ControlFlow;\n \n /// Provide implementations of queries relating to polymorphization analysis.\n pub fn provide(providers: &mut Providers) {\n@@ -138,7 +139,7 @@ fn mark_used_by_predicates<'tcx>(\n             // predicate is used.\n             let any_param_used = {\n                 let mut vis = HasUsedGenericParams { unused_parameters };\n-                predicate.visit_with(&mut vis)\n+                predicate.visit_with(&mut vis).is_break()\n             };\n \n             if any_param_used {\n@@ -249,17 +250,17 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n-    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> bool {\n+    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<()> {\n         debug!(\"visit_const: c={:?}\", c);\n         if !c.has_param_types_or_consts() {\n-            return false;\n+            return ControlFlow::CONTINUE;\n         }\n \n         match c.val {\n             ty::ConstKind::Param(param) => {\n                 debug!(\"visit_const: param={:?}\", param);\n                 self.unused_parameters.clear(param.index);\n-                false\n+                ControlFlow::CONTINUE\n             }\n             ty::ConstKind::Unevaluated(def, _, Some(p))\n                 // Avoid considering `T` unused when constants are of the form:\n@@ -270,41 +271,41 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n                 // the generic parameters, instead, traverse the promoted MIR.\n                 let promoted = self.tcx.promoted_mir(def.did);\n                 self.visit_body(&promoted[p]);\n-                false\n+                ControlFlow::CONTINUE\n             }\n             ty::ConstKind::Unevaluated(def, unevaluated_substs, None)\n                 if self.tcx.def_kind(def.did) == DefKind::AnonConst =>\n             {\n                 self.visit_child_body(def.did, unevaluated_substs);\n-                false\n+                ControlFlow::CONTINUE\n             }\n             _ => c.super_visit_with(self),\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<()> {\n         debug!(\"visit_ty: ty={:?}\", ty);\n         if !ty.has_param_types_or_consts() {\n-            return false;\n+            return ControlFlow::CONTINUE;\n         }\n \n         match *ty.kind() {\n             ty::Closure(def_id, substs) | ty::Generator(def_id, substs, ..) => {\n                 debug!(\"visit_ty: def_id={:?}\", def_id);\n                 // Avoid cycle errors with generators.\n                 if def_id == self.def_id {\n-                    return false;\n+                    return ControlFlow::CONTINUE;\n                 }\n \n                 // Consider any generic parameters used by any closures/generators as used in the\n                 // parent.\n                 self.visit_child_body(def_id, substs);\n-                false\n+                ControlFlow::CONTINUE\n             }\n             ty::Param(param) => {\n                 debug!(\"visit_ty: param={:?}\", param);\n                 self.unused_parameters.clear(param.index);\n-                false\n+                ControlFlow::CONTINUE\n             }\n             _ => ty.super_visit_with(self),\n         }\n@@ -317,28 +318,38 @@ struct HasUsedGenericParams<'a> {\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a> {\n-    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> bool {\n+    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<()> {\n         debug!(\"visit_const: c={:?}\", c);\n         if !c.has_param_types_or_consts() {\n-            return false;\n+            return ControlFlow::CONTINUE;\n         }\n \n         match c.val {\n             ty::ConstKind::Param(param) => {\n-                !self.unused_parameters.contains(param.index).unwrap_or(false)\n+                if self.unused_parameters.contains(param.index).unwrap_or(false) {\n+                    ControlFlow::CONTINUE\n+                } else {\n+                    ControlFlow::BREAK\n+                }\n             }\n             _ => c.super_visit_with(self),\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<()> {\n         debug!(\"visit_ty: ty={:?}\", ty);\n         if !ty.has_param_types_or_consts() {\n-            return false;\n+            return ControlFlow::CONTINUE;\n         }\n \n         match ty.kind() {\n-            ty::Param(param) => !self.unused_parameters.contains(param.index).unwrap_or(false),\n+            ty::Param(param) => {\n+                if self.unused_parameters.contains(param.index).unwrap_or(false) {\n+                    ControlFlow::CONTINUE\n+                } else {\n+                    ControlFlow::BREAK\n+                }\n+            }\n             _ => ty.super_visit_with(self),\n         }\n     }"}, {"sha": "5700492d6bbc78e5ab27f1b9055c076e429be48a", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -19,6 +19,7 @@ use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_target::abi::Size;\n+use std::ops::ControlFlow;\n \n const INDENT: &str = \"    \";\n /// Alignment for lining up comments following MIR statements\n@@ -639,7 +640,7 @@ pub fn write_allocations<'tcx>(\n     }\n     struct CollectAllocIds(BTreeSet<AllocId>);\n     impl<'tcx> TypeVisitor<'tcx> for CollectAllocIds {\n-        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<()> {\n             if let ty::ConstKind::Value(val) = c.val {\n                 self.0.extend(alloc_ids_from_const(val));\n             }"}, {"sha": "4c0941120a6fc6c50dd0fcfdb6e84fc498722f0d", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 87, "deletions": 63, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -2,6 +2,8 @@\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]\n+#![feature(control_flow_enum)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n \n use rustc_attr as attr;\n@@ -26,6 +28,7 @@ use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n \n use std::marker::PhantomData;\n+use std::ops::ControlFlow;\n use std::{cmp, fmt, mem};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -48,7 +51,12 @@ trait DefIdVisitor<'tcx> {\n     fn skip_assoc_tys(&self) -> bool {\n         false\n     }\n-    fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool;\n+    fn visit_def_id(\n+        &mut self,\n+        def_id: DefId,\n+        kind: &str,\n+        descr: &dyn fmt::Display,\n+    ) -> ControlFlow<()>;\n \n     /// Not overridden, but used to actually visit types and traits.\n     fn skeleton(&mut self) -> DefIdVisitorSkeleton<'_, 'tcx, Self> {\n@@ -58,13 +66,13 @@ trait DefIdVisitor<'tcx> {\n             dummy: Default::default(),\n         }\n     }\n-    fn visit(&mut self, ty_fragment: impl TypeFoldable<'tcx>) -> bool {\n+    fn visit(&mut self, ty_fragment: impl TypeFoldable<'tcx>) -> ControlFlow<()> {\n         ty_fragment.visit_with(&mut self.skeleton())\n     }\n-    fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n+    fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> ControlFlow<()> {\n         self.skeleton().visit_trait(trait_ref)\n     }\n-    fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> bool {\n+    fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> ControlFlow<()> {\n         self.skeleton().visit_predicates(predicates)\n     }\n }\n@@ -79,54 +87,49 @@ impl<'tcx, V> DefIdVisitorSkeleton<'_, 'tcx, V>\n where\n     V: DefIdVisitor<'tcx> + ?Sized,\n {\n-    fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n+    fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> ControlFlow<()> {\n         let TraitRef { def_id, substs } = trait_ref;\n-        self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref.print_only_trait_path())\n-            || (!self.def_id_visitor.shallow() && substs.visit_with(self))\n+        self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref.print_only_trait_path())?;\n+        if self.def_id_visitor.shallow() { ControlFlow::CONTINUE } else { substs.visit_with(self) }\n     }\n \n-    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<()> {\n         match predicate.skip_binders() {\n             ty::PredicateAtom::Trait(ty::TraitPredicate { trait_ref }, _) => {\n                 self.visit_trait(trait_ref)\n             }\n             ty::PredicateAtom::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n-                ty.visit_with(self)\n-                    || self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx()))\n+                ty.visit_with(self)?;\n+                self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx()))\n             }\n             ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n                 ty.visit_with(self)\n             }\n-            ty::PredicateAtom::RegionOutlives(..) => false,\n+            ty::PredicateAtom::RegionOutlives(..) => ControlFlow::CONTINUE,\n             ty::PredicateAtom::ConstEvaluatable(..)\n                 if self.def_id_visitor.tcx().features().const_evaluatable_checked =>\n             {\n                 // FIXME(const_evaluatable_checked): If the constant used here depends on a\n                 // private function we may have to do something here...\n                 //\n                 // For now, let's just pretend that everything is fine.\n-                false\n+                ControlFlow::CONTINUE\n             }\n             _ => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }\n \n-    fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> bool {\n+    fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> ControlFlow<()> {\n         let ty::GenericPredicates { parent: _, predicates } = predicates;\n-        for &(predicate, _span) in predicates {\n-            if self.visit_predicate(predicate) {\n-                return true;\n-            }\n-        }\n-        false\n+        predicates.iter().try_for_each(|&(predicate, _span)| self.visit_predicate(predicate))\n     }\n }\n \n impl<'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'tcx, V>\n where\n     V: DefIdVisitor<'tcx> + ?Sized,\n {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<()> {\n         let tcx = self.def_id_visitor.tcx();\n         // InternalSubsts are not visited here because they are visited below in `super_visit_with`.\n         match *ty.kind() {\n@@ -135,29 +138,23 @@ where\n             | ty::FnDef(def_id, ..)\n             | ty::Closure(def_id, ..)\n             | ty::Generator(def_id, ..) => {\n-                if self.def_id_visitor.visit_def_id(def_id, \"type\", &ty) {\n-                    return true;\n-                }\n+                self.def_id_visitor.visit_def_id(def_id, \"type\", &ty)?;\n                 if self.def_id_visitor.shallow() {\n-                    return false;\n+                    return ControlFlow::CONTINUE;\n                 }\n                 // Default type visitor doesn't visit signatures of fn types.\n                 // Something like `fn() -> Priv {my_func}` is considered a private type even if\n                 // `my_func` is public, so we need to visit signatures.\n                 if let ty::FnDef(..) = ty.kind() {\n-                    if tcx.fn_sig(def_id).visit_with(self) {\n-                        return true;\n-                    }\n+                    tcx.fn_sig(def_id).visit_with(self)?;\n                 }\n                 // Inherent static methods don't have self type in substs.\n                 // Something like `fn() {my_method}` type of the method\n                 // `impl Pub<Priv> { pub fn my_method() {} }` is considered a private type,\n                 // so we need to visit the self type additionally.\n                 if let Some(assoc_item) = tcx.opt_associated_item(def_id) {\n                     if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n-                        if tcx.type_of(impl_def_id).visit_with(self) {\n-                            return true;\n-                        }\n+                        tcx.type_of(impl_def_id).visit_with(self)?;\n                     }\n                 }\n             }\n@@ -168,7 +165,7 @@ where\n                     // as visible/reachable even if both `Type` and `Trait` are private.\n                     // Ideally, associated types should be substituted in the same way as\n                     // free type aliases, but this isn't done yet.\n-                    return false;\n+                    return ControlFlow::CONTINUE;\n                 }\n                 // This will also visit substs if necessary, so we don't need to recurse.\n                 return self.visit_trait(proj.trait_ref(tcx));\n@@ -185,9 +182,7 @@ where\n                         }\n                     };\n                     let ty::ExistentialTraitRef { def_id, substs: _ } = trait_ref;\n-                    if self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref) {\n-                        return true;\n-                    }\n+                    self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref)?;\n                 }\n             }\n             ty::Opaque(def_id, ..) => {\n@@ -200,12 +195,10 @@ where\n                     // through the trait list (default type visitor doesn't visit those traits).\n                     // All traits in the list are considered the \"primary\" part of the type\n                     // and are visited by shallow visitors.\n-                    if self.visit_predicates(ty::GenericPredicates {\n+                    self.visit_predicates(ty::GenericPredicates {\n                         parent: None,\n                         predicates: tcx.explicit_item_bounds(def_id),\n-                    }) {\n-                        return true;\n-                    }\n+                    })?;\n                 }\n             }\n             // These types don't have their own def-ids (but may have subcomponents\n@@ -231,7 +224,11 @@ where\n             }\n         }\n \n-        !self.def_id_visitor.shallow() && ty.super_visit_with(self)\n+        if self.def_id_visitor.shallow() {\n+            ControlFlow::CONTINUE\n+        } else {\n+            ty.super_visit_with(self)\n+        }\n     }\n }\n \n@@ -281,9 +278,14 @@ impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'tcx> for FindMin<'a, 'tcx, VL>\n     fn skip_assoc_tys(&self) -> bool {\n         true\n     }\n-    fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n+    fn visit_def_id(\n+        &mut self,\n+        def_id: DefId,\n+        _kind: &str,\n+        _descr: &dyn fmt::Display,\n+    ) -> ControlFlow<()> {\n         self.min = VL::new_min(self, def_id);\n-        false\n+        ControlFlow::CONTINUE\n     }\n }\n \n@@ -895,7 +897,12 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.ev.tcx\n     }\n-    fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n+    fn visit_def_id(\n+        &mut self,\n+        def_id: DefId,\n+        _kind: &str,\n+        _descr: &dyn fmt::Display,\n+    ) -> ControlFlow<()> {\n         if let Some(def_id) = def_id.as_local() {\n             if let (ty::Visibility::Public, _) | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n                 (self.tcx().visibility(def_id.to_def_id()), self.access_level)\n@@ -904,7 +911,7 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n                 self.ev.update(hir_id, self.access_level);\n             }\n         }\n-        false\n+        ControlFlow::CONTINUE\n     }\n }\n \n@@ -1072,17 +1079,14 @@ impl<'tcx> TypePrivacyVisitor<'tcx> {\n     fn check_expr_pat_type(&mut self, id: hir::HirId, span: Span) -> bool {\n         self.span = span;\n         let typeck_results = self.typeck_results();\n-        if self.visit(typeck_results.node_type(id)) || self.visit(typeck_results.node_substs(id)) {\n-            return true;\n-        }\n-        if let Some(adjustments) = typeck_results.adjustments().get(id) {\n-            for adjustment in adjustments {\n-                if self.visit(adjustment.target) {\n-                    return true;\n-                }\n+        let result: ControlFlow<()> = try {\n+            self.visit(typeck_results.node_type(id))?;\n+            self.visit(typeck_results.node_substs(id))?;\n+            if let Some(adjustments) = typeck_results.adjustments().get(id) {\n+                adjustments.iter().try_for_each(|adjustment| self.visit(adjustment.target))?;\n             }\n-        }\n-        false\n+        };\n+        result.is_break()\n     }\n \n     fn check_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n@@ -1124,14 +1128,14 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n         self.span = hir_ty.span;\n         if let Some(typeck_results) = self.maybe_typeck_results {\n             // Types in bodies.\n-            if self.visit(typeck_results.node_type(hir_ty.hir_id)) {\n+            if self.visit(typeck_results.node_type(hir_ty.hir_id)).is_break() {\n                 return;\n             }\n         } else {\n             // Types in signatures.\n             // FIXME: This is very ineffective. Ideally each HIR type should be converted\n             // into a semantic type only once and the result should be cached somehow.\n-            if self.visit(rustc_typeck::hir_ty_to_ty(self.tcx, hir_ty)) {\n+            if self.visit(rustc_typeck::hir_ty_to_ty(self.tcx, hir_ty)).is_break() {\n                 return;\n             }\n         }\n@@ -1153,15 +1157,17 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n             );\n \n             for (trait_predicate, _, _) in bounds.trait_bounds {\n-                if self.visit_trait(trait_predicate.skip_binder()) {\n+                if self.visit_trait(trait_predicate.skip_binder()).is_break() {\n                     return;\n                 }\n             }\n \n             for (poly_predicate, _) in bounds.projection_bounds {\n                 let tcx = self.tcx;\n-                if self.visit(poly_predicate.skip_binder().ty)\n-                    || self.visit_trait(poly_predicate.skip_binder().projection_ty.trait_ref(tcx))\n+                if self.visit(poly_predicate.skip_binder().ty).is_break()\n+                    || self\n+                        .visit_trait(poly_predicate.skip_binder().projection_ty.trait_ref(tcx))\n+                        .is_break()\n                 {\n                     return;\n                 }\n@@ -1188,7 +1194,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                 // Method calls have to be checked specially.\n                 self.span = span;\n                 if let Some(def_id) = self.typeck_results().type_dependent_def_id(expr.hir_id) {\n-                    if self.visit(self.tcx.type_of(def_id)) {\n+                    if self.visit(self.tcx.type_of(def_id)).is_break() {\n                         return;\n                     }\n                 } else {\n@@ -1288,8 +1294,17 @@ impl DefIdVisitor<'tcx> for TypePrivacyVisitor<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n-    fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n-        self.check_def_id(def_id, kind, descr)\n+    fn visit_def_id(\n+        &mut self,\n+        def_id: DefId,\n+        kind: &str,\n+        descr: &dyn fmt::Display,\n+    ) -> ControlFlow<()> {\n+        if self.check_def_id(def_id, kind, descr) {\n+            ControlFlow::BREAK\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n     }\n }\n \n@@ -1779,8 +1794,17 @@ impl DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n-    fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n-        self.check_def_id(def_id, kind, descr)\n+    fn visit_def_id(\n+        &mut self,\n+        def_id: DefId,\n+        kind: &str,\n+        descr: &dyn fmt::Display,\n+    ) -> ControlFlow<()> {\n+        if self.check_def_id(def_id, kind, descr) {\n+            ControlFlow::BREAK\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n     }\n }\n "}, {"sha": "42509cd8975828a9f269e5329cd70f1c801791a5", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -19,6 +19,7 @@\n #![feature(never_type)]\n #![feature(crate_visibility_modifier)]\n #![feature(or_patterns)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "914fa1e52c2697689e94585e5ea2deddda61cdf0", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -15,6 +15,8 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::config::nightly_options;\n use rustc_span::Span;\n \n+use std::ops::ControlFlow;\n+\n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n /// Information about the opaque types whose values we\n@@ -691,26 +693,26 @@ impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<OP>\n where\n     OP: FnMut(ty::Region<'tcx>),\n {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ControlFlow<()> {\n         t.as_ref().skip_binder().visit_with(self);\n-        false // keep visiting\n+        ControlFlow::CONTINUE\n     }\n \n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<()> {\n         match *r {\n             // ignore bound regions, keep visiting\n-            ty::ReLateBound(_, _) => false,\n+            ty::ReLateBound(_, _) => ControlFlow::CONTINUE,\n             _ => {\n                 (self.op)(r);\n-                false\n+                ControlFlow::CONTINUE\n             }\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<()> {\n         // We're only interested in types involving regions\n         if !ty.flags().intersects(ty::TypeFlags::HAS_FREE_REGIONS) {\n-            return false; // keep visiting\n+            return ControlFlow::CONTINUE;\n         }\n \n         match ty.kind() {\n@@ -745,7 +747,7 @@ where\n             }\n         }\n \n-        false\n+        ControlFlow::CONTINUE\n     }\n }\n "}, {"sha": "638a8253e7eb9481e227a914b7f405e73c61ca84", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -24,6 +24,7 @@ use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n \n use std::cmp;\n+use std::ops::ControlFlow;\n \n /// Check if a given constant can be evaluated.\n pub fn is_const_evaluatable<'cx, 'tcx>(\n@@ -86,9 +87,11 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                             failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                         }\n \n-                        false\n+                        ControlFlow::CONTINUE\n+                    }\n+                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {\n+                        ControlFlow::CONTINUE\n                     }\n-                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => false,\n                 });\n \n                 match failure_kind {\n@@ -564,29 +567,33 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n     // on `ErrorReported`.\n }\n \n-// FIXME: Use `std::ops::ControlFlow` instead of `bool` here.\n-pub fn walk_abstract_const<'tcx, F>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, mut f: F) -> bool\n+pub fn walk_abstract_const<'tcx, F>(\n+    tcx: TyCtxt<'tcx>,\n+    ct: AbstractConst<'tcx>,\n+    mut f: F,\n+) -> ControlFlow<()>\n where\n-    F: FnMut(Node<'tcx>) -> bool,\n+    F: FnMut(Node<'tcx>) -> ControlFlow<()>,\n {\n     fn recurse<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         ct: AbstractConst<'tcx>,\n-        f: &mut dyn FnMut(Node<'tcx>) -> bool,\n-    ) -> bool {\n+        f: &mut dyn FnMut(Node<'tcx>) -> ControlFlow<()>,\n+    ) -> ControlFlow<()> {\n         let root = ct.root();\n-        f(root)\n-            || match root {\n-                Node::Leaf(_) => false,\n-                Node::Binop(_, l, r) => {\n-                    recurse(tcx, ct.subtree(l), f) || recurse(tcx, ct.subtree(r), f)\n-                }\n-                Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n-                Node::FunctionCall(func, args) => {\n-                    recurse(tcx, ct.subtree(func), f)\n-                        || args.iter().any(|&arg| recurse(tcx, ct.subtree(arg), f))\n-                }\n+        f(root)?;\n+        match root {\n+            Node::Leaf(_) => ControlFlow::CONTINUE,\n+            Node::Binop(_, l, r) => {\n+                recurse(tcx, ct.subtree(l), f)?;\n+                recurse(tcx, ct.subtree(r), f)\n+            }\n+            Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n+            Node::FunctionCall(func, args) => {\n+                recurse(tcx, ct.subtree(func), f)?;\n+                args.iter().try_for_each(|&arg| recurse(tcx, ct.subtree(arg), f))\n             }\n+        }\n     }\n \n     recurse(tcx, ct, &mut f)"}, {"sha": "50efbbbe0fd766abea2ce257e72c2f996bc18dd1", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -27,6 +27,7 @@ use smallvec::SmallVec;\n \n use std::array;\n use std::iter;\n+use std::ops::ControlFlow;\n \n pub use crate::traits::{MethodViolationCode, ObjectSafetyViolation};\n \n@@ -770,9 +771,15 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n     }\n \n     impl<'tcx> TypeVisitor<'tcx> for IllegalSelfTypeVisitor<'tcx> {\n-        fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<()> {\n             match t.kind() {\n-                ty::Param(_) => t == self.tcx.types.self_param,\n+                ty::Param(_) => {\n+                    if t == self.tcx.types.self_param {\n+                        ControlFlow::BREAK\n+                    } else {\n+                        ControlFlow::CONTINUE\n+                    }\n+                }\n                 ty::Projection(ref data) => {\n                     // This is a projected type `<Foo as SomeTrait>::X`.\n \n@@ -796,7 +803,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                         self.supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n \n                     if is_supertrait_of_current_trait {\n-                        false // do not walk contained types, do not report error, do collect $200\n+                        ControlFlow::CONTINUE // do not walk contained types, do not report error, do collect $200\n                     } else {\n                         t.super_visit_with(self) // DO walk contained types, POSSIBLY reporting an error\n                     }\n@@ -805,11 +812,9 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n             }\n         }\n \n-        fn visit_const(&mut self, ct: &ty::Const<'tcx>) -> bool {\n+        fn visit_const(&mut self, ct: &ty::Const<'tcx>) -> ControlFlow<()> {\n             // First check if the type of this constant references `Self`.\n-            if self.visit_ty(ct.ty) {\n-                return true;\n-            }\n+            self.visit_ty(ct.ty)?;\n \n             // Constants can only influence object safety if they reference `Self`.\n             // This is only possible for unevaluated constants, so we walk these here.\n@@ -830,14 +835,16 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                         let leaf = leaf.subst(self.tcx, ct.substs);\n                         self.visit_const(leaf)\n                     }\n-                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => false,\n+                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n+                        ControlFlow::CONTINUE\n+                    }\n                 })\n             } else {\n-                false\n+                ControlFlow::CONTINUE\n             }\n         }\n \n-        fn visit_predicate(&mut self, pred: ty::Predicate<'tcx>) -> bool {\n+        fn visit_predicate(&mut self, pred: ty::Predicate<'tcx>) -> ControlFlow<()> {\n             if let ty::PredicateAtom::ConstEvaluatable(def, substs) = pred.skip_binders() {\n                 // FIXME(const_evaluatable_checked): We should probably deduplicate the logic for\n                 // `AbstractConst`s here, it might make sense to change `ConstEvaluatable` to\n@@ -849,18 +856,22 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                             let leaf = leaf.subst(self.tcx, ct.substs);\n                             self.visit_const(leaf)\n                         }\n-                        Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => false,\n+                        Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n+                            ControlFlow::CONTINUE\n+                        }\n                     })\n                 } else {\n-                    false\n+                    ControlFlow::CONTINUE\n                 }\n             } else {\n                 pred.super_visit_with(self)\n             }\n         }\n     }\n \n-    value.visit_with(&mut IllegalSelfTypeVisitor { tcx, trait_def_id, supertraits: None })\n+    value\n+        .visit_with(&mut IllegalSelfTypeVisitor { tcx, trait_def_id, supertraits: None })\n+        .is_break()\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "ce0d3ef8a6a58f312cc55819fa3414b09b21e27d", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::Span;\n+use std::ops::ControlFlow;\n \n #[derive(Debug)]\n pub enum NonStructuralMatchTy<'tcx> {\n@@ -134,38 +135,38 @@ impl Search<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<()> {\n         debug!(\"Search visiting ty: {:?}\", ty);\n \n         let (adt_def, substs) = match *ty.kind() {\n             ty::Adt(adt_def, substs) => (adt_def, substs),\n             ty::Param(_) => {\n                 self.found = Some(NonStructuralMatchTy::Param);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::Dynamic(..) => {\n                 self.found = Some(NonStructuralMatchTy::Dynamic);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::Foreign(_) => {\n                 self.found = Some(NonStructuralMatchTy::Foreign);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::Opaque(..) => {\n                 self.found = Some(NonStructuralMatchTy::Opaque);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::Projection(..) => {\n                 self.found = Some(NonStructuralMatchTy::Projection);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::Generator(..) | ty::GeneratorWitness(..) => {\n                 self.found = Some(NonStructuralMatchTy::Generator);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::Closure(..) => {\n                 self.found = Some(NonStructuralMatchTy::Closure);\n-                return true; // Stop visiting.\n+                return ControlFlow::BREAK;\n             }\n             ty::RawPtr(..) => {\n                 // structural-match ignores substructure of\n@@ -182,39 +183,31 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n                 // Even though `NonStructural` does not implement `PartialEq`,\n                 // structural equality on `T` does not recur into the raw\n                 // pointer. Therefore, one can still use `C` in a pattern.\n-\n-                // (But still tell the caller to continue search.)\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n             ty::FnDef(..) | ty::FnPtr(..) => {\n                 // Types of formals and return in `fn(_) -> _` are also irrelevant;\n                 // so we do not recur into them via `super_visit_with`\n-                //\n-                // (But still tell the caller to continue search.)\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n             ty::Array(_, n)\n                 if { n.try_eval_usize(self.tcx(), ty::ParamEnv::reveal_all()) == Some(0) } =>\n             {\n                 // rust-lang/rust#62336: ignore type of contents\n                 // for empty array.\n-                //\n-                // (But still tell the caller to continue search.)\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => {\n                 // These primitive types are always structural match.\n                 //\n                 // `Never` is kind of special here, but as it is not inhabitable, this should be fine.\n-                //\n-                // (But still tell the caller to continue search.)\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n \n             ty::Array(..) | ty::Slice(_) | ty::Ref(..) | ty::Tuple(..) => {\n                 // First check all contained types and then tell the caller to continue searching.\n                 ty.super_visit_with(self);\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n             ty::Infer(_) | ty::Placeholder(_) | ty::Bound(..) => {\n                 bug!(\"unexpected type during structural-match checking: {:?}\", ty);\n@@ -223,22 +216,19 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n                 self.tcx().sess.delay_span_bug(self.span, \"ty::Error in structural-match check\");\n                 // We still want to check other types after encountering an error,\n                 // as this may still emit relevant errors.\n-                //\n-                // So we continue searching here.\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n         };\n \n         if !self.seen.insert(adt_def.did) {\n             debug!(\"Search already seen adt_def: {:?}\", adt_def);\n-            // Let caller continue its search.\n-            return false;\n+            return ControlFlow::CONTINUE;\n         }\n \n         if !self.type_marked_structural(ty) {\n             debug!(\"Search found ty: {:?}\", ty);\n             self.found = Some(NonStructuralMatchTy::Adt(&adt_def));\n-            return true; // Halt visiting!\n+            return ControlFlow::BREAK;\n         }\n \n         // structural-match does not care about the\n@@ -258,16 +248,16 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n             let ty = self.tcx().normalize_erasing_regions(ty::ParamEnv::empty(), field_ty);\n             debug!(\"structural-match ADT: field_ty={:?}, ty={:?}\", field_ty, ty);\n \n-            if ty.visit_with(self) {\n+            if ty.visit_with(self).is_break() {\n                 // found an ADT without structural-match; halt visiting!\n                 assert!(self.found.is_some());\n-                return true;\n+                return ControlFlow::BREAK;\n             }\n         }\n \n         // Even though we do not want to recur on substs, we do\n         // want our caller to continue its own search.\n-        false\n+        ControlFlow::CONTINUE\n     }\n }\n "}, {"sha": "01c4dd1248772c7625b04be3943fd2b329289ede", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -42,6 +42,7 @@ use rustc_span::def_id::DefId;\n use chalk_ir::{FnSig, ForeignDefId};\n use rustc_hir::Unsafety;\n use std::collections::btree_map::{BTreeMap, Entry};\n+use std::ops::ControlFlow;\n \n /// Essentially an `Into` with a `&RustInterner` parameter\n crate trait LowerInto<'tcx, T> {\n@@ -897,14 +898,14 @@ impl<'tcx> BoundVarsCollector<'tcx> {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<()> {\n         self.binder_index.shift_in(1);\n         let result = t.super_visit_with(self);\n         self.binder_index.shift_out(1);\n         result\n     }\n \n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<()> {\n         match *t.kind() {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n                 match self.parameters.entry(bound_ty.var.as_u32()) {\n@@ -924,7 +925,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: Region<'tcx>) -> ControlFlow<()> {\n         match r {\n             ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n                 ty::BoundRegion::BrNamed(def_id, _name) => {\n@@ -1114,7 +1115,7 @@ impl PlaceholdersCollector {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<()> {\n         match t.kind() {\n             ty::Placeholder(p) if p.universe == self.universe_index => {\n                 self.next_ty_placeholder = self.next_ty_placeholder.max(p.name.as_usize() + 1);\n@@ -1126,7 +1127,7 @@ impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: Region<'tcx>) -> ControlFlow<()> {\n         match r {\n             ty::RePlaceholder(p) if p.universe == self.universe_index => {\n                 if let ty::BoundRegion::BrAnon(anon) = p.name {"}, {"sha": "7b688cd3e2199375d8e71309c0e282b08713597e", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -4,6 +4,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "70d94ef869d0582b51e902c8d9adc8e704accb7b", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -24,6 +24,8 @@ use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n+use std::ops::ControlFlow;\n+\n pub fn check_wf_new(tcx: TyCtxt<'_>) {\n     let visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n     tcx.hir().krate().par_visit_all_item_likes(&visit);\n@@ -448,30 +450,34 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n     };\n \n     impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n-        fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<()> {\n             debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n-            if t != self.opaque_identity_ty && t.super_visit_with(self) {\n+            if t != self.opaque_identity_ty && t.super_visit_with(self).is_break() {\n                 self.ty = Some(t);\n-                return true;\n+                return ControlFlow::BREAK;\n             }\n-            false\n+            ControlFlow::CONTINUE\n         }\n \n-        fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<()> {\n             debug!(\"check_opaque_for_inheriting_lifetimes: (visit_region) r={:?}\", r);\n             if let RegionKind::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = r {\n-                return *index < self.generics.parent_count as u32;\n+                if *index < self.generics.parent_count as u32 {\n+                    return ControlFlow::BREAK;\n+                } else {\n+                    return ControlFlow::CONTINUE;\n+                }\n             }\n \n             r.super_visit_with(self)\n         }\n \n-        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<()> {\n             if let ty::ConstKind::Unevaluated(..) = c.val {\n                 // FIXME(#72219) We currenctly don't detect lifetimes within substs\n                 // which would violate this check. Even though the particular substitution is not used\n                 // within the const, this should still be fixed.\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n             c.super_visit_with(self)\n         }\n@@ -493,7 +499,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n         let prohibit_opaque = tcx\n             .explicit_item_bounds(def_id)\n             .iter()\n-            .any(|(predicate, _)| predicate.visit_with(&mut visitor));\n+            .any(|(predicate, _)| predicate.visit_with(&mut visitor).is_break());\n         debug!(\n             \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor={:?}\",\n             prohibit_opaque, visitor\n@@ -1449,11 +1455,11 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n             {\n                 struct VisitTypes(Vec<DefId>);\n                 impl<'tcx> ty::fold::TypeVisitor<'tcx> for VisitTypes {\n-                    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<()> {\n                         match *t.kind() {\n                             ty::Opaque(def, _) => {\n                                 self.0.push(def);\n-                                false\n+                                ControlFlow::CONTINUE\n                             }\n                             _ => t.super_visit_with(self),\n                         }"}, {"sha": "247b525672603e47866e4e97fda691cb942f8206", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -19,6 +19,8 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n+use std::ops::ControlFlow;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a `a <op>= b`\n     pub fn check_binop_assign(\n@@ -981,7 +983,7 @@ fn suggest_constraining_param(\n struct TypeParamVisitor<'tcx>(Vec<Ty<'tcx>>);\n \n impl<'tcx> TypeVisitor<'tcx> for TypeParamVisitor<'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<()> {\n         if let ty::Param(_) = ty.kind() {\n             self.0.push(ty);\n         }"}, {"sha": "1e27357ce4414001f03db2b396dc2bbfa36c34a6", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -24,6 +24,8 @@ use rustc_trait_selection::opaque_types::may_define_opaque_type;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n+use std::ops::ControlFlow;\n+\n /// Helper type of a temporary returned by `.for_item(...)`.\n /// This is necessary because we can't write the following bound:\n ///\n@@ -798,26 +800,26 @@ fn check_where_clauses<'tcx, 'fcx>(\n                 params: FxHashSet<u32>,\n             }\n             impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n-                fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<()> {\n                     if let ty::Param(param) = t.kind() {\n                         self.params.insert(param.index);\n                     }\n                     t.super_visit_with(self)\n                 }\n \n-                fn visit_region(&mut self, _: ty::Region<'tcx>) -> bool {\n-                    true\n+                fn visit_region(&mut self, _: ty::Region<'tcx>) -> ControlFlow<()> {\n+                    ControlFlow::BREAK\n                 }\n \n-                fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+                fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<()> {\n                     if let ty::ConstKind::Param(param) = c.val {\n                         self.params.insert(param.index);\n                     }\n                     c.super_visit_with(self)\n                 }\n             }\n             let mut param_count = CountParams::default();\n-            let has_region = pred.visit_with(&mut param_count);\n+            let has_region = pred.visit_with(&mut param_count).is_break();\n             let substituted_pred = pred.subst(fcx.tcx, substs);\n             // Don't check non-defaulted params, dependent defaults (including lifetimes)\n             // or preds with multiple params."}, {"sha": "f014ea3d5a98b83a3c16c117db3345610d4cb8a4", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -50,6 +50,8 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n \n+use std::ops::ControlFlow;\n+\n mod item_bounds;\n mod type_of;\n \n@@ -2060,14 +2062,14 @@ fn const_evaluatable_predicates_of<'tcx>(\n             }\n \n             impl<'a, 'tcx> TypeVisitor<'tcx> for TyAliasVisitor<'a, 'tcx> {\n-                fn visit_const(&mut self, ct: &'tcx Const<'tcx>) -> bool {\n+                fn visit_const(&mut self, ct: &'tcx Const<'tcx>) -> ControlFlow<()> {\n                     if let ty::ConstKind::Unevaluated(def, substs, None) = ct.val {\n                         self.preds.insert((\n                             ty::PredicateAtom::ConstEvaluatable(def, substs).to_predicate(self.tcx),\n                             self.span,\n                         ));\n                     }\n-                    false\n+                    ControlFlow::CONTINUE\n                 }\n             }\n "}, {"sha": "bae5bde70026f365b82692e4f30c3a689a8b0854", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -2,6 +2,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::source_map::Span;\n+use std::ops::ControlFlow;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Parameter(pub u32);\n@@ -56,11 +57,11 @@ struct ParameterCollector {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<()> {\n         match *t.kind() {\n             ty::Projection(..) | ty::Opaque(..) if !self.include_nonconstraining => {\n                 // projections are not injective\n-                return false;\n+                return ControlFlow::CONTINUE;\n             }\n             ty::Param(data) => {\n                 self.parameters.push(Parameter::from(data));\n@@ -71,14 +72,14 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<()> {\n         if let ty::ReEarlyBound(data) = *r {\n             self.parameters.push(Parameter::from(data));\n         }\n-        false\n+        ControlFlow::CONTINUE\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<()> {\n         match c.val {\n             ty::ConstKind::Unevaluated(..) if !self.include_nonconstraining => {\n                 // Constant expressions are not injective"}, {"sha": "30904091c1b3fd2f3d1f929901231bcb67b47ea4", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -66,6 +66,7 @@ This API is completely unstable and subject to change.\n #![feature(try_blocks)]\n #![feature(never_type)]\n #![feature(slice_partition_dedup)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "e97fa543a093d286c19ff53e25bb04c98340b3fe", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -11,6 +11,7 @@\n #![feature(or_patterns)]\n #![feature(rustc_private)]\n #![feature(stmt_expr_attributes)]\n+#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![allow(clippy::missing_docs_in_private_items, clippy::must_use_candidate)]"}, {"sha": "ae3b0a037542a5bdd19417b1f83fa3f1e942f034", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d033dee3eff6e30c15c4c51958e219134dcc7bc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d033dee3eff6e30c15c4c51958e219134dcc7bc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=0d033dee3eff6e30c15c4c51958e219134dcc7bc", "patch": "@@ -18,6 +18,7 @@ use rustc_mir::dataflow::{Analysis, AnalysisDomain, GenKill, GenKillAnalysis, Re\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{BytePos, Span};\n use std::convert::TryFrom;\n+use std::ops::ControlFlow;\n \n macro_rules! unwrap_or_continue {\n     ($x:expr) => {\n@@ -517,7 +518,7 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n                 self.possible_borrower.add(borrowed.local, lhs);\n             },\n             other => {\n-                if !ContainsRegion.visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty) {\n+                if ContainsRegion.visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty).is_continue() {\n                     return;\n                 }\n                 rvalue_locals(other, |rhs| {\n@@ -539,7 +540,7 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n             // If the call returns something with lifetimes,\n             // let's conservatively assume the returned value contains lifetime of all the arguments.\n             // For example, given `let y: Foo<'a> = foo(x)`, `y` is considered to be a possible borrower of `x`.\n-            if !ContainsRegion.visit_ty(&self.body.local_decls[*dest].ty) {\n+            if ContainsRegion.visit_ty(&self.body.local_decls[*dest].ty).is_continue() {\n                 return;\n             }\n \n@@ -558,8 +559,8 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n struct ContainsRegion;\n \n impl TypeVisitor<'_> for ContainsRegion {\n-    fn visit_region(&mut self, _: ty::Region<'_>) -> bool {\n-        true\n+    fn visit_region(&mut self, _: ty::Region<'_>) -> ControlFlow<()> {\n+        ControlFlow::BREAK\n     }\n }\n "}]}