{"sha": "a32498d8464e0dfa4e2cb31967a66e076da40109", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMjQ5OGQ4NDY0ZTBkZmE0ZTJjYjMxOTY3YTY2ZTA3NmRhNDAxMDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-01T01:12:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-07T13:53:30Z"}, "message": "Make ~fn non-copyable, make &fn copyable, split barefn/closure types,\ncorrect handling of moves for struct-record update.\n\nPart of #3678.  Fixes #2828, #3904, #4719.", "tree": {"sha": "62fc02049c4d06ccd64a704f6f9e3af53d2835e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62fc02049c4d06ccd64a704f6f9e3af53d2835e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a32498d8464e0dfa4e2cb31967a66e076da40109", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a32498d8464e0dfa4e2cb31967a66e076da40109", "html_url": "https://github.com/rust-lang/rust/commit/a32498d8464e0dfa4e2cb31967a66e076da40109", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a32498d8464e0dfa4e2cb31967a66e076da40109/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82d73963334f01b818cda767b44cd0c8f3baf4cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/82d73963334f01b818cda767b44cd0c8f3baf4cc", "html_url": "https://github.com/rust-lang/rust/commit/82d73963334f01b818cda767b44cd0c8f3baf4cc"}], "stats": {"total": 4414, "additions": 2053, "deletions": 2361}, "files": [{"sha": "b63ac5e75a270953883068ec435ff00561040478", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -159,7 +159,7 @@ pub fn test_opts(config: config) -> test::TestOpts {\n     }\n }\n \n-pub fn make_tests(config: config) -> ~[test::TestDesc] {\n+pub fn make_tests(config: config) -> ~[test::TestDescAndFn] {\n     debug!(\"making tests from %s\",\n            config.src_base.to_str());\n     let mut tests = ~[];\n@@ -196,13 +196,14 @@ pub fn is_test(config: config, testfile: &Path) -> bool {\n     return valid;\n }\n \n-pub fn make_test(config: config, testfile: &Path) ->\n-   test::TestDesc {\n-    test::TestDesc {\n-        name: make_test_name(config, testfile),\n+pub fn make_test(config: config, testfile: &Path) -> test::TestDescAndFn {\n+    test::TestDescAndFn {\n+        desc: test::TestDesc {\n+            name: make_test_name(config, testfile),\n+            ignore: header::is_test_ignored(config, testfile),\n+            should_fail: false\n+        },\n         testfn: make_test_closure(config, testfile),\n-        ignore: header::is_test_ignored(config, testfile),\n-        should_fail: false\n     }\n }\n "}, {"sha": "75db5359e2e31e01836c67f82b14bc06965865ce", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,10 +10,6 @@\n \n //! Managed vectors\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast::transmute;\n use kinds::Copy;\n use iter;"}, {"sha": "1eebb716a5973564cb9ca690fa4d69651e024629", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -9,10 +9,6 @@\n // except according to those terms.\n \n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n //! Boolean logic\n \n use bool;"}, {"sha": "14cc79ceaffedda279ab40e65a7677551141a813", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Unsafe operations\n-#[forbid(deprecated_mode)]\n-\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n     fn forget<T>(-x: T);"}, {"sha": "f7a369489d1ab3599e6878eb5a53466fb9ed3c02", "filename": "src/libcore/char.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,10 +10,6 @@\n \n //! Utilities for manipulating the char type\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use char;\n use cmp::Eq;\n use option::{None, Option, Some};"}, {"sha": "11a4cad5d1bbb72559b7ef20bfa8c2db0c1bcb8e", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,10 +10,6 @@\n \n #[doc(hidden)];\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use libc::{c_char, c_void, intptr_t, uintptr_t};\n use ptr::{mut_null, null, to_unsafe_ptr};\n use repr::BoxRepr;"}, {"sha": "e1ec8c7737c7d23243eb9f7123a0a8674b5e15ee", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -20,10 +20,6 @@ and `Eq` to overload the `==` and `!=` operators.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n /**\n * Trait for values that can be compared for equality\n * and inequality."}, {"sha": "2a5ca7d8dfa6c784e4ed5b48ae92dd72906eca1b", "filename": "src/libcore/container.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,9 +10,6 @@\n \n //! Container traits\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use option::Option;\n \n pub trait Container {"}, {"sha": "64b480818b1e7b4ceefa9850d76d8992316f53a6", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -48,8 +48,6 @@ Implicitly, all crates behave as if they included the following prologue:\n // Don't link to core. We are core.\n #[no_core];\n \n-#[warn(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n #[warn(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n #[allow(deprecated_self)];"}, {"sha": "ed67e010b405588bf7699a7862280e75082ce129", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -18,10 +18,6 @@ Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use kinds::Copy;\n use managed;\n use option::{None, Option, Some};"}, {"sha": "fe36ed159603cccb5e3036545c8961e4d89b05ff", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -19,10 +19,6 @@ Note that recursive use is not permitted.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast;\n use cast::reinterpret_cast;\n use prelude::*;"}, {"sha": "7efde62c4ca6b672dee86e41394ad65fe4fa067e", "filename": "src/libcore/either.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n //! A type that represents one of two alternatives\n \n use cmp::Eq;"}, {"sha": "4d2a1b2afe08d47841750494915898e7eb82e98d", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -51,10 +51,6 @@\n //! * s - str (any flavor)\n //! * ? - arbitrary type (does not use the to_str trait)\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n // Transitional\n #[allow(structural_records)]; // Macros -- needs a snapshot\n "}, {"sha": "6b5c083662b84989f3c9b147c5686592b09aa2e8", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,10 +14,6 @@ Simple compression\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use libc;\n use libc::{c_void, size_t, c_int};\n use ptr;"}, {"sha": "9322c7e7cb822baddfc323db9e4b830af4d63241", "filename": "src/libcore/from_str.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffrom_str.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,10 +10,6 @@\n \n //! The trait for types that can be created from strings\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use option::Option;\n \n pub trait FromStr {"}, {"sha": "d0c40ccf19aa07ab36af0667e4788d51d6ddce4f", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -35,9 +35,6 @@ with destructors.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n // Transitional\n #[allow(structural_records)];\n "}, {"sha": "692cfee536581b3e2a692be610ed692fe624f673", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n /*!\n  * Implementation of SipHash 2-4\n  *"}, {"sha": "be785863f71ec3d9030dca39bc0d69a77016e25b", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,10 +10,6 @@\n \n //! Sendable hash maps.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use container::{Container, Mutable, Map, Set};\n use cmp::Eq;\n use hash::Hash;"}, {"sha": "721a6584c650677e136cbbbde7dc23ab8f0d5534", "filename": "src/libcore/io.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,9 +14,6 @@ Basic input/output\n \n */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use result::Result;\n \n use cmp::Eq;"}, {"sha": "df2aa6271d1f839cbb8dd4e76d20a8740a37fb19", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -12,9 +12,6 @@\n // workaround our lack of traits and lack of macros.  See core.{rc,rs} for\n // how this file is used.\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::{Eq, Ord};\n use iter::BaseIter;\n use iter;"}, {"sha": "c414ab0f5f3e551fb70d9394e62a0048de6c8252", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,9 +14,6 @@ The iteration traits and common implementation\n \n */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::{Eq, Ord};\n use kinds::Copy;\n use option::{None, Option, Some};"}, {"sha": "6976c83a6f407f0bc7229ddb01bda74cea09eb08", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n /*!\n * Bindings for libc.\n *"}, {"sha": "357a3415ac2da03a5f78ff33aa3416fc4e182bf6", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,10 +10,6 @@\n \n //! Logging\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast::transmute;\n use io;\n use libc;"}, {"sha": "700feee9839435408a58daa2b4d43164f243eebf", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,10 +10,6 @@\n \n //! Operations on managed box types\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast::transmute;\n use cmp::{Eq, Ord};\n use managed::raw::BoxRepr;"}, {"sha": "3c44c197f5ef67418443d6e185bbb495070d3225", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -18,8 +18,6 @@ dynamic checks: your program will fail if you attempt to perform\n mutation when the data structure should be immutable.\n \n */\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n \n use util::with;\n use cast::transmute_immut;"}, {"sha": "8f03a1b6e3498cd2a7091a44706f0f5f73ee1ef3", "filename": "src/libcore/nil.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnil.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,10 +14,6 @@ Functions for the unit type.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::{Eq, Ord};\n \n #[cfg(notest)]"}, {"sha": "c030dfc589977784816c453713c2a2f25a34375a", "filename": "src/libcore/num/cmath.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fcmath.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -9,9 +9,6 @@\n // except according to those terms.\n \n #[doc(hidden)]; // FIXME #3538\n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n \n use libc::c_int;\n use libc::c_float;"}, {"sha": "738445b5cd94616f84db218598d2990e2ce6ae38", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n //! Operations and constants for `f32`\n \n use cmath;"}, {"sha": "f09d874803c3d852c9fee27f993b9b25b3e30932", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n //! Operations and constants for `f64`\n \n use cmath;"}, {"sha": "f5ae05ebffb4e6cbd0e7a20d1b97b02c24e75c7f", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n //! Operations and constants for `float`\n \n // Even though this module exports everything defined in it,"}, {"sha": "1856781b1d7799a9fb62388558a789a11f6e0e4a", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use T = self::inst::T;\n \n use char;"}, {"sha": "f8bbb35204add49672320e10a324a790c2bcf2db", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use T = self::inst::T;\n use T_SIGNED = self::inst::T_SIGNED;\n "}, {"sha": "aaa4ab3fecfee33fcdc91230afa0c4df8ec63aba", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,9 +10,6 @@\n \n // Core operators\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n #[lang=\"drop\"]\n pub trait Drop {\n     fn finalize(&self);  // FIXME(#4332): Rename to \"drop\"? --pcwalton"}, {"sha": "e5d703eec4aeffc7a46635d11f34664f2573646b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -41,9 +41,6 @@ let unwrapped_msg = match move msg {\n \n */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::Eq;\n use kinds::Copy;\n use option;"}, {"sha": "a14abd23cc3cadab309db32e25abd8c740549ff4", "filename": "src/libcore/os.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n #[allow(structural_records)];\n \n /*!"}, {"sha": "d841188501d967756a2cc9e297d59a7369e45666", "filename": "src/libcore/owned.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fowned.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,10 +10,6 @@\n \n //! Operations on unique pointer types\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::{Eq, Ord};\n \n #[cfg(notest)]"}, {"sha": "bf1f1c713a9945be7638f94e0ae927760dce43df", "filename": "src/libcore/path.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,10 +14,6 @@ Cross-platform file path handling\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::Eq;\n use libc;\n use option::{None, Option, Some};"}, {"sha": "3f0aecb887d251672a8cbc1f88856c75e12354a4", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -82,11 +82,6 @@ bounded and unbounded protocols allows for less code duplication.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-// tjc: allowing deprecated modes due to function issue,\n-// re-forbid after snapshot\n-#[forbid(deprecated_pattern)];\n-\n // Transitional -- needs snapshot\n #[allow(structural_records)];\n "}, {"sha": "a798d8c866a3f2307331e8baf87808c2e2ae6ddb", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -36,7 +36,7 @@ pub use path::PosixPath;\n pub use path::WindowsPath;\n pub use pipes::{GenericChan, GenericPort};\n pub use ptr::Ptr;\n-pub use str::{StrSlice, Trimmable};\n+pub use str::{StrSlice, Trimmable, OwnedStr};\n pub use to_bytes::IterBytes;\n pub use to_str::ToStr;\n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};"}, {"sha": "d4cf39ad2625e194cea6803766a48e999feddcac", "filename": "src/libcore/private.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,11 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-// tjc: Re-forbid deprecated modes once a snapshot fixes the\n-// function problem\n-#[forbid(deprecated_pattern)];\n-\n #[doc(hidden)];\n \n use cast;"}, {"sha": "50c5ea70cbb40c0168e8a0378d9b24ee4654651c", "filename": "src/libcore/private/finally.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fprivate%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fprivate%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Ffinally.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -26,10 +26,19 @@ do || {\n use ops::Drop;\n use task::{spawn, failing};\n \n+#[cfg(stage0)]\n pub trait Finally<T> {\n     fn finally(&self, +dtor: &fn()) -> T;\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub trait Finally<T> {\n+    fn finally(&self, dtor: &fn()) -> T;\n+}\n+\n+#[cfg(stage0)]\n impl<T> &fn() -> T: Finally<T> {\n     // FIXME #4518: Should not require a mode here\n     fn finally(&self, +dtor: &fn()) -> T {\n@@ -41,6 +50,19 @@ impl<T> &fn() -> T: Finally<T> {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<T> &fn() -> T: Finally<T> {\n+    fn finally(&self, dtor: &fn()) -> T {\n+        let _d = Finallyalizer {\n+            dtor: dtor\n+        };\n+\n+        (*self)()\n+    }\n+}\n+\n struct Finallyalizer {\n     dtor: &fn()\n }"}, {"sha": "ad0bcb5cff8a21c5ac43c7d77d6c47bc60c79971", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,9 +10,6 @@\n \n //! Unsafe pointer utility functions\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast;\n use cmp::{Eq, Ord};\n use libc;"}, {"sha": "452ab9452510b90a25f3e2cfa79048304471e7f1", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,10 +10,6 @@\n \n //! Random number generation\n \n-// NB: transitional, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use int;\n use prelude::*;\n use str;"}, {"sha": "de94100d7a50615f095a81cd8da46009fb1b1f7f", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,9 +14,6 @@ Runtime type reflection\n \n */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use intrinsic::{TyDesc, get_tydesc, visit_tydesc, TyVisitor};\n use libc::c_void;\n use sys;"}, {"sha": "a47bad008b872ca5ad38d70eb605c7caee8d2eec", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,9 +14,6 @@ More runtime type reflection\n \n */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast::transmute;\n use cast;\n use char;"}, {"sha": "7f1513173786b2878807e1c9bdea85b8c4a935a7", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -12,9 +12,6 @@\n \n // NB: transitionary, de-mode-ing.\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp;\n use cmp::Eq;\n use either;"}, {"sha": "33d76cb3c685999acb476af6f752cee06b871d2c", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n //! Runtime calls emitted by the compiler.\n \n use cast::transmute;"}, {"sha": "e44bd2aab81728ae8b968a773123d91968670853", "filename": "src/libcore/run.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n #[allow(structural_records)];\n \n //! Process spawning"}, {"sha": "2e24df86c7809933159760e94590481d42f450b6", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -11,12 +11,7 @@\n #[doc(hidden)]; // FIXME #3538\n \n #[legacy_modes]; // tjc: remove after snapshot\n-\n-// NB: transitionary, de-mode-ing.\n-// FIXME #4425: Can't forbid this because frame_address needs a deprecated\n-// mode.\n #[allow(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n \n use cast::reinterpret_cast;\n use ptr::offset;"}, {"sha": "9b25f92ede2a47f10fece711bd4c2b10c22186c7", "filename": "src/libcore/str.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -17,9 +17,6 @@\n  * some heavy-duty uses, try std::rope.\n  */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use at_vec;\n use cast;\n use char;\n@@ -2314,6 +2311,21 @@ impl &str: StrSlice {\n     pure fn char_at(i: uint) -> char { char_at(self, i) }\n }\n \n+pub trait OwnedStr {\n+    fn push_str(&mut self, v: &str);\n+    fn push_char(&mut self, c: char);\n+}\n+\n+pub impl ~str : OwnedStr {\n+    fn push_str(&mut self, v: &str) {\n+        push_str(self, v);\n+    }\n+\n+    fn push_char(&mut self, c: char) {\n+        push_char(self, c);\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use char;"}, {"sha": "1571e645117849b68bbb9ee6af0790446519498a", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,10 +10,6 @@\n \n //! Misc low level stuff\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast;\n use cmp::{Eq, Ord};\n use gc;"}, {"sha": "9240a67c69a3dfd97b1435f51de751d3021adca9", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,11 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-// tjc: Deprecated modes allowed because of function arg issue\n-// in task::spawn. Re-forbid after snapshot.\n-#[forbid(deprecated_pattern)];\n-\n /*!\n  * Task management.\n  *"}, {"sha": "22a0c870de6495d7100984206bb4e8c6496440a1", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -71,7 +71,6 @@\n  ****************************************************************************/\n \n #[doc(hidden)]; // FIXME #3538\n-#[warn(deprecated_mode)];\n \n use cast;\n use container::Map;"}, {"sha": "b4647d0c621a112a37237e36300da876968fcaf5", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,16 +14,12 @@ The `ToBytes` and `IterBytes` traits\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use io;\n use io::Writer;\n use option::{None, Option, Some};\n use str;\n \n-pub type Cb = fn(buf: &[const u8]) -> bool;\n+pub type Cb = &fn(buf: &[const u8]) -> bool;\n \n /**\n  * A trait to implement in order to make a type hashable;"}, {"sha": "d98e341eab8a36c6a59430fde366fa1e60f2745e", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,10 +14,6 @@ The `ToStr` trait for converting to strings\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use kinds::Copy;\n use str;\n use vec;"}, {"sha": "484fc1a5a276556bbdb8031281ee1e7f2d662a03", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n //! Operations on tuples\n \n use cmp::{Eq, Ord};"}, {"sha": "ff3b908186a18b21b54b46b05a118443ed5b772c", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -9,9 +9,6 @@\n // except according to those terms.\n \n #[doc(hidden)]; // FIXME #3538\n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n \n pub mod general_category {\n     pub pure fn Cc(c: char) -> bool {"}, {"sha": "3b6a134bc52cd497c2969d43b56d173efa2cc444", "filename": "src/libcore/util.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,10 +14,6 @@ Miscellaneous helpers for common patterns.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::Eq;\n use prelude::*;\n "}, {"sha": "9ad5d9f32da366ead0b74f1ab61b888e2d923384", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 84, "deletions": 20, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,8 +10,6 @@\n \n //! Vectors\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n #[warn(non_camel_case_types)];\n \n use container::{Container, Mutable};\n@@ -841,14 +839,37 @@ pub pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n     u\n }\n \n-/**\n- * Apply a function to each element of a vector and return the results\n- *\n- * If function `f` returns `none` then that element is excluded from\n- * the resulting vector.\n- */\n-pub pure fn filter_map<T, U: Copy>(v: &[T], f: fn(t: &T) -> Option<U>)\n-    -> ~[U] {\n+pub fn filter_map<T, U>(\n+    v: ~[T],\n+    f: fn(t: T) -> Option<U>) -> ~[U]\n+{\n+    /*!\n+     *\n+     * Apply a function to each element of a vector and return the results.\n+     * Consumes the input vector.  If function `f` returns `None` then that\n+     * element is excluded from the resulting vector.\n+     */\n+\n+    let mut result = ~[];\n+    do consume(v) |_, elem| {\n+        match f(elem) {\n+            None => {}\n+            Some(result_elem) => { result.push(result_elem); }\n+        }\n+    }\n+    result\n+}\n+\n+pub pure fn filter_mapped<T, U: Copy>(\n+    v: &[T],\n+    f: fn(t: &T) -> Option<U>) -> ~[U]\n+{\n+    /*!\n+     *\n+     * Like `filter_map()`, but operates on a borrowed slice\n+     * and does not consume the input.\n+     */\n+\n     let mut result = ~[];\n     for each(v) |elem| {\n         match f(elem) {\n@@ -1695,7 +1716,7 @@ pub trait ImmutableVector<T> {\n     fn map_r<U>(&self, f: fn(x: &T) -> U) -> ~[U];\n     pure fn alli(&self, f: fn(uint, t: &T) -> bool) -> bool;\n     pure fn flat_map<U>(&self, f: fn(t: &T) -> ~[U]) -> ~[U];\n-    pure fn filter_map<U: Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U];\n+    pure fn filter_mapped<U: Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U];\n }\n \n /// Extension methods for vectors\n@@ -1758,8 +1779,8 @@ impl<T> &[T]: ImmutableVector<T> {\n      * the resulting vector.\n      */\n     #[inline]\n-    pure fn filter_map<U: Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U] {\n-        filter_map(*self, f)\n+    pure fn filter_mapped<U: Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U] {\n+        filter_mapped(*self, f)\n     }\n }\n \n@@ -2439,10 +2460,14 @@ mod tests {\n \n     pure fn is_equal(x: &uint, y:&uint) -> bool { return *x == *y; }\n \n-    fn square_if_odd(n: &uint) -> Option<uint> {\n+    fn square_if_odd_r(n: &uint) -> Option<uint> {\n         return if *n % 2u == 1u { Some(*n * *n) } else { None };\n     }\n \n+    fn square_if_odd_v(n: uint) -> Option<uint> {\n+        return if n % 2u == 1u { Some(n * n) } else { None };\n+    }\n+\n     fn add(x: uint, y: &uint) -> uint { return x + *y; }\n \n     #[test]\n@@ -2775,17 +2800,17 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_filter_map() {\n+    fn test_filter_mapped() {\n         // Test on-stack filter-map.\n         let mut v = ~[1u, 2u, 3u];\n-        let mut w = filter_map(v, square_if_odd);\n+        let mut w = filter_mapped(v, square_if_odd_r);\n         assert (len(w) == 2u);\n         assert (w[0] == 1u);\n         assert (w[1] == 9u);\n \n         // Test on-heap filter-map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n-        w = filter_map(v, square_if_odd);\n+        w = filter_mapped(v, square_if_odd_r);\n         assert (len(w) == 3u);\n         assert (w[0] == 1u);\n         assert (w[1] == 9u);\n@@ -2804,7 +2829,46 @@ mod tests {\n         let all_odd2: ~[int] = ~[];\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        assert (filter_map(all_even, halve) == map(all_even, halve_for_sure));\n+        assert (filter_mapped(all_even, halve) ==\n+                map(all_even, halve_for_sure));\n+        assert (filter_mapped(all_odd1, halve) == ~[]);\n+        assert (filter_mapped(all_odd2, halve) == ~[]);\n+        assert (filter_mapped(mix, halve) == mix_dest);\n+    }\n+\n+    #[test]\n+    fn test_filter_map() {\n+        // Test on-stack filter-map.\n+        let mut v = ~[1u, 2u, 3u];\n+        let mut w = filter_map(v, square_if_odd_v);\n+        assert (len(w) == 2u);\n+        assert (w[0] == 1u);\n+        assert (w[1] == 9u);\n+\n+        // Test on-heap filter-map.\n+        v = ~[1u, 2u, 3u, 4u, 5u];\n+        w = filter_map(v, square_if_odd_v);\n+        assert (len(w) == 3u);\n+        assert (w[0] == 1u);\n+        assert (w[1] == 9u);\n+        assert (w[2] == 25u);\n+\n+        fn halve(i: int) -> Option<int> {\n+            if i % 2 == 0 {\n+                return option::Some::<int>(i / 2);\n+            } else {\n+                return option::None::<int>;\n+            }\n+        }\n+        fn halve_for_sure(i: &int) -> int { return *i / 2; }\n+        let all_even: ~[int] = ~[0, 2, 8, 6];\n+        let all_even0: ~[int] = copy all_even;\n+        let all_odd1: ~[int] = ~[1, 7, 3];\n+        let all_odd2: ~[int] = ~[];\n+        let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n+        let mix_dest: ~[int] = ~[1, 3, 0, 0];\n+        assert (filter_map(all_even, halve) ==\n+                map(all_even0, halve_for_sure));\n         assert (filter_map(all_odd1, halve) == ~[]);\n         assert (filter_map(all_odd2, halve) == ~[]);\n         assert (filter_map(mix, halve) == mix_dest);\n@@ -3664,10 +3728,10 @@ mod tests {\n     #[ignore(windows)]\n     #[should_fail]\n     #[allow(non_implicitly_copyable_typarams)]\n-    fn test_filter_map_fail() {\n+    fn test_filter_mapped_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do filter_map(v) |_elt| {\n+        do filter_mapped(v) |_elt| {\n             if i == 2 {\n                 die!()\n             }"}, {"sha": "cf75db3a900140dfb349abd711b9cc7b2c0458b5", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -64,12 +64,13 @@ fn filter_view_item(cx: ctxt, &&view_item: @ast::view_item\n }\n \n fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n-    let filtered_items = vec::filter_map(m.items, |a| filter_item(cx, *a));\n-    let filtered_view_items = vec::filter_map(m.view_items,\n-                                              |a| filter_view_item(cx, *a));\n+    let filtered_items =\n+        m.items.filter_mapped(|a| filter_item(cx, *a));\n+    let filtered_view_items =\n+        m.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n     ast::_mod {\n         view_items: filtered_view_items.map(|x| fld.fold_view_item(*x)),\n-        items: filtered_items.filter_map(|x| fld.fold_item(*x)),\n+        items: vec::filter_map(filtered_items, |x| fld.fold_item(x))\n     }\n }\n \n@@ -85,10 +86,10 @@ fn fold_foreign_mod(\n     nm: ast::foreign_mod,\n     fld: fold::ast_fold\n ) -> ast::foreign_mod {\n-    let filtered_items = vec::filter_map(nm.items,\n-                                         |a| filter_foreign_item(cx, *a));\n-    let filtered_view_items = vec::filter_map(nm.view_items,\n-                                              |a| filter_view_item(cx, *a));\n+    let filtered_items =\n+        nm.items.filter_mapped(|a| filter_foreign_item(cx, *a));\n+    let filtered_view_items =\n+        nm.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n     ast::foreign_mod {\n         sort: nm.sort,\n         abi: nm.abi,\n@@ -136,7 +137,8 @@ fn fold_block(\n     b: ast::blk_,\n     fld: fold::ast_fold\n ) -> ast::blk_ {\n-    let filtered_stmts = vec::filter_map(b.stmts, |a| filter_stmt(cx, *a));\n+    let filtered_stmts =\n+        b.stmts.filter_mapped(|a| filter_stmt(cx, *a));\n     ast::blk_ {\n         view_items: /*bad*/copy b.view_items,\n         stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n@@ -183,8 +185,9 @@ pub fn metas_in_cfg(cfg: ast::crate_cfg,\n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n-    let cfg_metas = vec::concat(vec::filter_map(cfg_metas,\n-        |i| attr::get_meta_item_list(*i)));\n+    let cfg_metas =\n+        vec::concat(\n+            vec::filter_map(cfg_metas, |i| attr::get_meta_item_list(i)));\n \n     let has_cfg_metas = vec::len(cfg_metas) > 0u;\n     if !has_cfg_metas { return true; }"}, {"sha": "9fa1cea3e103f9106782aed90fd2f8f7ee316507", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 45, "deletions": 68, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -168,9 +168,11 @@ fn is_test_fn(i: @ast::item) -> bool {\n fn is_ignored(cx: test_ctxt, i: @ast::item) -> bool {\n     let ignoreattrs = attr::find_attrs_by_name(i.attrs, \"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n-    let cfg_metas = vec::concat(vec::filter_map(ignoreitems,\n-        |i| attr::get_meta_item_list(*i)));\n     return if !ignoreitems.is_empty() {\n+        let cfg_metas =\n+            vec::concat(\n+                vec::filter_map(ignoreitems,\n+                                |i| attr::get_meta_item_list(i)));\n         config::metas_in_cfg(/*bad*/copy cx.crate.node.config, cfg_metas)\n     } else {\n         false\n@@ -277,7 +279,7 @@ fn mk_std(cx: test_ctxt) -> @ast::view_item {\n }\n \n fn mk_tests(cx: test_ctxt) -> @ast::item {\n-    let ret_ty = mk_test_desc_vec_ty(cx);\n+    let ret_ty = mk_test_desc_and_fn_vec_ty(cx);\n \n     let decl = ast::fn_decl {\n         inputs: ~[],\n@@ -286,7 +288,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n     };\n \n     // The vector of test_descs for this crate\n-    let test_descs = mk_test_desc_vec(cx);\n+    let test_descs = mk_test_desc_and_fn_vec(cx);\n \n     let body_: ast::blk_ =\n         default_block(~[], option::Some(test_descs), cx.sess.next_node_id());\n@@ -327,19 +329,21 @@ fn mk_path(cx: test_ctxt, +path: ~[ast::ident]) -> @ast::path {\n     }\n }\n \n-// The ast::Ty of ~[std::test::test_desc]\n-fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::Ty {\n-    let test_desc_ty_path =\n+// The ast::Ty of ~[std::test::TestDescAndFn]\n+fn mk_test_desc_and_fn_vec_ty(cx: test_ctxt) -> @ast::Ty {\n+    let test_desc_and_fn_ty_path =\n         mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n-                      cx.sess.ident_of(~\"TestDesc\")]);\n+                      cx.sess.ident_of(~\"TestDescAndFn\")]);\n \n-    let test_desc_ty = ast::Ty {\n+    let test_desc_and_fn_ty = ast::Ty {\n         id: cx.sess.next_node_id(),\n-        node: ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()),\n+        node: ast::ty_path(test_desc_and_fn_ty_path,\n+                           cx.sess.next_node_id()),\n         span: dummy_sp(),\n     };\n \n-    let vec_mt = ast::mt {ty: @test_desc_ty, mutbl: ast::m_imm};\n+    let vec_mt = ast::mt {ty: @test_desc_and_fn_ty,\n+                          mutbl: ast::m_imm};\n \n     let inner_ty = @ast::Ty {\n         id: cx.sess.next_node_id(),\n@@ -354,11 +358,11 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::Ty {\n     }\n }\n \n-fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n+fn mk_test_desc_and_fn_vec(cx: test_ctxt) -> @ast::expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n     for cx.testfns.each |test| {\n-        descs.push(mk_test_desc_rec(cx, *test));\n+        descs.push(mk_test_desc_and_fn_rec(cx, *test));\n     }\n \n     let inner_expr = @ast::expr {\n@@ -376,7 +380,7 @@ fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n     }\n }\n \n-fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n+fn mk_test_desc_and_fn_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let span = test.span;\n     let path = /*bad*/copy test.path;\n \n@@ -407,23 +411,6 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n         expr: @name_expr,\n     });\n \n-    let fn_path = path_node_global(path);\n-\n-    let fn_expr = ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_path(fn_path),\n-        span: span,\n-    };\n-\n-    let fn_wrapper_expr = mk_test_wrapper(cx, fn_expr, span);\n-\n-    let fn_field = nospan(ast::field_ {\n-        mutbl: ast::m_imm,\n-        ident: cx.sess.ident_of(~\"testfn\"),\n-        expr: fn_wrapper_expr,\n-    });\n-\n     let ignore_lit: ast::lit = nospan(ast::lit_bool(test.ignore));\n \n     let ignore_expr = ast::expr {\n@@ -460,62 +447,52 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n \n     let desc_rec_ = ast::expr_struct(\n         test_desc_path,\n-        ~[name_field, fn_field, ignore_field, fail_field],\n+        ~[name_field, ignore_field, fail_field],\n         option::None\n     );\n \n-    let desc_rec = ast::expr {\n+    let desc_rec = @ast::expr {\n         id: cx.sess.next_node_id(),\n         callee_id: cx.sess.next_node_id(),\n         node: desc_rec_,\n         span: span,\n     };\n \n-    return @desc_rec;\n-}\n+    let desc_field = nospan(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: cx.sess.ident_of(~\"desc\"),\n+        expr: desc_rec\n+    });\n \n-// Produces a bare function that wraps the test function\n+    let fn_path = path_node_global(path);\n \n-// FIXME (#1281): This can go away once fn is the type of bare function.\n-fn mk_test_wrapper(cx: test_ctxt,\n-                   +fn_path_expr: ast::expr,\n-                   span: span) -> @ast::expr {\n-    let call_expr = ast::expr {\n+    let fn_expr = @ast::expr {\n         id: cx.sess.next_node_id(),\n         callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_call(@fn_path_expr, ~[], false),\n+        node: ast::expr_path(fn_path),\n         span: span,\n     };\n \n-    let call_stmt: ast::stmt = nospan(\n-        ast::stmt_semi(@call_expr, cx.sess.next_node_id()));\n-\n-    let wrapper_decl = ast::fn_decl {\n-        inputs: ~[],\n-        output: @ast::Ty {\n-            id: cx.sess.next_node_id(),\n-            node: ast::ty_nil,\n-            span: span,\n-        },\n-        cf: ast::return_val\n-    };\n-\n-    let wrapper_body = nospan(ast::blk_ {\n-        view_items: ~[],\n-        stmts: ~[@call_stmt],\n-        expr: option::None,\n-        id: cx.sess.next_node_id(),\n-        rules: ast::default_blk\n+    let fn_field = nospan(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: cx.sess.ident_of(~\"testfn\"),\n+        expr: fn_expr,\n     });\n \n-    let wrapper_expr = ast::expr  {\n+    let test_desc_and_fn_path =\n+        mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n+                      cx.sess.ident_of(~\"TestDescAndFn\")]);\n+\n+    let desc_and_fn_rec = @ast::expr {\n         id: cx.sess.next_node_id(),\n         callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_fn(ast::ProtoBare, wrapper_decl, wrapper_body, @()),\n-        span: span\n+        node: ast::expr_struct(test_desc_and_fn_path,\n+                               ~[fn_field, desc_field],\n+                               option::None),\n+        span: span,\n     };\n \n-    return @wrapper_expr;\n+    return desc_and_fn_rec;\n }\n \n fn mk_main(cx: test_ctxt) -> @ast::item {\n@@ -567,7 +544,7 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n     let args_call_expr = ast::expr {\n         id: cx.sess.next_node_id(),\n         callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_call(@args_path_expr, ~[], false),\n+        node: ast::expr_call(@args_path_expr, ~[], ast::NoSugar),\n         span: dummy_sp(),\n     };\n \n@@ -584,7 +561,7 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n     let test_call_expr = ast::expr {\n         id: cx.sess.next_node_id(),\n         callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_call(@test_path_expr, ~[], false),\n+        node: ast::expr_call(@test_path_expr, ~[], ast::NoSugar),\n         span: dummy_sp(),\n     };\n \n@@ -606,7 +583,7 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n         node: ast::expr_call(\n             @test_main_path_expr,\n             ~[@args_call_expr, @test_call_expr],\n-            false\n+            ast::NoSugar\n         ),\n         span: dummy_sp(),\n     };"}, {"sha": "67498ad5aafe6425babdac100d3b1202bbdac88f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -586,10 +586,8 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                                 item, tcx, cdata);\n         let name = item_name(intr, item);\n         let arg_tys = match ty::get(ctor_ty).sty {\n-          ty::ty_fn(ref f) => (*f).sig.inputs.map(|a| a.ty),\n-\n-          // Nullary enum variant.\n-          _ => ~[],\n+          ty::ty_bare_fn(ref f) => f.sig.inputs.map(|a| a.ty),\n+          _ => ~[], // Nullary enum variant.\n         };\n         match variant_disr_val(item) {\n           Some(val) => { disr_val = val; }\n@@ -705,11 +703,12 @@ pub fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n         let ty = doc_type(mth, tcx, cdata);\n         let def_id = item_def_id(mth, cdata);\n         let fty = match ty::get(ty).sty {\n-          ty::ty_fn(ref f) => (/*bad*/copy *f),\n-          _ => {\n-            tcx.diag.handler().bug(\n-                ~\"get_trait_methods: id has non-function type\");\n-        } };\n+            ty::ty_bare_fn(ref f) => copy *f,\n+            _ => {\n+                tcx.diag.handler().bug(\n+                    ~\"get_trait_methods: id has non-function type\");\n+            }\n+        };\n         let self_ty = get_self_ty(mth);\n         result.push({ident: name, tps: bounds, fty: fty, self_ty: self_ty,\n                      vis: ast::public, def_id: def_id});\n@@ -734,14 +733,13 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n         let name = item_name(intr, mth);\n         let ty = doc_type(mth, tcx, cdata);\n \n-        let fty;\n-        match ty::get(ty).sty {\n-            ty::ty_fn(ref f) => fty = (/*bad*/copy *f),\n+        let fty = match ty::get(ty).sty {\n+            ty::ty_bare_fn(ref f) => copy *f,\n             _ => {\n                 tcx.diag.handler().bug(~\"get_provided_trait_methods(): id \\\n                                          has non-function type\");\n             }\n-        }\n+        };\n \n         let self_ty = get_self_ty(mth);\n         let ty_method = {ident: name, tps: bounds, fty: fty, self_ty: self_ty,"}, {"sha": "b0a424447b35ec78eed00e9182178d13fc813ea9", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -768,8 +768,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                 encode_name(ecx, ebml_w, mty.ident);\n                 encode_type_param_bounds(ebml_w, ecx,\n                                          (*ty_m).tps);\n-                encode_type(ecx, ebml_w, ty::mk_fn(tcx, /*bad*/copy mty.fty));\n-                encode_family(ebml_w, purity_fn_family(mty.fty.meta.purity));\n+                encode_type(ecx, ebml_w,\n+                            ty::mk_bare_fn(tcx, copy mty.fty));\n+                encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 encode_method_sort(ebml_w, 'r');\n                 ebml_w.end_tag();\n@@ -781,8 +782,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                 encode_def_id(ebml_w, local_def(m.id));\n                 encode_name(ecx, ebml_w, mty.ident);\n                 encode_type_param_bounds(ebml_w, ecx, m.tps);\n-                encode_type(ecx, ebml_w, ty::mk_fn(tcx, /*bad*/copy mty.fty));\n-                encode_family(ebml_w, purity_fn_family(mty.fty.meta.purity));\n+                encode_type(ecx, ebml_w,\n+                            ty::mk_bare_fn(tcx, copy mty.fty));\n+                encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 encode_method_sort(ebml_w, 'p');\n                 ebml_w.end_tag();"}, {"sha": "3f989339e275e2dd05ab8c7e35f7022152dc022f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -17,8 +17,6 @@\n use core::prelude::*;\n \n use middle::ty;\n-use middle::ty::{FnTyBase, FnMeta, FnSig, arg, creader_cache_key, field};\n-use middle::ty::{substs};\n \n use core::io;\n use core::str;\n@@ -124,17 +122,12 @@ fn parse_path(st: @pstate) -> @ast::path {\n     };\n }\n \n-fn parse_ty_rust_fn(st: @pstate, conv: conv_did) -> ty::t {\n-    return ty::mk_fn(st.tcx, parse_ty_fn(st, conv));\n-}\n-\n-fn parse_proto(st: @pstate) -> ast::Proto {\n+fn parse_sigil(st: @pstate) -> ast::Sigil {\n     match next(st) {\n-        '_' => ast::ProtoBare,\n-        '@' => ast::ProtoBox,\n-        '~' => ast::ProtoUniq,\n-        '&' => ast::ProtoBorrowed,\n-        _ => die!(~\"parse_proto(): bad input\")\n+        '@' => ast::ManagedSigil,\n+        '~' => ast::OwnedSigil,\n+        '&' => ast::BorrowedSigil,\n+        c => st.tcx.sess.bug(fmt!(\"parse_sigil(): bad input '%c'\", c))\n     }\n }\n \n@@ -152,7 +145,7 @@ fn parse_vstore(st: @pstate) -> ty::vstore {\n       '~' => ty::vstore_uniq,\n       '@' => ty::vstore_box,\n       '&' => ty::vstore_slice(parse_region(st)),\n-      _ => die!(~\"parse_vstore: bad input\")\n+      c => st.tcx.sess.bug(fmt!(\"parse_vstore(): bad input '%c'\", c))\n     }\n }\n \n@@ -166,7 +159,7 @@ fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n     while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n     st.pos = st.pos + 1u;\n \n-    return substs {\n+    return ty::substs {\n         self_r: self_r,\n         self_ty: self_ty,\n         tps: params\n@@ -316,19 +309,24 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         return ty::mk_tup(st.tcx, params);\n       }\n       'f' => {\n-        parse_ty_rust_fn(st, conv)\n+        return ty::mk_closure(st.tcx, parse_closure_ty(st, conv));\n+      }\n+      'F' => {\n+        return ty::mk_bare_fn(st.tcx, parse_bare_fn_ty(st, conv));\n       }\n       'Y' => return ty::mk_type(st.tcx),\n       'C' => {\n-        let proto = parse_proto(st);\n-        return ty::mk_opaque_closure_ptr(st.tcx, proto);\n+        let sigil = parse_sigil(st);\n+        return ty::mk_opaque_closure_ptr(st.tcx, sigil);\n       }\n       '#' => {\n         let pos = parse_hex(st);\n         assert (next(st) == ':');\n         let len = parse_hex(st);\n         assert (next(st) == '#');\n-        let key = creader_cache_key { cnum: st.crate, pos: pos, len: len };\n+        let key = ty::creader_cache_key {cnum: st.crate,\n+                                         pos: pos,\n+                                         len: len };\n         match st.tcx.rcache.find(&key) {\n           Some(tt) => return tt,\n           None => {\n@@ -408,6 +406,13 @@ fn parse_purity(c: char) -> purity {\n     }\n }\n \n+fn parse_abi(c: char) -> Abi {\n+    match c {\n+      'r' => ast::RustAbi,\n+      _ => die!(fmt!(\"parse_abi: bad ABI '%c'\", c))\n+    }\n+}\n+\n fn parse_onceness(c: char) -> ast::Onceness {\n     match c {\n         'o' => ast::Once,\n@@ -430,12 +435,33 @@ fn parse_mode(st: @pstate) -> ast::mode {\n     return m;\n }\n \n-fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::FnTy {\n-    let proto = parse_proto(st);\n+fn parse_closure_ty(st: @pstate, conv: conv_did) -> ty::ClosureTy {\n+    let sigil = parse_sigil(st);\n     let purity = parse_purity(next(st));\n     let onceness = parse_onceness(next(st));\n     let region = parse_region(st);\n-    let bounds = parse_bounds(st, conv);\n+    let sig = parse_sig(st, conv);\n+    ty::ClosureTy {\n+        purity: purity,\n+        sigil: sigil,\n+        onceness: onceness,\n+        region: region,\n+        sig: sig\n+    }\n+}\n+\n+fn parse_bare_fn_ty(st: @pstate, conv: conv_did) -> ty::BareFnTy {\n+    let purity = parse_purity(next(st));\n+    let abi = parse_abi(next(st));\n+    let sig = parse_sig(st, conv);\n+    ty::BareFnTy {\n+        purity: purity,\n+        abi: abi,\n+        sig: sig\n+    }\n+}\n+\n+fn parse_sig(st: @pstate, conv: conv_did) -> ty::FnSig {\n     assert (next(st) == '[');\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n@@ -444,18 +470,9 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::FnTy {\n     }\n     st.pos += 1u; // eat the ']'\n     let ret_ty = parse_ty(st, conv);\n-    return FnTyBase {\n-        meta: FnMeta {purity: purity,\n-                      proto: proto,\n-                      onceness: onceness,\n-                      bounds: bounds,\n-                      region: region},\n-        sig: FnSig {inputs: inputs,\n-                    output: ret_ty}\n-    };\n+    ty::FnSig {inputs: inputs, output: ret_ty}\n }\n \n-\n // Rust metadata parsing\n pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let mut colon_idx = 0u;"}, {"sha": "a87ce02d5a30ae7d19f6458608455b08be839c2d", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -288,8 +288,13 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n         }\n         w.write_char(']');\n       }\n-      ty::ty_fn(ref f) => {\n-        enc_ty_fn(w, cx, (*f));\n+      ty::ty_closure(ref f) => {\n+        w.write_char('f');\n+        enc_closure_ty(w, cx, f);\n+      }\n+      ty::ty_bare_fn(ref f) => {\n+        w.write_char('F');\n+        enc_bare_fn_ty(w, cx, f);\n       }\n       ty::ty_infer(_) => {\n         cx.diag.handler().bug(~\"Cannot encode inference variable types\");\n@@ -306,7 +311,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n       ty::ty_type => w.write_char('Y'),\n       ty::ty_opaque_closure_ptr(p) => {\n           w.write_str(&\"C&\");\n-          enc_proto(w, p);\n+          enc_sigil(w, p);\n       }\n       ty::ty_opaque_box => w.write_char('B'),\n       ty::ty_struct(def, ref substs) => {\n@@ -325,13 +330,11 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n     }\n }\n \n-fn enc_proto(w: io::Writer, proto: Proto) {\n-    w.write_str(&\"f\");\n-    match proto {\n-        ProtoBare => w.write_str(&\"_\"),\n-        ProtoBox => w.write_str(&\"@\"),\n-        ProtoUniq => w.write_str(&\"~\"),\n-        ProtoBorrowed => w.write_str(&\"&\"),\n+fn enc_sigil(w: io::Writer, sigil: Sigil) {\n+    match sigil {\n+        ManagedSigil => w.write_str(\"@\"),\n+        OwnedSigil => w.write_str(\"~\"),\n+        BorrowedSigil => w.write_str(\"&\"),\n     }\n }\n \n@@ -357,25 +360,40 @@ fn enc_purity(w: io::Writer, p: purity) {\n     }\n }\n \n+fn enc_abi(w: io::Writer, a: Abi) {\n+    match a {\n+        RustAbi => w.write_char('r'),\n+    }\n+}\n+\n fn enc_onceness(w: io::Writer, o: Onceness) {\n     match o {\n         Once => w.write_char('o'),\n         Many => w.write_char('m')\n     }\n }\n \n-fn enc_ty_fn(w: io::Writer, cx: @ctxt, ft: ty::FnTy) {\n-    enc_proto(w, ft.meta.proto);\n-    enc_purity(w, ft.meta.purity);\n-    enc_onceness(w, ft.meta.onceness);\n-    enc_region(w, cx, ft.meta.region);\n-    enc_bounds(w, cx, ft.meta.bounds);\n+fn enc_bare_fn_ty(w: io::Writer, cx: @ctxt, ft: &ty::BareFnTy) {\n+    enc_purity(w, ft.purity);\n+    enc_abi(w, ft.abi);\n+    enc_fn_sig(w, cx, &ft.sig);\n+}\n+\n+fn enc_closure_ty(w: io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n+    enc_sigil(w, ft.sigil);\n+    enc_purity(w, ft.purity);\n+    enc_onceness(w, ft.onceness);\n+    enc_region(w, cx, ft.region);\n+    enc_fn_sig(w, cx, &ft.sig);\n+}\n+\n+fn enc_fn_sig(w: io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n     w.write_char('[');\n-    for ft.sig.inputs.each |arg| {\n+    for fsig.inputs.each |arg| {\n         enc_arg(w, cx, *arg);\n     }\n     w.write_char(']');\n-    enc_ty(w, cx, ft.sig.output);\n+    enc_ty(w, cx, fsig.output);\n }\n \n pub fn enc_bounds(w: io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {"}, {"sha": "dfc26000116a6e1dd2243ac0258351a3bd013ae9", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -221,27 +221,31 @@ impl check_loan_ctxt {\n \n         let callee_ty = ty::node_id_to_type(tcx, callee_id);\n         match ty::get(callee_ty).sty {\n-          ty::ty_fn(ref fn_ty) => {\n-            match fn_ty.meta.purity {\n-              ast::pure_fn => return, // case (c) above\n-              ast::impure_fn | ast::unsafe_fn | ast::extern_fn => {\n-                self.report_purity_error(\n-                    pc, callee_span,\n-                    fmt!(\"access to %s function\",\n-                         fn_ty.meta.purity.to_str()));\n-              }\n+            ty::ty_bare_fn(ty::BareFnTy {purity: purity, _}) |\n+            ty::ty_closure(ty::ClosureTy {purity: purity, _}) => {\n+                match purity {\n+                    ast::pure_fn => return, // case (c) above\n+                    ast::impure_fn | ast::unsafe_fn | ast::extern_fn => {\n+                        self.report_purity_error(\n+                            pc, callee_span,\n+                            fmt!(\"access to %s function\",\n+                                 purity.to_str()));\n+                    }\n+                }\n             }\n-          }\n-          _ => return, // case (d) above\n+            _ => return, // case (d) above\n         }\n     }\n \n     // True if the expression with the given `id` is a stack closure.\n     // The expression must be an expr_fn(*) or expr_fn_block(*)\n     fn is_stack_closure(id: ast::node_id) -> bool {\n         let fn_ty = ty::node_id_to_type(self.tcx(), id);\n-        let proto = ty::ty_fn_proto(fn_ty);\n-        return proto == ast::ProtoBorrowed;\n+        match ty::get(fn_ty).sty {\n+            ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n+                                          _}) => true,\n+            _ => false\n+        }\n     }\n \n     fn is_allowed_pure_arg(expr: @ast::expr) -> bool {\n@@ -564,17 +568,27 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n {\n     let is_stack_closure = self.is_stack_closure(id);\n     let fty = ty::node_id_to_type(self.tcx(), id);\n-    let fty_proto = ty::ty_fn_proto(fty);\n \n-    check_moves_from_captured_variables(self, id, fty_proto);\n+    let declared_purity;\n+    match fk {\n+        visit::fk_item_fn(*) | visit::fk_method(*) |\n+        visit::fk_dtor(*) => {\n+            declared_purity = ty::ty_fn_purity(fty);\n+        }\n+\n+        visit::fk_anon(*) | visit::fk_fn_block(*) => {\n+            let fty_sigil = ty::ty_closure_sigil(fty);\n+            check_moves_from_captured_variables(self, id, fty_sigil);\n+            declared_purity = ty::determine_inherited_purity(\n+                copy self.declared_purity, ty::ty_fn_purity(fty),\n+                fty_sigil);\n+        }\n+    }\n \n     debug!(\"purity on entry=%?\", copy self.declared_purity);\n     do save_and_restore(&mut(self.declared_purity)) {\n         do save_and_restore(&mut(self.fn_args)) {\n-            self.declared_purity = ty::determine_inherited_purity(\n-                copy self.declared_purity,\n-                ty::ty_fn_purity(fty),\n-                fty_proto);\n+            self.declared_purity = declared_purity;\n \n             match fk {\n                 visit::fk_anon(*) |\n@@ -608,10 +622,10 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n \n     fn check_moves_from_captured_variables(&&self: check_loan_ctxt,\n                                            id: ast::node_id,\n-                                           fty_proto: ast::Proto)\n+                                           fty_sigil: ast::Sigil)\n     {\n-        match fty_proto {\n-            ast::ProtoBox | ast::ProtoUniq => {\n+        match fty_sigil {\n+            ast::ManagedSigil | ast::OwnedSigil => {\n                 let cap_vars = self.bccx.capture_map.get(&id);\n                 for cap_vars.each |cap_var| {\n                     match cap_var.mode {\n@@ -646,7 +660,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                 }\n             }\n \n-            ast::ProtoBorrowed | ast::ProtoBare => {}\n+            ast::BorrowedSigil => {}\n         }\n     }\n }"}, {"sha": "ad46d3b6f4de07e56d125c88460aab56e9346052", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -150,7 +150,7 @@ pub fn check_expr(sess: Session,\n               }\n             }\n           }\n-          expr_call(callee, _, false) => {\n+          expr_call(callee, _, NoSugar) => {\n             match def_map.find(&callee.id) {\n                 Some(def_struct(*)) => {}    // OK.\n                 Some(def_variant(*)) => {}    // OK."}, {"sha": "38450de6b540cabf4041571ea516bb81be1acb20", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -39,8 +39,8 @@ pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n                 (v.visit_block)((*b), {in_loop: false, can_ret: false}, v);\n               }\n               expr_loop_body(@expr {node: expr_fn_block(_, ref b), _}) => {\n-                let proto = ty::ty_fn_proto(ty::expr_ty(tcx, e));\n-                let blk = (proto == ProtoBorrowed);\n+                let sigil = ty::ty_closure_sigil(ty::expr_ty(tcx, e));\n+                let blk = (sigil == BorrowedSigil);\n                 (v.visit_block)((*b), {in_loop: true, can_ret: blk}, v);\n               }\n               expr_break(_) => {"}, {"sha": "6f9fe1edca5beed25cbde536ca611ffeecb4b1d3", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -100,7 +100,7 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n           }\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n-       let arms = vec::concat(vec::filter_map((*arms), unguarded_pat));\n+       let arms = vec::concat(arms.filter_mapped(unguarded_pat));\n        check_exhaustive(cx, ex.span, arms);\n      }\n      _ => ()\n@@ -255,7 +255,8 @@ pub fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: &[@pat]) -> useful {\n             }\n           }\n           Some(ref ctor) => {\n-            match is_useful(cx, vec::filter_map(m, |r| default(cx, copy *r)),\n+            match is_useful(cx,\n+                            vec::filter_map(m, |r| default(cx, r)),\n                             vec::tail(v)) {\n               useful_ => useful(left_ty, (/*bad*/copy *ctor)),\n               ref u => (/*bad*/copy *u)\n@@ -277,8 +278,7 @@ pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n                              arity: uint,\n                              lty: ty::t)\n                           -> useful {\n-    let ms = vec::filter_map(m, |r| specialize(cx, *r,\n-                                               ctor, arity, lty));\n+    let ms = m.filter_mapped(|r| specialize(cx, *r, ctor, arity, lty));\n     let could_be_useful = is_useful(\n         cx, ms, specialize(cx, v, ctor, arity, lty).get());\n     match could_be_useful {\n@@ -387,9 +387,9 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n       ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n \n         // Find the lengths and tails of all vector patterns.\n-        let vec_pat_lens = do m.filter_map |r| {\n-            match /*bad*/copy r[0].node {\n-                pat_vec(elems, tail) => {\n+        let vec_pat_lens = do m.filter_mapped |r| {\n+            match r[0].node {\n+                pat_vec(ref elems, ref tail) => {\n                     Some((elems.len(), tail.is_some()))\n                 }\n                 _ => None"}, {"sha": "e609107721048889ed6f19c07a7a986e10e0dc53", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -48,10 +48,8 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n \n     let walk_expr = fn@(expr: @ast::expr, &&depth: int, v: visit::vt<int>) {\n             match expr.node {\n-              ast::expr_fn(proto, _, _, _) => {\n-                if proto != ast::ProtoBare {\n-                    visit::visit_expr(expr, depth + 1, v);\n-                }\n+              ast::expr_fn(_, _, _, _) => {\n+                visit::visit_expr(expr, depth + 1, v);\n               }\n               ast::expr_fn_block(*) => {\n                 visit::visit_expr(expr, depth + 1, v);"}, {"sha": "35d5595fefd43508ff380a46e3074526c37e8362", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 17, "deletions": 41, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -150,11 +150,23 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n     }\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n-    match ty::ty_fn_proto(fty) {\n-        ProtoUniq => b(check_for_uniq),\n-        ProtoBox => b(check_for_box),\n-        ProtoBare => b(check_for_bare),\n-        ProtoBorrowed => b(check_for_block),\n+    match ty::get(fty).sty {\n+        ty::ty_closure(ty::ClosureTy {sigil: OwnedSigil, _}) => {\n+            b(check_for_uniq)\n+        }\n+        ty::ty_closure(ty::ClosureTy {sigil: ManagedSigil, _}) => {\n+            b(check_for_box)\n+        }\n+        ty::ty_closure(ty::ClosureTy {sigil: BorrowedSigil, _}) => {\n+            b(check_for_block)\n+        }\n+        ty::ty_bare_fn(_) => {\n+            b(check_for_bare)\n+        }\n+        ref s => {\n+            cx.tcx.sess.bug(\n+                fmt!(\"expect fn type in kind checker, not %?\", s));\n+        }\n     }\n }\n \n@@ -240,42 +252,6 @@ pub fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n                        expr.span,\n                        \"explicit copy requires a copyable argument\");\n         }\n-        expr_rec(ref fields, def) | expr_struct(_, ref fields, def) => {\n-            match def {\n-                Some(ex) => {\n-                    // All noncopyable fields must be overridden\n-                    let t = ty::expr_ty(cx.tcx, ex);\n-                    let ty_fields = match ty::get(t).sty {\n-                        ty::ty_rec(ref f) => {\n-                            copy *f\n-                        }\n-                        ty::ty_struct(did, ref substs) => {\n-                            ty::struct_fields(cx.tcx, did, substs)\n-                        }\n-                        _ => {\n-                            cx.tcx.sess.span_bug(\n-                                ex.span,\n-                                ~\"bad base expr type in record\")\n-                        }\n-                    };\n-                    for ty_fields.each |tf| {\n-                        // If this field would not be copied, ok.\n-                        if fields.any(|f| f.node.ident == tf.ident) { loop; }\n-\n-                        // If this field is copyable, ok.\n-                        let kind = ty::type_kind(cx.tcx, tf.mt.ty);\n-                        if ty::kind_can_be_copied(kind) { loop; }\n-\n-                        cx.tcx.sess.span_err(\n-                            e.span,\n-                            fmt!(\"cannot copy field `%s` of base expression, \\\n-                                  which has a noncopyable type\",\n-                                 *cx.tcx.sess.intr().get(tf.ident)));\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n         expr_repeat(element, count_expr, _) => {\n             let count = ty::eval_repeat_count(cx.tcx, count_expr, e.span);\n             if count > 1 {"}, {"sha": "51bbdfdc19cc357ba539165e30ff2615b4914813", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -897,9 +897,10 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n                              span: span, id: ast::node_id) {\n     match ty::get(fn_ty).sty {\n-        ty::ty_fn(ref fn_ty) => {\n+        ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) |\n+        ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) => {\n             let mut counter = 0;\n-            for vec::each2(fn_ty.sig.inputs, decl.inputs) |arg_ty, arg_ast| {\n+            for vec::each2(sig.inputs, decl.inputs) |arg_ty, arg_ast| {\n                 counter += 1;\n                 debug!(\"arg %d, ty=%s, mode=%s\",\n                        counter,\n@@ -938,13 +939,14 @@ fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n                 }\n \n                 match ty::get(arg_ty.ty).sty {\n-                    ty::ty_fn(*) => {\n+                    ty::ty_closure(*) | ty::ty_bare_fn(*) => {\n                         let span = arg_ast.ty.span;\n                         // Recurse to check fn-type argument\n                         match arg_ast.ty.node {\n-                            ast::ty_fn(f) => {\n+                            ast::ty_closure(@ast::TyClosure{decl: ref d, _}) |\n+                            ast::ty_bare_fn(@ast::TyBareFn{decl: ref d, _})=>{\n                                 check_fn_deprecated_modes(tcx, arg_ty.ty,\n-                                                          f.decl, span, id);\n+                                                          *d, span, id);\n                             }\n                             ast::ty_path(*) => {\n                                 // This is probably a typedef, so we can't\n@@ -976,10 +978,11 @@ fn check_item_deprecated_modes(tcx: ty::ctxt, it: @ast::item) {\n     match it.node {\n         ast::item_ty(ty, _) => {\n             match ty.node {\n-                ast::ty_fn(f) => {\n+                ast::ty_closure(@ast::TyClosure {decl: ref decl, _}) |\n+                ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n                     let fn_ty = ty::node_id_to_type(tcx, it.id);\n                     check_fn_deprecated_modes(\n-                        tcx, fn_ty, f.decl, ty.span, it.id)\n+                        tcx, fn_ty, *decl, ty.span, it.id)\n                 }\n                 _ => ()\n             }"}, {"sha": "07de99870964f2a494b17b3b19dfe7cd559c6c78", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 43, "deletions": 56, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -146,63 +146,55 @@ pub enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n // pointer adjustment).\n pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).sty {\n-      ty::ty_uniq(*) |\n-      ty::ty_evec(_, ty::vstore_uniq) |\n-      ty::ty_estr(ty::vstore_uniq) => {\n-        Some(deref_ptr(uniq_ptr))\n-      }\n-\n-      ty::ty_fn(ref f) if (*f).meta.proto == ast::ProtoUniq => {\n-        Some(deref_ptr(uniq_ptr))\n-      }\n-\n-      ty::ty_rptr(r, mt) |\n-      ty::ty_evec(mt, ty::vstore_slice(r)) => {\n-        Some(deref_ptr(region_ptr(mt.mutbl, r)))\n-      }\n-\n-      ty::ty_estr(ty::vstore_slice(r)) => {\n-        Some(deref_ptr(region_ptr(ast::m_imm, r)))\n-      }\n+        ty::ty_uniq(*) |\n+        ty::ty_evec(_, ty::vstore_uniq) |\n+        ty::ty_estr(ty::vstore_uniq) |\n+        ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n+            Some(deref_ptr(uniq_ptr))\n+        }\n \n-      ty::ty_fn(ref f) if (*f).meta.proto == ast::ProtoBorrowed => {\n-        Some(deref_ptr(region_ptr(ast::m_imm, (*f).meta.region)))\n-      }\n+        ty::ty_rptr(r, mt) |\n+        ty::ty_evec(mt, ty::vstore_slice(r)) => {\n+            Some(deref_ptr(region_ptr(mt.mutbl, r)))\n+        }\n \n-      ty::ty_box(mt) |\n-      ty::ty_evec(mt, ty::vstore_box) => {\n-        Some(deref_ptr(gc_ptr(mt.mutbl)))\n-      }\n+        ty::ty_estr(ty::vstore_slice(r)) |\n+        ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n+                                      region: r, _}) => {\n+            Some(deref_ptr(region_ptr(ast::m_imm, r)))\n+        }\n \n-      ty::ty_estr(ty::vstore_box) => {\n-        Some(deref_ptr(gc_ptr(ast::m_imm)))\n-      }\n+        ty::ty_box(mt) |\n+        ty::ty_evec(mt, ty::vstore_box) => {\n+            Some(deref_ptr(gc_ptr(mt.mutbl)))\n+        }\n \n-      ty::ty_fn(ref f) if (*f).meta.proto == ast::ProtoBox => {\n-        Some(deref_ptr(gc_ptr(ast::m_imm)))\n-      }\n+        ty::ty_estr(ty::vstore_box) |\n+        ty::ty_closure(ty::ClosureTy {sigil: ast::ManagedSigil, _}) => {\n+            Some(deref_ptr(gc_ptr(ast::m_imm)))\n+        }\n \n-      ty::ty_ptr(*) => {\n-        Some(deref_ptr(unsafe_ptr))\n-      }\n+        ty::ty_ptr(*) => {\n+            Some(deref_ptr(unsafe_ptr))\n+        }\n \n-      ty::ty_enum(did, _) => {\n-        Some(deref_comp(comp_variant(did)))\n-      }\n+        ty::ty_enum(did, _) => {\n+            Some(deref_comp(comp_variant(did)))\n+        }\n \n-      ty::ty_struct(_, _) => {\n-        Some(deref_comp(comp_anon_field))\n-      }\n+        ty::ty_struct(_, _) => {\n+            Some(deref_comp(comp_anon_field))\n+        }\n \n-      ty::ty_evec(mt, ty::vstore_fixed(_)) => {\n-        Some(deref_comp(comp_index(t, mt.mutbl)))\n-      }\n+        ty::ty_evec(mt, ty::vstore_fixed(_)) => {\n+            Some(deref_comp(comp_index(t, mt.mutbl)))\n+        }\n \n-      ty::ty_estr(ty::vstore_fixed(_)) => {\n-        Some(deref_comp(comp_index(t, m_imm)))\n-      }\n+        ty::ty_estr(ty::vstore_fixed(_)) => {\n+            Some(deref_comp(comp_index(t, m_imm)))\n+        }\n \n-      _ => None\n+        _ => None\n     }\n }\n \n@@ -473,9 +465,9 @@ pub impl &mem_categorization_ctxt {\n \n           ast::def_upvar(_, inner, fn_node_id, _) => {\n             let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n-            let proto = ty::ty_fn_proto(ty);\n-            match proto {\n-                ast::ProtoBorrowed => {\n+            let sigil = ty::ty_closure_sigil(ty);\n+            match sigil {\n+                ast::BorrowedSigil => {\n                     let upcmt = self.cat_def(id, span, expr_ty, *inner);\n                     @cmt_ {\n                         id:id,\n@@ -486,7 +478,7 @@ pub impl &mem_categorization_ctxt {\n                         ty:upcmt.ty\n                     }\n                 }\n-                ast::ProtoUniq | ast::ProtoBox => {\n+                ast::OwnedSigil | ast::ManagedSigil => {\n                     // FIXME #2152 allow mutation of moved upvars\n                     @cmt_ {\n                         id:id,\n@@ -497,11 +489,6 @@ pub impl &mem_categorization_ctxt {\n                         ty:expr_ty\n                     }\n                 }\n-                ast::ProtoBare => {\n-                    self.tcx.sess.span_bug(\n-                        span,\n-                        fmt!(\"Upvar in a bare closure?\"));\n-                }\n             }\n           }\n "}, {"sha": "aaa3156e27c2574ac947880f673cfb205a2429be", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -474,7 +474,35 @@ impl VisitContext {\n                 }\n \n                 for opt_with.each |with_expr| {\n-                    self.consume_expr(*with_expr, visitor);\n+                    // If there are any fields whose type is move-by-default,\n+                    // then `with` is consumed, otherwise it is only read\n+                    let with_ty = ty::expr_ty(self.tcx, *with_expr);\n+                    let with_fields = match ty::get(with_ty).sty {\n+                        ty::ty_rec(ref f) => copy *f,\n+                        ty::ty_struct(did, ref substs) => {\n+                            ty::struct_fields(self.tcx, did, substs)\n+                        }\n+                        ref r => {\n+                           self.tcx.sess.span_bug(\n+                                with_expr.span,\n+                                fmt!(\"bad base expr type in record: %?\", r))\n+                        }\n+                    };\n+\n+                    // The `with` expr must be consumed if it contains\n+                    // any fields which (1) were not explicitly\n+                    // specified and (2) have a type that\n+                    // moves-by-default:\n+                    let consume_with = with_fields.any(|tf| {\n+                        !fields.any(|f| f.node.ident == tf.ident) &&\n+                            ty::type_implicitly_moves(self.tcx, tf.mt.ty)\n+                    });\n+\n+                    if consume_with {\n+                        self.consume_expr(*with_expr, visitor);\n+                    } else {\n+                        self.use_expr(*with_expr, Read, visitor);\n+                    }\n                 }\n             }\n \n@@ -786,9 +814,9 @@ impl VisitContext {\n         let _indenter = indenter();\n \n         let fn_ty = ty::node_id_to_type(self.tcx, fn_expr_id);\n-        let proto = ty::ty_fn_proto(fn_ty);\n+        let sigil = ty::ty_closure_sigil(fn_ty);\n         let freevars = freevars::get_freevars(self.tcx, fn_expr_id);\n-        if proto == ProtoBorrowed {\n+        if sigil == BorrowedSigil {\n             // &fn() captures everything by ref\n             at_vec::from_fn(freevars.len(), |i| {\n                 let fvar = &freevars[i];"}, {"sha": "68e41b329e366ac2ef1755c3e2f3fff63f935da9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -657,7 +657,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n             }\n         }\n \n-        ast::ty_fn(f) => {\n+        ast::ty_closure(ref f) => {\n             debug!(\"referenced fn type: %s\",\n                    pprust::ty_to_str(ty, cx.sess.intr()));\n             match f.region {\n@@ -668,7 +668,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n                     }\n                 }\n                 None => {\n-                    if f.proto == ast::ProtoBorrowed && cx.anon_implies_rp {\n+                    if f.sigil == ast::BorrowedSigil && cx.anon_implies_rp {\n                         cx.add_rp(cx.item_id,\n                                   cx.add_variance(rv_contravariant));\n                     }\n@@ -732,18 +732,18 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n         }\n       }\n \n-      ast::ty_fn(f) => {\n+      ast::ty_closure(@ast::TyClosure {decl: ref decl, _}) |\n+      ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n         // fn() binds the & region, so do not consider &T types that\n         // appear *inside* a fn() type to affect the enclosing item:\n         do cx.with(cx.item_id, false) {\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n-                for f.decl.inputs.each |a| {\n+                for decl.inputs.each |a| {\n                     (visitor.visit_ty)(a.ty, cx, visitor);\n                 }\n             }\n-            visit::visit_ty_param_bounds(f.bounds, cx, visitor);\n-            (visitor.visit_ty)(f.decl.output, cx, visitor);\n+            (visitor.visit_ty)(decl.output, cx, visitor);\n         }\n       }\n "}, {"sha": "ebd6d9f905642d9622f5ff202bb6a03a1a09d734", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -1652,7 +1652,7 @@ pub fn trans_match_inner(scope_cx: block,\n         // insert bindings into the lllocals map and add cleanups\n         bcx = insert_lllocals(bcx, *arm_data, true);\n \n-        bcx = controlflow::trans_block(bcx, arm_data.arm.body, dest);\n+        bcx = controlflow::trans_block(bcx, &arm_data.arm.body, dest);\n         bcx = trans_block_cleanups(bcx, block_cleanups(arm_data.bodycx));\n         arm_cxs.push(bcx);\n     }"}, {"sha": "588e2916e47e3c49ec9abe342906259103e3f1cc", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -613,7 +613,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         let ccx = cx.ccx();\n         let mut cx = cx;\n         match ty::get(fn_ty).sty {\n-          ty::ty_fn(ref fn_ty) => {\n+          ty::ty_bare_fn(ref fn_ty) => {\n             let mut j = 0u;\n             let v_id = variant.id;\n             for vec::each(fn_ty.sig.inputs) |a| {\n@@ -777,10 +777,10 @@ pub fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did).to_managed(); // Sad\n     match ty::get(t).sty {\n-      ty::ty_fn(_) => {\n+      ty::ty_bare_fn(_) | ty::ty_closure(_) => {\n         let llty = type_of_fn_from_ty(ccx, t);\n         return get_extern_fn(ccx.externs, ccx.llmod, name,\n-                          lib::llvm::CCallConv, llty);\n+                             lib::llvm::CCallConv, llty);\n       }\n       _ => {\n         let llty = type_of(ccx, t);\n@@ -1363,7 +1363,7 @@ pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<node_info>,\n     DatumBlock {bcx: leave_block(bcx, scope_cx), datum: datum}\n }\n \n-pub fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n+pub fn block_locals(b: &ast::blk, it: fn(@ast::local)) {\n     for vec::each(b.node.stmts) |s| {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n@@ -1727,8 +1727,8 @@ pub enum self_arg { impl_self(ty::t), impl_owned_self(ty::t), no_self, }\n // returned.\n pub fn trans_closure(ccx: @crate_ctxt,\n                      +path: path,\n-                     decl: ast::fn_decl,\n-                     body: ast::blk,\n+                     decl: &ast::fn_decl,\n+                     body: &ast::blk,\n                      llfndecl: ValueRef,\n                      ty_self: self_arg,\n                      +param_substs: Option<param_substs>,\n@@ -1791,8 +1791,8 @@ pub fn trans_closure(ccx: @crate_ctxt,\n // function.\n pub fn trans_fn(ccx: @crate_ctxt,\n                 +path: path,\n-                decl: ast::fn_decl,\n-                body: ast::blk,\n+                decl: &ast::fn_decl,\n+                body: &ast::blk,\n                 llfndecl: ValueRef,\n                 ty_self: self_arg,\n                 +param_substs: Option<param_substs>,\n@@ -1935,7 +1935,7 @@ pub fn trans_tuple_struct(ccx: @crate_ctxt,\n \n pub fn trans_struct_dtor(ccx: @crate_ctxt,\n                          +path: path,\n-                         body: ast::blk,\n+                         body: &ast::blk,\n                          dtor_id: ast::node_id,\n                          +psubsts: Option<param_substs>,\n                          hash_id: Option<mono_id>,\n@@ -1966,8 +1966,9 @@ pub fn trans_struct_dtor(ccx: @crate_ctxt,\n     ccx.monomorphized.insert(*h_id, lldecl);\n   }\n   /* Translate the dtor body */\n-  trans_fn(ccx, path, ast_util::dtor_dec(),\n-           body, lldecl, impl_self(class_ty), psubsts, dtor_id, None);\n+  let decl = ast_util::dtor_dec();\n+  trans_fn(ccx, path, &decl, body, lldecl,\n+           impl_self(class_ty), psubsts, dtor_id, None);\n   lldecl\n }\n \n@@ -2013,20 +2014,19 @@ pub fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         _ => die!(~\"trans_item\"),\n     };\n     match /*bad*/copy item.node {\n-      // XXX: Bad copies.\n-      ast::item_fn(copy decl, purity, copy tps, ref body) => {\n+      ast::item_fn(ref decl, purity, ref tps, ref body) => {\n         if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_foreign_fn(ccx,\n                                      vec::append(\n                                          /*bad*/copy *path,\n                                          ~[path_name(item.ident)]),\n-                                     decl, (*body), llfndecl, item.id);\n+                                      decl, body, llfndecl, item.id);\n         } else if tps.is_empty() {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n                      vec::append(/*bad*/copy *path, ~[path_name(item.ident)]),\n-                     decl, (*body), llfndecl, no_self, None, item.id, None);\n+                     decl, body, llfndecl, no_self, None, item.id, None);\n         } else {\n             for vec::each((*body).node.stmts) |stmt| {\n                 match stmt.node {\n@@ -2078,7 +2078,7 @@ pub fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                         id: ast::node_id) {\n     // Translate the destructor.\n     do option::iter(&struct_def.dtor) |dtor| {\n-        trans_struct_dtor(ccx, /*bad*/copy *path, dtor.node.body,\n+        trans_struct_dtor(ccx, /*bad*/copy *path, &dtor.node.body,\n                          dtor.node.id, None, None, local_def(id));\n     };\n "}, {"sha": "4af74b3623f5ada7108f24dd8a9236d19b04dfad", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -627,18 +627,17 @@ pub fn trans_arg_expr(bcx: block,\n         Some(_) => {\n             match arg_expr.node {\n                 ast::expr_loop_body(\n-                    // XXX: Bad copy.\n-                    blk@@ast::expr {\n-                        node: ast::expr_fn_block(copy decl, ref body),\n+                    blk @ @ast::expr {\n+                        node: ast::expr_fn_block(ref decl, ref body),\n                         _\n                     }) =>\n                 {\n                     let scratch_ty = expr_ty(bcx, arg_expr);\n                     let scratch = alloc_ty(bcx, scratch_ty);\n                     let arg_ty = expr_ty(bcx, arg_expr);\n-                    let proto = ty::ty_fn_proto(arg_ty);\n+                    let sigil = ty::ty_closure_sigil(arg_ty);\n                     let bcx = closure::trans_expr_fn(\n-                        bcx, proto, decl, /*bad*/copy *body, arg_expr.id,\n+                        bcx, sigil, decl, body, arg_expr.id,\n                         blk.id, Some(ret_flag), expr::SaveIn(scratch));\n                     DatumBlock {bcx: bcx,\n                                 datum: Datum {val: scratch,"}, {"sha": "c70425da9fa39cdfbc57be8ba0fd5b263d036df8", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 54, "deletions": 62, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -160,7 +160,7 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     return cdata_ty;\n }\n \n-pub fn allocate_cbox(bcx: block, proto: ast::Proto, cdata_ty: ty::t)\n+pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n                   -> Result {\n     let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n@@ -176,23 +176,19 @@ pub fn allocate_cbox(bcx: block, proto: ast::Proto, cdata_ty: ty::t)\n     }\n \n     // Allocate and initialize the box:\n-    match proto {\n-        ast::ProtoBox => {\n+    match sigil {\n+        ast::ManagedSigil => {\n             malloc_raw(bcx, cdata_ty, heap_shared)\n         }\n-        ast::ProtoUniq => {\n+        ast::OwnedSigil => {\n             malloc_raw(bcx, cdata_ty, heap_exchange)\n         }\n-        ast::ProtoBorrowed => {\n+        ast::BorrowedSigil => {\n             let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n             let llbox = base::alloc_ty(bcx, cbox_ty);\n             nuke_ref_count(bcx, llbox);\n             rslt(bcx, llbox)\n         }\n-        ast::ProtoBare => {\n-            let cdata_llty = type_of(bcx.ccx(), cdata_ty);\n-            rslt(bcx, C_null(cdata_llty))\n-        }\n     }\n }\n \n@@ -208,7 +204,7 @@ pub type closure_result = {\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n pub fn store_environment(bcx: block,\n                          bound_values: ~[EnvValue],\n-                         proto: ast::Proto) -> closure_result {\n+                         sigil: ast::Sigil) -> closure_result {\n     let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n@@ -217,7 +213,7 @@ pub fn store_environment(bcx: block,\n     let cdata_ty = mk_closure_tys(tcx, copy bound_values);\n \n     // allocate closure in the heap\n-    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, proto, cdata_ty);\n+    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, sigil, cdata_ty);\n     let mut temp_cleanups = ~[];\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n@@ -265,7 +261,7 @@ pub fn store_environment(bcx: block,\n // collects the upvars and packages them up for store_environment.\n pub fn build_closure(bcx0: block,\n                      cap_vars: &[moves::CaptureVar],\n-                     proto: ast::Proto,\n+                     sigil: ast::Sigil,\n                      include_ret_handle: Option<ValueRef>) -> closure_result {\n     let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n@@ -279,7 +275,7 @@ pub fn build_closure(bcx0: block,\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n             moves::CapRef => {\n-                assert proto == ast::ProtoBorrowed;\n+                assert sigil == ast::BorrowedSigil;\n                 env_vals.push(EnvValue {action: EnvRef,\n                                         datum: datum});\n             }\n@@ -316,7 +312,7 @@ pub fn build_closure(bcx0: block,\n                                 datum: ret_datum});\n     }\n \n-    return store_environment(bcx, env_vals, proto);\n+    return store_environment(bcx, env_vals, sigil);\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n@@ -326,7 +322,7 @@ pub fn load_environment(fcx: fn_ctxt,\n                         cdata_ty: ty::t,\n                         cap_vars: &[moves::CaptureVar],\n                         load_ret_handle: bool,\n-                        proto: ast::Proto) {\n+                        sigil: ast::Sigil) {\n     let _icx = fcx.insn_ctxt(\"closure::load_environment\");\n \n     let llloadenv = match fcx.llloadenv {\n@@ -352,9 +348,9 @@ pub fn load_environment(fcx: fn_ctxt,\n     let mut i = 0u;\n     for cap_vars.each |cap_var| {\n         let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n-        match proto {\n-            ast::ProtoBorrowed => { upvarptr = Load(bcx, upvarptr); }\n-            ast::ProtoBox | ast::ProtoUniq | ast::ProtoBare => {}\n+        match sigil {\n+            ast::BorrowedSigil => { upvarptr = Load(bcx, upvarptr); }\n+            ast::ManagedSigil | ast::OwnedSigil => {}\n         }\n         let def_id = ast_util::def_id_of_def(cap_var.def);\n         fcx.llupvars.insert(def_id.node, upvarptr);\n@@ -369,9 +365,9 @@ pub fn load_environment(fcx: fn_ctxt,\n }\n \n pub fn trans_expr_fn(bcx: block,\n-                     proto: ast::Proto,\n-                     +decl: ast::fn_decl,\n-                     +body: ast::blk,\n+                     sigil: ast::Sigil,\n+                     decl: &ast::fn_decl,\n+                     body: &ast::blk,\n                      outer_id: ast::node_id,\n                      user_id: ast::node_id,\n                      is_loop_body: Option<Option<ValueRef>>,\n@@ -381,7 +377,7 @@ pub fn trans_expr_fn(bcx: block,\n      *\n      * Translates the body of a closure expression.\n      *\n-     * - `proto`\n+     * - `sigil`\n      * - `decl`\n      * - `body`\n      * - `outer_id`: The id of the closure expression with the correct\n@@ -417,53 +413,49 @@ pub fn trans_expr_fn(bcx: block,\n                                                  ~\"expr_fn\");\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n-    let Result {bcx: bcx, val: closure} = match proto {\n-        ast::ProtoBorrowed | ast::ProtoBox | ast::ProtoUniq => {\n+    let Result {bcx: bcx, val: closure} = match sigil {\n+        ast::BorrowedSigil | ast::ManagedSigil | ast::OwnedSigil => {\n             let cap_vars = ccx.maps.capture_map.get(&user_id);\n             let ret_handle = match is_loop_body {Some(x) => x,\n                                                  None => None};\n-            let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, proto,\n+            let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, sigil,\n                                                        ret_handle);\n             trans_closure(ccx, sub_path, decl,\n                           body, llfn, no_self,\n                           /*bad*/ copy bcx.fcx.param_substs, user_id, None,\n                           |fcx| load_environment(fcx, cdata_ty, cap_vars,\n-                                                 ret_handle.is_some(), proto),\n+                                                 ret_handle.is_some(), sigil),\n                           |bcx| {\n                               if is_loop_body.is_some() {\n                                   Store(bcx, C_bool(true), bcx.fcx.llretptr);\n                               }\n                           });\n             rslt(bcx, llbox)\n         }\n-        ast::ProtoBare => {\n-            trans_closure(ccx, sub_path, decl, body, llfn, no_self, None,\n-                          user_id, None, |_fcx| { }, |_bcx| { });\n-            rslt(bcx, C_null(T_opaque_box_ptr(ccx)))\n-        }\n     };\n     fill_fn_pair(bcx, dest_addr, llfn, closure);\n \n     return bcx;\n }\n \n-pub fn make_fn_glue(cx: block,\n-                    v: ValueRef,\n-                    t: ty::t,\n-                    glue_fn: fn@(block, v: ValueRef, t: ty::t) -> block)\n-                 -> block {\n-    let _icx = cx.insn_ctxt(\"closure::make_fn_glue\");\n+pub fn make_closure_glue(\n+    cx: block,\n+    v: ValueRef,\n+    t: ty::t,\n+    glue_fn: fn@(block, v: ValueRef, t: ty::t) -> block) -> block\n+{\n+    let _icx = cx.insn_ctxt(\"closure::make_closure_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n \n-    let proto = ty::ty_fn_proto(t);\n-    match proto {\n-        ast::ProtoBare | ast::ProtoBorrowed => bcx,\n-        ast::ProtoUniq | ast::ProtoBox => {\n+    let sigil = ty::ty_closure_sigil(t);\n+    match sigil {\n+        ast::BorrowedSigil => bcx,\n+        ast::OwnedSigil | ast::ManagedSigil => {\n             let box_cell_v = GEPi(cx, v, [0u, abi::fn_field_box]);\n             let box_ptr_v = Load(cx, box_cell_v);\n             do with_cond(cx, IsNotNull(cx, box_ptr_v)) |bcx| {\n-                let closure_ty = ty::mk_opaque_closure_ptr(tcx, proto);\n+                let closure_ty = ty::mk_opaque_closure_ptr(tcx, sigil);\n                 glue_fn(bcx, box_cell_v, closure_ty)\n             }\n         }\n@@ -472,20 +464,20 @@ pub fn make_fn_glue(cx: block,\n \n pub fn make_opaque_cbox_take_glue(\n     bcx: block,\n-    proto: ast::Proto,\n+    sigil: ast::Sigil,\n     cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n     // Easy cases:\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_take_glue\");\n-    match proto {\n-        ast::ProtoBare | ast::ProtoBorrowed => {\n+    match sigil {\n+        ast::BorrowedSigil => {\n             return bcx;\n         }\n-        ast::ProtoBox => {\n+        ast::ManagedSigil => {\n             glue::incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr));\n             return bcx;\n         }\n-        ast::ProtoUniq => {\n+        ast::OwnedSigil => {\n             /* hard case: fallthrough to code below */\n         }\n     }\n@@ -531,36 +523,36 @@ pub fn make_opaque_cbox_take_glue(\n \n pub fn make_opaque_cbox_drop_glue(\n     bcx: block,\n-    proto: ast::Proto,\n+    sigil: ast::Sigil,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n     -> block {\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n-    match proto {\n-        ast::ProtoBare | ast::ProtoBorrowed => bcx,\n-        ast::ProtoBox => {\n+    match sigil {\n+        ast::BorrowedSigil => bcx,\n+        ast::ManagedSigil => {\n             glue::decr_refcnt_maybe_free(\n                 bcx, Load(bcx, cboxptr),\n-                ty::mk_opaque_closure_ptr(bcx.tcx(), proto))\n+                ty::mk_opaque_closure_ptr(bcx.tcx(), sigil))\n         }\n-        ast::ProtoUniq => {\n+        ast::OwnedSigil => {\n             glue::free_ty(\n                 bcx, cboxptr,\n-                ty::mk_opaque_closure_ptr(bcx.tcx(), proto))\n+                ty::mk_opaque_closure_ptr(bcx.tcx(), sigil))\n         }\n     }\n }\n \n pub fn make_opaque_cbox_free_glue(\n     bcx: block,\n-    proto: ast::Proto,\n+    sigil: ast::Sigil,\n     cbox: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_free_glue\");\n-    match proto {\n-        ast::ProtoBare | ast::ProtoBorrowed => {\n+    match sigil {\n+        ast::BorrowedSigil => {\n             return bcx;\n         }\n-        ast::ProtoBox | ast::ProtoUniq => {\n+        ast::ManagedSigil | ast::OwnedSigil => {\n             /* hard cases: fallthrough to code below */\n         }\n     }\n@@ -580,10 +572,10 @@ pub fn make_opaque_cbox_free_glue(\n                                     abi::tydesc_field_drop_glue, None);\n \n         // Free the ty descr (if necc) and the box itself\n-        match proto {\n-            ast::ProtoBox => glue::trans_free(bcx, cbox),\n-            ast::ProtoUniq => glue::trans_unique_free(bcx, cbox),\n-            ast::ProtoBare | ast::ProtoBorrowed => {\n+        match sigil {\n+            ast::ManagedSigil => glue::trans_free(bcx, cbox),\n+            ast::OwnedSigil => glue::trans_unique_free(bcx, cbox),\n+            ast::BorrowedSigil => {\n                 bcx.sess().bug(~\"impossible\")\n             }\n         }"}, {"sha": "0933eedd5e4bb0e91ef96b569f6897ca5f947c60", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -23,7 +23,7 @@ pub fn macros() {\n     include!(\"macros.rs\");\n }\n \n-pub fn trans_block(bcx: block, b: ast::blk, dest: expr::Dest) -> block {\n+pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     do block_locals(b) |local| {\n@@ -47,7 +47,7 @@ pub fn trans_block(bcx: block, b: ast::blk, dest: expr::Dest) -> block {\n \n pub fn trans_if(bcx: block,\n             cond: @ast::expr,\n-            thn: ast::blk,\n+            thn: &ast::blk,\n             els: Option<@ast::expr>,\n             dest: expr::Dest)\n          -> block {\n@@ -82,10 +82,10 @@ pub fn trans_if(bcx: block,\n         match elexpr.node {\n           ast::expr_if(_, _, _) => {\n             let elseif_blk = ast_util::block_from_expr(elexpr);\n-            trans_block(else_bcx_in, elseif_blk, dest)\n+            trans_block(else_bcx_in, &elseif_blk, dest)\n           }\n           ast::expr_block(ref blk) => {\n-            trans_block(else_bcx_in, (*blk), dest)\n+            trans_block(else_bcx_in, blk, dest)\n           }\n           // would be nice to have a constraint on ifs\n           _ => bcx.tcx().sess.bug(~\"strange alternative in if\")\n@@ -114,7 +114,7 @@ pub fn join_blocks(parent_bcx: block, in_cxs: ~[block]) -> block {\n     return out;\n }\n \n-pub fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk) -> block {\n+pub fn trans_while(bcx: block, cond: @ast::expr, body: &ast::blk) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_while\");\n     let next_bcx = sub_block(bcx, ~\"while next\");\n \n@@ -154,7 +154,7 @@ pub fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk) -> block {\n }\n \n pub fn trans_loop(bcx:block,\n-                  body: ast::blk,\n+                  body: &ast::blk,\n                   opt_label: Option<ident>)\n                -> block {\n     let _icx = bcx.insn_ctxt(\"trans_loop\");"}, {"sha": "f2da47eb0eccaf4b16b2cddd1c42813d961f54c1", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 22, "deletions": 49, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -475,10 +475,10 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n             return controlflow::trans_check_expr(bcx, expr, a, ~\"Assertion\");\n         }\n         ast::expr_while(cond, ref body) => {\n-            return controlflow::trans_while(bcx, cond, (*body));\n+            return controlflow::trans_while(bcx, cond, body);\n         }\n         ast::expr_loop(ref body, opt_label) => {\n-            return controlflow::trans_loop(bcx, (*body), opt_label);\n+            return controlflow::trans_loop(bcx, body, opt_label);\n         }\n         ast::expr_assign(dst, src) => {\n             let src_datum = unpack_datum!(\n@@ -530,7 +530,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n                                             bcx.def(expr.id), dest);\n         }\n         ast::expr_if(cond, ref thn, els) => {\n-            return controlflow::trans_if(bcx, cond, *thn, els, dest);\n+            return controlflow::trans_if(bcx, cond, thn, els, dest);\n         }\n         ast::expr_match(discr, ref arms) => {\n             return _match::trans_match(bcx, expr, discr, /*bad*/copy *arms,\n@@ -539,7 +539,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_block(ref blk) => {\n             return do base::with_scope(bcx, blk.info(),\n                                        ~\"block-expr body\") |bcx| {\n-                controlflow::trans_block(bcx, (*blk), dest)\n+                controlflow::trans_block(bcx, blk, dest)\n             };\n         }\n         ast::expr_rec(ref fields, base) |\n@@ -562,58 +562,31 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_vec(*) | ast::expr_repeat(*) => {\n             return tvec::trans_fixed_vstore(bcx, expr, expr, dest);\n         }\n-        // XXX: Bad copy.\n-        ast::expr_fn(proto, copy decl, ref body, _) => {\n-            // Don't use this function for anything real. Use the one in\n-            // astconv instead.\n-            return closure::trans_expr_fn(bcx, proto, decl,\n-                                          /*bad*/copy *body,\n-                                          expr.id, expr.id,\n-                                          None, dest);\n-        }\n+        ast::expr_fn(_, ref decl, ref body, _) |\n         ast::expr_fn_block(ref decl, ref body) => {\n             let expr_ty = expr_ty(bcx, expr);\n-            match ty::get(expr_ty).sty {\n-                ty::ty_fn(ref fn_ty) => {\n-                    debug!(\"translating fn_block %s with type %s\",\n-                           expr_to_str(expr, tcx.sess.intr()),\n-                           ty_to_str(tcx, expr_ty));\n-                    return closure::trans_expr_fn(\n-                        bcx, fn_ty.meta.proto, /*bad*/copy *decl,\n-                        /*bad*/copy *body, expr.id, expr.id,\n-                        None, dest);\n-                }\n-                _ => {\n-                    bcx.sess().impossible_case(\n-                        expr.span, \"fn_block has body with a non-fn type\");\n-                }\n-            }\n+            let sigil = ty::ty_closure_sigil(expr_ty);\n+            debug!(\"translating fn_block %s with type %s\",\n+                   expr_to_str(expr, tcx.sess.intr()),\n+                   ty_to_str(tcx, expr_ty));\n+            return closure::trans_expr_fn(bcx, sigil, decl, body,\n+                                          expr.id, expr.id,\n+                                          None, dest);\n         }\n         ast::expr_loop_body(blk) => {\n-            match ty::get(expr_ty(bcx, expr)).sty {\n-                ty::ty_fn(ref fn_ty) => {\n-                    match blk.node {\n-                        ast::expr_fn_block(copy decl, ref body) => {\n-                            return closure::trans_expr_fn(\n-                                bcx,\n-                                fn_ty.meta.proto,\n-                                decl,\n-                                /*bad*/copy *body,\n-                                expr.id,\n-                                blk.id,\n-                                Some(None),\n-                                dest);\n-                        }\n-                        _ => {\n-                            bcx.sess().impossible_case(\n-                                expr.span,\n-                                \"loop_body has the wrong kind of contents\")\n-                        }\n-                    }\n+            let expr_ty = expr_ty(bcx, expr);\n+            let sigil = ty::ty_closure_sigil(expr_ty);\n+            match blk.node {\n+                ast::expr_fn_block(ref decl, ref body) => {\n+                    return closure::trans_expr_fn(bcx, sigil,\n+                                                  decl, body,\n+                                                  expr.id, blk.id,\n+                                                  Some(None), dest);\n                 }\n                 _ => {\n                     bcx.sess().impossible_case(\n-                        expr.span, \"loop_body has body with a non-fn type\")\n+                        expr.span,\n+                        \"loop_body has the wrong kind of contents\")\n                 }\n             }\n         }"}, {"sha": "bb14fce805354784ff4f12b74c6f80faf34438c8", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -31,7 +31,7 @@ use middle::trans::machine;\n use middle::trans::shape;\n use middle::trans::type_of::*;\n use middle::trans::type_of;\n-use middle::ty::{FnTyBase, FnMeta, FnSig, arg};\n+use middle::ty::{FnSig, arg};\n use util::ppaux::ty_to_str;\n \n use core::libc::c_uint;\n@@ -66,10 +66,8 @@ type c_stack_tys = {\n fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n                        id: ast::node_id) -> (~[TypeRef], TypeRef, ty::t) {\n     match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n-        ty::ty_fn(ref fn_ty) => {\n-            let llargtys = type_of_explicit_args(\n-                ccx,\n-                fn_ty.sig.inputs);\n+        ty::ty_bare_fn(ref fn_ty) => {\n+            let llargtys = type_of_explicit_args(ccx, fn_ty.sig.inputs);\n             let llretty = type_of::type_of(ccx, fn_ty.sig.output);\n             (llargtys, llretty, fn_ty.sig.output)\n         }\n@@ -541,12 +539,11 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n             let star_u8 = ty::mk_imm_ptr(\n                 bcx.tcx(),\n                 ty::mk_mach_uint(bcx.tcx(), ast::ty_u8));\n-            let fty = ty::mk_fn(bcx.tcx(), FnTyBase {\n-                meta: FnMeta {purity: ast::impure_fn,\n-                              proto: ast::ProtoBorrowed,\n-                              onceness: ast::Many,\n-                              region: ty::re_bound(ty::br_anon(0)),\n-                              bounds: @~[]},\n+            let fty = ty::mk_closure(bcx.tcx(), ty::ClosureTy {\n+                purity: ast::impure_fn,\n+                sigil: ast::BorrowedSigil,\n+                onceness: ast::Many,\n+                region: ty::re_bound(ty::br_anon(0)),\n                 sig: FnSig {inputs: ~[arg {mode: ast::expl(ast::by_copy),\n                                            ty: star_u8}],\n                             output: ty::mk_nil(bcx.tcx())}\n@@ -843,14 +840,14 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n \n pub fn trans_foreign_fn(ccx: @crate_ctxt,\n                         +path: ast_map::path,\n-                        decl: ast::fn_decl,\n-                        body: ast::blk,\n+                        decl: &ast::fn_decl,\n+                        body: &ast::blk,\n                         llwrapfn: ValueRef,\n                         id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n \n     fn build_rust_fn(ccx: @crate_ctxt, +path: ast_map::path,\n-                     decl: ast::fn_decl, body: ast::blk,\n+                     decl: &ast::fn_decl, body: &ast::blk,\n                      id: ast::node_id) -> ValueRef {\n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);"}, {"sha": "564460fd88e9b9a85a6e55d9cbc34965fd0caa43", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -172,7 +172,8 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n \n     if field == abi::tydesc_field_free_glue {\n         match ty::get(t).sty {\n-          ty::ty_fn(*) |\n+          ty::ty_bare_fn(*) |\n+          ty::ty_closure(*) |\n           ty::ty_box(*) |\n           ty::ty_opaque_box |\n           ty::ty_uniq(*) |\n@@ -419,8 +420,8 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n                        tvec::expand_boxed_vec_ty(bcx.tcx(), t));\n         return;\n       }\n-      ty::ty_fn(_) => {\n-        closure::make_fn_glue(bcx, v, t, free_ty)\n+      ty::ty_closure(_) => {\n+        closure::make_closure_glue(bcx, v, t, free_ty)\n       }\n       ty::ty_opaque_closure_ptr(ck) => {\n         closure::make_opaque_cbox_free_glue(bcx, ck, v)\n@@ -528,8 +529,8 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n           }\n         }\n       }\n-      ty::ty_fn(_) => {\n-        closure::make_fn_glue(bcx, v0, t, drop_ty)\n+      ty::ty_closure(_) => {\n+        closure::make_closure_glue(bcx, v0, t, drop_ty)\n       }\n       ty::ty_trait(_, _, ty::vstore_box) => {\n         let llbox = Load(bcx, GEPi(bcx, v0, [0u, 1u]));\n@@ -594,8 +595,8 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n       | ty::ty_estr(ty::vstore_slice(_)) => {\n         bcx\n       }\n-      ty::ty_fn(_) => {\n-        closure::make_fn_glue(bcx, v, t, take_ty)\n+      ty::ty_closure(_) => {\n+        closure::make_closure_glue(bcx, v, t, take_ty)\n       }\n       ty::ty_trait(_, _, ty::vstore_box) => {\n         let llbox = Load(bcx, GEPi(bcx, v, [0u, 1u]));"}, {"sha": "c094db4ecca1f501cf3e431ab3074b61a9c25410", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -108,8 +108,8 @@ pub fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id,\n                 };\n                 trans_fn(ccx,\n                          path,\n-                         mth.decl,\n-                         mth.body,\n+                         &mth.decl,\n+                         &mth.body,\n                          llfn,\n                          self_kind,\n                          None,"}, {"sha": "828b561939055e60be503f07c318679a799b1fe5", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -34,8 +34,11 @@ pub fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           ty::ty_box(_) | ty::ty_opaque_box | ty::ty_uniq(_) |\n           ty::ty_evec(_, ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_box) |\n           ty::ty_estr(ty::vstore_uniq) | ty::ty_estr(ty::vstore_box) |\n-          ty::ty_ptr(_) | ty::ty_rptr(_,_) => nilptr(tcx),\n-          ty::ty_fn(_) => ty::mk_tup(tcx, ~[nilptr(tcx), nilptr(tcx)]),\n+          ty::ty_ptr(_) | ty::ty_rptr(*) => nilptr(tcx),\n+\n+          ty::ty_bare_fn(*) | // FIXME(#4804) Bare fn repr\n+          ty::ty_closure(*) => ty::mk_tup(tcx, ~[nilptr(tcx), nilptr(tcx)]),\n+\n           ty::ty_evec(_, ty::vstore_slice(_)) |\n           ty::ty_estr(ty::vstore_slice(_)) => {\n             ty::mk_tup(tcx, ~[nilptr(tcx), ty::mk_int(tcx)])"}, {"sha": "1d48d2dde6bc5051a2463057dc67bdc00ee4d024", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -142,8 +142,8 @@ pub fn trans_method(ccx: @crate_ctxt,\n     // generate the actual code\n     trans_fn(ccx,\n              path,\n-             method.decl,\n-             method.body,\n+             &method.decl,\n+             &method.body,\n              llfn,\n              self_arg,\n              param_substs,\n@@ -822,7 +822,7 @@ pub fn make_impl_vtable(ccx: @crate_ctxt,\n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n     make_vtable(ccx, vec::map(*ty::trait_methods(tcx, trt_id), |im| {\n         let fty = ty::subst_tps(tcx, substs, None,\n-                                ty::mk_fn(tcx, copy im.fty));\n+                                ty::mk_bare_fn(tcx, copy im.fty));\n         if (*im.tps).len() > 0u || ty::type_has_self(fty) {\n             debug!(\"(making impl vtable) method has self or type params: %s\",\n                    tcx.sess.str_of(im.ident));"}, {"sha": "b09a41f2b7f06bb088891649d8b90d557e6c5650", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -26,7 +26,7 @@ use middle::trans::shape;\n use middle::trans::type_of::type_of_fn_from_ty;\n use middle::trans::type_of;\n use middle::trans::type_use;\n-use middle::ty::{FnTyBase, FnMeta, FnSig};\n+use middle::ty::{FnSig};\n use middle::typeck;\n \n use core::option;\n@@ -166,12 +166,12 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n     let lldecl = match map_node {\n       ast_map::node_item(i@@ast::item {\n                 // XXX: Bad copy.\n-                node: ast::item_fn(copy decl, _, _, ref body),\n+                node: ast::item_fn(ref decl, _, _, ref body),\n                 _\n             }, _) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(/*bad*/copy i.attrs, d);\n-        trans_fn(ccx, pt, decl, *body, d, no_self, psubsts, fn_id.node, None);\n+        trans_fn(ccx, pt, decl, body, d, no_self, psubsts, fn_id.node, None);\n         d\n       }\n       ast_map::node_item(*) => {\n@@ -224,7 +224,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n                 None      => ccx.sess.span_bug(dtor.span, ~\"Bad self ty in \\\n                                                             dtor\")\n         };\n-        trans_struct_dtor(ccx, /*bad*/copy *pt, dtor.node.body,\n+        trans_struct_dtor(ccx, /*bad*/copy *pt, &dtor.node.body,\n           dtor.node.id, psubsts, Some(hash_id), parent_id)\n       }\n       ast_map::node_trait_method(@ast::provided(mth), _, pt) => {\n@@ -267,38 +267,55 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n                                       ty: ty::t) -> Option<ty::t> {\n     // FIXME[mono] could do this recursively. is that worthwhile? (#2529)\n-    match ty::get(ty).sty {\n+    return match ty::get(ty).sty {\n         ty::ty_box(*) => {\n             Some(ty::mk_opaque_box(tcx))\n         }\n-        ty::ty_fn(ref fty) => {\n-            Some(ty::mk_fn(\n+        ty::ty_bare_fn(_) => {\n+            Some(ty::mk_bare_fn(\n                 tcx,\n-                FnTyBase {meta: FnMeta {purity: ast::impure_fn,\n-                                        proto: fty.meta.proto,\n-                                        onceness: ast::Many,\n-                                        region: ty::re_static,\n-                                        bounds: @~[]},\n-                          sig: FnSig {inputs: ~[],\n-                                      output: ty::mk_nil(tcx)}}))\n+                ty::BareFnTy {\n+                    purity: ast::impure_fn,\n+                    abi: ast::RustAbi,\n+                    sig: FnSig {inputs: ~[],\n+                                output: ty::mk_nil(tcx)}}))\n         }\n-        ty::ty_trait(_, _, _) => {\n-            Some(ty::mk_fn(\n-                tcx,\n-                FnTyBase {meta: FnMeta {purity: ast::impure_fn,\n-                                        proto: ast::ProtoBox,\n-                                        onceness: ast::Many,\n-                                        region: ty::re_static,\n-                                        bounds: @~[]},\n-                          sig: FnSig {inputs: ~[],\n-                                      output: ty::mk_nil(tcx)}}))\n+        ty::ty_closure(ref fty) => {\n+            Some(normalized_closure_ty(tcx, fty.sigil))\n+        }\n+        ty::ty_trait(_, _, ref vstore) => {\n+            let sigil = match *vstore {\n+                ty::vstore_uniq => ast::OwnedSigil,\n+                ty::vstore_box => ast::ManagedSigil,\n+                ty::vstore_slice(_) => ast::BorrowedSigil,\n+                ty::vstore_fixed(*) => {\n+                    tcx.sess.bug(fmt!(\"ty_trait with vstore_fixed\"));\n+                }\n+            };\n+\n+            // Traits have the same runtime representation as closures.\n+            Some(normalized_closure_ty(tcx, sigil))\n         }\n         ty::ty_ptr(_) => {\n             Some(ty::mk_uint(tcx))\n         }\n         _ => {\n             None\n         }\n+    };\n+\n+    fn normalized_closure_ty(tcx: ty::ctxt,\n+                             sigil: ast::Sigil) -> ty::t\n+    {\n+        ty::mk_closure(\n+            tcx,\n+            ty::ClosureTy {\n+                purity: ast::impure_fn,\n+                sigil: sigil,\n+                onceness: ast::Many,\n+                region: ty::re_static,\n+                sig: ty::FnSig {inputs: ~[],\n+                                output: ty::mk_nil(tcx)}})\n     }\n }\n "}, {"sha": "9466099904c1ac5e9c9cb15230ca417d026fa90d", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 57, "deletions": 36, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -86,9 +86,8 @@ pub impl reflector {\n             tcx.sess.ident_of(~\"visit_\" + ty_name),\n             *self.visitor_methods).expect(fmt!(\"Couldn't find visit method \\\n                                                 for %s\", ty_name));\n-        let mth_ty = ty::mk_fn(\n-            tcx,\n-            /*bad*/copy self.visitor_methods[mth_idx].fty);\n+        let mth_ty =\n+            ty::mk_bare_fn(tcx, copy self.visitor_methods[mth_idx].fty);\n         let v = self.visitor_val;\n         debug!(\"passing %u args:\", vec::len(args));\n         let bcx = self.bcx;\n@@ -211,39 +210,33 @@ pub impl reflector {\n             }\n           }\n \n+          // FIXME (#2594): fetch constants out of intrinsic\n+          // FIXME (#4809): visitor should break out bare fns from other fns\n+          ty::ty_closure(ref fty) => {\n+            let pureval = ast_purity_constant(fty.purity);\n+            let sigilval = ast_sigil_constant(fty.sigil);\n+            let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n+            let extra = ~[self.c_uint(pureval),\n+                          self.c_uint(sigilval),\n+                          self.c_uint(vec::len(fty.sig.inputs)),\n+                          self.c_uint(retval)];\n+            self.visit(~\"enter_fn\", copy extra);    // XXX: Bad copy.\n+            self.visit_sig(retval, &fty.sig);\n+            self.visit(~\"leave_fn\", extra);\n+          }\n+\n           // FIXME (#2594): fetch constants out of intrinsic:: for the\n           // numbers.\n-          ty::ty_fn(ref fty) => {\n-            let pureval = match fty.meta.purity {\n-              ast::pure_fn => 0u,\n-              ast::unsafe_fn => 1u,\n-              ast::impure_fn => 2u,\n-              ast::extern_fn => 3u\n-            };\n-            let protoval = ast_proto_constant(fty.meta.proto);\n+          ty::ty_bare_fn(ref fty) => {\n+            let pureval = ast_purity_constant(fty.purity);\n+            let sigilval = 0u;\n             let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n             let extra = ~[self.c_uint(pureval),\n-                          self.c_uint(protoval),\n+                          self.c_uint(sigilval),\n                           self.c_uint(vec::len(fty.sig.inputs)),\n                           self.c_uint(retval)];\n             self.visit(~\"enter_fn\", copy extra);    // XXX: Bad copy.\n-            for fty.sig.inputs.eachi |i, arg| {\n-                let modeval = match arg.mode {\n-                  ast::infer(_) => 0u,\n-                  ast::expl(e) => match e {\n-                    ast::by_ref => 1u,\n-                    ast::by_val => 2u,\n-                    ast::by_copy => 5u\n-                  }\n-                };\n-                self.visit(~\"fn_input\",\n-                           ~[self.c_uint(i),\n-                             self.c_uint(modeval),\n-                             self.c_tydesc(arg.ty)]);\n-            }\n-            self.visit(~\"fn_output\",\n-                       ~[self.c_uint(retval),\n-                         self.c_tydesc(fty.sig.output)]);\n+            self.visit_sig(retval, &fty.sig);\n             self.visit(~\"leave_fn\", extra);\n           }\n \n@@ -302,11 +295,31 @@ pub impl reflector {\n           ty::ty_type => self.leaf(~\"type\"),\n           ty::ty_opaque_box => self.leaf(~\"opaque_box\"),\n           ty::ty_opaque_closure_ptr(ck) => {\n-            let ckval = ast_proto_constant(ck);\n+            let ckval = ast_sigil_constant(ck);\n             self.visit(~\"closure_ptr\", ~[self.c_uint(ckval)])\n           }\n         }\n     }\n+\n+    fn visit_sig(&self, retval: uint, sig: &ty::FnSig) {\n+        for sig.inputs.eachi |i, arg| {\n+            let modeval = match arg.mode {\n+                ast::infer(_) => 0u,\n+                ast::expl(e) => match e {\n+                    ast::by_ref => 1u,\n+                    ast::by_val => 2u,\n+                    ast::by_copy => 5u\n+                }\n+            };\n+            self.visit(~\"fn_input\",\n+                       ~[self.c_uint(i),\n+                         self.c_uint(modeval),\n+                         self.c_tydesc(arg.ty)]);\n+        }\n+        self.visit(~\"fn_output\",\n+                   ~[self.c_uint(retval),\n+                     self.c_tydesc(sig.output)]);\n+    }\n }\n \n // Emit a sequence of calls to visit_ty::visit_foo\n@@ -332,12 +345,20 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n     return final;\n }\n \n-pub fn ast_proto_constant(proto: ast::Proto) -> uint {\n-    match proto {\n-        ast::ProtoBare => 0u,\n-        ast::ProtoUniq => 2u,\n-        ast::ProtoBox => 3u,\n-        ast::ProtoBorrowed => 4u,\n+pub fn ast_sigil_constant(sigil: ast::Sigil) -> uint {\n+    match sigil {\n+        ast::OwnedSigil => 2u,\n+        ast::ManagedSigil => 3u,\n+        ast::BorrowedSigil => 4u,\n+    }\n+}\n+\n+pub fn ast_purity_constant(purity: ast::purity) -> uint {\n+    match purity {\n+        ast::pure_fn => 0u,\n+        ast::unsafe_fn => 1u,\n+        ast::impure_fn => 2u,\n+        ast::extern_fn => 3u\n     }\n }\n "}, {"sha": "f727b5a2de07454ac91b98f95992c1b86d329d2d", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -59,7 +59,13 @@ pub fn type_of_fn(cx: @crate_ctxt, inputs: &[ty::arg],\n \n // Given a function type and a count of ty params, construct an llvm type\n pub fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t) -> TypeRef {\n-    type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty))\n+    match ty::get(fty).sty {\n+        ty::ty_closure(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n+        ty::ty_bare_fn(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n+        _ => {\n+            cx.sess.bug(~\"type_of_fn_from_ty given non-closure, non-bare-fn\")\n+        }\n+    }\n }\n \n pub fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n@@ -170,7 +176,11 @@ pub fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         // structs\n         T_struct(~[T_struct(tys)])\n       }\n-      ty::ty_fn(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n+\n+      // FIXME(#4804) Bare fn repr\n+      // ty::ty_bare_fn(_) => T_ptr(type_of_fn_from_ty(cx, t)),\n+      ty::ty_bare_fn(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n+      ty::ty_closure(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n       ty::ty_trait(_, _, vstore) => T_opaque_trait(cx, vstore),\n       ty::ty_type => T_ptr(cx.tydesc_type),\n       ty::ty_tup(elts) => {"}, {"sha": "3fd334c2d15082a778fde4af19f4b3c5db933b3f", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -69,8 +69,9 @@ pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n \n     let cx = {ccx: ccx, uses: vec::cast_to_mut(vec::from_elem(n_tps, 0u))};\n     match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n-        ty::ty_fn(ref fn_ty) => {\n-            for vec::each(fn_ty.sig.inputs) |arg| {\n+        ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n+        ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n+            for vec::each(sig.inputs) |arg| {\n                 match ty::resolved_mode(ccx.tcx, arg.mode) {\n                     by_val | by_copy => {\n                         type_needs(cx, use_repr, arg.ty);\n@@ -197,8 +198,12 @@ pub fn type_needs_inner(cx: ctx,\n                  it, we depend on the drop glue for T (we have to write the\n                  right tydesc into the result)\n                  */\n-              ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _)\n-               | ty::ty_trait(_, _, _) => false,\n+                ty::ty_closure(*) |\n+                ty::ty_bare_fn(*) |\n+                ty::ty_ptr(_) |\n+                ty::ty_rptr(_, _) |\n+                ty::ty_trait(_, _, _) => false,\n+\n               ty::ty_enum(did, ref substs) => {\n                 if option::is_none(&list::find(enums_seen, |id| *id == did)) {\n                     let seen = @Cons(did, enums_seen);\n@@ -287,15 +292,15 @@ pub fn mark_for_expr(cx: ctx, e: @expr) {\n         }\n       }\n       expr_fn(*) | expr_fn_block(*) => {\n-        match ty::ty_fn_proto(ty::expr_ty(cx.ccx.tcx, e)) {\n-          ast::ProtoBare | ast::ProtoUniq => {}\n-          ast::ProtoBox | ast::ProtoBorrowed => {\n-            for vec::each(*freevars::get_freevars(cx.ccx.tcx, e.id)) |fv| {\n-                let node_id = ast_util::def_id_of_def(fv.def).node;\n-                node_type_needs(cx, use_repr, node_id);\n-            }\n+          match ty::ty_closure_sigil(ty::expr_ty(cx.ccx.tcx, e)) {\n+              ast::OwnedSigil => {}\n+              ast::BorrowedSigil | ast::ManagedSigil => {\n+                  for freevars::get_freevars(cx.ccx.tcx, e.id).each |fv| {\n+                      let node_id = ast_util::def_id_of_def(fv.def).node;\n+                      node_type_needs(cx, use_repr, node_id);\n+                  }\n+              }\n           }\n-        }\n       }\n       expr_assign(val, _) | expr_swap(val, _) | expr_assign_op(_, val, _) |\n       expr_ret(Some(val)) => {"}, {"sha": "ef62fb3caf18ab199e5cbdd449f3f46b96eb5655", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 179, "deletions": 359, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[warn(deprecated_pattern)];\n-\n use core::prelude::*;\n \n use driver::session;\n@@ -27,7 +25,7 @@ use middle;\n use session::Session;\n use util::ppaux::{note_and_explain_region, bound_region_to_str};\n use util::ppaux::{region_to_str, explain_region, vstore_to_str};\n-use util::ppaux::{ty_to_str, proto_ty_to_str, tys_to_str};\n+use util::ppaux::{ty_to_str, tys_to_str};\n \n use core::cast;\n use core::cmp;\n@@ -73,7 +71,7 @@ pub type param_bounds = @~[param_bound];\n pub type method = {\n     ident: ast::ident,\n     tps: @~[param_bounds],\n-    fty: FnTy,\n+    fty: BareFnTy,\n     self_ty: ast::self_ty_,\n     vis: ast::visibility,\n     def_id: ast::def_id\n@@ -344,22 +342,20 @@ pub pure fn type_contains_err(t: t) -> bool {\n pub pure fn type_def_id(t: t) -> Option<ast::def_id> { get(t).o_def_id }\n pub pure fn type_id(t: t) -> uint { get(t).id }\n \n-/**\n- * Meta information about a closure.\n- *\n- * - `purity` is the function's effect (pure, impure, unsafe).\n- * - `proto` is the protocol (fn@, fn~, etc).\n- * - `onceness` indicates whether the function can be called one time or many\n- *   times.\n- * - `region` is the region bound on the function's upvars (often &static).\n- * - `bounds` is the parameter bounds on the function's upvars. */\n #[deriving_eq]\n-pub struct FnMeta {\n+pub struct BareFnTy {\n+    purity: ast::purity,\n+    abi: Abi,\n+    sig: FnSig\n+}\n+\n+#[deriving_eq]\n+pub struct ClosureTy {\n     purity: ast::purity,\n-    proto: ast::Proto,\n+    sigil: ast::Sigil,\n     onceness: ast::Onceness,\n     region: Region,\n-    bounds: @~[param_bound]\n+    sig: FnSig\n }\n \n /**\n@@ -374,25 +370,19 @@ pub struct FnSig {\n     output: t\n }\n \n-/**\n- * Function type: combines the meta information and the\n- * type signature.  This particular type is parameterized\n- * by the meta information because, in some cases, the\n- * meta information is inferred. */\n-#[deriving_eq]\n-pub struct FnTyBase<M> {\n-    meta: M,        // Either FnMeta or FnVid\n-    sig: FnSig      // Types of arguments/return type\n+impl BareFnTy : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_3(&self.purity, &self.abi, &self.sig, lsb0, f)\n+    }\n }\n \n-impl<M: to_bytes::IterBytes> FnTyBase<M> : to_bytes::IterBytes {\n+impl ClosureTy : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.meta, &self.sig, lsb0, f)\n+        to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n+                               &self.region, &self.sig, lsb0, f)\n     }\n }\n \n-pub type FnTy = FnTyBase<FnMeta>;\n-\n #[deriving_eq]\n pub struct param_ty {\n     idx: uint,\n@@ -491,6 +481,7 @@ pub struct substs {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n+#[deriving_eq]\n pub enum sty {\n     ty_nil,\n     ty_bot,\n@@ -506,7 +497,8 @@ pub enum sty {\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n     ty_rec(~[field]),\n-    ty_fn(FnTy),\n+    ty_bare_fn(BareFnTy),\n+    ty_closure(ClosureTy),\n     ty_trait(def_id, substs, vstore),\n     ty_struct(def_id, substs),\n     ty_tup(~[t]),\n@@ -522,7 +514,7 @@ pub enum sty {\n     // \"Fake\" types, used for trans purposes\n     ty_type, // type_desc*\n     ty_opaque_box, // used by monomorphizer to represent any @ box\n-    ty_opaque_closure_ptr(ast::Proto), // ptr to env for fn, fn@, fn~\n+    ty_opaque_closure_ptr(Sigil), // ptr to env for fn, fn@, fn~\n     ty_unboxed_vec(mt),\n }\n \n@@ -546,8 +538,9 @@ pub enum type_err {\n     terr_mismatch,\n     terr_purity_mismatch(expected_found<purity>),\n     terr_onceness_mismatch(expected_found<Onceness>),\n+    terr_abi_mismatch(expected_found<ast::Abi>),\n     terr_mutability,\n-    terr_proto_mismatch(expected_found<ast::Proto>),\n+    terr_sigil_mismatch(expected_found<ast::Sigil>),\n     terr_box_mutability,\n     terr_ptr_mutability,\n     terr_ref_mutability,\n@@ -744,6 +737,15 @@ pub impl RegionVid : to_bytes::IterBytes {\n     }\n }\n \n+pub fn kind_to_param_bounds(kind: Kind) -> param_bounds {\n+    let mut bounds = ~[];\n+    if kind_can_be_copied(kind) { bounds.push(bound_copy); }\n+    if kind_can_be_sent(kind) { bounds.push(bound_owned); }\n+    else if kind_is_durable(kind) { bounds.push(bound_durable); }\n+    if kind_is_const(kind) { bounds.push(bound_const); }\n+    return @bounds;\n+}\n+\n pub fn param_bounds_to_kind(bounds: param_bounds) -> Kind {\n     let mut kind = kind_noncopyable();\n     for vec::each(*bounds) |bound| {\n@@ -925,8 +927,12 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       }\n       &ty_rec(ref flds) => for flds.each |f| { flags |= get(f.mt.ty).flags; },\n       &ty_tup(ref ts) => for ts.each |tt| { flags |= get(*tt).flags; },\n-      &ty_fn(ref f) => {\n-        flags |= rflags(f.meta.region);\n+      &ty_bare_fn(ref f) => {\n+        for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n+        flags |= get(f.sig.output).flags;\n+      }\n+      &ty_closure(ref f) => {\n+        flags |= rflags(f.region);\n         for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n         flags |= get(f.sig.output).flags;\n       }\n@@ -1044,8 +1050,25 @@ pub fn mk_rec(cx: ctxt, +fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n \n pub fn mk_tup(cx: ctxt, +ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n-// take a copy because we want to own the various vectors inside\n-pub fn mk_fn(cx: ctxt, +fty: FnTy) -> t { mk_t(cx, ty_fn(fty)) }\n+pub fn mk_closure(cx: ctxt, +fty: ClosureTy) -> t {\n+    mk_t(cx, ty_closure(fty))\n+}\n+\n+pub fn mk_bare_fn(cx: ctxt, +fty: BareFnTy) -> t {\n+    mk_t(cx, ty_bare_fn(fty))\n+}\n+\n+pub fn mk_ctor_fn(cx: ctxt, input_tys: &[ty::t], output: ty::t) -> t {\n+    let input_args = input_tys.map(|t| arg {mode: ast::expl(ast::by_copy),\n+                                            ty: *t});\n+    mk_bare_fn(cx,\n+               BareFnTy {\n+                   purity: ast::pure_fn,\n+                   abi: ast::RustAbi,\n+                   sig: FnSig {inputs: input_args,\n+                               output: output}})\n+}\n+\n \n pub fn mk_trait(cx: ctxt, did: ast::def_id, +substs: substs, vstore: vstore)\n          -> t {\n@@ -1074,8 +1097,8 @@ pub fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n \n pub fn mk_type(cx: ctxt) -> t { mk_t(cx, ty_type) }\n \n-pub fn mk_opaque_closure_ptr(cx: ctxt, proto: ast::Proto) -> t {\n-    mk_t(cx, ty_opaque_closure_ptr(proto))\n+pub fn mk_opaque_closure_ptr(cx: ctxt, sigil: ast::Sigil) -> t {\n+    mk_t(cx, ty_opaque_closure_ptr(sigil))\n }\n \n pub fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n@@ -1097,13 +1120,11 @@ pub pure fn mach_sty(cfg: @session::config, t: t) -> sty {\n pub fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n         // FIXME(#2202) --- We retain by-ref for fn& things to workaround a\n         // memory leak that otherwise results when @fn is upcast to &fn.\n-    if type_is_fn(ty) {\n-        match ty_fn_proto(ty) {\n-            ast::ProtoBorrowed => {\n-                return ast::by_ref;\n-            }\n-            _ => {}\n+    match ty::get(ty).sty {\n+        ty::ty_closure(ClosureTy {sigil: ast::BorrowedSigil, _}) => {\n+            return ast::by_ref;\n         }\n+        _ => {}\n     }\n     return if tcx.legacy_modes {\n         if type_is_borrowed(ty) {\n@@ -1119,13 +1140,6 @@ pub fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n         ast::by_copy\n     };\n \n-    fn type_is_fn(ty: t) -> bool {\n-        match get(ty).sty {\n-            ty_fn(*) => true,\n-            _ => false\n-        }\n-    }\n-\n     fn type_is_borrowed(ty: t) -> bool {\n         match ty::get(ty).sty {\n             ty::ty_rptr(*) => true,\n@@ -1171,7 +1185,11 @@ pub fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n         for fields.each |fl| { maybe_walk_ty(fl.mt.ty, f); }\n       }\n       ty_tup(ts) => { for ts.each |tt| { maybe_walk_ty(*tt, f); } }\n-      ty_fn(ref ft) => {\n+      ty_bare_fn(ref ft) => {\n+        for ft.sig.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n+        maybe_walk_ty(ft.sig.output, f);\n+      }\n+      ty_closure(ref ft) => {\n         for ft.sig.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n@@ -1235,9 +1253,13 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n             let new_ts = vec::map(ts, |tt| fldop(*tt));\n             ty_tup(new_ts)\n         }\n-        ty_fn(ref f) => {\n+        ty_bare_fn(ref f) => {\n+            let sig = fold_sig(&f.sig, fldop);\n+            ty_bare_fn(BareFnTy {sig: sig, abi: f.abi, purity: f.purity})\n+        }\n+        ty_closure(ref f) => {\n             let sig = fold_sig(&f.sig, fldop);\n-            ty_fn(FnTyBase {meta: f.meta, sig: sig})\n+            ty_closure(ClosureTy {sig: sig, ..copy *f})\n         }\n         ty_rptr(r, tm) => {\n             ty_rptr(r, mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n@@ -1318,41 +1340,21 @@ pub fn fold_regions_and_ty(\n       ty_trait(def_id, ref substs, vst) => {\n         ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), vst)\n       }\n-      ty_fn(ref f) => {\n-          ty::mk_fn(cx, FnTyBase {meta: FnMeta {region: fldr(f.meta.region),\n-                                                ..f.meta},\n-                                  sig: fold_sig(&f.sig, fldfnt)})\n+      ty_bare_fn(ref f) => {\n+          ty::mk_bare_fn(cx, BareFnTy {sig: fold_sig(&f.sig, fldfnt),\n+                                       ..copy *f})\n+      }\n+      ty_closure(ref f) => {\n+          ty::mk_closure(cx, ClosureTy {region: fldr(f.region),\n+                                        sig: fold_sig(&f.sig, fldfnt),\n+                                        ..copy *f})\n       }\n       ref sty => {\n         fold_sty_to_ty(cx, sty, |t| fldt(t))\n       }\n     }\n }\n \n-/* A little utility: it often happens that I have a `fn_ty`,\n- * but I want to use some function like `fold_regions_and_ty()`\n- * that is defined over all types.  This utility converts to\n- * a full type and back.  It's not the best way to do this (somewhat\n- * inefficient to do the conversion), it would be better to refactor\n- * all this folding business.  However, I've been waiting on that\n- * until trait support is improved. */\n-pub fn apply_op_on_t_to_ty_fn(\n-    cx: ctxt,\n-    f: &FnTy,\n-    t_op: fn(t) -> t) -> FnTy\n-{\n-    let t0 = ty::mk_fn(cx, /*bad*/copy *f);\n-    let t1 = t_op(t0);\n-    match ty::get(t1).sty {\n-        ty::ty_fn(copy f) => {\n-            move f\n-        }\n-        _ => {\n-            cx.sess.bug(~\"`t_op` did not return a function type\");\n-        }\n-    }\n-}\n-\n // n.b. this function is intended to eventually replace fold_region() below,\n // that is why its name is so similar.\n pub fn fold_regions(\n@@ -1372,41 +1374,6 @@ pub fn fold_regions(\n     do_fold(cx, ty, false, fldr)\n }\n \n-pub fn fold_region(cx: ctxt, t0: t, fldop: fn(Region, bool) -> Region) -> t {\n-    fn do_fold(cx: ctxt, t0: t, under_r: bool,\n-               fldop: fn(Region, bool) -> Region) -> t {\n-        let tb = get(t0);\n-        if !tbox_has_flag(tb, has_regions) { return t0; }\n-        match tb.sty {\n-          ty_rptr(r, mt {ty: t1, mutbl: m}) => {\n-            let m_r = fldop(r, under_r);\n-            let m_t1 = do_fold(cx, t1, true, fldop);\n-            ty::mk_rptr(cx, m_r, mt {ty: m_t1, mutbl: m})\n-          }\n-          ty_estr(vstore_slice(r)) => {\n-            let m_r = fldop(r, under_r);\n-            ty::mk_estr(cx, vstore_slice(m_r))\n-          }\n-          ty_evec(mt {ty: t1, mutbl: m}, vstore_slice(r)) => {\n-            let m_r = fldop(r, under_r);\n-            let m_t1 = do_fold(cx, t1, true, fldop);\n-            ty::mk_evec(cx, mt {ty: m_t1, mutbl: m}, vstore_slice(m_r))\n-          }\n-          ty_fn(_) => {\n-            // do not recurse into functions, which introduce fresh bindings\n-            t0\n-          }\n-          ref sty => {\n-            do fold_sty_to_ty(cx, sty) |t| {\n-                do_fold(cx, t, under_r, fldop)\n-            }\n-          }\n-      }\n-    }\n-\n-    do_fold(cx, t0, false, fldop)\n-}\n-\n // Substitute *only* type parameters.  Used in trans where regions are erased.\n pub fn subst_tps(cx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n     if tps.len() == 0u && self_ty_opt.is_none() { return typ; }\n@@ -1529,7 +1496,9 @@ pub fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n \n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_rec(_) | ty_struct(*) | ty_tup(_) | ty_enum(*) | ty_fn(_) |\n+      ty_rec(_) | ty_struct(*) | ty_tup(_) | ty_enum(*) |\n+      ty_closure(_) |\n+      ty_bare_fn(_) | // FIXME(#4804) Bare fn repr\n       ty_trait(*) |\n       ty_evec(_, vstore_fixed(_)) | ty_estr(vstore_fixed(_)) |\n       ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_))\n@@ -1715,10 +1684,11 @@ pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n         }\n         accum\n       }\n-      ty_fn(ref fty) => {\n-        match fty.meta.proto {\n-          ast::ProtoBare | ast::ProtoBorrowed => false,\n-          ast::ProtoBox | ast::ProtoUniq => true,\n+      ty_bare_fn(*) => false,\n+      ty_closure(ref fty) => {\n+        match fty.sigil {\n+          ast::BorrowedSigil => false,\n+          ast::ManagedSigil | ast::OwnedSigil => true,\n         }\n       }\n     };\n@@ -1813,7 +1783,7 @@ pub enum Kind { kind_(u32) }\n const KIND_MASK_COPY         : u32 = 0b000000000000000000000000001_u32;\n \n /// no shared box, borrowed ptr (must imply DURABLE)\n-const KIND_MASK_OWNED         : u32 = 0b000000000000000000000000010_u32;\n+const KIND_MASK_OWNED        : u32 = 0b000000000000000000000000010_u32;\n \n /// is durable (no borrowed ptrs)\n const KIND_MASK_DURABLE      : u32 = 0b000000000000000000000000100_u32;\n@@ -1942,20 +1912,25 @@ pub pure fn kind_is_durable(k: Kind) -> bool {\n     *k & KIND_MASK_DURABLE == KIND_MASK_DURABLE\n }\n \n-pub fn meta_kind(p: FnMeta) -> Kind {\n-    match p.proto { // XXX consider the kind bounds!\n-        ast::ProtoBare => {\n-            kind_safe_for_default_mode_send() | kind_const() | kind_durable()\n-        }\n-        ast::ProtoBorrowed => {\n-            kind_noncopyable() | kind_(KIND_MASK_DEFAULT_MODE)\n-        }\n-        ast::ProtoBox => {\n-            kind_safe_for_default_mode() | kind_durable()\n-        }\n-        ast::ProtoUniq => {\n-            kind_owned_copy() | kind_durable()\n-        }\n+pure fn kind_is_const(k: Kind) -> bool {\n+    *k & KIND_MASK_CONST == KIND_MASK_CONST\n+}\n+\n+fn closure_kind(cty: &ClosureTy) -> Kind {\n+    let kind = match cty.sigil {\n+        ast::BorrowedSigil => kind_implicitly_copyable(),\n+        ast::ManagedSigil => kind_implicitly_copyable(),\n+        ast::OwnedSigil => kind_owned_only() | kind_durable(),\n+    };\n+\n+    let kind = match cty.region {\n+        re_static => kind | kind_durable(),\n+        _ => kind - kind_owned_only() - kind_durable()\n+    };\n+\n+    match cty.onceness {\n+        ast::Once => kind - kind_implicitly_copyable(),\n+        ast::Many => kind\n     }\n }\n \n@@ -2022,7 +1997,7 @@ pub fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n     let mut result = match /*bad*/copy get(ty).sty {\n       // Scalar and unique types are sendable, constant, and owned\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_ptr(_) => {\n+      ty_bare_fn(_) | ty_ptr(_) => {\n         kind_safe_for_default_mode_send() | kind_const() | kind_durable()\n       }\n \n@@ -2035,8 +2010,9 @@ pub fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n         }\n       }\n \n-      // functions depend on the protocol\n-      ty_fn(ref f) => meta_kind(f.meta),\n+      ty_closure(ref c) => {\n+          closure_kind(c)\n+      }\n \n       // Those with refcounts raise noncopyable to copyable,\n       // lower sendable to copyable. Therefore just set result to copyable.\n@@ -2215,7 +2191,8 @@ fn type_size(cx: ctxt, ty: t) -> uint {\n \n       ty_evec(_, vstore_slice(_)) |\n       ty_estr(vstore_slice(_)) |\n-      ty_fn(_) => {\n+      ty_bare_fn(*) |\n+      ty_closure(*) => {\n         2\n       }\n \n@@ -2297,7 +2274,8 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_uint(_) |\n           ty_float(_) |\n           ty_estr(_) |\n-          ty_fn(_) |\n+          ty_bare_fn(_) |\n+          ty_closure(_) |\n           ty_infer(_) |\n           ty_err |\n           ty_param(_) |\n@@ -2472,9 +2450,9 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     match /*bad*/copy get(ty).sty {\n       // Scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_type | ty_ptr(_) => result = true,\n+      ty_type | ty_ptr(_) | ty_bare_fn(_) => result = true,\n       // Boxed types\n-      ty_box(_) | ty_uniq(_) | ty_fn(_) |\n+      ty_box(_) | ty_uniq(_) | ty_closure(_) |\n       ty_estr(vstore_uniq) | ty_estr(vstore_box) |\n       ty_evec(_, vstore_uniq) | ty_evec(_, vstore_box) |\n       ty_trait(_, _, _) | ty_rptr(_,_) | ty_opaque_box => result = false,\n@@ -2700,14 +2678,9 @@ impl arg : to_bytes::IterBytes {\n     }\n }\n \n-impl FnMeta : to_bytes::IterBytes {\n+impl Kind : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_5(&self.purity,\n-                               &self.proto,\n-                               &self.onceness,\n-                               &self.region,\n-                               &self.bounds,\n-                               lsb0, f);\n+        (**self).iter_bytes(lsb0, f)\n     }\n }\n \n@@ -2755,7 +2728,7 @@ impl sty : to_bytes::IterBytes {\n           ty_rec(ref fs) =>\n           to_bytes::iter_bytes_2(&11u8, fs, lsb0, f),\n \n-          ty_fn(ref ft) =>\n+          ty_bare_fn(ref ft) =>\n           to_bytes::iter_bytes_2(&12u8, ft, lsb0, f),\n \n           ty_self => 13u8.iter_bytes(lsb0, f),\n@@ -2789,7 +2762,10 @@ impl sty : to_bytes::IterBytes {\n           ty_rptr(ref r, ref mt) =>\n           to_bytes::iter_bytes_3(&24u8, r, mt, lsb0, f),\n \n-          ty_err => 25u8.iter_bytes(lsb0, f)\n+          ty_err => 25u8.iter_bytes(lsb0, f),\n+\n+          ty_closure(ref ct) =>\n+          to_bytes::iter_bytes_2(&26u8, ct, lsb0, f),\n         }\n     }\n }\n@@ -2823,36 +2799,48 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n // Type accessors for substructures of types\n pub fn ty_fn_args(fty: t) -> ~[arg] {\n     match get(fty).sty {\n-      ty_fn(ref f) => /*bad*/copy f.sig.inputs,\n-      _ => die!(~\"ty_fn_args() called on non-fn type\")\n+        ty_bare_fn(ref f) => copy f.sig.inputs,\n+        ty_closure(ref f) => copy f.sig.inputs,\n+        ref s => {\n+            die!(fmt!(\"ty_fn_args() called on non-fn type: %?\", s))\n+        }\n     }\n }\n \n-pub fn ty_fn_proto(fty: t) -> Proto {\n+pub fn ty_closure_sigil(fty: t) -> Sigil {\n     match get(fty).sty {\n-      ty_fn(ref f) => f.meta.proto,\n-      _ => die!(~\"ty_fn_proto() called on non-fn type\")\n+        ty_closure(ref f) => f.sigil,\n+        ref s => {\n+            die!(fmt!(\"ty_closure_sigil() called on non-closure type: %?\", s))\n+        }\n     }\n }\n \n pub fn ty_fn_purity(fty: t) -> ast::purity {\n     match get(fty).sty {\n-      ty_fn(ref f) => f.meta.purity,\n-      _ => die!(~\"ty_fn_purity() called on non-fn type\")\n+        ty_bare_fn(ref f) => f.purity,\n+        ty_closure(ref f) => f.purity,\n+        ref s => {\n+            die!(fmt!(\"ty_fn_purity() called on non-fn type: %?\", s))\n+        }\n     }\n }\n \n pub pure fn ty_fn_ret(fty: t) -> t {\n     match get(fty).sty {\n-        ty_fn(ref f) => f.sig.output,\n-        _ => die!(~\"ty_fn_ret() called on non-fn type\")\n+        ty_bare_fn(ref f) => f.sig.output,\n+        ty_closure(ref f) => f.sig.output,\n+        ref s => {\n+            die!(fmt!(\"ty_fn_ret() called on non-fn type: %?\", s))\n+        }\n     }\n }\n \n fn is_fn_ty(fty: t) -> bool {\n     match get(fty).sty {\n-      ty_fn(_) => true,\n-      _ => false\n+        ty_bare_fn(_) => true,\n+        ty_closure(_) => true,\n+        _ => false\n     }\n }\n \n@@ -2874,17 +2862,17 @@ pub fn ty_region(ty: t) -> Region {\n     }\n }\n \n-pub fn replace_fn_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n+pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n     /*!\n      *\n      * Returns a new function type based on `fn_type` but returning a value of\n      * type `ret_type` instead. */\n \n     match ty::get(fn_type).sty {\n-        ty::ty_fn(ref fty) => {\n-            ty::mk_fn(tcx, FnTyBase {\n-                meta: fty.meta,\n-                sig: FnSig {output: ret_type, ..copy fty.sig}\n+        ty::ty_closure(ref fty) => {\n+            ty::mk_closure(tcx, ClosureTy {\n+                sig: FnSig {output: ret_type, ..copy fty.sig},\n+                ..copy *fty\n             })\n         }\n         _ => {\n@@ -2900,12 +2888,6 @@ pub fn tys_in_fn_sig(sig: &FnSig) -> ~[t] {\n     vec::append_one(sig.inputs.map(|a| a.ty), sig.output)\n }\n \n-// Just checks whether it's a fn that returns bool,\n-// not its purity.\n-pub fn is_pred_ty(fty: t) -> bool {\n-    is_fn_ty(fty) && type_is_bool(ty_fn_ret(fty))\n-}\n-\n // Type accessors for AST nodes\n pub fn block_ty(cx: ctxt, b: &ast::blk) -> t {\n     return node_id_to_type(cx, b.node.id);\n@@ -3023,11 +3005,12 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n     fn borrow_fn(cx: ctxt, expr: @ast::expr,\n                  autoref: &AutoRef, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n-            ty_fn(ref fty) => {\n-                ty::mk_fn(cx, FnTyBase {meta: FnMeta {proto: ProtoBorrowed,\n-                                                      region: autoref.region,\n-                                                      ..copy fty.meta},\n-                                        sig: copy fty.sig})\n+            ty_closure(ref fty) => {\n+                ty::mk_closure(cx, ClosureTy {\n+                    sigil: BorrowedSigil,\n+                    region: autoref.region,\n+                    ..copy *fty\n+                })\n             }\n \n             ref s => {\n@@ -3417,7 +3400,8 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_ptr(_) => ~\"*-ptr\",\n       ty_rptr(_, _) => ~\"&-ptr\",\n       ty_rec(_) => ~\"record\",\n-      ty_fn(_) => ~\"fn\",\n+      ty_bare_fn(_) => ~\"extern fn\",\n+      ty_closure(_) => ~\"fn\",\n       ty_trait(id, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n       ty_struct(id, _) => fmt!(\"struct %s\", item_path_str(cx, id)),\n       ty_tup(_) => ~\"tuple\",\n@@ -3455,14 +3439,18 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n             fmt!(\"expected %s fn but found %s fn\",\n                  values.expected.to_str(), values.found.to_str())\n         }\n+        terr_abi_mismatch(values) => {\n+            fmt!(\"expected %s fn but found %s fn\",\n+                 values.expected.to_str(), values.found.to_str())\n+        }\n         terr_onceness_mismatch(values) => {\n             fmt!(\"expected %s fn but found %s fn\",\n                  values.expected.to_str(), values.found.to_str())\n         }\n-        terr_proto_mismatch(values) => {\n+        terr_sigil_mismatch(values) => {\n             fmt!(\"expected %s closure, found %s closure\",\n-                 proto_ty_to_str(cx, values.expected, false),\n-                 proto_ty_to_str(cx, values.found, false))\n+                 values.expected.to_str(),\n+                 values.found.to_str())\n         }\n         terr_mutability => ~\"values differ in mutability\",\n         terr_box_mutability => ~\"boxed values differ in mutability\",\n@@ -4232,13 +4220,10 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n             // This type has a region. Get rid of it\n             mk_rptr(cx, re_static, normalize_mt(cx, mt)),\n \n-        ty_fn(ref fn_ty) => {\n-            mk_fn(cx, FnTyBase {\n-                meta: FnMeta {\n-                    region: ty::re_static,\n-                    ..fn_ty.meta\n-                },\n-                sig: /*bad*/copy fn_ty.sig\n+        ty_closure(ref closure_ty) => {\n+            mk_closure(cx, ClosureTy {\n+                region: ty::re_static,\n+                ..copy *closure_ty\n             })\n         }\n \n@@ -4310,13 +4295,13 @@ pub fn eval_repeat_count(tcx: ctxt,\n // Determine what purity to check a nested function under\n pub pure fn determine_inherited_purity(parent_purity: ast::purity,\n                                        child_purity: ast::purity,\n-                                       child_proto: ast::Proto)\n+                                       child_sigil: ast::Sigil)\n                                     -> ast::purity {\n     // If the closure is a stack closure and hasn't had some non-standard\n     // purity inferred for it, then check it under its parent's purity.\n     // Otherwise, use its own\n-    match child_proto {\n-        ast::ProtoBorrowed if child_purity == ast::impure_fn => parent_purity,\n+    match child_sigil {\n+        ast::BorrowedSigil if child_purity == ast::impure_fn => parent_purity,\n         _ => child_purity\n     }\n }\n@@ -4526,171 +4511,6 @@ impl bound_region : cmp::Eq {\n     pure fn ne(&self, other: &bound_region) -> bool { !(*self).eq(other) }\n }\n \n-impl sty : cmp::Eq {\n-    pure fn eq(&self, other: &sty) -> bool {\n-        match (/*bad*/copy *self) {\n-            ty_nil => {\n-                match (*other) {\n-                    ty_nil => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bot => {\n-                match (*other) {\n-                    ty_bot => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bool => {\n-                match (*other) {\n-                    ty_bool => true,\n-                    _ => false\n-                }\n-            }\n-            ty_int(e0a) => {\n-                match (*other) {\n-                    ty_int(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uint(e0a) => {\n-                match (*other) {\n-                    ty_uint(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_float(e0a) => {\n-                match (*other) {\n-                    ty_float(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_estr(e0a) => {\n-                match (*other) {\n-                    ty_estr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_enum(e0a, ref e1a) => {\n-                match (*other) {\n-                    ty_enum(e0b, ref e1b) => e0a == e0b && (*e1a) == (*e1b),\n-                    _ => false\n-                }\n-            }\n-            ty_box(e0a) => {\n-                match (*other) {\n-                    ty_box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uniq(e0a) => {\n-                match (*other) {\n-                    ty_uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_evec(e0a, e1a) => {\n-                match (*other) {\n-                    ty_evec(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_ptr(e0a) => {\n-                match (*other) {\n-                    ty_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_rptr(e0a, e1a) => {\n-                match (*other) {\n-                    ty_rptr(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_rec(e0a) => {\n-                match (/*bad*/copy *other) {\n-                    ty_rec(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_fn(ref e0a) => {\n-                match (*other) {\n-                    ty_fn(ref e0b) => (*e0a) == (*e0b),\n-                    _ => false\n-                }\n-            }\n-            ty_trait(e0a, ref e1a, e2a) => {\n-                match (*other) {\n-                    ty_trait(e0b, ref e1b, e2b) =>\n-                        e0a == e0b && (*e1a) == (*e1b) && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            ty_struct(e0a, ref e1a) => {\n-                match (*other) {\n-                    ty_struct(e0b, ref e1b) => e0a == e0b && (*e1a) == (*e1b),\n-                    _ => false\n-                }\n-            }\n-            ty_tup(e0a) => {\n-                match (/*bad*/copy *other) {\n-                    ty_tup(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_infer(ref e0a) => {\n-                match (*other) {\n-                    ty_infer(ref e0b) => *e0a == *e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_err => {\n-                match (*other) {\n-                    ty_err => true,\n-                    _ => false\n-                }\n-            }\n-            ty_param(e0a) => {\n-                match (*other) {\n-                    ty_param(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_self => {\n-                match (*other) {\n-                    ty_self => true,\n-                    _ => false\n-                }\n-            }\n-            ty_type => {\n-                match (*other) {\n-                    ty_type => true,\n-                    _ => false\n-                }\n-            }\n-            ty_opaque_box => {\n-                match (*other) {\n-                    ty_opaque_box => true,\n-                    _ => false\n-                }\n-            }\n-            ty_opaque_closure_ptr(e0a) => {\n-                match (*other) {\n-                    ty_opaque_closure_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_unboxed_vec(e0a) => {\n-                match (*other) {\n-                    ty_unboxed_vec(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &sty) -> bool { !(*self).eq(other) }\n-}\n-\n impl param_bound : cmp::Eq {\n     pure fn eq(&self, other: &param_bound) -> bool {\n         match (*self) {"}, {"sha": "0aafeac265aef412ab861ed0db99eb7f28a44cb6", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 85, "deletions": 61, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -55,7 +55,7 @@\n use core::prelude::*;\n \n use middle::pat_util::pat_id_map;\n-use middle::ty::{FnTyBase, FnMeta, FnSig, arg, field, substs};\n+use middle::ty::{arg, field, substs};\n use middle::ty::{ty_param_substs_and_ty};\n use middle::ty;\n use middle::typeck::check::fn_ctxt;\n@@ -70,7 +70,7 @@ use core::vec;\n use syntax::ast;\n use syntax::codemap::span;\n use syntax::print::pprust::path_to_str;\n-use util::common::indent;\n+use util::common::indenter;\n \n pub trait ast_conv {\n     fn tcx() -> ty::ctxt;\n@@ -321,13 +321,16 @@ pub fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n         };\n         ty::mk_rec(tcx, flds)\n       }\n-      ast::ty_fn(f) => {\n-        let bounds = collect::compute_bounds(self.ccx(), f.bounds);\n-        let fn_decl = ty_of_fn_decl(self, rscope, f.proto,\n-                                    f.purity, f.onceness,\n-                                    bounds, f.region, f.decl, None,\n-                                    ast_ty.span);\n-        ty::mk_fn(tcx, fn_decl)\n+      ast::ty_bare_fn(bf) => {\n+          ty::mk_bare_fn(tcx, ty_of_bare_fn(self, rscope, bf.purity,\n+                                            bf.abi, bf.decl))\n+      }\n+      ast::ty_closure(f) => {\n+          let fn_decl = ty_of_closure(self, rscope, f.sigil,\n+                                      f.purity, f.onceness,\n+                                      f.region, f.decl, None,\n+                                      ast_ty.span);\n+          ty::mk_closure(tcx, fn_decl)\n       }\n       ast::ty_path(path, id) => {\n         let a_def = match tcx.def_map.find(&id) {\n@@ -452,71 +455,92 @@ pub fn ty_of_arg<AC: ast_conv, RS: region_scope Copy Durable>(\n     arg {mode: mode, ty: ty}\n }\n \n-pub type expected_tys = Option<{inputs: ~[ty::arg],\n-                                output: ty::t}>;\n+pub fn ty_of_bare_fn<AC: ast_conv, RS: region_scope Copy Durable>(\n+    self: AC, rscope: RS,\n+    purity: ast::purity,\n+    abi: ast::Abi,\n+    decl: ast::fn_decl) -> ty::BareFnTy\n+{\n+    debug!(\"ty_of_fn_decl\");\n+\n+    // new region names that appear inside of the fn decl are bound to\n+    // that function type\n+    let rb = in_binding_rscope(rscope);\n+\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(self, rb, *a, None));\n+    let output_ty = match decl.output.node {\n+        ast::ty_infer => self.ty_infer(decl.output.span),\n+        _ => ast_ty_to_ty(self, rb, decl.output)\n+    };\n+\n+    ty::BareFnTy {\n+        purity: purity,\n+        abi: abi,\n+        sig: ty::FnSig {inputs: input_tys, output: output_ty}\n+    }\n+}\n \n-pub fn ty_of_fn_decl<AC: ast_conv, RS: region_scope Copy Durable>(\n+pub fn ty_of_closure<AC: ast_conv, RS: region_scope Copy Durable>(\n     self: AC, rscope: RS,\n-    ast_proto: ast::Proto,\n+    sigil: ast::Sigil,\n     purity: ast::purity,\n     onceness: ast::Onceness,\n-    bounds: @~[ty::param_bound],\n     opt_region: Option<@ast::region>,\n     decl: ast::fn_decl,\n-    expected_tys: expected_tys,\n-    span: span) -> ty::FnTy {\n+    expected_tys: Option<ty::FnSig>,\n+    span: span) -> ty::ClosureTy\n+{\n     debug!(\"ty_of_fn_decl\");\n-    do indent {\n-        // resolve the function bound region in the original region\n-        // scope `rscope`, not the scope of the function parameters\n-        let bound_region = match opt_region {\n-            Some(region) => {\n-                ast_region_to_region(self, rscope, span, region)\n-            }\n-            None => {\n-                match ast_proto {\n-                    ast::ProtoBare | ast::ProtoUniq | ast::ProtoBox => {\n-                        // @fn(), ~fn() default to static as the bound\n-                        // on their upvars:\n-                        ty::re_static\n-                    }\n-                    ast::ProtoBorrowed => {\n-                        // &fn() defaults to an anonymous region:\n-                        let r_result = rscope.anon_region(span);\n-                        get_region_reporting_err(self.tcx(), span, r_result)\n-                    }\n+    let _i = indenter();\n+\n+    // resolve the function bound region in the original region\n+    // scope `rscope`, not the scope of the function parameters\n+    let bound_region = match opt_region {\n+        Some(region) => {\n+            ast_region_to_region(self, rscope, span, region)\n+        }\n+        None => {\n+            match sigil {\n+                ast::OwnedSigil | ast::ManagedSigil => {\n+                    // @fn(), ~fn() default to static as the bound\n+                    // on their upvars:\n+                    ty::re_static\n+                }\n+                ast::BorrowedSigil => {\n+                    // &fn() defaults to an anonymous region:\n+                    let r_result = rscope.anon_region(span);\n+                    get_region_reporting_err(self.tcx(), span, r_result)\n                 }\n             }\n-        };\n+        }\n+    };\n \n-        // new region names that appear inside of the fn decl are bound to\n-        // that function type\n-        let rb = in_binding_rscope(rscope);\n-\n-        let input_tys = do decl.inputs.mapi |i, a| {\n-            let expected_arg_ty = do expected_tys.chain_ref |e| {\n-                // no guarantee that the correct number of expected args\n-                // were supplied\n-                if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n-            };\n-            ty_of_arg(self, rb, *a, expected_arg_ty)\n-        };\n+    // new region names that appear inside of the fn decl are bound to\n+    // that function type\n+    let rb = in_binding_rscope(rscope);\n \n-        let expected_ret_ty = expected_tys.map(|e| e.output);\n-        let output_ty = match decl.output.node {\n-          ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.get(),\n-          ast::ty_infer => self.ty_infer(decl.output.span),\n-          _ => ast_ty_to_ty(self, rb, decl.output)\n+    let input_tys = do decl.inputs.mapi |i, a| {\n+        let expected_arg_ty = do expected_tys.chain_ref |e| {\n+            // no guarantee that the correct number of expected args\n+            // were supplied\n+            if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n         };\n+        ty_of_arg(self, rb, *a, expected_arg_ty)\n+    };\n \n-        FnTyBase {\n-            meta: FnMeta {purity: purity,\n-                          proto: ast_proto,\n-                          onceness: onceness,\n-                          region: bound_region,\n-                          bounds: bounds},\n-            sig: FnSig {inputs: input_tys,\n+    let expected_ret_ty = expected_tys.map(|e| e.output);\n+    let output_ty = match decl.output.node {\n+        ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.get(),\n+        ast::ty_infer => self.ty_infer(decl.output.span),\n+        _ => ast_ty_to_ty(self, rb, decl.output)\n+    };\n+\n+    ty::ClosureTy {\n+        purity: purity,\n+        sigil: sigil,\n+        onceness: onceness,\n+        region: bound_region,\n+        sig: ty::FnSig {inputs: input_tys,\n                         output: output_ty}\n-        }\n     }\n }"}, {"sha": "f5faa968791c54a16e9ed149182567631b307c75", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -883,7 +883,7 @@ pub impl LookupContext {\n                     })\n             }\n \n-            ty_trait(*) | ty_fn(*) => {\n+            ty_trait(*) | ty_closure(*) => {\n                 // NDM---eventually these should be some variant of autoref\n                 None\n             }\n@@ -906,14 +906,14 @@ pub impl LookupContext {\n \n         let tcx = self.tcx();\n         match ty::get(self_ty).sty {\n-            ty_box(*) | ty_uniq(*) | ty_rptr(*) |\n+            ty_bare_fn(*) | ty_box(*) | ty_uniq(*) | ty_rptr(*) |\n             ty_infer(IntVar(_)) |\n             ty_infer(FloatVar(_)) |\n             ty_self | ty_param(*) | ty_nil | ty_bot | ty_bool |\n             ty_int(*) | ty_uint(*) |\n             ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_rec(*) |\n             ty_struct(*) | ty_tup(*) | ty_estr(*) | ty_evec(*) |\n-            ty_trait(*) | ty_fn(*) => {\n+            ty_trait(*) | ty_closure(*) => {\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoPtr, autoderefs, [m_const, m_imm, m_mutbl],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n@@ -1212,7 +1212,7 @@ pub impl LookupContext {\n                                 trait_did: def_id,\n                                 method_num: uint) -> ty::t {\n             let trait_methods = ty::trait_methods(tcx, trait_did);\n-            ty::mk_fn(tcx, /*bad*/copy trait_methods[method_num].fty)\n+            ty::mk_bare_fn(tcx, copy trait_methods[method_num].fty)\n         }\n     }\n "}, {"sha": "074a0a565ae590c050a3d7cb47fe4b99fae47705", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 276, "deletions": 255, "changes": 531, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -81,7 +81,7 @@ use core::prelude::*;\n use middle::const_eval;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n-use middle::ty::{TyVid, Vid, FnTyBase, FnMeta, FnSig, VariantInfo_, field};\n+use middle::ty::{TyVid, Vid, FnSig, VariantInfo_, field};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n use middle::ty::{re_bound, br_cap_avoid, substs, arg, param_ty};\n use middle::ty;\n@@ -90,7 +90,6 @@ use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::check::_match::pat_ctxt;\n use middle::typeck::check::method::TransformTypeNormally;\n-use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_ty;\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::crate_ctxt;\n@@ -248,8 +247,9 @@ pub fn check_bare_fn(ccx: @crate_ctxt,\n                      self_info: Option<self_info>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n     match ty::get(fty).sty {\n-        ty::ty_fn(ref fn_ty) => {\n-            check_fn(ccx, self_info, fn_ty, decl, body, Vanilla, None)\n+        ty::ty_bare_fn(ref fn_ty) => {\n+            check_fn(ccx, self_info, fn_ty.purity, None,\n+                     &fn_ty.sig, decl, body, Vanilla, None)\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n                                  \"check_bare_fn: function type expected\")\n@@ -258,12 +258,14 @@ pub fn check_bare_fn(ccx: @crate_ctxt,\n \n pub fn check_fn(ccx: @crate_ctxt,\n                 self_info: Option<self_info>,\n-                fn_ty: &ty::FnTy,\n+                purity: ast::purity,\n+                sigil: Option<ast::Sigil>,\n+                fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n                 body: ast::blk,\n                 fn_kind: FnKind,\n-                old_fcx: Option<@fn_ctxt>) {\n-\n+                old_fcx: Option<@fn_ctxt>)\n+{\n     let tcx = ccx.tcx;\n     let indirect_ret = match fn_kind {\n         ForLoop => true, _ => false\n@@ -277,7 +279,7 @@ pub fn check_fn(ccx: @crate_ctxt,\n     let {isr, self_info, fn_sig} = {\n         let old_isr = option::map_default(&old_fcx, @Nil,\n                                           |fcx| fcx.in_scope_regions);\n-        replace_bound_regions_in_fn_sig(tcx, old_isr, self_info, &fn_ty.sig,\n+        replace_bound_regions_in_fn_sig(tcx, old_isr, self_info, fn_sig,\n                                         |br| ty::re_free(body.node.id, br))\n     };\n \n@@ -294,13 +296,10 @@ pub fn check_fn(ccx: @crate_ctxt,\n     // in the case of function expressions, based on the outer context.\n     let fcx: @fn_ctxt = {\n         let (purity, inherited) = match old_fcx {\n-            None => {\n-                (fn_ty.meta.purity,\n-                 blank_inherited(ccx))\n-            }\n+            None => (purity, blank_inherited(ccx)),\n             Some(fcx) => {\n-                (ty::determine_inherited_purity(fcx.purity, fn_ty.meta.purity,\n-                                                fn_ty.meta.proto),\n+                (ty::determine_inherited_purity(fcx.purity, purity,\n+                                                sigil.get()),\n                  fcx.inh)\n             }\n         };\n@@ -1092,8 +1091,9 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         in_fty: ty::t,\n         callee_expr: @ast::expr,\n         args: ~[@ast::expr],\n-        deref_args: DerefArgs) -> {fty: ty::t, bot: bool} {\n-\n+        sugar: ast::CallSugar,\n+        deref_args: DerefArgs) -> (ty::t, bool)\n+    {\n         let tcx = fcx.ccx.tcx;\n         let mut bot = false;\n \n@@ -1103,62 +1103,72 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         debug!(\"check_call_inner: before universal quant., in_fty=%s\",\n                fcx.infcx().ty_to_str(in_fty));\n \n-        let mut formal_tys;\n+        let formal_tys;\n \n         // This is subtle: we expect `fty` to be a function type, which\n         // normally introduce a level of binding.  In this case, we want to\n         // process the types bound by the function but not by any nested\n         // functions.  Therefore, we match one level of structure.\n-        let fty =\n-            match structure_of(fcx, sp, in_fty) {\n-              ty::ty_fn(ref fn_ty) => {\n-                  let fn_ty =\n-                    /*bad*/copy replace_bound_regions_in_fn_ty(tcx, @Nil,\n-                      None, fn_ty, |_br| fcx.infcx().next_region_var(sp,\n-                                                      call_expr_id)).fn_ty;\n-\n-                  let supplied_arg_count = args.len();\n-\n-                  bot |= ty::type_is_bot(fn_ty.sig.output);\n-\n-                  // Grab the argument types, supplying fresh type variables\n-                  // if the wrong number of arguments were supplied\n-                  let expected_arg_count = fn_ty.sig.inputs.len();\n-                  formal_tys = if expected_arg_count == supplied_arg_count {\n-                      fn_ty.sig.inputs.map(|a| a.ty)\n-                  } else {\n-                      tcx.sess.span_err(\n-                          sp, fmt!(\"this function takes %u parameter%s but \\\n-                                    %u parameter%s supplied\",\n+        let ret_ty = match structure_of(fcx, sp, in_fty) {\n+            ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n+            ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n+                let {fn_sig: sig, _} =\n+                    replace_bound_regions_in_fn_sig(\n+                        tcx, @Nil, None, sig,\n+                        |_br| fcx.infcx().next_region_var(\n+                            sp, call_expr_id));\n+\n+                let supplied_arg_count = args.len();\n+\n+                bot |= ty::type_is_bot(sig.output);\n+\n+                // Grab the argument types, supplying fresh type variables\n+                // if the wrong number of arguments were supplied\n+                let expected_arg_count = sig.inputs.len();\n+                formal_tys = if expected_arg_count == supplied_arg_count {\n+                    sig.inputs.map(|a| a.ty)\n+                } else {\n+                    let suffix = match sugar {\n+                        ast::NoSugar => \"\",\n+                        ast::DoSugar => \" (including the closure passed by \\\n+                                         the `do` keyword)\",\n+                        ast::ForSugar => \" (including the closure passed by \\\n+                                          the `for` keyword)\"\n+                    };\n+                    let msg = fmt!(\"this function takes %u parameter%s but \\\n+                                    %u parameter%s supplied%s\",\n                                    expected_arg_count,\n-                                   if expected_arg_count == 1 {\n-                                       ~\"\"\n-                                   } else {\n-                                       ~\"s\"\n-                                   },\n+                                   if expected_arg_count == 1 {\"\"}\n+                                   else {\"s\"},\n                                    supplied_arg_count,\n-                                   if supplied_arg_count == 1 {\n-                                       ~\" was\"\n-                                   } else {\n-                                       ~\"s were\"\n-                                   }));\n-                      fcx.infcx().next_ty_vars(supplied_arg_count)\n-                  };\n-                  ty::mk_fn(tcx, fn_ty)\n-              }\n-              _ => {\n-                  fcx.type_error_message(sp, |actual| {\n-                      fmt!(\"expected function or foreign function but \\\n-                            found `%s`\", actual) }, in_fty, None);\n-                  // check each arg against \"error\", in order to set up\n-                  // all the node type bindings\n-                  formal_tys = args.map(|_x| ty::mk_err(tcx));\n-                  ty::mk_err(tcx)\n-              }\n-            };\n+                                   if supplied_arg_count == 1 {\" was\"}\n+                                   else {\"s were\"},\n+                                   suffix);\n \n-        debug!(\"check_call_inner: after universal quant., fty=%s\",\n-               fcx.infcx().ty_to_str(fty));\n+                    tcx.sess.span_err(sp, msg);\n+\n+                    vec::from_fn(expected_arg_count, |_| ty::mk_err(tcx))\n+                };\n+\n+                sig.output\n+            }\n+\n+            _ => {\n+                fcx.type_error_message(sp, |actual| {\n+                    fmt!(\"expected function or foreign function but \\\n+                          found `%s`\", actual) }, in_fty, None);\n+\n+                // check each arg against \"error\", in order to set up\n+                // all the node type bindings\n+                formal_tys = args.map(|_x| ty::mk_err(tcx));\n+                ty::mk_err(tcx)\n+            }\n+        };\n+\n+        debug!(\"check_call_inner: after universal quant., \\\n+                formal_tys=%? ret_ty=%s\",\n+               formal_tys.map(|t| fcx.infcx().ty_to_str(*t)),\n+               fcx.infcx().ty_to_str(ret_ty));\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n@@ -1209,7 +1219,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n             }\n         }\n \n-        {fty: fty, bot: bot}\n+        (ret_ty, bot)\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1233,36 +1243,26 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                             fn_ty: ty::t,\n                             expr: @ast::expr,\n                             +args: ~[@ast::expr],\n-                            bot: bool)\n-                         -> bool {\n+                            bot: bool,\n+                            sugar: ast::CallSugar) -> bool\n+    {\n         let mut bot = bot;\n \n         // Call the generic checker.\n-        let fty = {\n-            let r = check_call_inner(fcx, sp, call_expr_id,\n-                                     fn_ty, expr, args, DontDerefArgs);\n-            bot |= r.bot;\n-            r.fty\n-        };\n+        let (ret_ty, b) = check_call_inner(fcx, sp, call_expr_id,\n+                                           fn_ty, expr, args, sugar,\n+                                           DontDerefArgs);\n+        bot |= b;\n \n         // Pull the return type out of the type of the function.\n-        match structure_of(fcx, sp, fty) {\n-          ty::ty_fn(ref f) => {\n-              fcx.write_ty(call_expr_id, f.sig.output);\n-              return bot;\n-          }\n-          _ => {\n-              fcx.write_ty(call_expr_id, ty::mk_err(fcx.ccx.tcx));\n-              fcx.type_error_message(sp, |_actual| {\n-                  ~\"expected function\"}, fty, None);\n-              return bot;\n-          }\n-        }\n+        fcx.write_ty(call_expr_id, ret_ty);\n+        return bot;\n     }\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id,\n-                  f: @ast::expr, +args: ~[@ast::expr]) -> bool {\n+                  f: @ast::expr, +args: ~[@ast::expr],\n+                  sugar: ast::CallSugar) -> bool {\n         // Index expressions need to be handled separately, to inform them\n         // that they appear in call position.\n         let mut bot = match /*bad*/copy f.node {\n@@ -1278,7 +1278,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                              fcx.expr_ty(f),\n                              f,\n                              args,\n-                             bot)\n+                             bot,\n+                             sugar)\n     }\n \n     // Checks a method call.\n@@ -1287,7 +1288,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                          rcvr: @ast::expr,\n                          method_name: ast::ident,\n                          +args: ~[@ast::expr],\n-                         tps: ~[@ast::Ty])\n+                         tps: ~[@ast::Ty],\n+                         sugar: ast::CallSugar)\n                       -> bool {\n         let bot = check_expr(fcx, rcvr);\n         let expr_t = structurally_resolved_type(fcx,\n@@ -1329,7 +1331,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                              fcx.node_ty(expr.callee_id),\n                              expr,\n                              args,\n-                             bot)\n+                             bot,\n+                             sugar)\n     }\n \n     // A generic function for checking for or for-each loops\n@@ -1378,13 +1381,11 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                              op_ex.callee_id, opname, self_t, ~[],\n                              deref_args) {\n           Some(ref origin) => {\n-            let {fty: method_ty, bot: bot} = {\n-                let method_ty = fcx.node_ty(op_ex.callee_id);\n-                check_call_inner(fcx, op_ex.span, op_ex.id,\n-                                 method_ty, op_ex, args, deref_args)\n-            };\n-            fcx.ccx.method_map.insert(op_ex.id, (*origin));\n-            Some((ty::ty_fn_ret(method_ty), bot))\n+              let method_ty = fcx.node_ty(op_ex.callee_id);\n+              fcx.ccx.method_map.insert(op_ex.id, *origin);\n+              Some(check_call_inner(fcx, op_ex.span, op_ex.id,\n+                                    method_ty, op_ex, args,\n+                                    ast::NoSugar, deref_args))\n           }\n           _ => None\n         }\n@@ -1472,13 +1473,14 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // If the or operator is used it might be that the user forgot to\n         // supply the do keyword.  Let's be more helpful in that situation.\n         if op == ast::or {\n-          match ty::get(lhs_resolved_t).sty {\n-            ty::ty_fn(_) => {\n-              tcx.sess.span_note(\n-                  ex.span, ~\"did you forget the `do` keyword for the call?\");\n+            match ty::get(lhs_resolved_t).sty {\n+                ty::ty_bare_fn(_) | ty::ty_closure(_) => {\n+                    tcx.sess.span_note(\n+                        ex.span, ~\"did you forget the `do` keyword \\\n+                                   for the call?\");\n+                }\n+                _ => ()\n             }\n-            _ => ()\n-          }\n         }\n \n         (lhs_resolved_t, false)\n@@ -1523,7 +1525,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n     fn check_expr_fn(fcx: @fn_ctxt,\n                      expr: @ast::expr,\n-                     ast_proto_opt: Option<ast::Proto>,\n+                     ast_sigil_opt: Option<ast::Sigil>,\n                      decl: &ast::fn_decl,\n                      body: ast::blk,\n                      fn_kind: FnKind,\n@@ -1534,50 +1536,44 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // avoid capture of bound regions in the expected type.  See\n         // def'n of br_cap_avoid() for a more lengthy explanation of\n         // what's going on here.\n-        // Also try to pick up inferred purity and proto, defaulting\n+        // Also try to pick up inferred purity and sigil, defaulting\n         // to impure and block. Note that we only will use those for\n         // block syntax lambdas; that is, lambdas without explicit\n-        // protos.\n+        // sigils.\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n         let (expected_tys,\n              expected_purity,\n-             expected_proto,\n+             expected_sigil,\n              expected_onceness) = {\n             match expected_sty {\n-                Some(ty::ty_fn(ref fn_ty)) => {\n+                Some(ty::ty_closure(ref cenv)) => {\n                     let id = expr.id;\n-                    let {fn_ty: fn_ty, _} =\n-                        replace_bound_regions_in_fn_ty(\n-                            tcx, @Nil, None, fn_ty,\n+                    let {fn_sig: sig, _} =\n+                        replace_bound_regions_in_fn_sig(\n+                            tcx, @Nil, None, &cenv.sig,\n                             |br| ty::re_bound(ty::br_cap_avoid(id, @br)));\n-                    (Some({inputs: /*bad*/copy fn_ty.sig.inputs,\n-                           output: fn_ty.sig.output}),\n-                     fn_ty.meta.purity,\n-                     fn_ty.meta.proto,\n-                     fn_ty.meta.onceness)\n+                    (Some(sig), cenv.purity, cenv.sigil, cenv.onceness)\n                 }\n                 _ => {\n-                    (None, ast::impure_fn, ast::ProtoBorrowed, ast::Many)\n+                    (None, ast::impure_fn, ast::BorrowedSigil, ast::Many)\n                 }\n             }\n         };\n \n         // If the proto is specified, use that, otherwise select a\n         // proto based on inference.\n-        let (proto, purity) = match ast_proto_opt {\n+        let (sigil, purity) = match ast_sigil_opt {\n             Some(p) => (p, ast::impure_fn),\n-            None => (expected_proto, expected_purity)\n+            None => (expected_sigil, expected_purity)\n         };\n \n         // construct the function type\n-        let mut fn_ty = astconv::ty_of_fn_decl(\n+        let mut fn_ty = astconv::ty_of_closure(\n             fcx, fcx,\n-            proto, purity, expected_onceness,\n-            /*bounds:*/ @~[], /*opt_region:*/ None,\n-            *decl, expected_tys, expr.span);\n+            sigil, purity, expected_onceness,\n+            None, *decl, expected_tys, expr.span);\n \n-        // XXX: Bad copy.\n-        let fty = ty::mk_fn(tcx, copy fn_ty);\n+        let fty = ty::mk_closure(tcx, copy fn_ty);\n \n         debug!(\"check_expr_fn_with_unifier %s fty=%s\",\n                fcx.expr_to_str(expr),\n@@ -1587,8 +1583,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // We inherit the same self info as the enclosing scope,\n         // since the function we're checking might capture `self`\n-        check_fn(fcx.ccx, fcx.self_info, &fn_ty, decl, body,\n-                 fn_kind, Some(fcx));\n+        check_fn(fcx.ccx, fcx.self_info, fn_ty.purity, Some(fn_ty.sigil),\n+                 &fn_ty.sig, decl, body, fn_kind, Some(fcx));\n     }\n \n \n@@ -1913,6 +1909,119 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         return bot;\n     }\n \n+    fn check_loop_body(fcx: @fn_ctxt,\n+                       expr: @ast::expr,\n+                       expected: Option<ty::t>,\n+                       loop_body: @ast::expr)\n+    {\n+        // a loop body is the special argument to a `for` loop.  We know that\n+        // there will be an expected type in this context because it can only\n+        // appear in the context of a call, so we get the expected type of the\n+        // parameter. The catch here is that we need to validate two things:\n+        // 1. a closure that returns a bool is expected\n+        // 2. the closure that was given returns unit\n+        let tcx = fcx.tcx();\n+        let mut err_happened = false;\n+        let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n+        let inner_ty = match expected_sty {\n+            Some(ty::ty_closure(ref fty)) => {\n+                match fcx.mk_subty(false, expr.span,\n+                                   fty.sig.output, ty::mk_bool(tcx)) {\n+                    result::Ok(_) => {\n+                        ty::mk_closure(tcx, ty::ClosureTy {\n+                            sig: FnSig {output: ty::mk_nil(tcx),\n+                                        ..copy fty.sig},\n+                            ..copy *fty\n+                        })\n+                    }\n+                    result::Err(_) => {\n+                        fcx.type_error_message(\n+                            expr.span,\n+                            |actual| {\n+                                let did_you_mean = {\n+                                    if ty::type_is_nil(fty.sig.output) {\n+                                        \"\\nDid you mean to use \\\n+                                             `do` instead of `for`?\"\n+                                     } else {\n+                                         \"\"\n+                                     }\n+                                };\n+                                fmt!(\"A `for` loop iterator should expect a \\\n+                                      closure that returns `bool`. This \\\n+                                      iterator expects a closure that \\\n+                                      returns `%s`.%s\",\n+                                     actual, did_you_mean)\n+                            },\n+                            fty.sig.output,\n+                            None);\n+                        err_happened = true;\n+\n+                        // Kind of a hack: create a function type with\n+                        // the result replaced with ty_err, to\n+                        // suppress derived errors.\n+                        let t = ty::replace_closure_return_type(\n+                            tcx, ty::mk_closure(tcx, copy *fty),\n+                            ty::mk_err(tcx));\n+                        fcx.write_ty(expr.id, ty::mk_err(tcx));\n+                        t\n+                    }\n+                }\n+            }\n+            _ => {\n+                match expected {\n+                    Some(expected_t) => {\n+                        fcx.type_error_message(\n+                            expr.span,\n+                            |actual| {\n+                                fmt!(\"last argument in `for` call \\\n+                                      has non-closure type: %s\",\n+                                     actual)\n+                            },\n+                            expected_t, None);\n+                        let err_ty = ty::mk_err(tcx);\n+                        fcx.write_ty(expr.id, err_ty);\n+                        err_happened = true;\n+                        err_ty\n+                    }\n+                    None => fcx.tcx().sess.impossible_case(\n+                        expr.span,\n+                        ~\"loop body must have an expected type\")\n+                }\n+            }\n+        };\n+\n+        match loop_body.node {\n+            ast::expr_fn_block(ref decl, ref body) => {\n+                // If an error occurred, we pretend this isn't a for\n+                // loop, so as to assign types to all nodes while also\n+                // propagating ty_err throughout so as to suppress\n+                // derived errors. If we passed in ForLoop in the\n+                // error case, we'd potentially emit a spurious error\n+                // message because of the indirect_ret_ty.\n+                let fn_kind = if err_happened {Vanilla} else {ForLoop};\n+                check_expr_fn(fcx, loop_body, None,\n+                              decl, *body, fn_kind, Some(inner_ty));\n+                demand::suptype(fcx, loop_body.span,\n+                                inner_ty, fcx.expr_ty(loop_body));\n+            }\n+            ref n => {\n+                die!(fmt!(\n+                    \"check_loop_body expected expr_fn_block, not %?\", n))\n+            }\n+        }\n+\n+        let block_ty = structurally_resolved_type(\n+            fcx, expr.span, fcx.node_ty(loop_body.id));\n+        if err_happened {\n+            fcx.write_ty(expr.id, ty::mk_err(fcx.tcx()));\n+        } else {\n+            let loop_body_ty =\n+                ty::replace_closure_return_type(\n+                    tcx, block_ty, ty::mk_bool(tcx));\n+            fcx.write_ty(expr.id, loop_body_ty);\n+        }\n+    }\n+\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     let mut bot = false;\n@@ -2153,121 +2262,38 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_match(discrim, ref arms) => {\n         bot = _match::check_match(fcx, expr, discrim, (/*bad*/copy *arms));\n       }\n-      ast::expr_fn(proto, ref decl, ref body, _) => {\n-        check_expr_fn(fcx, expr, Some(proto),\n+      ast::expr_fn(sigil, ref decl, ref body, _) => {\n+        check_expr_fn(fcx, expr, Some(sigil),\n                       decl, (*body), Vanilla, expected);\n       }\n       ast::expr_fn_block(ref decl, ref body) => {\n         check_expr_fn(fcx, expr, None,\n                       decl, (*body), Vanilla, expected);\n       }\n-      ast::expr_loop_body(b) => {\n-        // a loop body is the special argument to a `for` loop.  We know that\n-        // there will be an expected type in this context because it can only\n-        // appear in the context of a call, so we get the expected type of the\n-        // parameter. The catch here is that we need to validate two things:\n-        // 1. a closure that returns a bool is expected\n-        // 2. the closure that was given returns unit\n-        let mut err_happened = false;\n-        let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n-        let inner_ty = match expected_sty {\n-          Some(ty::ty_fn(ref fty)) => {\n-            match fcx.mk_subty(false, expr.span,\n-                               (*fty).sig.output, ty::mk_bool(tcx)) {\n-              result::Ok(_) =>\n-                  ty::mk_fn(tcx, FnTyBase {\n-                      meta: (*fty).meta,\n-                      sig: FnSig {output: ty::mk_nil(tcx),\n-                                  ../*bad*/copy (*fty).sig}\n-                  }),\n-              result::Err(_) => {\n-                   fcx.type_error_message(expr.span,\n-                      |actual| {\n-                          fmt!(\"A `for` loop iterator should expect a \\\n-                                closure that returns `bool`. This iterator \\\n-                                expects a closure that returns `%s`. %s\",\n-                               actual, if ty::type_is_nil((*fty).sig.output) {\n-                                   \"\\nDid you mean to use `do` instead of \\\n-                                        `for`?\" } else { \"\" } )\n-                      },\n-                      (*fty).sig.output, None);\n-                err_happened = true;\n-                // Kind of a hack: create a function type with the result\n-                // replaced with ty_err, to suppress derived errors.\n-                let t = ty::replace_fn_return_type(tcx, ty::mk_fn(tcx,\n-                                                                  copy *fty),\n-                                                   ty::mk_err(tcx));\n-                fcx.write_ty(id, ty::mk_err(tcx));\n-                t\n-              }\n-            }\n-          }\n-          _ =>\n-              match expected {\n-                  Some(expected_t) => {\n-                      fcx.type_error_message(expr.span, |actual| {\n-                          fmt!(\"a `loop` function's last \\\n-                                argument should be of function \\\n-                                type, not `%s`\",\n-                               actual)\n-                      },\n-                                             expected_t, None);\n-                      let err_ty = ty::mk_err(tcx);\n-                      fcx.write_ty(id, err_ty);\n-                      err_happened = true;\n-                      err_ty\n-                  }\n-                  None => fcx.tcx().sess.impossible_case(expr.span,\n-                            ~\"loop body must have an expected type\")\n-              }\n-        };\n-        match b.node {\n-                ast::expr_fn_block(ref decl, ref body) => {\n-                    // If an error occurred, we pretend this isn't a for\n-                    // loop, so as to assign types to all nodes while also\n-                    // propagating ty_err throughout so as to suppress\n-                    // derived errors. If we passed in ForLoop in the\n-                    // error case, we'd potentially emit a spurious error\n-                    // message because of the indirect_ret_ty.\n-                    let fn_kind = if err_happened { Vanilla }\n-                                  else { ForLoop };\n-                    check_expr_fn(fcx, b, None,\n-                                  decl, *body, fn_kind, Some(inner_ty));\n-                    demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n-                }\n-                // argh\n-                _ => die!(~\"expr_fn_block\")\n-        }\n-        let block_ty = structurally_resolved_type(\n-            fcx, expr.span, fcx.node_ty(b.id));\n-        if err_happened {\n-            fcx.write_ty(expr.id, ty::mk_err(fcx.tcx()));\n-        } else {\n-            let loop_body_ty = ty::replace_fn_return_type(tcx, block_ty,\n-                                                          ty::mk_bool(tcx));\n-            fcx.write_ty(expr.id, loop_body_ty);\n-        }\n+      ast::expr_loop_body(loop_body) => {\n+          check_loop_body(fcx, expr, expected, loop_body);\n       }\n       ast::expr_do_body(b) => {\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n         let inner_ty = match expected_sty {\n-          Some(ty::ty_fn(ref fty)) => {\n-              ty::mk_fn(tcx, (/*bad*/copy *fty))\n-          }\n-          _ => match expected {\n-                  Some(expected_t) => {\n-                      fcx.type_error_message(expr.span, |_actual| {\n-                          ~\"Non-function passed to a `do` \\\n-                            function as its last argument, or wrong number \\\n-                            of arguments passed to a `do` function\"\n-                      }, expected_t, None);\n-                      let err_ty = ty::mk_err(tcx);\n-                      fcx.write_ty(id, err_ty);\n-                      err_ty\n-                  }\n-                  None => fcx.tcx().sess.impossible_case(expr.span,\n-                              ~\"do body must have expected type\")\n-              }\n+            Some(ty::ty_closure(_)) => expected.get(),\n+            _ => match expected {\n+                Some(expected_t) => {\n+                    fcx.type_error_message(expr.span, |actual| {\n+                        fmt!(\"last argument in `do` call \\\n+                              has non-closure type: %s\",\n+                             actual)\n+                    }, expected_t, None);\n+                    let err_ty = ty::mk_err(tcx);\n+                    fcx.write_ty(id, err_ty);\n+                    err_ty\n+                }\n+                None => {\n+                    fcx.tcx().sess.impossible_case(\n+                        expr.span,\n+                        ~\"do body must have expected type\")\n+                }\n+            }\n         };\n         match b.node {\n           ast::expr_fn_block(ref decl, ref body) => {\n@@ -2290,11 +2316,11 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n             };\n         fcx.write_ty(id, typ);\n       }\n-      ast::expr_call(f, args, _) => {\n-        bot = check_call(fcx, expr.span, expr.id, f, args);\n+      ast::expr_call(f, args, sugar) => {\n+        bot = check_call(fcx, expr.span, expr.id, f, args, sugar);\n       }\n-      ast::expr_method_call(rcvr, ident, tps, args, _) => {\n-        bot = check_method_call(fcx, expr, rcvr, ident, args, tps);\n+      ast::expr_method_call(rcvr, ident, tps, args, sugar) => {\n+        bot = check_method_call(fcx, expr, rcvr, ident, args, tps, sugar);\n       }\n       ast::expr_cast(e, t) => {\n         bot = check_expr(fcx, e);\n@@ -3088,20 +3114,18 @@ pub fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n                  arg(ast::by_ref, visitor_trait)], ty::mk_nil(tcx))\n       }\n       ~\"frame_address\" => {\n-        let fty = ty::mk_fn(ccx.tcx, FnTyBase {\n-            meta: FnMeta {purity: ast::impure_fn,\n-                          proto: ast::ProtoBorrowed,\n-                          onceness: ast::Once,\n-                          region: ty::re_bound(ty::br_anon(0)),\n-                          bounds: @~[]},\n-            sig: FnSig {\n-                inputs: ~[arg {\n-                    mode: ast::expl(ast::by_val),\n-                    ty: ty::mk_imm_ptr(\n-                        ccx.tcx,\n-                        ty::mk_mach_uint(ccx.tcx, ast::ty_u8))\n-                }],\n-                output: ty::mk_nil(ccx.tcx)}\n+        let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n+            purity: ast::impure_fn,\n+            sigil: ast::BorrowedSigil,\n+            onceness: ast::Once,\n+            region: ty::re_bound(ty::br_anon(0)),\n+            sig: ty::FnSig {\n+                inputs: ~[arg {mode: ast::expl(ast::by_val),\n+                               ty: ty::mk_imm_ptr(\n+                                   ccx.tcx,\n+                                   ty::mk_mach_uint(ccx.tcx, ast::ty_u8))}],\n+                output: ty::mk_nil(ccx.tcx)\n+            }\n         });\n         (0u, ~[arg(ast::by_ref, fty)], ty::mk_nil(tcx))\n       }\n@@ -3324,12 +3348,9 @@ pub fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n         return;\n       }\n     };\n-    let fty = ty::mk_fn(tcx, FnTyBase {\n-        meta: FnMeta {purity: ast::unsafe_fn,\n-                      proto: ast::ProtoBare,\n-                      onceness: ast::Many,\n-                      region: ty::re_static,\n-                      bounds: @~[]},\n+    let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+        purity: ast::unsafe_fn,\n+        abi: ast::RustAbi,\n         sig: FnSig {inputs: inputs,\n                     output: output}\n     });"}, {"sha": "9dfaaeebc8fd9f46677330d6aa70ebd06f846ba1", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -32,7 +32,7 @@ use core::prelude::*;\n use middle::freevars::get_freevars;\n use middle::pat_util::{pat_bindings, pat_is_binding};\n use middle::ty::{encl_region, re_scope};\n-use middle::ty::{ty_fn_proto, vstore_box, vstore_fixed, vstore_slice};\n+use middle::ty::{vstore_box, vstore_fixed, vstore_slice};\n use middle::ty::{vstore_uniq};\n use middle::ty;\n use middle::typeck::check::fn_ctxt;\n@@ -42,7 +42,7 @@ use middle::typeck::infer::{resolve_type};\n use util::ppaux::{note_and_explain_region, ty_to_str};\n \n use core::result;\n-use syntax::ast::{ProtoBare, ProtoBox, ProtoUniq, ProtoBorrowed};\n+use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n use syntax::ast::{def_arg, def_binding, def_local, def_self, def_upvar};\n use syntax::ast;\n use syntax::codemap::span;\n@@ -59,10 +59,9 @@ pub fn encl_region_of_def(fcx: @fn_ctxt, def: ast::def) -> ty::Region {\n         def_self(node_id, _) | def_binding(node_id, _) =>\n             return encl_region(tcx, node_id),\n         def_upvar(_, subdef, closure_id, body_id) => {\n-            match ty_fn_proto(fcx.node_ty(closure_id)) {\n-                ProtoBare => tcx.sess.bug(~\"ProtoBare with upvars?!\"),\n-                ProtoBorrowed => encl_region_of_def(fcx, *subdef),\n-                ProtoBox | ProtoUniq => re_scope(body_id)\n+            match ty::ty_closure_sigil(fcx.node_ty(closure_id)) {\n+                BorrowedSigil => encl_region_of_def(fcx, *subdef),\n+                ManagedSigil | OwnedSigil => re_scope(body_id)\n             }\n         }\n         _ => {\n@@ -278,11 +277,9 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n         ast::expr_fn(*) | ast::expr_fn_block(*) => {\n             let function_type = rcx.resolve_node_type(expr.id);\n             match ty::get(function_type).sty {\n-                ty::ty_fn(ref fn_ty) => {\n-                    if fn_ty.meta.proto == ast::ProtoBorrowed {\n-                        constrain_free_variables(\n-                            rcx, fn_ty.meta.region, expr);\n-                    }\n+                ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n+                                              region: region, _}) => {\n+                    constrain_free_variables(rcx, region, expr);\n                 }\n                 _ => ()\n             }"}, {"sha": "f0956df545c41bc806668f9551530beb49a1cece", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -12,7 +12,6 @@\n \n use core::prelude::*;\n \n-use middle::ty::{FnTyBase};\n use middle::ty;\n use middle::typeck::check::self_info;\n use middle::typeck::isr_alist;\n@@ -27,22 +26,6 @@ use syntax::print::pprust::{expr_to_str};\n \n // Helper functions related to manipulating region types.\n \n-pub fn replace_bound_regions_in_fn_ty(\n-    tcx: ty::ctxt,\n-    isr: isr_alist,\n-    self_info: Option<self_info>,\n-    fn_ty: &ty::FnTy,\n-    mapf: fn(ty::bound_region) -> ty::Region) ->\n-    {isr: isr_alist, self_info: Option<self_info>, fn_ty: ty::FnTy} {\n-    let {isr, self_info, fn_sig} =\n-        replace_bound_regions_in_fn_sig(\n-            tcx, isr, self_info, &fn_ty.sig, mapf);\n-    {isr: isr,\n-     self_info: self_info,\n-     fn_ty: FnTyBase {meta: fn_ty.meta,\n-                      sig: fn_sig}}\n-}\n-\n pub fn replace_bound_regions_in_fn_sig(\n     tcx: ty::ctxt,\n     isr: isr_alist,"}, {"sha": "abd4697eb31a83abfaccae2d060377b82498de63", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -233,7 +233,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n             relate_trait_tys(vcx, location_info, trait_ty, ty);\n             if !allow_unsafe && !is_early {\n                 for vec::each(*ty::trait_methods(tcx, did)) |m| {\n-                    if ty::type_has_self(ty::mk_fn(tcx, /*bad*/copy m.fty)) {\n+                    if ty::type_has_self(ty::mk_bare_fn(tcx, copy m.fty)) {\n                         tcx.sess.span_err(\n                             location_info.span,\n                             ~\"a boxed trait with self types may not be \\"}, {"sha": "8fc8c4f6cbb8df20f3d6ae594908252e9a8de176", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -26,10 +26,10 @@ use middle::resolve::{Impl, MethodInfo};\n use middle::ty::{ProvidedMethodSource, ProvidedMethodInfo, bound_copy, get};\n use middle::ty::{kind_can_be_copied, lookup_item_type, param_bounds, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n-use middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_infer, ty_int, ty_nil};\n+use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};\n use middle::ty::{ty_rec, ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n-use middle::ty::{ty_type, ty_uint, ty_uniq};\n+use middle::ty::{ty_type, ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_kind_ext};\n use middle::ty::{type_is_ty_var};\n use middle::ty;\n@@ -108,7 +108,7 @@ pub fn get_base_type(inference_context: @InferCtxt,\n \n         ty_nil | ty_bot | ty_bool | ty_int(*) | ty_uint(*) | ty_float(*) |\n         ty_estr(*) | ty_evec(*) | ty_rec(*) |\n-        ty_fn(*) | ty_tup(*) | ty_infer(*) |\n+        ty_bare_fn(*) | ty_closure(*) | ty_tup(*) | ty_infer(*) |\n         ty_param(*) | ty_self | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err => {\n             debug!(\"(getting base type) no base type; found %?\","}, {"sha": "120fd89e5ebdf279656e894e3dd3109f65bf2a33", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 68, "deletions": 118, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -33,10 +33,10 @@ are represented as `ty_param()` instances.\n use core::prelude::*;\n \n use metadata::csearch;\n-use middle::ty::{FnMeta, FnSig, FnTyBase, InstantiatedTraitRef, arg};\n+use middle::ty::{InstantiatedTraitRef, arg};\n use middle::ty::{substs, ty_param_substs_and_ty};\n use middle::ty;\n-use middle::typeck::astconv::{ast_conv, ty_of_fn_decl, ty_of_arg};\n+use middle::typeck::astconv::{ast_conv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::infer;\n@@ -153,9 +153,10 @@ pub impl @crate_ctxt: ast_conv {\n \n pub fn get_enum_variant_types(ccx: @crate_ctxt,\n                               enum_ty: ty::t,\n-                              variants: ~[ast::variant],\n-                              ty_params: ~[ast::ty_param],\n-                              rp: Option<ty::region_variance>) {\n+                              variants: &[ast::variant],\n+                              ty_params: &[ast::ty_param],\n+                              rp: Option<ty::region_variance>)\n+{\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n@@ -166,70 +167,45 @@ pub fn get_enum_variant_types(ccx: @crate_ctxt,\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let rs = type_rscope(rp);\n-                let args = args.map(|va| {\n-                    let arg_ty = ccx.to_ty(rs, va.ty);\n-                    arg { mode: ast::expl(ast::by_copy), ty: arg_ty }\n-                });\n-                result_ty = Some(ty::mk_fn(tcx, FnTyBase {\n-                    meta: FnMeta {purity: ast::pure_fn,\n-                                  proto: ast::ProtoBare,\n-                                  onceness: ast::Many,\n-                                  bounds: @~[],\n-                                  region: ty::re_static},\n-                    sig: FnSig {inputs: args,\n-                                output: enum_ty}\n-                }));\n+                let input_tys = args.map(|va| ccx.to_ty(rs, va.ty));\n+                result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n             }\n+\n             ast::tuple_variant_kind(_) => {\n                 result_ty = Some(enum_ty);\n             }\n+\n             ast::struct_variant_kind(struct_def) => {\n-                // XXX: Merge with computation of the the same value below?\n-                let tpt = {\n-                    bounds: ty_param_bounds(ccx, /*bad*/copy ty_params),\n-                    region_param: rp,\n-                    ty: enum_ty\n-                };\n-                convert_struct(\n-                    ccx,\n-                    rp,\n-                    struct_def,\n-                    /*bad*/copy ty_params,\n-                    tpt,\n-                    variant.node.id);\n-                // Compute the ctor arg types from the struct fields\n-                let struct_fields = do struct_def.fields.map |struct_field| {\n-                    arg {\n-                        mode: ast::expl(ast::by_val),\n-                        ty: ty::node_id_to_type(ccx.tcx, struct_field.node.id)\n-                    }\n-                };\n-                result_ty = Some(ty::mk_fn(tcx, FnTyBase {\n-                    meta: FnMeta {purity: ast::pure_fn,\n-                                  proto: ast::ProtoBare,\n-                                  onceness: ast::Many,\n-                                  bounds: @~[],\n-                                  region: ty::re_static},\n-                    sig: FnSig {inputs: struct_fields, output: enum_ty }}));\n+                let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n+                           region_param: rp,\n+                           ty: enum_ty};\n+\n+                convert_struct(ccx,\n+                               rp,\n+                               struct_def,\n+                               ty_params.to_vec(),\n+                               tpt,\n+                               variant.node.id);\n+\n+                let input_tys = struct_def.fields.map(\n+                    |f| ty::node_id_to_type(ccx.tcx, f.node.id));\n+                result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n             }\n+\n             ast::enum_variant_kind(ref enum_definition) => {\n-                get_enum_variant_types(ccx,\n-                                       enum_ty,\n-                                       /*bad*/copy enum_definition.variants,\n-                                       /*bad*/copy ty_params,\n-                                       rp);\n+                get_enum_variant_types(ccx, enum_ty,\n+                                       enum_definition.variants,\n+                                       ty_params, rp);\n                 result_ty = None;\n             }\n         };\n \n         match result_ty {\n             None => {}\n             Some(result_ty) => {\n-                let tpt = {\n-                    bounds: ty_param_bounds(ccx, /*bad*/copy ty_params),\n-                    region_param: rp,\n-                    ty: result_ty\n-                };\n+                let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n+                           region_param: rp,\n+                           ty: result_ty};\n                 tcx.tcache.insert(local_def(variant.node.id), tpt);\n                 write_ty_to_tcx(tcx, variant.node.id, result_ty);\n             }\n@@ -279,7 +255,7 @@ pub fn ensure_trait_methods(ccx: @crate_ctxt,\n         };\n         let ty = ty::subst(ccx.tcx,\n                            &substs,\n-                           ty::mk_fn(ccx.tcx, /*bad*/copy m.fty));\n+                           ty::mk_bare_fn(ccx.tcx, copy m.fty));\n         let bounds = @(*trait_bounds + ~[@~[ty::bound_trait(trait_ty)]]\n                        + *m.tps);\n         ccx.tcx.tcache.insert(local_def(am.id),\n@@ -305,7 +281,7 @@ pub fn ensure_trait_methods(ccx: @crate_ctxt,\n                 ast::provided(method) => def_id = local_def(method.id)\n             }\n \n-            let trait_bounds = ty_param_bounds(ccx, copy *params);\n+            let trait_bounds = ty_param_bounds(ccx, *params);\n             let ty_m = trait_method_to_ty_method(*m);\n             let method_ty = ty_of_ty_method(ccx, ty_m, region_paramd, def_id);\n             if ty_m.self_ty.node == ast::sty_static {\n@@ -458,7 +434,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     //   that correspond to the parameters we will find on the impl\n     // - replace self region with a fresh, dummy region\n     let impl_fty = {\n-        let impl_fty = ty::mk_fn(tcx, /*bad*/copy impl_m.fty);\n+        let impl_fty = ty::mk_bare_fn(tcx, copy impl_m.fty);\n         debug!(\"impl_fty (pre-subst): %s\", ppaux::ty_to_str(tcx, impl_fty));\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n@@ -476,7 +452,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             self_ty: Some(self_ty),\n             tps: vec::append(trait_tps, dummy_tps)\n         };\n-        let trait_fty = ty::mk_fn(tcx, /*bad*/copy trait_m.fty);\n+        let trait_fty = ty::mk_bare_fn(tcx, copy trait_m.fty);\n         debug!(\"trait_fty (pre-subst): %s\", ppaux::ty_to_str(tcx, trait_fty));\n         ty::subst(tcx, &substs, trait_fty)\n     };\n@@ -583,9 +559,9 @@ pub fn convert_methods(ccx: @crate_ctxt,\n \n     let tcx = ccx.tcx;\n     do vec::map(ms) |m| {\n-        let bounds = ty_param_bounds(ccx, /*bad*/copy m.tps);\n+        let bounds = ty_param_bounds(ccx, m.tps);\n         let mty = ty_of_method(ccx, *m, rp);\n-        let fty = ty::mk_fn(tcx, /*bad*/copy mty.fty);\n+        let fty = ty::mk_bare_fn(tcx, copy mty.fty);\n         tcx.tcache.insert(\n             local_def(m.id),\n \n@@ -626,13 +602,11 @@ pub fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         ensure_no_ty_param_bounds(ccx, it.span, *ty_params, \"enumeration\");\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n-        get_enum_variant_types(ccx,\n-                               tpt.ty,\n-                               /*bad*/copy (*enum_definition).variants,\n-                               /*bad*/copy *ty_params, rp);\n+        get_enum_variant_types(ccx, tpt.ty, enum_definition.variants,\n+                               *ty_params, rp);\n       }\n       ast::item_impl(ref tps, trait_ref, selfty, ref ms) => {\n-        let i_bounds = ty_param_bounds(ccx, /*bad*/copy *tps);\n+        let i_bounds = ty_param_bounds(ccx, *tps);\n         let selfty = ccx.to_ty(type_rscope(rp), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n@@ -695,13 +669,12 @@ pub fn convert_struct(ccx: @crate_ctxt,\n \n     do option::iter(&struct_def.dtor) |dtor| {\n         // Write the dtor type\n-        let t_dtor = ty::mk_fn(\n+        let t_dtor = ty::mk_bare_fn(\n             tcx,\n-            ty_of_fn_decl(\n-                ccx, type_rscope(rp), ast::ProtoBare,\n-                ast::impure_fn, ast::Many,\n-                /*bounds:*/ @~[], /*opt_region:*/ None,\n-                ast_util::dtor_dec(), None, dtor.span));\n+            astconv::ty_of_bare_fn(\n+                ccx, type_rscope(rp),\n+                ast::impure_fn, ast::RustAbi,\n+                ast_util::dtor_dec()));\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n         tcx.tcache.insert(local_def(dtor.node.id),\n                           {bounds: tpt.bounds,\n@@ -727,25 +700,11 @@ pub fn convert_struct(ccx: @crate_ctxt,\n                 tcx.tcache.insert(local_def(ctor_id), tpt);\n             } else if struct_def.fields[0].node.kind == ast::unnamed_field {\n                 // Tuple-like.\n-                let ctor_fn_ty = ty::mk_fn(tcx, FnTyBase {\n-                    meta: FnMeta {\n-                        purity: ast::pure_fn,\n-                        proto: ast::ProtoBare,\n-                        onceness: ast::Many,\n-                        bounds: @~[],\n-                        region: ty::re_static\n-                    },\n-                    sig: FnSig {\n-                        inputs: do struct_def.fields.map |field| {\n-                            arg {\n-                                mode: ast::expl(ast::by_copy),\n-                                ty: ccx.tcx.tcache.get\n-                                        (&local_def(field.node.id)).ty\n-                            }\n-                        },\n-                        output: selfty\n-                    }\n-                });\n+                let inputs =\n+                    struct_def.fields.map(\n+                        |field| ccx.tcx.tcache.get(\n+                            &local_def(field.node.id)).ty);\n+                let ctor_fn_ty = ty::mk_ctor_fn(tcx, inputs, selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.insert(local_def(ctor_id), {\n                     bounds: tpt.bounds,\n@@ -770,11 +729,9 @@ pub fn ty_of_method(ccx: @crate_ctxt,\n                     m: @ast::method,\n                     rp: Option<ty::region_variance>) -> ty::method {\n     {ident: m.ident,\n-     tps: ty_param_bounds(ccx, /*bad*/copy m.tps),\n-     fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::ProtoBare,\n-                        m.purity, ast::Many,\n-                        /*bounds:*/ @~[], /*opt_region:*/ None,\n-                        m.decl, None, m.span),\n+     tps: ty_param_bounds(ccx, m.tps),\n+     fty: astconv::ty_of_bare_fn(ccx, type_rscope(rp), m.purity,\n+                                 ast::RustAbi, m.decl),\n      self_ty: m.self_ty.node,\n      vis: m.vis,\n      def_id: local_def(m.id)}\n@@ -785,11 +742,9 @@ pub fn ty_of_ty_method(self: @crate_ctxt,\n                        rp: Option<ty::region_variance>,\n                        id: ast::def_id) -> ty::method {\n     {ident: m.ident,\n-     tps: ty_param_bounds(self, /*bad*/copy m.tps),\n-     fty: ty_of_fn_decl(self, type_rscope(rp), ast::ProtoBare,\n-                        m.purity, ast::Many,\n-                        /*bounds:*/ @~[], /*opt_region:*/ None,\n-                        m.decl, None, m.span),\n+     tps: ty_param_bounds(self, m.tps),\n+     fty: astconv::ty_of_bare_fn(self, type_rscope(rp), m.purity,\n+                                 ast::RustAbi, m.decl),\n      // assume public, because this is only invoked on trait methods\n      self_ty: m.self_ty.node,\n      vis: ast::public,\n@@ -844,13 +799,11 @@ pub fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n       }\n       ast::item_fn(decl, purity, tps, _) => {\n         let bounds = ty_param_bounds(ccx, tps);\n-        let tofd = ty_of_fn_decl(ccx, empty_rscope,\n-                                 ast::ProtoBare, purity, ast::Many,\n-                                 /*bounds:*/ @~[], /*opt_region:*/ None,\n-                                 decl, None, it.span);\n+        let tofd = astconv::ty_of_bare_fn(ccx, empty_rscope, purity,\n+                                          ast::RustAbi, decl);\n         let tpt = {bounds: bounds,\n                    region_param: None,\n-                   ty: ty::mk_fn(ccx.tcx, tofd)};\n+                   ty: ty::mk_bare_fn(ccx.tcx, tofd)};\n         debug!(\"type of %s (id %d) is %s\",\n                tcx.sess.str_of(it.ident),\n                it.id,\n@@ -976,7 +929,7 @@ pub fn compute_bounds(ccx: @crate_ctxt,\n }\n \n pub fn ty_param_bounds(ccx: @crate_ctxt,\n-                       params: ~[ast::ty_param]) -> @~[ty::param_bounds] {\n+                       params: &[ast::ty_param]) -> @~[ty::param_bounds] {\n     @do params.map |param| {\n         match ccx.tcx.ty_param_bounds.find(&param.id) {\n           Some(bs) => bs,\n@@ -999,15 +952,13 @@ pub fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, rb, *a, None) );\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n \n-    let t_fn = ty::mk_fn(ccx.tcx, FnTyBase {\n-        meta: FnMeta {purity: ast::unsafe_fn,\n-                      onceness: ast::Many,\n-                      proto: ast::ProtoBare,\n-                      bounds: @~[],\n-                      region: ty::re_static},\n-        sig: FnSig {inputs: input_tys,\n-                    output: output_ty}\n-    });\n+    let t_fn = ty::mk_bare_fn(\n+        ccx.tcx,\n+        ty::BareFnTy {\n+            abi: ast::RustAbi,\n+            purity: ast::unsafe_fn,\n+            sig: ty::FnSig {inputs: input_tys, output: output_ty}\n+        });\n     let tpt = {bounds: bounds, region_param: None, ty: t_fn};\n     ccx.tcx.tcache.insert(def_id, tpt);\n     return tpt;\n@@ -1017,8 +968,7 @@ pub fn mk_ty_params(ccx: @crate_ctxt, atps: ~[ast::ty_param])\n     -> {bounds: @~[ty::param_bounds], params: ~[ty::t]} {\n \n     let mut i = 0u;\n-    // XXX: Bad copy.\n-    let bounds = ty_param_bounds(ccx, copy atps);\n+    let bounds = ty_param_bounds(ccx, atps);\n     {bounds: bounds,\n      params: vec::map(atps, |atp| {\n          let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));"}, {"sha": "5d291fdde77b386a43f2094c529adf32a8df9470", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -69,7 +69,7 @@ use core::prelude::*;\n use middle::ty::{TyVar, AutoPtr, AutoBorrowVec, AutoBorrowFn};\n use middle::ty::{AutoAdjustment, AutoRef};\n use middle::ty::{vstore_slice, vstore_box, vstore_uniq, vstore_fixed};\n-use middle::ty::{FnMeta, FnTyBase, mt};\n+use middle::ty::{mt};\n use middle::ty;\n use middle::typeck::infer::{CoerceResult, resolve_type};\n use middle::typeck::infer::combine::CombineFields;\n@@ -117,7 +117,7 @@ impl Coerce {\n                 };\n             }\n \n-            ty::ty_fn(ref b_f) if b_f.meta.proto == ast::ProtoBorrowed => {\n+            ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil, _}) => {\n                 return do self.unpack_actual_value(a) |sty_a| {\n                     self.coerce_borrowed_fn(a, sty_a, b)\n                 };\n@@ -134,7 +134,7 @@ impl Coerce {\n \n         do self.unpack_actual_value(a) |sty_a| {\n             match *sty_a {\n-                ty::ty_fn(ref a_f) if a_f.meta.proto == ast::ProtoBare => {\n+                ty::ty_bare_fn(ref a_f) => {\n                     // Bare functions are coercable to any closure type.\n                     //\n                     // FIXME(#3320) this should go away and be\n@@ -289,9 +289,9 @@ impl Coerce {\n                b.inf_str(self.infcx));\n \n         let fn_ty = match *sty_a {\n-            ty::ty_fn(ref f) if f.meta.proto == ast::ProtoBox => {f}\n-            ty::ty_fn(ref f) if f.meta.proto == ast::ProtoUniq => {f}\n-            ty::ty_fn(ref f) if f.meta.proto == ast::ProtoBare => {\n+            ty::ty_closure(ref f) if f.sigil == ast::ManagedSigil => copy *f,\n+            ty::ty_closure(ref f) if f.sigil == ast::OwnedSigil => copy *f,\n+            ty::ty_bare_fn(ref f) => {\n                 return self.coerce_from_bare_fn(a, f, b);\n             }\n             _ => {\n@@ -300,12 +300,13 @@ impl Coerce {\n         };\n \n         let r_borrow = self.infcx.next_region_var_nb(self.span);\n-        let meta = FnMeta {proto: ast::ProtoBorrowed,\n-                           region: r_borrow,\n-                           ..fn_ty.meta};\n-        let a_borrowed = ty::mk_fn(self.infcx.tcx,\n-                                   FnTyBase {meta: meta,\n-                                             sig: copy fn_ty.sig});\n+        let a_borrowed = ty::mk_closure(\n+            self.infcx.tcx,\n+            ty::ClosureTy {\n+                sigil: ast::BorrowedSigil,\n+                region: r_borrow,\n+                ..fn_ty\n+            });\n \n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoAdjustment {\n@@ -320,7 +321,7 @@ impl Coerce {\n \n     fn coerce_from_bare_fn(&self,\n                            a: ty::t,\n-                           fn_ty_a: &ty::FnTy,\n+                           fn_ty_a: &ty::BareFnTy,\n                            b: ty::t) -> CoerceResult\n     {\n         do self.unpack_actual_value(b) |sty_b| {\n@@ -330,26 +331,26 @@ impl Coerce {\n \n     fn coerce_from_bare_fn_post_unpack(&self,\n                                        a: ty::t,\n-                                       fn_ty_a: &ty::FnTy,\n+                                       fn_ty_a: &ty::BareFnTy,\n                                        b: ty::t,\n                                        sty_b: &ty::sty) -> CoerceResult\n     {\n         debug!(\"coerce_from_bare_fn(a=%s, b=%s)\",\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n         let fn_ty_b = match *sty_b {\n-            ty::ty_fn(ref f) if f.meta.proto != ast::ProtoBare => {f}\n+            ty::ty_closure(ref f) => {copy *f}\n             _ => {\n                 return self.subtype(a, b);\n             }\n         };\n \n-            // for now, bare fn and closures have the same\n-            // representation\n-        let a_adapted = ty::mk_fn(self.infcx.tcx,\n-                                  FnTyBase {meta: copy fn_ty_b.meta,\n-                                            sig: copy fn_ty_a.sig});\n-        self.subtype(a_adapted, b)\n+        // for now, bare fn and closures have the same\n+        // representation\n+        let a_closure = ty::mk_closure(\n+            self.infcx.tcx,\n+            ty::ClosureTy {sig: copy fn_ty_a.sig, ..fn_ty_b});\n+        self.subtype(a_closure, b)\n     }\n \n     fn coerce_unsafe_ptr(&self,"}, {"sha": "7737327bc0c52935f7f292b353aafab6dc9a6ad5", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -56,7 +56,7 @@\n \n use core::prelude::*;\n \n-use middle::ty::{FloatVar, FnTyBase, FnMeta, FnSig, IntVar, TyVar};\n+use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n use middle::ty::{IntType, UintType, arg, substs};\n use middle::ty;\n use middle::typeck::infer::glb::Glb;\n@@ -94,14 +94,17 @@ pub trait Combine {\n     fn self_tys(a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>>;\n     fn substs(did: ast::def_id, as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs>;\n-    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy>;\n+    fn bare_fn_tys(a: &ty::BareFnTy,\n+                   b: &ty::BareFnTy) -> cres<ty::BareFnTy>;\n+    fn closure_tys(a: &ty::ClosureTy,\n+                   b: &ty::ClosureTy) -> cres<ty::ClosureTy>;\n     fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n-    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta>;\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field>;\n     fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode>;\n     fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n-    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto>;\n+    fn sigils(p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil>;\n     fn purities(a: purity, b: purity) -> cres<purity>;\n+    fn abis(a: ast::Abi, b: ast::Abi) -> cres<ast::Abi>;\n     fn oncenesses(a: Onceness, b: Onceness) -> cres<Onceness>;\n     fn contraregions(a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n     fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n@@ -287,12 +290,12 @@ pub fn super_self_tys<C:Combine>(\n     }\n }\n \n-pub fn super_protos<C: Combine>(\n-    self: &C, p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n+pub fn super_sigils<C: Combine>(\n+    self: &C, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n     if p1 == p2 {\n         Ok(p1)\n     } else {\n-        Err(ty::terr_proto_mismatch(expected_found(self, p1, p2)))\n+        Err(ty::terr_sigil_mismatch(expected_found(self, p1, p2)))\n     }\n }\n \n@@ -350,21 +353,45 @@ pub fn super_vstores<C:Combine>(\n     }\n }\n \n-pub fn super_fn_metas<C:Combine>(\n-    self: &C, a_f: &ty::FnMeta, b_f: &ty::FnMeta) -> cres<ty::FnMeta> {\n-    let p = if_ok!(self.protos(a_f.proto, b_f.proto));\n+pub fn super_closure_tys<C:Combine>(\n+    self: &C, a_f: &ty::ClosureTy, b_f: &ty::ClosureTy) -> cres<ty::ClosureTy>\n+{\n+    let p = if_ok!(self.sigils(a_f.sigil, b_f.sigil));\n     let r = if_ok!(self.contraregions(a_f.region, b_f.region));\n     let purity = if_ok!(self.purities(a_f.purity, b_f.purity));\n     let onceness = if_ok!(self.oncenesses(a_f.onceness, b_f.onceness));\n-    Ok(FnMeta {purity: purity,\n-               proto: p,\n-               onceness: onceness,\n-               region: r,\n-               bounds: a_f.bounds}) // XXX: This is wrong!\n+    let sig = if_ok!(self.fn_sigs(&a_f.sig, &b_f.sig));\n+    Ok(ty::ClosureTy {purity: purity,\n+                      sigil: p,\n+                      onceness: onceness,\n+                      region: r,\n+                      sig: sig})\n+}\n+\n+pub fn super_abis<C:Combine>(\n+    self: &C, a: ast::Abi, b: ast::Abi) -> cres<ast::Abi>\n+{\n+    if a == b {\n+        Ok(a)\n+    } else {\n+        Err(ty::terr_abi_mismatch(expected_found(self, a, b)))\n+    }\n+}\n+\n+pub fn super_bare_fn_tys<C:Combine>(\n+    self: &C, a_f: &ty::BareFnTy, b_f: &ty::BareFnTy) -> cres<ty::BareFnTy>\n+{\n+    let purity = if_ok!(self.purities(a_f.purity, b_f.purity));\n+    let abi = if_ok!(self.abis(a_f.abi, b_f.abi));\n+    let sig = if_ok!(self.fn_sigs(&a_f.sig, &b_f.sig));\n+    Ok(ty::BareFnTy {purity: purity,\n+                     abi: abi,\n+                     sig: sig})\n }\n \n pub fn super_fn_sigs<C:Combine>(\n-    self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig> {\n+    self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig>\n+{\n     fn argvecs<C:Combine>(self: &C,\n                           +a_args: ~[ty::arg],\n                           +b_args: ~[ty::arg]) -> cres<~[ty::arg]>\n@@ -384,13 +411,6 @@ pub fn super_fn_sigs<C:Combine>(\n     }\n }\n \n-pub fn super_fns<C:Combine>(\n-    self: &C, a_f: &ty::FnTy, b_f: &ty::FnTy) -> cres<ty::FnTy> {\n-    let m = if_ok!(self.fn_metas(&a_f.meta, &b_f.meta));\n-    let s = if_ok!(self.fn_sigs(&a_f.sig, &b_f.sig));\n-    Ok(FnTyBase {meta: m, sig: s})\n-}\n-\n pub fn super_tys<C:Combine>(\n     self: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n     let tcx = self.infcx().tcx;\n@@ -551,9 +571,15 @@ pub fn super_tys<C:Combine>(\n         }\n       }\n \n-      (ty::ty_fn(ref a_fty), ty::ty_fn(ref b_fty)) => {\n-        do self.fns(a_fty, b_fty).chain |fty| {\n-            Ok(ty::mk_fn(tcx, fty))\n+      (ty::ty_bare_fn(ref a_fty), ty::ty_bare_fn(ref b_fty)) => {\n+        do self.bare_fn_tys(a_fty, b_fty).chain |fty| {\n+            Ok(ty::mk_bare_fn(tcx, fty))\n+        }\n+      }\n+\n+      (ty::ty_closure(ref a_fty), ty::ty_closure(ref b_fty)) => {\n+        do self.closure_tys(a_fty, b_fty).chain |fty| {\n+            Ok(ty::mk_closure(tcx, fty))\n         }\n       }\n "}, {"sha": "382d5f24cc74b6dd48f83a245eccaca5043bb357", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -267,16 +267,22 @@ pub impl Glb: Combine {\n         }\n     }\n \n-    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n-        super_protos(&self, p1, p2)\n+    fn sigils(p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n+        super_sigils(&self, p1, p2)\n     }\n \n-    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n-        super_fns(&self, a, b)\n+    fn abis(p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n+        super_abis(&self, p1, p2)\n     }\n \n-    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n-        super_fn_metas(&self, a, b)\n+    fn bare_fn_tys(a: &ty::BareFnTy,\n+                   b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n+        super_bare_fn_tys(&self, a, b)\n+    }\n+\n+    fn closure_tys(a: &ty::ClosureTy,\n+                   b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n+        super_closure_tys(&self, a, b)\n     }\n \n     fn substs(did: ast::def_id,"}, {"sha": "4bf8a0bae8623dd29af701251024aef4d89fc9e2", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -71,23 +71,6 @@ pub impl ty::t: LatticeValue {\n     }\n }\n \n-pub impl FnMeta: LatticeValue {\n-    static fn sub(cf: &CombineFields,\n-                  a: &FnMeta, b: &FnMeta) -> ures {\n-        Sub(*cf).fn_metas(a, b).to_ures()\n-    }\n-\n-    static fn lub(cf: &CombineFields,\n-                  a: &FnMeta, b: &FnMeta) -> cres<FnMeta> {\n-        Lub(*cf).fn_metas(a, b)\n-    }\n-\n-    static fn glb(cf: &CombineFields,\n-                  a: &FnMeta, b: &FnMeta) -> cres<FnMeta> {\n-        Glb(*cf).fn_metas(a, b)\n-    }\n-}\n-\n pub impl CombineFields {\n     fn var_sub_var<T:Copy InferStr LatticeValue,\n                    V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>("}, {"sha": "44ad367c9dcf9d5e79232e6373bcfdaa586ce227", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -191,18 +191,24 @@ pub impl Lub: Combine {\n         }\n     }\n \n-    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n-        super_fns(&self, a, b)\n+    fn bare_fn_tys(a: &ty::BareFnTy,\n+                   b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n+        super_bare_fn_tys(&self, a, b)\n     }\n \n-    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n-        super_fn_metas(&self, a, b)\n+    fn closure_tys(a: &ty::ClosureTy,\n+                   b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n+        super_closure_tys(&self, a, b)\n     }\n \n     // Traits please (FIXME: #2794):\n \n-    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n-        super_protos(&self, p1, p2)\n+    fn sigils(p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n+        super_sigils(&self, p1, p2)\n+    }\n+\n+    fn abis(p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n+        super_abis(&self, p1, p2)\n     }\n \n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {"}, {"sha": "d6ecf11ef26faf96556a5757ca4b252026e5f089", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -242,9 +242,6 @@ section on \"Type Combining\" below for details.\n \n */\n \n-#[warn(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n-\n use core::prelude::*;\n \n pub use middle::ty::IntVarValue;\n@@ -257,7 +254,6 @@ pub use middle::typeck::infer::resolve::{resolve_nested_tvar};\n pub use middle::typeck::infer::resolve::{resolve_rvar};\n \n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n-use middle::ty::{mk_fn, type_is_bot};\n use middle::ty::{ty_int, ty_uint, get, terr_fn, TyVar, IntVar, FloatVar};\n use middle::ty;\n use middle::typeck::check::regionmanip::{replace_bound_regions_in_fn_sig};"}, {"sha": "afb18888cd90587b0d2586a9b3d17cedc3cd860d", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -536,9 +536,6 @@ more convincing in the future.\n \n */\n \n-#[warn(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n-\n use core::prelude::*;\n \n use middle::region::is_subregion_of;"}, {"sha": "bc834ef0289964773ff6c561841f90794fb91fa9", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -212,20 +212,26 @@ pub impl Sub: Combine {\n \n     // Traits please (FIXME: #2794):\n \n-    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n-        super_protos(&self, p1, p2)\n+    fn sigils(p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n+        super_sigils(&self, p1, p2)\n+    }\n+\n+    fn abis(p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n+        super_abis(&self, p1, p2)\n     }\n \n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n         super_flds(&self, a, b)\n     }\n \n-    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n-        super_fns(&self, a, b)\n+    fn bare_fn_tys(a: &ty::BareFnTy,\n+                   b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n+        super_bare_fn_tys(&self, a, b)\n     }\n \n-    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n-        super_fn_metas(&self, a, b)\n+    fn closure_tys(a: &ty::ClosureTy,\n+                   b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n+        super_closure_tys(&self, a, b)\n     }\n \n     fn vstores(vk: ty::terr_vstore_kind,"}, {"sha": "bade7639e4baf60a2828c83138b24ed65ee54966", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,7 +10,7 @@\n \n use core::prelude::*;\n \n-use middle::ty::{FnMeta, FnTyBase, FnSig, Vid};\n+use middle::ty::{FnSig, Vid};\n use middle::ty::{IntVarValue, IntType, UintType};\n use middle::ty;\n use middle::typeck::infer::{Bound, Bounds};\n@@ -34,12 +34,6 @@ pub impl ty::t : InferStr {\n     }\n }\n \n-pub impl FnMeta : InferStr {\n-    fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n-        fmt!(\"%?\", *self)\n-    }\n-}\n-\n pub impl FnSig : InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         fmt!(\"(%s) -> %s\",\n@@ -48,12 +42,6 @@ pub impl FnSig : InferStr {\n     }\n }\n \n-pub impl<M:InferStr> FnTyBase<M> : InferStr {\n-    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n-        fmt!(\"%s%s\", self.meta.inf_str(cx), self.sig.inf_str(cx))\n-    }\n-}\n-\n pub impl ty::mt : InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         mt_to_str(cx.tcx, *self)"}, {"sha": "3d9e2e7b86ab28b433a81064c9e68450b565fc75", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -324,7 +324,7 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).sty {\n-        ty::ty_fn(ref fn_ty) => {\n+        ty::ty_bare_fn(ref fn_ty) => {\n             match tcx.items.find(&main_id) {\n                 Some(ast_map::node_item(it,_)) => {\n                     match it.node {\n@@ -341,8 +341,8 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n                 }\n                 _ => ()\n             }\n-            let mut ok = ty::type_is_nil((*fn_ty).sig.output);\n-            let num_args = vec::len((*fn_ty).sig.inputs);\n+            let mut ok = ty::type_is_nil(fn_ty.sig.output);\n+            let num_args = vec::len(fn_ty.sig.inputs);\n             ok &= num_args == 0u;\n             if !ok {\n                 tcx.sess.span_err("}, {"sha": "43d12c95c4df6e348c3cff604854f9b5a90816f3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 85, "deletions": 74, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -21,7 +21,8 @@ use middle::ty::{mt, t, param_bound, param_ty};\n use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region};\n use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{ty_bool, ty_bot, ty_box, ty_struct, ty_enum};\n-use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_fn, ty_trait, ty_int};\n+use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n+use middle::ty::{ty_trait, ty_int};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n use middle::ty::{ty_ptr, ty_rec, ty_rptr, ty_self, ty_tup};\n use middle::ty::{ty_type, ty_uniq, ty_uint, ty_infer};\n@@ -30,7 +31,7 @@ use metadata::encoder;\n use syntax::codemap;\n use syntax::codemap::span;\n use syntax::print::pprust;\n-use syntax::print::pprust::{path_to_str, proto_to_str, mode_to_str};\n+use syntax::print::pprust::{path_to_str, mode_to_str};\n use syntax::{ast, ast_util};\n use syntax::ast_map;\n \n@@ -252,17 +253,6 @@ pub fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n     }\n }\n \n-pub fn proto_ty_to_str(_cx: ctxt, proto: ast::Proto,\n-                       followed_by_word: bool) -> &static/str {\n-    match proto {\n-        ast::ProtoBare if followed_by_word => \"extern \",\n-        ast::ProtoBare => \"extern\",\n-        ast::ProtoBox => \"@\",\n-        ast::ProtoBorrowed => \"&\",\n-        ast::ProtoUniq => \"~\",\n-    }\n-}\n-\n pub fn expr_repr(cx: ctxt, expr: @ast::expr) -> ~str {\n     fmt!(\"expr(%d: %s)\",\n          expr.id,\n@@ -306,69 +296,95 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         };\n         fmt!(\"%s%s\", modestr, ty_to_str(cx, ty))\n     }\n-    fn fn_to_str(cx: ctxt,\n-                 proto: ast::Proto,\n-                 region: ty::Region,\n-                 purity: ast::purity,\n-                 onceness: ast::Onceness,\n-                 ident: Option<ast::ident>,\n-                 inputs: &[arg],\n-                 output: t) -> ~str {\n-        let mut s;\n-\n-        s = match purity {\n-            ast::impure_fn => ~\"\",\n-            _ => purity.to_str() + ~\" \"\n-        };\n+    fn bare_fn_to_str(cx: ctxt,\n+                      purity: ast::purity,\n+                      abi: ast::Abi,\n+                      ident: Option<ast::ident>,\n+                      sig: &ty::FnSig) -> ~str\n+    {\n+        let mut s = ~\"extern \";\n \n-        s += match onceness {\n-            ast::Many => ~\"\",\n-            ast::Once => onceness.to_str() + ~\" \"\n+        match abi {\n+            ast::RustAbi => {}\n+        }\n+\n+        match purity {\n+            ast::impure_fn => {}\n+            _ => {\n+                s.push_str(purity.to_str());\n+                s.push_char(' ');\n+            }\n         };\n \n-        s += proto_ty_to_str(cx, proto, true);\n+        s.push_str(\"fn\");\n \n-        match (proto, region) {\n-            (ast::ProtoBox, ty::re_static) |\n-            (ast::ProtoUniq, ty::re_static) |\n-            (ast::ProtoBare, ty::re_static) => {\n-            }\n+        match ident {\n+          Some(i) => {\n+              s.push_char(' ');\n+              s.push_str(cx.sess.str_of(i));\n+          }\n+          _ => { }\n+        }\n+\n+        push_sig_to_str(cx, &mut s, sig);\n+\n+        return s;\n+    }\n+    fn closure_to_str(cx: ctxt, cty: &ty::ClosureTy) -> ~str\n+    {\n+        let mut s = cty.sigil.to_str();\n+\n+        match (cty.sigil, cty.region) {\n+            (ast::ManagedSigil, ty::re_static) |\n+            (ast::OwnedSigil, ty::re_static) => {}\n \n             (_, region) => {\n-                s += region_to_str_adorned(cx, ~\"\", region, ~\"/\");\n+                s.push_str(region_to_str_adorned(cx, \"\", region, \"/\"));\n             }\n         }\n \n-        s += ~\"fn\";\n+        match cty.purity {\n+            ast::impure_fn => {}\n+            _ => {\n+                s.push_str(cty.purity.to_str());\n+                s.push_char(' ');\n+            }\n+        };\n \n-        match ident {\n-          Some(i) => { s += ~\" \"; s += cx.sess.str_of(i); }\n-          _ => { }\n-        }\n-        s += ~\"(\";\n-        let strs = inputs.map(|a| fn_input_to_str(cx, *a));\n-        s += str::connect(strs, ~\", \");\n-        s += ~\")\";\n-        if ty::get(output).sty != ty_nil {\n-            s += ~\" -> \";\n-            if ty::type_is_bot(output) {\n-                s += ~\"!\";\n+        match cty.onceness {\n+            ast::Many => {}\n+            ast::Once => {\n+                s.push_str(cty.onceness.to_str());\n+                s.push_char(' ');\n+            }\n+        };\n+\n+        s.push_str(\"fn\");\n+\n+        push_sig_to_str(cx, &mut s, &cty.sig);\n+\n+        return s;\n+    }\n+    fn push_sig_to_str(cx: ctxt, s: &mut ~str, sig: &ty::FnSig) {\n+        s.push_char('(');\n+        let strs = sig.inputs.map(|a| fn_input_to_str(cx, *a));\n+        s.push_str(str::connect(strs, \", \"));\n+        s.push_char(')');\n+        if ty::get(sig.output).sty != ty_nil {\n+            s.push_str(\" -> \");\n+            if ty::type_is_bot(sig.output) {\n+                s.push_char('!');\n             } else {\n-                s += ty_to_str(cx, output);\n+                s.push_str(ty_to_str(cx, sig.output));\n             }\n         }\n-        return s;\n     }\n     fn method_to_str(cx: ctxt, m: method) -> ~str {\n-        return fn_to_str(\n-            cx,\n-            m.fty.meta.proto,\n-            m.fty.meta.region,\n-            m.fty.meta.purity,\n-            m.fty.meta.onceness,\n-            Some(m.ident),\n-            m.fty.sig.inputs,\n-            m.fty.sig.output) + ~\";\";\n+        bare_fn_to_str(cx,\n+                       m.fty.purity,\n+                       m.fty.abi,\n+                       Some(m.ident),\n+                       &m.fty.sig) + ~\";\"\n     }\n     fn field_to_str(cx: ctxt, f: field) -> ~str {\n         return cx.sess.str_of(f.ident) + ~\": \" + mt_to_str(cx, f.mt);\n@@ -409,15 +425,11 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         let strs = elems.map(|elem| ty_to_str(cx, *elem));\n         ~\"(\" + str::connect(strs, ~\",\") + ~\")\"\n       }\n-      ty_fn(ref f) => {\n-        fn_to_str(cx,\n-                  f.meta.proto,\n-                  f.meta.region,\n-                  f.meta.purity,\n-                  f.meta.onceness,\n-                  None,\n-                  f.sig.inputs,\n-                  f.sig.output)\n+      ty_closure(ref f) => {\n+          closure_to_str(cx, f)\n+      }\n+      ty_bare_fn(ref f) => {\n+          bare_fn_to_str(cx, f.purity, f.abi, None, &f.sig)\n       }\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_err => ~\"[type error]\",\n@@ -448,10 +460,9 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_estr(vs) => vstore_ty_to_str(cx, ~\"str\", vs),\n       ty_opaque_box => ~\"@?\",\n-      ty_opaque_closure_ptr(ast::ProtoBorrowed) => ~\"closure&\",\n-      ty_opaque_closure_ptr(ast::ProtoBox) => ~\"closure@\",\n-      ty_opaque_closure_ptr(ast::ProtoUniq) => ~\"closure~\",\n-      ty_opaque_closure_ptr(ast::ProtoBare) => ~\"closure\"\n+      ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"closure&\",\n+      ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"closure@\",\n+      ty_opaque_closure_ptr(ast::OwnedSigil) => ~\"closure~\",\n     }\n }\n "}, {"sha": "1d629467a42e9ebd99e22d037832551b68405a31", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -21,6 +21,7 @@ use core::prelude::*;\n \n use parse;\n use util;\n+use std::cell::Cell;\n \n use core::pipes::{stream, Chan, SharedChan, Port};\n use core::vec;\n@@ -78,8 +79,10 @@ fn run<T>(owner: SrvOwner<T>, source: ~str, parse: Parser) -> T {\n \n     let (po, ch) = stream();\n \n+    let source = Cell(source);\n+    let parse = Cell(parse);\n     do task::spawn {\n-        act(&po, copy source, copy parse);\n+        act(&po, source.take(), parse.take());\n     }\n \n     let srv_ = Srv {"}, {"sha": "0beb651afc4ed1f3ab0768307c407283247adfff", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -96,7 +96,7 @@ fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n }\n \n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n-    let doc_strs = do doc_metas(attrs).filter_map |meta| {\n+    let doc_strs = do doc_metas(attrs).filter_mapped |meta| {\n         attr::get_meta_item_value_str(*meta)\n     };\n     if doc_strs.is_empty() {"}, {"sha": "2d0969562a05cd61014d6b26b435613a7721739f", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -62,7 +62,7 @@ fn fold_trait(fold: &fold::Fold<()>, doc: doc::TraitDoc) -> doc::TraitDoc {\n     let doc =fold::default_seq_fold_trait(fold, doc);\n \n     doc::TraitDoc {\n-        methods: par::map(doc.methods, |doc| doc::MethodDoc {\n+        methods: doc.methods.map(|doc| doc::MethodDoc {\n             brief: extract(copy doc.desc),\n             .. copy *doc\n         }),\n@@ -74,7 +74,7 @@ fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n     let doc =fold::default_seq_fold_impl(fold, doc);\n \n     doc::ImplDoc {\n-        methods: par::map(doc.methods, |doc| doc::MethodDoc {\n+        methods: doc.methods.map(|doc| doc::MethodDoc {\n             brief: extract(copy doc.desc),\n             .. copy *doc\n         }),"}, {"sha": "2eb4ed97871323801149d2d1d9b4b1bcbb6485b0", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -192,7 +192,7 @@ impl Doc {\n /// Some helper methods on ModDoc, mostly for testing\n impl ModDoc {\n     fn mods(&self) -> ~[ModDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               ModTag(ModDoc) => Some(ModDoc),\n               _ => None\n@@ -201,7 +201,7 @@ impl ModDoc {\n     }\n \n     fn nmods(&self) -> ~[NmodDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               NmodTag(nModDoc) => Some(nModDoc),\n               _ => None\n@@ -210,7 +210,7 @@ impl ModDoc {\n     }\n \n     fn fns(&self) -> ~[FnDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               FnTag(FnDoc) => Some(FnDoc),\n               _ => None\n@@ -219,7 +219,7 @@ impl ModDoc {\n     }\n \n     fn consts(&self) -> ~[ConstDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               ConstTag(ConstDoc) => Some(ConstDoc),\n               _ => None\n@@ -228,7 +228,7 @@ impl ModDoc {\n     }\n \n     fn enums(&self) -> ~[EnumDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               EnumTag(EnumDoc) => Some(EnumDoc),\n               _ => None\n@@ -237,7 +237,7 @@ impl ModDoc {\n     }\n \n     fn traits(&self) -> ~[TraitDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               TraitTag(TraitDoc) => Some(TraitDoc),\n               _ => None\n@@ -246,7 +246,7 @@ impl ModDoc {\n     }\n \n     fn impls(&self) -> ~[ImplDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               ImplTag(ImplDoc) => Some(ImplDoc),\n               _ => None\n@@ -255,7 +255,7 @@ impl ModDoc {\n     }\n \n     fn types(&self) -> ~[TyDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               TyTag(TyDoc) => Some(TyDoc),\n               _ => None\n@@ -264,7 +264,7 @@ impl ModDoc {\n     }\n \n     fn structs(&self) -> ~[StructDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n                 StructTag(StructDoc) => Some(StructDoc),\n                 _ => None\n@@ -287,7 +287,7 @@ pub trait PageUtils {\n impl ~[Page]: PageUtils {\n \n     fn mods(&self) -> ~[ModDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(ModTag(ModDoc)) => Some(ModDoc),\n               _ => None\n@@ -296,7 +296,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn nmods(&self) -> ~[NmodDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(NmodTag(nModDoc)) => Some(nModDoc),\n               _ => None\n@@ -305,7 +305,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn fns(&self) -> ~[FnDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(FnTag(FnDoc)) => Some(FnDoc),\n               _ => None\n@@ -314,7 +314,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn consts(&self) -> ~[ConstDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(ConstTag(ConstDoc)) => Some(ConstDoc),\n               _ => None\n@@ -323,7 +323,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn enums(&self) -> ~[EnumDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(EnumTag(EnumDoc)) => Some(EnumDoc),\n               _ => None\n@@ -332,7 +332,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn traits(&self) -> ~[TraitDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(TraitTag(TraitDoc)) => Some(TraitDoc),\n               _ => None\n@@ -341,7 +341,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn impls(&self) -> ~[ImplDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(ImplTag(ImplDoc)) => Some(ImplDoc),\n               _ => None\n@@ -350,7 +350,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn types(&self) -> ~[TyDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(TyTag(TyDoc)) => Some(TyDoc),\n               _ => None"}, {"sha": "822a423eae40ca31929fde8f359585f06eb2f4da", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -92,7 +92,7 @@ fn moddoc_from_mod(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: itemdoc,\n-        items: do vec::filter_map(module_.items) |item| {\n+        items: do vec::filter_mapped(module_.items) |item| {\n             let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n             match copy item.node {\n               ast::item_mod(m) => {"}, {"sha": "e9b25b07de15bdb5c25f65300411e9cbdcdb0a72", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -55,23 +55,23 @@ impl<T: Clone> Fold<T>: Clone {\n     }\n }\n \n-type FoldDoc<T> = fn~(fold: &Fold<T>, doc: doc::Doc) -> doc::Doc;\n-type FoldCrate<T> = fn~(fold: &Fold<T>, doc: doc::CrateDoc) -> doc::CrateDoc;\n-type FoldItem<T> = fn~(fold: &Fold<T>, doc: doc::ItemDoc) -> doc::ItemDoc;\n-type FoldMod<T> = fn~(fold: &Fold<T>, doc: doc::ModDoc) -> doc::ModDoc;\n-type FoldNmod<T> = fn~(fold: &Fold<T>, doc: doc::NmodDoc) -> doc::NmodDoc;\n-type FoldFn<T> = fn~(fold: &Fold<T>, doc: doc::FnDoc) -> doc::FnDoc;\n-type FoldConst<T> = fn~(fold: &Fold<T>, doc: doc::ConstDoc) -> doc::ConstDoc;\n-type FoldEnum<T> = fn~(fold: &Fold<T>, doc: doc::EnumDoc) -> doc::EnumDoc;\n-type FoldTrait<T> = fn~(fold: &Fold<T>, doc: doc::TraitDoc) -> doc::TraitDoc;\n-type FoldImpl<T> = fn~(fold: &Fold<T>, doc: doc::ImplDoc) -> doc::ImplDoc;\n-type FoldType<T> = fn~(fold: &Fold<T>, doc: doc::TyDoc) -> doc::TyDoc;\n-type FoldStruct<T> = fn~(fold: &Fold<T>,\n+type FoldDoc<T> = @fn(fold: &Fold<T>, doc: doc::Doc) -> doc::Doc;\n+type FoldCrate<T> = @fn(fold: &Fold<T>, doc: doc::CrateDoc) -> doc::CrateDoc;\n+type FoldItem<T> = @fn(fold: &Fold<T>, doc: doc::ItemDoc) -> doc::ItemDoc;\n+type FoldMod<T> = @fn(fold: &Fold<T>, doc: doc::ModDoc) -> doc::ModDoc;\n+type FoldNmod<T> = @fn(fold: &Fold<T>, doc: doc::NmodDoc) -> doc::NmodDoc;\n+type FoldFn<T> = @fn(fold: &Fold<T>, doc: doc::FnDoc) -> doc::FnDoc;\n+type FoldConst<T> = @fn(fold: &Fold<T>, doc: doc::ConstDoc) -> doc::ConstDoc;\n+type FoldEnum<T> = @fn(fold: &Fold<T>, doc: doc::EnumDoc) -> doc::EnumDoc;\n+type FoldTrait<T> = @fn(fold: &Fold<T>, doc: doc::TraitDoc) -> doc::TraitDoc;\n+type FoldImpl<T> = @fn(fold: &Fold<T>, doc: doc::ImplDoc) -> doc::ImplDoc;\n+type FoldType<T> = @fn(fold: &Fold<T>, doc: doc::TyDoc) -> doc::TyDoc;\n+type FoldStruct<T> = @fn(fold: &Fold<T>,\n                          doc: doc::StructDoc) -> doc::StructDoc;\n \n // This exists because fn types don't infer correctly as record\n // initializers, but they do as function arguments\n-fn mk_fold<T:Clone>(\n+fn mk_fold<T>(\n     ctxt: T,\n     fold_doc: FoldDoc<T>,\n     fold_crate: FoldCrate<T>,\n@@ -103,7 +103,7 @@ fn mk_fold<T:Clone>(\n     }\n }\n \n-pub fn default_any_fold<T:Owned Clone>(ctxt: T) -> Fold<T> {\n+pub fn default_any_fold<T: Clone>(ctxt: T) -> Fold<T> {\n     mk_fold(\n         move ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -121,7 +121,7 @@ pub fn default_any_fold<T:Owned Clone>(ctxt: T) -> Fold<T> {\n     )\n }\n \n-pub fn default_seq_fold<T:Clone>(ctxt: T) -> Fold<T> {\n+pub fn default_seq_fold<T: Clone>(ctxt: T) -> Fold<T> {\n     mk_fold(\n         move ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -139,7 +139,7 @@ pub fn default_seq_fold<T:Clone>(ctxt: T) -> Fold<T> {\n     )\n }\n \n-pub fn default_par_fold<T:Owned Clone>(ctxt: T) -> Fold<T> {\n+pub fn default_par_fold<T: Clone>(ctxt: T) -> Fold<T> {\n     mk_fold(\n         move ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -189,7 +189,7 @@ pub fn default_seq_fold_item<T>(\n     doc\n }\n \n-pub fn default_any_fold_mod<T:Owned Clone>(\n+pub fn default_any_fold_mod<T:Clone>(\n     fold: &Fold<T>,\n     doc: doc::ModDoc\n ) -> doc::ModDoc {\n@@ -215,7 +215,7 @@ pub fn default_seq_fold_mod<T>(\n     }\n }\n \n-pub fn default_par_fold_mod<T:Owned Clone>(\n+pub fn default_par_fold_mod<T:Clone>(\n     fold: &Fold<T>,\n     doc: doc::ModDoc\n ) -> doc::ModDoc {\n@@ -228,7 +228,7 @@ pub fn default_par_fold_mod<T:Owned Clone>(\n     }\n }\n \n-pub fn default_any_fold_nmod<T:Owned Clone>(\n+pub fn default_any_fold_nmod<T:Clone>(\n     fold: &Fold<T>,\n     doc: doc::NmodDoc\n ) -> doc::NmodDoc {\n@@ -254,7 +254,7 @@ pub fn default_seq_fold_nmod<T>(\n     }\n }\n \n-pub fn default_par_fold_nmod<T:Owned Clone>(\n+pub fn default_par_fold_nmod<T:Clone>(\n     fold: &Fold<T>,\n     doc: doc::NmodDoc\n ) -> doc::NmodDoc {"}, {"sha": "42a7d0006db09f4ebcdd786e759a17ef4d63ee46", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -28,9 +28,7 @@ use std::par;\n pub fn mk_pass(config: config::Config) -> Pass {\n     Pass {\n         name: ~\"markdown_index\",\n-        f: fn~(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-            run(srv, doc, copy config)\n-        }\n+        f: |srv, doc| run(srv, doc, copy config)\n     }\n }\n \n@@ -78,7 +76,7 @@ fn build_mod_index(\n     config: config::Config\n ) -> doc::Index {\n     doc::Index {\n-        entries: par::map(doc.items, |doc| {\n+        entries: doc.items.map(|doc| {\n             item_to_entry(copy *doc, copy config)\n         })\n     }\n@@ -89,7 +87,7 @@ fn build_nmod_index(\n     config: config::Config\n ) -> doc::Index {\n     doc::Index {\n-        entries: par::map(doc.fns, |doc| {\n+        entries: doc.fns.map(|doc| {\n             item_to_entry(doc::FnTag(copy *doc), copy config)\n         })\n     }"}, {"sha": "161642a2f3d974e4ba53b6247c27683e34c8da4b", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -43,14 +43,9 @@ use syntax;\n \n pub fn mk_pass(writer_factory: WriterFactory) -> Pass {\n     let writer_factory = Cell(writer_factory);\n-    let f = fn~(move writer_factory,\n-                srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-        run(srv, doc, writer_factory.take())\n-    };\n-\n     Pass {\n         name: ~\"markdown\",\n-        f: move f\n+        f: |srv, doc| run(srv, doc, writer_factory.take())\n     }\n }\n "}, {"sha": "08abe4b351b6f1008beefaebce8f451efa4d6d73", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -36,9 +36,7 @@ use syntax::ast;\n pub fn mk_pass(output_style: config::OutputStyle) -> Pass {\n     Pass {\n         name: ~\"page\",\n-        f: fn~(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-            run(srv, doc, output_style)\n-        }\n+        f: |srv, doc| run(srv, doc, output_style)\n     }\n }\n "}, {"sha": "e78c7d54019fc5a1bce1c2c10530e0c46482901a", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -20,7 +20,7 @@ use core::vec;\n /// A single operation on the document model\n pub struct Pass {\n     name: ~str,\n-    f: fn~(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc\n+    f: @fn(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc\n }\n \n pub fn run_passes("}, {"sha": "205fc0aa86decc599fe64d3fd8ae0b98c1182ed2", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -57,7 +57,7 @@ fn fold_trait(fold: &fold::Fold<()>, doc: doc::TraitDoc) -> doc::TraitDoc {\n     let doc = fold::default_seq_fold_trait(fold, doc);\n \n     doc::TraitDoc {\n-        methods: do par::map(doc.methods) |method| {\n+        methods: do doc.methods.map |method| {\n             let (desc, sections) = sectionalize(copy method.desc);\n \n             doc::MethodDoc {\n@@ -74,7 +74,7 @@ fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n     doc::ImplDoc {\n-        methods: do par::map(doc.methods) |method| {\n+        methods: do doc.methods.map |method| {\n             let (desc, sections) = sectionalize(copy method.desc);\n \n             doc::MethodDoc {"}, {"sha": "b7614a785c74205c19aa3dd8218857e639b27787", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -23,16 +23,14 @@ use util::NominalOp;\n \n use std::sort;\n \n-pub type ItemLtEqOp = pure fn~(v1: &doc::ItemTag, v2:  &doc::ItemTag) -> bool;\n+pub type ItemLtEqOp = @pure fn(v1: &doc::ItemTag, v2:  &doc::ItemTag) -> bool;\n \n type ItemLtEq = NominalOp<ItemLtEqOp>;\n \n pub fn mk_pass(name: ~str, lteq: ItemLtEqOp) -> Pass {\n     Pass {\n         name: copy name,\n-        f: fn~(move lteq, srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-            run(srv, doc, NominalOp { op: copy lteq })\n-        }\n+        f: |srv, doc| run(srv, doc, NominalOp { op: lteq })\n     }\n }\n "}, {"sha": "79ba8f0684a5852d476508af508a0fab89d66822", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -23,17 +23,17 @@ use util::NominalOp;\n use std::par;\n use std::cell::Cell;\n \n-pub fn mk_pass(name: ~str, op: fn~(&str) -> ~str) -> Pass {\n+pub fn mk_pass(name: ~str, op: @fn(&str) -> ~str) -> Pass {\n     let op = Cell(op);\n     Pass {\n         name: copy name,\n-        f: fn~(move op, srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n+        f: |srv: astsrv::Srv, doc: doc::Doc| -> doc::Doc {\n             run(srv, doc, op.take())\n         }\n     }\n }\n \n-type Op = fn~(&str) -> ~str;\n+type Op = @fn(&str) -> ~str;\n \n #[allow(non_implicitly_copyable_typarams)]\n fn run(\n@@ -76,7 +76,7 @@ fn apply_to_sections(\n     op: NominalOp<Op>,\n     sections: ~[doc::Section]\n ) -> ~[doc::Section] {\n-    par::map(sections, |section, copy op| doc::Section {\n+    sections.map(|section, copy op| doc::Section {\n         header: (op.op)(copy section.header),\n         body: (op.op)(copy section.body)\n     })\n@@ -89,7 +89,7 @@ fn fold_enum(\n     let fold_copy = copy *fold;\n \n     doc::EnumDoc {\n-        variants: do par::map(doc.variants) |variant, copy fold_copy| {\n+        variants: do doc.variants.map |variant, copy fold_copy| {\n             doc::VariantDoc {\n                 desc: maybe_apply_op(copy fold_copy.ctxt, &variant.desc),\n                 .. copy *variant\n@@ -116,7 +116,7 @@ fn apply_to_methods(\n     docs: ~[doc::MethodDoc]\n ) -> ~[doc::MethodDoc] {\n     let op = copy op;\n-    do par::map(docs) |doc| {\n+    do docs.map |doc| {\n         doc::MethodDoc {\n             brief: maybe_apply_op(copy op, &doc.brief),\n             desc: maybe_apply_op(copy op, &doc.desc),"}, {"sha": "fa8c2dd93c0381b99a3fabe6fe9389202d273cbd", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -80,7 +80,7 @@ fn unindent(s: &str) -> ~str {\n \n     if !lines.is_empty() {\n         let unindented = ~[str::trim(vec::head(lines))]\n-            + do par::map(vec::tail(lines)) |line| {\n+            + do vec::tail(lines).map |line| {\n             if str::is_whitespace(*line) {\n                 copy *line\n             } else {"}, {"sha": "a1fd7a66f7ec81f6696cbea8dcd7dfa390fd8dff", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n /**\n  * Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n  * between tasks."}, {"sha": "a2cbe27ea9045407d08b5b894f1375ab41aa66f4", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -32,8 +32,6 @@\n // overhead when initializing plain-old-data and means we don't need\n // to waste time running the destructors of POD.\n \n-#[forbid(deprecated_mode)];\n-\n use arena;\n use list;\n use list::{List, Cons, Nil};"}, {"sha": "d9e121798f183f37abda3b8b65f9b8d823af53b8", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use core::io::Reader;\n use core::iter;\n use core::str;"}, {"sha": "a94c4f790641d093e3108ea9f9fdf7d1df8b5bbb", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use core::ops;\n use core::prelude::*;\n use core::uint;"}, {"sha": "5ea5418d9882e66c7c968ba6789b3b493191dd7d", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -35,7 +35,6 @@\n  * great care must be taken to ensure that a reference to the c_vec::t is\n  * still held if needed.\n  */\n-#[forbid(deprecated_mode)];\n \n use core::libc;\n use core::option;"}, {"sha": "10a896a40896f57d21e7be91370195c017783a45", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use core::option;\n use core::prelude::*;\n "}, {"sha": "110559ddcefe0fb4fe568aec74c4d7277b743260", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n //! Additional general-purpose comparison functionality.\n \n use core::f32;"}, {"sha": "71eb29e26eba750c466d52c645d21508867b14e3", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,9 +14,6 @@ Higher level communication abstractions.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-\n use core::pipes::{GenericChan, GenericSmartChan, GenericPort};\n use core::pipes::{Chan, Port, Selectable, Peekable};\n use core::pipes;"}, {"sha": "7813357caf228d9ccb476ebaa9ce8cf4d9549436", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n //! Unsafe debugging functions for inspecting values.\n \n use core::cast::reinterpret_cast;"}, {"sha": "465c5d8f8feea36b9bb80e9f1fd3a358eb6bfc48", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! A deque. Untested as of yet. Likely buggy\n-#[forbid(deprecated_mode)];\n #[forbid(non_camel_case_types)];\n \n use core::cmp::Eq;"}, {"sha": "768d2dbf2d4ba640c2b6a01ff4d91d0281dc70b2", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use serialize;\n \n use core::io;"}, {"sha": "d6c2cf5a265eedadc3e69a8d91103c11e9290afc", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n /*!\n  * A functional key,value store that works on anything.\n  *"}, {"sha": "fa8fdf56428d88d1f9892644af883f06c2a4ee67", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -72,7 +72,6 @@\n  *         do_work(input, output);\n  *     }\n  */\n-#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use core::prelude::*;"}, {"sha": "99c6c2f008dd65c708fa6b3780c8b99a75957523", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,7 +10,6 @@\n \n // Rust JSON serialization library\n // Copyright (c) 2011 Google Inc.\n-#[forbid(deprecated_mode)];\n #[forbid(non_camel_case_types)];\n \n //! json serialization"}, {"sha": "140c2013738de6acecd26842035d8ccbf4c46d14", "filename": "src/libstd/list.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! A standard linked list\n-#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use core::option;"}, {"sha": "1d831af0e292aa9e727b70b21e108d4a8d8618c7", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use core::str;\n use core::uint;\n use core::vec;"}, {"sha": "511e80b0160f6823f357a1022f42162cb20c976d", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! Types/fns concerning Internet Protocol (IP), versions 4 & 6\n-#[forbid(deprecated_mode)];\n \n use core::libc;\n use core::prelude::*;"}, {"sha": "c90518f1692b1d8e130315db0cbe08cd98f10fcc", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,6 +10,7 @@\n \n //! High-level interface to libuv's TCP functionality\n // FIXME #4425: Need FFI fixes\n+\n #[allow(deprecated_mode)];\n \n use future;"}, {"sha": "9403438dde0ead2b308d2930292fac3d0b06a37a", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n //! Types/fns concerning URLs (see RFC 3986)\n-#[forbid(deprecated_mode)];\n+\n+#[allow(deprecated_mode)];\n \n use core::cmp::Eq;\n use core::dvec::DVec;"}, {"sha": "ad7e8e50e38f09ecc6086fb38e8ec0d16cefd4ff", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! A map type - **deprecated**, use `core::hashmap` instead\n-#[forbid(deprecated_mode)];\n \n use core::container::{Container, Mutable, Map};\n use core::cmp::Eq;"}, {"sha": "8293ff1c2afdf09573d2db3dff05c1b8e53b1e1a", "filename": "src/libstd/par.rs", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use core::cast;\n use core::prelude::*;\n use core::ptr;\n@@ -38,7 +36,7 @@ const min_granularity : uint = 1024u;\n  */\n fn map_slices<A: Copy Owned, B: Copy Owned>(\n     xs: &[A],\n-    f: fn() -> fn~(uint, v: &[A]) -> B)\n+    f: &fn() -> ~fn(uint, v: &[A]) -> B)\n     -> ~[B] {\n \n     let len = xs.len();\n@@ -93,20 +91,22 @@ fn map_slices<A: Copy Owned, B: Copy Owned>(\n \n /// A parallel version of map.\n pub fn map<A: Copy Owned, B: Copy Owned>(\n-    xs: &[A], f: fn~(&A) -> B) -> ~[B] {\n+    xs: &[A], fn_factory: &fn() -> ~fn(&A) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n-        let f = copy f;\n+        let f = fn_factory();\n         fn~(_base: uint, slice : &[A]) -> ~[B] {\n             vec::map(slice, |x| f(x))\n         }\n     }))\n }\n \n /// A parallel version of mapi.\n-pub fn mapi<A: Copy Owned, B: Copy Owned>(xs: &[A],\n-                                    f: fn~(uint, &A) -> B) -> ~[B] {\n+pub fn mapi<A: Copy Owned, B: Copy Owned>(\n+    xs: &[A],\n+    fn_factory: &fn() -> ~fn(uint, &A) -> B) -> ~[B]\n+{\n     let slices = map_slices(xs, || {\n-        let f = copy f;\n+        let f = fn_factory();\n         fn~(base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::mapi(slice, |i, x| {\n                 f(i + base, x)\n@@ -119,32 +119,13 @@ pub fn mapi<A: Copy Owned, B: Copy Owned>(xs: &[A],\n     r\n }\n \n-/**\n- * A parallel version of mapi.\n- *\n- * In this case, f is a function that creates functions to run over the\n- * inner elements. This is to skirt the need for copy constructors.\n- */\n-pub fn mapi_factory<A: Copy Owned, B: Copy Owned>(\n-    xs: &[A], f: fn() -> fn~(uint, A) -> B) -> ~[B] {\n-    let slices = map_slices(xs, || {\n-        let f = f();\n-        fn~(base: uint, slice : &[A], move f) -> ~[B] {\n-            vec::mapi(slice, |i, x| {\n-                f(i + base, *x)\n-            })\n-        }\n-    });\n-    let r = vec::concat(slices);\n-    log(info, (r.len(), xs.len()));\n-    assert(r.len() == xs.len());\n-    r\n-}\n-\n /// Returns true if the function holds for all elements in the vector.\n-pub fn alli<A: Copy Owned>(xs: &[A], f: fn~(uint, &A) -> bool) -> bool {\n+pub fn alli<A: Copy Owned>(\n+    xs: &[A],\n+    fn_factory: &fn() -> ~fn(uint, &A) -> bool) -> bool\n+{\n     do vec::all(map_slices(xs, || {\n-        let f = copy f;\n+        let f = fn_factory();\n         fn~(base: uint, slice : &[A], copy f) -> bool {\n             vec::alli(slice, |i, x| {\n                 f(i + base, x)\n@@ -154,9 +135,11 @@ pub fn alli<A: Copy Owned>(xs: &[A], f: fn~(uint, &A) -> bool) -> bool {\n }\n \n /// Returns true if the function holds for any elements in the vector.\n-pub fn any<A: Copy Owned>(xs: &[A], f: fn~(&A) -> bool) -> bool {\n+pub fn any<A: Copy Owned>(\n+    xs: &[A],\n+    fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n     do vec::any(map_slices(xs, || {\n-        let f = copy f;\n+        let f = fn_factory();\n         fn~(_base : uint, slice: &[A], copy f) -> bool {\n             vec::any(slice, |x| f(x))\n         }"}, {"sha": "dc2e3d3da2bd40e48736712ad95d85000e91a7ad", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use serialize;\n \n use core::io::Writer;"}, {"sha": "30baa3cc5f15ad80d773b8ce391540c79eed8eb0", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -64,7 +64,7 @@ pub unsafe fn read(prompt: ~str) -> Option<~str> {\n     }\n }\n \n-pub type CompletionCb = fn~(~str, fn(~str));\n+pub type CompletionCb = @fn(~str, fn(~str));\n \n fn complete_key(_v: @CompletionCb) {}\n \n@@ -75,7 +75,7 @@ pub unsafe fn complete(cb: CompletionCb) {\n \n         extern fn callback(line: *c_char, completions: *()) {\n             unsafe {\n-                let cb = copy *task::local_data::local_data_get(complete_key)\n+                let cb = *task::local_data::local_data_get(complete_key)\n                     .get();\n \n                 do cb(str::raw::from_c_str(line)) |suggestion| {"}, {"sha": "f8aef2c5f1e992d01db2f256039e5a97dee59f28", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -33,8 +33,6 @@\n  * * access to a character by index is logarithmic (linear in strings);\n  */\n \n-#[forbid(deprecated_mode)];\n-\n use core::cast;\n use core::char;\n use core::option;"}, {"sha": "972df73d2160949096e1b2d33de2393b3886a436", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,7 +14,6 @@\n Core encoding and decoding interfaces.\n */\n \n-#[forbid(deprecated_mode)];\n #[forbid(non_camel_case_types)];\n \n use core::at_vec;"}, {"sha": "6209170ac3d1fa7df396092aa8bbd3f8ba004361", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -22,8 +22,6 @@\n  * the `reset` method.\n  */\n \n-#[forbid(deprecated_mode)];\n-\n use core::str;\n use core::uint;\n use core::vec;"}, {"sha": "9af596eb1f5f88103efca8d96a6722279603cde8", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -12,7 +12,6 @@\n  * A simple map based on a vector for small integer keys. Space requirements\n  * are O(highest integer key).\n  */\n-#[forbid(deprecated_mode)];\n \n use core::container::{Container, Mutable, Map, Set};\n use core::option::{Some, None};"}, {"sha": "680a2b99c4a2e10568aa7f89e5b98b047a207580", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! Sorting methods\n-#[forbid(deprecated_mode)];\n \n use core::cmp::{Eq, Ord};\n use core::dvec::DVec;\n@@ -64,14 +63,13 @@ pub pure fn merge_sort<T: Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n     }\n }\n \n-fn part<T: Copy>(arr: &mut [T], left: uint,\n-                right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    let pivot_value = arr[pivot];\n+fn part<T>(arr: &mut [T], left: uint,\n+           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n     arr[pivot] <-> arr[right];\n     let mut storage_index: uint = left;\n     let mut i: uint = left;\n     while i < right {\n-        if compare_func(&arr[i], &pivot_value) {\n+        if compare_func(&arr[i], &arr[right]) {\n             arr[i] <-> arr[storage_index];\n             storage_index += 1;\n         }\n@@ -81,8 +79,8 @@ fn part<T: Copy>(arr: &mut [T], left: uint,\n     return storage_index;\n }\n \n-fn qsort<T: Copy>(arr: &mut [T], left: uint,\n-             right: uint, compare_func: Le<T>) {\n+fn qsort<T>(arr: &mut [T], left: uint,\n+            right: uint, compare_func: Le<T>) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n         let new_pivot = part::<T>(arr, left, right, pivot, compare_func);\n@@ -100,7 +98,7 @@ fn qsort<T: Copy>(arr: &mut [T], left: uint,\n  * Has worst case O(n^2) performance, average case O(n log n).\n  * This is an unstable sort.\n  */\n-pub fn quick_sort<T: Copy>(arr: &mut [T], compare_func: Le<T>) {\n+pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n     if len::<T>(arr) == 0u { return; }\n     qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n }"}, {"sha": "8c142908d106fa43e744aaa9ef56499e98b56a90", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -28,10 +28,6 @@ not required in or otherwise suitable for the core library.\n \n #[allow(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n-// XXX this is set to allow because there are two methods in encoding\n-// that can't be silenced otherwise. Most every module is set to forbid\n-#[allow(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n #[allow(deprecated_self)];\n \n #[no_core];"}, {"sha": "b7e75897bf1e9e343db67a6664eb7c0ac2d40e7b", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n /**\n  * The concurrency primitives you know and love.\n  *"}, {"sha": "b786d913639cd52fd82f9f2876b0335333fcb223", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,8 +10,6 @@\n \n //! Temporary files and directories\n \n-#[forbid(deprecated_mode)];\n-\n use core::os;\n use core::prelude::*;\n use core::rand;"}, {"sha": "5616c7211c1da5dcdb505d0a3b765fb29a4d6a3c", "filename": "src/libstd/term.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! Simple ANSI color library\n-#[forbid(deprecated_mode)];\n \n use core::i32;\n use core::io;"}, {"sha": "e83b759f90144f50927af17f4675ab65a361a547", "filename": "src/libstd/test.rs", "status": "modified", "additions": 116, "deletions": 93, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -15,8 +15,6 @@\n // simplest interface possible for representing and running tests\n // while providing a base that other test frameworks may build off of.\n \n-#[forbid(deprecated_mode)];\n-\n use getopts;\n use sort;\n use term;\n@@ -51,20 +49,24 @@ pub type TestName = ~str;\n // the test succeeds; if the function fails then the test fails. We\n // may need to come up with a more clever definition of test in order\n // to support isolation of tests into tasks.\n-pub type TestFn = fn~();\n+pub type TestFn = ~fn();\n \n // The definition of a single test. A test runner will run a list of\n // these.\n pub struct TestDesc {\n     name: TestName,\n-    testfn: TestFn,\n     ignore: bool,\n     should_fail: bool\n }\n \n+pub struct TestDescAndFn {\n+    desc: TestDesc,\n+    testfn: TestFn,\n+}\n+\n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n-pub fn test_main(args: &[~str], tests: &[TestDesc]) {\n+pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n     let opts =\n         match parse_opts(args) {\n           either::Left(move o) => o,\n@@ -124,7 +126,7 @@ struct ConsoleTestState {\n \n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts,\n-                     tests: &[TestDesc]) -> bool {\n+                         tests: ~[TestDescAndFn]) -> bool {\n \n     fn callback(event: &TestEvent, st: @ConsoleTestState) {\n         debug!(\"callback(event=%?)\", event);\n@@ -247,17 +249,17 @@ fn print_failures(st: @ConsoleTestState) {\n \n #[test]\n fn should_sort_failures_before_printing_them() {\n+    fn dummy() {}\n+\n     let s = do io::with_str_writer |wr| {\n         let test_a = TestDesc {\n             name: ~\"a\",\n-            testfn: fn~() { },\n             ignore: false,\n             should_fail: false\n         };\n \n         let test_b = TestDesc {\n             name: ~\"b\",\n-            testfn: fn~() { },\n             ignore: false,\n             should_fail: false\n         };\n@@ -291,45 +293,44 @@ enum TestEvent {\n type MonitorMsg = (TestDesc, TestResult);\n \n fn run_tests(opts: &TestOpts,\n-             tests: &[TestDesc],\n+             tests: ~[TestDescAndFn],\n              callback: fn@(e: TestEvent)) {\n     let mut filtered_tests = filter_tests(opts, tests);\n-    callback(TeFiltered(copy filtered_tests));\n+\n+    let filtered_descs = filtered_tests.map(|t| t.desc);\n+    callback(TeFiltered(filtered_descs));\n \n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n     let concurrency = get_concurrency();\n     debug!(\"using %u test tasks\", concurrency);\n \n-    let total = vec::len(filtered_tests);\n-    let mut run_idx = 0;\n-    let mut wait_idx = 0;\n-    let mut done_idx = 0;\n+    let mut remaining = filtered_tests;\n+    vec::reverse(remaining);\n+    let mut pending = 0;\n \n     let (p, ch) = stream();\n     let ch = SharedChan(ch);\n \n-    while done_idx < total {\n-        while wait_idx < concurrency && run_idx < total {\n-            let test = copy filtered_tests[run_idx];\n+    while pending > 0 || !remaining.is_empty() {\n+        while pending < concurrency && !remaining.is_empty() {\n+            let test = remaining.pop();\n             if concurrency == 1 {\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                callback(TeWait(copy test));\n+                callback(TeWait(test.desc));\n             }\n-            run_test(move test, ch.clone());\n-            wait_idx += 1;\n-            run_idx += 1;\n+            run_test(test, ch.clone());\n+            pending += 1;\n         }\n \n-        let (test, result) = p.recv();\n+        let (desc, result) = p.recv();\n         if concurrency != 1 {\n-            callback(TeWait(copy test));\n+            callback(TeWait(desc));\n         }\n-        callback(TeResult(move test, result));\n-        wait_idx -= 1;\n-        done_idx += 1;\n+        callback(TeResult(desc, result));\n+        pending -= 1;\n     }\n }\n \n@@ -349,10 +350,11 @@ fn get_concurrency() -> uint {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-pub fn filter_tests(opts: &TestOpts,\n-                    tests: &[TestDesc])\n-                 -> ~[TestDesc] {\n-    let mut filtered = vec::slice(tests, 0, tests.len());\n+pub fn filter_tests(\n+    opts: &TestOpts,\n+    tests: ~[TestDescAndFn]) -> ~[TestDescAndFn]\n+{\n+    let mut filtered = tests;\n \n     // Remove tests that don't match the test filter\n     filtered = if opts.filter.is_none() {\n@@ -364,10 +366,10 @@ pub fn filter_tests(opts: &TestOpts,\n           option::None => ~\"\"\n         };\n \n-        fn filter_fn(test: &TestDesc, filter_str: &str) ->\n-            Option<TestDesc> {\n-            if str::contains(test.name, filter_str) {\n-                return option::Some(copy *test);\n+        fn filter_fn(test: TestDescAndFn, filter_str: &str) ->\n+            Option<TestDescAndFn> {\n+            if str::contains(test.desc.name, filter_str) {\n+                return option::Some(test);\n             } else { return option::None; }\n         }\n \n@@ -378,26 +380,26 @@ pub fn filter_tests(opts: &TestOpts,\n     filtered = if !opts.run_ignored {\n         move filtered\n     } else {\n-        fn filter(test: &TestDesc) -> Option<TestDesc> {\n-            if test.ignore {\n-                return option::Some(TestDesc {\n-                    name: test.name,\n-                    testfn: copy test.testfn,\n-                    ignore: false,\n-                    should_fail: test.should_fail});\n-            } else { return option::None; }\n+        fn filter(test: TestDescAndFn) -> Option<TestDescAndFn> {\n+            if test.desc.ignore {\n+                let TestDescAndFn {desc, testfn} = test;\n+                Some(TestDescAndFn {\n+                    desc: TestDesc {ignore: false, ..desc},\n+                    testfn: testfn\n+                })\n+            } else {\n+                None\n+            }\n         };\n \n         vec::filter_map(filtered, |x| filter(x))\n     };\n \n     // Sort the tests alphabetically\n-    filtered = {\n-        pure fn lteq(t1: &TestDesc, t2: &TestDesc) -> bool {\n-            str::le(t1.name, t2.name)\n-        }\n-        sort::merge_sort(filtered, lteq)\n-    };\n+    pure fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n+        str::le(t1.desc.name, t2.desc.name)\n+    }\n+    sort::quick_sort(filtered, lteq);\n \n     move filtered\n }\n@@ -407,37 +409,40 @@ struct TestFuture {\n     wait: fn@() -> TestResult,\n }\n \n-pub fn run_test(test: TestDesc, monitor_ch: SharedChan<MonitorMsg>) {\n-    if test.ignore {\n-        monitor_ch.send((copy test, TrIgnored));\n+pub fn run_test(test: TestDescAndFn, monitor_ch: SharedChan<MonitorMsg>) {\n+    let TestDescAndFn {desc, testfn} = test;\n+\n+    if desc.ignore {\n+        monitor_ch.send((desc, TrIgnored));\n         return;\n     }\n \n-    do task::spawn |move test| {\n-        let testfn = copy test.testfn;\n+    let testfn_cell = ::cell::Cell(testfn);\n+    do task::spawn {\n         let mut result_future = None; // task::future_result(builder);\n         task::task().unlinked().future_result(|+r| {\n             result_future = Some(move r);\n-        }).spawn(move testfn);\n+        }).spawn(testfn_cell.take());\n         let task_result = option::unwrap(move result_future).recv();\n-        let test_result = calc_result(&test, task_result == task::Success);\n-        monitor_ch.send((copy test, test_result));\n+        let test_result = calc_result(&desc, task_result == task::Success);\n+        monitor_ch.send((desc, test_result));\n     };\n }\n \n-fn calc_result(test: &TestDesc, task_succeeded: bool) -> TestResult {\n+fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n     if task_succeeded {\n-        if test.should_fail { TrFailed }\n+        if desc.should_fail { TrFailed }\n         else { TrOk }\n     } else {\n-        if test.should_fail { TrOk }\n+        if desc.should_fail { TrOk }\n         else { TrFailed }\n     }\n }\n \n #[cfg(test)]\n mod tests {\n-    use test::{TrFailed, TrIgnored, TrOk, filter_tests, parse_opts, TestDesc};\n+    use test::{TrFailed, TrIgnored, TrOk, filter_tests, parse_opts,\n+               TestDesc, TestDescAndFn};\n     use test::{TestOpts, run_test};\n \n     use core::either;\n@@ -448,11 +453,13 @@ mod tests {\n     #[test]\n     pub fn do_not_run_ignored_tests() {\n         fn f() { die!(); }\n-        let desc = TestDesc {\n-            name: ~\"whatever\",\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: ~\"whatever\",\n+                ignore: true,\n+                should_fail: false\n+            },\n             testfn: f,\n-            ignore: true,\n-            should_fail: false\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan(ch);\n@@ -464,11 +471,13 @@ mod tests {\n     #[test]\n     pub fn ignored_tests_result_in_ignored() {\n         fn f() { }\n-        let desc = TestDesc {\n-            name: ~\"whatever\",\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: ~\"whatever\",\n+                ignore: true,\n+                should_fail: false\n+            },\n             testfn: f,\n-            ignore: true,\n-            should_fail: false\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan(ch);\n@@ -481,11 +490,13 @@ mod tests {\n     #[ignore(cfg(windows))]\n     pub fn test_should_fail() {\n         fn f() { die!(); }\n-        let desc = TestDesc {\n-            name: ~\"whatever\",\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: ~\"whatever\",\n+                ignore: false,\n+                should_fail: true\n+            },\n             testfn: f,\n-            ignore: false,\n-            should_fail: true\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan(ch);\n@@ -497,11 +508,13 @@ mod tests {\n     #[test]\n     pub fn test_should_fail_but_succeeds() {\n         fn f() { }\n-        let desc = TestDesc {\n-            name: ~\"whatever\",\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: ~\"whatever\",\n+                ignore: false,\n+                should_fail: true\n+            },\n             testfn: f,\n-            ignore: false,\n-            should_fail: true\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan(ch);\n@@ -532,6 +545,8 @@ mod tests {\n \n     #[test]\n     pub fn filter_for_ignored_option() {\n+        fn dummy() {}\n+\n         // When we run ignored tests the test filter should filter out all the\n         // unignored tests and flip the ignore flag on the rest to false\n \n@@ -542,24 +557,28 @@ mod tests {\n         };\n \n         let tests = ~[\n-            TestDesc {\n-                name: ~\"1\",\n-                testfn: fn~() { },\n-                ignore: true,\n-                should_fail: false,\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: ~\"1\",\n+                    ignore: true,\n+                    should_fail: false,\n+                },\n+                testfn: dummy,\n             },\n-            TestDesc {\n-                name: ~\"2\",\n-                testfn: fn~() { },\n-                ignore: false,\n-                should_fail: false,\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: ~\"2\",\n+                    ignore: false,\n+                    should_fail: false\n+                },\n+                testfn: dummy,\n             },\n         ];\n         let filtered = filter_tests(&opts, tests);\n \n         assert (vec::len(filtered) == 1);\n-        assert (filtered[0].name == ~\"1\");\n-        assert (filtered[0].ignore == false);\n+        assert (filtered[0].desc.name == ~\"1\");\n+        assert (filtered[0].desc.ignore == false);\n     }\n \n     #[test]\n@@ -579,12 +598,16 @@ mod tests {\n              ~\"test::sort_tests\"];\n         let tests =\n         {\n-            let testfn = fn~() { };\n+            fn testfn() { }\n             let mut tests = ~[];\n             for vec::each(names) |name| {\n-                let test = TestDesc {\n-                    name: *name, testfn: copy testfn, ignore: false,\n-                    should_fail: false};\n+                let test = TestDescAndFn {\n+                    desc: TestDesc {\n+                        name: *name, ignore: false,\n+                        should_fail: false\n+                    },\n+                    testfn: testfn,\n+                };\n                 tests.push(move test);\n             }\n             move tests\n@@ -604,7 +627,7 @@ mod tests {\n \n         for vec::each(pairs) |p| {\n             match *p {\n-                (ref a, ref b) => { assert (*a == b.name); }\n+                (ref a, ref b) => { assert (*a == b.desc.name); }\n             }\n         }\n     }"}, {"sha": "f696d239d30df8b65b756499e532014339ea3aaf", "filename": "src/libstd/time.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use core::cmp::{Eq, Ord};\n use core::int;\n use core::libc::{c_char, c_int, c_long, size_t, time_t};"}, {"sha": "1da1bc60314d2eb3ce29a84494558fb1b39e786b", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,8 +10,6 @@\n \n //! Utilities that leverage libuv's `uv_timer_*` API\n \n-#[forbid(deprecated_mode)];\n-\n use uv;\n use uv::iotask;\n use uv::iotask::IoTask;"}, {"sha": "1e90abcc03dc640f2b2f422d01afdf7368b140e5", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -12,8 +12,6 @@\n //! trees. The only requirement for the types is that the key implements\n //! `Ord`, and that the `lt` method provides a total ordering.\n \n-#[forbid(deprecated_mode)];\n-\n use core::container::{Container, Mutable, Map, Set};\n use core::cmp::{Eq, Ord};\n use core::option::{Option, Some, None};"}, {"sha": "9763f655a6f4ed33f9504a2a1ba99a5ad0bf49c2", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,8 +10,6 @@\n \n //! A process-wide libuv event loop for library use.\n \n-#[forbid(deprecated_mode)];\n-\n use ll = uv_ll;\n use iotask = uv_iotask;\n use get_gl = get;"}, {"sha": "a44fef54b726a337fa4f1c53ffab412807474e52", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -14,7 +14,6 @@\n  * The I/O task runs in its own single-threaded scheduler.  By using the\n  * `interact` function you can execute code in a uv callback.\n  */\n-#[forbid(deprecated_mode)];\n \n use ll = uv_ll;\n "}, {"sha": "b828c4ef629f58c8d0849c163dec93c7fd452ed0", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(deprecated_mode)];\n+\n use json;\n use sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};"}, {"sha": "574ce281e2827fe1fe3a224e33d3c5b5126e9c85", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -399,16 +399,46 @@ pub impl mutability : cmp::Eq {\n #[auto_encode]\n #[auto_decode]\n #[deriving_eq]\n-pub enum Proto {\n-    ProtoBare,     // bare functions (deprecated)\n-    ProtoUniq,     // ~fn\n-    ProtoBox,      // @fn\n-    ProtoBorrowed, // &fn\n+pub enum Abi {\n+    RustAbi\n }\n \n-pub impl Proto : to_bytes::IterBytes {\n+pub impl Abi : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        (*self as uint).iter_bytes(lsb0, f);\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+pub impl Abi : ToStr {\n+    pure fn to_str(&self) -> ~str {\n+        match *self {\n+            RustAbi => ~\"\\\"rust\\\"\"\n+        }\n+    }\n+}\n+\n+#[auto_encode]\n+#[auto_decode]\n+#[deriving_eq]\n+pub enum Sigil {\n+    BorrowedSigil,\n+    OwnedSigil,\n+    ManagedSigil\n+}\n+\n+pub impl Sigil : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+pub impl Sigil : ToStr {\n+    pure fn to_str(&self) -> ~str {\n+        match *self {\n+            BorrowedSigil => ~\"&\",\n+            OwnedSigil => ~\"~\",\n+            ManagedSigil => ~\"@\"\n+         }\n     }\n }\n \n@@ -434,13 +464,6 @@ pub enum expr_vstore {\n     expr_vstore_mut_slice,             // &mut [1,2,3,4]\n }\n \n-pub pure fn is_blockish(p: Proto) -> bool {\n-    match p {\n-        ProtoBorrowed => true,\n-        ProtoBare | ProtoUniq | ProtoBox => false\n-    }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n pub enum binop {\n@@ -671,14 +694,23 @@ pub struct expr {\n pub enum log_level { error, debug, log_other }\n // 0 = error, 1 = debug, 2 = log_other\n \n+#[auto_encode]\n+#[auto_decode]\n+#[deriving_eq]\n+pub enum CallSugar {\n+    NoSugar,\n+    DoSugar,\n+    ForSugar\n+}\n+\n #[auto_encode]\n #[auto_decode]\n pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n     expr_rec(~[field], Option<@expr>),\n-    expr_call(@expr, ~[@expr], bool), // True iff last argument is a block\n-    expr_method_call(@expr, ident, ~[@Ty], ~[@expr], bool), // Ditto\n+    expr_call(@expr, ~[@expr], CallSugar),\n+    expr_method_call(@expr, ident, ~[@Ty], ~[@expr], CallSugar),\n     expr_tup(~[@expr]),\n     expr_binary(binop, @expr, @expr),\n     expr_unary(unop, @expr),\n@@ -693,7 +725,7 @@ pub enum expr_ {\n     expr_match(@expr, ~[arm]),\n \n     // FIXME(#4717) the @() is req'd on windows or else LLVM croaks\n-    expr_fn(Proto, fn_decl, blk, @()),\n+    expr_fn(Sigil, fn_decl, blk, @()),\n \n     expr_fn_block(fn_decl, blk),\n     // Inner expr is always an expr_fn_block. We need the wrapping node to\n@@ -1112,12 +1144,19 @@ pub impl Onceness : to_bytes::IterBytes {\n \n #[auto_encode]\n #[auto_decode]\n-pub struct TyFn {\n-    proto: Proto,\n+pub struct TyClosure {\n+    sigil: Sigil,\n     region: Option<@region>,\n     purity: purity,\n     onceness: Onceness,\n-    bounds: @~[ty_param_bound],\n+    decl: fn_decl\n+}\n+\n+#[auto_encode]\n+#[auto_decode]\n+pub struct TyBareFn {\n+    purity: purity,\n+    abi: Abi,\n     decl: fn_decl\n }\n \n@@ -1133,7 +1172,8 @@ pub enum ty_ {\n     ty_ptr(mt),\n     ty_rptr(@region, mt),\n     ty_rec(~[ty_field]),\n-    ty_fn(@TyFn),\n+    ty_closure(@TyClosure),\n+    ty_bare_fn(@TyBareFn),\n     ty_tup(~[@Ty]),\n     ty_path(@path, node_id),\n     ty_mac(mac),"}, {"sha": "c347c04641f10e5d7744dc7dff50939f364f2979", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -154,7 +154,7 @@ pub fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n             option::None\n         }\n     };\n-    return vec::filter_map(attrs, filter);\n+    return vec::filter_mapped(attrs, filter);\n }\n \n /// Search a list of meta items and return only those with a specific name\n@@ -277,9 +277,9 @@ pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n    ~[@ast::meta_item] {\n \n-    return vec::filter_map(items, |item| {\n+    return vec::filter_mapped(items, |item| {\n         if get_meta_item_name(*item) != name {\n-            option::Some(/* FIXME (#2543) */ copy *item)\n+            option::Some(*item)\n         } else {\n             option::None\n         }"}, {"sha": "a509325facecadea641de2bf782d18cb28cba381", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -76,7 +76,7 @@ pub impl BytePos: Sub<BytePos, BytePos> {\n }\n \n pub impl BytePos: to_bytes::IterBytes {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n@@ -99,7 +99,7 @@ pub impl CharPos: cmp::Ord {\n }\n \n pub impl CharPos: to_bytes::IterBytes {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "21154bff01e9a6f3a9179dfa9ee509490e142d6a", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -392,7 +392,7 @@ priv impl ext_ctxt {\n         expr: @ast::expr,\n         args: ~[@ast::expr]\n     ) -> @ast::expr {\n-        self.expr(span, ast::expr_call(expr, args, false))\n+        self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n     }\n \n     fn lambda_expr(expr: @ast::expr) -> @ast::expr {"}, {"sha": "a050b2316e873a41872cc1390033dc384a873885", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -103,7 +103,7 @@ pub fn mk_addr_of(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n }\n pub fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n                 args: ~[@ast::expr]) -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_call(fn_expr, args, false))\n+    mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))\n }\n pub fn mk_call(cx: ext_ctxt, sp: span, fn_path: ~[ast::ident],\n                args: ~[@ast::expr]) -> @ast::expr {"}, {"sha": "8cecbfb12101ec5acf16578ad319219ed50c4156", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -536,13 +536,18 @@ pub fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n       ty_rptr(region, mt) => ty_rptr(region, fold_mt(mt, fld)),\n       ty_rec(ref fields) =>\n         ty_rec(vec::map((*fields), |f| fold_field(*f, fld))),\n-      ty_fn(f) =>\n-        ty_fn(@TyFn {\n-            proto: f.proto,\n+      ty_closure(f) =>\n+        ty_closure(@TyClosure {\n+            sigil: f.sigil,\n             purity: f.purity,\n             region: f.region,\n             onceness: f.onceness,\n-            bounds: @vec::map(*f.bounds, |x| fold_ty_param_bound(*x, fld)),\n+            decl: fold_fn_decl(f.decl, fld)\n+        }),\n+      ty_bare_fn(f) =>\n+        ty_bare_fn(@TyBareFn {\n+            purity: f.purity,\n+            abi: f.abi,\n             decl: fold_fn_decl(f.decl, fld)\n         }),\n       ty_tup(tys) => ty_tup(vec::map(tys, |ty| fld.fold_ty(*ty))),\n@@ -557,7 +562,7 @@ pub fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n pub fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n     ast::_mod {\n         view_items: vec::map(m.view_items, |x| fld.fold_view_item(*x)),\n-        items: vec::filter_map(m.items, |x| fld.fold_item(*x)),\n+        items: vec::filter_mapped(m.items, |x| fld.fold_item(*x)),\n     }\n }\n "}, {"sha": "64c4cb3c508a1d487bdb2611e12c7834bd8d4a69", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -23,8 +23,10 @@ pub fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n       | ast::expr_block(_)\n       | ast::expr_while(*)\n       | ast::expr_loop(*)\n-      | ast::expr_call(_, _, true)\n-      | ast::expr_method_call(_, _, _, _, true) => false,\n+      | ast::expr_call(_, _, ast::DoSugar)\n+      | ast::expr_call(_, _, ast::ForSugar)\n+      | ast::expr_method_call(_, _, _, _, ast::DoSugar)\n+      | ast::expr_method_call(_, _, _, _, ast::ForSugar) => false,\n       _ => true\n     }\n }"}, {"sha": "7fb3064c388f1f5bdac80b9191d41287c5721b3d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 96, "deletions": 74, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -10,7 +10,10 @@\n \n use core::prelude::*;\n \n-use ast::{ProtoBox, ProtoUniq, RegionTyParamBound, TraitTyParamBound};\n+use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil, RustAbi};\n+use ast::{CallSugar, NoSugar, DoSugar, ForSugar};\n+use ast::{TyBareFn, TyClosure};\n+use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{provided, public, pure_fn, purity, re_static};\n use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n@@ -27,7 +30,7 @@ use ast::{expr_ret, expr_swap, expr_struct, expr_tup, expr_unary};\n use ast::{expr_vec, expr_vstore, expr_vstore_mut_box};\n use ast::{expr_vstore_fixed, expr_vstore_slice, expr_vstore_box};\n use ast::{expr_vstore_mut_slice, expr_while, extern_fn, field, fn_decl};\n-use ast::{expr_vstore_uniq, TyFn, Onceness, Once, Many};\n+use ast::{expr_vstore_uniq, TyClosure, TyBareFn, Onceness, Once, Many};\n use ast::{foreign_item, foreign_item_const, foreign_item_fn, foreign_mod};\n use ast::{ident, impure_fn, infer, inherited, item, item_, item_const};\n use ast::{item_const, item_enum, item_fn, item_foreign_mod, item_impl};\n@@ -38,15 +41,16 @@ use ast::{m_imm, m_mutbl, mac_, mac_invoc_tt, matcher, match_nonterminal};\n use ast::{match_seq, match_tok, method, mode, module_ns, mt, mul, mutability};\n use ast::{named_field, neg, node_id, noreturn, not, pat, pat_box, pat_enum};\n use ast::{pat_ident, pat_lit, pat_range, pat_rec, pat_region, pat_struct};\n-use ast::{pat_tup, pat_uniq, pat_wild, path, private, Proto, ProtoBare};\n-use ast::{ProtoBorrowed, re_self, re_anon, re_named, region, rem, required};\n+use ast::{pat_tup, pat_uniq, pat_wild, path, private};\n+use ast::{re_self, re_anon, re_named, region, rem, required};\n use ast::{ret_style, return_val, self_ty, shl, shr, stmt, stmt_decl};\n use ast::{stmt_expr, stmt_semi, stmt_mac, struct_def, struct_field};\n use ast::{struct_immutable, struct_mutable, struct_variant_kind, subtract};\n use ast::{sty_box, sty_by_ref, sty_region, sty_static, sty_uniq, sty_value};\n use ast::{token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok};\n use ast::{tt_nonterminal, tuple_variant_kind, Ty, ty_, ty_bot, ty_box};\n-use ast::{ty_field, ty_fixed_length_vec, ty_fn, ty_infer, ty_mac, ty_method};\n+use ast::{ty_field, ty_fixed_length_vec, ty_closure, ty_bare_fn};\n+use ast::{ty_infer, ty_mac, ty_method};\n use ast::{ty_nil, ty_param, ty_param_bound, ty_path, ty_ptr, ty_rec, ty_rptr};\n use ast::{ty_tup, ty_u32, ty_uniq, ty_vec, type_value_ns, uniq};\n use ast::{unnamed_field, unsafe_blk, unsafe_fn, variant, view_item};\n@@ -293,25 +297,49 @@ pub impl Parser {\n \n     pure fn id_to_str(id: ident) -> @~str { self.sess.interner.get(id) }\n \n-    fn token_is_fn_keyword(+tok: token::Token) -> bool {\n+    fn token_is_closure_keyword(+tok: token::Token) -> bool {\n         self.token_is_keyword(~\"pure\", tok) ||\n             self.token_is_keyword(~\"unsafe\", tok) ||\n             self.token_is_keyword(~\"once\", tok) ||\n-            self.token_is_keyword(~\"fn\", tok) ||\n-            self.token_is_keyword(~\"extern\", tok)\n+            self.token_is_keyword(~\"fn\", tok)\n     }\n \n-    fn parse_ty_fn(pre_proto: Option<ast::Proto>,\n-                       pre_region_name: Option<ident>) -> ty_\n+    fn parse_ty_bare_fn() -> ty_\n     {\n         /*\n \n-        (&|~|@) [r/] [pure|unsafe] [once] fn [:K] (S) -> T\n-        ^~~~~~^ ^~~^ ^~~~~~~~~~~~^ ^~~~~^    ^~~^ ^~^    ^\n-           |     |     |             |        |    |     |\n-           |     |     |             |        |    |   Return type\n-           |     |     |             |        |  Argument types\n-           |     |     |             |    Environment bounds\n+        extern \"ABI\" [pure|unsafe] fn (S) -> T\n+               ^~~~^ ^~~~~~~~~~~~^    ^~^    ^\n+                 |     |               |     |\n+                 |     |               |   Return type\n+                 |     |             Argument types\n+                 |     |\n+                 |     |\n+                 |   Purity\n+                ABI\n+\n+        */\n+\n+        let purity = self.parse_purity();\n+        self.expect_keyword(~\"fn\");\n+        return ty_bare_fn(@TyBareFn {\n+            abi: RustAbi,\n+            purity: purity,\n+            decl: self.parse_ty_fn_decl()\n+        });\n+    }\n+\n+    fn parse_ty_closure(pre_sigil: Option<ast::Sigil>,\n+                        pre_region_name: Option<ident>) -> ty_\n+    {\n+        /*\n+\n+        (&|~|@) [r/] [pure|unsafe] [once] fn (S) -> T\n+        ^~~~~~^ ^~~^ ^~~~~~~~~~~~^ ^~~~~^    ^~^    ^\n+           |     |     |             |        |     |\n+           |     |     |             |        |   Return type\n+           |     |     |             |      Argument types\n+           |     |     |             |\n            |     |     |          Once-ness (a.k.a., affine)\n            |     |   Purity\n            | Lifetime bound\n@@ -322,22 +350,13 @@ pub impl Parser {\n         // At this point, the allocation type and lifetime bound have been\n         // parsed.\n \n-        let purity = parse_purity(&self);\n+        let purity = self.parse_purity();\n         let onceness = parse_onceness(&self);\n+        self.expect_keyword(~\"fn\");\n+        let post_sigil = self.parse_fn_ty_sigil();\n \n-        let bounds, post_proto;\n-        if self.eat_keyword(~\"extern\") {\n-            self.expect_keyword(~\"fn\");\n-            post_proto = Some(ast::ProtoBare);\n-            bounds = @~[];\n-        } else {\n-            self.expect_keyword(~\"fn\");\n-            post_proto = self.parse_fn_ty_proto();\n-            bounds = self.parse_optional_ty_param_bounds();\n-        };\n-\n-        let proto = match (pre_proto, post_proto) {\n-            (None, None) => ast::ProtoBorrowed,\n+        let sigil = match (pre_sigil, post_sigil) {\n+            (None, None) => BorrowedSigil,\n             (Some(p), None) | (None, Some(p)) => p,\n             (Some(_), Some(_)) => {\n                 self.fatal(~\"cannot combine prefix and postfix \\\n@@ -352,30 +371,28 @@ pub impl Parser {\n             None\n         };\n \n-        return ty_fn(@TyFn {\n-            proto: proto,\n+        return ty_closure(@TyClosure {\n+            sigil: sigil,\n             region: region,\n             purity: purity,\n             onceness: onceness,\n-            bounds: bounds,\n             decl: self.parse_ty_fn_decl()\n         });\n \n-        fn parse_purity(self: &Parser) -> purity {\n-            if self.eat_keyword(~\"pure\") {\n-                return pure_fn;\n-            } else if self.eat_keyword(~\"unsafe\") {\n-                return unsafe_fn;\n-            } else {\n-                return impure_fn;\n-            }\n-        }\n-\n         fn parse_onceness(self: &Parser) -> Onceness {\n             if self.eat_keyword(~\"once\") {Once} else {Many}\n         }\n     }\n \n+    fn parse_purity() -> purity {\n+        if self.eat_keyword(~\"pure\") {\n+            return pure_fn;\n+        } else if self.eat_keyword(~\"unsafe\") {\n+            return unsafe_fn;\n+        } else {\n+            return impure_fn;\n+        }\n+    }\n \n     fn parse_ty_fn_decl() -> fn_decl {\n         let inputs = do self.parse_unspanned_seq(\n@@ -560,10 +577,10 @@ pub impl Parser {\n             }\n         } else if self.token == token::AT {\n             self.bump();\n-            self.parse_box_or_uniq_pointee(ast::ProtoBox, ty_box)\n+            self.parse_box_or_uniq_pointee(ManagedSigil, ty_box)\n         } else if self.token == token::TILDE {\n             self.bump();\n-            self.parse_box_or_uniq_pointee(ast::ProtoUniq, ty_uniq)\n+            self.parse_box_or_uniq_pointee(OwnedSigil, ty_uniq)\n         } else if self.token == token::BINOP(token::STAR) {\n             self.bump();\n             ty_ptr(self.parse_mt())\n@@ -590,8 +607,10 @@ pub impl Parser {\n         } else if self.token == token::BINOP(token::AND) {\n             self.bump();\n             self.parse_borrowed_pointee()\n-        } else if self.token_is_fn_keyword(self.token) {\n-            self.parse_ty_fn(None, None)\n+        } else if self.eat_keyword(~\"extern\") {\n+            self.parse_ty_bare_fn()\n+        } else if self.token_is_closure_keyword(self.token) {\n+            self.parse_ty_closure(None, None)\n         } else if self.token == token::MOD_SEP\n             || is_ident_or_path(self.token) {\n             let path = self.parse_path_with_tps(colons_before_params);\n@@ -603,19 +622,19 @@ pub impl Parser {\n     }\n \n     fn parse_box_or_uniq_pointee(\n-        proto: ast::Proto,\n+        sigil: ast::Sigil,\n         ctor: &fn(+v: mt) -> ty_) -> ty_\n     {\n         // @foo/fn() or @fn() are parsed directly as fn types:\n         match copy self.token {\n             token::IDENT(rname, _) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) &&\n-                    self.token_is_fn_keyword(self.look_ahead(2u))\n+                    self.token_is_closure_keyword(self.look_ahead(2u))\n                 {\n                     self.bump(); self.bump();\n-                    return self.parse_ty_fn(Some(proto), Some(rname));\n-                } else if self.token_is_fn_keyword(self.token) {\n-                    return self.parse_ty_fn(Some(proto), None);\n+                    return self.parse_ty_closure(Some(sigil), Some(rname));\n+                } else if self.token_is_closure_keyword(self.token) {\n+                    return self.parse_ty_closure(Some(sigil), None);\n                 }\n             }\n             _ => {}\n@@ -643,8 +662,8 @@ pub impl Parser {\n             _ => { None }\n         };\n \n-        if self.token_is_fn_keyword(self.token) {\n-            return self.parse_ty_fn(Some(ProtoBorrowed), rname);\n+        if self.token_is_closure_keyword(self.token) {\n+            return self.parse_ty_closure(Some(BorrowedSigil), rname);\n         }\n \n         let r = self.region_from_name(rname);\n@@ -981,24 +1000,26 @@ pub impl Parser {\n         } else if self.eat_keyword(~\"if\") {\n             return self.parse_if_expr();\n         } else if self.eat_keyword(~\"for\") {\n-            return self.parse_sugary_call_expr(~\"for\", expr_loop_body);\n+            return self.parse_sugary_call_expr(~\"for\", ForSugar,\n+                                               expr_loop_body);\n         } else if self.eat_keyword(~\"do\") {\n-            return self.parse_sugary_call_expr(~\"do\", expr_do_body);\n+            return self.parse_sugary_call_expr(~\"do\", DoSugar,\n+                                               expr_do_body);\n         } else if self.eat_keyword(~\"while\") {\n             return self.parse_while_expr();\n         } else if self.eat_keyword(~\"loop\") {\n             return self.parse_loop_expr();\n         } else if self.eat_keyword(~\"match\") {\n             return self.parse_match_expr();\n         } else if self.eat_keyword(~\"fn\") {\n-            let opt_proto = self.parse_fn_ty_proto();\n-            let proto = match opt_proto {\n-                None | Some(ast::ProtoBare) => {\n+            let opt_sigil = self.parse_fn_ty_sigil();\n+            let sigil = match opt_sigil {\n+                None => {\n                     self.fatal(~\"fn expr are deprecated, use fn@\")\n                 }\n                 Some(p) => { p }\n             };\n-            return self.parse_fn_expr(proto);\n+            return self.parse_fn_expr(sigil);\n         } else if self.eat_keyword(~\"unsafe\") {\n             return self.parse_block_expr(lo, unsafe_blk);\n         } else if self.token == token::LBRACKET {\n@@ -1176,7 +1197,7 @@ pub impl Parser {\n                                 |p| p.parse_expr());\n                             hi = self.span.hi;\n \n-                            let nd = expr_method_call(e, i, tys, es, false);\n+                            let nd = expr_method_call(e, i, tys, es, NoSugar);\n                             e = self.mk_expr(lo, hi, move nd);\n                         }\n                         _ => {\n@@ -1198,7 +1219,7 @@ pub impl Parser {\n                     |p| p.parse_expr());\n                 hi = self.span.hi;\n \n-                let nd = expr_call(e, es, false);\n+                let nd = expr_call(e, es, NoSugar);\n                 e = self.mk_expr(lo, hi, nd);\n               }\n \n@@ -1566,7 +1587,7 @@ pub impl Parser {\n         self.mk_expr(q.lo, q.hi, expr_if(q.cond, q.then, q.els))\n     }\n \n-    fn parse_fn_expr(proto: Proto) -> @expr {\n+    fn parse_fn_expr(sigil: Sigil) -> @expr {\n         let lo = self.last_span.lo;\n \n         // if we want to allow fn expression argument types to be inferred in\n@@ -1576,7 +1597,7 @@ pub impl Parser {\n         let body = self.parse_block();\n \n         self.mk_expr(lo, body.span.hi,\n-                            expr_fn(proto, decl, body, @()))\n+                     expr_fn(sigil, decl, body, @()))\n     }\n \n     // `|args| { ... }` like in `do` expressions\n@@ -1641,6 +1662,7 @@ pub impl Parser {\n     }\n \n     fn parse_sugary_call_expr(keyword: ~str,\n+                              sugar: CallSugar,\n                               ctor: fn(+v: @expr) -> expr_) -> @expr {\n         let lo = self.last_span;\n         // Parse the callee `foo` in\n@@ -1654,35 +1676,35 @@ pub impl Parser {\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n         match e.node {\n-            expr_call(f, args, false) => {\n+            expr_call(f, args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(args, ~[last_arg]);\n-                self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, true))\n+                self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, sugar))\n             }\n-            expr_method_call(f, i, tps, args, false) => {\n+            expr_method_call(f, i, tps, args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(args, ~[last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi,\n-                             expr_method_call(f, i, tps, args, true))\n+                             expr_method_call(f, i, tps, args, sugar))\n             }\n             expr_field(f, i, tps) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 self.mk_expr(lo.lo, block.span.hi,\n-                             expr_method_call(f, i, tps, ~[last_arg], true))\n+                             expr_method_call(f, i, tps, ~[last_arg], sugar))\n             }\n             expr_path(*) | expr_call(*) | expr_method_call(*) |\n                 expr_paren(*) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 self.mk_expr(lo.lo, last_arg.span.hi,\n-                             expr_call(e, ~[last_arg], true))\n+                             expr_call(e, ~[last_arg], sugar))\n             }\n             _ => {\n                 // There may be other types of expressions that can\n@@ -3592,19 +3614,19 @@ pub impl Parser {\n         (id, item_enum(enum_definition, ty_params), None)\n     }\n \n-    fn parse_fn_ty_proto() -> Option<Proto> {\n+    fn parse_fn_ty_sigil() -> Option<Sigil> {\n         match self.token {\n             token::AT => {\n                 self.bump();\n-                Some(ProtoBox)\n+                Some(ManagedSigil)\n             }\n             token::TILDE => {\n                 self.bump();\n-                Some(ProtoUniq)\n+                Some(OwnedSigil)\n             }\n             token::BINOP(token::AND) => {\n                 self.bump();\n-                Some(ProtoBorrowed)\n+                Some(BorrowedSigil)\n             }\n             _ => {\n                 None"}, {"sha": "bcbee7b2f244490ee6f00c5ac92bf9ca76e4bf88", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -404,9 +404,15 @@ pub fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n         commasep(s, inconsistent, elts, print_type);\n         pclose(s);\n       }\n-      ast::ty_fn(f) => {\n-        print_ty_fn(s, Some(f.proto), f.region, f.purity,\n-                    f.onceness, f.bounds, f.decl, None, None, None);\n+      ast::ty_bare_fn(f) => {\n+          print_ty_fn(s, Some(f.abi), None, None,\n+                      f.purity, ast::Many, f.decl, None,\n+                      None, None);\n+      }\n+      ast::ty_closure(f) => {\n+          print_ty_fn(s, None, Some(f.sigil), f.region,\n+                      f.purity, f.onceness, f.decl, None,\n+                      None, None);\n       }\n       ast::ty_path(path, _) => print_path(s, path, print_colons),\n       ast::ty_fixed_length_vec(mt, v) => {\n@@ -806,8 +812,8 @@ pub fn print_ty_method(s: ps, m: ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n-    print_ty_fn(s, None, None, m.purity, ast::Many,\n-                @~[], m.decl, Some(m.ident), Some(m.tps),\n+    print_ty_fn(s, None, None, None, m.purity, ast::Many,\n+                m.decl, Some(m.ident), Some(m.tps),\n                 Some(m.self_ty.node));\n     word(s.s, ~\";\");\n }\n@@ -1046,32 +1052,32 @@ pub fn print_expr_vstore(s: ps, t: ast::expr_vstore) {\n }\n \n pub fn print_call_pre(s: ps,\n-                      has_block: bool,\n+                      sugar: ast::CallSugar,\n                       base_args: &mut ~[@ast::expr])\n                    -> Option<@ast::expr> {\n-    if has_block {\n-        let blk_arg = base_args.pop();\n-        match blk_arg.node {\n-          ast::expr_loop_body(_) => { head(s, ~\"for\"); }\n-          ast::expr_do_body(_) => { head(s, ~\"do\"); }\n-          _ => {}\n-        }\n-        Some(blk_arg)\n-    } else {\n-        None\n+    match sugar {\n+        ast::DoSugar => {\n+            head(s, ~\"do\");\n+            Some(base_args.pop())\n+        }\n+        ast::ForSugar => {\n+            head(s, ~\"for\");\n+            Some(base_args.pop())\n+        }\n+        ast::NoSugar => None\n     }\n }\n \n pub fn print_call_post(s: ps,\n-                       has_block: bool,\n+                       sugar: ast::CallSugar,\n                        blk: &Option<@ast::expr>,\n                        base_args: &mut ~[@ast::expr]) {\n-    if !has_block || !base_args.is_empty() {\n+    if sugar == ast::NoSugar || !base_args.is_empty() {\n         popen(s);\n         commasep_exprs(s, inconsistent, *base_args);\n         pclose(s);\n     }\n-    if has_block {\n+    if sugar != ast::NoSugar {\n         nbsp(s);\n         match blk.get().node {\n           // need to handle closures specifically\n@@ -1181,15 +1187,15 @@ pub fn print_expr(s: ps, &&expr: @ast::expr) {\n         commasep_exprs(s, inconsistent, exprs);\n         pclose(s);\n       }\n-      ast::expr_call(func, args, has_block) => {\n+      ast::expr_call(func, args, sugar) => {\n         let mut base_args = copy args;\n-        let blk = print_call_pre(s, has_block, &mut base_args);\n+        let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n-        print_call_post(s, has_block, &blk, &mut base_args);\n+        print_call_post(s, sugar, &blk, &mut base_args);\n       }\n-      ast::expr_method_call(func, ident, tys, args, has_block) => {\n+      ast::expr_method_call(func, ident, tys, args, sugar) => {\n         let mut base_args = copy args;\n-        let blk = print_call_pre(s, has_block, &mut base_args);\n+        let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n         word(s.s, ~\".\");\n         print_ident(s, ident);\n@@ -1198,7 +1204,7 @@ pub fn print_expr(s: ps, &&expr: @ast::expr) {\n             commasep(s, inconsistent, tys, print_type);\n             word(s.s, ~\">\");\n         }\n-        print_call_post(s, has_block, &blk, &mut base_args);\n+        print_call_post(s, sugar, &blk, &mut base_args);\n       }\n       ast::expr_binary(op, lhs, rhs) => {\n         print_expr(s, lhs);\n@@ -1305,13 +1311,13 @@ pub fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n         bclose_(s, expr.span, match_indent_unit);\n       }\n-      ast::expr_fn(proto, decl, ref body, _) => {\n+      ast::expr_fn(sigil, decl, ref body, _) => {\n         // containing cbox, will be closed by print-block at }\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n         print_fn_header_info(s, None, None, ast::Many,\n-                             Some(proto), ast::inherited);\n+                             Some(sigil), ast::inherited);\n         print_fn_args_and_ret(s, decl, None);\n         space(s.s);\n         print_block(s, (*body));\n@@ -1900,33 +1906,32 @@ pub fn print_arg(s: ps, input: ast::arg) {\n }\n \n pub fn print_ty_fn(s: ps,\n-                   opt_proto: Option<ast::Proto>,\n+                   opt_abi: Option<ast::Abi>,\n+                   opt_sigil: Option<ast::Sigil>,\n                    opt_region: Option<@ast::region>,\n                    purity: ast::purity,\n                    onceness: ast::Onceness,\n-                   bounds: @~[ast::ty_param_bound],\n                    decl: ast::fn_decl, id: Option<ast::ident>,\n                    tps: Option<~[ast::ty_param]>,\n                    opt_self_ty: Option<ast::self_ty_>) {\n     ibox(s, indent_unit);\n \n     // Duplicates the logic in `print_fn_header_info()`.  This is because that\n-    // function prints the proto in the wrong place.  That should be fixed.\n+    // function prints the sigil in the wrong place.  That should be fixed.\n     print_self_ty_if_static(s, opt_self_ty);\n-    print_opt_proto(s, opt_proto);\n+    print_opt_abi(s, opt_abi);\n+    print_opt_sigil(s, opt_sigil);\n     for opt_region.each |r| { print_region(s, ~\"\", *r, ~\"/\"); }\n     print_purity(s, purity);\n     print_onceness(s, onceness);\n     word(s.s, ~\"fn\");\n-    print_bounds(s, bounds);\n     match id { Some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n     match tps { Some(tps) => print_type_params(s, tps), _ => () }\n     zerobreak(s.s);\n \n     popen(s);\n-    // It is unfortunate to duplicate the commasep logic, but we\n-    // we want the self type, the args, and the capture clauses all\n-    // in the same box.\n+    // It is unfortunate to duplicate the commasep logic, but we we want the\n+    // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n     let mut first = true;\n     for opt_self_ty.each |self_ty| {\n@@ -2157,12 +2162,18 @@ pub fn print_opt_purity(s: ps, opt_purity: Option<ast::purity>) {\n     }\n }\n \n-pub fn print_opt_proto(s: ps, opt_proto: Option<ast::Proto>) {\n-    match opt_proto {\n-        Some(ast::ProtoBare) => { word(s.s, ~\"extern \"); }\n-        Some(ast::ProtoBorrowed) => { word(s.s, ~\"&\"); }\n-        Some(ast::ProtoUniq) => { word(s.s, ~\"~\"); }\n-        Some(ast::ProtoBox) => { word(s.s, ~\"@\"); }\n+pub fn print_opt_abi(s: ps, opt_abi: Option<ast::Abi>) {\n+    match opt_abi {\n+        Some(ast::RustAbi) => { word_nbsp(s, ~\"extern\"); }\n+        None => {}\n+    };\n+}\n+\n+pub fn print_opt_sigil(s: ps, opt_sigil: Option<ast::Sigil>) {\n+    match opt_sigil {\n+        Some(ast::BorrowedSigil) => { word(s.s, ~\"&\"); }\n+        Some(ast::OwnedSigil) => { word(s.s, ~\"~\"); }\n+        Some(ast::ManagedSigil) => { word(s.s, ~\"@\"); }\n         None => {}\n     };\n }\n@@ -2171,20 +2182,20 @@ pub fn print_fn_header_info(s: ps,\n                             opt_sty: Option<ast::self_ty_>,\n                             opt_purity: Option<ast::purity>,\n                             onceness: ast::Onceness,\n-                            opt_proto: Option<ast::Proto>,\n+                            opt_sigil: Option<ast::Sigil>,\n                             vis: ast::visibility) {\n     print_self_ty_if_static(s, opt_sty);\n     word(s.s, visibility_qualified(vis, ~\"\"));\n     print_opt_purity(s, opt_purity);\n     print_onceness(s, onceness);\n     word(s.s, ~\"fn\");\n-    print_opt_proto(s, opt_proto);\n+    print_opt_sigil(s, opt_sigil);\n }\n \n-pub fn opt_proto_to_str(opt_p: Option<ast::Proto>) -> ~str {\n+pub fn opt_sigil_to_str(opt_p: Option<ast::Sigil>) -> ~str {\n     match opt_p {\n       None => ~\"fn\",\n-      Some(p) => proto_to_str(p)\n+      Some(p) => fmt!(\"fn%s\", p.to_str())\n     }\n }\n \n@@ -2218,15 +2229,6 @@ pub fn print_onceness(s: ps, o: ast::Onceness) {\n     }\n }\n \n-pub fn proto_to_str(p: ast::Proto) -> ~str {\n-    return match p {\n-      ast::ProtoBare => ~\"extern fn\",\n-      ast::ProtoBorrowed => ~\"fn&\",\n-      ast::ProtoUniq => ~\"fn~\",\n-      ast::ProtoBox => ~\"fn@\"\n-    };\n-}\n-\n #[cfg(test)]\n pub mod test {\n     use ast;"}, {"sha": "877817af06c1807f2ba70639c6d5c18c1a4b4f0f", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -22,7 +22,6 @@\n #[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n #[allow(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n #[allow(deprecated_self)];\n \n #[no_core];"}, {"sha": "37b96e056537064160c863c434ffcd1a911cc08a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -30,10 +30,10 @@ use core::vec;\n pub enum vt<E> { mk_vt(visitor<E>), }\n \n pub enum fn_kind {\n-    fk_item_fn(ident, ~[ty_param], purity), //< an item declared with fn()\n-    fk_method(ident, ~[ty_param], @method),\n-    fk_anon(Proto),    //< an anonymous function like fn@(...)\n-    fk_fn_block,       //< a block {||...}\n+    fk_item_fn(ident, ~[ty_param], purity), // fn foo()\n+    fk_method(ident, ~[ty_param], @method), // fn foo(&self)\n+    fk_anon(ast::Sigil),                    // fn@(x, y) { ... }\n+    fk_fn_block,                            // |x, y| ...\n     fk_dtor(~[ty_param], ~[attribute], node_id /* self id */,\n             def_id /* parent class id */) // class destructor\n \n@@ -217,9 +217,12 @@ pub fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n       ty_tup(ts) => for ts.each |tt| {\n         (v.visit_ty)(*tt, e, v);\n       },\n-      ty_fn(f) => {\n+      ty_closure(f) => {\n+        for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n+        (v.visit_ty)(f.decl.output, e, v);\n+      }\n+      ty_bare_fn(f) => {\n         for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n-        visit_ty_param_bounds(f.bounds, e, v);\n         (v.visit_ty)(f.decl.output, e, v);\n       }\n       ty_path(p, _) => visit_path(p, e, v),"}, {"sha": "222307bd240df4ecc7e050268031cb6a3dd6beca", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[legacy_modes];\n+#[allow(deprecated_mode)];\n \n /*!\n \n@@ -247,8 +248,13 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n         }\n     }\n \n+    fn is_gray_factory() -> ~fn(c: &color) -> bool {\n+        let r: ~fn(c: &color) -> bool = is_gray;\n+        r\n+    }\n+\n     let mut i = 0;\n-    while par::any(colors, is_gray) {\n+    while par::any(colors, is_gray_factory) {\n         // Do the BFS.\n         log(info, fmt!(\"PBFS iteration %?\", i));\n         i += 1;\n@@ -257,14 +263,13 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n         let color = arc::ARC(move colors);\n \n         let color_vec = arc::get(&color); // FIXME #3387 requires this temp\n-        colors = do par::mapi_factory(*color_vec) {\n+        colors = do par::mapi(*color_vec) {\n             let colors = arc::clone(&color);\n             let graph = arc::clone(&graph);\n-            fn~(move graph, move colors, +i: uint, +c: color) -> color {\n-                let c : color = c;\n+            fn~(+i: uint, +c: &color) -> color {\n                 let colors = arc::get(&colors);\n                 let graph = arc::get(&graph);\n-                match c {\n+                match *c {\n                   white => {\n                     let i = i as node_id;\n \n@@ -290,11 +295,13 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n     }\n \n     // Convert the results.\n-    do par::map(colors) |c| {\n-        match *c {\n-          white => { -1i64 }\n-          black(parent) => { parent }\n-          _ => { die!(~\"Found remaining gray nodes in BFS\") }\n+    do par::map(colors) {\n+        fn~(c: &color) -> i64 {\n+            match *c {\n+                white => { -1i64 }\n+                black(parent) => { parent }\n+                _ => { die!(~\"Found remaining gray nodes in BFS\") }\n+            }\n         }\n     }\n }\n@@ -377,14 +384,15 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     log(info, ~\"Verifying tree and graph edges...\");\n \n-    let edges = copy edges;\n-    let status = do par::alli(tree) |u, v| {\n-        let u = u as node_id;\n-        if *v == -1i64 || u == root {\n-            true\n-        }\n-        else {\n-            edges.contains(&(u, *v)) || edges.contains(&(*v, u))\n+    let status = do par::alli(tree) {\n+        let edges = copy edges;\n+        fn~(+u: uint, v: &i64) -> bool {\n+            let u = u as node_id;\n+            if *v == -1i64 || u == root {\n+                true\n+            } else {\n+                edges.contains(&(u, *v)) || edges.contains(&(*v, u))\n+            }\n         }\n     };\n "}, {"sha": "8e5ab45bae8684591a86a86861b99c0f1f4c623d", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -15,6 +15,10 @@ extern mod std;\n use std::list::{List, Cons, Nil};\n use std::time::precise_time_s;\n \n+enum UniqueList {\n+    ULNil, ULCons(~UniqueList)\n+}\n+\n fn main() {\n     let (repeat, depth) = if os::getenv(~\"RUST_BENCH\").is_some() {\n         (50, 1000)\n@@ -43,7 +47,6 @@ struct State {\n     box: @nillist,\n     unique: ~nillist,\n     fn_box: fn@() -> @nillist,\n-    fn_unique: fn~() -> ~nillist,\n     tuple: (@nillist, ~nillist),\n     vec: ~[@nillist],\n     res: r\n@@ -76,22 +79,18 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n                 box: @Nil,\n                 unique: ~Nil,\n                 fn_box: fn@() -> @nillist { @Nil::<()> },\n-                fn_unique: fn~() -> ~nillist { ~Nil::<()> },\n                 tuple: (@Nil, ~Nil),\n                 vec: ~[@Nil],\n                 res: r(@Nil)\n             }\n           }\n           Some(st) => {\n             let fn_box = st.fn_box;\n-            let fn_unique = copy st.fn_unique;\n \n             State {\n                 box: @Cons((), st.box),\n                 unique: ~Cons((), @*st.unique),\n                 fn_box: fn@() -> @nillist { @Cons((), fn_box()) },\n-                fn_unique: fn~(move fn_unique) -> ~nillist\n-                    { ~Cons((), @*fn_unique()) },\n                 tuple: (@Cons((), st.tuple.first()),\n                         ~Cons((), @*st.tuple.second())),\n                 vec: st.vec + ~[@Cons((), st.vec.last())],"}, {"sha": "b093af6e80c6690188dd7c63616448e70676e14a", "filename": "src/test/compile-fail/bad-var-env-capture-in-block-arg.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/82d73963334f01b818cda767b44cd0c8f3baf4cc/src%2Ftest%2Fcompile-fail%2Fbad-var-env-capture-in-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d73963334f01b818cda767b44cd0c8f3baf4cc/src%2Ftest%2Fcompile-fail%2Fbad-var-env-capture-in-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-var-env-capture-in-block-arg.rs?ref=82d73963334f01b818cda767b44cd0c8f3baf4cc", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let x = 3;\n-    fn blah(_a: extern fn()) {}\n-    blah(|| {\n-        log(debug, x); //~ ERROR attempted dynamic environment capture\n-    });\n-}\n\\ No newline at end of file"}, {"sha": "0671e8046016d53c583bd7925f0abd9793fba144", "filename": "src/test/compile-fail/block-arg-used-as-lambda-with-illegal-cap.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82d73963334f01b818cda767b44cd0c8f3baf4cc/src%2Ftest%2Fcompile-fail%2Fblock-arg-used-as-lambda-with-illegal-cap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d73963334f01b818cda767b44cd0c8f3baf4cc/src%2Ftest%2Fcompile-fail%2Fblock-arg-used-as-lambda-with-illegal-cap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-used-as-lambda-with-illegal-cap.rs?ref=82d73963334f01b818cda767b44cd0c8f3baf4cc", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn to_lambda1(f: fn@(uint) -> uint) -> fn@(uint) -> uint {\n-    return f;\n-}\n-\n-fn to_lambda2(b: fn(uint) -> uint) -> fn@(uint) -> uint {\n-    return to_lambda1(|x| b(x)); //~ ERROR illegal move from argument `b`\n-}\n-\n-fn main() {\n-}"}, {"sha": "c0430a6a8bb7dd0abb4e60592efe8db0a63a79ab", "filename": "src/test/compile-fail/functional-struct-update.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/82d73963334f01b818cda767b44cd0c8f3baf4cc/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d73963334f01b818cda767b44cd0c8f3baf4cc/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update.rs?ref=82d73963334f01b818cda767b44cd0c8f3baf4cc", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Bar {\n-    x: int,\n-}\n-\n-impl Bar : Drop {\n-    fn finalize(&self) {\n-        io::println(\"Goodbye, cruel world\");\n-    }\n-}\n-\n-struct Foo {\n-    x: int,\n-    y: Bar\n-}\n-\n-fn main() {\n-    let a = Foo { x: 1, y: Bar { x: 5 } };\n-    let c = Foo { x: 4, .. a}; //~ ERROR cannot copy field `y` of base expression, which has a noncopyable type\n-    io::println(fmt!(\"%?\", c));\n-}\n-"}, {"sha": "46ad7f64589446816ca5dd09533a0dfaaab4fe5d", "filename": "src/test/compile-fail/issue-3044.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: Non-function passed to a `do` function as its last argument, or wrong number of arguments passed to a `do` function\n fn main() {\n     let needlesArr: ~[char] = ~['a', 'f'];\n     do vec::foldr(needlesArr) |x, y| {\n+        //~^ ERROR 2 parameters were supplied (including the closure passed by the `do` keyword)\n+        //~^^ ERROR Unconstrained region variable #2\n+        //\n+        // this last error is, um, non-ideal.\n     }\n-// for some reason if I use the new error syntax for the two error messages this generates,\n-// the test runner gets confused -- tjc\n }\n "}, {"sha": "bc6dd8f5dc959c72c7c1c75701d003aa70b2a1f7", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -24,6 +24,6 @@ fn main() {\n     copy2(@&x); //~ ERROR missing `&static`\n \n     copy2(fn@() {});\n-    copy2(fn~() {}); //~ WARNING instantiating copy type parameter with a not implicitly copyable type\n-    copy2(fn&() {}); //~ ERROR missing `copy &static`\n+    copy2(fn~() {}); //~ ERROR missing `copy`\n+    copy2(fn&() {}); //~ ERROR missing `&static`\n }"}, {"sha": "660e5596ca55202df70be69a40466ae0bcd963d0", "filename": "src/test/compile-fail/moves-sru-moved-field.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -0,0 +1,27 @@\n+type Noncopyable = ~fn();\n+\n+struct Foo {\n+    copied: int,\n+    moved: ~int,\n+    noncopyable: Noncopyable\n+}\n+\n+fn test0(f: Foo, g: Noncopyable, h: Noncopyable) {\n+    // just copy implicitly copyable fields from `f`, no moves:\n+    let _b = Foo {moved: ~1, noncopyable: g, ..f};\n+    let _c = Foo {moved: ~2, noncopyable: h, ..f};\n+}\n+\n+fn test1(f: Foo, g: Noncopyable, h: Noncopyable) {\n+    // copying move-by-default fields from `f`, so move:\n+    let _b = Foo {noncopyable: g, ..f};\n+    let _c = Foo {noncopyable: h, ..f}; //~ ERROR use of moved value: `f`\n+}\n+\n+fn test2(f: Foo, g: Noncopyable) {\n+    // move non-copyable field\n+    let _b = Foo {copied: 22, moved: ~23, ..f};\n+    let _c = Foo {noncopyable: g, ..f}; //~ ERROR use of moved value: `f`\n+}\n+\n+fn main() {}"}, {"sha": "5f4a88375a489053d14805a35ca0c64b2d2ddd7b", "filename": "src/test/run-pass/bounded-fn-type.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/82d73963334f01b818cda767b44cd0c8f3baf4cc/src%2Ftest%2Frun-pass%2Fbounded-fn-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d73963334f01b818cda767b44cd0c8f3baf4cc/src%2Ftest%2Frun-pass%2Fbounded-fn-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbounded-fn-type.rs?ref=82d73963334f01b818cda767b44cd0c8f3baf4cc", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn ignore<T>(_x: T) {}\n-\n-pub fn main() {\n-    let f: fn@:Owned() = ||();\n-    ignore(f);\n-}\n-"}, {"sha": "9b852cbc635aa213167f3a4748e9b3ce959e2d1c", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -29,11 +29,11 @@ fn calllink08() { unsafe { rustrt::get_task_id(); } }\n fn calllink09() { unsafe { rustrt::rust_sched_threads(); } }\n fn calllink10() { unsafe { rustrt::rust_get_task(); } }\n \n-fn runtest(f: fn~(), frame_backoff: u32) {\n+fn runtest(f: extern fn(), frame_backoff: u32) {\n     runtest2(f, frame_backoff, 0 as *u8);\n }\n \n-fn runtest2(f: fn~(), frame_backoff: u32, last_stk: *u8) -> u32 {\n+fn runtest2(f: extern fn(), frame_backoff: u32, last_stk: *u8) -> u32 {\n     unsafe {\n         let curr_stk = rustrt::debug_get_stk_seg();\n         if (last_stk != curr_stk && last_stk != 0 as *u8) {\n@@ -67,6 +67,6 @@ pub fn main() {\n         let f = *f;\n         let sz = rng.next() % 256u32 + 256u32;\n         let frame_backoff = rng.next() % 10u32 + 1u32;\n-        task::try(|move f| runtest(f, frame_backoff) );\n+        task::try(|| runtest(f, frame_backoff) );\n     }\n }"}, {"sha": "18c446fe3505401d82d7be07467ccefd2db633bb", "filename": "src/test/run-pass/newtype.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Frun-pass%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Frun-pass%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -16,5 +16,6 @@ fn compute(i: mytype) -> int { return i.val + 20; }\n \n pub fn main() {\n     let myval = mytype(Mytype{compute: compute, val: 30});\n+    io::println(fmt!(\"%d\", compute(myval)));\n     assert ((myval.compute)(myval) == 50);\n }"}, {"sha": "520ddf3f73a753f146e8858d02e74e236f5bd067", "filename": "src/test/run-pass/sendfn-deep-copy.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/82d73963334f01b818cda767b44cd0c8f3baf4cc/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d73963334f01b818cda767b44cd0c8f3baf4cc/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs?ref=82d73963334f01b818cda767b44cd0c8f3baf4cc", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn main() { test05(); }\n-\n-fn mk_counter<A:Copy>() -> fn~(A) -> (A,uint) {\n-    // The only reason that the counter is generic is so that it closes\n-    // over both a type descriptor and some data.\n-    let v = ~[mut 0u];\n-    return fn~(a: A) -> (A,uint) {\n-        let n = v[0];\n-        v[0] = n + 1u;\n-        (a, n)\n-    };\n-}\n-\n-fn test05() {\n-    let fp0 = mk_counter::<float>();\n-\n-    assert (5.3f, 0u) == fp0(5.3f);\n-    assert (5.5f, 1u) == fp0(5.5f);\n-\n-    let fp1 = copy fp0;\n-\n-    assert (5.3f, 2u) == fp0(5.3f);\n-    assert (5.3f, 2u) == fp1(5.3f);\n-    assert (5.5f, 3u) == fp0(5.5f);\n-    assert (5.5f, 3u) == fp1(5.5f);\n-}"}, {"sha": "1f4df7be1f3522cc36090412d89ea9d69c8ff944", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32498d8464e0dfa4e2cb31967a66e076da40109/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=a32498d8464e0dfa4e2cb31967a66e076da40109", "patch": "@@ -28,11 +28,11 @@ fn checktests() {\n     // Pull the tests out of the secreturn test module\n     let tests = __test::tests();\n \n-    let shouldignore = option::get(\n-        vec::find(tests, |t| t.name == ~\"shouldignore\" ));\n-    assert shouldignore.ignore == true;\n+    assert vec::any(\n+        tests,\n+        |t| t.desc.name == ~\"shouldignore\" && t.desc.ignore);\n \n-    let shouldnotignore = option::get(\n-        vec::find(tests, |t| t.name == ~\"shouldnotignore\" ));\n-    assert shouldnotignore.ignore == false;\n+    assert vec::any(\n+        tests,\n+        |t| t.desc.name == ~\"shouldnotignore\" && !t.desc.ignore);\n }\n\\ No newline at end of file"}]}