{"sha": "182044248ca2aa569844a25e73f90e5bc2fd05d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MjA0NDI0OGNhMmFhNTY5ODQ0YTI1ZTczZjkwZTViYzJmZDA1ZDM=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2017-03-02T16:27:57Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2017-03-14T09:02:45Z"}, "message": "Add Utf8Error::resume_from, to help incremental and/or lossy decoding.\n\nWithout this, code outside of the standard library needs to reimplement\nmost of the logic `from_utf8` to interpret the bytes after `valid_up_to()`.", "tree": {"sha": "5f0ee861b3a3b0f9191b7c80e3452ff86f499ddb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f0ee861b3a3b0f9191b7c80e3452ff86f499ddb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/182044248ca2aa569844a25e73f90e5bc2fd05d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/182044248ca2aa569844a25e73f90e5bc2fd05d3", "html_url": "https://github.com/rust-lang/rust/commit/182044248ca2aa569844a25e73f90e5bc2fd05d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/182044248ca2aa569844a25e73f90e5bc2fd05d3/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd182c4010b5aee72d070b15e90c98cb0fdc3776", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd182c4010b5aee72d070b15e90c98cb0fdc3776", "html_url": "https://github.com/rust-lang/rust/commit/fd182c4010b5aee72d070b15e90c98cb0fdc3776"}], "stats": {"total": 109, "additions": 87, "deletions": 22}, "files": [{"sha": "a7018daf0984781a3b0a0a621345d8c3785e1c82", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/182044248ca2aa569844a25e73f90e5bc2fd05d3/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182044248ca2aa569844a25e73f90e5bc2fd05d3/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=182044248ca2aa569844a25e73f90e5bc2fd05d3", "patch": "@@ -28,6 +28,7 @@\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n+#![feature(utf8_error_resume_from)]\n \n extern crate collections;\n extern crate test;"}, {"sha": "5de74d68b9eca47da2c66493f61b4c4ebb5d6776", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/182044248ca2aa569844a25e73f90e5bc2fd05d3/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182044248ca2aa569844a25e73f90e5bc2fd05d3/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=182044248ca2aa569844a25e73f90e5bc2fd05d3", "patch": "@@ -540,6 +540,36 @@ fn from_utf8_mostly_ascii() {\n     }\n }\n \n+#[test]\n+fn from_utf8_error() {\n+    macro_rules! test {\n+        ($input: expr, $expected_valid_up_to: expr, $expected_resume_from: expr) => {\n+            let error = from_utf8($input).unwrap_err();\n+            assert_eq!(error.valid_up_to(), $expected_valid_up_to);\n+            assert_eq!(error.resume_from(), $expected_resume_from);\n+        }\n+    }\n+    test!(b\"A\\xC3\\xA9 \\xFF \", 4, Some(5));\n+    test!(b\"A\\xC3\\xA9 \\x80 \", 4, Some(5));\n+    test!(b\"A\\xC3\\xA9 \\xC1 \", 4, Some(5));\n+    test!(b\"A\\xC3\\xA9 \\xC1\", 4, Some(5));\n+    test!(b\"A\\xC3\\xA9 \\xC2\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xC2 \", 4, Some(5));\n+    test!(b\"A\\xC3\\xA9 \\xC2\\xC0\", 4, Some(5));\n+    test!(b\"A\\xC3\\xA9 \\xE0\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xE0\\x9F\", 4, Some(5));\n+    test!(b\"A\\xC3\\xA9 \\xE0\\xA0\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xE0\\xA0\\xC0\", 4, Some(6));\n+    test!(b\"A\\xC3\\xA9 \\xE0\\xA0 \", 4, Some(6));\n+    test!(b\"A\\xC3\\xA9 \\xED\\xA0\\x80 \", 4, Some(5));\n+    test!(b\"A\\xC3\\xA9 \\xF1\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xF1\\x80\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xF1\\x80\\x80\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xF1 \", 4, Some(5));\n+    test!(b\"A\\xC3\\xA9 \\xF1\\x80 \", 4, Some(6));\n+    test!(b\"A\\xC3\\xA9 \\xF1\\x80\\x80 \", 4, Some(7));\n+}\n+\n #[test]\n fn test_as_bytes() {\n     // no null"}, {"sha": "eb13d28e82d23aea7a065d8c2599b6bfbf735fe9", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 56, "deletions": 22, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/182044248ca2aa569844a25e73f90e5bc2fd05d3/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182044248ca2aa569844a25e73f90e5bc2fd05d3/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=182044248ca2aa569844a25e73f90e5bc2fd05d3", "patch": "@@ -125,13 +125,14 @@ Section: Creating a string\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Utf8Error {\n     valid_up_to: usize,\n+    invalid_length: Option<u8>,\n }\n \n impl Utf8Error {\n     /// Returns the index in the given string up to which valid UTF-8 was\n     /// verified.\n     ///\n-    /// It is the maximum index such that `from_utf8(input[..index])`\n+    /// It is the maximum index such that `from_utf8(&input[..index])`\n     /// would return `Ok(_)`.\n     ///\n     /// # Examples\n@@ -152,6 +153,21 @@ impl Utf8Error {\n     /// ```\n     #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n     pub fn valid_up_to(&self) -> usize { self.valid_up_to }\n+\n+    /// Provide more information about the failure:\n+    ///\n+    /// * `None`: the end of the input was reached unexpectedly.\n+    ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n+    ///   If a byte stream (such as a file or a network socket) is being decoded incrementally,\n+    ///   this could be a valid `char` whose UTF-8 byte sequence is spanning multiple chunks.\n+    ///\n+    /// * `Some(index)`: an unexpected byte was encountered.\n+    ///   The index provided is where decoding should resume\n+    ///   (after inserting a U+FFFD REPLACEMENT CHARACTER) in case of lossy decoding.\n+    #[unstable(feature = \"utf8_error_resume_from\", reason =\"new\", issue = \"0\")]\n+    pub fn resume_from(&self) -> Option<usize> {\n+        self.invalid_length.map(|l| self.valid_up_to + l as usize)\n+    }\n }\n \n /// Converts a slice of bytes to a string slice.\n@@ -300,7 +316,12 @@ pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Utf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"invalid utf-8: invalid byte near index {}\", self.valid_up_to)\n+        if let Some(invalid_length) = self.invalid_length {\n+            write!(f, \"invalid utf-8 sequence of {} bytes from index {}\",\n+                   invalid_length, self.valid_up_to)\n+        } else {\n+            write!(f, \"incomplete utf-8 byte sequence from index {}\", self.valid_up_to)\n+        }\n     }\n }\n \n@@ -1241,25 +1262,27 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n \n     while index < len {\n         let old_offset = index;\n-        macro_rules! err { () => {{\n-            return Err(Utf8Error {\n-                valid_up_to: old_offset\n-            })\n-        }}}\n+        macro_rules! err {\n+            ($invalid_length: expr) => {\n+                return Err(Utf8Error {\n+                    valid_up_to: old_offset,\n+                    invalid_length: $invalid_length,\n+                })\n+            }\n+        }\n \n         macro_rules! next { () => {{\n             index += 1;\n             // we needed data, but there was none: error!\n             if index >= len {\n-                err!()\n+                err!(None)\n             }\n             v[index]\n         }}}\n \n         let first = v[index];\n         if first >= 128 {\n             let w = UTF8_CHAR_WIDTH[first as usize];\n-            let second = next!();\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n             // 3-byte encoding is for codepoints  \\u{0800} to  \\u{ffff}\n@@ -1279,25 +1302,36 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n             //               %xF4 %x80-8F 2( UTF8-tail )\n             match w {\n-                2 => if second & !CONT_MASK != TAG_CONT_U8 {err!()},\n+                2 => if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                    err!(Some(1))\n+                },\n                 3 => {\n-                    match (first, second, next!() & !CONT_MASK) {\n-                        (0xE0         , 0xA0 ... 0xBF, TAG_CONT_U8) |\n-                        (0xE1 ... 0xEC, 0x80 ... 0xBF, TAG_CONT_U8) |\n-                        (0xED         , 0x80 ... 0x9F, TAG_CONT_U8) |\n-                        (0xEE ... 0xEF, 0x80 ... 0xBF, TAG_CONT_U8) => {}\n-                        _ => err!()\n+                    match (first, next!()) {\n+                        (0xE0         , 0xA0 ... 0xBF) |\n+                        (0xE1 ... 0xEC, 0x80 ... 0xBF) |\n+                        (0xED         , 0x80 ... 0x9F) |\n+                        (0xEE ... 0xEF, 0x80 ... 0xBF) => {}\n+                        _ => err!(Some(1))\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(2))\n                     }\n                 }\n                 4 => {\n-                    match (first, second, next!() & !CONT_MASK, next!() & !CONT_MASK) {\n-                        (0xF0         , 0x90 ... 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n-                        (0xF1 ... 0xF3, 0x80 ... 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n-                        (0xF4         , 0x80 ... 0x8F, TAG_CONT_U8, TAG_CONT_U8) => {}\n-                        _ => err!()\n+                    match (first, next!()) {\n+                        (0xF0         , 0x90 ... 0xBF) |\n+                        (0xF1 ... 0xF3, 0x80 ... 0xBF) |\n+                        (0xF4         , 0x80 ... 0x8F) => {}\n+                        _ => err!(Some(1))\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(2))\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(3))\n                     }\n                 }\n-                _ => err!()\n+                _ => err!(Some(1))\n             }\n             index += 1;\n         } else {"}]}