{"sha": "7721d46bd76967e73a04b7944651094d3d2f9274", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MjFkNDZiZDc2OTY3ZTczYTA0Yjc5NDQ2NTEwOTRkM2QyZjkyNzQ=", "commit": {"author": {"name": "Markus", "email": "marwes91@gmail.com", "date": "2015-06-12T07:41:06Z"}, "committer": {"name": "Markus Westerlind", "email": "marwes91@gmail.com", "date": "2015-06-13T18:40:59Z"}, "message": "Utilize discriminant_value for more efficient deriving\n\nThe new code generated for deriving on enums looks something like this:\n\n```rust\nlet __self0_vi = unsafe {\n    std::intrinsics::discriminant_value(&self) } as i32;\nlet __self1_vi = unsafe {\n    std::intrinsics::discriminant_value(&__arg1) } as i32;\nlet __self2_vi = unsafe {\n    std::intrinsics::discriminant_value(&__arg2) } as i32;\n///\nif __self0_vi == __self1_vi && __self0_vi == __self2_vi && ... {\n    match (...) {\n        (Variant1, Variant1, ...) => Body1\n        (Variant2, Variant2, ...) => Body2,\n        ...\n        _ => ::core::intrinsics::unreachable()\n    }\n}\nelse {\n    ... // catch-all remainder can inspect above variant index values.\n}\n```\nThis helps massively for C-like enums since they will be compiled as a\nsingle comparison giving observed speedups of up to 8x. For more complex\nenums the speedup is more difficult to measure but it should not be\nslower to generate code this way regardless.", "tree": {"sha": "0b0bdab1dfce71aa270ea0e1cd670acbed31c4f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b0bdab1dfce71aa270ea0e1cd670acbed31c4f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7721d46bd76967e73a04b7944651094d3d2f9274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7721d46bd76967e73a04b7944651094d3d2f9274", "html_url": "https://github.com/rust-lang/rust/commit/7721d46bd76967e73a04b7944651094d3d2f9274", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7721d46bd76967e73a04b7944651094d3d2f9274/comments", "author": {"login": "Marwes", "id": 957312, "node_id": "MDQ6VXNlcjk1NzMxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/957312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Marwes", "html_url": "https://github.com/Marwes", "followers_url": "https://api.github.com/users/Marwes/followers", "following_url": "https://api.github.com/users/Marwes/following{/other_user}", "gists_url": "https://api.github.com/users/Marwes/gists{/gist_id}", "starred_url": "https://api.github.com/users/Marwes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Marwes/subscriptions", "organizations_url": "https://api.github.com/users/Marwes/orgs", "repos_url": "https://api.github.com/users/Marwes/repos", "events_url": "https://api.github.com/users/Marwes/events{/privacy}", "received_events_url": "https://api.github.com/users/Marwes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Marwes", "id": 957312, "node_id": "MDQ6VXNlcjk1NzMxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/957312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Marwes", "html_url": "https://github.com/Marwes", "followers_url": "https://api.github.com/users/Marwes/followers", "following_url": "https://api.github.com/users/Marwes/following{/other_user}", "gists_url": "https://api.github.com/users/Marwes/gists{/gist_id}", "starred_url": "https://api.github.com/users/Marwes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Marwes/subscriptions", "organizations_url": "https://api.github.com/users/Marwes/orgs", "repos_url": "https://api.github.com/users/Marwes/repos", "events_url": "https://api.github.com/users/Marwes/events{/privacy}", "received_events_url": "https://api.github.com/users/Marwes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9f1e29c4ef68d09f3a926462e4be946d0749042", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f1e29c4ef68d09f3a926462e4be946d0749042", "html_url": "https://github.com/rust-lang/rust/commit/a9f1e29c4ef68d09f3a926462e4be946d0749042"}], "stats": {"total": 124, "additions": 85, "deletions": 39}, "files": [{"sha": "e5b93db4f395d28fb8b273e8499b2fbfa7f44633", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 85, "deletions": 39, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/7721d46bd76967e73a04b7944651094d3d2f9274/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7721d46bd76967e73a04b7944651094d3d2f9274/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7721d46bd76967e73a04b7944651094d3d2f9274", "patch": "@@ -1048,15 +1048,23 @@ impl<'a> MethodDef<'a> {\n     /// discriminant values.  See issue #15523.)\n \n     /// ```{.text}\n-    /// match (this, that, ...) {\n-    ///   (Variant1, Variant1, Variant1) => ... // delegate Matching on Variant1\n-    ///   (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\n-    ///   ...\n-    ///   _ => {\n-    ///     let __this_vi = match this { Variant1 => 0, Variant2 => 1, ... };\n-    ///     let __that_vi = match that { Variant1 => 0, Variant2 => 1, ... };\n+    /// let __self0_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&self) } as i32;\n+    /// let __self1_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&__arg1) } as i32;\n+    /// let __self2_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&__arg2) } as i32;\n+    ///\n+    /// if __self0_vi == __self1_vi && __self0_vi == __self2_vi && ... {\n+    ///     match (...) {\n+    ///         (Variant1, Variant1, ...) => Body1\n+    ///         (Variant2, Variant2, ...) => Body2,\n+    ///         ...\n+    ///         _ => ::core::intrinsics::unreachable()\n+    ///     }\n+    /// }\n+    /// else {\n     ///     ... // catch-all remainder can inspect above variant index values.\n-    ///   }\n     /// }\n     /// ```\n     fn build_enum_match_tuple<'b>(\n@@ -1187,7 +1195,6 @@ impl<'a> MethodDef<'a> {\n \n                 cx.arm(sp, vec![single_pat], arm_expr)\n             }).collect();\n-\n         // We will usually need the catch-all after matching the\n         // tuples `(VariantK, VariantK, ...)` for each VariantK of the\n         // enum.  But:\n@@ -1223,9 +1230,14 @@ impl<'a> MethodDef<'a> {\n             // ```\n             let mut index_let_stmts: Vec<P<ast::Stmt>> = Vec::new();\n \n+            //We also build an expression which checks whether all discriminants are equal\n+            // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n+            let mut discriminant_test = cx.expr_bool(sp, true);\n+\n             let target_type_name =\n                 find_repr_type_name(&cx.parse_sess.span_diagnostic, type_attrs);\n \n+            let mut first_ident = None;\n             for (&ident, self_arg) in vi_idents.iter().zip(&self_args) {\n                 let path = vec![cx.ident_of_std(\"core\"),\n                                 cx.ident_of(\"intrinsics\"),\n@@ -1243,32 +1255,64 @@ impl<'a> MethodDef<'a> {\n                 let variant_disr = cx.expr_cast(sp, variant_value, target_ty);\n                 let let_stmt = cx.stmt_let(sp, false, ident, variant_disr);\n                 index_let_stmts.push(let_stmt);\n+\n+                match first_ident {\n+                    Some(first) => {\n+                        let first_expr = cx.expr_ident(sp, first);\n+                        let id = cx.expr_ident(sp, ident);\n+                        let test = cx.expr_binary(sp, ast::BiEq, first_expr, id);\n+                        discriminant_test = cx.expr_binary(sp, ast::BiAnd, discriminant_test, test)\n+                    }\n+                    None => {\n+                        first_ident = Some(ident);\n+                    }\n+                }\n             }\n \n             let arm_expr = self.call_substructure_method(\n                 cx, trait_, type_ident, &self_args[..], nonself_args,\n                 &catch_all_substructure);\n \n-            // Builds the expression:\n-            // {\n-            //   let __self0_vi = ...;\n-            //   let __self1_vi = ...;\n-            //   ...\n-            //   <delegated expression referring to __self0_vi, et al.>\n-            // }\n-            let arm_expr = cx.expr_block(\n-                cx.block_all(sp, index_let_stmts, Some(arm_expr)));\n-\n-            // Builds arm:\n-            // _ => { let __self0_vi = ...;\n-            //        let __self1_vi = ...;\n-            //        ...\n-            //        <delegated expression as above> }\n-            let catch_all_match_arm =\n-                cx.arm(sp, vec![cx.pat_wild(sp)], arm_expr);\n-\n-            match_arms.push(catch_all_match_arm);\n-\n+            //Since we know that all the arguments will match if we reach the match expression we\n+            //add the unreachable intrinsics as the result of the catch all which should help llvm\n+            //in optimizing it\n+            let path = vec![cx.ident_of_std(\"core\"),\n+                            cx.ident_of(\"intrinsics\"),\n+                            cx.ident_of(\"unreachable\")];\n+            let call = cx.expr_call_global(\n+                sp, path, vec![]);\n+            let unreachable = cx.expr_block(P(ast::Block {\n+                stmts: vec![],\n+                expr: Some(call),\n+                id: ast::DUMMY_NODE_ID,\n+                rules: ast::UnsafeBlock(ast::CompilerGenerated),\n+                span: sp }));\n+            match_arms.push(cx.arm(sp, vec![cx.pat_wild(sp)], unreachable));\n+\n+            // Final wrinkle: the self_args are expressions that deref\n+            // down to desired l-values, but we cannot actually deref\n+            // them when they are fed as r-values into a tuple\n+            // expression; here add a layer of borrowing, turning\n+            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n+            let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n+            let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n+\n+            //Lastly we create an expression which branches on all discriminants being equal\n+            //  if discriminant_test {\n+            //      match (...) {\n+            //          (Variant1, Variant1, ...) => Body1\n+            //          (Variant2, Variant2, ...) => Body2,\n+            //          ...\n+            //          _ => ::core::intrinsics::unreachable()\n+            //      }\n+            //  }\n+            //  else {\n+            //      <delegated expression referring to __self0_vi, et al.>\n+            //  }\n+            let all_match = cx.expr_match(sp, match_arg, match_arms);\n+            let arm_expr = cx.expr_if(sp, discriminant_test, all_match, Some(arm_expr));\n+            cx.expr_block(\n+                cx.block_all(sp, index_let_stmts, Some(arm_expr)))\n         } else if variants.is_empty() {\n             // As an additional wrinkle, For a zero-variant enum A,\n             // currently the compiler\n@@ -1319,17 +1363,19 @@ impl<'a> MethodDef<'a> {\n             // derive Debug on such a type could here generate code\n             // that needs the feature gate enabled.)\n \n-            return cx.expr_unreachable(sp);\n+            cx.expr_unreachable(sp)\n+        }\n+        else {\n+\n+            // Final wrinkle: the self_args are expressions that deref\n+            // down to desired l-values, but we cannot actually deref\n+            // them when they are fed as r-values into a tuple\n+            // expression; here add a layer of borrowing, turning\n+            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n+            let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n+            let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n+            cx.expr_match(sp, match_arg, match_arms)\n         }\n-\n-        // Final wrinkle: the self_args are expressions that deref\n-        // down to desired l-values, but we cannot actually deref\n-        // them when they are fed as r-values into a tuple\n-        // expression; here add a layer of borrowing, turning\n-        // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-        let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n-        let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n-        cx.expr_match(sp, match_arg, match_arms)\n     }\n \n     fn expand_static_enum_method_body(&self,"}]}