{"sha": "c6e130e89bb6e57ce492a9551da6828cce054422", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZTEzMGU4OWJiNmU1N2NlNDkyYTk1NTFkYTY4MjhjY2UwNTQ0MjI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-01T20:17:18Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-01T20:17:18Z"}, "message": "rustc_const_eval: convert constants to Pattern instead of hir::Pat.", "tree": {"sha": "86cb4e9102fabb992ace38e0d1fd8dbe2338da62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86cb4e9102fabb992ace38e0d1fd8dbe2338da62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6e130e89bb6e57ce492a9551da6828cce054422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6e130e89bb6e57ce492a9551da6828cce054422", "html_url": "https://github.com/rust-lang/rust/commit/c6e130e89bb6e57ce492a9551da6828cce054422", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6e130e89bb6e57ce492a9551da6828cce054422/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c001b0940c1597f422f41c308a55cc6e22f48e46", "url": "https://api.github.com/repos/rust-lang/rust/commits/c001b0940c1597f422f41c308a55cc6e22f48e46", "html_url": "https://github.com/rust-lang/rust/commit/c001b0940c1597f422f41c308a55cc6e22f48e46"}], "stats": {"total": 368, "additions": 180, "deletions": 188}, "files": [{"sha": "53e83815b465233ca5261435a56afc543971a289", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c6e130e89bb6e57ce492a9551da6828cce054422/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e130e89bb6e57ce492a9551da6828cce054422/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=c6e130e89bb6e57ce492a9551da6828cce054422", "patch": "@@ -116,13 +116,6 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     fn report_inlining_errors(&self, patcx: PatternContext, pat_span: Span) {\n         for error in patcx.errors {\n             match error {\n-                PatternError::BadConstInPattern(span, def_id) => {\n-                    self.tcx.sess.span_err(\n-                        span,\n-                        &format!(\"constants of the type `{}` \\\n-                                  cannot be used in patterns\",\n-                                 self.tcx.item_path_str(def_id)));\n-                }\n                 PatternError::StaticInPattern(span) => {\n                     span_err!(self.tcx.sess, span, E0158,\n                               \"statics cannot be referenced in patterns\");"}, {"sha": "6b8e0e34c1df63db42f70429e13631ce284b7b48", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 3, "deletions": 127, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c6e130e89bb6e57ce492a9551da6828cce054422/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e130e89bb6e57ce492a9551da6828cce054422/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=c6e130e89bb6e57ce492a9551da6828cce054422", "patch": "@@ -18,24 +18,20 @@ use self::EvalHint::*;\n use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::traits;\n-use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::Substs;\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::DefIdMap;\n-use rustc::lint;\n \n use graphviz::IntoCow;\n use syntax::ast;\n-use rustc::hir::{Expr, PatKind};\n-use rustc::hir;\n-use syntax::ptr::P;\n-use syntax::codemap;\n+use rustc::hir::{self, Expr};\n use syntax::attr::IntType;\n-use syntax_pos::{self, Span};\n+use syntax_pos::Span;\n \n use std::borrow::Cow;\n use std::cmp::Ordering;\n@@ -186,126 +182,6 @@ fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     }\n }\n \n-pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   expr: &Expr,\n-                                   pat_id: ast::NodeId,\n-                                   span: Span)\n-                                   -> Result<P<hir::Pat>, DefId> {\n-    let pat_ty = tcx.tables().expr_ty(expr);\n-    debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n-    match pat_ty.sty {\n-        ty::TyFloat(_) => {\n-            tcx.sess.add_lint(\n-                lint::builtin::ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN,\n-                pat_id,\n-                span,\n-                format!(\"floating point constants cannot be used in patterns\"));\n-        }\n-        ty::TyAdt(adt_def, _) if adt_def.is_union() => {\n-            // Matching on union fields is unsafe, we can't hide it in constants\n-            tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n-        }\n-        ty::TyAdt(adt_def, _) => {\n-            if !tcx.has_attr(adt_def.did, \"structural_match\") {\n-                tcx.sess.add_lint(\n-                    lint::builtin::ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n-                    pat_id,\n-                    span,\n-                    format!(\"to use a constant of type `{}` \\\n-                             in a pattern, \\\n-                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                            tcx.item_path_str(adt_def.did),\n-                            tcx.item_path_str(adt_def.did)));\n-            }\n-        }\n-        _ => { }\n-    }\n-    let pat = match expr.node {\n-        hir::ExprTup(ref exprs) =>\n-            PatKind::Tuple(exprs.iter()\n-                                .map(|expr| const_expr_to_pat(tcx, &expr, pat_id, span))\n-                                .collect::<Result<_, _>>()?, None),\n-\n-        hir::ExprCall(ref callee, ref args) => {\n-            let qpath = match callee.node {\n-                hir::ExprPath(ref qpath) => qpath,\n-                _ => bug!()\n-            };\n-            let def = tcx.tables().qpath_def(qpath, callee.id);\n-            let ctor_path = if let hir::QPath::Resolved(_, ref path) = *qpath {\n-                match def {\n-                    Def::StructCtor(_, CtorKind::Fn) |\n-                    Def::VariantCtor(_, CtorKind::Fn) => {\n-                        Some(path.clone())\n-                    }\n-                    _ => None\n-                }\n-            } else {\n-                None\n-            };\n-            match (def, ctor_path) {\n-                (Def::Fn(..), None) | (Def::Method(..), None) => {\n-                    PatKind::Lit(P(expr.clone()))\n-                }\n-                (_, Some(ctor_path)) => {\n-                    let pats = args.iter()\n-                                   .map(|expr| const_expr_to_pat(tcx, expr, pat_id, span))\n-                                   .collect::<Result<_, _>>()?;\n-                    PatKind::TupleStruct(hir::QPath::Resolved(None, ctor_path), pats, None)\n-                }\n-                _ => bug!()\n-            }\n-        }\n-\n-        hir::ExprStruct(ref qpath, ref fields, None) => {\n-            let field_pats =\n-                fields.iter()\n-                      .map(|field| Ok(codemap::Spanned {\n-                          span: syntax_pos::DUMMY_SP,\n-                          node: hir::FieldPat {\n-                              name: field.name.node,\n-                              pat: const_expr_to_pat(tcx, &field.expr, pat_id, span)?,\n-                              is_shorthand: false,\n-                          },\n-                      }))\n-                      .collect::<Result<_, _>>()?;\n-            PatKind::Struct(qpath.clone(), field_pats, false)\n-        }\n-\n-        hir::ExprArray(ref exprs) => {\n-            let pats = exprs.iter()\n-                            .map(|expr| const_expr_to_pat(tcx, &expr, pat_id, span))\n-                            .collect::<Result<_, _>>()?;\n-            PatKind::Slice(pats, None, hir::HirVec::new())\n-        }\n-\n-        hir::ExprPath(ref qpath) => {\n-            let def = tcx.tables().qpath_def(qpath, expr.id);\n-            match def {\n-                Def::StructCtor(_, CtorKind::Const) |\n-                Def::VariantCtor(_, CtorKind::Const) => {\n-                    match expr.node {\n-                        hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n-                            PatKind::Path(hir::QPath::Resolved(None, path.clone()))\n-                        }\n-                        _ => bug!()\n-                    }\n-                }\n-                Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                    let substs = Some(tcx.tables().node_id_item_substs(expr.id)\n-                        .unwrap_or_else(|| tcx.intern_substs(&[])));\n-                    let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n-                    return const_expr_to_pat(tcx, expr, pat_id, span);\n-                },\n-                _ => bug!(),\n-            }\n-        }\n-\n-        _ => PatKind::Lit(P(expr.clone()))\n-    };\n-    Ok(P(hir::Pat { id: expr.id, node: pat, span: span }))\n-}\n-\n pub fn report_const_eval_err<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err: &ConstEvalErr,"}, {"sha": "b122d97a702f6df6574582667f6625a171d58fa5", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 177, "deletions": 54, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/c6e130e89bb6e57ce492a9551da6828cce054422/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e130e89bb6e57ce492a9551da6828cce054422/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=c6e130e89bb6e57ce492a9551da6828cce054422", "patch": "@@ -10,12 +10,12 @@\n \n use eval;\n \n+use rustc::lint;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{Def, CtorKind};\n-use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -28,7 +28,6 @@ use syntax_pos::Span;\n #[derive(Clone, Debug)]\n pub enum PatternError {\n     StaticInPattern(Span),\n-    BadConstInPattern(Span, DefId),\n     ConstEval(eval::ConstEvalErr),\n }\n \n@@ -286,64 +285,20 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n \n-            PatKind::Lit(ref value) => {\n-                match eval::eval_const_expr_checked(self.tcx.global_tcx(), value) {\n-                    Ok(value) => {\n-                        PatternKind::Constant { value: value }\n-                    }\n-                    Err(e) => {\n-                        self.errors.push(PatternError::ConstEval(e));\n-                        PatternKind::Wild\n-                    }\n-                }\n-            }\n+            PatKind::Lit(ref value) => self.lower_lit(value),\n \n             PatKind::Range(ref lo, ref hi) => {\n-                let r_lo = eval::eval_const_expr_checked(self.tcx.global_tcx(), lo);\n-                if let Err(ref e_lo) = r_lo {\n-                    self.errors.push(PatternError::ConstEval(e_lo.clone()));\n-                }\n-\n-                let r_hi = eval::eval_const_expr_checked(self.tcx.global_tcx(), hi);\n-                if let Err(ref e_hi) = r_hi {\n-                    self.errors.push(PatternError::ConstEval(e_hi.clone()));\n-                }\n-\n-                if let (Ok(lo), Ok(hi)) = (r_lo, r_hi) {\n-                    PatternKind::Range { lo: lo, hi: hi }\n-                } else {\n-                    PatternKind::Wild\n+                match (self.lower_lit(lo), self.lower_lit(hi)) {\n+                    (PatternKind::Constant { value: lo },\n+                     PatternKind::Constant { value: hi }) => {\n+                        PatternKind::Range { lo: lo, hi: hi }\n+                    }\n+                    _ => PatternKind::Wild\n                 }\n             }\n \n             PatKind::Path(ref qpath) => {\n-                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n-                match def {\n-                    Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                        let tcx = self.tcx.global_tcx();\n-                        let substs = tcx.tables().node_id_item_substs(pat.id)\n-                            .unwrap_or_else(|| tcx.intern_substs(&[]));\n-                        match eval::lookup_const_by_id(tcx, def_id, Some(substs)) {\n-                            Some((const_expr, _const_ty)) => {\n-                                match eval::const_expr_to_pat(\n-                                    tcx, const_expr, pat.id, pat.span)\n-                                {\n-                                    Ok(pat) => return self.lower_pattern(&pat),\n-                                    Err(_) => {\n-                                        self.errors.push(PatternError::BadConstInPattern(\n-                                            pat.span, def_id));\n-                                        PatternKind::Wild\n-                                    }\n-                                }\n-                            }\n-                            None => {\n-                                self.errors.push(PatternError::StaticInPattern(pat.span));\n-                                PatternKind::Wild\n-                            }\n-                        }\n-                    }\n-                    _ => self.lower_variant_or_leaf(def, vec![])\n-                }\n+                return self.lower_path(qpath, pat.id, pat.id, pat.span);\n             }\n \n             PatKind::Ref(ref subpattern, _) |\n@@ -600,6 +555,174 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             _ => bug!()\n         }\n     }\n+\n+    fn lower_path(&mut self,\n+                  qpath: &hir::QPath,\n+                  id: ast::NodeId,\n+                  pat_id: ast::NodeId,\n+                  span: Span)\n+                  -> Pattern<'tcx> {\n+        let def = self.tcx.tables().qpath_def(qpath, id);\n+        let kind = match def {\n+            Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n+                let tcx = self.tcx.global_tcx();\n+                let substs = tcx.tables().node_id_item_substs(id)\n+                    .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                match eval::lookup_const_by_id(tcx, def_id, Some(substs)) {\n+                    Some((const_expr, _const_ty)) => {\n+                        return self.lower_const_expr(const_expr, pat_id, span);\n+                    }\n+                    None => {\n+                        self.errors.push(PatternError::StaticInPattern(span));\n+                        PatternKind::Wild\n+                    }\n+                }\n+            }\n+            _ => self.lower_variant_or_leaf(def, vec![])\n+        };\n+\n+        Pattern {\n+            span: span,\n+            ty: self.tcx.tables().node_id_to_type(id),\n+            kind: Box::new(kind),\n+        }\n+    }\n+\n+    fn lower_lit(&mut self, expr: &hir::Expr) -> PatternKind<'tcx> {\n+        match eval::eval_const_expr_checked(self.tcx.global_tcx(), expr) {\n+            Ok(value) => {\n+                PatternKind::Constant { value: value }\n+            }\n+            Err(e) => {\n+                self.errors.push(PatternError::ConstEval(e));\n+                PatternKind::Wild\n+            }\n+        }\n+    }\n+\n+    fn lower_const_expr(&mut self,\n+                        expr: &hir::Expr,\n+                        pat_id: ast::NodeId,\n+                        span: Span)\n+                        -> Pattern<'tcx> {\n+        let pat_ty = self.tcx.tables().expr_ty(expr);\n+        debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n+        match pat_ty.sty {\n+            ty::TyFloat(_) => {\n+                self.tcx.sess.add_lint(\n+                    lint::builtin::ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN,\n+                    pat_id,\n+                    span,\n+                    format!(\"floating point constants cannot be used in patterns\"));\n+            }\n+            ty::TyAdt(adt_def, _) if adt_def.is_union() => {\n+                // Matching on union fields is unsafe, we can't hide it in constants\n+                self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n+            }\n+            ty::TyAdt(adt_def, _) => {\n+                if !self.tcx.has_attr(adt_def.did, \"structural_match\") {\n+                    self.tcx.sess.add_lint(\n+                        lint::builtin::ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n+                        pat_id,\n+                        span,\n+                        format!(\"to use a constant of type `{}` \\\n+                                 in a pattern, \\\n+                                 `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                                self.tcx.item_path_str(adt_def.did),\n+                                self.tcx.item_path_str(adt_def.did)));\n+                }\n+            }\n+            _ => { }\n+        }\n+        let kind = match expr.node {\n+            hir::ExprTup(ref exprs) => {\n+                PatternKind::Leaf {\n+                    subpatterns: exprs.iter().enumerate().map(|(i, expr)| {\n+                        FieldPattern {\n+                            field: Field::new(i),\n+                            pattern: self.lower_const_expr(expr, pat_id, span)\n+                        }\n+                    }).collect()\n+                }\n+            }\n+\n+            hir::ExprCall(ref callee, ref args) => {\n+                let qpath = match callee.node {\n+                    hir::ExprPath(ref qpath) => qpath,\n+                    _ => bug!()\n+                };\n+                let def = self.tcx.tables().qpath_def(qpath, callee.id);\n+                match def {\n+                    Def::Fn(..) | Def::Method(..) => self.lower_lit(expr),\n+                    _ => {\n+                        let subpatterns = args.iter().enumerate().map(|(i, expr)| {\n+                            FieldPattern {\n+                                field: Field::new(i),\n+                                pattern: self.lower_const_expr(expr, pat_id, span)\n+                            }\n+                        }).collect();\n+                        self.lower_variant_or_leaf(def, subpatterns)\n+                    }\n+                }\n+            }\n+\n+            hir::ExprStruct(ref qpath, ref fields, None) => {\n+                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n+                let pat_ty = self.tcx.tables().node_id_to_type(expr.id);\n+                let adt_def = match pat_ty.sty {\n+                    ty::TyAdt(adt_def, _) => adt_def,\n+                    _ => {\n+                        span_bug!(\n+                            expr.span,\n+                            \"struct expr without ADT type\");\n+                    }\n+                };\n+                let variant_def = adt_def.variant_of_def(def);\n+\n+                let subpatterns =\n+                    fields.iter()\n+                          .map(|field| {\n+                              let index = variant_def.index_of_field_named(field.name.node);\n+                              let index = index.unwrap_or_else(|| {\n+                                  span_bug!(\n+                                      expr.span,\n+                                      \"no field with name {:?}\",\n+                                      field.name);\n+                              });\n+                              FieldPattern {\n+                                  field: Field::new(index),\n+                                  pattern: self.lower_const_expr(&field.expr, pat_id, span),\n+                              }\n+                          })\n+                          .collect();\n+\n+                self.lower_variant_or_leaf(def, subpatterns)\n+            }\n+\n+            hir::ExprArray(ref exprs) => {\n+                let pats = exprs.iter()\n+                                .map(|expr| self.lower_const_expr(expr, pat_id, span))\n+                                .collect();\n+                PatternKind::Array {\n+                    prefix: pats,\n+                    slice: None,\n+                    suffix: vec![]\n+                }\n+            }\n+\n+            hir::ExprPath(ref qpath) => {\n+                return self.lower_path(qpath, expr.id, pat_id, span);\n+            }\n+\n+            _ => self.lower_lit(expr)\n+        };\n+\n+        Pattern {\n+            span: span,\n+            ty: pat_ty,\n+            kind: Box::new(kind),\n+        }\n+    }\n }\n \n pub trait PatternFoldable<'tcx> : Sized {"}]}