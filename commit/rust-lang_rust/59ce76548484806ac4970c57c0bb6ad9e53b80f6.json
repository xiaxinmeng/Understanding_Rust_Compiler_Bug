{"sha": "59ce76548484806ac4970c57c0bb6ad9e53b80f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5Y2U3NjU0ODQ4NDgwNmFjNDk3MGM1N2MwYmI2YWQ5ZTUzYjgwZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-29T10:12:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-29T10:12:54Z"}, "message": "Auto merge of #88312 - jackh726:issue-87748, r=nikomatsakis\n\nTreat types in unnormalized function signatures as well-formed\n\nFixes #87748\n\nr? `@nikomatsakis`", "tree": {"sha": "c6611ca8c4c111e9880e10bccc1614138615bcdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6611ca8c4c111e9880e10bccc1614138615bcdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59ce76548484806ac4970c57c0bb6ad9e53b80f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59ce76548484806ac4970c57c0bb6ad9e53b80f6", "html_url": "https://github.com/rust-lang/rust/commit/59ce76548484806ac4970c57c0bb6ad9e53b80f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59ce76548484806ac4970c57c0bb6ad9e53b80f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66acdee9f7822ff2427f2b967e537215421eeb16", "url": "https://api.github.com/repos/rust-lang/rust/commits/66acdee9f7822ff2427f2b967e537215421eeb16", "html_url": "https://github.com/rust-lang/rust/commit/66acdee9f7822ff2427f2b967e537215421eeb16"}, {"sha": "97bf80dfda3627175b21bade3ba8e51b512c2186", "url": "https://api.github.com/repos/rust-lang/rust/commits/97bf80dfda3627175b21bade3ba8e51b512c2186", "html_url": "https://github.com/rust-lang/rust/commit/97bf80dfda3627175b21bade3ba8e51b512c2186"}], "stats": {"total": 99, "additions": 90, "deletions": 9}, "files": [{"sha": "6426098d843fe80fd2dd709de1a3dcd3b7fc7fab", "filename": "compiler/rustc_mir/src/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ce76548484806ac4970c57c0bb6ad9e53b80f6/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=59ce76548484806ac4970c57c0bb6ad9e53b80f6", "patch": "@@ -256,6 +256,9 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n         let constraint_sets: Vec<_> = unnormalized_input_output_tys\n             .flat_map(|ty| {\n                 debug!(\"build: input_or_output={:?}\", ty);\n+                // We add implied bounds from both the unnormalized and normalized ty\n+                // See issue #87748\n+                let constraints_implied_1 = self.add_implied_bounds(ty);\n                 let TypeOpOutput { output: ty, constraints: constraints1, .. } = self\n                     .param_env\n                     .and(type_op::normalize::Normalize::new(ty))\n@@ -271,9 +274,21 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                             canonicalized_query: None,\n                         }\n                     });\n-                let constraints2 = self.add_implied_bounds(ty);\n+                // Note: we need this in examples like\n+                // ```\n+                // trait Foo {\n+                //   type Bar;\n+                //   fn foo(&self) -> &Self::Bar;\n+                // }\n+                // impl Foo for () {\n+                //   type Bar = ();\n+                //   fn foo(&self) ->&() {}\n+                // }\n+                // ```\n+                // Both &Self::Bar and &() are WF\n+                let constraints_implied_2 = self.add_implied_bounds(ty);\n                 normalized_inputs_and_output.push(ty);\n-                constraints1.into_iter().chain(constraints2)\n+                constraints1.into_iter().chain(constraints_implied_1).chain(constraints_implied_2)\n             })\n             .collect();\n "}, {"sha": "d59291b8fd493e1a1c2106e7c629585ac3ff167a", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ce76548484806ac4970c57c0bb6ad9e53b80f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=59ce76548484806ac4970c57c0bb6ad9e53b80f6", "patch": "@@ -250,6 +250,8 @@ fn compare_predicate_entailment<'tcx>(\n         // Compute placeholder form of impl and trait method tys.\n         let tcx = infcx.tcx;\n \n+        let mut wf_tys = vec![];\n+\n         let (impl_sig, _) = infcx.replace_bound_vars_with_fresh_vars(\n             impl_m_span,\n             infer::HigherRankedType,\n@@ -260,10 +262,18 @@ fn compare_predicate_entailment<'tcx>(\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n+        // First liberate late bound regions and subst placeholders\n         let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, tcx.fn_sig(trait_m.def_id));\n         let trait_sig = trait_sig.subst(tcx, trait_to_placeholder_substs);\n+        // Next, add all inputs and output as well-formed tys. Importantly,\n+        // we have to do this before normalization, since the normalized ty may\n+        // not contain the input parameters. See issue #87748.\n+        wf_tys.extend(trait_sig.inputs_and_output.iter());\n         let trait_sig =\n             inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, trait_sig);\n+        // Also add the resulting inputs and output as well-formed.\n+        // This probably isn't strictly necessary.\n+        wf_tys.extend(trait_sig.inputs_and_output.iter());\n         let trait_fty = tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n@@ -388,7 +398,7 @@ fn compare_predicate_entailment<'tcx>(\n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n         let fcx = FnCtxt::new(&inh, param_env, impl_m_hir_id);\n-        fcx.regionck_item(impl_m_hir_id, impl_m_span, trait_sig.inputs_and_output);\n+        fcx.regionck_item(impl_m_hir_id, impl_m_span, &wf_tys);\n \n         Ok(())\n     })"}, {"sha": "803c440bbc98b3ae6f06aed391238390d38ea9df", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ce76548484806ac4970c57c0bb6ad9e53b80f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=59ce76548484806ac4970c57c0bb6ad9e53b80f6", "patch": "@@ -364,7 +364,7 @@ fn typeck_with_fallback<'tcx>(\n \n     let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n-        let fcx = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n+        let (fcx, wf_tys) = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n             let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n                 let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n                 <dyn AstConv<'_>>::ty_of_fn(\n@@ -383,17 +383,25 @@ fn typeck_with_fallback<'tcx>(\n \n             check_abi(tcx, id, span, fn_sig.abi());\n \n+            // When normalizing the function signature, we assume all types are\n+            // well-formed. So, we don't need to worry about the obligations\n+            // from normalization. We could just discard these, but to align with\n+            // compare_method and elsewhere, we just add implied bounds for\n+            // these types.\n+            let mut wf_tys = vec![];\n             // Compute the fty from point of view of inside the fn.\n             let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n+            wf_tys.extend(fn_sig.inputs_and_output.iter());\n             let fn_sig = inh.normalize_associated_types_in(\n                 body.value.span,\n                 body_id.hir_id,\n                 param_env,\n                 fn_sig,\n             );\n+            wf_tys.extend(fn_sig.inputs_and_output.iter());\n \n             let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, None, true).0;\n-            fcx\n+            (fcx, wf_tys)\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n             let expected_type = body_ty\n@@ -443,7 +451,7 @@ fn typeck_with_fallback<'tcx>(\n \n             fcx.write_ty(id, expected_type);\n \n-            fcx\n+            (fcx, vec![])\n         };\n \n         let fallback_has_occurred = fcx.type_inference_fallback();\n@@ -467,7 +475,7 @@ fn typeck_with_fallback<'tcx>(\n         fcx.select_all_obligations_or_error();\n \n         if fn_sig.is_some() {\n-            fcx.regionck_fn(id, body);\n+            fcx.regionck_fn(id, body, span, &wf_tys);\n         } else {\n             fcx.regionck_expr(body);\n         }"}, {"sha": "290fa5fc36719278954ab0e9963399234d2d9ff3", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ce76548484806ac4970c57c0bb6ad9e53b80f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=59ce76548484806ac4970c57c0bb6ad9e53b80f6", "patch": "@@ -144,11 +144,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// rest of type check and because sometimes we need type\n     /// inference to have completed before we can determine which\n     /// constraints to add.\n-    pub fn regionck_fn(&self, fn_id: hir::HirId, body: &'tcx hir::Body<'tcx>) {\n+    pub(crate) fn regionck_fn(\n+        &self,\n+        fn_id: hir::HirId,\n+        body: &'tcx hir::Body<'tcx>,\n+        span: Span,\n+        wf_tys: &[Ty<'tcx>],\n+    ) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let hir_id = body.value.hir_id;\n         let mut rcx = RegionCtxt::new(self, hir_id, Subject(subject), self.param_env);\n+        // We need to add the implied bounds from the function signature\n+        rcx.outlives_environment.add_implied_bounds(self, wf_tys, fn_id, span);\n+        rcx.outlives_environment.save_implied_bounds(fn_id);\n \n         if !self.errors_reported_since_creation() {\n             // regionck assumes typeck succeeded"}, {"sha": "5ade3828b72654f5b9d471703774f45c5f793b63", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ce76548484806ac4970c57c0bb6ad9e53b80f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=59ce76548484806ac4970c57c0bb6ad9e53b80f6", "patch": "@@ -911,6 +911,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n     }\n }\n \n+#[tracing::instrument(level = \"debug\", skip(fcx, span, hir_decl))]\n fn check_fn_or_method<'fcx, 'tcx>(\n     fcx: &FnCtxt<'fcx, 'tcx>,\n     span: Span,\n@@ -921,6 +922,11 @@ fn check_fn_or_method<'fcx, 'tcx>(\n ) {\n     let sig = fcx.tcx.liberate_late_bound_regions(def_id, sig);\n \n+    // Unnormalized types in signature are WF too\n+    implied_bounds.extend(sig.inputs());\n+    // FIXME(#27579) return types should not be implied bounds\n+    implied_bounds.push(sig.output());\n+\n     // Normalize the input and output types one at a time, using a different\n     // `WellFormedLoc` for each. We cannot call `normalize_associated_types`\n     // on the entire `FnSig`, since this would use the same `WellFormedLoc`\n@@ -970,9 +976,11 @@ fn check_fn_or_method<'fcx, 'tcx>(\n         ObligationCauseCode::ReturnType,\n     );\n \n-    // FIXME(#25759) return types should not be implied bounds\n+    // FIXME(#27579) return types should not be implied bounds\n     implied_bounds.push(sig.output());\n \n+    debug!(?implied_bounds);\n+\n     check_where_clauses(fcx, span, def_id, Some((sig.output(), hir_decl.output.span())));\n }\n \n@@ -1117,6 +1125,7 @@ const HELP_FOR_SELF_TYPE: &str = \"consider changing to `self`, `&self`, `&mut se\n      `self: Rc<Self>`, `self: Arc<Self>`, or `self: Pin<P>` (where P is one \\\n      of the previous types except `Self`)\";\n \n+#[tracing::instrument(level = \"debug\", skip(fcx))]\n fn check_method_receiver<'fcx, 'tcx>(\n     fcx: &FnCtxt<'fcx, 'tcx>,\n     fn_sig: &hir::FnSig<'_>,"}, {"sha": "93c3b3937cb814f060d4cc0a4dc0698f47b8cf1e", "filename": "src/test/ui/generic-associated-types/issue-87748.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/59ce76548484806ac4970c57c0bb6ad9e53b80f6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87748.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ce76548484806ac4970c57c0bb6ad9e53b80f6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87748.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87748.rs?ref=59ce76548484806ac4970c57c0bb6ad9e53b80f6", "patch": "@@ -0,0 +1,30 @@\n+// Checks that we properly add implied bounds from unnormalized projections in\n+// inputs when typechecking functions.\n+\n+// check-pass\n+\n+#![feature(generic_associated_types)]\n+\n+trait MyTrait {\n+    type Assoc<'a, 'b> where 'b: 'a;\n+    fn do_sth(arg: Self::Assoc<'_, '_>);\n+}\n+\n+struct A;\n+struct B;\n+struct C;\n+\n+impl MyTrait for A {\n+    type Assoc<'a, 'b> where 'b: 'a = u32;\n+    fn do_sth(_: u32) {}\n+}\n+impl MyTrait for B {\n+    type Assoc<'a, 'b> where 'b: 'a = u32;\n+    fn do_sth(_: Self::Assoc<'_, '_>) {}\n+}\n+impl MyTrait for C {\n+    type Assoc<'a, 'b> where 'b: 'a = u32;\n+    fn do_sth(_: Self::Assoc<'static, 'static>) {}\n+}\n+\n+fn main () {}"}]}