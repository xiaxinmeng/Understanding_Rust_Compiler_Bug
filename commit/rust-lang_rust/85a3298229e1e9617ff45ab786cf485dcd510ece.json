{"sha": "85a3298229e1e9617ff45ab786cf485dcd510ece", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YTMyOTgyMjllMWU5NjE3ZmY0NWFiNzg2Y2Y0ODVkY2Q1MTBlY2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-19T18:37:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-22T03:31:52Z"}, "message": "unify size_of, align_of into one call (metrics)\n\ncreate some new (xfail'd) tests looking at tag variant alignment", "tree": {"sha": "55674e83512f1673bcf2c774e11ff54703ca4f3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55674e83512f1673bcf2c774e11ff54703ca4f3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85a3298229e1e9617ff45ab786cf485dcd510ece", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85a3298229e1e9617ff45ab786cf485dcd510ece", "html_url": "https://github.com/rust-lang/rust/commit/85a3298229e1e9617ff45ab786cf485dcd510ece", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85a3298229e1e9617ff45ab786cf485dcd510ece/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd1056df78d8936cfa732556bfaab8caf6d80c1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd1056df78d8936cfa732556bfaab8caf6d80c1c", "html_url": "https://github.com/rust-lang/rust/commit/cd1056df78d8936cfa732556bfaab8caf6d80c1c"}], "stats": {"total": 578, "additions": 474, "deletions": 104}, "files": [{"sha": "27630bb4adae915d448a831c63f557d6f3f347ad", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 97, "deletions": 102, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/85a3298229e1e9617ff45ab786cf485dcd510ece/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a3298229e1e9617ff45ab786cf485dcd510ece/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=85a3298229e1e9617ff45ab786cf485dcd510ece", "patch": "@@ -238,19 +238,24 @@ fn compute_static_tag_size(ccx: @crate_ctxt, largest_variants: [uint],\n     ret {size: max_size, align: max_align};\n }\n \n-enum tag_kind { tk_unit, tk_enum, tk_complex, }\n+enum tag_kind {\n+    tk_unit,    // 1 variant, no data\n+    tk_enum,    // N variants, no data\n+    tk_newtype, // 1 variant, data\n+    tk_complex  // N variants, no data\n+}\n \n fn tag_kind(ccx: @crate_ctxt, did: ast::def_id) -> tag_kind {\n     let variants = ty::tag_variants(ccx.tcx, did);\n-    if vec::len(*variants) == 0u { ret tk_complex; }\n-    for v: ty::variant_info in *variants {\n-        if vec::len(v.args) > 0u { ret tk_complex; }\n+    if vec::any(*variants) {|v| vec::len(v.args) > 0u} {\n+        if vec::len(*variants) == 1u { tk_newtype }\n+        else { tk_complex }\n+    } else {\n+        if vec::len(*variants) <= 1u { tk_unit }\n+        else { tk_enum }\n     }\n-    if vec::len(*variants) == 1u { ret tk_unit; }\n-    ret tk_enum;\n }\n \n-\n // Returns the code corresponding to the pointer size on this architecture.\n fn s_int(tcx: ty_ctxt) -> u8 {\n     ret alt tcx.sess.targ_cfg.arch {\n@@ -351,7 +356,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n             s += [s_variant_tag_t(ccx.tcx)];\n           }\n           tk_enum { s += [s_variant_tag_t(ccx.tcx)]; }\n-          tk_complex {\n+          tk_newtype | tk_complex {\n             s += [shape_tag];\n \n             let sub = [];\n@@ -607,20 +612,47 @@ fn gen_shape_tables(ccx: @crate_ctxt) {\n // ______________________________________________________________________\n // compute sizeof / alignof\n \n-fn size_of(cx: @block_ctxt, t: ty::t) -> result {\n-    let ccx = bcx_ccx(cx);\n+type metrics = {\n+    bcx: @block_ctxt,\n+    sz: ValueRef,\n+    align: ValueRef\n+};\n+\n+type tag_metrics = {\n+    bcx: @block_ctxt,\n+    sz: ValueRef,\n+    align: ValueRef,\n+    payload_align: ValueRef\n+};\n+\n+fn size_of(bcx: @block_ctxt, t: ty::t) -> result {\n+    let ccx = bcx_ccx(bcx);\n+    if check type_has_static_size(ccx, t) {\n+        rslt(bcx, llsize_of(ccx, trans::type_of(ccx, bcx.sp, t)))\n+    } else {\n+        let { bcx, sz, align: _ } = dynamic_metrics(bcx, t);\n+        rslt(bcx, sz)\n+    }\n+}\n+\n+fn align_of(bcx: @block_ctxt, t: ty::t) -> result {\n+    let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n-        let sp = cx.sp;\n-        rslt(cx, llsize_of(bcx_ccx(cx), trans::type_of(ccx, sp, t)))\n-    } else { dynamic_size_of(cx, t) }\n+        rslt(bcx, llalign_of(ccx, trans::type_of(ccx, bcx.sp, t)))\n+    } else {\n+        let { bcx, sz: _, align } = dynamic_metrics(bcx, t);\n+        rslt(bcx, align)\n+    }\n }\n \n-fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n-    let ccx = bcx_ccx(cx);\n+fn metrics(bcx: @block_ctxt, t: ty::t) -> metrics {\n+    let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n-        let sp = cx.sp;\n-        rslt(cx, llalign_of(bcx_ccx(cx), trans::type_of(ccx, sp, t)))\n-    } else { dynamic_align_of(cx, t) }\n+        let llty = trans::type_of(ccx, bcx.sp, t);\n+        { bcx: bcx, sz: llsize_of(ccx, llty), align: llalign_of(ccx, llty) }\n+    } else {\n+        dynamic_metrics(bcx, t)\n+    }\n }\n \n // Returns the real size of the given type for the current target.\n@@ -676,8 +708,8 @@ fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n     }\n }\n \n-fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n-    fn align_elements(cx: @block_ctxt, elts: [ty::t]) -> result {\n+fn dynamic_metrics(cx: @block_ctxt, t: ty::t) -> metrics {\n+    fn align_elements(cx: @block_ctxt, elts: [ty::t]) -> metrics {\n         //\n         // C padding rules:\n         //\n@@ -700,110 +732,62 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n             max_align = umax(bcx, max_align, elt_align.val);\n         }\n         off = align_to(bcx, off, max_align);\n-        //off = alt mode {\n-        //  align_total. {\n-        //    align_to(bcx, off, max_align)\n-        //  }\n-        //  align_next(t) {\n-        //    let {bcx, val: align} = align_of(bcx, t);\n-        //    align_to(bcx, off, align)\n-        //  }\n-        //};\n-        ret rslt(bcx, off);\n+        ret { bcx: bcx, sz: off, align: max_align };\n     }\n+\n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_param(p, _) {\n-        let szptr = field_of_tydesc(cx, t, false, abi::tydesc_field_size);\n-        ret rslt(szptr.bcx, Load(szptr.bcx, szptr.val));\n+        let ti = none::<@tydesc_info>;\n+        let {bcx, val: tydesc} = trans::get_tydesc(cx, t, false, ti).result;\n+        let szptr = GEPi(bcx, tydesc, [0, abi::tydesc_field_size]);\n+        let aptr = GEPi(bcx, tydesc, [0, abi::tydesc_field_align]);\n+        {bcx: bcx, sz: Load(bcx, szptr), align: Load(bcx, aptr)}\n       }\n       ty::ty_rec(flds) {\n         let tys: [ty::t] = [];\n         for f: ty::field in flds { tys += [f.mt.ty]; }\n-        ret align_elements(cx, tys);\n+        align_elements(cx, tys)\n       }\n       ty::ty_tup(elts) {\n         let tys = [];\n         for tp in elts { tys += [tp]; }\n-        ret align_elements(cx, tys);\n+        align_elements(cx, tys)\n       }\n       ty::ty_tag(tid, tps) {\n         let bcx = cx;\n         let ccx = bcx_ccx(bcx);\n-        // Compute max(variant sizes).\n-\n-        let max_size: ValueRef = trans::alloca(bcx, ccx.int_type);\n-        Store(bcx, C_int(ccx, 0), max_size);\n-        let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n-        for variant: ty::variant_info in *variants {\n-            // Perform type substitution on the raw argument types.\n \n-            let raw_tys: [ty::t] = variant.args;\n-            let tys: [ty::t] = [];\n-            for raw_ty: ty::t in raw_tys {\n-                let t = ty::substitute_type_params(bcx_tcx(cx), tps, raw_ty);\n-                tys += [t];\n+        let compute_max_variant_size = fn@(bcx: @block_ctxt) -> result {\n+            // Compute max(variant sizes).\n+            let bcx = bcx;\n+            let max_size: ValueRef = C_int(ccx, 0);\n+            let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n+            for variant: ty::variant_info in *variants {\n+                // Perform type substitution on the raw argument types.\n+                let tys = vec::map(variant.args) {|raw_ty|\n+                    ty::substitute_type_params(bcx_tcx(cx), tps, raw_ty)\n+                };\n+                let rslt = align_elements(bcx, tys);\n+                bcx = rslt.bcx;\n+                max_size = umax(bcx, rslt.sz, max_size);\n             }\n-            let rslt = align_elements(bcx, tys);\n-            bcx = rslt.bcx;\n-            let this_size = rslt.val;\n-            let old_max_size = Load(bcx, max_size);\n-            Store(bcx, umax(bcx, this_size, old_max_size), max_size);\n-        }\n-        let max_size_val = Load(bcx, max_size);\n-        let total_size =\n-            if vec::len(*variants) != 1u {\n-                Add(bcx, max_size_val, llsize_of(ccx, ccx.int_type))\n-            } else { max_size_val };\n-        ret rslt(bcx, total_size);\n-      }\n-    }\n-}\n+            rslt(bcx, max_size)\n+        };\n \n-fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n-// FIXME: Typestate constraint that shows this alt is\n-// exhaustive\n-    alt ty::struct(bcx_tcx(cx), t) {\n-      ty::ty_param(p, _) {\n-        let aptr = field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n-        ret rslt(aptr.bcx, Load(aptr.bcx, aptr.val));\n-      }\n-      ty::ty_rec(flds) {\n-        let a = C_int(bcx_ccx(cx), 1);\n-        let bcx = cx;\n-        for f: ty::field in flds {\n-            let align = align_of(bcx, f.mt.ty);\n-            bcx = align.bcx;\n-            a = umax(bcx, a, align.val);\n-        }\n-        ret rslt(bcx, a);\n-      }\n-      ty::ty_tag(_, _) {\n-        ret rslt(cx, C_int(bcx_ccx(cx), 1)); // FIXME: stub\n-      }\n-      ty::ty_tup(elts) {\n-        let a = C_int(bcx_ccx(cx), 1);\n-        let bcx = cx;\n-        for e in elts {\n-            let align = align_of(bcx, e);\n-            bcx = align.bcx;\n-            a = umax(bcx, a, align.val);\n-        }\n-        ret rslt(bcx, a);\n+        let {bcx, val: sz} = alt tag_kind(ccx, tid) {\n+          tk_unit | tk_enum { rslt(bcx, llsize_of(ccx, T_tag_variant(ccx))) }\n+          tk_newtype { compute_max_variant_size(bcx) }\n+          tk_complex {\n+            let {bcx, val} = compute_max_variant_size(bcx);\n+            rslt(bcx, Add(bcx, val, llsize_of(ccx, T_tag_variant(ccx))))\n+          }\n+        };\n+\n+        { bcx: bcx, sz: sz, align: C_int(ccx, 1) }\n       }\n     }\n }\n \n-// Given a type and a field index into its corresponding type descriptor,\n-// returns an LLVM ValueRef of that field from the tydesc, generating the\n-// tydesc if necessary.\n-fn field_of_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool, field: int) ->\n-   result {\n-    let ti = none::<@tydesc_info>;\n-    let tydesc = trans::get_tydesc(cx, t, escapes, ti).result;\n-    ret rslt(tydesc.bcx,\n-             GEPi(tydesc.bcx, tydesc.val, [0, field]));\n-}\n-\n // Creates a simpler, size-equivalent type. The resulting type is guaranteed\n // to have (a) the same size as the type that was passed in; (b) to be non-\n // recursive. This is done by replacing all boxes in a type with boxed unit\n@@ -832,3 +816,14 @@ fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n     }\n     ret ty::fold_ty(ccx.tcx, ty::fm_general(bind simplifier(ccx, _)), typ);\n }\n+\n+// Given a tag type `ty`, returns the offset of the payload.\n+//fn tag_payload_offs(bcx: @block_ctxt, tag_id: ast::def_id, tps: [ty::t])\n+//    -> ValueRef {\n+//    alt tag_kind(tag_id) {\n+//      tk_unit | tk_enum | tk_newtype { C_int(bcx_ccx(bcx), 0) }\n+//      tk_complex {\n+//        compute_tag_metrics(tag_id, tps)\n+//      }\n+//    }\n+//}"}, {"sha": "8919237b68863b0567e64dd1170f6bba63724019", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 249, "deletions": 2, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/85a3298229e1e9617ff45ab786cf485dcd510ece/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a3298229e1e9617ff45ab786cf485dcd510ece/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=85a3298229e1e9617ff45ab786cf485dcd510ece", "patch": "@@ -41,8 +41,6 @@ import link::{mangle_internal_name_by_type_only,\n               mangle_exported_name};\n import metadata::{csearch, cstore};\n import util::ppaux::{ty_to_str, ty_to_short_str};\n-import shape::{size_of, align_of, llsize_of_real, llalign_of_real,\n-               llsize_of, llalign_of, static_size_of_tag};\n \n import trans_common::*;\n import trans_build::*;\n@@ -376,6 +374,63 @@ fn trans_shared_free(cx: @block_ctxt, v: ValueRef) -> @block_ctxt {\n     ret cx;\n }\n \n+fn umax(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n+    let cond = ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n+    ret Select(cx, cond, b, a);\n+}\n+\n+fn umin(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n+    let cond = ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n+    ret Select(cx, cond, a, b);\n+}\n+\n+fn align_to(cx: @block_ctxt, off: ValueRef, align: ValueRef) -> ValueRef {\n+    let mask = Sub(cx, align, C_int(bcx_ccx(cx), 1));\n+    let bumped = Add(cx, off, mask);\n+    ret And(cx, bumped, Not(cx, mask));\n+}\n+\n+\n+// Returns the real size of the given type for the current target.\n+fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n+    ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n+}\n+\n+// Returns the real alignment of the given type for the current target.\n+fn llalign_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n+    ret llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n+}\n+\n+fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n+                               False);\n+}\n+\n+fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMAlignOf(t), cx.int_type,\n+                               False);\n+}\n+\n+fn size_of(cx: @block_ctxt, t: ty::t) -> result {\n+    size_of_(cx, t)\n+}\n+\n+fn size_of_(cx: @block_ctxt, t: ty::t) -> result {\n+    let ccx = bcx_ccx(cx);\n+    if check type_has_static_size(ccx, t) {\n+        let sp = cx.sp;\n+        rslt(cx, llsize_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n+    } else { dynamic_size_of(cx, t) }\n+}\n+\n+fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n+    let ccx = bcx_ccx(cx);\n+    if check type_has_static_size(ccx, t) {\n+        let sp = cx.sp;\n+        rslt(cx, llalign_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n+    } else { dynamic_align_of(cx, t) }\n+}\n+\n fn alloca(cx: @block_ctxt, t: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n     ret Alloca(new_raw_block_ctxt(cx.fcx, cx.fcx.llstaticallocas), t);\n@@ -412,6 +467,187 @@ fn mk_obstack_token(ccx: @crate_ctxt, fcx: @fn_ctxt) ->\n     ret Call(cx, ccx.upcalls.dynastack_mark, []);\n }\n \n+\n+// Creates a simpler, size-equivalent type. The resulting type is guaranteed\n+// to have (a) the same size as the type that was passed in; (b) to be non-\n+// recursive. This is done by replacing all boxes in a type with boxed unit\n+// types.\n+fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n+    fn simplifier(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n+        alt ty::struct(ccx.tcx, typ) {\n+          ty::ty_box(_) | ty::ty_iface(_, _) {\n+            ret ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx));\n+          }\n+          ty::ty_uniq(_) {\n+            ret ty::mk_imm_uniq(ccx.tcx, ty::mk_nil(ccx.tcx));\n+          }\n+          ty::ty_fn(_) {\n+            ret ty::mk_tup(ccx.tcx,\n+                           [ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)),\n+                            ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx))]);\n+          }\n+          ty::ty_res(_, sub, tps) {\n+            let sub1 = ty::substitute_type_params(ccx.tcx, tps, sub);\n+            ret ty::mk_tup(ccx.tcx,\n+                           [ty::mk_int(ccx.tcx), simplify_type(ccx, sub1)]);\n+          }\n+          _ { ret typ; }\n+        }\n+    }\n+    ret ty::fold_ty(ccx.tcx, ty::fm_general(bind simplifier(ccx, _)), typ);\n+}\n+\n+\n+// Computes the size of the data part of a non-dynamically-sized tag.\n+fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n+    : type_has_static_size(cx, t) -> uint {\n+    if cx.tag_sizes.contains_key(t) { ret cx.tag_sizes.get(t); }\n+    alt ty::struct(cx.tcx, t) {\n+      ty::ty_tag(tid, subtys) {\n+        // Compute max(variant sizes).\n+\n+        let max_size = 0u;\n+        let variants = ty::tag_variants(cx.tcx, tid);\n+        for variant: ty::variant_info in *variants {\n+            let tup_ty = simplify_type(cx, ty::mk_tup(cx.tcx, variant.args));\n+            // Perform any type parameter substitutions.\n+\n+            tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n+            // Here we possibly do a recursive call.\n+\n+            // FIXME: Avoid this check. Since the parent has static\n+            // size, any field must as well. There should be a way to\n+            // express that with constrained types.\n+            check (type_has_static_size(cx, tup_ty));\n+            let this_size = llsize_of_real(cx, type_of(cx, sp, tup_ty));\n+            if max_size < this_size { max_size = this_size; }\n+        }\n+        cx.tag_sizes.insert(t, max_size);\n+        ret max_size;\n+      }\n+      _ {\n+        cx.tcx.sess.span_fatal(sp, \"non-tag passed to static_size_of_tag()\");\n+      }\n+    }\n+}\n+\n+fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n+    fn align_elements(cx: @block_ctxt, elts: [ty::t]) -> result {\n+        //\n+        // C padding rules:\n+        //\n+        //\n+        //   - Pad after each element so that next element is aligned.\n+        //   - Pad after final structure member so that whole structure\n+        //     is aligned to max alignment of interior.\n+        //\n+\n+        let off = C_int(bcx_ccx(cx), 0);\n+        let max_align = C_int(bcx_ccx(cx), 1);\n+        let bcx = cx;\n+        for e: ty::t in elts {\n+            let elt_align = align_of(bcx, e);\n+            bcx = elt_align.bcx;\n+            let elt_size = size_of(bcx, e);\n+            bcx = elt_size.bcx;\n+            let aligned_off = align_to(bcx, off, elt_align.val);\n+            off = Add(bcx, aligned_off, elt_size.val);\n+            max_align = umax(bcx, max_align, elt_align.val);\n+        }\n+        off = align_to(bcx, off, max_align);\n+        //off = alt mode {\n+        //  align_total. {\n+        //    align_to(bcx, off, max_align)\n+        //  }\n+        //  align_next(t) {\n+        //    let {bcx, val: align} = align_of(bcx, t);\n+        //    align_to(bcx, off, align)\n+        //  }\n+        //};\n+        ret rslt(bcx, off);\n+    }\n+    alt ty::struct(bcx_tcx(cx), t) {\n+      ty::ty_param(p, _) {\n+        let szptr = field_of_tydesc(cx, t, false, abi::tydesc_field_size);\n+        ret rslt(szptr.bcx, Load(szptr.bcx, szptr.val));\n+      }\n+      ty::ty_rec(flds) {\n+        let tys: [ty::t] = [];\n+        for f: ty::field in flds { tys += [f.mt.ty]; }\n+        ret align_elements(cx, tys);\n+      }\n+      ty::ty_tup(elts) {\n+        let tys = [];\n+        for tp in elts { tys += [tp]; }\n+        ret align_elements(cx, tys);\n+      }\n+      ty::ty_tag(tid, tps) {\n+        let bcx = cx;\n+        let ccx = bcx_ccx(bcx);\n+        // Compute max(variant sizes).\n+\n+        let max_size: ValueRef = alloca(bcx, ccx.int_type);\n+        Store(bcx, C_int(ccx, 0), max_size);\n+        let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n+        for variant: ty::variant_info in *variants {\n+            // Perform type substitution on the raw argument types.\n+\n+            let raw_tys: [ty::t] = variant.args;\n+            let tys: [ty::t] = [];\n+            for raw_ty: ty::t in raw_tys {\n+                let t = ty::substitute_type_params(bcx_tcx(cx), tps, raw_ty);\n+                tys += [t];\n+            }\n+            let rslt = align_elements(bcx, tys);\n+            bcx = rslt.bcx;\n+            let this_size = rslt.val;\n+            let old_max_size = Load(bcx, max_size);\n+            Store(bcx, umax(bcx, this_size, old_max_size), max_size);\n+        }\n+        let max_size_val = Load(bcx, max_size);\n+        let total_size =\n+            if vec::len(*variants) != 1u {\n+                Add(bcx, max_size_val, llsize_of(ccx, ccx.int_type))\n+            } else { max_size_val };\n+        ret rslt(bcx, total_size);\n+      }\n+    }\n+}\n+\n+fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n+// FIXME: Typestate constraint that shows this alt is\n+// exhaustive\n+    alt ty::struct(bcx_tcx(cx), t) {\n+      ty::ty_param(p, _) {\n+        let aptr = field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n+        ret rslt(aptr.bcx, Load(aptr.bcx, aptr.val));\n+      }\n+      ty::ty_rec(flds) {\n+        let a = C_int(bcx_ccx(cx), 1);\n+        let bcx = cx;\n+        for f: ty::field in flds {\n+            let align = align_of(bcx, f.mt.ty);\n+            bcx = align.bcx;\n+            a = umax(bcx, a, align.val);\n+        }\n+        ret rslt(bcx, a);\n+      }\n+      ty::ty_tag(_, _) {\n+        ret rslt(cx, C_int(bcx_ccx(cx), 1)); // FIXME: stub\n+      }\n+      ty::ty_tup(elts) {\n+        let a = C_int(bcx_ccx(cx), 1);\n+        let bcx = cx;\n+        for e in elts {\n+            let align = align_of(bcx, e);\n+            bcx = align.bcx;\n+            a = umax(bcx, a, align.val);\n+        }\n+        ret rslt(bcx, a);\n+      }\n+    }\n+}\n+\n // Given a pointer p, returns a pointer sz(p) (i.e., inc'd by sz bytes).\n // The type of the returned pointer is always i8*.  If you care about the\n // return type, use bump_ptr().\n@@ -622,6 +858,17 @@ fn trans_malloc_boxed(cx: @block_ctxt, t: ty::t) ->\n \n // Type descriptor and type glue stuff\n \n+// Given a type and a field index into its corresponding type descriptor,\n+// returns an LLVM ValueRef of that field from the tydesc, generating the\n+// tydesc if necessary.\n+fn field_of_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool, field: int) ->\n+   result {\n+    let ti = none::<@tydesc_info>;\n+    let tydesc = get_tydesc(cx, t, escapes, ti).result;\n+    ret rslt(tydesc.bcx,\n+             GEPi(tydesc.bcx, tydesc.val, [0, field]));\n+}\n+\n // Given a type containing ty params, build a vector containing a ValueRef for\n // each of the ty params it uses (from the current frame) and a vector of the\n // indices of the ty params present in the type. This is used solely for"}, {"sha": "18f612b19ad11cf499e3752f456c71f001d1763f", "filename": "src/test/run-pass/tag-align-dyn-u64.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/85a3298229e1e9617ff45ab786cf485dcd510ece/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a3298229e1e9617ff45ab786cf485dcd510ece/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs?ref=85a3298229e1e9617ff45ab786cf485dcd510ece", "patch": "@@ -0,0 +1,24 @@\n+// xfail-test\n+\n+tag a_tag<A> {\n+    a_tag(A);\n+}\n+\n+type t_rec = {\n+    c8: u8,\n+    t: a_tag<u64>\n+};\n+\n+fn mk_rec() -> t_rec {\n+    ret { c8:0u8, t:a_tag(0u64) };\n+}\n+\n+fn is_8_byte_aligned(&&u: a_tag<u64>) -> bool {\n+    let p = ptr::addr_of(u) as uint;\n+    ret (p & 7u) == 0u;\n+}\n+\n+fn main() {\n+    let x = mk_rec();\n+    assert is_8_byte_aligned(x.t);\n+}"}, {"sha": "10ea8f80b65b3042603bbf239b85341b0d3378a6", "filename": "src/test/run-pass/tag-align-dyn-variants.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/85a3298229e1e9617ff45ab786cf485dcd510ece/src%2Ftest%2Frun-pass%2Ftag-align-dyn-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a3298229e1e9617ff45ab786cf485dcd510ece/src%2Ftest%2Frun-pass%2Ftag-align-dyn-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-dyn-variants.rs?ref=85a3298229e1e9617ff45ab786cf485dcd510ece", "patch": "@@ -0,0 +1,61 @@\n+// xfail-test\n+\n+tag a_tag<A,B> {\n+    varA(A);\n+    varB(B);\n+}\n+\n+type t_rec<A,B> = {\n+    chA: u8,\n+    tA: a_tag<A,B>,\n+    chB: u8,\n+    tB: a_tag<A,B>\n+};\n+\n+fn mk_rec<A:copy,B:copy>(a: A, b: B) -> t_rec<A,B> {\n+    ret { chA:0u8, tA:varA(a), chB:1u8, tB:varB(b) };\n+}\n+\n+fn is_aligned<A>(amnt: uint, &&u: A) -> bool {\n+    let p = ptr::addr_of(u) as uint;\n+    ret (p & (amnt-1u)) == 0u;\n+}\n+\n+fn variant_data_is_aligned<A,B>(amnt: uint, &&u: a_tag<A,B>) -> bool {\n+    alt u {\n+      varA(a) { is_aligned(amnt, a) }\n+      varB(b) { is_aligned(amnt, b) }\n+    }\n+}\n+\n+fn main() {\n+    let x = mk_rec(22u64, 23u64);\n+    assert is_aligned(8u, x.tA);\n+    assert variant_data_is_aligned(8u, x.tA);\n+    assert is_aligned(8u, x.tB);\n+    assert variant_data_is_aligned(8u, x.tB);\n+\n+    let x = mk_rec(22u64, 23u32);\n+    assert is_aligned(8u, x.tA);\n+    assert variant_data_is_aligned(8u, x.tA);\n+    assert is_aligned(8u, x.tB);\n+    assert variant_data_is_aligned(4u, x.tB);\n+\n+    let x = mk_rec(22u32, 23u64);\n+    assert is_aligned(8u, x.tA);\n+    assert variant_data_is_aligned(4u, x.tA);\n+    assert is_aligned(8u, x.tB);\n+    assert variant_data_is_aligned(8u, x.tB);\n+\n+    let x = mk_rec(22u32, 23u32);\n+    assert is_aligned(4u, x.tA);\n+    assert variant_data_is_aligned(4u, x.tA);\n+    assert is_aligned(4u, x.tB);\n+    assert variant_data_is_aligned(4u, x.tB);\n+\n+    let x = mk_rec(22f64, 23f64);\n+    assert is_aligned(8u, x.tA);\n+    assert variant_data_is_aligned(8u, x.tA);\n+    assert is_aligned(8u, x.tB);\n+    assert variant_data_is_aligned(8u, x.tB);\n+}"}, {"sha": "18084aecab2543b269356691c3f651cb7bcc97a0", "filename": "src/test/run-pass/tag-align-shape.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/85a3298229e1e9617ff45ab786cf485dcd510ece/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a3298229e1e9617ff45ab786cf485dcd510ece/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs?ref=85a3298229e1e9617ff45ab786cf485dcd510ece", "patch": "@@ -0,0 +1,19 @@\n+// xfail-test\n+//\n+// See issue #1535\n+\n+tag a_tag {\n+    a_tag(u64);\n+}\n+\n+type t_rec = {\n+    c8: u8,\n+    t: a_tag\n+};\n+\n+fn main() {\n+    let x = {c8: 22u8, t: a_tag(44u64)};\n+    let y = #fmt[\"%?\", x];\n+    #debug[\"y = %s\", y];\n+    assert y == \"(22, a_tag(44))\";\n+}"}, {"sha": "f0df400cf19a9aa1cddfe62bae012a52ec695417", "filename": "src/test/run-pass/tag-align-u64.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/85a3298229e1e9617ff45ab786cf485dcd510ece/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a3298229e1e9617ff45ab786cf485dcd510ece/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs?ref=85a3298229e1e9617ff45ab786cf485dcd510ece", "patch": "@@ -0,0 +1,24 @@\n+// xfail-test\n+\n+tag a_tag {\n+    a_tag(u64);\n+}\n+\n+type t_rec = {\n+    c8: u8,\n+    t: a_tag\n+};\n+\n+fn mk_rec() -> t_rec {\n+    ret { c8:0u8, t:a_tag(0u64) };\n+}\n+\n+fn is_8_byte_aligned(&&u: a_tag) -> bool {\n+    let p = ptr::addr_of(u) as u64;\n+    ret (p & 7u64) == 0u64;\n+}\n+\n+fn main() {\n+    let x = mk_rec();\n+    assert is_8_byte_aligned(x.t);\n+}"}]}