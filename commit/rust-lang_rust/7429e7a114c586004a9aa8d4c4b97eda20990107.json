{"sha": "7429e7a114c586004a9aa8d4c4b97eda20990107", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MjllN2ExMTRjNTg2MDA0YTlhYThkNGM0Yjk3ZWRhMjA5OTAxMDc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-09T15:29:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-11T18:37:45Z"}, "message": "rustc: Add new graph library, based on code from region_infernece", "tree": {"sha": "4854848c1bd95e87dbcda1b667bf3197e927e873", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4854848c1bd95e87dbcda1b667bf3197e927e873"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7429e7a114c586004a9aa8d4c4b97eda20990107", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7429e7a114c586004a9aa8d4c4b97eda20990107", "html_url": "https://github.com/rust-lang/rust/commit/7429e7a114c586004a9aa8d4c4b97eda20990107", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7429e7a114c586004a9aa8d4c4b97eda20990107/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "278ed50e0a66f4c549e43c82e4a545890091e9ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/278ed50e0a66f4c549e43c82e4a545890091e9ba", "html_url": "https://github.com/rust-lang/rust/commit/278ed50e0a66f4c549e43c82e4a545890091e9ba"}], "stats": {"total": 412, "additions": 412, "deletions": 0}, "files": [{"sha": "804dc88746ca4cdb16402e180eba6c862847fb22", "filename": "src/librustc/middle/graph.rs", "status": "added", "additions": 411, "deletions": 0, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/7429e7a114c586004a9aa8d4c4b97eda20990107/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7429e7a114c586004a9aa8d4c4b97eda20990107/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=7429e7a114c586004a9aa8d4c4b97eda20990107", "patch": "@@ -0,0 +1,411 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+A graph module for use in dataflow, region resolution, and elsewhere.\n+\n+# Interface details\n+\n+You customize the graph by specifying a \"node data\" type `N` and an\n+\"edge data\" type `E`. You can then later gain access (mutable or\n+immutable) to these \"user-data\" bits. Currently, you can only add\n+nodes or edges to the graph. You cannot remove or modify them once\n+added. This could be changed if we have a need.\n+\n+# Implementation details\n+\n+The main tricky thing about this code is the way that edges are\n+stored. The edges are stored in a central array, but they are also\n+threaded onto two linked lists for each node, one for incoming edges\n+and one for outgoing edges. Note that every edge is a member of some\n+incoming list and some outgoing list.  Basically you can load the\n+first index of the linked list from the node data structures (the\n+field `first_edge`) and then, for each edge, load the next index from\n+the field `next_edge`). Each of those fields is an array that should\n+be indexed by the direction (see the type `Direction`).\n+\n+*/\n+\n+use std::prelude::*;\n+use std::uint;\n+use std::vec;\n+\n+pub struct Graph<N,E> {\n+    priv nodes: ~[Node<N>],\n+    priv edges: ~[Edge<E>],\n+}\n+\n+pub struct Node<N> {\n+    priv first_edge: [EdgeIndex, ..2], // see module comment\n+    data: N,\n+}\n+\n+pub struct Edge<E> {\n+    priv next_edge: [EdgeIndex, ..2], // see module comment\n+    priv source: NodeIndex,\n+    priv target: NodeIndex,\n+    data: E,\n+}\n+\n+#[deriving(Eq)]\n+pub struct NodeIndex(uint);\n+pub static InvalidNodeIndex: NodeIndex = NodeIndex(uint::max_value);\n+\n+#[deriving(Eq)]\n+pub struct EdgeIndex(uint);\n+pub static InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::max_value);\n+\n+// Use a private field here to guarantee no more instances are created:\n+pub struct Direction { priv repr: uint }\n+pub static Outgoing: Direction = Direction { repr: 0 };\n+pub static Incoming: Direction = Direction { repr: 1 };\n+\n+impl<N,E> Graph<N,E> {\n+    pub fn new() -> Graph<N,E> {\n+        Graph {nodes: ~[], edges: ~[]}\n+    }\n+\n+    pub fn with_capacity(num_nodes: uint,\n+                         num_edges: uint) -> Graph<N,E> {\n+        Graph {nodes: vec::with_capacity(num_nodes),\n+               edges: vec::with_capacity(num_edges)}\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Simple accessors\n+\n+    #[inline]\n+    pub fn all_nodes<'a>(&'a self) -> &'a [Node<N>] {\n+        let nodes: &'a [Node<N>] = self.nodes;\n+        nodes\n+    }\n+\n+    #[inline]\n+    pub fn all_edges<'a>(&'a self) -> &'a [Edge<E>] {\n+        let edges: &'a [Edge<E>] = self.edges;\n+        edges\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Node construction\n+\n+    pub fn next_node_index(&self) -> NodeIndex {\n+        NodeIndex(self.nodes.len())\n+    }\n+\n+    pub fn add_node(&mut self, data: N) -> NodeIndex {\n+        let idx = self.next_node_index();\n+        self.nodes.push(Node {\n+            first_edge: [InvalidEdgeIndex, InvalidEdgeIndex],\n+            data: data\n+        });\n+        idx\n+    }\n+\n+    pub fn mut_node_data<'a>(&'a mut self, idx: NodeIndex) -> &'a mut N {\n+        &mut self.nodes[*idx].data\n+    }\n+\n+    pub fn node_data<'a>(&'a self, idx: NodeIndex) -> &'a N {\n+        &self.nodes[*idx].data\n+    }\n+\n+    pub fn node<'a>(&'a self, idx: NodeIndex) -> &'a Node<N> {\n+        &self.nodes[*idx]\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Edge construction and queries\n+\n+    pub fn next_edge_index(&self) -> EdgeIndex {\n+        EdgeIndex(self.edges.len())\n+    }\n+\n+    pub fn add_edge(&mut self,\n+                    source: NodeIndex,\n+                    target: NodeIndex,\n+                    data: E) -> EdgeIndex {\n+        let idx = self.next_edge_index();\n+\n+        // read current first of the list of edges from each node\n+        let source_first = self.nodes[*source].first_edge[Outgoing.repr];\n+        let target_first = self.nodes[*target].first_edge[Incoming.repr];\n+\n+        // create the new edge, with the previous firsts from each node\n+        // as the next pointers\n+        self.edges.push(Edge {\n+            next_edge: [source_first, target_first],\n+            source: source,\n+            target: target,\n+            data: data\n+        });\n+\n+        // adjust the firsts for each node target be the next object.\n+        self.nodes[*source].first_edge[Outgoing.repr] = idx;\n+        self.nodes[*target].first_edge[Incoming.repr] = idx;\n+\n+        return idx;\n+    }\n+\n+    pub fn mut_edge_data<'a>(&'a mut self, idx: EdgeIndex) -> &'a mut E {\n+        &mut self.edges[*idx].data\n+    }\n+\n+    pub fn edge_data<'a>(&'a self, idx: EdgeIndex) -> &'a E {\n+        &self.edges[*idx].data\n+    }\n+\n+    pub fn edge<'a>(&'a self, idx: EdgeIndex) -> &'a Edge<E> {\n+        &self.edges[*idx]\n+    }\n+\n+    pub fn first_adjacent(&self, node: NodeIndex, dir: Direction) -> EdgeIndex {\n+        //! Accesses the index of the first edge adjacent to `node`.\n+        //! This is useful if you wish to modify the graph while walking\n+        //! the linked list of edges.\n+\n+        self.nodes[*node].first_edge[dir.repr]\n+    }\n+\n+    pub fn next_adjacent(&self, edge: EdgeIndex, dir: Direction) -> EdgeIndex {\n+        //! Accesses the next edge in a given direction.\n+        //! This is useful if you wish to modify the graph while walking\n+        //! the linked list of edges.\n+\n+        self.edges[*edge].next_edge[dir.repr]\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Iterating over nodes, edges\n+\n+    pub fn each_node(&self, f: &fn(NodeIndex, &Node<N>) -> bool) -> bool {\n+        //! Iterates over all edges defined in the graph.\n+\n+        uint::range(0, self.nodes.len(),\n+                    |i| f(NodeIndex(i), &self.nodes[i]))\n+    }\n+\n+    pub fn each_edge(&self, f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+        //! Iterates over all edges defined in the graph.\n+\n+        uint::range(0, self.nodes.len(),\n+                    |i| f(EdgeIndex(i), &self.edges[i]))\n+    }\n+\n+    pub fn each_outgoing_edge(&self,\n+                              source: NodeIndex,\n+                              f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+        //! Iterates over all outgoing edges from the node `from`\n+\n+        self.each_adjacent_edge(source, Outgoing, f)\n+    }\n+\n+    pub fn each_incoming_edge(&self,\n+                              target: NodeIndex,\n+                              f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+        //! Iterates over all incoming edges to the node `target`\n+\n+        self.each_adjacent_edge(target, Incoming, f)\n+    }\n+\n+    pub fn each_adjacent_edge(&self,\n+                              node: NodeIndex,\n+                              dir: Direction,\n+                              f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+        //! Iterates over all edges adjacent to the node `node`\n+        //! in the direction `dir` (either `Outgoing` or `Incoming)\n+\n+        let mut edge_idx = self.first_adjacent(node, dir);\n+        while edge_idx != InvalidEdgeIndex {\n+            let edge = &self.edges[*edge_idx];\n+            if !f(edge_idx, edge) {\n+                return false;\n+            }\n+            edge_idx = edge.next_edge[dir.repr];\n+        }\n+        return true;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Fixed-point iteration\n+    //\n+    // A common use for graphs in our compiler is to perform\n+    // fixed-point iteration. In this case, each edge represents a\n+    // constaint, and the nodes themselves are associated with\n+    // variables or other bitsets. This method facilitates such a\n+    // computation.\n+\n+    pub fn iterate_until_fixed_point(&self,\n+                                     op: &fn(iter_index: uint,\n+                                             edge_index: EdgeIndex,\n+                                             edge: &Edge<E>) -> bool) {\n+        let mut iteration = 0;\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+            iteration += 1;\n+            for self.edges.iter().enumerate().advance |(i, edge)| {\n+                changed |= op(iteration, EdgeIndex(i), edge);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn each_edge_index(max_edge_index: EdgeIndex, f: &fn(EdgeIndex) -> bool) {\n+    let mut i = 0;\n+    let n = *max_edge_index;\n+    while i < n {\n+        if !f(EdgeIndex(i)) {\n+            return;\n+        }\n+        i += 1;\n+    }\n+}\n+\n+impl<E> Edge<E> {\n+    pub fn source(&self) -> NodeIndex {\n+        self.source\n+    }\n+\n+    pub fn target(&self) -> NodeIndex {\n+        self.target\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use middle::graph::*;\n+\n+    type TestNode = Node<&'static str>;\n+    type TestEdge = Edge<&'static str>;\n+    type TestGraph = Graph<&'static str, &'static str>;\n+\n+    fn create_graph() -> TestGraph {\n+        let mut graph = Graph::new();\n+\n+        // Create a simple graph\n+        //\n+        //    A -+> B --> C\n+        //       |  |     ^\n+        //       |  v     |\n+        //       F  D --> E\n+\n+        let a = graph.add_node(\"A\");\n+        let b = graph.add_node(\"B\");\n+        let c = graph.add_node(\"C\");\n+        let d = graph.add_node(\"D\");\n+        let e = graph.add_node(\"E\");\n+        let f = graph.add_node(\"F\");\n+\n+        graph.add_edge(a, b, \"AB\");\n+        graph.add_edge(b, c, \"BC\");\n+        graph.add_edge(b, d, \"BD\");\n+        graph.add_edge(d, e, \"DE\");\n+        graph.add_edge(e, c, \"EC\");\n+        graph.add_edge(f, b, \"FB\");\n+\n+        return graph;\n+    }\n+\n+    #[test]\n+    fn each_node() {\n+        let graph = create_graph();\n+        let expected = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n+        for graph.each_node |idx, node| {\n+            assert_eq!(&expected[*idx], graph.node_data(idx));\n+            assert_eq!(expected[*idx], node.data);\n+        }\n+    }\n+\n+    #[test]\n+    fn each_edge() {\n+        let graph = create_graph();\n+        let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n+        for graph.each_edge |idx, edge| {\n+            assert_eq!(&expected[*idx], graph.edge_data(idx));\n+            assert_eq!(expected[*idx], edge.data);\n+        }\n+    }\n+\n+    fn test_adjacent_edges<N:Eq,E:Eq>(graph: &Graph<N,E>,\n+                                      start_index: NodeIndex,\n+                                      start_data: N,\n+                                      expected_incoming: &[(E,N)],\n+                                      expected_outgoing: &[(E,N)]) {\n+        assert_eq!(graph.node_data(start_index), &start_data);\n+\n+        let mut counter = 0;\n+        for graph.each_incoming_edge(start_index) |edge_index, edge| {\n+            assert_eq!(graph.edge_data(edge_index), &edge.data);\n+            assert!(counter < expected_incoming.len());\n+            debug!(\"counter=%? expected=%? edge_index=%? edge=%?\",\n+                   counter, expected_incoming[counter], edge_index, edge);\n+            match expected_incoming[counter] {\n+                (ref e, ref n) => {\n+                    assert_eq!(e, &edge.data);\n+                    assert_eq!(n, graph.node_data(edge.source));\n+                    assert_eq!(start_index, edge.target);\n+                }\n+            }\n+            counter += 1;\n+        }\n+        assert_eq!(counter, expected_incoming.len());\n+\n+        let mut counter = 0;\n+        for graph.each_outgoing_edge(start_index) |edge_index, edge| {\n+            assert_eq!(graph.edge_data(edge_index), &edge.data);\n+            assert!(counter < expected_outgoing.len());\n+            debug!(\"counter=%? expected=%? edge_index=%? edge=%?\",\n+                   counter, expected_outgoing[counter], edge_index, edge);\n+            match expected_outgoing[counter] {\n+                (ref e, ref n) => {\n+                    assert_eq!(e, &edge.data);\n+                    assert_eq!(start_index, edge.source);\n+                    assert_eq!(n, graph.node_data(edge.target));\n+                }\n+            }\n+            counter += 1;\n+        }\n+        assert_eq!(counter, expected_outgoing.len());\n+    }\n+\n+    #[test]\n+    fn each_adjacent_from_a() {\n+        let graph = create_graph();\n+        test_adjacent_edges(&graph, NodeIndex(0), \"A\",\n+                            [],\n+                            [(\"AB\", \"B\")]);\n+    }\n+\n+    #[test]\n+    fn each_adjacent_from_b() {\n+        let graph = create_graph();\n+        test_adjacent_edges(&graph, NodeIndex(1), \"B\",\n+                            [(\"FB\", \"F\"), (\"AB\", \"A\"),],\n+                            [(\"BD\", \"D\"), (\"BC\", \"C\"),]);\n+    }\n+\n+    #[test]\n+    fn each_adjacent_from_c() {\n+        let graph = create_graph();\n+        test_adjacent_edges(&graph, NodeIndex(2), \"C\",\n+                            [(\"EC\", \"E\"), (\"BC\", \"B\")],\n+                            []);\n+    }\n+\n+    #[test]\n+    fn each_adjacent_from_d() {\n+        let graph = create_graph();\n+        test_adjacent_edges(&graph, NodeIndex(3), \"D\",\n+                            [(\"BD\", \"B\")],\n+                            [(\"DE\", \"E\")]);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "9e53ef63054bc87c630a4f41fefc21c78b3aaf6e", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7429e7a114c586004a9aa8d4c4b97eda20990107/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7429e7a114c586004a9aa8d4c4b97eda20990107/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=7429e7a114c586004a9aa8d4c4b97eda20990107", "patch": "@@ -74,6 +74,7 @@ pub mod middle {\n     pub mod entry;\n     pub mod effect;\n     pub mod reachable;\n+    pub mod graph;\n }\n \n pub mod front {"}]}