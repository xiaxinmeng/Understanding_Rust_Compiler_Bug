{"sha": "bf9ce9e65cea5a79bfba3917c4b8c5ee80f67481", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmOWNlOWU2NWNlYTVhNzliZmJhMzkxN2M0YjhjNWVlODBmNjc0ODE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-22T12:31:04Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-22T12:31:04Z"}, "message": "internal: document source_to_def and it's connection to Kotlin&Roslyn", "tree": {"sha": "c791c501c38fa7f01e9ddb9f789a6bb1ca0eda2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c791c501c38fa7f01e9ddb9f789a6bb1ca0eda2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf9ce9e65cea5a79bfba3917c4b8c5ee80f67481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf9ce9e65cea5a79bfba3917c4b8c5ee80f67481", "html_url": "https://github.com/rust-lang/rust/commit/bf9ce9e65cea5a79bfba3917c4b8c5ee80f67481", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf9ce9e65cea5a79bfba3917c4b8c5ee80f67481/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff92afb4c1934b611ab67d35dc6c6b113e97e525", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff92afb4c1934b611ab67d35dc6c6b113e97e525", "html_url": "https://github.com/rust-lang/rust/commit/ff92afb4c1934b611ab67d35dc6c6b113e97e525"}], "stats": {"total": 69, "additions": 69, "deletions": 0}, "files": [{"sha": "24afcfba007effe24ac4464a5870826597f5382b", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bf9ce9e65cea5a79bfba3917c4b8c5ee80f67481/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9ce9e65cea5a79bfba3917c4b8c5ee80f67481/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=bf9ce9e65cea5a79bfba3917c4b8c5ee80f67481", "patch": "@@ -1,4 +1,73 @@\n //! Maps *syntax* of various definitions to their semantic ids.\n+//!\n+//! This is a very interesting module, and, in some sense, can be considered a\n+//! heart of the IDE parts of rust-analyzer.\n+//!\n+//! This module solves the following problem:\n+//!\n+//!     Given a piece of syntax, find the corresponding semantic definition (def).\n+//!\n+//! This problem is a part of more-or-less every IDE feature implemented. Every\n+//! IDE functionality (like goto to definition), conceptually starts with a\n+//! specific cursor position in a file. Starting with this text offset, we first\n+//! figure out what syntactic construct are we at: is this a pattern, an\n+//! expression, an item definition.\n+//!\n+//! Knowing only the syntax gives us relatively little info. For example,\n+//! looking at the syntax of the function we can realise that it is a part of an\n+//! `impl` block, but we won't be able to tell what trait function the current\n+//! function overrides, and whether it does that correctly. For that, we need to\n+//! go from [`ast::Fn`] to [`crate::Function], and that's exactly what this\n+//! module does.\n+//!\n+//! As syntax trees are values and don't know their place of origin/identity,\n+//! this module also requires [`InFile`] wrappers to understand which specific\n+//! real or macro-expanded file the tree comes from.\n+//!\n+//! The actual algorithm to resolve syntax to def is curious in two aspects:\n+//!\n+//!     * It is recursive\n+//!     * It uses the inverse algorithm (what is the syntax for this def?)\n+//!\n+//! Specifically, the algorithm goes like this:\n+//!\n+//!     1. Find the syntactic container for the syntax. For example, field's\n+//!        container is the struct, and structs container is a module.\n+//!     2. Recursively get the def corresponding to container.\n+//!     3. Ask the container def for all child defs. These child defs contain\n+//!        the answer and answer's siblings.\n+//!     4. For each child def, ask for it's source.\n+//!     5. The child def whose source is the syntax node we've started with\n+//!        is the answer.\n+//!\n+//! It's interesting that both Roslyn and Kotlin contain very similar code\n+//! shape.\n+//!\n+//! Let's take a look at Roslyn:\n+//!\n+//!   <https://github.com/dotnet/roslyn/blob/36a0c338d6621cc5fe34b79d414074a95a6a489c/src/Compilers/CSharp/Portable/Compilation/SyntaxTreeSemanticModel.cs#L1403-L1429>\n+//!   <https://sourceroslyn.io/#Microsoft.CodeAnalysis.CSharp/Compilation/SyntaxTreeSemanticModel.cs,1403>\n+//!\n+//! The `GetDeclaredType` takes `Syntax` as input, and returns `Symbol` as\n+//! output. First, it retrieves a `Symbol` for parent `Syntax`:\n+//!\n+//! * https://sourceroslyn.io/#Microsoft.CodeAnalysis.CSharp/Compilation/SyntaxTreeSemanticModel.cs,1423\n+//!\n+//! Then, it iterates parent symbol's children, looking for one which has the\n+//! same text span as the original node:\n+//!\n+//!   <https://sourceroslyn.io/#Microsoft.CodeAnalysis.CSharp/Compilation/SyntaxTreeSemanticModel.cs,1786>\n+//!\n+//! Now, let's look at Kotlin:\n+//!\n+//!   <https://github.com/JetBrains/kotlin/blob/a288b8b00e4754a1872b164999c6d3f3b8c8994a/idea/idea-frontend-fir/idea-fir-low-level-api/src/org/jetbrains/kotlin/idea/fir/low/level/api/FirModuleResolveStateImpl.kt#L93-L125>\n+//!\n+//! This function starts with a syntax node (`KtExpression` is syntax, like all\n+//! `Kt` nodes), and returns a def. It uses\n+//! `getNonLocalContainingOrThisDeclaration` to get syntactic container for a\n+//! current node. Then, `findSourceNonLocalFirDeclaration` gets `Fir` for this\n+//! parent. Finally, `findElementIn` function traverses `Fir` children to find\n+//! one with the same source we originally started with.\n \n use base_db::FileId;\n use hir_def::{"}]}