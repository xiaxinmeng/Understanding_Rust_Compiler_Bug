{"sha": "909f5a049415a815b23502a5498de9a99bbf276b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwOWY1YTA0OTQxNWE4MTViMjM1MDJhNTQ5OGRlOWE5OWJiZjI3NmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-09T02:53:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-09T02:53:20Z"}, "message": "Auto merge of #62511 - Centril:rollup-ojzb35x, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #60458 (Add key and value methods to DebugMap)\n - #62090 (typeck: merge opaque type inference logic)\n - #62403 (Replace SliceConcatExt trait with inherent methods and SliceConcat helper trait)\n - #62494 (Remove unused dependencies)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "12723b9672bc78d2b0dd2771a20ed67396981129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12723b9672bc78d2b0dd2771a20ed67396981129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/909f5a049415a815b23502a5498de9a99bbf276b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/909f5a049415a815b23502a5498de9a99bbf276b", "html_url": "https://github.com/rust-lang/rust/commit/909f5a049415a815b23502a5498de9a99bbf276b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/909f5a049415a815b23502a5498de9a99bbf276b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09ab31bc64f4ede9f9498440cb4225c173767c1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/09ab31bc64f4ede9f9498440cb4225c173767c1e", "html_url": "https://github.com/rust-lang/rust/commit/09ab31bc64f4ede9f9498440cb4225c173767c1e"}, {"sha": "4e5bccc46df06bb1d010283cf774401bdaa606e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e5bccc46df06bb1d010283cf774401bdaa606e5", "html_url": "https://github.com/rust-lang/rust/commit/4e5bccc46df06bb1d010283cf774401bdaa606e5"}], "stats": {"total": 775, "additions": 531, "deletions": 244}, "files": [{"sha": "f2ef5f5aacab676d37d1a0826e3a63d04718d0f6", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -2985,7 +2985,6 @@ dependencies = [\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n@@ -3064,7 +3063,6 @@ dependencies = [\n  \"rustc_target 0.0.0\",\n  \"rustc_traits 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n- \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n@@ -3128,7 +3126,6 @@ dependencies = [\n  \"rustc_resolve 0.0.0\",\n  \"rustc_traits 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n- \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\","}, {"sha": "ae839bf2ac32b7d96c419045d2a436554ae6445a", "filename": "src/doc/unstable-book/src/library-features/debug-map-key-value.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -0,0 +1,9 @@\n+# `debug_map_key_value`\n+\n+The tracking issue for this feature is: [#62482]\n+\n+[#62482]: https://github.com/rust-lang/rust/issues/62482\n+\n+------------------------\n+\n+Add the methods `key` and `value` to `DebugMap` so that an entry can be formatted across multiple calls without additional buffering."}, {"sha": "3cb285bf0492f5ccf32252c89547bbe6f6232866", "filename": "src/liballoc/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Fliballoc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Fliballoc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fv1.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -6,6 +6,5 @@\n \n #[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::borrow::ToOwned;\n #[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::boxed::Box;\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::slice::SliceConcatExt;\n #[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::string::{String, ToString};\n #[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::vec::Vec;"}, {"sha": "bc4ae167984785a3d1e925f1cc6fedb26b70230d", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 69, "deletions": 60, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -484,6 +484,56 @@ impl<T> [T] {\n         }\n         buf\n     }\n+\n+    /// Flattens a slice of `T` into a single value `Self::Output`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n+    /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn concat<Separator: ?Sized>(&self) -> T::Output\n+        where T: SliceConcat<Separator>\n+    {\n+        SliceConcat::concat(self)\n+    }\n+\n+    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n+    /// given separator between each.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n+    /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n+    pub fn join<Separator: ?Sized>(&self, sep: &Separator) -> T::Output\n+        where T: SliceConcat<Separator>\n+    {\n+        SliceConcat::join(self, sep)\n+    }\n+\n+    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n+    /// given separator between each.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![allow(deprecated)]\n+    /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n+    /// assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n+    pub fn connect<Separator: ?Sized>(&self, sep: &Separator) -> T::Output\n+        where T: SliceConcat<Separator>\n+    {\n+        SliceConcat::join(self, sep)\n+    }\n+\n }\n \n #[lang = \"slice_u8_alloc\"]\n@@ -527,87 +577,46 @@ impl [u8] {\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-/// An extension trait for concatenating slices\n-///\n-/// While this trait is unstable, the methods are stable. `SliceConcatExt` is\n-/// included in the [standard library prelude], so you can use [`join()`] and\n-/// [`concat()`] as if they existed on `[T]` itself.\n-///\n-/// [standard library prelude]: ../../std/prelude/index.html\n-/// [`join()`]: #tymethod.join\n-/// [`concat()`]: #tymethod.concat\n-pub trait SliceConcatExt<T: ?Sized> {\n-    #[unstable(feature = \"slice_concat_ext\",\n-               reason = \"trait should not have to exist\",\n-               issue = \"27747\")]\n+\n+/// Helper trait for [`[T]::concat`](../../std/primitive.slice.html#method.concat)\n+/// and [`[T]::join`](../../std/primitive.slice.html#method.join)\n+#[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+pub trait SliceConcat<Separator: ?Sized>: Sized {\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n     /// The resulting type after concatenation\n     type Output;\n \n-    /// Flattens a slice of `T` into a single value `Self::Output`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n-    /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn concat(&self) -> Self::Output;\n-\n-    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n-    /// given separator between each.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n-    /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n-    fn join(&self, sep: &T) -> Self::Output;\n+    /// Implementation of [`[T]::concat`](../../std/primitive.slice.html#method.concat)\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+    fn concat(slice: &[Self]) -> Self::Output;\n \n-    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n-    /// given separator between each.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n-    /// assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n-    fn connect(&self, sep: &T) -> Self::Output {\n-        self.join(sep)\n-    }\n+    /// Implementation of [`[T]::join`](../../std/primitive.slice.html#method.join)\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+    fn join(slice: &[Self], sep: &Separator) -> Self::Output;\n }\n \n #[unstable(feature = \"slice_concat_ext\",\n            reason = \"trait should not have to exist\",\n            issue = \"27747\")]\n-impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n+impl<T: Clone, V: Borrow<[T]>> SliceConcat<T> for V {\n     type Output = Vec<T>;\n \n-    fn concat(&self) -> Vec<T> {\n-        let size = self.iter().map(|slice| slice.borrow().len()).sum();\n+    fn concat(slice: &[Self]) -> Vec<T> {\n+        let size = slice.iter().map(|slice| slice.borrow().len()).sum();\n         let mut result = Vec::with_capacity(size);\n-        for v in self {\n+        for v in slice {\n             result.extend_from_slice(v.borrow())\n         }\n         result\n     }\n \n-    fn join(&self, sep: &T) -> Vec<T> {\n-        let mut iter = self.iter();\n+    fn join(slice: &[Self], sep: &T) -> Vec<T> {\n+        let mut iter = slice.iter();\n         let first = match iter.next() {\n             Some(first) => first,\n             None => return vec![],\n         };\n-        let size = self.iter().map(|slice| slice.borrow().len()).sum::<usize>() + self.len() - 1;\n+        let size = slice.iter().map(|slice| slice.borrow().len()).sum::<usize>() + slice.len() - 1;\n         let mut result = Vec::with_capacity(size);\n         result.extend_from_slice(first.borrow());\n "}, {"sha": "37a1046d0942dd4370159b51babe387798d233fe", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -37,7 +37,7 @@ use core::unicode::conversions;\n \n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n-use crate::slice::{SliceConcatExt, SliceIndex};\n+use crate::slice::{SliceConcat, SliceIndex};\n use crate::string::String;\n use crate::vec::Vec;\n \n@@ -74,16 +74,16 @@ pub use core::str::{EscapeDebug, EscapeDefault, EscapeUnicode};\n #[unstable(feature = \"slice_concat_ext\",\n            reason = \"trait should not have to exist\",\n            issue = \"27747\")]\n-impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n+impl<S: Borrow<str>> SliceConcat<str> for S {\n     type Output = String;\n \n-    fn concat(&self) -> String {\n-        self.join(\"\")\n+    fn concat(slice: &[Self]) -> String {\n+        Self::join(slice, \"\")\n     }\n \n-    fn join(&self, sep: &str) -> String {\n+    fn join(slice: &[Self], sep: &str) -> String {\n         unsafe {\n-            String::from_utf8_unchecked( join_generic_copy(self, sep.as_bytes()) )\n+            String::from_utf8_unchecked( join_generic_copy(slice, sep.as_bytes()) )\n         }\n     }\n }\n@@ -126,7 +126,7 @@ macro_rules! copy_slice_and_advance {\n \n // Optimized join implementation that works for both Vec<T> (T: Copy) and String's inner vec\n // Currently (2018-05-13) there is a bug with type inference and specialization (see issue #36262)\n-// For this reason SliceConcatExt<T> is not specialized for T: Copy and SliceConcatExt<str> is the\n+// For this reason SliceConcat<T> is not specialized for T: Copy and SliceConcat<str> is the\n // only user of this function. It is left in place for the time when that is fixed.\n //\n // the bounds for String-join are S: Borrow<str> and for Vec-join Borrow<[T]>"}, {"sha": "cb4e32622ff1f6a169725e06651d918fb02f8cf2", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 143, "deletions": 17, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -1,37 +1,50 @@\n use crate::fmt;\n \n-struct PadAdapter<'a> {\n-    buf: &'a mut (dyn fmt::Write + 'a),\n+struct PadAdapter<'buf, 'state> {\n+    buf: &'buf mut (dyn fmt::Write + 'buf),\n+    state: &'state mut PadAdapterState,\n+}\n+\n+struct PadAdapterState {\n     on_newline: bool,\n }\n \n-impl<'a> PadAdapter<'a> {\n-    fn wrap<'b, 'c: 'a+'b>(fmt: &'c mut fmt::Formatter<'_>, slot: &'b mut Option<Self>)\n-                        -> fmt::Formatter<'b> {\n+impl Default for PadAdapterState {\n+    fn default() -> Self {\n+        PadAdapterState {\n+            on_newline: true,\n+        }\n+    }\n+}\n+\n+impl<'buf, 'state> PadAdapter<'buf, 'state> {\n+    fn wrap<'slot, 'fmt: 'buf+'slot>(fmt: &'fmt mut fmt::Formatter<'_>,\n+                                     slot: &'slot mut Option<Self>,\n+                                     state: &'state mut PadAdapterState) -> fmt::Formatter<'slot> {\n         fmt.wrap_buf(move |buf| {\n             *slot = Some(PadAdapter {\n                 buf,\n-                on_newline: true,\n+                state,\n             });\n             slot.as_mut().unwrap()\n         })\n     }\n }\n \n-impl fmt::Write for PadAdapter<'_> {\n+impl fmt::Write for PadAdapter<'_, '_> {\n     fn write_str(&mut self, mut s: &str) -> fmt::Result {\n         while !s.is_empty() {\n-            if self.on_newline {\n+            if self.state.on_newline {\n                 self.buf.write_str(\"    \")?;\n             }\n \n             let split = match s.find('\\n') {\n                 Some(pos) => {\n-                    self.on_newline = true;\n+                    self.state.on_newline = true;\n                     pos + 1\n                 }\n                 None => {\n-                    self.on_newline = false;\n+                    self.state.on_newline = false;\n                     s.len()\n                 }\n             };\n@@ -133,7 +146,8 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n                     self.fmt.write_str(\" {\\n\")?;\n                 }\n                 let mut slot = None;\n-                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot);\n+                let mut state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                 writer.write_str(name)?;\n                 writer.write_str(\": \")?;\n                 value.fmt(&mut writer)?;\n@@ -279,7 +293,8 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n                     self.fmt.write_str(\"(\\n\")?;\n                 }\n                 let mut slot = None;\n-                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot);\n+                let mut state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                 value.fmt(&mut writer)?;\n                 writer.write_str(\",\\n\")\n             } else {\n@@ -349,7 +364,8 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n                     self.fmt.write_str(\"\\n\")?;\n                 }\n                 let mut slot = None;\n-                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot);\n+                let mut state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                 entry.fmt(&mut writer)?;\n                 writer.write_str(\",\\n\")\n             } else {\n@@ -676,6 +692,9 @@ pub struct DebugMap<'a, 'b: 'a> {\n     fmt: &'a mut fmt::Formatter<'b>,\n     result: fmt::Result,\n     has_fields: bool,\n+    has_key: bool,\n+    // The state of newlines is tracked between keys and values\n+    state: PadAdapterState,\n }\n \n pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> {\n@@ -684,6 +703,8 @@ pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b\n         fmt,\n         result,\n         has_fields: false,\n+        has_key: false,\n+        state: Default::default(),\n     }\n }\n \n@@ -712,25 +733,123 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn entry(&mut self, key: &dyn fmt::Debug, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n+        self.key(key).value(value)\n+    }\n+\n+    /// Adds the key part of a new entry to the map output.\n+    ///\n+    /// This method, together with `value`, is an alternative to `entry` that\n+    /// can be used when the complete entry isn't known upfront. Prefer the `entry`\n+    /// method when it's possible to use.\n+    ///\n+    /// # Panics\n+    ///\n+    /// `key` must be called before `value` and each call to `key` must be followed\n+    /// by a corresponding call to `value`. Otherwise this method will panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(debug_map_key_value)]\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(Vec<(String, i32)>);\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         fmt.debug_map()\n+    ///            .key(&\"whole\").value(&self.0) // We add the \"whole\" entry.\n+    ///            .finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(\n+    ///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n+    ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"debug_map_key_value\",\n+               reason = \"recently added\",\n+               issue = \"62482\")]\n+    pub fn key(&mut self, key: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n+        assert!(!self.has_key, \"attempted to begin a new map entry \\\n+                                without completing the previous one\");\n+\n         self.result = self.result.and_then(|_| {\n             if self.is_pretty() {\n                 if !self.has_fields {\n                     self.fmt.write_str(\"\\n\")?;\n                 }\n                 let mut slot = None;\n-                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot);\n+                self.state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut self.state);\n                 key.fmt(&mut writer)?;\n                 writer.write_str(\": \")?;\n-                value.fmt(&mut writer)?;\n-                writer.write_str(\",\\n\")\n             } else {\n                 if self.has_fields {\n                     self.fmt.write_str(\", \")?\n                 }\n                 key.fmt(self.fmt)?;\n                 self.fmt.write_str(\": \")?;\n-                value.fmt(self.fmt)\n             }\n+\n+            self.has_key = true;\n+            Ok(())\n+        });\n+\n+        self\n+    }\n+\n+    /// Adds the value part of a new entry to the map output.\n+    ///\n+    /// This method, together with `key`, is an alternative to `entry` that\n+    /// can be used when the complete entry isn't known upfront. Prefer the `entry`\n+    /// method when it's possible to use.\n+    ///\n+    /// # Panics\n+    ///\n+    /// `key` must be called before `value` and each call to `key` must be followed\n+    /// by a corresponding call to `value`. Otherwise this method will panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(debug_map_key_value)]\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(Vec<(String, i32)>);\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         fmt.debug_map()\n+    ///            .key(&\"whole\").value(&self.0) // We add the \"whole\" entry.\n+    ///            .finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(\n+    ///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n+    ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"debug_map_key_value\",\n+               reason = \"recently added\",\n+               issue = \"62482\")]\n+    pub fn value(&mut self, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n+        assert!(self.has_key, \"attempted to format a map value before its key\");\n+\n+        self.result = self.result.and_then(|_| {\n+            if self.is_pretty() {\n+                let mut slot = None;\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut self.state);\n+                value.fmt(&mut writer)?;\n+                writer.write_str(\",\\n\")?;\n+            } else {\n+                value.fmt(self.fmt)?;\n+            }\n+\n+            self.has_key = false;\n+            Ok(())\n         });\n \n         self.has_fields = true;\n@@ -775,6 +894,11 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n \n     /// Finishes output and returns any error encountered.\n     ///\n+    /// # Panics\n+    ///\n+    /// `key` must be called before `value` and each call to `key` must be followed\n+    /// by a corresponding call to `value`. Otherwise this method will panic.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -797,6 +921,8 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn finish(&mut self) -> fmt::Result {\n+        assert!(!self.has_key, \"attempted to finish a map with a partial entry\");\n+\n         self.result.and_then(|_| self.fmt.write_str(\"}\"))\n     }\n "}, {"sha": "200659b91bb4ec696697e0423347c4fbb720cb3c", "filename": "src/libcore/tests/fmt/builders.rs", "status": "modified", "additions": 85, "deletions": 8, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -211,29 +211,42 @@ mod debug_map {\n \n     #[test]\n     fn test_single() {\n-        struct Foo;\n+        struct Entry;\n \n-        impl fmt::Debug for Foo {\n+        impl fmt::Debug for Entry {\n             fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 fmt.debug_map()\n                     .entry(&\"bar\", &true)\n                     .finish()\n             }\n         }\n \n-        assert_eq!(\"{\\\"bar\\\": true}\", format!(\"{:?}\", Foo));\n+        struct KeyValue;\n+\n+        impl fmt::Debug for KeyValue {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .key(&\"bar\").value(&true)\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(format!(\"{:?}\", Entry), format!(\"{:?}\", KeyValue));\n+        assert_eq!(format!(\"{:#?}\", Entry), format!(\"{:#?}\", KeyValue));\n+\n+        assert_eq!(\"{\\\"bar\\\": true}\", format!(\"{:?}\", Entry));\n         assert_eq!(\n \"{\n     \\\"bar\\\": true,\n }\",\n-                   format!(\"{:#?}\", Foo));\n+                   format!(\"{:#?}\", Entry));\n     }\n \n     #[test]\n     fn test_multiple() {\n-        struct Foo;\n+        struct Entry;\n \n-        impl fmt::Debug for Foo {\n+        impl fmt::Debug for Entry {\n             fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 fmt.debug_map()\n                     .entry(&\"bar\", &true)\n@@ -242,13 +255,27 @@ mod debug_map {\n             }\n         }\n \n-        assert_eq!(\"{\\\"bar\\\": true, 10: 10/20}\", format!(\"{:?}\", Foo));\n+        struct KeyValue;\n+\n+        impl fmt::Debug for KeyValue {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .key(&\"bar\").value(&true)\n+                    .key(&10).value(&format_args!(\"{}/{}\", 10, 20))\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(format!(\"{:?}\", Entry), format!(\"{:?}\", KeyValue));\n+        assert_eq!(format!(\"{:#?}\", Entry), format!(\"{:#?}\", KeyValue));\n+\n+        assert_eq!(\"{\\\"bar\\\": true, 10: 10/20}\", format!(\"{:?}\", Entry));\n         assert_eq!(\n \"{\n     \\\"bar\\\": true,\n     10: 10/20,\n }\",\n-                   format!(\"{:#?}\", Foo));\n+                   format!(\"{:#?}\", Entry));\n     }\n \n     #[test]\n@@ -291,6 +318,56 @@ mod debug_map {\n }\",\n                    format!(\"{:#?}\", Bar));\n     }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_invalid_key_when_entry_is_incomplete() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .key(&\"bar\")\n+                    .key(&\"invalid\")\n+                    .finish()\n+            }\n+        }\n+\n+        format!(\"{:?}\", Foo);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_invalid_finish_incomplete_entry() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .key(&\"bar\")\n+                    .finish()\n+            }\n+        }\n+\n+        format!(\"{:?}\", Foo);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_invalid_value_before_key() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .value(&\"invalid\")\n+                    .key(&\"bar\")\n+                    .finish()\n+            }\n+        }\n+\n+        format!(\"{:?}\", Foo);\n+    }\n }\n \n mod debug_set {"}, {"sha": "4b48d1225902b808e3aee7dde9edb2fc2baa844e", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -3,6 +3,7 @@\n #![feature(cell_update)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n+#![feature(debug_map_key_value)]\n #![feature(dec2flt)]\n #![feature(euclidean_division)]\n #![feature(exact_size_is_empty)]"}, {"sha": "f3dc4d3f72a9b37129c46cbfbcdffc82b4f2f1d7", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -4,6 +4,7 @@ use crate::hir::Node;\n use crate::infer::outlives::free_region_map::FreeRegionRelations;\n use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::middle::region;\n+use crate::mir::interpret::ConstValue;\n use crate::traits::{self, PredicateObligation};\n use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::subst::{InternalSubsts, Kind, SubstsRef, UnpackedKind};\n@@ -553,6 +554,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         def_id: DefId,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         instantiated_ty: Ty<'tcx>,\n+        span: Span,\n     ) -> Ty<'tcx> {\n         debug!(\n             \"infer_opaque_definition_from_instantiation(def_id={:?}, instantiated_ty={:?})\",\n@@ -584,6 +586,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             def_id,\n             map,\n             instantiated_ty,\n+            span,\n         ));\n         debug!(\"infer_opaque_definition_from_instantiation: definition_ty={:?}\", definition_ty);\n \n@@ -761,6 +764,9 @@ struct ReverseMapper<'tcx> {\n \n     /// initially `Some`, set to `None` once error has been reported\n     hidden_ty: Option<Ty<'tcx>>,\n+\n+    /// Span of function being checked.\n+    span: Span,\n }\n \n impl ReverseMapper<'tcx> {\n@@ -770,6 +776,7 @@ impl ReverseMapper<'tcx> {\n         opaque_type_def_id: DefId,\n         map: FxHashMap<Kind<'tcx>, Kind<'tcx>>,\n         hidden_ty: Ty<'tcx>,\n+        span: Span,\n     ) -> Self {\n         Self {\n             tcx,\n@@ -778,6 +785,7 @@ impl ReverseMapper<'tcx> {\n             map,\n             map_missing_regions_to_empty: false,\n             hidden_ty: Some(hidden_ty),\n+            span,\n         }\n     }\n \n@@ -812,10 +820,11 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             _ => { }\n         }\n \n+        let generics = self.tcx().generics_of(self.opaque_type_def_id);\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n             Some(UnpackedKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None => {\n+            None if generics.parent.is_some() => {\n                 if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n                     if let Some(hidden_ty) = self.hidden_ty.take() {\n                         unexpected_hidden_region_diagnostic(\n@@ -829,6 +838,21 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 }\n                 self.tcx.lifetimes.re_empty\n             }\n+            None => {\n+                self.tcx.sess\n+                    .struct_span_err(\n+                        self.span,\n+                        \"non-defining existential type use in defining scope\"\n+                    )\n+                    .span_label(\n+                        self.span,\n+                        format!(\"lifetime `{}` is part of concrete type but not used in \\\n+                                 parameter list of existential type\", r),\n+                    )\n+                    .emit();\n+\n+                self.tcx().global_tcx().mk_region(ty::ReStatic)\n+            },\n         }\n     }\n \n@@ -890,9 +914,59 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 self.tcx.mk_generator(def_id, ty::GeneratorSubsts { substs }, movability)\n             }\n \n+            ty::Param(..) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list; replace with the parameter from the\n+                    // existential type.\n+                    Some(UnpackedKind::Type(t1)) => t1,\n+                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        self.tcx.sess\n+                            .struct_span_err(\n+                                self.span,\n+                                &format!(\"type parameter `{}` is part of concrete type but not \\\n+                                          used in parameter list for existential type\", ty),\n+                            )\n+                            .emit();\n+\n+                        self.tcx().types.err\n+                    }\n+                }\n+            }\n+\n             _ => ty.super_fold_with(self),\n         }\n     }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        trace!(\"checking const {:?}\", ct);\n+        // Find a const parameter\n+        match ct.val {\n+            ConstValue::Param(..) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list, replace with the parameter from the\n+                    // existential type.\n+                    Some(UnpackedKind::Const(c1)) => c1,\n+                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        self.tcx.sess\n+                            .struct_span_err(\n+                                self.span,\n+                                &format!(\"const parameter `{}` is part of concrete type but not \\\n+                                          used in parameter list for existential type\", ct)\n+                            )\n+                            .emit();\n+\n+                        self.tcx().consts.err\n+                    }\n+                }\n+            }\n+\n+            _ => ct,\n+        }\n+    }\n }\n \n struct Instantiator<'a, 'tcx> {"}, {"sha": "e7ee06df7e12dab9c95dfcd33fb1c44bd0066a75", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -13,7 +13,6 @@ test = false\n bitflags = \"1.0.4\"\n cc = \"1.0.1\"\n num_cpus = \"1.0\"\n-rustc-demangle = \"0.1.15\"\n memmap = \"0.6\"\n log = \"0.4.5\"\n libc = \"0.2.44\""}, {"sha": "9a8473e1409d1f9750754e23453298b46e9746f1", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -15,7 +15,6 @@ graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n env_logger = { version = \"0.5\", default-features = false }\n rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n-scoped-tls = \"1.0\"\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "2712355d5379b772475e0ee57278e0e405e686aa", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -13,7 +13,6 @@ doctest = false\n log = \"0.4\"\n rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n-scoped-tls = \"1.0\"\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "145b37ff907abb29fe1c51bea3739a63159191ef", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 15, "deletions": 138, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -9,10 +9,8 @@ use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::infer::InferCtxt;\n use rustc::ty::adjustment::{Adjust, Adjustment, PointerCast};\n-use rustc::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n-use rustc::ty::subst::UnpackedKind;\n+use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::mir::interpret::ConstValue;\n use rustc::util::nodemap::DefIdSet;\n use rustc_data_structures::sync::Lrc;\n use std::mem;\n@@ -440,141 +438,20 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n \n-            let generics = self.tcx().generics_of(def_id);\n-\n-            let definition_ty = if generics.parent.is_some() {\n-                // `impl Trait`\n-                self.fcx.infer_opaque_definition_from_instantiation(\n-                    def_id,\n-                    opaque_defn,\n-                    instantiated_ty,\n-                )\n-            } else {\n-                // Prevent:\n-                // * `fn foo<T>() -> Foo<T>`\n-                // * `fn foo<T: Bound + Other>() -> Foo<T>`\n-                // from being defining.\n-\n-                // Also replace all generic params with the ones from the existential type\n-                // definition so that\n-                // ```rust\n-                // existential type Foo<T>: 'static;\n-                // fn foo<U>() -> Foo<U> { .. }\n-                // ```\n-                // figures out the concrete type with `U`, but the stored type is with `T`.\n-                instantiated_ty.fold_with(&mut BottomUpFolder {\n-                    tcx: self.tcx().global_tcx(),\n-                    ty_op: |ty| {\n-                        trace!(\"checking type {:?}\", ty);\n-                        // Find a type parameter.\n-                        if let ty::Param(..) = ty.sty {\n-                            // Look it up in the substitution list.\n-                            assert_eq!(opaque_defn.substs.len(), generics.params.len());\n-                            for (subst, param) in opaque_defn.substs.iter().zip(&generics.params) {\n-                                if let UnpackedKind::Type(subst) = subst.unpack() {\n-                                    if subst == ty {\n-                                        // Found it in the substitution list; replace with the\n-                                        // parameter from the existential type.\n-                                        return self.tcx()\n-                                            .global_tcx()\n-                                            .mk_ty_param(param.index, param.name);\n-                                    }\n-                                }\n-                            }\n-                            self.tcx()\n-                                .sess\n-                                .struct_span_err(\n-                                    span,\n-                                    &format!(\n-                                        \"type parameter `{}` is part of concrete type but not used \\\n-                                         in parameter list for existential type\",\n-                                        ty,\n-                                    ),\n-                                )\n-                                .emit();\n-                            return self.tcx().types.err;\n-                        }\n-                        ty\n-                    },\n-                    lt_op: |region| {\n-                        match region {\n-                            // Skip static and bound regions: they don't require substitution.\n-                            ty::ReStatic | ty::ReLateBound(..) => region,\n-                            _ => {\n-                                trace!(\"checking {:?}\", region);\n-                                for (subst, p) in opaque_defn.substs.iter().zip(&generics.params) {\n-                                    if let UnpackedKind::Lifetime(subst) = subst.unpack() {\n-                                        if subst == region {\n-                                            // Found it in the substitution list; replace with the\n-                                            // parameter from the existential type.\n-                                            let reg = ty::EarlyBoundRegion {\n-                                                def_id: p.def_id,\n-                                                index: p.index,\n-                                                name: p.name,\n-                                            };\n-                                            trace!(\"replace {:?} with {:?}\", region, reg);\n-                                            return self.tcx()\n-                                                .global_tcx()\n-                                                .mk_region(ty::ReEarlyBound(reg));\n-                                        }\n-                                    }\n-                                }\n-                                trace!(\"opaque_defn: {:#?}\", opaque_defn);\n-                                trace!(\"generics: {:#?}\", generics);\n-                                self.tcx()\n-                                    .sess\n-                                    .struct_span_err(\n-                                        span,\n-                                        \"non-defining existential type use in defining scope\",\n-                                    )\n-                                    .span_label(\n-                                        span,\n-                                        format!(\n-                                            \"lifetime `{}` is part of concrete type but not used \\\n-                                             in parameter list of existential type\",\n-                                            region,\n-                                        ),\n-                                    )\n-                                    .emit();\n-                                self.tcx().global_tcx().mk_region(ty::ReStatic)\n-                            }\n-                        }\n-                    },\n-                    ct_op: |ct| {\n-                        trace!(\"checking const {:?}\", ct);\n-                        // Find a const parameter\n-                        if let ConstValue::Param(..) = ct.val {\n-                            // look it up in the substitution list\n-                            assert_eq!(opaque_defn.substs.len(), generics.params.len());\n-                            for (subst, param) in opaque_defn.substs.iter()\n-                                                                    .zip(&generics.params) {\n-                                if let UnpackedKind::Const(subst) = subst.unpack() {\n-                                    if subst == ct {\n-                                        // found it in the substitution list, replace with the\n-                                        // parameter from the existential type\n-                                        return self.tcx()\n-                                            .global_tcx()\n-                                            .mk_const_param(param.index, param.name, ct.ty);\n-                                    }\n-                                }\n-                            }\n-                            self.tcx()\n-                                .sess\n-                                .struct_span_err(\n-                                    span,\n-                                    &format!(\n-                                        \"const parameter `{}` is part of concrete type but not \\\n-                                            used in parameter list for existential type\",\n-                                        ct,\n-                                    ),\n-                                )\n-                                .emit();\n-                            return self.tcx().consts.err;\n-                        }\n-                        ct\n-                    }\n-                })\n-            };\n+            // Prevent:\n+            // * `fn foo<T>() -> Foo<T>`\n+            // * `fn foo<T: Bound + Other>() -> Foo<T>`\n+            // from being defining.\n+\n+            // Also replace all generic params with the ones from the existential type\n+            // definition so that\n+            // ```rust\n+            // existential type Foo<T>: 'static;\n+            // fn foo<U>() -> Foo<U> { .. }\n+            // ```\n+            // figures out the concrete type with `U`, but the stored type is with `T`.\n+            let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n+                def_id, opaque_defn, instantiated_ty, span);\n \n             if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.sty {\n                 if def_id == defin_ty_def_id {"}, {"sha": "3085c3d829653b0f6750f476e4a7666ac2be0bbe", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -71,9 +71,6 @@\n //! * [`std::result`]::[`Result`]::{`self`, `Ok`, `Err`}. A type for functions\n //!   that may succeed or fail. Like [`Option`], its variants are exported as\n //!   well.\n-//! * [`std::slice`]::[`SliceConcatExt`], a trait that exists for technical\n-//!   reasons, but shouldn't have to exist. It provides a few useful methods on\n-//!   slices.\n //! * [`std::string`]::{[`String`], [`ToString`]}, heap allocated strings.\n //! * [`std::vec`]::[`Vec`](../vec/struct.Vec.html), a growable, heap-allocated\n //!   vector."}, {"sha": "a863bebf4a2648572b9a5abe6ffa62f906138312", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -60,9 +60,6 @@ pub use crate::boxed::Box;\n pub use crate::borrow::ToOwned;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::slice::SliceConcatExt;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)]\n pub use crate::string::{String, ToString};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]"}, {"sha": "5095b26f8a4e0f935f0abbc240fb4cce9634a939", "filename": "src/test/ui/impl-trait/issue-55872-1.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -0,0 +1,22 @@\n+// ignore-tidy-linelength\n+#![feature(existential_type)]\n+\n+pub trait Bar\n+{\n+    type E: Copy;\n+\n+    fn foo<T>() -> Self::E;\n+}\n+\n+impl<S: Default> Bar for S {\n+    existential type E: Copy;\n+    //~^ ERROR the trait bound `S: std::marker::Copy` is not satisfied in `(S, T)` [E0277]\n+    //~^^ ERROR the trait bound `T: std::marker::Copy` is not satisfied in `(S, T)` [E0277]\n+\n+    fn foo<T: Default>() -> Self::E {\n+    //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for existential type\n+        (S::default(), T::default())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "04b4d2d4a50a53008b127f53943ebb6d011b0110", "filename": "src/test/ui/impl-trait/issue-55872-1.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -0,0 +1,33 @@\n+error[E0277]: the trait bound `S: std::marker::Copy` is not satisfied in `(S, T)`\n+  --> $DIR/issue-55872-1.rs:12:5\n+   |\n+LL |     existential type E: Copy;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `S`\n+   |\n+   = help: consider adding a `where S: std::marker::Copy` bound\n+   = note: required because it appears within the type `(S, T)`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied in `(S, T)`\n+  --> $DIR/issue-55872-1.rs:12:5\n+   |\n+LL |     existential type E: Copy;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `T`\n+   |\n+   = help: consider adding a `where T: std::marker::Copy` bound\n+   = note: required because it appears within the type `(S, T)`\n+   = note: the return type of a function must have a statically known size\n+\n+error: type parameter `T` is part of concrete type but not used in parameter list for existential type\n+  --> $DIR/issue-55872-1.rs:16:37\n+   |\n+LL |       fn foo<T: Default>() -> Self::E {\n+   |  _____________________________________^\n+LL | |\n+LL | |         (S::default(), T::default())\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2bdeb14bdc3e6fd9144fd1497c69691401334bed", "filename": "src/test/ui/impl-trait/issue-55872-2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -0,0 +1,20 @@\n+// edition:2018\n+// ignore-tidy-linelength\n+#![feature(async_await, existential_type)]\n+\n+pub trait Bar {\n+    type E: Copy;\n+\n+    fn foo<T>() -> Self::E;\n+}\n+\n+impl<S> Bar for S {\n+    existential type E: Copy;\n+    //~^ ERROR the trait bound `impl std::future::Future: std::marker::Copy` is not satisfied [E0277]\n+    fn foo<T>() -> Self::E {\n+    //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for existential type\n+        async {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2505a82ee23cb30638858453dbfd2ff8c4eea99c", "filename": "src/test/ui/impl-trait/issue-55872-2.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -0,0 +1,21 @@\n+error[E0277]: the trait bound `impl std::future::Future: std::marker::Copy` is not satisfied\n+  --> $DIR/issue-55872-2.rs:12:5\n+   |\n+LL |     existential type E: Copy;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `impl std::future::Future`\n+   |\n+   = note: the return type of a function must have a statically known size\n+\n+error: type parameter `T` is part of concrete type but not used in parameter list for existential type\n+  --> $DIR/issue-55872-2.rs:14:28\n+   |\n+LL |       fn foo<T>() -> Self::E {\n+   |  ____________________________^\n+LL | |\n+LL | |         async {}\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "95604545c37f18b29dc52a89e9acb553fa72b444", "filename": "src/test/ui/impl-trait/issue-55872.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -0,0 +1,19 @@\n+// ignore-tidy-linelength\n+#![feature(existential_type)]\n+\n+pub trait Bar {\n+    type E: Copy;\n+\n+    fn foo<T>() -> Self::E;\n+}\n+\n+impl<S> Bar for S {\n+    existential type E: Copy;\n+\n+    fn foo<T>() -> Self::E {\n+    //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for existential type\n+        || ()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "487f276e317e9ff3026eee37d2fb7862e3358c35", "filename": "src/test/ui/impl-trait/issue-55872.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/909f5a049415a815b23502a5498de9a99bbf276b/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/909f5a049415a815b23502a5498de9a99bbf276b/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr?ref=909f5a049415a815b23502a5498de9a99bbf276b", "patch": "@@ -0,0 +1,12 @@\n+error: type parameter `T` is part of concrete type but not used in parameter list for existential type\n+  --> $DIR/issue-55872.rs:13:28\n+   |\n+LL |       fn foo<T>() -> Self::E {\n+   |  ____________________________^\n+LL | |\n+LL | |         || ()\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to previous error\n+"}]}