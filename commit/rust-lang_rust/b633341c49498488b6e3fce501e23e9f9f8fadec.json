{"sha": "b633341c49498488b6e3fce501e23e9f9f8fadec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MzMzNDFjNDk0OTg0ODhiNmUzZmNlNTAxZTIzZTlmOWY4ZmFkZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-20T17:36:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-20T17:36:40Z"}, "message": "Auto merge of #44792 - Mark-Simulacrum:correct-deps, r=alexcrichton\n\nMake sure to clear out the stageN-{rustc,std,tools} directories.\n\nWe copy built tool binaries into a dedicated directory to avoid deleting them,\nstageN-tools-bin.  These aren't ever cleared out by code, since there should be\nno reason to do so, and we'll simply overwrite them as necessary.\n\nWhen clearing out the stageN-{std,rustc,tools} directories, make sure to delete\nboth Cargo directories -- per-target and build scripts. This ensures that\nchanging libstd doesn't cause problems due to build scripts not being rebuilt,\neven though they should be.\n\nFixes https://github.com/rust-lang/rust/issues/44739.", "tree": {"sha": "60a9d960be0b2db28ef5a4912c5f29265a9cced3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60a9d960be0b2db28ef5a4912c5f29265a9cced3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b633341c49498488b6e3fce501e23e9f9f8fadec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b633341c49498488b6e3fce501e23e9f9f8fadec", "html_url": "https://github.com/rust-lang/rust/commit/b633341c49498488b6e3fce501e23e9f9f8fadec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b633341c49498488b6e3fce501e23e9f9f8fadec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc", "url": "https://api.github.com/repos/rust-lang/rust/commits/87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc", "html_url": "https://github.com/rust-lang/rust/commit/87a8e8e07387f99ffe931b1f2bbc4c0585b16ccc"}, {"sha": "686c1015cfa341748b6de20114e8caba4626931b", "url": "https://api.github.com/repos/rust-lang/rust/commits/686c1015cfa341748b6de20114e8caba4626931b", "html_url": "https://github.com/rust-lang/rust/commit/686c1015cfa341748b6de20114e8caba4626931b"}], "stats": {"total": 211, "additions": 132, "deletions": 79}, "files": [{"sha": "dee4999879ca384e721e7a9bccb58dfaf0a03611", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=b633341c49498488b6e3fce501e23e9f9f8fadec", "patch": "@@ -612,7 +612,7 @@ impl<'a> Builder<'a> {\n         // Set this for all builds to make sure doc builds also get it.\n         cargo.env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel);\n \n-        if self.is_verbose() {\n+        if self.is_very_verbose() {\n             cargo.arg(\"-v\");\n         }\n         // FIXME: cargo bench does not accept `--release`"}, {"sha": "11bc9f7d217721b83252ce26e12a34bdbb9c5034", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=b633341c49498488b6e3fce501e23e9f9f8fadec", "patch": "@@ -340,25 +340,28 @@ impl Step for Miri {\n         let host = self.host;\n         let compiler = builder.compiler(1, host);\n \n-        let miri = builder.ensure(tool::Miri { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-        // miri tests need to know about the stage sysroot\n-        cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n-        cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-        cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-        cargo.env(\"MIRI_PATH\", miri);\n-\n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-        try_run_expecting(\n-            build,\n-            &mut cargo,\n-            builder.build.config.toolstate.miri.passes(ToolState::Testing),\n-        );\n+        if let Some(miri) = builder.ensure(tool::Miri { compiler, target: self.host }) {\n+            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n+            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n+\n+            // Don't build tests dynamically, just a pain to work with\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+            // miri tests need to know about the stage sysroot\n+            cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+            cargo.env(\"MIRI_PATH\", miri);\n+\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+            try_run_expecting(\n+                build,\n+                &mut cargo,\n+                builder.build.config.toolstate.miri.passes(ToolState::Testing),\n+            );\n+        } else {\n+            eprintln!(\"failed to test miri: could not build\");\n+        }\n     }\n }\n \n@@ -391,24 +394,27 @@ impl Step for Clippy {\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n \n-        let clippy = builder.ensure(tool::Clippy { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n+        if let Some(clippy) = builder.ensure(tool::Clippy { compiler, target: self.host }) {\n+            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n+            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n \n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-        // clippy tests need to know about the stage sysroot\n-        cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n-        // clippy tests need to find the driver\n-        cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n+            // Don't build tests dynamically, just a pain to work with\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+            // clippy tests need to know about the stage sysroot\n+            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n+            // clippy tests need to find the driver\n+            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n \n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-        try_run_expecting(\n-            build,\n-            &mut cargo,\n-            builder.build.config.toolstate.clippy.passes(ToolState::Testing),\n-        );\n+            try_run_expecting(\n+                build,\n+                &mut cargo,\n+                builder.build.config.toolstate.clippy.passes(ToolState::Testing),\n+            );\n+        } else {\n+            eprintln!(\"failed to test clippy: could not build\");\n+        }\n     }\n }\n "}, {"sha": "f837371bebecbe737cf2be50428236b69da1c3c8", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=b633341c49498488b6e3fce501e23e9f9f8fadec", "patch": "@@ -29,7 +29,7 @@ use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n use serde_json;\n \n-use util::{exe, libdir, is_dylib, copy};\n+use util::{exe, libdir, is_dylib, copy, read_stamp_file};\n use {Build, Compiler, Mode};\n use native;\n use tool;\n@@ -102,7 +102,7 @@ impl Step for Std {\n             copy_musl_third_party_objects(build, target, &libdir);\n         }\n \n-        let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n+        let out_dir = build.stage_out(compiler, Mode::Libstd);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n         std_cargo(build, &compiler, target, &mut cargo);\n@@ -354,7 +354,7 @@ impl Step for Test {\n         let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n         println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target);\n-        let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n+        let out_dir = build.stage_out(compiler, Mode::Libtest);\n         build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"build\");\n         test_cargo(build, &compiler, target, &mut cargo);\n@@ -480,8 +480,9 @@ impl Step for Rustc {\n         println!(\"Building stage{} compiler artifacts ({} -> {})\",\n                  compiler.stage, &compiler.host, target);\n \n-        let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n-        build.clear_if_dirty(&out_dir, &libtest_stamp(build, compiler, target));\n+        let stage_out = builder.stage_out(compiler, Mode::Librustc);\n+        build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n+        build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n         rustc_cargo(build, &compiler, target, &mut cargo);\n@@ -757,15 +758,7 @@ impl Step for Assemble {\n /// `sysroot_dst` provided.\n fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n-    let mut contents = Vec::new();\n-    t!(t!(File::open(stamp)).read_to_end(&mut contents));\n-    // This is the method we use for extracting paths from the stamp file passed to us. See\n-    // run_cargo for more information (in this file).\n-    for part in contents.split(|b| *b == 0) {\n-        if part.is_empty() {\n-            continue\n-        }\n-        let path = Path::new(t!(str::from_utf8(part)));\n+    for path in read_stamp_file(stamp) {\n         copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n     }\n }\n@@ -938,6 +931,8 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n     let max = max.unwrap();\n     let max_path = max_path.unwrap();\n     if stamp_contents == new_contents && max <= stamp_mtime {\n+        build.verbose(&format!(\"not updating {:?}; contents equal and {} <= {}\",\n+                stamp, max, stamp_mtime));\n         return\n     }\n     if max > stamp_mtime {"}, {"sha": "e41f01ac8344060f039bdaa1bcbb2260d0238b7a", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=b633341c49498488b6e3fce501e23e9f9f8fadec", "patch": "@@ -1073,10 +1073,12 @@ impl Step for Rls {\n         t!(fs::create_dir_all(&image));\n \n         // Prepare the image directory\n+        // We expect RLS to build, because we've exited this step above if tool\n+        // state for RLS isn't testing.\n         let rls = builder.ensure(tool::Rls {\n             compiler: builder.compiler(stage, build.build),\n             target\n-        });\n+        }).expect(\"Rls to build: toolstate is testing\");\n         install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n         install(&src.join(\"README.md\"), &doc, 0o644);"}, {"sha": "479283b3595548adf366c437e7ff80a74e63f415", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=b633341c49498488b6e3fce501e23e9f9f8fadec", "patch": "@@ -385,16 +385,19 @@ impl Build {\n     /// Clear out `dir` if `input` is newer.\n     ///\n     /// After this executes, it will also ensure that `dir` exists.\n-    fn clear_if_dirty(&self, dir: &Path, input: &Path) {\n+    fn clear_if_dirty(&self, dir: &Path, input: &Path) -> bool {\n         let stamp = dir.join(\".stamp\");\n+        let mut cleared = false;\n         if mtime(&stamp) < mtime(input) {\n             self.verbose(&format!(\"Dirty - {}\", dir.display()));\n             let _ = fs::remove_dir_all(dir);\n+            cleared = true;\n         } else if stamp.exists() {\n-            return\n+            return cleared;\n         }\n         t!(fs::create_dir_all(dir));\n         t!(File::create(stamp));\n+        cleared\n     }\n \n     /// Get the space-separated set of activated features for the standard\n@@ -435,6 +438,12 @@ impl Build {\n         if self.config.rust_optimize {\"release\"} else {\"debug\"}\n     }\n \n+    fn tools_dir(&self, compiler: Compiler) -> PathBuf {\n+        let out = self.out.join(&*compiler.host).join(format!(\"stage{}-tools-bin\", compiler.stage));\n+        t!(fs::create_dir_all(&out));\n+        out\n+    }\n+\n     /// Get the directory for incremental by-products when using the\n     /// given compiler.\n     fn incremental_dir(&self, compiler: Compiler) -> PathBuf {"}, {"sha": "912ffa519758cc1fdd8ef3e8959c9458d48ab08c", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=b633341c49498488b6e3fce501e23e9f9f8fadec", "patch": "@@ -38,24 +38,40 @@ impl Step for CleanTools {\n         run.never()\n     }\n \n-    /// Build a tool in `src/tools`\n-    ///\n-    /// This will build the specified tool with the specified `host` compiler in\n-    /// `stage` into the normal cargo output directory.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n         let mode = self.mode;\n \n-        let stamp = match mode {\n-            Mode::Libstd => libstd_stamp(build, compiler, target),\n-            Mode::Libtest => libtest_stamp(build, compiler, target),\n-            Mode::Librustc => librustc_stamp(build, compiler, target),\n-            _ => panic!(),\n+        // This is for the original compiler, but if we're forced to use stage 1, then\n+        // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n+        // we copy the libs forward.\n+        let tools_dir = build.stage_out(compiler, Mode::Tool);\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n+        } else {\n+            compiler\n         };\n-        let out_dir = build.cargo_out(compiler, Mode::Tool, target);\n-        build.clear_if_dirty(&out_dir, &stamp);\n+\n+        for &cur_mode in &[Mode::Libstd, Mode::Libtest, Mode::Librustc] {\n+            let stamp = match cur_mode {\n+                Mode::Libstd => libstd_stamp(build, compiler, target),\n+                Mode::Libtest => libtest_stamp(build, compiler, target),\n+                Mode::Librustc => librustc_stamp(build, compiler, target),\n+                _ => panic!(),\n+            };\n+\n+            if build.clear_if_dirty(&tools_dir, &stamp) {\n+                break;\n+            }\n+\n+            // If we are a rustc tool, and std changed, we also need to clear ourselves out -- our\n+            // dependencies depend on std. Therefore, we iterate up until our own mode.\n+            if mode == cur_mode {\n+                break;\n+            }\n+        }\n     }\n }\n \n@@ -70,7 +86,7 @@ struct ToolBuild {\n }\n \n impl Step for ToolBuild {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.never()\n@@ -80,7 +96,7 @@ impl Step for ToolBuild {\n     ///\n     /// This will build the specified tool with the specified `host` compiler in\n     /// `stage` into the normal cargo output directory.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n@@ -100,7 +116,15 @@ impl Step for ToolBuild {\n \n         let mut cargo = prepare_tool_cargo(builder, compiler, target, \"build\", path);\n         build.run_expecting(&mut cargo, expectation);\n-        build.cargo_out(compiler, Mode::Tool, target).join(exe(tool, &compiler.host))\n+        if expectation == BuildExpectation::Succeeding || expectation == BuildExpectation::None {\n+            let cargo_out = build.cargo_out(compiler, Mode::Tool, target)\n+                .join(exe(tool, &compiler.host));\n+            let bin = build.tools_dir(compiler).join(exe(tool, &compiler.host));\n+            copy(&cargo_out, &bin);\n+            Some(bin)\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -209,7 +233,7 @@ macro_rules! tool {\n                     mode: $mode,\n                     path: $path,\n                     expectation: BuildExpectation::None,\n-                })\n+                }).expect(\"expected to build -- BuildExpectation::None\")\n             }\n         }\n         )+\n@@ -257,7 +281,7 @@ impl Step for RemoteTestServer {\n             mode: Mode::Libstd,\n             path: \"src/tools/remote-test-server\",\n             expectation: BuildExpectation::None,\n-        })\n+        }).expect(\"expected to build -- BuildExpectation::None\")\n     }\n }\n \n@@ -375,7 +399,7 @@ impl Step for Cargo {\n             mode: Mode::Librustc,\n             path: \"src/tools/cargo\",\n             expectation: BuildExpectation::None,\n-        })\n+        }).expect(\"BuildExpectation::None - expected to build\")\n     }\n }\n \n@@ -386,7 +410,7 @@ pub struct Clippy {\n }\n \n impl Step for Clippy {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -401,7 +425,7 @@ impl Step for Clippy {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         // Clippy depends on procedural macros (serde), which requires a full host\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n@@ -426,7 +450,7 @@ pub struct Rls {\n }\n \n impl Step for Rls {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -442,7 +466,7 @@ impl Step for Rls {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         builder.ensure(native::Openssl {\n             target: self.target,\n         });\n@@ -470,7 +494,7 @@ pub struct Rustfmt {\n }\n \n impl Step for Rustfmt {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -486,7 +510,7 @@ impl Step for Rustfmt {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n@@ -506,7 +530,7 @@ pub struct Miri {\n }\n \n impl Step for Miri {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -522,7 +546,7 @@ impl Step for Miri {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,"}, {"sha": "2506048858f2b67dadf83f970214815c062cc2a8", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b633341c49498488b6e3fce501e23e9f9f8fadec/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=b633341c49498488b6e3fce501e23e9f9f8fadec", "patch": "@@ -14,8 +14,9 @@\n //! not a lot of interesting happenings here unfortunately.\n \n use std::env;\n-use std::fs;\n-use std::io::{self, Write};\n+use std::str;\n+use std::fs::{self, File};\n+use std::io::{self, Read, Write};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{SystemTime, Instant};\n@@ -50,6 +51,22 @@ pub fn copy(src: &Path, dst: &Path) {\n     t!(filetime::set_file_times(dst, atime, mtime));\n }\n \n+pub fn read_stamp_file(stamp: &Path) -> Vec<PathBuf> {\n+    let mut paths = Vec::new();\n+    let mut contents = Vec::new();\n+    t!(t!(File::open(stamp)).read_to_end(&mut contents));\n+    // This is the method we use for extracting paths from the stamp file passed to us. See\n+    // run_cargo for more information (in compile.rs).\n+    for part in contents.split(|b| *b == 0) {\n+        if part.is_empty() {\n+            continue\n+        }\n+        let path = PathBuf::from(t!(str::from_utf8(part)));\n+        paths.push(path);\n+    }\n+    paths\n+}\n+\n /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n /// when this function is called.\n pub fn cp_r(src: &Path, dst: &Path) {"}]}