{"sha": "57e13e0325c1d41161a31de1f8520538ec2c575c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZTEzZTAzMjVjMWQ0MTE2MWEzMWRlMWY4NTIwNTM4ZWMyYzU3NWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-09T02:07:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-09T02:07:44Z"}, "message": "Auto merge of #61653 - oli-obk:visit_place_recursion, r=spastorino\n\nget rid of visit_place recursion\n\nr? @spastorino\n\nthis is groundwork for https://github.com/rust-lang/rust/pull/60913, since after that PR we won't be able to implement `visit_place` in a recursive manner without heavy cloning everywhere.\n\ncc @eddyb this touches const qualif", "tree": {"sha": "eae860a149da01fda01c8ec92854c500e5a18005", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eae860a149da01fda01c8ec92854c500e5a18005"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57e13e0325c1d41161a31de1f8520538ec2c575c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57e13e0325c1d41161a31de1f8520538ec2c575c", "html_url": "https://github.com/rust-lang/rust/commit/57e13e0325c1d41161a31de1f8520538ec2c575c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57e13e0325c1d41161a31de1f8520538ec2c575c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "053666f9062d71091ea7970dcbad5963097191a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/053666f9062d71091ea7970dcbad5963097191a3", "html_url": "https://github.com/rust-lang/rust/commit/053666f9062d71091ea7970dcbad5963097191a3"}, {"sha": "b137a4729fa6133e4977e3a356e22ffb50e30410", "url": "https://api.github.com/repos/rust-lang/rust/commits/b137a4729fa6133e4977e3a356e22ffb50e30410", "html_url": "https://github.com/rust-lang/rust/commit/b137a4729fa6133e4977e3a356e22ffb50e30410"}], "stats": {"total": 261, "additions": 142, "deletions": 119}, "files": [{"sha": "b48fc3a83b037794ad87c558aa78fe99ca7cec3e", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/57e13e0325c1d41161a31de1f8520538ec2c575c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e13e0325c1d41161a31de1f8520538ec2c575c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=57e13e0325c1d41161a31de1f8520538ec2c575c", "patch": "@@ -160,8 +160,9 @@ macro_rules! make_mir_visitor {\n \n             fn visit_projection(&mut self,\n                                 place: & $($mutability)? Projection<'tcx>,\n+                                context: PlaceContext,\n                                 location: Location) {\n-                self.super_projection(place, location);\n+                self.super_projection(place, context, location);\n             }\n \n             fn visit_constant(&mut self,\n@@ -686,8 +687,7 @@ macro_rules! make_mir_visitor {\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n                         };\n \n-                        self.visit_place(& $($mutability)? proj.base, context, location);\n-                        self.visit_projection(proj, location);\n+                        self.visit_projection(proj, context, location);\n                     }\n                 }\n             }\n@@ -708,7 +708,12 @@ macro_rules! make_mir_visitor {\n \n             fn super_projection(&mut self,\n                                 proj: & $($mutability)? Projection<'tcx>,\n+                                context: PlaceContext,\n                                 location: Location) {\n+                // this is calling `super_place` in preparation for changing `Place` to be\n+                // a struct with a base and a slice of projections. `visit_place` should only ever\n+                // be called for the outermost place now.\n+                self.super_place(& $($mutability)? proj.base, context, location);\n                 match & $($mutability)? proj.elem {\n                     ProjectionElem::Deref => {\n                     }"}, {"sha": "35640e9a45e599deb29ecdb5ab19833bd093d564", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/57e13e0325c1d41161a31de1f8520538ec2c575c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e13e0325c1d41161a31de1f8520538ec2c575c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=57e13e0325c1d41161a31de1f8520538ec2c575c", "patch": "@@ -103,11 +103,11 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n                     place: &mut Place<'tcx>,\n                     context: PlaceContext,\n                     location: Location) {\n-        if *place == Place::Base(PlaceBase::Local(self_arg())) {\n-            *place = Place::Projection(Box::new(Projection {\n-                base: place.clone(),\n+        if place.base_local() == Some(self_arg()) {\n+            replace_base(place, Place::Projection(Box::new(Projection {\n+                base: Place::Base(PlaceBase::Local(self_arg())),\n                 elem: ProjectionElem::Deref,\n-            }));\n+            })));\n         } else {\n             self.super_place(place, context, location);\n         }\n@@ -130,17 +130,25 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n                     place: &mut Place<'tcx>,\n                     context: PlaceContext,\n                     location: Location) {\n-        if *place == Place::Base(PlaceBase::Local(self_arg())) {\n-            *place = Place::Projection(Box::new(Projection {\n-                base: place.clone(),\n+        if place.base_local() == Some(self_arg()) {\n+            replace_base(place, Place::Projection(Box::new(Projection {\n+                base: Place::Base(PlaceBase::Local(self_arg())),\n                 elem: ProjectionElem::Field(Field::new(0), self.ref_gen_ty),\n-            }));\n+            })));\n         } else {\n             self.super_place(place, context, location);\n         }\n     }\n }\n \n+fn replace_base(place: &mut Place<'tcx>, new_base: Place<'tcx>) {\n+    if let Place::Projection(proj) = place {\n+        replace_base(&mut proj.base, new_base);\n+    } else {\n+        *place = new_base;\n+    }\n+}\n+\n fn self_arg() -> Local {\n     Local::new(1)\n }\n@@ -236,10 +244,10 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n                     place: &mut Place<'tcx>,\n                     context: PlaceContext,\n                     location: Location) {\n-        if let Place::Base(PlaceBase::Local(l)) = *place {\n+        if let Some(l) = place.base_local() {\n             // Replace an Local in the remap with a generator struct access\n             if let Some(&(ty, variant_index, idx)) = self.remap.get(&l) {\n-                *place = self.make_field(variant_index, idx, ty);\n+                replace_base(place, self.make_field(variant_index, idx, ty));\n             }\n         } else {\n             self.super_place(place, context, location);"}, {"sha": "64aecee633719db131ba97d21f95ddaf9aa98a07", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 116, "deletions": 106, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/57e13e0325c1d41161a31de1f8520538ec2c575c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e13e0325c1d41161a31de1f8520538ec2c575c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=57e13e0325c1d41161a31de1f8520538ec2c575c", "patch": "@@ -926,125 +926,135 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n /// For functions (constant or not), it also records\n /// candidates for promotion in `promotion_candidates`.\n impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n-    fn visit_place(&mut self,\n-                    place: &Place<'tcx>,\n-                    context: PlaceContext,\n-                    location: Location) {\n-        debug!(\"visit_place: place={:?} context={:?} location={:?}\", place, context, location);\n-        place.iterate(|place_base, place_projections| {\n-            match place_base {\n-                PlaceBase::Local(_) => {}\n-                PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. }) => {\n-                    unreachable!()\n-                }\n-                PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. }) => {\n-                    if self.tcx\n-                           .get_attrs(*def_id)\n-                           .iter()\n-                           .any(|attr| attr.check_name(sym::thread_local)) {\n-                        if self.mode != Mode::Fn {\n-                            span_err!(self.tcx.sess, self.span, E0625,\n-                                      \"thread-local statics cannot be \\\n-                                       accessed at compile-time\");\n-                        }\n-                        return;\n+    fn visit_place_base(\n+        &mut self,\n+        place_base: &PlaceBase<'tcx>,\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n+        self.super_place_base(place_base, context, location);\n+        match place_base {\n+            PlaceBase::Local(_) => {}\n+            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. }) => {\n+                unreachable!()\n+            }\n+            PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. }) => {\n+                if self.tcx\n+                        .get_attrs(*def_id)\n+                        .iter()\n+                        .any(|attr| attr.check_name(sym::thread_local)) {\n+                    if self.mode != Mode::Fn {\n+                        span_err!(self.tcx.sess, self.span, E0625,\n+                                    \"thread-local statics cannot be \\\n+                                    accessed at compile-time\");\n                     }\n+                    return;\n+                }\n \n-                    // Only allow statics (not consts) to refer to other statics.\n-                    if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n-                        if self.mode == Mode::Static && context.is_mutating_use() {\n-                            // this is not strictly necessary as miri will also bail out\n-                            // For interior mutability we can't really catch this statically as that\n-                            // goes through raw pointers and intermediate temporaries, so miri has\n-                            // to catch this anyway\n-                            self.tcx.sess.span_err(\n-                                self.span,\n-                                \"cannot mutate statics in the initializer of another static\",\n-                            );\n-                        }\n-                        return;\n+                // Only allow statics (not consts) to refer to other statics.\n+                if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n+                    if self.mode == Mode::Static && context.is_mutating_use() {\n+                        // this is not strictly necessary as miri will also bail out\n+                        // For interior mutability we can't really catch this statically as that\n+                        // goes through raw pointers and intermediate temporaries, so miri has\n+                        // to catch this anyway\n+                        self.tcx.sess.span_err(\n+                            self.span,\n+                            \"cannot mutate statics in the initializer of another static\",\n+                        );\n                     }\n-                    unleash_miri!(self);\n+                    return;\n+                }\n+                unleash_miri!(self);\n \n-                    if self.mode != Mode::Fn {\n-                        let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n-                                                       \"{}s cannot refer to statics, use \\\n-                                                        a constant instead\", self.mode);\n-                        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                            err.note(\n-                                \"Static and const variables can refer to other const variables. \\\n-                                 But a const variable cannot refer to a static variable.\"\n-                            );\n-                            err.help(\n-                                \"To fix this, the value can be extracted as a const and then used.\"\n-                            );\n-                        }\n-                        err.emit()\n+                if self.mode != Mode::Fn {\n+                    let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n+                                                    \"{}s cannot refer to statics, use \\\n+                                                    a constant instead\", self.mode);\n+                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                        err.note(\n+                            \"Static and const variables can refer to other const variables. \\\n+                                But a const variable cannot refer to a static variable.\"\n+                        );\n+                        err.help(\n+                            \"To fix this, the value can be extracted as a const and then used.\"\n+                        );\n                     }\n+                    err.emit()\n                 }\n             }\n+        }\n+    }\n \n-            for proj in place_projections {\n-                match proj.elem {\n-                    ProjectionElem::Deref => {\n-                        if context.is_mutating_use() {\n-                            // `not_const` errors out in const contexts\n-                            self.not_const()\n-                        }\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n-                        match self.mode {\n-                            Mode::Fn => {},\n-                            _ => {\n-                                if let ty::RawPtr(_) = base_ty.sty {\n-                                    if !self.tcx.features().const_raw_ptr_deref {\n-                                        emit_feature_err(\n-                                            &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n-                                            self.span, GateIssue::Language,\n-                                            &format!(\n-                                                \"dereferencing raw pointers in {}s is unstable\",\n-                                                self.mode,\n-                                            ),\n-                                        );\n-                                    }\n-                                }\n+    fn visit_projection(\n+        &mut self,\n+        proj: &Projection<'tcx>,\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n+        debug!(\n+            \"visit_place_projection: proj={:?} context={:?} location={:?}\",\n+            proj, context, location,\n+        );\n+        self.super_projection(proj, context, location);\n+        match proj.elem {\n+            ProjectionElem::Deref => {\n+                if context.is_mutating_use() {\n+                    // `not_const` errors out in const contexts\n+                    self.not_const()\n+                }\n+                let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n+                match self.mode {\n+                    Mode::Fn => {},\n+                    _ => {\n+                        if let ty::RawPtr(_) = base_ty.sty {\n+                            if !self.tcx.features().const_raw_ptr_deref {\n+                                emit_feature_err(\n+                                    &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n+                                    self.span, GateIssue::Language,\n+                                    &format!(\n+                                        \"dereferencing raw pointers in {}s is unstable\",\n+                                        self.mode,\n+                                    ),\n+                                );\n                             }\n                         }\n                     }\n+                }\n+            }\n \n-                    ProjectionElem::ConstantIndex {..} |\n-                    ProjectionElem::Subslice {..} |\n-                    ProjectionElem::Field(..) |\n-                    ProjectionElem::Index(_) => {\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n-                        if let Some(def) = base_ty.ty_adt_def() {\n-                            if def.is_union() {\n-                                match self.mode {\n-                                    Mode::ConstFn => {\n-                                        if !self.tcx.features().const_fn_union {\n-                                            emit_feature_err(\n-                                                &self.tcx.sess.parse_sess, sym::const_fn_union,\n-                                                self.span, GateIssue::Language,\n-                                                \"unions in const fn are unstable\",\n-                                            );\n-                                        }\n-                                    },\n-\n-                                    | Mode::Fn\n-                                    | Mode::Static\n-                                    | Mode::StaticMut\n-                                    | Mode::Const\n-                                    => {},\n+            ProjectionElem::ConstantIndex {..} |\n+            ProjectionElem::Subslice {..} |\n+            ProjectionElem::Field(..) |\n+            ProjectionElem::Index(_) => {\n+                let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n+                if let Some(def) = base_ty.ty_adt_def() {\n+                    if def.is_union() {\n+                        match self.mode {\n+                            Mode::ConstFn => {\n+                                if !self.tcx.features().const_fn_union {\n+                                    emit_feature_err(\n+                                        &self.tcx.sess.parse_sess, sym::const_fn_union,\n+                                        self.span, GateIssue::Language,\n+                                        \"unions in const fn are unstable\",\n+                                    );\n                                 }\n-                            }\n-                        }\n-                    }\n+                            },\n \n-                    ProjectionElem::Downcast(..) => {\n-                        self.not_const()\n+                            | Mode::Fn\n+                            | Mode::Static\n+                            | Mode::StaticMut\n+                            | Mode::Const\n+                            => {},\n+                        }\n                     }\n                 }\n             }\n-        });\n+\n+            ProjectionElem::Downcast(..) => {\n+                self.not_const()\n+            }\n+        }\n     }\n \n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n@@ -1069,17 +1079,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         // Check nested operands and places.\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n             // Special-case reborrows.\n-            let mut is_reborrow = false;\n+            let mut reborrow_place = None;\n             if let Place::Projection(ref proj) = *place {\n                 if let ProjectionElem::Deref = proj.elem {\n                     let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.sty {\n-                        is_reborrow = true;\n+                        reborrow_place = Some(&proj.base);\n                     }\n                 }\n             }\n \n-            if is_reborrow {\n+            if let Some(place) = reborrow_place {\n                 let ctx = match kind {\n                     BorrowKind::Shared => PlaceContext::NonMutatingUse(\n                         NonMutatingUseContext::SharedBorrow,\n@@ -1094,7 +1104,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         MutatingUseContext::Borrow,\n                     ),\n                 };\n-                self.super_place(place, ctx, location);\n+                self.visit_place(place, ctx, location);\n             } else {\n                 self.super_rvalue(rvalue, location);\n             }"}]}