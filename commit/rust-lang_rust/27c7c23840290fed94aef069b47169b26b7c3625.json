{"sha": "27c7c23840290fed94aef069b47169b26b7c3625", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3YzdjMjM4NDAyOTBmZWQ5NGFlZjA2OWI0NzE2OWIyNmI3YzM2MjU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-20T01:29:45Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-20T01:31:50Z"}, "message": "Rename `waiting_cache`.\n\nThe name `waiting_cache` sounds like it is related to the states\n`NodeState::Waiting`, but it's not; the cache holds nodes of various\nstates.\n\nThis commit changes it to `active_state`.", "tree": {"sha": "8df744ccc786509e49e89b51ac39b4dc4445791c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8df744ccc786509e49e89b51ac39b4dc4445791c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27c7c23840290fed94aef069b47169b26b7c3625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27c7c23840290fed94aef069b47169b26b7c3625", "html_url": "https://github.com/rust-lang/rust/commit/27c7c23840290fed94aef069b47169b26b7c3625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27c7c23840290fed94aef069b47169b26b7c3625/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75fd4f754e344df63353eb530f31500455b904d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/75fd4f754e344df63353eb530f31500455b904d8", "html_url": "https://github.com/rust-lang/rust/commit/75fd4f754e344df63353eb530f31500455b904d8"}], "stats": {"total": 28, "additions": 14, "deletions": 14}, "files": [{"sha": "2b7c44cdac35b793748ad34cf2992a042133655d", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/27c7c23840290fed94aef069b47169b26b7c3625/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c7c23840290fed94aef069b47169b26b7c3625/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=27c7c23840290fed94aef069b47169b26b7c3625", "patch": "@@ -149,7 +149,7 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// A cache of the nodes in `nodes`, indexed by predicate. Unfortunately,\n     /// its contents are not guaranteed to match those of `nodes`. See the\n     /// comments in `process_obligation` for details.\n-    waiting_cache: FxHashMap<O::Predicate, usize>,\n+    active_cache: FxHashMap<O::Predicate, usize>,\n \n     /// A scratch vector reused in various operations, to avoid allocating new\n     /// vectors.\n@@ -278,7 +278,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         ObligationForest {\n             nodes: vec![],\n             done_cache: Default::default(),\n-            waiting_cache: Default::default(),\n+            active_cache: Default::default(),\n             scratch: RefCell::new(vec![]),\n             obligation_tree_id_generator: (0..).map(ObligationTreeId),\n             error_cache: Default::default(),\n@@ -303,15 +303,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n             return Ok(());\n         }\n \n-        match self.waiting_cache.entry(obligation.as_predicate().clone()) {\n+        match self.active_cache.entry(obligation.as_predicate().clone()) {\n             Entry::Occupied(o) => {\n                 debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n                        obligation, parent, o.get());\n                 let node = &mut self.nodes[*o.get()];\n                 if let Some(parent_index) = parent {\n-                    // If the node is already in `waiting_cache`, it has\n-                    // already had its chance to be marked with a parent. So if\n-                    // it's not already present, just dump `parent` into the\n+                    // If the node is already in `active_cache`, it has already\n+                    // had its chance to be marked with a parent. So if it's\n+                    // not already present, just dump `parent` into the\n                     // dependents as a non-parent.\n                     if !node.dependents.contains(&parent_index) {\n                         node.dependents.push(parent_index);\n@@ -405,8 +405,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n             // `processor.process_obligation` can modify the predicate within\n             // `node.obligation`, and that predicate is the key used for\n-            // `self.waiting_cache`. This means that `self.waiting_cache` can\n-            // get out of sync with `nodes`. It's not very common, but it does\n+            // `self.active_cache`. This means that `self.active_cache` can get\n+            // out of sync with `nodes`. It's not very common, but it does\n             // happen, and code in `compress` has to allow for it.\n             let result = match node.state.get() {\n                 NodeState::Pending => processor.process_obligation(&mut node.obligation),\n@@ -637,11 +637,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 }\n                 NodeState::Done => {\n                     // This lookup can fail because the contents of\n-                    // `self.waiting_cache` is not guaranteed to match those of\n+                    // `self.active_cache` is not guaranteed to match those of\n                     // `self.nodes`. See the comment in `process_obligation`\n                     // for more details.\n-                    if let Some((predicate, _)) = self.waiting_cache\n-                        .remove_entry(node.obligation.as_predicate())\n+                    if let Some((predicate, _)) =\n+                        self.active_cache.remove_entry(node.obligation.as_predicate())\n                     {\n                         self.done_cache.insert(predicate);\n                     } else {\n@@ -654,7 +654,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n-                    self.waiting_cache.remove(node.obligation.as_predicate());\n+                    self.active_cache.remove(node.obligation.as_predicate());\n                     node_rewrites[index] = nodes_len;\n                     dead_nodes += 1;\n                     self.insert_into_error_cache(index);\n@@ -714,9 +714,9 @@ impl<O: ForestObligation> ObligationForest<O> {\n             }\n         }\n \n-        // This updating of `self.waiting_cache` is necessary because the\n+        // This updating of `self.active_cache` is necessary because the\n         // removal of nodes within `compress` can fail. See above.\n-        self.waiting_cache.retain(|_predicate, index| {\n+        self.active_cache.retain(|_predicate, index| {\n             let new_index = node_rewrites[*index];\n             if new_index >= nodes_len {\n                 false"}]}