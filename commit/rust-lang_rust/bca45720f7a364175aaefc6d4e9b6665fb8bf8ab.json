{"sha": "bca45720f7a364175aaefc6d4e9b6665fb8bf8ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYTQ1NzIwZjdhMzY0MTc1YWFlZmM2ZDRlOWI2NjY1ZmI4YmY4YWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-01T00:29:54Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-01T17:45:30Z"}, "message": "Remove the environment concept from front::eval\n\nThis is the old method of conditional compilation. It is going away.\n\nIssue #489", "tree": {"sha": "93bdb4a4b6930bc098c03691ed3090242371fb69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93bdb4a4b6930bc098c03691ed3090242371fb69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bca45720f7a364175aaefc6d4e9b6665fb8bf8ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bca45720f7a364175aaefc6d4e9b6665fb8bf8ab", "html_url": "https://github.com/rust-lang/rust/commit/bca45720f7a364175aaefc6d4e9b6665fb8bf8ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bca45720f7a364175aaefc6d4e9b6665fb8bf8ab/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70a28dc23829e849a31d479a59933b5f13e4cce6", "url": "https://api.github.com/repos/rust-lang/rust/commits/70a28dc23829e849a31d479a59933b5f13e4cce6", "html_url": "https://github.com/rust-lang/rust/commit/70a28dc23829e849a31d479a59933b5f13e4cce6"}], "stats": {"total": 126, "additions": 51, "deletions": 75}, "files": [{"sha": "97e7585f0d799ff7e56d49894a79fea8b669cb25", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bca45720f7a364175aaefc6d4e9b6665fb8bf8ab/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca45720f7a364175aaefc6d4e9b6665fb8bf8ab/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=bca45720f7a364175aaefc6d4e9b6665fb8bf8ab", "patch": "@@ -6,6 +6,7 @@ import front::parser;\n import front::token;\n import front::eval;\n import front::ast;\n+import front::attr;\n import middle::trans;\n import middle::resolve;\n import middle::ty;\n@@ -35,22 +36,25 @@ import back::link::output_type;\n \n tag pp_mode { ppm_normal; ppm_typed; ppm_identified; }\n \n-fn default_environment(session::session sess, str argv0, str input) ->\n-   eval::env {\n+fn default_configuration(session::session sess, str argv0, str input) ->\n+    ast::crate_cfg {\n     auto libc =\n         alt (sess.get_targ_cfg().os) {\n             case (session::os_win32) { \"msvcrt.dll\" }\n             case (session::os_macos) { \"libc.dylib\" }\n             case (session::os_linux) { \"libc.so.6\" }\n             case (_) { \"libc.so\" }\n         };\n+\n+    auto mk = attr::mk_name_value_item;\n+\n     ret [ // Target bindings.\n-         tup(\"target_os\", eval::val_str(std::os::target_os())),\n-         tup(\"target_arch\", eval::val_str(\"x86\")),\n-         tup(\"target_libc\", eval::val_str(libc)),\n+         mk(\"target_os\", std::os::target_os()),\n+         mk(\"target_arch\", \"x86\"),\n+         mk(\"target_libc\", libc),\n          // Build bindings.\n-         tup(\"build_compiler\", eval::val_str(argv0)),\n-         tup(\"build_input\", eval::val_str(input))];\n+         mk(\"build_compiler\", argv0),\n+         mk(\"build_input\", input)];\n }\n \n fn parse_input(session::session sess, parser::parser p, str input) ->\n@@ -73,10 +77,10 @@ fn time[T](bool do_it, str what, fn() -> T  thunk) -> T {\n     ret rv;\n }\n \n-fn compile_input(session::session sess, eval::env env, str input,\n+fn compile_input(session::session sess, ast::crate_cfg cfg, str input,\n                  str output) {\n     auto time_passes = sess.get_opts().time_passes;\n-    auto p = parser::new_parser(sess, env, input, 0u, 0);\n+    auto p = parser::new_parser(sess, cfg, input, 0u, 0);\n     auto crate =\n         time(time_passes, \"parsing\", bind parse_input(sess, p, input));\n     if (sess.get_opts().output_type == link::output_type_none) { ret; }\n@@ -104,9 +108,9 @@ fn compile_input(session::session sess, eval::env env, str input,\n              bind link::write::run_passes(sess, llmod, output));\n }\n \n-fn pretty_print_input(session::session sess, eval::env env, str input,\n-                      pp_mode ppm) {\n-    auto p = front::parser::new_parser(sess, env, input, 0u, 0);\n+fn pretty_print_input(session::session sess, ast::crate_cfg cfg,\n+                      str input, pp_mode ppm) {\n+    auto p = front::parser::new_parser(sess, cfg, input, 0u, 0);\n     auto crate = parse_input(sess, p, input);\n     auto mode;\n     alt (ppm) {\n@@ -337,15 +341,15 @@ fn main(vec[str] args) {\n     }\n     auto ifile = match.free.(0);\n     let str saved_out_filename = \"\";\n-    auto env = default_environment(sess, binary, ifile);\n+    auto cfg = default_configuration(sess, binary, ifile);\n     auto pretty =\n         option::map[str,\n                     pp_mode](bind parse_pretty(sess, _),\n                              getopts::opt_default(match, \"pretty\", \"normal\"));\n     auto ls = opt_present(match, \"ls\");\n     alt (pretty) {\n         case (some[pp_mode](?ppm)) {\n-            pretty_print_input(sess, env, ifile, ppm);\n+            pretty_print_input(sess, cfg, ifile, ppm);\n             ret;\n         }\n         case (none[pp_mode]) {/* continue */ }\n@@ -371,7 +375,7 @@ fn main(vec[str] args) {\n                 case (link::output_type_exe) { parts += [\"o\"]; }\n             }\n             auto ofile = str::connect(parts, \".\");\n-            compile_input(sess, env, ifile, ofile);\n+            compile_input(sess, cfg, ifile, ofile);\n         }\n         case (some(?ofile)) {\n             // FIXME: what about windows? This will create a foo.exe.o.\n@@ -386,7 +390,7 @@ fn main(vec[str] args) {\n                 }\n                 case (_) { temp_filename = ofile; }\n             }\n-            compile_input(sess, env, ifile, temp_filename);\n+            compile_input(sess, cfg, ifile, temp_filename);\n         }\n     }\n "}, {"sha": "df79499231160d624aad1195f9973c3b3cae0f33", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 26, "deletions": 41, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bca45720f7a364175aaefc6d4e9b6665fb8bf8ab/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca45720f7a364175aaefc6d4e9b6665fb8bf8ab/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=bca45720f7a364175aaefc6d4e9b6665fb8bf8ab", "patch": "@@ -23,17 +23,14 @@ tag val { val_bool(bool); val_int(int); val_str(str); }\n \n tag eval_mode { mode_depend; mode_parse; }\n \n-type env = vec[tup(ident, val)];\n-\n type ctx =\n     @rec(parser p,\n          eval_mode mode,\n          mutable vec[str] deps,\n          session::session sess,\n          mutable uint chpos,\n-         mutable int next_id);\n-\n-fn mk_env() -> env { ret []; }\n+         mutable int next_id,\n+         ast::crate_cfg cfg);\n \n fn val_is_bool(val v) -> bool {\n     alt (v) { case (val_bool(_)) { true } case (_) { false } }\n@@ -59,13 +56,6 @@ fn val_as_str(val v) -> str {\n     alt (v) { case (val_str(?s)) { s } case (_) { fail } }\n }\n \n-fn lookup(session::session sess, env e, span sp, ident i) -> val {\n-    for (tup(ident, val) pair in e) {\n-        if (str::eq(i, pair._0)) { ret pair._1; }\n-    }\n-    sess.span_fatal(sp, \"unknown variable: \" + i)\n-}\n-\n fn eval_lit(ctx cx, span sp, @ast::lit lit) -> val {\n     alt (lit.node) {\n         case (ast::lit_bool(?b)) { val_bool(b) }\n@@ -75,18 +65,14 @@ fn eval_lit(ctx cx, span sp, @ast::lit lit) -> val {\n     }\n }\n \n-fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n+fn eval_expr(ctx cx, @ast::expr x) -> val {\n     alt (x.node) {\n         case (ast::expr_path(?pth)) {\n-            if (vec::len[ident](pth.node.idents) == 1u &&\n-                    vec::len[@ast::ty](pth.node.types) == 0u) {\n-                ret lookup(cx.sess, e, x.span, pth.node.idents.(0));\n-            }\n             cx.sess.span_fatal(x.span, \"evaluating structured path-name\");\n         }\n         case (ast::expr_lit(?lit)) { ret eval_lit(cx, x.span, lit); }\n         case (ast::expr_unary(?op, ?a)) {\n-            auto av = eval_expr(cx, e, a);\n+            auto av = eval_expr(cx, a);\n             alt (op) {\n                 case (ast::not) {\n                     if (val_is_bool(av)) { ret val_bool(!val_as_bool(av)); }\n@@ -98,8 +84,8 @@ fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n             }\n         }\n         case (ast::expr_binary(?op, ?a, ?b)) {\n-            auto av = eval_expr(cx, e, a);\n-            auto bv = eval_expr(cx, e, b);\n+            auto av = eval_expr(cx, a);\n+            auto bv = eval_expr(cx, b);\n             alt (op) {\n                 case (ast::add) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n@@ -177,30 +163,30 @@ fn val_eq(session::session sess, span sp, val av, val bv) -> bool {\n     } else { sess.span_fatal(sp, \"bad types in comparison\") }\n }\n \n-fn eval_crate_directives(ctx cx, env e, vec[@ast::crate_directive] cdirs,\n+fn eval_crate_directives(ctx cx, vec[@ast::crate_directive] cdirs,\n                          str prefix, &mutable vec[@ast::view_item] view_items,\n                          &mutable vec[@ast::item] items) {\n     for (@ast::crate_directive sub_cdir in cdirs) {\n-        eval_crate_directive(cx, e, sub_cdir, prefix, view_items, items);\n+        eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n     }\n }\n \n-fn eval_crate_directives_to_mod(ctx cx, env e,\n+fn eval_crate_directives_to_mod(ctx cx,\n                                 vec[@ast::crate_directive] cdirs, str prefix)\n    -> ast::_mod {\n     let vec[@ast::view_item] view_items = [];\n     let vec[@ast::item] items = [];\n-    eval_crate_directives(cx, e, cdirs, prefix, view_items, items);\n+    eval_crate_directives(cx, cdirs, prefix, view_items, items);\n     ret rec(view_items=view_items, items=items);\n }\n \n-fn eval_crate_directive_block(ctx cx, env e, &ast::block blk, str prefix,\n+fn eval_crate_directive_block(ctx cx, &ast::block blk, str prefix,\n                               &mutable vec[@ast::view_item] view_items,\n                               &mutable vec[@ast::item] items) {\n     for (@ast::stmt s in blk.node.stmts) {\n         alt (s.node) {\n             case (ast::stmt_crate_directive(?cdir)) {\n-                eval_crate_directive(cx, e, cdir, prefix, view_items, items);\n+                eval_crate_directive(cx, cdir, prefix, view_items, items);\n             }\n             case (_) {\n                 cx.sess.span_fatal(s.span,\n@@ -210,22 +196,22 @@ fn eval_crate_directive_block(ctx cx, env e, &ast::block blk, str prefix,\n     }\n }\n \n-fn eval_crate_directive_expr(ctx cx, env e, @ast::expr x, str prefix,\n+fn eval_crate_directive_expr(ctx cx, @ast::expr x, str prefix,\n                              &mutable vec[@ast::view_item] view_items,\n                              &mutable vec[@ast::item] items) {\n     alt (x.node) {\n         case (ast::expr_if(?cond, ?thn, ?elopt)) {\n-            auto cv = eval_expr(cx, e, cond);\n+            auto cv = eval_expr(cx, cond);\n             if (!val_is_bool(cv)) {\n                 cx.sess.span_fatal(x.span, \"bad cond type in 'if'\");\n             }\n             if (val_as_bool(cv)) {\n-                ret eval_crate_directive_block(cx, e, thn, prefix, view_items,\n+                ret eval_crate_directive_block(cx, thn, prefix, view_items,\n                                                items);\n             }\n             alt (elopt) {\n                 case (some(?els)) {\n-                    ret eval_crate_directive_expr(cx, e, els, prefix,\n+                    ret eval_crate_directive_expr(cx, els, prefix,\n                                                   view_items, items);\n                 }\n                 case (_) {\n@@ -235,19 +221,19 @@ fn eval_crate_directive_expr(ctx cx, env e, @ast::expr x, str prefix,\n             }\n         }\n         case (ast::expr_alt(?v, ?arms)) {\n-            auto vv = eval_expr(cx, e, v);\n+            auto vv = eval_expr(cx, v);\n             for (ast::arm arm in arms) {\n                 alt (arm.pat.node) {\n                     case (ast::pat_lit(?lit, _)) {\n                         auto pv = eval_lit(cx, arm.pat.span, lit);\n                         if (val_eq(cx.sess, arm.pat.span, vv, pv)) {\n-                            ret eval_crate_directive_block(cx, e, arm.block,\n+                            ret eval_crate_directive_block(cx, arm.block,\n                                                            prefix, view_items,\n                                                            items);\n                         }\n                     }\n                     case (ast::pat_wild(_)) {\n-                        ret eval_crate_directive_block(cx, e, arm.block,\n+                        ret eval_crate_directive_block(cx, arm.block,\n                                                        prefix, view_items,\n                                                        items);\n                     }\n@@ -260,24 +246,23 @@ fn eval_crate_directive_expr(ctx cx, env e, @ast::expr x, str prefix,\n             cx.sess.span_fatal(x.span, \"no cases matched in 'alt'\");\n         }\n         case (ast::expr_block(?block)) {\n-            ret eval_crate_directive_block(cx, e, block, prefix, view_items,\n+            ret eval_crate_directive_block(cx, block, prefix, view_items,\n                                            items);\n         }\n         case (_) { cx.sess.span_fatal(x.span, \"unsupported expr type\"); }\n     }\n }\n \n-fn eval_crate_directive(ctx cx, env e, @ast::crate_directive cdir, str prefix,\n+fn eval_crate_directive(ctx cx, @ast::crate_directive cdir, str prefix,\n                         &mutable vec[@ast::view_item] view_items,\n                         &mutable vec[@ast::item] items) {\n     alt (cdir.node) {\n         case (ast::cdir_let(?id, ?x, ?cdirs)) {\n-            auto v = eval_expr(cx, e, x);\n-            auto e0 = [tup(id, v)] + e;\n-            eval_crate_directives(cx, e0, cdirs, prefix, view_items, items);\n+            auto v = eval_expr(cx, x);\n+            eval_crate_directives(cx, cdirs, prefix, view_items, items);\n         }\n         case (ast::cdir_expr(?x)) {\n-            eval_crate_directive_expr(cx, e, x, prefix, view_items, items);\n+            eval_crate_directive_expr(cx, x, prefix, view_items, items);\n         }\n         case (ast::cdir_src_mod(?id, ?file_opt, ?attrs)) {\n             auto file_path = id + \".rs\";\n@@ -292,7 +277,7 @@ fn eval_crate_directive(ctx cx, env e, @ast::crate_directive cdir, str prefix,\n             };\n             if (cx.mode == mode_depend) { cx.deps += [full_path]; ret; }\n             auto p0 =\n-                new_parser(cx.sess, e, full_path, cx.chpos,\n+                new_parser(cx.sess, cx.cfg, full_path, cx.chpos,\n                            cx.next_id);\n             auto inner_attrs = parse_inner_attrs_and_next(p0);\n             auto mod_attrs = attrs + inner_attrs._0;\n@@ -315,7 +300,7 @@ fn eval_crate_directive(ctx cx, env e, @ast::crate_directive cdir, str prefix,\n             } else {\n                 prefix + std::fs::path_sep() + path\n             };\n-            auto m0 = eval_crate_directives_to_mod(cx, e, cdirs, full_path);\n+            auto m0 = eval_crate_directives_to_mod(cx, cdirs, full_path);\n             auto i = @rec(ident=id,\n                           attrs=attrs,\n                           id=cx.next_id,"}, {"sha": "0d86d5d949ed056f4ce46af4a5fe01d299e2c0c5", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bca45720f7a364175aaefc6d4e9b6665fb8bf8ab/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca45720f7a364175aaefc6d4e9b6665fb8bf8ab/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=bca45720f7a364175aaefc6d4e9b6665fb8bf8ab", "patch": "@@ -32,7 +32,6 @@ type parser =\n         fn restrict(restriction) ;\n         fn get_restriction() -> restriction ;\n         fn get_file_type() -> file_type ;\n-        fn get_env() -> eval::env ;\n         fn get_cfg() -> ast::crate_cfg;\n         fn get_session() -> session::session ;\n         fn get_span() -> common::span ;\n@@ -50,10 +49,9 @@ type parser =\n         fn next_id() -> ast::node_id ;\n     };\n \n-fn new_parser(session::session sess, eval::env env,\n+fn new_parser(session::session sess, ast::crate_cfg cfg,\n               str path, uint pos, ast::node_id next_id) -> parser {\n     obj stdio_parser(session::session sess,\n-                     eval::env env,\n                      ast::crate_cfg cfg,\n                      file_type ftype,\n                      mutable token::token tok,\n@@ -85,7 +83,6 @@ fn new_parser(session::session sess, eval::env env,\n         fn get_hi_pos() -> uint { ret hi; }\n         fn get_last_lo_pos() -> uint { ret last_lo; }\n         fn get_file_type() -> file_type { ret ftype; }\n-        fn get_env() -> eval::env { ret env; }\n         fn get_cfg() -> ast::crate_cfg { ret cfg; }\n         fn get_prec_table() -> vec[op_spec] { ret precs; }\n         fn get_str(token::str_num i) -> str {\n@@ -106,17 +103,6 @@ fn new_parser(session::session sess, eval::env env,\n         fn next_id() -> ast::node_id { ret next_id_var; }\n     }\n \n-    auto cfg = {\n-        fn m(&tup(ast::ident, eval::val) item) -> @ast::meta_item {\n-            auto name = item._0;\n-            auto value = eval::val_as_str(item._1);\n-            auto meta_item_ = ast::meta_name_value(name, value);\n-            ret @rec(node=meta_item_,\n-                     span=rec(lo=0u,hi=0u));\n-        }\n-        vec::map(m, env)\n-    };\n-\n     auto ftype = SOURCE_FILE;\n     if (str::ends_with(path, \".rc\")) { ftype = CRATE_FILE; }\n     auto srdr = io::file_reader(path);\n@@ -128,7 +114,7 @@ fn new_parser(session::session sess, eval::env env,\n \n     lexer::consume_whitespace_and_comments(rdr);\n     auto npos = rdr.get_chpos();\n-    ret stdio_parser(sess, env, cfg, ftype, lexer::next_token(rdr),\n+    ret stdio_parser(sess, cfg, ftype, lexer::next_token(rdr),\n                      npos, npos, npos, UNRESTRICTED, rdr,\n                      prec_table(), next_id, bad_expr_word_table(),\n                      ext::syntax_expander_table());\n@@ -2465,9 +2451,10 @@ fn parse_crate_from_crate_file(&parser p) -> @ast::crate {\n              mutable deps=deps,\n              sess=p.get_session(),\n              mutable chpos=p.get_chpos(),\n-             mutable next_id=p.next_id());\n+             mutable next_id=p.next_id(),\n+             cfg = p.get_cfg());\n     auto m =\n-        eval::eval_crate_directives_to_mod(cx, p.get_env(), cdirs, prefix);\n+        eval::eval_crate_directives_to_mod(cx, cdirs, prefix);\n     auto hi = p.get_hi_pos();\n     expect(p, token::EOF);\n     ret @spanned(lo, hi, rec(directives=cdirs,"}]}