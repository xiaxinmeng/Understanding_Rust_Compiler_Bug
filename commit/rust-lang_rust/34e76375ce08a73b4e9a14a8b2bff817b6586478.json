{"sha": "34e76375ce08a73b4e9a14a8b2bff817b6586478", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZTc2Mzc1Y2UwOGE3M2I0ZTlhMTRhOGIyYmZmODE3YjY1ODY0Nzg=", "commit": {"author": {"name": "Matthew Russo", "email": "mcr431@nyu.edu", "date": "2018-08-22T01:09:48Z"}, "committer": {"name": "Matthew Russo", "email": "mcr431@nyu.edu", "date": "2018-08-24T12:50:00Z"}, "message": "Removing GenericArgMismatchErrorCode.", "tree": {"sha": "9d2448bcf949a9703ff718ae53dc369e49bd1573", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d2448bcf949a9703ff718ae53dc369e49bd1573"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34e76375ce08a73b4e9a14a8b2bff817b6586478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34e76375ce08a73b4e9a14a8b2bff817b6586478", "html_url": "https://github.com/rust-lang/rust/commit/34e76375ce08a73b4e9a14a8b2bff817b6586478", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34e76375ce08a73b4e9a14a8b2bff817b6586478/comments", "author": null, "committer": null, "parents": [{"sha": "aa2abeaf342223da4da47b839b51549f7bcd5ef5", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2abeaf342223da4da47b839b51549f7bcd5ef5", "html_url": "https://github.com/rust-lang/rust/commit/aa2abeaf342223da4da47b839b51549f7bcd5ef5"}], "stats": {"total": 28, "additions": 2, "deletions": 26}, "files": [{"sha": "4f8f1f2325482eaffacf1eb25ec33f9eedf3a6e2", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/34e76375ce08a73b4e9a14a8b2bff817b6586478/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e76375ce08a73b4e9a14a8b2bff817b6586478/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=34e76375ce08a73b4e9a14a8b2bff817b6586478", "patch": "@@ -99,12 +99,6 @@ enum GenericArgPosition {\n     MethodCall,\n }\n \n-// FIXME(#53525): these error codes should all be unified.\n-struct GenericArgMismatchErrorCode {\n-    lifetimes: (&'static str, &'static str),\n-    types: (&'static str, &'static str),\n-}\n-\n /// Dummy type used for the `Self` of a `TraitRef` created for converting\n /// a trait object, and which gets removed in `ExistentialTraitRef`.\n /// This type must not appear anywhere in other converted types.\n@@ -262,10 +256,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             },\n             def.parent.is_none() && def.has_self, // `has_self`\n             seg.infer_types || suppress_mismatch, // `infer_types`\n-            GenericArgMismatchErrorCode {\n-                lifetimes: (\"E0090\", \"E0088\"),\n-                types: (\"E0089\", \"E0087\"),\n-            },\n         )\n     }\n \n@@ -279,7 +269,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         position: GenericArgPosition,\n         has_self: bool,\n         infer_types: bool,\n-        error_codes: GenericArgMismatchErrorCode,\n     ) -> bool {\n         // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n@@ -325,8 +314,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             }\n         }\n \n-        let check_kind_count = |error_code: (&str, &str),\n-                                kind,\n+        let check_kind_count = |kind,\n                                 required,\n                                 permitted,\n                                 provided,\n@@ -384,21 +372,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                     bound,\n                     provided,\n                 ),\n-                DiagnosticId::Error({\n-                    if provided <= permitted {\n-                        error_code.0\n-                    } else {\n-                        error_code.1\n-                    }\n-                }.into())\n+                DiagnosticId::Error(\"E0107\".into())\n             ).span_label(span, label).emit();\n \n             provided > required // `suppress_error`\n         };\n \n         if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n             check_kind_count(\n-                error_codes.lifetimes,\n                 \"lifetime\",\n                 param_counts.lifetimes,\n                 param_counts.lifetimes,\n@@ -409,7 +390,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         if !infer_types\n             || arg_counts.types > param_counts.types - defaults.types - has_self as usize {\n             check_kind_count(\n-                error_codes.types,\n                 \"type\",\n                 param_counts.types - defaults.types - has_self as usize,\n                 param_counts.types - has_self as usize,\n@@ -587,10 +567,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             GenericArgPosition::Type,\n             has_self,\n             infer_types,\n-            GenericArgMismatchErrorCode {\n-                lifetimes: (\"E0107\", \"E0107\"),\n-                types: (\"E0243\", \"E0244\"),\n-            },\n         );\n \n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);"}]}