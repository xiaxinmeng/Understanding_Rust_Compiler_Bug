{"sha": "12aa84bdf3231f563b7f86186dbece2023d1235a", "node_id": "C_kwDOAAsO6NoAKDEyYWE4NGJkZjMyMzFmNTYzYjdmODYxODZkYmVjZTIwMjNkMTIzNWE", "commit": {"author": {"name": "Jhonny Bill Mena", "email": "jhonnybillm@gmail.com", "date": "2022-10-03T03:21:15Z"}, "committer": {"name": "Jhonny Bill Mena", "email": "jhonnybillm@gmail.com", "date": "2022-10-07T14:03:45Z"}, "message": "ADD - initial port of link.rs", "tree": {"sha": "4f9a960361e85154898c9143c8ae3dec177cd040", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f9a960361e85154898c9143c8ae3dec177cd040"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12aa84bdf3231f563b7f86186dbece2023d1235a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12aa84bdf3231f563b7f86186dbece2023d1235a", "html_url": "https://github.com/rust-lang/rust/commit/12aa84bdf3231f563b7f86186dbece2023d1235a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12aa84bdf3231f563b7f86186dbece2023d1235a/comments", "author": {"login": "JhonnyBillM", "id": 18747072, "node_id": "MDQ6VXNlcjE4NzQ3MDcy", "avatar_url": "https://avatars.githubusercontent.com/u/18747072?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JhonnyBillM", "html_url": "https://github.com/JhonnyBillM", "followers_url": "https://api.github.com/users/JhonnyBillM/followers", "following_url": "https://api.github.com/users/JhonnyBillM/following{/other_user}", "gists_url": "https://api.github.com/users/JhonnyBillM/gists{/gist_id}", "starred_url": "https://api.github.com/users/JhonnyBillM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JhonnyBillM/subscriptions", "organizations_url": "https://api.github.com/users/JhonnyBillM/orgs", "repos_url": "https://api.github.com/users/JhonnyBillM/repos", "events_url": "https://api.github.com/users/JhonnyBillM/events{/privacy}", "received_events_url": "https://api.github.com/users/JhonnyBillM/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JhonnyBillM", "id": 18747072, "node_id": "MDQ6VXNlcjE4NzQ3MDcy", "avatar_url": "https://avatars.githubusercontent.com/u/18747072?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JhonnyBillM", "html_url": "https://github.com/JhonnyBillM", "followers_url": "https://api.github.com/users/JhonnyBillM/followers", "following_url": "https://api.github.com/users/JhonnyBillM/following{/other_user}", "gists_url": "https://api.github.com/users/JhonnyBillM/gists{/gist_id}", "starred_url": "https://api.github.com/users/JhonnyBillM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JhonnyBillM/subscriptions", "organizations_url": "https://api.github.com/users/JhonnyBillM/orgs", "repos_url": "https://api.github.com/users/JhonnyBillM/repos", "events_url": "https://api.github.com/users/JhonnyBillM/events{/privacy}", "received_events_url": "https://api.github.com/users/JhonnyBillM/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f97d4a1417cdf58b7a39e351dcdf40cf58e48b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f97d4a1417cdf58b7a39e351dcdf40cf58e48b9", "html_url": "https://github.com/rust-lang/rust/commit/0f97d4a1417cdf58b7a39e351dcdf40cf58e48b9"}], "stats": {"total": 224, "additions": 166, "deletions": 58}, "files": [{"sha": "ac2a8f969df00cf7d3fba6bbe66f400c79647268", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 37, "deletions": 52, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/12aa84bdf3231f563b7f86186dbece2023d1235a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12aa84bdf3231f563b7f86186dbece2023d1235a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=12aa84bdf3231f563b7f86186dbece2023d1235a", "patch": "@@ -31,7 +31,9 @@ use super::command::Command;\n use super::linker::{self, Linker};\n use super::metadata::{create_rmeta_file, MetadataPosition};\n use super::rpath::{self, RPathConfig};\n-use crate::{looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib};\n+use crate::{\n+    errors, looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib,\n+};\n \n use cc::windows_registry;\n use regex::Regex;\n@@ -93,7 +95,7 @@ pub fn link_binary<'a>(\n             let tmpdir = TempFileBuilder::new()\n                 .prefix(\"rustc\")\n                 .tempdir()\n-                .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+                .unwrap_or_else(|error| sess.emit_fatal(errors::CreateTempDir { error }));\n             let path = MaybeTempDir::new(tmpdir, sess.opts.cg.save_temps);\n             let out_filename = out_filename(\n                 sess,\n@@ -208,7 +210,7 @@ pub fn link_binary<'a>(\n pub fn each_linked_rlib(\n     info: &CrateInfo,\n     f: &mut dyn FnMut(CrateNum, &Path),\n-) -> Result<(), String> {\n+) -> Result<(), errors::LinkRlibError> {\n     let crates = info.used_crates.iter();\n     let mut fmts = None;\n     for (ty, list) in info.dependency_formats.iter() {\n@@ -224,26 +226,23 @@ pub fn each_linked_rlib(\n         }\n     }\n     let Some(fmts) = fmts else {\n-        return Err(\"could not find formats for rlibs\".to_string());\n+        return Err(errors::LinkRlibError::MissingFormat);\n     };\n     for &cnum in crates {\n         match fmts.get(cnum.as_usize() - 1) {\n             Some(&Linkage::NotLinked | &Linkage::IncludedFromDylib) => continue,\n             Some(_) => {}\n-            None => return Err(\"could not find formats for rlibs\".to_string()),\n+            None => return Err(errors::LinkRlibError::MissingFormat),\n         }\n-        let name = info.crate_name[&cnum];\n+        let crate_name = info.crate_name[&cnum];\n         let used_crate_source = &info.used_crate_source[&cnum];\n         if let Some((path, _)) = &used_crate_source.rlib {\n             f(cnum, &path);\n         } else {\n             if used_crate_source.rmeta.is_some() {\n-                return Err(format!(\n-                    \"could not find rlib for: `{}`, found rmeta (metadata) file\",\n-                    name\n-                ));\n+                return Err(errors::LinkRlibError::OnlyRmetaFound { crate_name });\n             } else {\n-                return Err(format!(\"could not find rlib for: `{}`\", name));\n+                return Err(errors::LinkRlibError::NotFound { crate_name });\n             }\n         }\n     }\n@@ -340,10 +339,7 @@ fn link_rlib<'a>(\n                 // -whole-archive and it isn't clear how we can currently handle such a\n                 // situation correctly.\n                 // See https://github.com/rust-lang/rust/issues/88085#issuecomment-901050897\n-                sess.err(\n-                    \"the linking modifiers `+bundle` and `+whole-archive` are not compatible \\\n-                        with each other when generating rlibs\",\n-                );\n+                sess.emit_err(errors::IncompatibleLinkingModifiers);\n             }\n             NativeLibKind::Static { bundle: None | Some(true), .. } => {}\n             NativeLibKind::Static { bundle: Some(false), .. }\n@@ -365,12 +361,11 @@ fn link_rlib<'a>(\n                 ));\n                 continue;\n             }\n-            ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|e| {\n-                sess.fatal(&format!(\n-                    \"failed to add native library {}: {}\",\n-                    location.to_string_lossy(),\n-                    e\n-                ));\n+            ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|error| {\n+                sess.emit_fatal(errors::AddNativeLibrary {\n+                    library_path: &location.to_string_lossy(),\n+                    error,\n+                });\n             });\n         }\n     }\n@@ -385,8 +380,11 @@ fn link_rlib<'a>(\n             tmpdir.as_ref(),\n         );\n \n-        ab.add_archive(&output_path, Box::new(|_| false)).unwrap_or_else(|e| {\n-            sess.fatal(&format!(\"failed to add native library {}: {}\", output_path.display(), e));\n+        ab.add_archive(&output_path, Box::new(|_| false)).unwrap_or_else(|error| {\n+            sess.emit_fatal(errors::AddNativeLibrary {\n+                library_path: &output_path.display().to_string(),\n+                error,\n+            });\n         });\n     }\n \n@@ -451,14 +449,11 @@ fn collate_raw_dylibs(\n                     // FIXME: when we add support for ordinals, figure out if we need to do anything\n                     // if we have two DllImport values with the same name but different ordinals.\n                     if import.calling_convention != old_import.calling_convention {\n-                        sess.span_err(\n-                            import.span,\n-                            &format!(\n-                                \"multiple declarations of external function `{}` from \\\n-                                 library `{}` have different calling conventions\",\n-                                import.name, name,\n-                            ),\n-                        );\n+                        sess.emit_err(errors::MultipleExternalFuncDecl {\n+                            span: import.span,\n+                            function: import.name,\n+                            library_name: &name,\n+                        });\n                     }\n                 }\n             }\n@@ -560,7 +555,7 @@ fn link_staticlib<'a>(\n         all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n     });\n     if let Err(e) = res {\n-        sess.fatal(&e);\n+        sess.emit_fatal(e);\n     }\n \n     ab.build(out_filename);\n@@ -673,9 +668,8 @@ fn link_dwarf_object<'a>(\n     }) {\n         Ok(()) => {}\n         Err(e) => {\n-            sess.struct_err(\"linking dwarf objects with thorin failed\")\n-                .note(&format!(\"{:?}\", e))\n-                .emit();\n+            let thorin_error = errors::ThorinErrorWrapper(e);\n+            sess.emit_err(errors::ThorinDwarfLinking { thorin_error });\n             sess.abort_if_errors();\n         }\n     }\n@@ -879,23 +873,14 @@ fn link_natively<'a>(\n                 let mut output = prog.stderr.clone();\n                 output.extend_from_slice(&prog.stdout);\n                 let escaped_output = escape_string(&output);\n-                let mut err = sess.struct_err(&format!(\n-                    \"linking with `{}` failed: {}\",\n-                    linker_path.display(),\n-                    prog.status\n-                ));\n-                err.note(&format!(\"{:?}\", &cmd)).note(&escaped_output);\n-                if escaped_output.contains(\"undefined reference to\") {\n-                    err.help(\n-                        \"some `extern` functions couldn't be found; some native libraries may \\\n-                         need to be installed or have their path specified\",\n-                    );\n-                    err.note(\"use the `-l` flag to specify native libraries to link\");\n-                    err.note(\"use the `cargo:rustc-link-lib` directive to specify the native \\\n-                              libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargorustc-link-libkindname)\");\n-                }\n-                err.emit();\n-\n+                // FIXME: Add UI tests for this error.\n+                let err = errors::LinkingFailed {\n+                    linker_path: &linker_path,\n+                    exit_status: prog.status,\n+                    command: &cmd,\n+                    escaped_output: &escaped_output,\n+                };\n+                sess.diagnostic().emit_err(err);\n                 // If MSVC's `link.exe` was expected but the return code\n                 // is not a Microsoft LNK error then suggest a way to fix or\n                 // install the Visual Studio build tools."}, {"sha": "6bd1dc2e03f66ed1747ffad5fc3019d09853cd6f", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 103, "deletions": 6, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/12aa84bdf3231f563b7f86186dbece2023d1235a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12aa84bdf3231f563b7f86186dbece2023d1235a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=12aa84bdf3231f563b7f86186dbece2023d1235a", "patch": "@@ -1,10 +1,16 @@\n //! Errors emitted by codegen_ssa\n \n-use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n+use crate::back::command::Command;\n+use rustc_errors::{\n+    fluent, DiagnosticArgValue, DiagnosticBuilder, ErrorGuaranteed, Handler, IntoDiagnostic,\n+    IntoDiagnosticArg,\n+};\n use rustc_macros::Diagnostic;\n+use rustc_span::{Span, Symbol};\n use std::borrow::Cow;\n use std::io::Error;\n use std::path::{Path, PathBuf};\n+use std::process::ExitStatus;\n \n #[derive(Diagnostic)]\n #[diag(codegen_ssa::lib_def_write_failure)]\n@@ -73,17 +79,15 @@ pub struct CopyPath<'a> {\n \n impl<'a> CopyPath<'a> {\n     pub fn new(from: &'a Path, to: &'a Path, error: Error) -> CopyPath<'a> {\n-        CopyPath { from: DebugArgPath { path: from }, to: DebugArgPath { path: to }, error }\n+        CopyPath { from: DebugArgPath(from), to: DebugArgPath(to), error }\n     }\n }\n \n-struct DebugArgPath<'a> {\n-    pub path: &'a Path,\n-}\n+struct DebugArgPath<'a>(pub &'a Path);\n \n impl IntoDiagnosticArg for DebugArgPath<'_> {\n     fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(format!(\"{:?}\", self.path)))\n+        DiagnosticArgValue::Str(Cow::Owned(format!(\"{:?}\", self.0)))\n     }\n }\n \n@@ -98,3 +102,96 @@ pub struct IgnoringEmitPath {\n pub struct IgnoringOutput {\n     pub extension: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::create_temp_dir)]\n+pub struct CreateTempDir {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::incompatible_linking_modifiers)]\n+pub struct IncompatibleLinkingModifiers;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::add_native_library)]\n+pub struct AddNativeLibrary<'a> {\n+    pub library_path: &'a str,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::multiple_external_func_decl)]\n+pub struct MultipleExternalFuncDecl<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub function: Symbol,\n+    pub library_name: &'a str,\n+}\n+\n+pub enum LinkRlibError {\n+    MissingFormat,\n+    OnlyRmetaFound { crate_name: Symbol },\n+    NotFound { crate_name: Symbol },\n+}\n+\n+impl IntoDiagnostic<'_, !> for LinkRlibError {\n+    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n+        match self {\n+            LinkRlibError::MissingFormat => {\n+                handler.struct_fatal(fluent::codegen_ssa::rlib_missing_format)\n+            }\n+            LinkRlibError::OnlyRmetaFound { crate_name } => {\n+                let mut diag = handler.struct_fatal(fluent::codegen_ssa::rlib_only_rmeta_found);\n+                diag.set_arg(\"crate_name\", crate_name);\n+                diag\n+            }\n+            LinkRlibError::NotFound { crate_name } => {\n+                let mut diag = handler.struct_fatal(fluent::codegen_ssa::rlib_not_found);\n+                diag.set_arg(\"crate_name\", crate_name);\n+                diag\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::thorin_dwarf_linking)]\n+#[note]\n+pub struct ThorinDwarfLinking {\n+    pub thorin_error: ThorinErrorWrapper,\n+}\n+pub struct ThorinErrorWrapper(pub thorin::Error);\n+\n+// FIXME: How should we support translations for external crate errors?\n+impl IntoDiagnosticArg for ThorinErrorWrapper {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(format!(\"{:?}\", self.0)))\n+    }\n+}\n+\n+pub struct LinkingFailed<'a> {\n+    pub linker_path: &'a PathBuf,\n+    pub exit_status: ExitStatus,\n+    pub command: &'a Command,\n+    pub escaped_output: &'a str,\n+}\n+\n+impl IntoDiagnostic<'_> for LinkingFailed<'_> {\n+    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_err(fluent::codegen_ssa::linking_failed);\n+        diag.set_arg(\"linker_path\", format!(\"{}\", self.linker_path.display()));\n+        diag.set_arg(\"exit_status\", format!(\"{}\", self.exit_status));\n+\n+        diag.note(format!(\"{:?}\", self.command)).note(self.escaped_output);\n+\n+        // Trying to match an error from OS linkers\n+        // which by now we have no way to translate.\n+        if self.escaped_output.contains(\"undefined reference to\") {\n+            diag.note(fluent::codegen_ssa::extern_funcs_not_found)\n+                .note(fluent::codegen_ssa::specify_libraries_to_link)\n+                .note(fluent::codegen_ssa::use_cargo_directive);\n+        }\n+        diag\n+    }\n+}"}, {"sha": "ceebe4d417f7d68b0014f8b75d80d6f150e97b36", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12aa84bdf3231f563b7f86186dbece2023d1235a/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12aa84bdf3231f563b7f86186dbece2023d1235a/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=12aa84bdf3231f563b7f86186dbece2023d1235a", "patch": "@@ -6,6 +6,7 @@\n #![feature(strict_provenance)]\n #![feature(int_roundings)]\n #![feature(if_let_guard)]\n+#![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "d996a096a892ea67ab7dc29522a2845a326f731a", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/12aa84bdf3231f563b7f86186dbece2023d1235a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/12aa84bdf3231f563b7f86186dbece2023d1235a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=12aa84bdf3231f563b7f86186dbece2023d1235a", "patch": "@@ -25,3 +25,28 @@ codegen_ssa_copy_path_buf = unable to copy {$source_file} to {$output_path}: {$e\n codegen_ssa_ignoring_emit_path = ignoring emit path because multiple .{$extension} files were produced\n \n codegen_ssa_ignoring_output = ignoring -o because multiple .{$extension} files were produced\n+\n+codegen_ssa_create_temp_dir = couldn't create a temp dir: {$error}\n+\n+codegen_ssa_incompatible_linking_modifiers = the linking modifiers `+bundle` and `+whole-archive` are not compatible with each other when generating rlibs\n+\n+codegen_ssa_add_native_library = failed to add native library {$library_path}: {$error}\n+\n+codegen_ssa_multiple_external_func_decl = multiple declarations of external function `{$function}` from library `{$library_name}` have different calling conventions\n+\n+codegen_ssa_rlib_missing_format = could not find formats for rlibs\n+\n+codegen_ssa_rlib_only_rmeta_found = could not find rlib for: `{$crate_name}`, found rmeta (metadata) file\n+\n+codegen_ssa_rlib_not_found = could not find rlib for: `{$crate_name}`\n+\n+codegen_ssa_thorin_dwarf_linking = linking dwarf objects with thorin failed\n+    .note = {$thorin_error}\n+\n+codegen_ssa_linking_failed = linking with `{$linker_path}` failed: {$exit_status}\n+\n+codegen_ssa_extern_funcs_not_found = some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n+\n+codegen_ssa_specify_libraries_to_link = use the `-l` flag to specify native libraries to link\n+\n+codegen_ssa_use_cargo_directive = use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargorustc-link-libkindname)"}]}