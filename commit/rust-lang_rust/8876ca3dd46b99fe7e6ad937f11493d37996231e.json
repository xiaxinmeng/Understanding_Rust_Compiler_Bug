{"sha": "8876ca3dd46b99fe7e6ad937f11493d37996231e", "node_id": "C_kwDOAAsO6NoAKDg4NzZjYTNkZDQ2Yjk5ZmU3ZTZhZDkzN2YxMTQ5M2QzNzk5NjIzMWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-06T22:37:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-06T22:37:54Z"}, "message": "Auto merge of #94597 - nnethercote:ConstAllocation, r=fee1-dead\n\nIntroduce `ConstAllocation`.\n\nCurrently some `Allocation`s are interned, some are not, and it's very\nhard to tell at a use point which is which.\n\nThis commit introduces `ConstAllocation` for the known-interned ones,\nwhich makes the division much clearer. `ConstAllocation::inner()` is\nused to get the underlying `Allocation`.\n\nIn some places it's natural to use an `Allocation`, in some it's natural\nto use a `ConstAllocation`, and in some places there's no clear choice.\nI've tried to make things look as nice as possible, while generally\nfavouring `ConstAllocation`, which is the type that embodies more\ninformation. This does require quite a few calls to `inner()`.\n\nThe commit also tweaks how `PartialOrd` works for `Interned`. The\nprevious code was too clever by half, building on `T: Ord` to make the\ncode shorter. That caused problems with deriving `PartialOrd` and `Ord`\nfor `ConstAllocation`, so I changed it to build on `T: PartialOrd`,\nwhich is slightly more verbose but much more standard and avoided the\nproblems.\n\nr? `@fee1-dead`", "tree": {"sha": "cf019658fc97dc581e45f15d0ca2a67cbfa9c7ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf019658fc97dc581e45f15d0ca2a67cbfa9c7ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8876ca3dd46b99fe7e6ad937f11493d37996231e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8876ca3dd46b99fe7e6ad937f11493d37996231e", "html_url": "https://github.com/rust-lang/rust/commit/8876ca3dd46b99fe7e6ad937f11493d37996231e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8876ca3dd46b99fe7e6ad937f11493d37996231e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38a0b81b1c32764d6a583a5efb6f306b8c44c503", "url": "https://api.github.com/repos/rust-lang/rust/commits/38a0b81b1c32764d6a583a5efb6f306b8c44c503", "html_url": "https://github.com/rust-lang/rust/commit/38a0b81b1c32764d6a583a5efb6f306b8c44c503"}, {"sha": "4852291417127d86c3f8404ef03cb1706d89a3e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4852291417127d86c3f8404ef03cb1706d89a3e6", "html_url": "https://github.com/rust-lang/rust/commit/4852291417127d86c3f8404ef03cb1706d89a3e6"}], "stats": {"total": 285, "additions": 166, "deletions": 119}, "files": [{"sha": "aff3603303a98ff8f90120303d3804bbac681487", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -4,7 +4,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::ErrorGuaranteed;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n-    read_target_uint, AllocId, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n+    read_target_uint, AllocId, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n use rustc_middle::ty::ConstKind;\n use rustc_span::DUMMY_SP;\n@@ -202,7 +202,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n                             &mut fx.constants_cx,\n                             fx.module,\n                             alloc_id,\n-                            alloc.mutability,\n+                            alloc.inner().mutability,\n                         );\n                         let local_data_id =\n                             fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n@@ -257,11 +257,15 @@ pub(crate) fn codegen_const_value<'tcx>(\n \n pub(crate) fn pointer_for_allocation<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    alloc: &'tcx Allocation,\n+    alloc: ConstAllocation<'tcx>,\n ) -> crate::pointer::Pointer {\n     let alloc_id = fx.tcx.create_memory_alloc(alloc);\n-    let data_id =\n-        data_id_for_alloc_id(&mut fx.constants_cx, &mut *fx.module, alloc_id, alloc.mutability);\n+    let data_id = data_id_for_alloc_id(\n+        &mut fx.constants_cx,\n+        &mut *fx.module,\n+        alloc_id,\n+        alloc.inner().mutability,\n+    );\n \n     let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n@@ -361,7 +365,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 let data_id = *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n                     module\n                         .declare_anonymous_data(\n-                            alloc.mutability == rustc_hir::Mutability::Mut,\n+                            alloc.inner().mutability == rustc_hir::Mutability::Mut,\n                             false,\n                         )\n                         .unwrap()\n@@ -386,6 +390,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n         }\n \n         let mut data_ctx = DataContext::new();\n+        let alloc = alloc.inner();\n         data_ctx.set_align(alloc.align.bytes());\n \n         if let Some(section_name) = section_name {\n@@ -429,7 +434,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                     continue;\n                 }\n                 GlobalAlloc::Memory(target_alloc) => {\n-                    data_id_for_alloc_id(cx, module, alloc_id, target_alloc.mutability)\n+                    data_id_for_alloc_id(cx, module, alloc_id, target_alloc.inner().mutability)\n                 }\n                 GlobalAlloc::Static(def_id) => {\n                     if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)"}, {"sha": "49022ebd3e26fd19dfd4ec31b914b123ce1303fb", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -159,7 +159,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 let idx_bytes = match idx_const {\n                     ConstValue::ByRef { alloc, offset } => {\n                         let size = Size::from_bytes(4 * ret_lane_count /* size_of([u32; ret_lane_count]) */);\n-                        alloc.get_bytes(fx, alloc_range(offset, size)).unwrap()\n+                        alloc.inner().get_bytes(fx, alloc_range(offset, size)).unwrap()\n                     }\n                     _ => unreachable!(\"{:?}\", idx_const),\n                 };"}, {"sha": "a80b8e5b76c7c365cbb63db1a00b657593edfed3", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -13,7 +13,7 @@ use rustc_codegen_ssa::traits::{\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty::ScalarInt;\n use rustc_middle::ty::layout::{TyAndLayout, LayoutOf};\n-use rustc_middle::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n+use rustc_middle::mir::interpret::{ConstAllocation, GlobalAlloc, Scalar};\n use rustc_span::Symbol;\n use rustc_target::abi::{self, HasDataLayout, Pointer, Size};\n \n@@ -230,6 +230,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                     match self.tcx.global_alloc(alloc_id) {\n                         GlobalAlloc::Memory(alloc) => {\n                             let init = const_alloc_to_gcc(self, alloc);\n+                            let alloc = alloc.inner();\n                             let value =\n                                 match alloc.mutability {\n                                     Mutability::Mut => self.static_addr_of_mut(init, alloc.align, None),\n@@ -262,21 +263,21 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         }\n     }\n \n-    fn const_data_from_alloc(&self, alloc: &Allocation) -> Self::Value {\n+    fn const_data_from_alloc(&self, alloc: ConstAllocation<'tcx>) -> Self::Value {\n         const_alloc_to_gcc(self, alloc)\n     }\n \n-    fn from_const_alloc(&self, layout: TyAndLayout<'tcx>, alloc: &Allocation, offset: Size) -> PlaceRef<'tcx, RValue<'gcc>> {\n-        assert_eq!(alloc.align, layout.align.abi);\n+    fn from_const_alloc(&self, layout: TyAndLayout<'tcx>, alloc: ConstAllocation<'tcx>, offset: Size) -> PlaceRef<'tcx, RValue<'gcc>> {\n+        assert_eq!(alloc.inner().align, layout.align.abi);\n         let ty = self.type_ptr_to(layout.gcc_type(self, true));\n         let value =\n             if layout.size == Size::ZERO {\n-                let value = self.const_usize(alloc.align.bytes());\n+                let value = self.const_usize(alloc.inner().align.bytes());\n                 self.context.new_cast(None, value, ty)\n             }\n             else {\n                 let init = const_alloc_to_gcc(self, alloc);\n-                let base_addr = self.static_addr_of(init, alloc.align, None);\n+                let base_addr = self.static_addr_of(init, alloc.inner().align, None);\n \n                 let array = self.const_bitcast(base_addr, self.type_i8p());\n                 let value = self.context.new_array_access(None, array, self.const_usize(offset.bytes())).get_address(None);"}, {"sha": "d53b15159fa44d3d135a56e3fdcff90c576b7a53", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs}\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::ty::layout::LayoutOf;\n-use rustc_middle::mir::interpret::{self, Allocation, ErrorHandled, Scalar as InterpScalar, read_target_uint};\n+use rustc_middle::mir::interpret::{self, ConstAllocation, ErrorHandled, Scalar as InterpScalar, read_target_uint};\n use rustc_span::Span;\n use rustc_span::def_id::DefId;\n use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRange};\n@@ -284,7 +284,8 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n-pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: &Allocation) -> RValue<'gcc> {\n+pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAllocation<'tcx>) -> RValue<'gcc> {\n+    let alloc = alloc.inner();\n     let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n@@ -338,7 +339,7 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: &Alloca\n     cx.const_struct(&llvals, true)\n }\n \n-pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id: DefId) -> Result<(RValue<'gcc>, &'tcx Allocation), ErrorHandled> {\n+pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id: DefId) -> Result<(RValue<'gcc>, ConstAllocation<'tcx>), ErrorHandled> {\n     let alloc = cx.tcx.eval_static_initializer(def_id)?;\n     Ok((const_alloc_to_gcc(cx, alloc), alloc))\n }"}, {"sha": "0a4254a55ac5e52c42272459ea96e2d01eb2b1ee", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -11,7 +11,7 @@ use rustc_ast::Mutability;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_middle::bug;\n-use rustc_middle::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n+use rustc_middle::mir::interpret::{ConstAllocation, GlobalAlloc, Scalar};\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_middle::ty::ScalarInt;\n use rustc_span::symbol::Symbol;\n@@ -249,6 +249,7 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 let (base_addr, base_addr_space) = match self.tcx.global_alloc(alloc_id) {\n                     GlobalAlloc::Memory(alloc) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n+                        let alloc = alloc.inner();\n                         let value = match alloc.mutability {\n                             Mutability::Mut => self.static_addr_of_mut(init, alloc.align, None),\n                             _ => self.static_addr_of(init, alloc.align, None),\n@@ -285,24 +286,25 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn const_data_from_alloc(&self, alloc: &Allocation) -> Self::Value {\n+    fn const_data_from_alloc(&self, alloc: ConstAllocation<'tcx>) -> Self::Value {\n         const_alloc_to_llvm(self, alloc)\n     }\n \n     fn from_const_alloc(\n         &self,\n         layout: TyAndLayout<'tcx>,\n-        alloc: &Allocation,\n+        alloc: ConstAllocation<'tcx>,\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n-        assert_eq!(alloc.align, layout.align.abi);\n+        let alloc_align = alloc.inner().align;\n+        assert_eq!(alloc_align, layout.align.abi);\n         let llty = self.type_ptr_to(layout.llvm_type(self));\n         let llval = if layout.size == Size::ZERO {\n-            let llval = self.const_usize(alloc.align.bytes());\n+            let llval = self.const_usize(alloc_align.bytes());\n             unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n         } else {\n             let init = const_alloc_to_llvm(self, alloc);\n-            let base_addr = self.static_addr_of(init, alloc.align, None);\n+            let base_addr = self.static_addr_of(init, alloc_align, None);\n \n             let llval = unsafe {\n                 llvm::LLVMRustConstInBoundsGEP2("}, {"sha": "7d3fe43eeab17d3f0bff7ca7ea88952a8b02d2f1", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -12,7 +12,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::interpret::{\n-    read_target_uint, Allocation, ErrorHandled, GlobalAlloc, InitChunk, Pointer,\n+    read_target_uint, Allocation, ConstAllocation, ErrorHandled, GlobalAlloc, InitChunk, Pointer,\n     Scalar as InterpScalar,\n };\n use rustc_middle::mir::mono::MonoItem;\n@@ -25,7 +25,8 @@ use rustc_target::abi::{\n use std::ops::Range;\n use tracing::debug;\n \n-pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n+pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<'_>) -> &'ll Value {\n+    let alloc = alloc.inner();\n     let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n@@ -127,7 +128,7 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) ->\n pub fn codegen_static_initializer<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     def_id: DefId,\n-) -> Result<(&'ll Value, &'tcx Allocation), ErrorHandled> {\n+) -> Result<(&'ll Value, ConstAllocation<'tcx>), ErrorHandled> {\n     let alloc = cx.tcx.eval_static_initializer(def_id)?;\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))\n }\n@@ -370,6 +371,7 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                 // Error has already been reported\n                 return;\n             };\n+            let alloc = alloc.inner();\n \n             let g = self.get_static(def_id);\n "}, {"sha": "918f36841695a194a5af533997f87e52cb2c2532", "filename": "compiler/rustc_codegen_ssa/src/traits/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -1,6 +1,6 @@\n use super::BackendTypes;\n use crate::mir::place::PlaceRef;\n-use rustc_middle::mir::interpret::{Allocation, Scalar};\n+use rustc_middle::mir::interpret::{ConstAllocation, Scalar};\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_span::Symbol;\n use rustc_target::abi::{self, Size};\n@@ -26,13 +26,13 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn const_to_opt_uint(&self, v: Self::Value) -> Option<u64>;\n     fn const_to_opt_u128(&self, v: Self::Value, sign_ext: bool) -> Option<u128>;\n \n-    fn const_data_from_alloc(&self, alloc: &Allocation) -> Self::Value;\n+    fn const_data_from_alloc(&self, alloc: ConstAllocation<'tcx>) -> Self::Value;\n \n     fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, llty: Self::Type) -> Self::Value;\n     fn from_const_alloc(\n         &self,\n         layout: TyAndLayout<'tcx>,\n-        alloc: &Allocation,\n+        alloc: ConstAllocation<'tcx>,\n         offset: Size,\n     ) -> PlaceRef<'tcx, Self::Value>;\n "}, {"sha": "df809e8270195862ffd27ceb39b81fa4f20011c5", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -367,7 +367,7 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                             \"the raw bytes of the constant ({}\",\n                             display_allocation(\n                                 *ecx.tcx,\n-                                ecx.tcx.global_alloc(alloc_id).unwrap_memory()\n+                                ecx.tcx.global_alloc(alloc_id).unwrap_memory().inner()\n                             )\n                         ));\n                     },"}, {"sha": "92f4d3a6772444d79638249261ddcbc8fd7aa48c", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -18,8 +18,8 @@ use rustc_target::abi::{Align, Size};\n use rustc_target::spec::abi::Abi;\n \n use crate::interpret::{\n-    self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, InterpCx, InterpResult, OpTy,\n-    PlaceTy, Scalar, StackPopUnwind,\n+    self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n+    OpTy, PlaceTy, Scalar, StackPopUnwind,\n };\n \n use super::error::*;\n@@ -475,13 +475,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     fn before_access_global(\n         memory_extra: &MemoryExtra,\n         alloc_id: AllocId,\n-        allocation: &Allocation,\n+        alloc: ConstAllocation<'tcx>,\n         static_def_id: Option<DefId>,\n         is_write: bool,\n     ) -> InterpResult<'tcx> {\n+        let alloc = alloc.inner();\n         if is_write {\n             // Write access. These are never allowed, but we give a targeted error message.\n-            if allocation.mutability == Mutability::Not {\n+            if alloc.mutability == Mutability::Not {\n                 Err(err_ub!(WriteToReadOnly(alloc_id)).into())\n             } else {\n                 Err(ConstEvalErrKind::ModifiedGlobal.into())\n@@ -504,7 +505,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 // But make sure we never accept a read from something mutable, that would be\n                 // unsound. The reason is that as the content of this allocation may be different\n                 // now and at run-time, so if we permit reading now we might return the wrong value.\n-                assert_eq!(allocation.mutability, Mutability::Not);\n+                assert_eq!(alloc.mutability, Mutability::Not);\n                 Ok(())\n             }\n         }"}, {"sha": "c49c5ecac267607290081dee62f6264761fcba78", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -183,7 +183,7 @@ pub(crate) fn deref_const<'tcx>(\n     let mplace = ecx.deref_operand(&op).unwrap();\n     if let Some(alloc_id) = mplace.ptr.provenance {\n         assert_eq!(\n-            tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().mutability,\n+            tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().inner().mutability,\n             Mutability::Not,\n             \"deref_const cannot be used with mutable allocations as \\\n             that could allow pattern matching to observe mutable statics\","}, {"sha": "bacb3f6ea7fec8471131ba42d3bc81c8d1d1be0b", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -23,7 +23,10 @@ use rustc_middle::ty::{self, layout::TyAndLayout, Ty};\n \n use rustc_ast::Mutability;\n \n-use super::{AllocId, Allocation, InterpCx, MPlaceTy, Machine, MemoryKind, PlaceTy, ValueVisitor};\n+use super::{\n+    AllocId, Allocation, ConstAllocation, InterpCx, MPlaceTy, Machine, MemoryKind, PlaceTy,\n+    ValueVisitor,\n+};\n use crate::const_eval;\n \n pub trait CompileTimeMachine<'mir, 'tcx, T> = Machine<\n@@ -131,8 +134,8 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n         alloc.mutability = Mutability::Not;\n     };\n     // link the alloc id to the actual allocation\n-    let alloc = tcx.intern_const_alloc(alloc);\n     leftover_allocations.extend(alloc.relocations().iter().map(|&(_, alloc_id)| alloc_id));\n+    let alloc = tcx.intern_const_alloc(alloc);\n     tcx.set_alloc_id_memory(alloc_id, alloc);\n     None\n }\n@@ -393,7 +396,7 @@ pub fn intern_const_alloc_recursive<\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.set_alloc_id_memory(alloc_id, alloc);\n-            for &(_, alloc_id) in alloc.relocations().iter() {\n+            for &(_, alloc_id) in alloc.inner().relocations().iter() {\n                 if leftover_allocations.insert(alloc_id) {\n                     todo.push(alloc_id);\n                 }\n@@ -425,7 +428,7 @@ impl<'mir, 'tcx: 'mir, M: super::intern::CompileTimeMachine<'mir, 'tcx, !>>\n             &mut InterpCx<'mir, 'tcx, M>,\n             &PlaceTy<'tcx, M::PointerTag>,\n         ) -> InterpResult<'tcx, ()>,\n-    ) -> InterpResult<'tcx, &'tcx Allocation> {\n+    ) -> InterpResult<'tcx, ConstAllocation<'tcx>> {\n         let dest = self.allocate(layout, MemoryKind::Stack)?;\n         f(self, &dest.into())?;\n         let mut alloc = self.memory.alloc_map.remove(&dest.ptr.provenance.unwrap()).unwrap().1;"}, {"sha": "9b58e25d3308f29630daa0f771eb0ccfd34708ae", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -56,7 +56,7 @@ crate fn eval_nullary_intrinsic<'tcx>(\n         sym::type_name => {\n             ensure_monomorphic_enough(tcx, tp_ty)?;\n             let alloc = type_name::alloc_type_name(tcx, tp_ty);\n-            ConstValue::Slice { data: alloc, start: 0, end: alloc.len() }\n+            ConstValue::Slice { data: alloc, start: 0, end: alloc.inner().len() }\n         }\n         sym::needs_drop => {\n             ensure_monomorphic_enough(tcx, tp_ty)?;"}, {"sha": "dfc1a6e4d38e12828791fd4c39c8b7b51cf69537", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -1,6 +1,6 @@\n use rustc_hir::def_id::CrateNum;\n use rustc_hir::definitions::DisambiguatedDefPathData;\n-use rustc_middle::mir::interpret::Allocation;\n+use rustc_middle::mir::interpret::{Allocation, ConstAllocation};\n use rustc_middle::ty::{\n     self,\n     print::{PrettyPrinter, Print, Printer},\n@@ -188,7 +188,7 @@ impl Write for AbsolutePathPrinter<'_> {\n }\n \n /// Directly returns an `Allocation` containing an absolute path representation of the given type.\n-crate fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx Allocation {\n+crate fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ConstAllocation<'tcx> {\n     let path = AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path;\n     let alloc = Allocation::from_bytes_byte_aligned_immutable(path.into_bytes());\n     tcx.intern_const_alloc(alloc)"}, {"sha": "7d75c84d108357d35b993301f7da2816c7076cb4", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -13,8 +13,9 @@ use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n use super::{\n-    AllocId, AllocRange, Allocation, Frame, ImmTy, InterpCx, InterpResult, LocalValue, MemPlace,\n-    Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n+    AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n+    LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar,\n+    StackPopUnwind,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -252,7 +253,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn before_access_global(\n         _memory_extra: &Self::MemoryExtra,\n         _alloc_id: AllocId,\n-        _allocation: &Allocation,\n+        _allocation: ConstAllocation<'tcx>,\n         _static_def_id: Option<DefId>,\n         _is_write: bool,\n     ) -> InterpResult<'tcx> {"}, {"sha": "e100ebc4ccb2814fe8450608985e9a825fa48d65", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -525,12 +525,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n         };\n         M::before_access_global(&self.extra, id, alloc, def_id, is_write)?;\n-        let alloc = Cow::Borrowed(alloc);\n         // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n         let alloc = M::init_allocation_extra(\n             self,\n             id, // always use the ID we got as input, not the \"hidden\" one.\n-            alloc,\n+            Cow::Borrowed(alloc.inner()),\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n         );\n         Ok(alloc)\n@@ -711,6 +710,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Memory(alloc)) => {\n                 // Need to duplicate the logic here, because the global allocations have\n                 // different associated types than the interpreter-local ones.\n+                let alloc = alloc.inner();\n                 Ok((alloc.size(), alloc.align))\n             }\n             Some(GlobalAlloc::Function(_)) => bug!(\"We already checked function pointers above\"),\n@@ -867,7 +867,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n                                 &mut *fmt,\n                                 self.mem.tcx,\n                                 &mut allocs_to_print,\n-                                alloc,\n+                                alloc.inner(),\n                             )?;\n                         }\n                         Some(GlobalAlloc::Function(func)) => {"}, {"sha": "f0e3f83e8489cfeadf925b0abd7ebfdfdfb87325", "filename": "compiler/rustc_data_structures/src/intern.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -62,13 +62,17 @@ impl<'a, T> PartialEq for Interned<'a, T> {\n \n impl<'a, T> Eq for Interned<'a, T> {}\n \n-// In practice you can't intern any `T` that doesn't implement `Eq`, because\n-// that's needed for hashing. Therefore, we won't be interning any `T` that\n-// implements `PartialOrd` without also implementing `Ord`. So we can have the\n-// bound `T: Ord` here and avoid duplication with the `Ord` impl below.\n-impl<'a, T: Ord> PartialOrd for Interned<'a, T> {\n+impl<'a, T: PartialOrd> PartialOrd for Interned<'a, T> {\n     fn partial_cmp(&self, other: &Interned<'a, T>) -> Option<Ordering> {\n-        Some(self.cmp(other))\n+        // Pointer equality implies equality, due to the uniqueness constraint,\n+        // but the contents must be compared otherwise.\n+        if ptr::eq(self.0, other.0) {\n+            Some(Ordering::Equal)\n+        } else {\n+            let res = self.0.partial_cmp(&other.0);\n+            debug_assert_ne!(res, Some(Ordering::Equal));\n+            res\n+        }\n     }\n }\n "}, {"sha": "17ff52cefcfa8f9ee4533de1822f075a3a422014", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -2,11 +2,13 @@\n \n use std::borrow::Cow;\n use std::convert::{TryFrom, TryInto};\n+use std::fmt;\n use std::iter;\n use std::ops::{Deref, Range};\n use std::ptr;\n \n use rustc_ast::Mutability;\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::{Align, HasDataLayout, Size};\n@@ -47,6 +49,34 @@ pub struct Allocation<Tag = AllocId, Extra = ()> {\n     pub extra: Extra,\n }\n \n+/// Interned types generally have an `Outer` type and an `Inner` type, where\n+/// `Outer` is a newtype around `Interned<Inner>`, and all the operations are\n+/// done on `Outer`, because all occurrences are interned. E.g. `Ty` is an\n+/// outer type and `TyS` is its inner type.\n+///\n+/// Here things are different because only const allocations are interned. This\n+/// means that both the inner type (`Allocation`) and the outer type\n+/// (`ConstAllocation`) are used quite a bit.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n+#[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n+pub struct ConstAllocation<'tcx, Tag = AllocId, Extra = ()>(\n+    pub Interned<'tcx, Allocation<Tag, Extra>>,\n+);\n+\n+impl<'tcx> fmt::Debug for ConstAllocation<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // This matches how `Allocation` is printed. We print it like this to\n+        // avoid having to update expected output in a lot of tests.\n+        write!(f, \"{:?}\", self.inner())\n+    }\n+}\n+\n+impl<'tcx, Tag, Extra> ConstAllocation<'tcx, Tag, Extra> {\n+    pub fn inner(self) -> &'tcx Allocation<Tag, Extra> {\n+        self.0.0\n+    }\n+}\n+\n /// We have our own error type that does not know about the `AllocId`; that information\n /// is added when converting to `InterpError`.\n #[derive(Debug)]"}, {"sha": "bce962491b7b1c99c17b43139d2743c12d78ebe6", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -126,7 +126,8 @@ pub use self::error::{\n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar, ScalarMaybeUninit};\n \n pub use self::allocation::{\n-    alloc_range, AllocRange, Allocation, InitChunk, InitChunkIter, InitMask, Relocations,\n+    alloc_range, AllocRange, Allocation, ConstAllocation, InitChunk, InitChunkIter, InitMask,\n+    Relocations,\n };\n \n pub use self::pointer::{Pointer, PointerArithmetic, Provenance};\n@@ -343,7 +344,7 @@ impl<'s> AllocDecodingSession<'s> {\n         let alloc_id = decoder.with_position(pos, |decoder| {\n             match alloc_kind {\n                 AllocDiscriminant::Alloc => {\n-                    let alloc = <&'tcx Allocation as Decodable<_>>::decode(decoder);\n+                    let alloc = <ConstAllocation<'tcx> as Decodable<_>>::decode(decoder);\n                     // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n@@ -387,14 +388,14 @@ pub enum GlobalAlloc<'tcx> {\n     /// This is also used to break the cycle in recursive statics.\n     Static(DefId),\n     /// The alloc ID points to memory.\n-    Memory(&'tcx Allocation),\n+    Memory(ConstAllocation<'tcx>),\n }\n \n impl<'tcx> GlobalAlloc<'tcx> {\n     /// Panics if the `GlobalAlloc` does not refer to an `GlobalAlloc::Memory`\n     #[track_caller]\n     #[inline]\n-    pub fn unwrap_memory(&self) -> &'tcx Allocation {\n+    pub fn unwrap_memory(&self) -> ConstAllocation<'tcx> {\n         match *self {\n             GlobalAlloc::Memory(mem) => mem,\n             _ => bug!(\"expected memory, got {:?}\", self),\n@@ -512,7 +513,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Statics with identical content will still point to the same `Allocation`, i.e.,\n     /// their data will be deduplicated through `Allocation` interning -- but they\n     /// are different places in memory and as such need different IDs.\n-    pub fn create_memory_alloc(self, mem: &'tcx Allocation) -> AllocId {\n+    pub fn create_memory_alloc(self, mem: ConstAllocation<'tcx>) -> AllocId {\n         let id = self.reserve_alloc_id();\n         self.set_alloc_id_memory(id, mem);\n         id\n@@ -543,15 +544,15 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n-    pub fn set_alloc_id_memory(self, id: AllocId, mem: &'tcx Allocation) {\n+    pub fn set_alloc_id_memory(self, id: AllocId, mem: ConstAllocation<'tcx>) {\n         if let Some(old) = self.alloc_map.lock().alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n             bug!(\"tried to set allocation ID {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n     /// twice for the same `(AllocId, Allocation)` pair.\n-    fn set_alloc_id_same_memory(self, id: AllocId, mem: &'tcx Allocation) {\n+    fn set_alloc_id_same_memory(self, id: AllocId, mem: ConstAllocation<'tcx>) {\n         self.alloc_map.lock().alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n     }\n }"}, {"sha": "8b0f92d23d75fb72f0aed5f404192901667cb9f9", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn eval_static_initializer(\n         self,\n         def_id: DefId,\n-    ) -> Result<&'tcx mir::Allocation, ErrorHandled> {\n+    ) -> Result<mir::ConstAllocation<'tcx>, ErrorHandled> {\n         trace!(\"eval_static_initializer: Need to compute {:?}\", def_id);\n         assert!(self.is_static(def_id));\n         let instance = ty::Instance::mono(self, def_id);\n@@ -92,7 +92,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         gid: GlobalId<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> Result<&'tcx mir::Allocation, ErrorHandled> {\n+    ) -> Result<mir::ConstAllocation<'tcx>, ErrorHandled> {\n         let param_env = param_env.with_const();\n         trace!(\"eval_to_allocation: Need to compute {:?}\", gid);\n         let raw_const = self.eval_to_allocation_raw(param_env.and(gid))?;"}, {"sha": "8e32603a357026f9b4af0b6fa1d8eccea5f83df8", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -11,7 +11,7 @@ use rustc_target::abi::{HasDataLayout, Size};\n use crate::ty::{Lift, ParamEnv, ScalarInt, Ty, TyCtxt};\n \n use super::{\n-    AllocId, AllocRange, Allocation, InterpResult, Pointer, PointerArithmetic, Provenance,\n+    AllocId, AllocRange, ConstAllocation, InterpResult, Pointer, PointerArithmetic, Provenance,\n };\n \n /// Represents the result of const evaluation via the `eval_to_allocation` query.\n@@ -34,13 +34,13 @@ pub enum ConstValue<'tcx> {\n     Scalar(Scalar),\n \n     /// Used only for `&[u8]` and `&str`\n-    Slice { data: &'tcx Allocation, start: usize, end: usize },\n+    Slice { data: ConstAllocation<'tcx>, start: usize, end: usize },\n \n     /// A value not represented/representable by `Scalar` or `Slice`\n     ByRef {\n         /// The backing memory of the value, may contain more memory than needed for just the value\n-        /// in order to share `Allocation`s between values\n-        alloc: &'tcx Allocation,\n+        /// in order to share `ConstAllocation`s between values\n+        alloc: ConstAllocation<'tcx>,\n         /// Offset into `alloc`\n         offset: Size,\n     },\n@@ -603,11 +603,12 @@ impl<'tcx, Tag: Provenance> ScalarMaybeUninit<Tag> {\n pub fn get_slice_bytes<'tcx>(cx: &impl HasDataLayout, val: ConstValue<'tcx>) -> &'tcx [u8] {\n     if let ConstValue::Slice { data, start, end } = val {\n         let len = end - start;\n-        data.get_bytes(\n-            cx,\n-            AllocRange { start: Size::from_bytes(start), size: Size::from_bytes(len) },\n-        )\n-        .unwrap_or_else(|err| bug!(\"const slice is invalid: {:?}\", err))\n+        data.inner()\n+            .get_bytes(\n+                cx,\n+                AllocRange { start: Size::from_bytes(start), size: Size::from_bytes(len) },\n+            )\n+            .unwrap_or_else(|err| bug!(\"const slice is invalid: {:?}\", err))\n     } else {\n         bug!(\"expected const slice, but found another const value\");\n     }"}, {"sha": "62be33b16cc0b07729df0fefc125844c531d1225", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -3,7 +3,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n use crate::mir::coverage::{CodeRegion, CoverageKind};\n-use crate::mir::interpret::{Allocation, ConstValue, GlobalAlloc, Scalar};\n+use crate::mir::interpret::{ConstAllocation, ConstValue, GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::codec::{TyDecoder, TyEncoder};"}, {"sha": "1d176cc72cdd991bf37d55e1fc48c91c1e4c79fb", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -12,7 +12,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{\n-    read_target_uint, AllocId, Allocation, ConstValue, GlobalAlloc, Pointer, Provenance,\n+    read_target_uint, AllocId, Allocation, ConstAllocation, ConstValue, GlobalAlloc, Pointer,\n+    Provenance,\n };\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::MirSource;\n@@ -652,8 +653,10 @@ pub fn write_allocations<'tcx>(\n     body: &Body<'_>,\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n-    fn alloc_ids_from_alloc(alloc: &Allocation) -> impl DoubleEndedIterator<Item = AllocId> + '_ {\n-        alloc.relocations().values().map(|id| *id)\n+    fn alloc_ids_from_alloc(\n+        alloc: ConstAllocation<'_>,\n+    ) -> impl DoubleEndedIterator<Item = AllocId> + '_ {\n+        alloc.inner().relocations().values().map(|id| *id)\n     }\n     fn alloc_ids_from_const(val: ConstValue<'_>) -> impl Iterator<Item = AllocId> + '_ {\n         match val {\n@@ -686,14 +689,14 @@ pub fn write_allocations<'tcx>(\n     let mut todo: Vec<_> = seen.iter().copied().collect();\n     while let Some(id) = todo.pop() {\n         let mut write_allocation_track_relocs =\n-            |w: &mut dyn Write, alloc: &Allocation| -> io::Result<()> {\n+            |w: &mut dyn Write, alloc: ConstAllocation<'tcx>| -> io::Result<()> {\n                 // `.rev()` because we are popping them from the back of the `todo` vector.\n                 for id in alloc_ids_from_alloc(alloc).rev() {\n                     if seen.insert(id) {\n                         todo.push(id);\n                     }\n                 }\n-                write!(w, \"{}\", display_allocation(tcx, alloc))\n+                write!(w, \"{}\", display_allocation(tcx, alloc.inner()))\n             };\n         write!(w, \"\\n{}\", id)?;\n         match tcx.get_global_alloc(id) {"}, {"sha": "69455951c5794b8a97f1814ad52fa33396bbd844", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -10,7 +10,7 @@ use crate::arena::ArenaAllocatable;\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::mir::{\n     self,\n-    interpret::{AllocId, Allocation},\n+    interpret::{AllocId, ConstAllocation},\n };\n use crate::thir;\n use crate::traits;\n@@ -150,6 +150,12 @@ impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Const<'tcx> {\n     }\n }\n \n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ConstAllocation<'tcx> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        self.inner().encode(e)\n+    }\n+}\n+\n impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for AllocId {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         e.encode_alloc_id(self)\n@@ -355,8 +361,8 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [ty::ValTree<'tcx>] {\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for Allocation {\n-    fn decode(decoder: &mut D) -> &'tcx Self {\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ConstAllocation<'tcx> {\n+    fn decode(decoder: &mut D) -> Self {\n         decoder.tcx().intern_const_alloc(Decodable::decode(decoder))\n     }\n }\n@@ -399,7 +405,6 @@ impl_decodable_via_ref! {\n     &'tcx ty::List<Ty<'tcx>>,\n     &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     &'tcx traits::ImplSource<'tcx, ()>,\n-    &'tcx Allocation,\n     &'tcx mir::Body<'tcx>,\n     &'tcx mir::UnsafetyCheckResult,\n     &'tcx mir::BorrowCheckResult<'tcx>,"}, {"sha": "b48b6e3a820c523ae67391fee45ac60c0dc95402", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -7,7 +7,7 @@ use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath};\n use crate::middle::stability;\n-use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n+use crate::mir::interpret::{self, Allocation, ConstAllocation, ConstValue, Scalar};\n use crate::mir::{\n     Body, BorrowCheckResult, Field, Local, Place, PlaceElem, ProjectionKind, Promoted,\n };\n@@ -1653,22 +1653,6 @@ pub trait Lift<'tcx>: fmt::Debug {\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted>;\n }\n \n-// Deprecated: we are in the process of converting all uses to `nop_lift`.\n-macro_rules! nop_lift_old {\n-    ($set:ident; $ty:ty => $lifted:ty) => {\n-        impl<'a, 'tcx> Lift<'tcx> for $ty {\n-            type Lifted = $lifted;\n-            fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-                if tcx.interners.$set.contains_pointer_to(&InternedInSet(self)) {\n-                    Some(unsafe { mem::transmute(self) })\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n-    };\n-}\n-\n macro_rules! nop_lift {\n     ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n@@ -1726,7 +1710,7 @@ macro_rules! nop_list_lift {\n nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n nop_lift! {region; Region<'a> => Region<'tcx>}\n nop_lift! {const_; Const<'a> => Const<'tcx>}\n-nop_lift_old! {const_allocation; &'a Allocation => &'tcx Allocation}\n+nop_lift! {const_allocation; ConstAllocation<'a> => ConstAllocation<'tcx>}\n nop_lift! {predicate; Predicate<'a> => Predicate<'tcx>}\n \n nop_list_lift! {poly_existential_predicates; ty::Binder<'a, ExistentialPredicate<'a>> => ty::Binder<'tcx, ExistentialPredicate<'tcx>>}\n@@ -2161,6 +2145,7 @@ macro_rules! direct_interners {\n direct_interners! {\n     region: mk_region(RegionKind): Region -> Region<'tcx>,\n     const_: mk_const(ConstS<'tcx>): Const -> Const<'tcx>,\n+    const_allocation: intern_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n }\n \n macro_rules! direct_interners_old {\n@@ -2201,7 +2186,6 @@ macro_rules! direct_interners_old {\n \n // FIXME: eventually these should all be converted to `direct_interners`.\n direct_interners_old! {\n-    const_allocation: intern_const_alloc(Allocation),\n     layout: intern_layout(Layout),\n     adt_def: intern_adt_def(AdtDef),\n }"}, {"sha": "0927dc2d266abe4353b461d3276fcfe135bb76d6", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -1267,7 +1267,7 @@ pub trait PrettyPrinter<'tcx>:\n                 Some(GlobalAlloc::Memory(alloc)) => {\n                     let len = int.assert_bits(self.tcx().data_layout.pointer_size);\n                     let range = AllocRange { start: offset, size: Size::from_bytes(len) };\n-                    if let Ok(byte_str) = alloc.get_bytes(&self.tcx(), range) {\n+                    if let Ok(byte_str) = alloc.inner().get_bytes(&self.tcx(), range) {\n                         p!(pretty_print_byte_str(byte_str))\n                     } else {\n                         p!(\"<too short allocation>\")\n@@ -1424,7 +1424,8 @@ pub trait PrettyPrinter<'tcx>:\n                 // The `inspect` here is okay since we checked the bounds, and there are\n                 // no relocations (we have an active slice reference here). We don't use\n                 // this result to affect interpreter execution.\n-                let byte_str = data.inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n+                let byte_str =\n+                    data.inner().inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n                 self.pretty_print_byte_str(byte_str)\n             }\n             (\n@@ -1434,7 +1435,8 @@ pub trait PrettyPrinter<'tcx>:\n                 // The `inspect` here is okay since we checked the bounds, and there are no\n                 // relocations (we have an active `str` reference here). We don't use this\n                 // result to affect interpreter execution.\n-                let slice = data.inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n+                let slice =\n+                    data.inner().inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n                 p!(write(\"{:?}\", String::from_utf8_lossy(slice)));\n                 Ok(self)\n             }\n@@ -1443,7 +1445,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // cast is ok because we already checked for pointer size (32 or 64 bit) above\n                 let range = AllocRange { start: offset, size: Size::from_bytes(n) };\n \n-                let byte_str = alloc.get_bytes(&self.tcx(), range).unwrap();\n+                let byte_str = alloc.inner().get_bytes(&self.tcx(), range).unwrap();\n                 p!(\"*\");\n                 p!(pretty_print_byte_str(byte_str));\n                 Ok(self)"}, {"sha": "34c539f319194761c161ca96b6e6c372a9a3e8ec", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -31,8 +31,8 @@ use rustc_trait_selection::traits;\n use crate::MirPass;\n use rustc_const_eval::const_eval::ConstEvalErr;\n use rustc_const_eval::interpret::{\n-    self, compile_time_machine, AllocId, Allocation, ConstValue, CtfeValidationMode, Frame, ImmTy,\n-    Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, MemoryKind, OpTy,\n+    self, compile_time_machine, AllocId, ConstAllocation, ConstValue, CtfeValidationMode, Frame,\n+    ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, MemoryKind, OpTy,\n     Operand as InterpOperand, PlaceTy, Scalar, ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n };\n \n@@ -274,7 +274,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     fn before_access_global(\n         _memory_extra: &(),\n         _alloc_id: AllocId,\n-        allocation: &Allocation<Self::PointerTag, Self::AllocExtra>,\n+        alloc: ConstAllocation<'tcx, Self::PointerTag, Self::AllocExtra>,\n         _static_def_id: Option<DefId>,\n         is_write: bool,\n     ) -> InterpResult<'tcx> {\n@@ -283,7 +283,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         }\n         // If the static allocation is mutable, then we can't const prop it as its content\n         // might be different at runtime.\n-        if allocation.mutability == Mutability::Mut {\n+        if alloc.inner().mutability == Mutability::Mut {\n             throw_machine_stop_str!(\"can't access mutable globals in ConstProp\");\n         }\n "}, {"sha": "ed771534c4c4c2c152252541c294998261dcc65d", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -401,7 +401,7 @@ fn collect_items_rec<'tcx>(\n             recursion_depth_reset = None;\n \n             if let Ok(alloc) = tcx.eval_static_initializer(def_id) {\n-                for &id in alloc.relocations().values() {\n+                for &id in alloc.inner().relocations().values() {\n                     collect_miri(tcx, id, &mut neighbors);\n                 }\n             }\n@@ -1370,7 +1370,7 @@ fn collect_miri<'tcx>(\n         }\n         GlobalAlloc::Memory(alloc) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n-            for &inner in alloc.relocations().values() {\n+            for &inner in alloc.inner().relocations().values() {\n                 rustc_data_structures::stack::ensure_sufficient_stack(|| {\n                     collect_miri(tcx, inner, output);\n                 });\n@@ -1405,7 +1405,7 @@ fn collect_const_value<'tcx>(\n     match value {\n         ConstValue::Scalar(Scalar::Ptr(ptr, _size)) => collect_miri(tcx, ptr.provenance, output),\n         ConstValue::Slice { data: alloc, start: _, end: _ } | ConstValue::ByRef { alloc, .. } => {\n-            for &id in alloc.relocations().values() {\n+            for &id in alloc.inner().relocations().values() {\n                 collect_miri(tcx, id, output);\n             }\n         }"}, {"sha": "a9c41ce0c4ea4033bdfecb76bd9c261cafd5eff2", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -633,8 +633,9 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                         // The `inspect` here is okay since we checked the bounds, and there are no\n                         // relocations (we have an active `str` reference here). We don't use this\n                         // result to affect interpreter execution.\n-                        let slice =\n-                            data.inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n+                        let slice = data\n+                            .inner()\n+                            .inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n                         let s = std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n \n                         self.push(\"e\");"}, {"sha": "4c0eab51c355833decf4392b29e624345c2921a9", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -553,7 +553,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId, span: S\n     // the consumer's responsibility to ensure all bytes that have been read\n     // have defined values.\n     if let Ok(alloc) = tcx.eval_static_initializer(id.to_def_id()) {\n-        if alloc.relocations().len() != 0 {\n+        if alloc.inner().relocations().len() != 0 {\n             let msg = \"statics with a custom `#[link_section]` must be a \\\n                            simple list of bytes on the wasm target with no \\\n                            extra levels of indirection such as references\";"}, {"sha": "42b9e692d3ff4cbcf5198ffd29f3a8ef49805ca4", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8876ca3dd46b99fe7e6ad937f11493d37996231e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ca3dd46b99fe7e6ad937f11493d37996231e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=8876ca3dd46b99fe7e6ad937f11493d37996231e", "patch": "@@ -593,7 +593,7 @@ pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n         ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty().kind() {\n             ty::Ref(_, tam, _) => match tam.kind() {\n                 ty::Str => String::from_utf8(\n-                    data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n+                    data.inner().inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n                         .to_owned(),\n                 )\n                 .ok()\n@@ -605,7 +605,7 @@ pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n         ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty().kind() {\n             ty::Array(sub_type, len) => match sub_type.kind() {\n                 ty::Float(FloatTy::F32) => match miri_to_const(*len) {\n-                    Some(Constant::Int(len)) => alloc\n+                    Some(Constant::Int(len)) => alloc.inner()\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n                         .to_owned()\n                         .chunks(4)\n@@ -619,7 +619,7 @@ pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n                     _ => None,\n                 },\n                 ty::Float(FloatTy::F64) => match miri_to_const(*len) {\n-                    Some(Constant::Int(len)) => alloc\n+                    Some(Constant::Int(len)) => alloc.inner()\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n                         .to_owned()\n                         .chunks(8)"}]}