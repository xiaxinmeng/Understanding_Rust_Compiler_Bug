{"sha": "7e3b93417c620072169a061e7f3c975705723d30", "node_id": "C_kwDOAAsO6NoAKDdlM2I5MzQxN2M2MjAwNzIxNjlhMDYxZTdmM2M5NzU3MDU3MjNkMzA", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2023-05-06T11:28:38Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2023-05-06T11:28:38Z"}, "message": "clean up transmutes in core", "tree": {"sha": "739408f7db47f6f0d2feb0926e36f45ad1e66ebd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/739408f7db47f6f0d2feb0926e36f45ad1e66ebd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e3b93417c620072169a061e7f3c975705723d30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e3b93417c620072169a061e7f3c975705723d30", "html_url": "https://github.com/rust-lang/rust/commit/7e3b93417c620072169a061e7f3c975705723d30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e3b93417c620072169a061e7f3c975705723d30/comments", "author": null, "committer": null, "parents": [{"sha": "151a070afe09c0c844e8d9af98a20fee56a5a7f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/151a070afe09c0c844e8d9af98a20fee56a5a7f2", "html_url": "https://github.com/rust-lang/rust/commit/151a070afe09c0c844e8d9af98a20fee56a5a7f2"}], "stats": {"total": 22, "additions": 9, "deletions": 13}, "files": [{"sha": "d09a24b4b1d5be860affd89ff50d62ca38f34046", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3b93417c620072169a061e7f3c975705723d30/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3b93417c620072169a061e7f3c975705723d30/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=7e3b93417c620072169a061e7f3c975705723d30", "patch": "@@ -1287,7 +1287,7 @@ impl<T, const N: usize> MaybeUninit<[T; N]> {\n     #[inline]\n     pub const fn transpose(self) -> [MaybeUninit<T>; N] {\n         // SAFETY: T and MaybeUninit<T> have the same layout\n-        unsafe { super::transmute_copy(&ManuallyDrop::new(self)) }\n+        unsafe { intrinsics::transmute_unchecked(self) }\n     }\n }\n \n@@ -1307,6 +1307,6 @@ impl<T, const N: usize> [MaybeUninit<T>; N] {\n     #[inline]\n     pub const fn transpose(self) -> MaybeUninit<[T; N]> {\n         // SAFETY: T and MaybeUninit<T> have the same layout\n-        unsafe { super::transmute_copy(&ManuallyDrop::new(self)) }\n+        unsafe { intrinsics::transmute_unchecked(self) }\n     }\n }"}, {"sha": "172e5fccb61aa60d1b603434f7fbc06c81dafb32", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e3b93417c620072169a061e7f3c975705723d30/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3b93417c620072169a061e7f3c975705723d30/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=7e3b93417c620072169a061e7f3c975705723d30", "patch": "@@ -1,7 +1,6 @@\n // See src/libstd/primitive_docs.rs for documentation.\n \n use crate::cmp::Ordering::{self, *};\n-use crate::mem::transmute;\n \n // Recursive macro for implementing n-ary tuple functions and operations\n //\n@@ -142,16 +141,13 @@ macro_rules! maybe_tuple_doc {\n #[inline]\n const fn ordering_is_some(c: Option<Ordering>, x: Ordering) -> bool {\n     // FIXME: Just use `==` once that's const-stable on `Option`s.\n-    // This isn't using `match` because that optimizes worse due to\n-    // making a two-step check (`Some` *then* the inner value).\n-\n-    // SAFETY: There's no public guarantee for `Option<Ordering>`,\n-    // but we're core so we know that it's definitely a byte.\n-    unsafe {\n-        let c: i8 = transmute(c);\n-        let x: i8 = transmute(Some(x));\n-        c == x\n-    }\n+    // This is mapping `None` to 2 and then doing the comparison afterwards\n+    // because it optimizes better (`None::<Ordering>` is represented as 2).\n+    x as i8\n+        == match c {\n+            Some(c) => c as i8,\n+            None => 2,\n+        }\n }\n \n // Constructs an expression that performs a lexical ordering using method `$rel`."}]}