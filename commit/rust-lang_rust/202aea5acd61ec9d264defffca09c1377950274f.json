{"sha": "202aea5acd61ec9d264defffca09c1377950274f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMmFlYTVhY2Q2MWVjOWQyNjRkZWZmZmNhMDljMTM3Nzk1MDI3NGY=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-06-27T02:59:10Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-06-27T03:04:17Z"}, "message": "Speed up compilation of large constant arrays\n\nThis is a different approach to #51672 as suggested by @oli-obk. Rather\nthan write each repeated value one-by-one, we write the first one and\nthen copy its value directly into the remaining memory.", "tree": {"sha": "fe3f13c9dc8147537e22cd28085ce07f299405b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe3f13c9dc8147537e22cd28085ce07f299405b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/202aea5acd61ec9d264defffca09c1377950274f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/202aea5acd61ec9d264defffca09c1377950274f", "html_url": "https://github.com/rust-lang/rust/commit/202aea5acd61ec9d264defffca09c1377950274f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/202aea5acd61ec9d264defffca09c1377950274f/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cf0691ea1879a84d09d53a19e0f0b06827cf95a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cf0691ea1879a84d09d53a19e0f0b06827cf95a", "html_url": "https://github.com/rust-lang/rust/commit/0cf0691ea1879a84d09d53a19e0f0b06827cf95a"}], "stats": {"total": 38, "additions": 30, "deletions": 8}, "files": [{"sha": "1faa23637a5ed90053cf4c6dcc1d9df1a106cc18", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/202aea5acd61ec9d264defffca09c1377950274f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202aea5acd61ec9d264defffca09c1377950274f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=202aea5acd61ec9d264defffca09c1377950274f", "patch": "@@ -591,10 +591,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                 let (dest, dest_align) = self.force_allocation(dest)?.to_ptr_align();\n \n-                // FIXME: speed up repeat filling\n-                for i in 0..length {\n-                    let elem_dest = dest.ptr_offset(elem_size * i as u64, &self)?;\n-                    self.write_value_to_ptr(value, elem_dest, dest_align, elem_ty)?;\n+                if length > 0 {\n+                    //write the first value\n+                    self.write_value_to_ptr(value, dest, dest_align, elem_ty)?;\n+\n+                    if length > 1 {\n+                        let rest = dest.ptr_offset(elem_size * 1 as u64, &self)?;\n+                        self.memory.copy_repeatedly(dest, dest_align, rest, dest_align, elem_size, length - 1, false)?;\n+                    }\n                 }\n             }\n "}, {"sha": "7a547c406a92b465d7e5f3e32c112b19642b6583", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/202aea5acd61ec9d264defffca09c1377950274f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/202aea5acd61ec9d264defffca09c1377950274f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=202aea5acd61ec9d264defffca09c1377950274f", "patch": "@@ -594,6 +594,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         dest_align: Align,\n         size: Size,\n         nonoverlapping: bool,\n+    ) -> EvalResult<'tcx> {\n+        self.copy_repeatedly(src, src_align, dest, dest_align, size, 1, nonoverlapping)\n+    }\n+\n+    pub fn copy_repeatedly(\n+        &mut self,\n+        src: Scalar,\n+        src_align: Align,\n+        dest: Scalar,\n+        dest_align: Align,\n+        size: Size,\n+        length: u64,\n+        nonoverlapping: bool,\n     ) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be aligned\n         self.check_align(src, src_align)?;\n@@ -617,7 +630,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             .collect();\n \n         let src_bytes = self.get_bytes_unchecked(src, size, src_align)?.as_ptr();\n-        let dest_bytes = self.get_bytes_mut(dest, size, dest_align)?.as_mut_ptr();\n+        let dest_bytes = self.get_bytes_mut(dest, size * length, dest_align)?.as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n@@ -634,13 +647,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                         ));\n                     }\n                 }\n-                ptr::copy(src_bytes, dest_bytes, size.bytes() as usize);\n+\n+                for i in 0..length {\n+                    ptr::copy(src_bytes, dest_bytes.offset((size.bytes() * i) as isize), size.bytes() as usize);\n+                }\n             } else {\n-                ptr::copy_nonoverlapping(src_bytes, dest_bytes, size.bytes() as usize);\n+                for i in 0..length {\n+                    ptr::copy_nonoverlapping(src_bytes, dest_bytes.offset((size.bytes() * i) as isize), size.bytes() as usize);\n+                }\n             }\n         }\n \n-        self.copy_undef_mask(src, dest, size)?;\n+        self.copy_undef_mask(src, dest, size * length)?;\n         // copy back the relocations\n         self.get_mut(dest.alloc_id)?.relocations.insert_presorted(relocations);\n "}]}