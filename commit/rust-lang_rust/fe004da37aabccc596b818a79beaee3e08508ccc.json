{"sha": "fe004da37aabccc596b818a79beaee3e08508ccc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMDA0ZGEzN2FhYmNjYzU5NmI4MThhNzliZWFlZTNlMDg1MDhjY2M=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T00:25:37Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T00:25:37Z"}, "message": "typeck/expr.rs: extract out check_expr_cast.", "tree": {"sha": "149443194850de765d44473f1b1b0c1e1692dba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/149443194850de765d44473f1b1b0c1e1692dba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe004da37aabccc596b818a79beaee3e08508ccc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe004da37aabccc596b818a79beaee3e08508ccc", "html_url": "https://github.com/rust-lang/rust/commit/fe004da37aabccc596b818a79beaee3e08508ccc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe004da37aabccc596b818a79beaee3e08508ccc/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "046cd903c5b700782d08bbd54ff7c88bebbf24d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/046cd903c5b700782d08bbd54ff7c88bebbf24d9", "html_url": "https://github.com/rust-lang/rust/commit/046cd903c5b700782d08bbd54ff7c88bebbf24d9"}], "stats": {"total": 55, "additions": 32, "deletions": 23}, "files": [{"sha": "70420f4ee5aa994c0a926d74578c18bdcd40447a", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fe004da37aabccc596b818a79beaee3e08508ccc/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe004da37aabccc596b818a79beaee3e08508ccc/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=fe004da37aabccc596b818a79beaee3e08508ccc", "patch": "@@ -114,29 +114,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_method_call(expr, segment, span, args, expected, needs)\n             }\n             ExprKind::Cast(ref e, ref t) => {\n-                // Find the type of `e`. Supply hints based on the type we are casting to,\n-                // if appropriate.\n-                let t_cast = self.to_ty_saving_user_provided_ty(t);\n-                let t_cast = self.resolve_vars_if_possible(&t_cast);\n-                let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n-                let t_cast = self.resolve_vars_if_possible(&t_cast);\n-\n-                // Eagerly check for some obvious errors.\n-                if t_expr.references_error() || t_cast.references_error() {\n-                    tcx.types.err\n-                } else {\n-                    // Defer other checks until we're done type checking.\n-                    let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n-                    match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n-                        Ok(cast_check) => {\n-                            deferred_cast_checks.push(cast_check);\n-                            t_cast\n-                        }\n-                        Err(ErrorReported) => {\n-                            tcx.types.err\n-                        }\n-                    }\n-                }\n+                self.check_expr_cast(e, t, expr)\n             }\n             ExprKind::Type(ref e, ref t) => {\n                 let ty = self.to_ty_saving_user_provided_ty(&t);\n@@ -806,4 +784,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         ctxt.coerce.map(|c| c.complete(self)).unwrap_or_else(|| self.tcx.mk_unit())\n     }\n+\n+    fn check_expr_cast(\n+        &self,\n+        e: &'tcx hir::Expr,\n+        t: &'tcx hir::Ty,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        // Find the type of `e`. Supply hints based on the type we are casting to,\n+        // if appropriate.\n+        let t_cast = self.to_ty_saving_user_provided_ty(t);\n+        let t_cast = self.resolve_vars_if_possible(&t_cast);\n+        let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n+        let t_cast = self.resolve_vars_if_possible(&t_cast);\n+\n+        // Eagerly check for some obvious errors.\n+        if t_expr.references_error() || t_cast.references_error() {\n+            self.tcx.types.err\n+        } else {\n+            // Defer other checks until we're done type checking.\n+            let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n+            match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n+                Ok(cast_check) => {\n+                    deferred_cast_checks.push(cast_check);\n+                    t_cast\n+                }\n+                Err(ErrorReported) => {\n+                    self.tcx.types.err\n+                }\n+            }\n+        }\n+    }\n }"}]}