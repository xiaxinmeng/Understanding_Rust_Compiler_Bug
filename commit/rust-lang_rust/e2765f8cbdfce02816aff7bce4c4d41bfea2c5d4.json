{"sha": "e2765f8cbdfce02816aff7bce4c4d41bfea2c5d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNzY1ZjhjYmRmY2UwMjgxNmFmZjdiY2U0YzRkNDFiZmVhMmM1ZDQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2021-02-10T03:24:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-10T03:24:22Z"}, "message": "Rollup merge of #81687 - WaffleLapkin:split_at_spare, r=KodrAus\n\nMake Vec::split_at_spare_mut public\n\nThis PR introduces a new method to the public API, under\n`vec_split_at_spare` feature gate:\n\n```rust\nimpl<T, A: Allocator> impl Vec<T, A> {\n    pub fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]);\n}\n```\n\nThe method returns 2 slices, one slice references the content of the vector,\nand the other references the remaining spare capacity.\n\nThe method was previously implemented while adding `Vec::extend_from_within` in #79015,\nand used to implement `Vec::spare_capacity_mut` (as the later is just a\nsubset of former one).\n\nSee also previous [discussion in `Vec::spare_capacity_mut` tracking issue](https://github.com/rust-lang/rust/issues/75017#issuecomment-770381335).\n\n## Unresolved questions\n\n- [ ] Should we consider changing the name? `split_at_spare_mut` doesn't seem like an intuitive name\n- [ ] Should we deprecate `Vec::spare_capacity_mut`? Any usecase of `Vec::spare_capacity_mut` can be replaced with `Vec::split_at_spare_mut` (but not vise-versa)\n\nr? `@KodrAus`", "tree": {"sha": "7b2316579f8ac1d42dfc83b36fc71542217a1cbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b2316579f8ac1d42dfc83b36fc71542217a1cbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2765f8cbdfce02816aff7bce4c4d41bfea2c5d4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgI1HmCRBK7hj4Ov3rIwAAdHIIAIhwPm0mdzC0ySyFMubo1mus\nhTpPLVJhwTUn3i7DDtntfGrbmK2ce2F05mjyDPYLnnL0v+2ylXbT6rfI00mdvh4A\ny9SGKe09rc628L9Au30tgRxXMkvqpq/l3Gf+LE1GUKRCHsORUU5pDhgKhxTkfgeH\nOkkmg7mgHFXLYlGJ/MnG0fw3kvEJhkbPwx3QV/9z4kyJjtWZZoCghag1uVoOU/5U\nlkanqgCp2s/jlNLpneF1JVAbEVkApqe+Ah7kx8p/ilVBSe+XRNWJADxL9cL5c6G3\nOPQ6zn2+NQUeFPbiPpeSAskmKWhU0pDNWps2XXCTYrNBwrCY/a7Pr/+KCaQhmXk=\n=MEkE\n-----END PGP SIGNATURE-----\n", "payload": "tree 7b2316579f8ac1d42dfc83b36fc71542217a1cbe\nparent 3f09418cbe0cc598e8b0567626c2c800a09cc9cc\nparent 8ff7b75c016af8bebf995f12e7e5b246ad849470\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1612927462 +0900\ncommitter GitHub <noreply@github.com> 1612927462 +0900\n\nRollup merge of #81687 - WaffleLapkin:split_at_spare, r=KodrAus\n\nMake Vec::split_at_spare_mut public\n\nThis PR introduces a new method to the public API, under\n`vec_split_at_spare` feature gate:\n\n```rust\nimpl<T, A: Allocator> impl Vec<T, A> {\n    pub fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]);\n}\n```\n\nThe method returns 2 slices, one slice references the content of the vector,\nand the other references the remaining spare capacity.\n\nThe method was previously implemented while adding `Vec::extend_from_within` in #79015,\nand used to implement `Vec::spare_capacity_mut` (as the later is just a\nsubset of former one).\n\nSee also previous [discussion in `Vec::spare_capacity_mut` tracking issue](https://github.com/rust-lang/rust/issues/75017#issuecomment-770381335).\n\n## Unresolved questions\n\n- [ ] Should we consider changing the name? `split_at_spare_mut` doesn't seem like an intuitive name\n- [ ] Should we deprecate `Vec::spare_capacity_mut`? Any usecase of `Vec::spare_capacity_mut` can be replaced with `Vec::split_at_spare_mut` (but not vise-versa)\n\nr? `@KodrAus`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2765f8cbdfce02816aff7bce4c4d41bfea2c5d4", "html_url": "https://github.com/rust-lang/rust/commit/e2765f8cbdfce02816aff7bce4c4d41bfea2c5d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2765f8cbdfce02816aff7bce4c4d41bfea2c5d4/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f09418cbe0cc598e8b0567626c2c800a09cc9cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f09418cbe0cc598e8b0567626c2c800a09cc9cc", "html_url": "https://github.com/rust-lang/rust/commit/3f09418cbe0cc598e8b0567626c2c800a09cc9cc"}, {"sha": "8ff7b75c016af8bebf995f12e7e5b246ad849470", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ff7b75c016af8bebf995f12e7e5b246ad849470", "html_url": "https://github.com/rust-lang/rust/commit/8ff7b75c016af8bebf995f12e7e5b246ad849470"}], "stats": {"total": 54, "additions": 53, "deletions": 1}, "files": [{"sha": "c7b4c98041b2e658e4f1969cfe407420880f66f6", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e2765f8cbdfce02816aff7bce4c4d41bfea2c5d4/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2765f8cbdfce02816aff7bce4c4d41bfea2c5d4/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=e2765f8cbdfce02816aff7bce4c4d41bfea2c5d4", "patch": "@@ -1828,8 +1828,60 @@ impl<T, A: Allocator> Vec<T, A> {\n         self.split_at_spare_mut().1\n     }\n \n+    /// Returns vector content as a slice of `T`, along with the remaining spare\n+    /// capacity of the vector as a slice of `MaybeUninit<T>`.\n+    ///\n+    /// The returned spare capacity slice can be used to fill the vector with data\n+    /// (e.g. by reading from a file) before marking the data as initialized using\n+    /// the [`set_len`] method.\n+    ///\n+    /// [`set_len`]: Vec::set_len\n+    ///\n+    /// Note that this is a low-level API, which should be used with care for\n+    /// optimization purposes. If you need to append data to a `Vec`\n+    /// you can use [`push`], [`extend`], [`extend_from_slice`],\n+    /// [`extend_from_within`], [`insert`], [`append`], [`resize`] or\n+    /// [`resize_with`], depending on your exact needs.\n+    ///\n+    /// [`push`]: Vec::push\n+    /// [`extend`]: Vec::extend\n+    /// [`extend_from_slice`]: Vec::extend_from_slice\n+    /// [`extend_from_within`]: Vec::extend_from_within\n+    /// [`insert`]: Vec::insert\n+    /// [`append`]: Vec::append\n+    /// [`resize`]: Vec::resize\n+    /// [`resize_with`]: Vec::resize_with\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_split_at_spare, maybe_uninit_extra)]\n+    ///\n+    /// let mut v = vec![1, 1, 2];\n+    ///\n+    /// // Reserve additional space big enough for 10 elements.\n+    /// v.reserve(10);\n+    ///\n+    /// let (init, uninit) = v.split_at_spare_mut();\n+    /// let sum = init.iter().copied().sum::<u32>();\n+    ///\n+    /// // Fill in the next 4 elements.\n+    /// uninit[0].write(sum);\n+    /// uninit[1].write(sum * 2);\n+    /// uninit[2].write(sum * 3);\n+    /// uninit[3].write(sum * 4);\n+    ///\n+    /// // Mark the 4 elements of the vector as being initialized.\n+    /// unsafe {\n+    ///     let len = v.len();\n+    ///     v.set_len(len + 4);\n+    /// }\n+    ///\n+    /// assert_eq!(&v, &[1, 1, 2, 4, 8, 12, 16]);\n+    /// ```\n+    #[unstable(feature = \"vec_split_at_spare\", issue = \"81944\")]\n     #[inline]\n-    fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]) {\n+    pub fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]) {\n         let ptr = self.as_mut_ptr();\n \n         // Safety:"}]}