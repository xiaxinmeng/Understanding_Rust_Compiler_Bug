{"sha": "dd9c8d32f2d7984545816ee07e1e7213b36013f0", "node_id": "C_kwDOAAsO6NoAKGRkOWM4ZDMyZjJkNzk4NDU0NTgxNmVlMDdlMWU3MjEzYjM2MDEzZjA", "commit": {"author": {"name": "Yechan Bae", "email": "yechan@gatech.edu", "date": "2021-10-03T04:23:57Z"}, "committer": {"name": "Yechan Bae", "email": "yechan@gatech.edu", "date": "2021-10-09T09:43:58Z"}, "message": "Extract get_vec_init_kind and share it", "tree": {"sha": "3fe0d84e8b3689bef596c4e4209f8bca45f0504e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fe0d84e8b3689bef596c4e4209f8bca45f0504e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd9c8d32f2d7984545816ee07e1e7213b36013f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd9c8d32f2d7984545816ee07e1e7213b36013f0", "html_url": "https://github.com/rust-lang/rust/commit/dd9c8d32f2d7984545816ee07e1e7213b36013f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd9c8d32f2d7984545816ee07e1e7213b36013f0/comments", "author": {"login": "Qwaz", "id": 5073807, "node_id": "MDQ6VXNlcjUwNzM4MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5073807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Qwaz", "html_url": "https://github.com/Qwaz", "followers_url": "https://api.github.com/users/Qwaz/followers", "following_url": "https://api.github.com/users/Qwaz/following{/other_user}", "gists_url": "https://api.github.com/users/Qwaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Qwaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Qwaz/subscriptions", "organizations_url": "https://api.github.com/users/Qwaz/orgs", "repos_url": "https://api.github.com/users/Qwaz/repos", "events_url": "https://api.github.com/users/Qwaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Qwaz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Qwaz", "id": 5073807, "node_id": "MDQ6VXNlcjUwNzM4MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5073807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Qwaz", "html_url": "https://github.com/Qwaz", "followers_url": "https://api.github.com/users/Qwaz/followers", "following_url": "https://api.github.com/users/Qwaz/following{/other_user}", "gists_url": "https://api.github.com/users/Qwaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Qwaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Qwaz/subscriptions", "organizations_url": "https://api.github.com/users/Qwaz/orgs", "repos_url": "https://api.github.com/users/Qwaz/repos", "events_url": "https://api.github.com/users/Qwaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Qwaz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fec20bf61799764fab2b0d00d4666f4a9a9632c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/fec20bf61799764fab2b0d00d4666f4a9a9632c2", "html_url": "https://github.com/rust-lang/rust/commit/fec20bf61799764fab2b0d00d4666f4a9a9632c2"}], "stats": {"total": 217, "additions": 105, "deletions": 112}, "files": [{"sha": "833c95f4940328af9cfe92adea3915d3c9f09ee6", "filename": "clippy_lints/src/uninit_vec.rs", "status": "modified", "additions": 52, "deletions": 64, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/dd9c8d32f2d7984545816ee07e1e7213b36013f0/clippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9c8d32f2d7984545816ee07e1e7213b36013f0/clippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funinit_vec.rs?ref=dd9c8d32f2d7984545816ee07e1e7213b36013f0", "patch": "@@ -1,41 +1,50 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::get_vec_init_kind;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{\n-    match_def_path, path_to_local_id, paths, peel_hir_expr_while, ty::is_uninit_value_valid_for_ty, SpanlessEq,\n-};\n-use rustc_hir::def::Res;\n-use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, Stmt, StmtKind};\n+use clippy_utils::{path_to_local_id, peel_hir_expr_while, ty::is_uninit_value_valid_for_ty, SpanlessEq};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, PathSegment, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n \n+// TODO: add `ReadBuf` (RFC 2930) in \"How to fix\" once it is available in std\n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for the creation of uninitialized `Vec<T>` by calling `set_len()`\n-    /// immediately after `with_capacity()` or `reserve()`.\n+    /// Checks for `set_len()` call that creates `Vec` with uninitialized elements.\n+    /// This is commonly caused by calling `set_len()` right after after calling\n+    /// `with_capacity()` or `reserve()`.\n     ///\n     /// ### Why is this bad?\n-    /// It creates `Vec<T>` that contains uninitialized data, which leads to an\n+    /// It creates a `Vec` with uninitialized data, which leads to an\n     /// undefined behavior with most safe operations.\n-    /// Notably, using uninitialized `Vec<u8>` with generic `Read` is unsound.\n+    /// Notably, uninitialized `Vec<u8>` must not be used with generic `Read`.\n     ///\n     /// ### Example\n     /// ```rust,ignore\n     /// let mut vec: Vec<u8> = Vec::with_capacity(1000);\n     /// unsafe { vec.set_len(1000); }\n     /// reader.read(&mut vec); // undefined behavior!\n     /// ```\n-    /// Use an initialized buffer:\n-    /// ```rust,ignore\n-    /// let mut vec: Vec<u8> = vec![0; 1000];\n-    /// reader.read(&mut vec);\n-    /// ```\n-    /// Or, wrap the content in `MaybeUninit`:\n-    /// ```rust,ignore\n-    /// let mut vec: Vec<MaybeUninit<T>> = Vec::with_capacity(1000);\n-    /// unsafe { vec.set_len(1000); }\n-    /// ```\n+    ///\n+    /// ### How to fix?\n+    /// 1. Use an initialized buffer:\n+    ///    ```rust,ignore\n+    ///    let mut vec: Vec<u8> = vec![0; 1000];\n+    ///    reader.read(&mut vec);\n+    ///    ```\n+    /// 2. Wrap the content in `MaybeUninit`:\n+    ///    ```rust,ignore\n+    ///    let mut vec: Vec<MaybeUninit<T>> = Vec::with_capacity(1000);\n+    ///    vec.set_len(1000);  // `MaybeUninit` can be uninitialized\n+    ///    ```\n+    /// 3. If you are on nightly, `Vec::spare_capacity_mut()` is available:\n+    ///    ```rust,ignore\n+    ///    let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    ///    let remaining = vec.spare_capacity_mut();  // `&mut [MaybeUninit<u8>]`\n+    ///    // perform initialization with `remaining`\n+    ///    vec.set_len(...);  // Safe to call `set_len()` on initialized part\n+    ///    ```\n     pub UNINIT_VEC,\n     correctness,\n     \"Vec with uninitialized data\"\n@@ -59,24 +68,24 @@ impl<'tcx> LateLintPass<'tcx> for UninitVec {\n \n fn handle_uninit_vec_pair(\n     cx: &LateContext<'tcx>,\n-    maybe_with_capacity_or_reserve: &'tcx Stmt<'tcx>,\n+    maybe_init_or_reserve: &'tcx Stmt<'tcx>,\n     maybe_set_len: &'tcx Expr<'tcx>,\n ) {\n     if_chain! {\n-        if let Some(vec) = extract_with_capacity_or_reserve_target(cx, maybe_with_capacity_or_reserve);\n+        if let Some(vec) = extract_init_or_reserve_target(cx, maybe_init_or_reserve);\n         if let Some((set_len_self, call_span)) = extract_set_len_self(cx, maybe_set_len);\n         if vec.eq_expr(cx, set_len_self);\n         if let ty::Ref(_, vec_ty, _) = cx.typeck_results().expr_ty_adjusted(set_len_self).kind();\n         if let ty::Adt(_, substs) = vec_ty.kind();\n         // Check T of Vec<T>\n         if !is_uninit_value_valid_for_ty(cx, substs.type_at(0));\n         then {\n-            // FIXME: false positive #7698\n+            // FIXME: #7698, false positive of the internal lints\n             #[allow(clippy::collapsible_span_lint_calls)]\n             span_lint_and_then(\n                 cx,\n                 UNINIT_VEC,\n-                vec![call_span, maybe_with_capacity_or_reserve.span],\n+                vec![call_span, maybe_init_or_reserve.span],\n                 \"calling `set_len()` immediately after reserving a buffer creates uninitialized values\",\n                 |diag| {\n                     diag.help(\"initialize the buffer or wrap the content in `MaybeUninit`\");\n@@ -101,56 +110,36 @@ impl<'tcx> LocalOrExpr<'tcx> {\n     }\n }\n \n-/// Returns the target vec of `Vec::with_capacity()` or `Vec::reserve()`\n-fn extract_with_capacity_or_reserve_target(cx: &LateContext<'_>, stmt: &'tcx Stmt<'_>) -> Option<LocalOrExpr<'tcx>> {\n+/// Finds the target location where the result of `Vec` initialization is stored\n+/// or `self` expression for `Vec::reserve()`.\n+fn extract_init_or_reserve_target<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'tcx>) -> Option<LocalOrExpr<'tcx>> {\n     match stmt.kind {\n         StmtKind::Local(local) => {\n-            // let mut x = Vec::with_capacity()\n             if_chain! {\n                 if let Some(init_expr) = local.init;\n                 if let PatKind::Binding(_, hir_id, _, None) = local.pat.kind;\n-                if is_with_capacity(cx, init_expr);\n+                if get_vec_init_kind(cx, init_expr).is_some();\n                 then {\n                     Some(LocalOrExpr::Local(hir_id))\n                 } else {\n                     None\n                 }\n             }\n         },\n-        StmtKind::Expr(expr) | StmtKind::Semi(expr) => {\n-            match expr.kind {\n-                ExprKind::Assign(lhs, rhs, _span) if is_with_capacity(cx, rhs) => {\n-                    // self.vec = Vec::with_capacity()\n-                    Some(LocalOrExpr::Expr(lhs))\n-                },\n-                ExprKind::MethodCall(path, _, [self_expr, _], _) => {\n-                    // self.vec.reserve()\n-                    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr).peel_refs(), sym::vec_type)\n-                        && path.ident.name.as_str() == \"reserve\"\n-                    {\n-                        Some(LocalOrExpr::Expr(self_expr))\n-                    } else {\n-                        None\n-                    }\n-                },\n-                _ => None,\n-            }\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => match expr.kind {\n+            ExprKind::Assign(lhs, rhs, _span) if get_vec_init_kind(cx, rhs).is_some() => Some(LocalOrExpr::Expr(lhs)),\n+            ExprKind::MethodCall(path, _, [self_expr, _], _) if is_reserve(cx, path, self_expr) => {\n+                Some(LocalOrExpr::Expr(self_expr))\n+            },\n+            _ => None,\n         },\n         StmtKind::Item(_) => None,\n     }\n }\n \n-fn is_with_capacity(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> bool {\n-    if_chain! {\n-        if let ExprKind::Call(path_expr, _) = &expr.kind;\n-        if let ExprKind::Path(qpath) = &path_expr.kind;\n-        if let Res::Def(_, def_id) = cx.qpath_res(qpath, path_expr.hir_id);\n-        then {\n-            match_def_path(cx, def_id, &paths::VEC_WITH_CAPACITY)\n-        } else {\n-            false\n-        }\n-    }\n+fn is_reserve(cx: &LateContext<'_>, path: &PathSegment<'_>, self_expr: &Expr<'_>) -> bool {\n+    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr).peel_refs(), sym::Vec)\n+        && path.ident.name.as_str() == \"reserve\"\n }\n \n /// Returns self if the expression is `Vec::set_len()`\n@@ -169,14 +158,13 @@ fn extract_set_len_self(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<(&\n         }\n     });\n     match expr.kind {\n-        ExprKind::MethodCall(_, _, [vec_expr, _], _) => {\n-            cx.typeck_results().type_dependent_def_id(expr.hir_id).and_then(|id| {\n-                if match_def_path(cx, id, &paths::VEC_SET_LEN) {\n-                    Some((vec_expr, expr.span))\n-                } else {\n-                    None\n-                }\n-            })\n+        ExprKind::MethodCall(path, _, [self_expr, _], _) => {\n+            let self_type = cx.typeck_results().expr_ty(self_expr).peel_refs();\n+            if is_type_diagnostic_item(cx, self_type, sym::Vec) && path.ident.name.as_str() == \"set_len\" {\n+                Some((self_expr, expr.span))\n+            } else {\n+                None\n+            }\n         },\n         _ => None,\n     }"}, {"sha": "478314c08368ef058745f9a789a6c4fb7a429970", "filename": "clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 5, "deletions": 46, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/dd9c8d32f2d7984545816ee07e1e7213b36013f0/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9c8d32f2d7984545816ee07e1e7213b36013f0/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=dd9c8d32f2d7984545816ee07e1e7213b36013f0", "patch": "@@ -1,16 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{match_def_path, path_to_local, path_to_local_id, paths};\n+use clippy_utils::{get_vec_init_kind, path_to_local, path_to_local_id, VecInitKind};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Local, PatKind, QPath, Stmt, StmtKind};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Local, PatKind, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span};\n-use std::convert::TryInto;\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -41,11 +38,6 @@ pub struct VecInitThenPush {\n     searcher: Option<VecPushSearcher>,\n }\n \n-#[derive(Clone, Copy)]\n-enum VecInitKind {\n-    New,\n-    WithCapacity(u64),\n-}\n struct VecPushSearcher {\n     local_id: HirId,\n     init: VecInitKind,\n@@ -58,7 +50,8 @@ impl VecPushSearcher {\n     fn display_err(&self, cx: &LateContext<'_>) {\n         match self.init {\n             _ if self.found == 0 => return,\n-            VecInitKind::WithCapacity(x) if x > self.found => return,\n+            VecInitKind::WithLiteralCapacity(x) if x > self.found => return,\n+            VecInitKind::WithExprCapacity(_) => return,\n             _ => (),\n         };\n \n@@ -152,37 +145,3 @@ impl LateLintPass<'_> for VecInitThenPush {\n         }\n     }\n }\n-\n-fn get_vec_init_kind<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<VecInitKind> {\n-    if let ExprKind::Call(func, args) = expr.kind {\n-        match func.kind {\n-            ExprKind::Path(QPath::TypeRelative(ty, name))\n-                if is_type_diagnostic_item(cx, cx.typeck_results().node_type(ty.hir_id), sym::Vec) =>\n-            {\n-                if name.ident.name == sym::new {\n-                    return Some(VecInitKind::New);\n-                } else if name.ident.name.as_str() == \"with_capacity\" {\n-                    return args.get(0).and_then(|arg| {\n-                        if_chain! {\n-                            if let ExprKind::Lit(lit) = &arg.kind;\n-                            if let LitKind::Int(num, _) = lit.node;\n-                            then {\n-                                Some(VecInitKind::WithCapacity(num.try_into().ok()?))\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                    });\n-                }\n-            }\n-            ExprKind::Path(QPath::Resolved(_, path))\n-                if match_def_path(cx, path.res.opt_def_id()?, &paths::DEFAULT_TRAIT_METHOD)\n-                    && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Vec) =>\n-            {\n-                return Some(VecInitKind::New);\n-            }\n-            _ => (),\n-        }\n-    }\n-    None\n-}"}, {"sha": "b450059e18a93116bf0e1b41ec38ba816fb888f3", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/dd9c8d32f2d7984545816ee07e1e7213b36013f0/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9c8d32f2d7984545816ee07e1e7213b36013f0/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=dd9c8d32f2d7984545816ee07e1e7213b36013f0", "patch": "@@ -93,7 +93,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n-use crate::ty::{can_partially_move_ty, is_copy, is_recursively_primitive_type};\n+use crate::ty::{can_partially_move_ty, is_copy, is_recursively_primitive_type, is_type_diagnostic_item};\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -1789,6 +1789,53 @@ pub fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool\n     }\n }\n \n+#[derive(Clone, Copy)]\n+pub enum VecInitKind {\n+    /// `Vec::new()`\n+    New,\n+    /// `Vec::default()` or `Default::default()`\n+    Default,\n+    /// `Vec::with_capacity(123)`\n+    WithLiteralCapacity(u64),\n+    /// `Vec::with_capacity(slice.len())`\n+    WithExprCapacity(HirId),\n+}\n+\n+/// Checks if given expression is an initialization of `Vec` and returns its kind.\n+pub fn get_vec_init_kind<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<VecInitKind> {\n+    if let ExprKind::Call(func, args) = expr.kind {\n+        match func.kind {\n+            ExprKind::Path(QPath::TypeRelative(ty, name))\n+                if is_type_diagnostic_item(cx, cx.typeck_results().node_type(ty.hir_id), sym::Vec) =>\n+            {\n+                if name.ident.name == sym::new {\n+                    return Some(VecInitKind::New);\n+                } else if name.ident.name.as_str() == \"with_capacity\" {\n+                    return args.get(0).and_then(|arg| {\n+                        if_chain! {\n+                            if let ExprKind::Lit(lit) = &arg.kind;\n+                            if let LitKind::Int(num, _) = lit.node;\n+                            then {\n+                                Some(VecInitKind::WithLiteralCapacity(num.try_into().ok()?))\n+                            } else {\n+                                Some(VecInitKind::WithExprCapacity(arg.hir_id))\n+                            }\n+                        }\n+                    });\n+                }\n+            }\n+            ExprKind::Path(QPath::Resolved(_, path))\n+                if match_def_path(cx, path.res.opt_def_id()?, &paths::DEFAULT_TRAIT_METHOD)\n+                    && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Vec) =>\n+            {\n+                return Some(VecInitKind::Default);\n+            }\n+            _ => (),\n+        }\n+    }\n+    None\n+}\n+\n /// Gets the node where an expression is either used, or it's type is unified with another branch.\n pub fn get_expr_use_or_unification_node(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n     let mut child_id = expr.hir_id;"}, {"sha": "a39c0fc0b10cd95f831bc39c89877636e68f8394", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd9c8d32f2d7984545816ee07e1e7213b36013f0/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9c8d32f2d7984545816ee07e1e7213b36013f0/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=dd9c8d32f2d7984545816ee07e1e7213b36013f0", "patch": "@@ -183,7 +183,6 @@ pub const VEC_AS_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_slice\"];\n pub const VEC_FROM_ELEM: [&str; 3] = [\"alloc\", \"vec\", \"from_elem\"];\n pub const VEC_NEW: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"new\"];\n pub const VEC_RESIZE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"resize\"];\n-pub const VEC_WITH_CAPACITY: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"with_capacity\"];\n pub const VEC_SET_LEN: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"set_len\"];\n pub const WEAK_ARC: [&str; 3] = [\"alloc\", \"sync\", \"Weak\"];\n pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];"}]}