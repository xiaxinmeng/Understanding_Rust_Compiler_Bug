{"sha": "43e33ea1fff581f74478b8181614b0a424dee2b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZTMzZWExZmZmNTgxZjc0NDc4YjgxODE2MTRiMGE0MjRkZWUyYjA=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-03-30T19:15:11Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-04-04T22:55:09Z"}, "message": "Add DropArena and use it to allocate types with few allocations", "tree": {"sha": "4cef5bbf947523014fe52bbbc929bcd167fe7053", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cef5bbf947523014fe52bbbc929bcd167fe7053"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43e33ea1fff581f74478b8181614b0a424dee2b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43e33ea1fff581f74478b8181614b0a424dee2b0", "html_url": "https://github.com/rust-lang/rust/commit/43e33ea1fff581f74478b8181614b0a424dee2b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43e33ea1fff581f74478b8181614b0a424dee2b0/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ccb9ae98afa892edaaf7dbfc624870fd5d28339", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ccb9ae98afa892edaaf7dbfc624870fd5d28339", "html_url": "https://github.com/rust-lang/rust/commit/4ccb9ae98afa892edaaf7dbfc624870fd5d28339"}], "stats": {"total": 175, "additions": 150, "deletions": 25}, "files": [{"sha": "cafa973ea8b5e8fea0968517584e360adabf303a", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 140, "deletions": 18, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/43e33ea1fff581f74478b8181614b0a424dee2b0/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e33ea1fff581f74478b8181614b0a424dee2b0/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=43e33ea1fff581f74478b8181614b0a424dee2b0", "patch": "@@ -1,5 +1,10 @@\n use arena::{TypedArena, DroplessArena};\n use std::mem;\n+use std::ptr;\n+use std::slice;\n+use std::cell::RefCell;\n+use std::marker::PhantomData;\n+use smallvec::SmallVec;\n \n #[macro_export]\n macro_rules! arena_types {\n@@ -9,29 +14,55 @@ macro_rules! arena_types {\n                 rustc::hir::def_id::DefId,\n                 rustc::ty::subst::SubstsRef<$tcx>\n             )>,\n+            [few] mir_keys: rustc::util::nodemap::DefIdSet,\n             [decode] specialization_graph: rustc::traits::specialization_graph::Graph,\n         ], $tcx);\n     )\n }\n \n+macro_rules! arena_for_type {\n+    ([][$ty:ty]) => {\n+        TypedArena<$ty>\n+    };\n+    ([few $(, $attrs:ident)*][$ty:ty]) => {\n+        PhantomData<$ty>\n+    };\n+    ([$ignore:ident $(, $attrs:ident)*]$args:tt) => {\n+        arena_for_type!([$($attrs),*]$args)\n+    };\n+}\n+\n macro_rules! declare_arena {\n     ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n         #[derive(Default)]\n         pub struct Arena<$tcx> {\n             dropless: DroplessArena,\n-            $($name: TypedArena<$ty>,)*\n+            drop: DropArena,\n+            $($name: arena_for_type!($a[$ty]),)*\n         }\n     }\n }\n \n+macro_rules! which_arena_for_type {\n+    ([][$arena:expr]) => {\n+        Some($arena)\n+    };\n+    ([few$(, $attrs:ident)*][$arena:expr]) => {\n+        None\n+    };\n+    ([$ignore:ident$(, $attrs:ident)*]$args:tt) => {\n+        which_arena_for_type!([$($attrs),*]$args)\n+    };\n+}\n+\n macro_rules! impl_arena_allocatable {\n     ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n         $(\n             impl ArenaAllocatable for $ty {}\n-            impl<$tcx> ArenaField<$tcx> for $ty {\n+            unsafe impl<$tcx> ArenaField<$tcx> for $ty {\n                 #[inline]\n-                fn arena<'a>(arena: &'a Arena<$tcx>) -> &'a TypedArena<Self> {\n-                    &arena.$name\n+                fn arena<'a>(_arena: &'a Arena<$tcx>) -> Option<&'a TypedArena<Self>> {\n+                    which_arena_for_type!($a[&_arena.$name])\n                 }\n             }\n         )*\n@@ -46,39 +77,130 @@ pub trait ArenaAllocatable {}\n \n impl<T: Copy> ArenaAllocatable for T {}\n \n-pub trait ArenaField<'tcx>: Sized {\n+pub unsafe trait ArenaField<'tcx>: Sized {\n     /// Returns a specific arena to allocate from.\n-    fn arena<'a>(arena: &'a Arena<'tcx>) -> &'a TypedArena<Self>;\n+    /// If None is returned, the DropArena will be used.\n+    fn arena<'a>(arena: &'a Arena<'tcx>) -> Option<&'a TypedArena<Self>>;\n }\n \n-impl<'tcx, T> ArenaField<'tcx> for T {\n+unsafe impl<'tcx, T> ArenaField<'tcx> for T {\n     #[inline]\n-    default fn arena<'a>(_: &'a Arena<'tcx>) -> &'a TypedArena<Self> {\n+    default fn arena<'a>(_: &'a Arena<'tcx>) -> Option<&'a TypedArena<Self>> {\n         panic!()\n     }\n }\n \n impl<'tcx> Arena<'tcx> {\n     #[inline]\n     pub fn alloc<T: ArenaAllocatable>(&self, value: T) -> &mut T {\n-        if mem::needs_drop::<T>() {\n-            <T as ArenaField<'tcx>>::arena(self).alloc(value)\n-        } else {\n-            self.dropless.alloc(value)\n+        if !mem::needs_drop::<T>() {\n+            return self.dropless.alloc(value);\n+        }\n+        match <T as ArenaField<'tcx>>::arena(self) {\n+            Some(arena) => arena.alloc(value),\n+            None => unsafe { self.drop.alloc(value) },\n         }\n     }\n \n     pub fn alloc_from_iter<\n         T: ArenaAllocatable,\n         I: IntoIterator<Item = T>\n     >(\n-        &self,\n+        &'a self,\n         iter: I\n-    ) -> &mut [T] {\n-        if mem::needs_drop::<T>() {\n-            <T as ArenaField<'tcx>>::arena(self).alloc_from_iter(iter)\n-        } else {\n-            self.dropless.alloc_from_iter(iter)\n+    ) -> &'a mut [T] {\n+        if !mem::needs_drop::<T>() {\n+            return self.dropless.alloc_from_iter(iter);\n+        }\n+        match <T as ArenaField<'tcx>>::arena(self) {\n+            Some(arena) => arena.alloc_from_iter(iter),\n+            None => unsafe { self.drop.alloc_from_iter(iter) },\n+        }\n+    }\n+}\n+\n+/// Calls the destructor for an object when dropped.\n+struct DropType {\n+    drop_fn: unsafe fn(*mut u8),\n+    obj: *mut u8,\n+}\n+\n+unsafe fn drop_for_type<T>(to_drop: *mut u8) {\n+    std::ptr::drop_in_place(to_drop as *mut T)\n+}\n+\n+impl Drop for DropType {\n+    fn drop(&mut self) {\n+        unsafe {\n+            (self.drop_fn)(self.obj)\n+        }\n+    }\n+}\n+\n+/// An arena which can be used to allocate any type.\n+/// Allocating in this arena is unsafe since the type system\n+/// doesn't know which types it contains. In order to\n+/// allocate safetly, you must store a PhantomData<T>\n+/// alongside this arena for each type T you allocate.\n+#[derive(Default)]\n+struct DropArena {\n+    /// A list of destructors to run when the arena drops.\n+    /// Ordered so `destructors` gets dropped before the arena\n+    /// since its destructor can reference memory in the arena.\n+    destructors: RefCell<Vec<DropType>>,\n+    arena: DroplessArena,\n+}\n+\n+impl DropArena {\n+    #[inline]\n+    unsafe fn alloc<T>(&self, object: T) -> &mut T {\n+        let mem = self.arena.alloc_raw(\n+            mem::size_of::<T>(),\n+            mem::align_of::<T>()\n+        ) as *mut _ as *mut T;\n+        // Write into uninitialized memory.\n+        ptr::write(mem, object);\n+        let result = &mut *mem;\n+        // Record the destructor after doing the allocation as that may panic\n+        // and would cause `object`'s destuctor to run twice if it was recorded before\n+        self.destructors.borrow_mut().push(DropType {\n+            drop_fn: drop_for_type::<T>,\n+            obj: result as *mut T as *mut u8,\n+        });\n+        result\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_from_iter<T, I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n+        let mut vec: SmallVec<[_; 8]> = iter.into_iter().collect();\n+        if vec.is_empty() {\n+            return &mut [];\n         }\n+        let len = vec.len();\n+\n+        let start_ptr = self.arena.alloc_raw(\n+            len.checked_mul(mem::size_of::<T>()).unwrap(),\n+            mem::align_of::<T>()\n+        ) as *mut _ as *mut T;\n+\n+        let mut destructors = self.destructors.borrow_mut();\n+        // Reserve space for the destructors so we can't panic while adding them\n+        destructors.reserve(len);\n+\n+        // Move the content to the arena by copying it and then forgetting\n+        // the content of the SmallVec\n+        vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+        mem::forget(vec.drain());\n+\n+        // Record the destructors after doing the allocation as that may panic\n+        // and would cause `object`'s destuctor to run twice if it was recorded before\n+        for i in 0..len {\n+            destructors.push(DropType {\n+                drop_fn: drop_for_type::<T>,\n+                obj: start_ptr.offset(i as isize) as *mut u8,\n+            });\n+        }\n+\n+        slice::from_raw_parts_mut(start_ptr, len)\n     }\n }"}, {"sha": "329add5edd00a8dabad7db3029fdb47c86518632", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43e33ea1fff581f74478b8181614b0a424dee2b0/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e33ea1fff581f74478b8181614b0a424dee2b0/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=43e33ea1fff581f74478b8181614b0a424dee2b0", "patch": "@@ -84,7 +84,7 @@ rustc_queries! {\n         /// Set of all the `DefId`s in this crate that have MIR associated with\n         /// them. This includes all the body owners, but also things like struct\n         /// constructors.\n-        query mir_keys(_: CrateNum) -> Lrc<DefIdSet> {\n+        query mir_keys(_: CrateNum) -> &'tcx DefIdSet {\n             desc { \"getting a list of all mir_keys\" }\n         }\n "}, {"sha": "a76cc3dfdec02a1686729d652d79cfc2f835b93e", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43e33ea1fff581f74478b8181614b0a424dee2b0/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e33ea1fff581f74478b8181614b0a424dee2b0/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=43e33ea1fff581f74478b8181614b0a424dee2b0", "patch": "@@ -296,7 +296,9 @@ macro_rules! __impl_decoder_methods {\n \n #[macro_export]\n macro_rules! impl_arena_allocatable_decoder {\n-    ([$DecoderName:ident [$($typaram:tt),*]], [[decode] $name:ident: $ty:ty], $tcx:lifetime) => {\n+    ([]$args:tt) => {};\n+    ([decode $(, $attrs:ident)*]\n+     [[$DecoderName:ident [$($typaram:tt),*]], [$name:ident: $ty:ty], $tcx:lifetime]) => {\n         impl<$($typaram),*> SpecializedDecoder<&$tcx $ty> for $DecoderName<$($typaram),*> {\n             #[inline]\n             fn specialized_decode(&mut self) -> Result<&$tcx $ty, Self::Error> {\n@@ -311,14 +313,16 @@ macro_rules! impl_arena_allocatable_decoder {\n             }\n         }\n     };\n-    ([$DecoderName:ident [$($typaram:tt),*]], [[] $name:ident: $ty:ty], $tcx:lifetime) => {};\n+    ([$ignore:ident $(, $attrs:ident)*]$args:tt) => {\n+        impl_arena_allocatable_decoder!([$($attrs),*]$args);\n+    };\n }\n \n #[macro_export]\n macro_rules! impl_arena_allocatable_decoders {\n     ($args:tt, [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n         $(\n-            impl_arena_allocatable_decoder!($args, [$a $name: $ty], $tcx);\n+            impl_arena_allocatable_decoder!($a [$args, [$name: $ty], $tcx]);\n         )*\n     }\n }"}, {"sha": "27cb87f5dcaa0f2afcc3d871d1c48ab7c309710a", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43e33ea1fff581f74478b8181614b0a424dee2b0/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e33ea1fff581f74478b8181614b0a424dee2b0/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=43e33ea1fff581f74478b8181614b0a424dee2b0", "patch": "@@ -8,7 +8,6 @@ use rustc::ty::steal::Steal;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::util::nodemap::DefIdSet;\n-use rustc_data_structures::sync::Lrc;\n use std::borrow::Cow;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -59,7 +58,7 @@ fn is_mir_available<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> boo\n /// Finds the full set of `DefId`s within the current crate that have\n /// MIR associated with them.\n fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n-                      -> Lrc<DefIdSet> {\n+                      -> &'tcx DefIdSet {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let mut set = DefIdSet::default();\n@@ -94,7 +93,7 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n         set: &mut set,\n     }.as_deep_visitor());\n \n-    Lrc::new(set)\n+    tcx.arena.alloc(set)\n }\n \n fn mir_built<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {"}]}