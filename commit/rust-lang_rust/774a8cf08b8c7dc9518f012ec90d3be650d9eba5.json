{"sha": "774a8cf08b8c7dc9518f012ec90d3be650d9eba5", "node_id": "C_kwDOAAsO6NoAKDc3NGE4Y2YwOGI4YzdkYzk1MThmMDEyZWM5MGQzYmU2NTBkOWViYTU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-28T13:31:55Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-28T17:22:32Z"}, "message": "Fix inline_call breaking RecordExprField shorthands", "tree": {"sha": "9f236a23a57fc3e3e4355b7108aa37fe171c1182", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f236a23a57fc3e3e4355b7108aa37fe171c1182"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/774a8cf08b8c7dc9518f012ec90d3be650d9eba5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/774a8cf08b8c7dc9518f012ec90d3be650d9eba5", "html_url": "https://github.com/rust-lang/rust/commit/774a8cf08b8c7dc9518f012ec90d3be650d9eba5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/774a8cf08b8c7dc9518f012ec90d3be650d9eba5/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "533ca584c31a251bc47f978b55df9b69058dabba", "url": "https://api.github.com/repos/rust-lang/rust/commits/533ca584c31a251bc47f978b55df9b69058dabba", "html_url": "https://github.com/rust-lang/rust/commit/533ca584c31a251bc47f978b55df9b69058dabba"}], "stats": {"total": 132, "additions": 112, "deletions": 20}, "files": [{"sha": "d252d61a6960f1c11cb008cd46efcd997d1a761e", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "modified", "additions": 79, "deletions": 14, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/774a8cf08b8c7dc9518f012ec90d3be650d9eba5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/774a8cf08b8c7dc9518f012ec90d3be650d9eba5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=774a8cf08b8c7dc9518f012ec90d3be650d9eba5", "patch": "@@ -4,14 +4,14 @@ use hir::{db::HirDatabase, HasSource, PathResolution, Semantics, TypeInfo};\n use ide_db::{\n     base_db::{FileId, FileRange},\n     defs::Definition,\n-    helpers::insert_use::remove_path_if_in_use_stmt,\n+    helpers::{insert_use::remove_path_if_in_use_stmt, node_ext::expr_as_name_ref},\n     path_transform::PathTransform,\n     search::{FileReference, SearchScope},\n     RootDatabase,\n };\n use itertools::{izip, Itertools};\n use syntax::{\n-    ast::{self, edit_in_place::Indent, HasArgList},\n+    ast::{self, edit_in_place::Indent, HasArgList, PathExpr},\n     ted, AstNode, SyntaxNode,\n };\n \n@@ -359,33 +359,37 @@ fn inline(\n     }\n     // Inline parameter expressions or generate `let` statements depending on whether inlining works or not.\n     for ((pat, param_ty, _), usages, expr) in izip!(params, param_use_nodes, arguments).rev() {\n-        let expr_is_name_ref = matches!(&expr,\n-            ast::Expr::PathExpr(expr)\n-                if expr.path().and_then(|path| path.as_single_name_ref()).is_some()\n-        );\n-        match &*usages {\n+        let inline_direct = |usage, replacement: &ast::Expr| {\n+            if let Some(field) = path_expr_as_record_field(usage) {\n+                cov_mark::hit!(inline_call_inline_direct_field);\n+                field.replace_expr(replacement.clone_for_update());\n+            } else {\n+                ted::replace(usage.syntax(), &replacement.syntax().clone_for_update());\n+            }\n+        };\n+        // izip confuses RA due to our lack of hygiene info currently losing us typeinfo\n+        let usages: &[ast::PathExpr] = &*usages;\n+        match usages {\n             // inline single use closure arguments\n             [usage]\n                 if matches!(expr, ast::Expr::ClosureExpr(_))\n                     && usage.syntax().parent().and_then(ast::Expr::cast).is_some() =>\n             {\n                 cov_mark::hit!(inline_call_inline_closure);\n                 let expr = make::expr_paren(expr.clone());\n-                ted::replace(usage.syntax(), expr.syntax().clone_for_update());\n+                inline_direct(usage, &expr);\n             }\n             // inline single use literals\n             [usage] if matches!(expr, ast::Expr::Literal(_)) => {\n                 cov_mark::hit!(inline_call_inline_literal);\n-                ted::replace(usage.syntax(), expr.syntax().clone_for_update());\n+                inline_direct(usage, &expr);\n             }\n             // inline direct local arguments\n-            [_, ..] if expr_is_name_ref => {\n+            [_, ..] if expr_as_name_ref(&expr).is_some() => {\n                 cov_mark::hit!(inline_call_inline_locals);\n-                usages.into_iter().for_each(|usage| {\n-                    ted::replace(usage.syntax(), &expr.syntax().clone_for_update());\n-                });\n+                usages.into_iter().for_each(|usage| inline_direct(usage, &expr));\n             }\n-            // cant inline, emit a let statement\n+            // can't inline, emit a let statement\n             _ => {\n                 let ty =\n                     sema.type_of_expr(expr).filter(TypeInfo::has_adjustment).and(param_ty.clone());\n@@ -421,6 +425,12 @@ fn inline(\n     }\n }\n \n+fn path_expr_as_record_field(usage: &PathExpr) -> Option<ast::RecordExprField> {\n+    let path = usage.path()?;\n+    let name_ref = path.as_single_name_ref()?;\n+    ast::RecordExprField::for_name_ref(&name_ref)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -1022,6 +1032,61 @@ fn foo$0() {\n fn foo() {\n     foo$0();\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inline_call_field_shorthand() {\n+        cov_mark::check!(inline_call_inline_direct_field);\n+        check_assist(\n+            inline_call,\n+            r#\"\n+struct Foo {\n+    field: u32,\n+    field1: u32,\n+    field2: u32,\n+    field3: u32,\n+}\n+fn foo(field: u32, field1: u32, val2: u32, val3: u32) -> Foo {\n+    Foo {\n+        field,\n+        field1,\n+        field2: val2,\n+        field3: val3,\n+    }\n+}\n+fn main() {\n+    let bar = 0;\n+    let baz = 0;\n+    foo$0(bar, 0, baz, 0);\n+}\n+\"#,\n+            r#\"\n+struct Foo {\n+    field: u32,\n+    field1: u32,\n+    field2: u32,\n+    field3: u32,\n+}\n+fn foo(field: u32, field1: u32, val2: u32, val3: u32) -> Foo {\n+    Foo {\n+        field,\n+        field1,\n+        field2: val2,\n+        field3: val3,\n+    }\n+}\n+fn main() {\n+    let bar = 0;\n+    let baz = 0;\n+    Foo {\n+            field: bar,\n+            field1: 0,\n+            field2: baz,\n+            field3: 0,\n+        };\n+}\n \"#,\n         );\n     }"}, {"sha": "82178ed74962259190017accaa9cb872948b8a7b", "filename": "crates/ide_db/src/helpers/node_ext.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/774a8cf08b8c7dc9518f012ec90d3be650d9eba5/crates%2Fide_db%2Fsrc%2Fhelpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/774a8cf08b8c7dc9518f012ec90d3be650d9eba5/crates%2Fide_db%2Fsrc%2Fhelpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fnode_ext.rs?ref=774a8cf08b8c7dc9518f012ec90d3be650d9eba5", "patch": "@@ -7,18 +7,16 @@ use syntax::{\n pub fn expr_as_name_ref(expr: &ast::Expr) -> Option<ast::NameRef> {\n     if let ast::Expr::PathExpr(expr) = expr {\n         let path = expr.path()?;\n-        let segment = path.segment()?;\n-        let name_ref = segment.name_ref()?;\n-        if path.qualifier().is_none() {\n-            return Some(name_ref);\n-        }\n+        path.as_single_name_ref()\n+    } else {\n+        None\n     }\n-    None\n }\n \n pub fn block_as_lone_tail(block: &ast::BlockExpr) -> Option<ast::Expr> {\n     block.statements().next().is_none().then(|| block.tail_expr()).flatten()\n }\n+\n /// Preorder walk all the expression's child expressions.\n pub fn walk_expr(expr: &ast::Expr, cb: &mut dyn FnMut(ast::Expr)) {\n     preorder_expr(expr, &mut |ev| {"}, {"sha": "d271b5f836f2517b2fae301487457aaca7c9e744", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/774a8cf08b8c7dc9518f012ec90d3be650d9eba5/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/774a8cf08b8c7dc9518f012ec90d3be650d9eba5/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=774a8cf08b8c7dc9518f012ec90d3be650d9eba5", "patch": "@@ -451,6 +451,35 @@ impl ast::RecordExprFieldList {\n     }\n }\n \n+impl ast::RecordExprField {\n+    /// This will either replace the initializer, or in the case that this is a shorthand convert\n+    /// the initializer into the name ref and insert the expr as the new initializer.\n+    pub fn replace_expr(&self, expr: ast::Expr) {\n+        if let Some(_) = self.name_ref() {\n+            match self.expr() {\n+                Some(prev) => ted::replace(prev.syntax(), expr.syntax()),\n+                None => ted::append_child(self.syntax(), expr.syntax()),\n+            }\n+            return;\n+        }\n+        // this is a shorthand\n+        if let Some(ast::Expr::PathExpr(path_expr)) = self.expr() {\n+            if let Some(path) = path_expr.path() {\n+                if let Some(name_ref) = path.as_single_name_ref() {\n+                    path_expr.syntax().detach();\n+                    let children = vec![\n+                        name_ref.syntax().clone().into(),\n+                        ast::make::token(T![:]).into(),\n+                        ast::make::tokens::single_space().into(),\n+                        expr.syntax().clone().into(),\n+                    ];\n+                    ted::insert_all_raw(Position::last_child_of(self.syntax()), children);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl ast::StmtList {\n     pub fn push_front(&self, statement: ast::Stmt) {\n         ted::insert(Position::after(self.l_curly_token().unwrap()), statement.syntax());"}]}