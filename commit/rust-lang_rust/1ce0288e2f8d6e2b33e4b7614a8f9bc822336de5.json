{"sha": "1ce0288e2f8d6e2b33e4b7614a8f9bc822336de5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZTAyODhlMmY4ZDZlMmIzM2U0Yjc2MTRhOGY5YmM4MjIzMzZkZTU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-25T02:57:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-25T02:57:32Z"}, "message": "Rollup merge of #61092 - spastorino:sanitize-place-iterative, r=oli-obk\n\nMake sanitize_place iterate instead of recurse\n\nr? @oli-obk", "tree": {"sha": "5344a668b9f23aac003089f82b0b6c65b81a1f0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5344a668b9f23aac003089f82b0b6c65b81a1f0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ce0288e2f8d6e2b33e4b7614a8f9bc822336de5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc6K8cCRBK7hj4Ov3rIwAAdHIIADdyA/KEGqZqHHQmOX7/FGQo\nnPPcrNefjS1/bDq9Vm7WCuZhfPoBs1vPcnjXTxzsCQCcIE6usBxaRl0nC8mvH1K2\nXnAG95mq80vqaPLGMhWGrpotC+cLJAdKkWOFZ0OXXizGn4AQ5myu09eXmMEKtSvZ\nzytp3JEdNg64ZfII5cD6sYOARl45/fIIoWhF6DJhXC1LAQQ2bqWaWxilqc3yn8Z6\n87oo3/IZuxL3x4Fa5iDQmG7AtQXN3Hi66i6zu0emGgzMrxUWkBXAWup3YsUzn+Rb\nnLguDhBTBlOI0liJZvHSVkDWgutAXdLFgQ6dt2d2vy5Yoa6OIrhxEDg9eCI52h4=\n=7YNN\n-----END PGP SIGNATURE-----\n", "payload": "tree 5344a668b9f23aac003089f82b0b6c65b81a1f0e\nparent dec4c5201f88efbc3020b04ba96a5ee2c3b6cfcd\nparent 03dc30d3d523753b44daab007d67e160a9a9d794\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1558753052 +0200\ncommitter GitHub <noreply@github.com> 1558753052 +0200\n\nRollup merge of #61092 - spastorino:sanitize-place-iterative, r=oli-obk\n\nMake sanitize_place iterate instead of recurse\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ce0288e2f8d6e2b33e4b7614a8f9bc822336de5", "html_url": "https://github.com/rust-lang/rust/commit/1ce0288e2f8d6e2b33e4b7614a8f9bc822336de5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ce0288e2f8d6e2b33e4b7614a8f9bc822336de5/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dec4c5201f88efbc3020b04ba96a5ee2c3b6cfcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec4c5201f88efbc3020b04ba96a5ee2c3b6cfcd", "html_url": "https://github.com/rust-lang/rust/commit/dec4c5201f88efbc3020b04ba96a5ee2c3b6cfcd"}, {"sha": "03dc30d3d523753b44daab007d67e160a9a9d794", "url": "https://api.github.com/repos/rust-lang/rust/commits/03dc30d3d523753b44daab007d67e160a9a9d794", "html_url": "https://github.com/rust-lang/rust/commit/03dc30d3d523753b44daab007d67e160a9a9d794"}], "stats": {"total": 153, "additions": 78, "deletions": 75}, "files": [{"sha": "52c8f15c44bb983500d9a1d42435be4322be92d0", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 78, "deletions": 75, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/1ce0288e2f8d6e2b33e4b7614a8f9bc822336de5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ce0288e2f8d6e2b33e4b7614a8f9bc822336de5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=1ce0288e2f8d6e2b33e4b7614a8f9bc822336de5", "patch": "@@ -29,7 +29,7 @@ use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionV\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::mir::interpret::{InterpError::BoundsCheck, ConstValue};\n use rustc::mir::tcx::PlaceTy;\n-use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n+use rustc::mir::visit::{PlaceContext, Visitor, NonMutatingUseContext};\n use rustc::mir::*;\n use rustc::traits::query::type_op;\n use rustc::traits::query::type_op::custom::CustomTypeOp;\n@@ -447,92 +447,95 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         context: PlaceContext,\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n-        let place_ty = match place {\n-            Place::Base(PlaceBase::Local(index)) =>\n-                PlaceTy::from_ty(self.mir.local_decls[*index].ty),\n-            Place::Base(PlaceBase::Static(box Static { kind, ty: sty })) => {\n-                let sty = self.sanitize_type(place, sty);\n-                let check_err =\n-                    |verifier: &mut TypeVerifier<'a, 'b, 'gcx, 'tcx>,\n-                     place: &Place<'tcx>,\n-                     ty,\n-                     sty| {\n-                        if let Err(terr) = verifier.cx.eq_types(\n-                            sty,\n-                            ty,\n-                            location.to_locations(),\n-                            ConstraintCategory::Boring,\n-                        ) {\n-                            span_mirbug!(\n-                            verifier,\n-                            place,\n-                            \"bad promoted type ({:?}: {:?}): {:?}\",\n-                            ty,\n-                            sty,\n-                            terr\n-                        );\n+\n+        place.iterate(|place_base, place_projection| {\n+            let mut place_ty = match place_base {\n+                PlaceBase::Local(index) =>\n+                    PlaceTy::from_ty(self.mir.local_decls[*index].ty),\n+                PlaceBase::Static(box Static { kind, ty: sty }) => {\n+                    let sty = self.sanitize_type(place, sty);\n+                    let check_err =\n+                        |verifier: &mut TypeVerifier<'a, 'b, 'gcx, 'tcx>,\n+                         place: &Place<'tcx>,\n+                         ty,\n+                         sty| {\n+                            if let Err(terr) = verifier.cx.eq_types(\n+                                sty,\n+                                ty,\n+                                location.to_locations(),\n+                                ConstraintCategory::Boring,\n+                            ) {\n+                                span_mirbug!(\n+                                verifier,\n+                                place,\n+                                \"bad promoted type ({:?}: {:?}): {:?}\",\n+                                ty,\n+                                sty,\n+                                terr\n+                            );\n+                            };\n                         };\n-                    };\n-                match kind {\n-                    StaticKind::Promoted(promoted) => {\n-                        if !self.errors_reported {\n-                            let promoted_mir = &self.mir.promoted[*promoted];\n-                            self.sanitize_promoted(promoted_mir, location);\n-\n-                            let promoted_ty = promoted_mir.return_ty();\n-                            check_err(self, place, promoted_ty, sty);\n+                    match kind {\n+                        StaticKind::Promoted(promoted) => {\n+                            if !self.errors_reported {\n+                                let promoted_mir = &self.mir.promoted[*promoted];\n+                                self.sanitize_promoted(promoted_mir, location);\n+\n+                                let promoted_ty = promoted_mir.return_ty();\n+                                check_err(self, place, promoted_ty, sty);\n+                            }\n                         }\n-                    }\n-                    StaticKind::Static(def_id) => {\n-                        let ty = self.tcx().type_of(*def_id);\n-                        let ty = self.cx.normalize(ty, location);\n+                        StaticKind::Static(def_id) => {\n+                            let ty = self.tcx().type_of(*def_id);\n+                            let ty = self.cx.normalize(ty, location);\n \n-                        check_err(self, place, ty, sty);\n+                            check_err(self, place, ty, sty);\n+                        }\n                     }\n+                    PlaceTy::from_ty(sty)\n+                }\n+            };\n+\n+            // FIXME use place_projection.is_empty() when is available\n+            if let Place::Base(_) = place {\n+                if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n+                    let tcx = self.tcx();\n+                    let trait_ref = ty::TraitRef {\n+                        def_id: tcx.lang_items().copy_trait().unwrap(),\n+                        substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n+                    };\n+\n+                    // In order to have a Copy operand, the type T of the\n+                    // value must be Copy. Note that we prove that T: Copy,\n+                    // rather than using the `is_copy_modulo_regions`\n+                    // test. This is important because\n+                    // `is_copy_modulo_regions` ignores the resulting region\n+                    // obligations and assumes they pass. This can result in\n+                    // bounds from Copy impls being unsoundly ignored (e.g.,\n+                    // #29149). Note that we decide to use Copy before knowing\n+                    // whether the bounds fully apply: in effect, the rule is\n+                    // that if a value of some type could implement Copy, then\n+                    // it must.\n+                    self.cx.prove_trait_ref(\n+                        trait_ref,\n+                        location.to_locations(),\n+                        ConstraintCategory::CopyBound,\n+                    );\n                 }\n-                PlaceTy::from_ty(sty)\n             }\n-            Place::Projection(ref proj) => {\n-                let base_context = if context.is_mutating_use() {\n-                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n-                } else {\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n-                };\n-                let base_ty = self.sanitize_place(&proj.base, location, base_context);\n-                if base_ty.variant_index.is_none() {\n-                    if base_ty.ty.references_error() {\n+\n+            for proj in place_projection {\n+                if place_ty.variant_index.is_none() {\n+                    if place_ty.ty.references_error() {\n                         assert!(self.errors_reported);\n                         return PlaceTy::from_ty(self.tcx().types.err);\n                     }\n                 }\n-                self.sanitize_projection(base_ty, &proj.elem, place, location)\n+                place_ty = self.sanitize_projection(place_ty, &proj.elem, place, location)\n             }\n-        };\n-        if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-            let tcx = self.tcx();\n-            let trait_ref = ty::TraitRef {\n-                def_id: tcx.lang_items().copy_trait().unwrap(),\n-                substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n-            };\n \n-            // In order to have a Copy operand, the type T of the\n-            // value must be Copy. Note that we prove that T: Copy,\n-            // rather than using the `is_copy_modulo_regions`\n-            // test. This is important because\n-            // `is_copy_modulo_regions` ignores the resulting region\n-            // obligations and assumes they pass. This can result in\n-            // bounds from Copy impls being unsoundly ignored (e.g.,\n-            // #29149). Note that we decide to use Copy before knowing\n-            // whether the bounds fully apply: in effect, the rule is\n-            // that if a value of some type could implement Copy, then\n-            // it must.\n-            self.cx.prove_trait_ref(\n-                trait_ref,\n-                location.to_locations(),\n-                ConstraintCategory::CopyBound,\n-            );\n-        }\n-        place_ty\n+            place_ty\n+        })\n     }\n \n     fn sanitize_promoted(&mut self, promoted_mir: &'b Mir<'tcx>, location: Location) {"}]}