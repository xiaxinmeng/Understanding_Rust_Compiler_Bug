{"sha": "c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f", "node_id": "C_kwDOAAsO6NoAKGM5ODk3NDZjY2ZhZTIyZGQwZjdmNmQxZTNkNGY5ODRhYzg4ODllOWY", "commit": {"author": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-08T20:02:26Z"}, "committer": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-19T18:00:20Z"}, "message": "Remove checks on char slice; improve lint suggestion", "tree": {"sha": "bc36044377aaf4b2976064a7c43baf1d8a73353e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc36044377aaf4b2976064a7c43baf1d8a73353e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f", "html_url": "https://github.com/rust-lang/rust/commit/c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242", "html_url": "https://github.com/rust-lang/rust/commit/a9bd0bd3214f04e5f3df9cc5cd9f6ecd375e6242"}], "stats": {"total": 150, "additions": 59, "deletions": 91}, "files": [{"sha": "1760232041add00d957ea7d0c78898294fb632d3", "filename": "clippy_lints/src/methods/collapsible_str_replace.rs", "status": "modified", "additions": 29, "deletions": 60, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs?ref=c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f", "patch": "@@ -11,6 +11,7 @@ use rustc_hir::*;\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Spanned;\n+use rustc_span::Span;\n \n use super::method_call;\n use super::COLLAPSIBLE_STR_REPLACE;\n@@ -23,31 +24,20 @@ pub(super) fn check<'tcx>(\n     args: &'tcx [hir::Expr<'tcx>],\n ) {\n     match (name, args) {\n-        (\"replace\", [from, to]) => {\n+        (\"replace\", ..) => {\n             // The receiver of the method call must be `str` type to lint `collapsible_str_replace`\n             let original_recv = find_original_recv(recv);\n             let original_recv_ty_kind = cx.typeck_results().expr_ty(original_recv).peel_refs().kind();\n             let original_recv_is_str_kind = matches!(original_recv_ty_kind, ty::Str);\n \n-            if_chain! {\n-                // Check for `str::replace` calls with char slice for linting\n-                if original_recv_is_str_kind;\n-                let from_ty_kind = cx.typeck_results().expr_ty(from).peel_refs().kind();\n-                if let ty::Array(array_ty, _) = from_ty_kind;\n-                if matches!(array_ty.kind(), ty::Char);\n-                then {\n-                    check_replace_call_with_char_slice(cx, from, to);\n-                    return;\n-                }\n-            }\n-\n             if_chain! {\n                 if original_recv_is_str_kind;\n                 if let Some(parent) = get_parent_expr(cx, expr);\n-                if let Some((name, [..], _)) = method_call(parent);\n+                if let Some((name, ..)) = method_call(parent);\n \n                 then {\n                     match name {\n+                        // If the parent node is a `str::replace` call, we've already handled the lint, don't lint again\n                         \"replace\" => return,\n                         _ => {\n                             check_consecutive_replace_calls(cx, expr);\n@@ -59,7 +49,7 @@ pub(super) fn check<'tcx>(\n \n             match method_call(recv) {\n                 // Check if there's an earlier `str::replace` call\n-                Some((\"replace\", [_, _, _], _)) => {\n+                Some((\"replace\", ..)) => {\n                     if original_recv_is_str_kind {\n                         check_consecutive_replace_calls(cx, expr);\n                         return;\n@@ -72,55 +62,14 @@ pub(super) fn check<'tcx>(\n     }\n }\n \n-/// Check a `str::replace` call that contains a char slice as `from` argument for\n-/// `collapsible_str_replace` lint.\n-fn check_replace_call_with_char_slice<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    from_arg: &'tcx hir::Expr<'tcx>,\n-    to_arg: &'tcx hir::Expr<'tcx>,\n-) {\n-    let mut char_slice_has_no_variables = true;\n-    let mut chars: Vec<String> = Vec::new();\n-\n-    // Go through the `from_arg` to collect all char literals\n-    let _: Option<()> = for_each_expr(from_arg, |e| {\n-        if let ExprKind::Lit(Spanned {\n-            node: LitKind::Char(_), ..\n-        }) = e.kind\n-        {\n-            chars.push(get_replace_call_char_arg_repr(e).unwrap());\n-            ControlFlow::Continue(())\n-        } else if let ExprKind::Path(..) = e.kind {\n-            // If a variable is found in the char slice, no lint for first version of this lint\n-            char_slice_has_no_variables = false;\n-            ControlFlow::BREAK\n-        } else {\n-            ControlFlow::Continue(())\n-        }\n-    });\n-\n-    if char_slice_has_no_variables {\n-        if let Some(to_arg_repr) = get_replace_call_char_arg_repr(to_arg) {\n-            let app = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                COLLAPSIBLE_STR_REPLACE,\n-                from_arg.span,\n-                \"used slice of chars in `str::replace` call\",\n-                \"replace with\",\n-                format!(\"replace(|c| matches!(c, {}), {})\", chars.join(\" | \"), to_arg_repr,),\n-                app,\n-            );\n-        }\n-    }\n-}\n-\n /// Check a chain of `str::replace` calls for `collapsible_str_replace` lint.\n fn check_consecutive_replace_calls<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n     if_chain! {\n         if let Some(from_args) = get_replace_call_from_args_if_all_char_ty(cx, expr);\n         if let Some(to_arg) = get_replace_call_unique_to_arg_repr(expr);\n         then {\n+            let earliest_replace_call_span = get_earliest_replace_call_span(expr);\n+\n             if replace_call_from_args_are_only_lit_chars(&from_args) {\n                 let from_arg_reprs: Vec<String> = from_args.iter().map(|from_arg| {\n                     get_replace_call_char_arg_repr(from_arg).unwrap()\n@@ -130,7 +79,7 @@ fn check_consecutive_replace_calls<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir\n                 span_lint_and_sugg(\n                     cx,\n                     COLLAPSIBLE_STR_REPLACE,\n-                    expr.span,\n+                    expr.span.with_lo(earliest_replace_call_span.lo()),\n                     \"used consecutive `str::replace` call\",\n                     \"replace with\",\n                     format!(\n@@ -150,7 +99,7 @@ fn check_consecutive_replace_calls<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir\n                 span_lint_and_sugg(\n                     cx,\n                     COLLAPSIBLE_STR_REPLACE,\n-                    expr.span,\n+                    expr.span.with_lo(earliest_replace_call_span.lo()),\n                     \"used consecutive `str::replace` call\",\n                     \"replace with\",\n                     format!(\n@@ -295,6 +244,26 @@ fn get_replace_call_char_arg_repr<'tcx>(arg: &'tcx hir::Expr<'tcx>) -> Option<St\n     }\n }\n \n+fn get_earliest_replace_call_span<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Span {\n+    let mut earliest_replace_call_span = expr.span;\n+\n+    let _: Option<()> = for_each_expr(expr, |e| {\n+        if let Some((name, [_, args @ ..], span)) = method_call(e) {\n+            match (name, args) {\n+                (\"replace\", [_, _]) => {\n+                    earliest_replace_call_span = span;\n+                    ControlFlow::Continue(())\n+                },\n+                _ => ControlFlow::BREAK,\n+            }\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    });\n+\n+    earliest_replace_call_span\n+}\n+\n /// Find the original receiver of a chain of `str::replace` method calls.\n fn find_original_recv<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> &'tcx hir::Expr<'tcx> {\n     let mut original_recv = recv;"}, {"sha": "05a4fd08a327b26229a87cbfffe062a009ea7624", "filename": "tests/ui/collapsible_str_replace.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f/tests%2Fui%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f/tests%2Fui%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_str_replace.rs?ref=c989746ccfae22dd0f7f6d1e3d4f984ac8889e9f", "patch": "@@ -13,36 +13,38 @@ fn main() {\n     let l = \"l\";\n \n     // LINT CASES\n-    // If the first argument to a single `str::replace` call is a slice and none of the chars\n-    // are variables, recommend `collapsible_str_replace`\n-    let replacement = misspelled.replace(&['s', 'u', 'p'], \"l\");\n+    let replacement = misspelled.replace('s', \"l\").replace('u', \"l\");\n     println!(\"{replacement}\");\n \n-    let replacement = misspelled.replace(&['s', 'u', 'p'], l);\n+    let replacement = misspelled.replace('s', l).replace('u', l);\n     println!(\"{replacement}\");\n \n-    // If multiple `str::replace` calls contain slices and none of the chars are variables,\n-    // recommend `collapsible_str_replace`\n-    let replacement = misspelled.replace(&['s', 'u'], \"l\").replace(&['u', 'p'], \"l\");\n+    let replacement = misspelled.replace('s', \"l\").replace('u', \"l\").replace('p', \"l\");\n     println!(\"{replacement}\");\n \n-    let replacement = misspelled.replace('s', \"l\").replace(&['u', 'p'], \"l\");\n+    let replacement = misspelled\n+        .replace('s', \"l\")\n+        .replace('u', \"l\")\n+        .replace('p', \"l\")\n+        .replace('d', \"l\");\n     println!(\"{replacement}\");\n \n-    let replacement = misspelled.replace(&['s', 'u'], \"l\").replace('p', \"l\");\n-    println!(\"replacement\");\n+    // FALLBACK CASES\n+    // If there are consecutive calls to `str::replace` and all or any chars are variables,\n+    // recommend the fallback `misspelled.replace(&[s, u, p], \"l\")`\n+    let replacement = misspelled.replace(s, \"l\").replace('u', \"l\");\n+    println!(\"{replacement}\");\n \n-    // If there are consecutive calls to `str::replace` and none of the chars are variables,\n-    // recommend `collapsible_str_replace`\n-    let replacement = misspelled.replace('s', \"l\").replace('u', \"l\");\n+    let replacement = misspelled.replace(s, \"l\").replace('u', \"l\").replace('p', \"l\");\n     println!(\"{replacement}\");\n \n-    let replacement = misspelled.replace('s', \"l\").replace('u', \"l\").replace('p', \"l\");\n+    let replacement = misspelled.replace(s, \"l\").replace(u, \"l\").replace('p', \"l\");\n+    println!(\"{replacement}\");\n+\n+    let replacement = misspelled.replace(s, \"l\").replace(u, \"l\").replace(p, \"l\");\n     println!(\"{replacement}\");\n \n     // NO LINT CASES\n-    // If there is a single call to `str::replace` and the first argument is a char or a variable,\n-    // do not recommend `collapsible_str_replace`\n     let replacement = misspelled.replace('s', \"l\");\n     println!(\"{replacement}\");\n \n@@ -53,36 +55,33 @@ fn main() {\n     let replacement = misspelled.replace('s', \"l\").replace('u', \"p\");\n     println!(\"{replacement}\");\n \n-    // If the `from` argument is of kind other than a slice or a char, do not lint\n     let replacement = misspelled.replace(&get_filter(), \"l\");\n+    println!(\"{replacement}\");\n \n-    // NO LINT TIL IMPROVEMENT\n-    // The first iteration of `collapsible_str_replace` will not create lint if the first argument to\n-    // a single `str::replace` call is a slice and one or more of its chars are variables\n-    let replacement = misspelled.replace(&['s', u, 'p'], \"l\");\n+    let replacement = misspelled.replace(&['s', 'u', 'p'], \"l\");\n     println!(\"{replacement}\");\n \n-    let replacement = misspelled.replace(&[s, u, 'p'], \"l\");\n+    let replacement = misspelled.replace(&['s', 'u', 'p'], l);\n     println!(\"{replacement}\");\n \n-    let replacement = misspelled.replace(&[s, u, p], \"l\");\n+    let replacement = misspelled.replace(&['s', 'u'], \"l\").replace(&['u', 'p'], \"l\");\n     println!(\"{replacement}\");\n \n-    let replacement = misspelled.replace(&[s, u], \"l\").replace(&[u, p], \"l\");\n+    let replacement = misspelled.replace('s', \"l\").replace(&['u', 'p'], \"l\");\n     println!(\"{replacement}\");\n \n-    // FALLBACK CASES\n-    // If there are consecutive calls to `str::replace` and all or any chars are variables,\n-    // recommend the fallback `misspelled.replace(&[s, u, p], \"l\")`\n-    let replacement = misspelled.replace(s, \"l\").replace('u', \"l\");\n+    let replacement = misspelled.replace(&['s', 'u'], \"l\").replace('p', \"l\");\n+    println!(\"replacement\");\n+\n+    let replacement = misspelled.replace(&['s', u, 'p'], \"l\");\n     println!(\"{replacement}\");\n \n-    let replacement = misspelled.replace(s, \"l\").replace('u', \"l\").replace('p', \"l\");\n+    let replacement = misspelled.replace(&[s, u, 'p'], \"l\");\n     println!(\"{replacement}\");\n \n-    let replacement = misspelled.replace(s, \"l\").replace(u, \"l\").replace('p', \"l\");\n+    let replacement = misspelled.replace(&[s, u, p], \"l\");\n     println!(\"{replacement}\");\n \n-    let replacement = misspelled.replace(s, \"l\").replace(u, \"l\").replace(p, \"l\");\n+    let replacement = misspelled.replace(&[s, u], \"l\").replace(&[u, p], \"l\");\n     println!(\"{replacement}\");\n }"}]}