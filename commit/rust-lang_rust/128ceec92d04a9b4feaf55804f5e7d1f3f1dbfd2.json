{"sha": "128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2", "node_id": "C_kwDOAAsO6NoAKDEyOGNlZWM5MmQwNGE5YjRmZWFmNTU4MDRmNWU3ZDFmM2YxZGJmZDI", "commit": {"author": {"name": "Petr Sumbera", "email": "petr.sumbera@oracle.com", "date": "2021-12-01T09:03:45Z"}, "committer": {"name": "Petr Sumbera", "email": "petr.sumbera@oracle.com", "date": "2021-12-01T09:03:45Z"}, "message": "fix sparc64 ABI for aggregates with floating point members", "tree": {"sha": "afa1955bbcb51551f1f90ee250ed5f70cab58659", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afa1955bbcb51551f1f90ee250ed5f70cab58659"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2", "html_url": "https://github.com/rust-lang/rust/commit/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/comments", "author": {"login": "psumbera", "id": 4249116, "node_id": "MDQ6VXNlcjQyNDkxMTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4249116?v=4", "gravatar_id": "", "url": "https://api.github.com/users/psumbera", "html_url": "https://github.com/psumbera", "followers_url": "https://api.github.com/users/psumbera/followers", "following_url": "https://api.github.com/users/psumbera/following{/other_user}", "gists_url": "https://api.github.com/users/psumbera/gists{/gist_id}", "starred_url": "https://api.github.com/users/psumbera/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/psumbera/subscriptions", "organizations_url": "https://api.github.com/users/psumbera/orgs", "repos_url": "https://api.github.com/users/psumbera/repos", "events_url": "https://api.github.com/users/psumbera/events{/privacy}", "received_events_url": "https://api.github.com/users/psumbera/received_events", "type": "User", "site_admin": false}, "committer": {"login": "psumbera", "id": 4249116, "node_id": "MDQ6VXNlcjQyNDkxMTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4249116?v=4", "gravatar_id": "", "url": "https://api.github.com/users/psumbera", "html_url": "https://github.com/psumbera", "followers_url": "https://api.github.com/users/psumbera/followers", "following_url": "https://api.github.com/users/psumbera/following{/other_user}", "gists_url": "https://api.github.com/users/psumbera/gists{/gist_id}", "starred_url": "https://api.github.com/users/psumbera/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/psumbera/subscriptions", "organizations_url": "https://api.github.com/users/psumbera/orgs", "repos_url": "https://api.github.com/users/psumbera/repos", "events_url": "https://api.github.com/users/psumbera/events{/privacy}", "received_events_url": "https://api.github.com/users/psumbera/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6414e0b5b308d3ae27da83c6a25098cc8aadc1a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6414e0b5b308d3ae27da83c6a25098cc8aadc1a9", "html_url": "https://github.com/rust-lang/rust/commit/6414e0b5b308d3ae27da83c6a25098cc8aadc1a9"}], "stats": {"total": 330, "additions": 272, "deletions": 58}, "files": [{"sha": "45d4906259312db4942a3d662acac102593514a6", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2", "patch": "@@ -71,7 +71,7 @@ fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n         .prefix\n         .iter()\n         .flatten()\n-        .map(|&kind| reg_to_abi_param(Reg { kind, size: cast.prefix_chunk_size }))\n+        .map(|&reg| reg_to_abi_param(reg))\n         .chain((0..rest_count).map(|_| reg_to_abi_param(cast.rest.unit)))\n         .collect::<SmallVec<_>>();\n "}, {"sha": "f1b9c310e728a6df7def182eadaf73a01d9c5e51", "filename": "compiler/rustc_codegen_gcc/src/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs?ref=128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2", "patch": "@@ -48,8 +48,8 @@ impl GccType for CastTarget {\n         let mut args: Vec<_> = self\n             .prefix\n             .iter()\n-            .flat_map(|option_kind| {\n-                option_kind.map(|kind| Reg { kind, size: self.prefix_chunk_size }.gcc_type(cx))\n+            .flat_map(|option_reg| {\n+                option_reg.map(|reg| reg.gcc_type(cx))\n             })\n             .chain((0..rest_count).map(|_| rest_gcc_unit))\n             .collect();"}, {"sha": "4fab743b3ec5f3400d6ce9c1afa2db6f7dfe1a6e", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2", "patch": "@@ -181,9 +181,7 @@ impl LlvmType for CastTarget {\n         let mut args: Vec<_> = self\n             .prefix\n             .iter()\n-            .flat_map(|option_kind| {\n-                option_kind.map(|kind| Reg { kind, size: self.prefix_chunk_size }.llvm_type(cx))\n-            })\n+            .flat_map(|option_reg| option_reg.map(|reg| reg.llvm_type(cx)))\n             .chain((0..rest_count).map(|_| rest_ll_unit))\n             .collect();\n \n@@ -466,6 +464,9 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     );\n                 }\n             }\n+            PassMode::Cast(cast) => {\n+                cast.attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, cx, llfn);\n+            }\n             _ => {}\n         }\n         for arg in &self.args {\n@@ -497,8 +498,8 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     apply(a);\n                     apply(b);\n                 }\n-                PassMode::Cast(_) => {\n-                    apply(&ArgAttributes::new());\n+                PassMode::Cast(cast) => {\n+                    apply(&cast.attrs);\n                 }\n             }\n         }\n@@ -533,6 +534,13 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     );\n                 }\n             }\n+            PassMode::Cast(cast) => {\n+                cast.attrs.apply_attrs_to_callsite(\n+                    llvm::AttributePlace::ReturnValue,\n+                    &bx.cx,\n+                    callsite,\n+                );\n+            }\n             _ => {}\n         }\n         if let abi::Abi::Scalar(scalar) = self.ret.layout.abi {\n@@ -577,8 +585,8 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     apply(bx.cx, a);\n                     apply(bx.cx, b);\n                 }\n-                PassMode::Cast(_) => {\n-                    apply(bx.cx, &ArgAttributes::new());\n+                PassMode::Cast(cast) => {\n+                    apply(bx.cx, &cast.attrs);\n                 }\n             }\n         }"}, {"sha": "1ac454be5e9ad558657f3f51dd75ff4e62865980", "filename": "compiler/rustc_target/src/abi/call/mips64.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs?ref=128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2", "patch": "@@ -1,4 +1,6 @@\n-use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n+use crate::abi::call::{\n+    ArgAbi, ArgAttribute, ArgAttributes, ArgExtension, CastTarget, FnAbi, PassMode, Reg, Uniform,\n+};\n use crate::abi::{self, HasDataLayout, Size, TyAbiInterface};\n \n fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n@@ -115,15 +117,15 @@ where\n                             for _ in 0..((offset - last_offset).bits() / 64)\n                                 .min((prefix.len() - prefix_index) as u64)\n                             {\n-                                prefix[prefix_index] = Some(RegKind::Integer);\n+                                prefix[prefix_index] = Some(Reg::i64());\n                                 prefix_index += 1;\n                             }\n \n                             if prefix_index == prefix.len() {\n                                 break;\n                             }\n \n-                            prefix[prefix_index] = Some(RegKind::Float);\n+                            prefix[prefix_index] = Some(Reg::f64());\n                             prefix_index += 1;\n                             last_offset = offset + Reg::f64().size;\n                         }\n@@ -137,8 +139,13 @@ where\n     let rest_size = size - Size::from_bytes(8) * prefix_index as u64;\n     arg.cast_to(CastTarget {\n         prefix,\n-        prefix_chunk_size: Size::from_bytes(8),\n         rest: Uniform { unit: Reg::i64(), total: rest_size },\n+        attrs: ArgAttributes {\n+            regular: ArgAttribute::default(),\n+            arg_ext: ArgExtension::None,\n+            pointee_size: Size::ZERO,\n+            pointee_align: None,\n+        },\n     });\n }\n "}, {"sha": "735b7e76e3862a5ceaf792d0226c9f4fa7e71625", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2", "patch": "@@ -214,9 +214,9 @@ impl Uniform {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct CastTarget {\n-    pub prefix: [Option<RegKind>; 8],\n-    pub prefix_chunk_size: Size,\n+    pub prefix: [Option<Reg>; 8],\n     pub rest: Uniform,\n+    pub attrs: ArgAttributes,\n }\n \n impl From<Reg> for CastTarget {\n@@ -227,29 +227,48 @@ impl From<Reg> for CastTarget {\n \n impl From<Uniform> for CastTarget {\n     fn from(uniform: Uniform) -> CastTarget {\n-        CastTarget { prefix: [None; 8], prefix_chunk_size: Size::ZERO, rest: uniform }\n+        CastTarget {\n+            prefix: [None; 8],\n+            rest: uniform,\n+            attrs: ArgAttributes {\n+                regular: ArgAttribute::default(),\n+                arg_ext: ArgExtension::None,\n+                pointee_size: Size::ZERO,\n+                pointee_align: None,\n+            },\n+        }\n     }\n }\n \n impl CastTarget {\n     pub fn pair(a: Reg, b: Reg) -> CastTarget {\n         CastTarget {\n-            prefix: [Some(a.kind), None, None, None, None, None, None, None],\n-            prefix_chunk_size: a.size,\n+            prefix: [Some(a), None, None, None, None, None, None, None],\n             rest: Uniform::from(b),\n+            attrs: ArgAttributes {\n+                regular: ArgAttribute::default(),\n+                arg_ext: ArgExtension::None,\n+                pointee_size: Size::ZERO,\n+                pointee_align: None,\n+            },\n         }\n     }\n \n-    pub fn size<C: HasDataLayout>(&self, cx: &C) -> Size {\n-        (self.prefix_chunk_size * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n-            .align_to(self.rest.align(cx))\n-            + self.rest.total\n+    pub fn size<C: HasDataLayout>(&self, _cx: &C) -> Size {\n+        let mut size = self.rest.total;\n+        for i in 0..self.prefix.iter().count() {\n+            match self.prefix[i] {\n+                Some(v) => size += Size { raw: v.size.bytes() },\n+                None => {}\n+            }\n+        }\n+        return size;\n     }\n \n     pub fn align<C: HasDataLayout>(&self, cx: &C) -> Align {\n         self.prefix\n             .iter()\n-            .filter_map(|x| x.map(|kind| Reg { kind, size: self.prefix_chunk_size }.align(cx)))\n+            .filter_map(|x| x.map(|reg| reg.align(cx)))\n             .fold(cx.data_layout().aggregate_align.abi.max(self.rest.align(cx)), |acc, align| {\n                 acc.max(align)\n             })"}, {"sha": "39d80c4c7e76d1ceed26b24194c8af4895c65a49", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 93, "deletions": 33, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2", "patch": "@@ -1,7 +1,9 @@\n // FIXME: This needs an audit for correctness and completeness.\n \n-use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, TyAbiInterface};\n+use crate::abi::call::{\n+    ArgAbi, ArgAttribute, ArgAttributes, ArgExtension, CastTarget, FnAbi, Reg, RegKind, Uniform,\n+};\n+use crate::abi::{self, HasDataLayout, Size, TyAbiInterface};\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n@@ -16,41 +18,15 @@ where\n \n         let valid_unit = match unit.kind {\n             RegKind::Integer => false,\n-            RegKind::Float => true,\n+            RegKind::Float => false,\n             RegKind::Vector => arg.layout.size.bits() == 128,\n         };\n \n         valid_unit.then_some(Uniform { unit, total: arg.layout.size })\n     })\n }\n \n-fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n-where\n-    Ty: TyAbiInterface<'a, C> + Copy,\n-    C: HasDataLayout,\n-{\n-    if !ret.layout.is_aggregate() {\n-        ret.extend_integer_width_to(64);\n-        return;\n-    }\n-\n-    if let Some(uniform) = is_homogeneous_aggregate(cx, ret) {\n-        ret.cast_to(uniform);\n-        return;\n-    }\n-    let size = ret.layout.size;\n-    let bits = size.bits();\n-    if bits <= 256 {\n-        let unit = Reg::i64();\n-        ret.cast_to(Uniform { unit, total: size });\n-        return;\n-    }\n-\n-    // don't return aggregates in registers\n-    ret.make_indirect();\n-}\n-\n-fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, in_registers_max: Size)\n where\n     Ty: TyAbiInterface<'a, C> + Copy,\n     C: HasDataLayout,\n@@ -60,13 +36,97 @@ where\n         return;\n     }\n \n+    // This doesn't intentionally handle structures with floats which needs\n+    // special care below.\n     if let Some(uniform) = is_homogeneous_aggregate(cx, arg) {\n         arg.cast_to(uniform);\n         return;\n     }\n \n+    if let abi::FieldsShape::Arbitrary { .. } = arg.layout.fields {\n+        let dl = cx.data_layout();\n+        let size = arg.layout.size;\n+        let mut prefix = [None; 8];\n+        let mut prefix_index = 0;\n+        let mut last_offset = Size::ZERO;\n+        let mut has_float = false;\n+        let mut arg_attribute = ArgAttribute::default();\n+\n+        for i in 0..arg.layout.fields.count() {\n+            let field = arg.layout.field(cx, i);\n+            let offset = arg.layout.fields.offset(i);\n+\n+            if let abi::Abi::Scalar(scalar) = &field.abi {\n+                if scalar.value == abi::F32 || scalar.value == abi::F64 {\n+                    has_float = true;\n+\n+                    if !last_offset.is_aligned(dl.f64_align.abi) && last_offset < offset {\n+                        if prefix_index == prefix.len() {\n+                            break;\n+                        }\n+                        prefix[prefix_index] = Some(Reg::i32());\n+                        prefix_index += 1;\n+                        last_offset = last_offset + Reg::i32().size;\n+                    }\n+\n+                    for _ in 0..((offset - last_offset).bits() / 64)\n+                        .min((prefix.len() - prefix_index) as u64)\n+                    {\n+                        prefix[prefix_index] = Some(Reg::i64());\n+                        prefix_index += 1;\n+                        last_offset = last_offset + Reg::i64().size;\n+                    }\n+\n+                    if last_offset < offset {\n+                        if prefix_index == prefix.len() {\n+                            break;\n+                        }\n+                        prefix[prefix_index] = Some(Reg::i32());\n+                        prefix_index += 1;\n+                        last_offset = last_offset + Reg::i32().size;\n+                    }\n+\n+                    if prefix_index == prefix.len() {\n+                        break;\n+                    }\n+\n+                    if scalar.value == abi::F32 {\n+                        arg_attribute = ArgAttribute::InReg;\n+                        prefix[prefix_index] = Some(Reg::f32());\n+                        last_offset = offset + Reg::f32().size;\n+                    } else {\n+                        prefix[prefix_index] = Some(Reg::f64());\n+                        last_offset = offset + Reg::f64().size;\n+                    }\n+                    prefix_index += 1;\n+                }\n+            }\n+        }\n+\n+        if has_float && arg.layout.size <= in_registers_max {\n+            let mut rest_size = size - last_offset;\n+\n+            if (rest_size.raw % 8) != 0 && prefix_index < prefix.len() {\n+                prefix[prefix_index] = Some(Reg::i32());\n+                rest_size = rest_size - Reg::i32().size;\n+            }\n+\n+            arg.cast_to(CastTarget {\n+                prefix,\n+                rest: Uniform { unit: Reg::i64(), total: rest_size },\n+                attrs: ArgAttributes {\n+                    regular: arg_attribute,\n+                    arg_ext: ArgExtension::None,\n+                    pointee_size: Size::ZERO,\n+                    pointee_align: None,\n+                },\n+            });\n+            return;\n+        }\n+    }\n+\n     let total = arg.layout.size;\n-    if total.bits() > 128 {\n+    if total > in_registers_max {\n         arg.make_indirect();\n         return;\n     }\n@@ -80,13 +140,13 @@ where\n     C: HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {\n-        classify_ret(cx, &mut fn_abi.ret);\n+        classify_arg(cx, &mut fn_abi.ret, Size { raw: 32 });\n     }\n \n     for arg in &mut fn_abi.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg(cx, arg);\n+        classify_arg(cx, arg, Size { raw: 16 });\n     }\n }"}, {"sha": "dd8e6f614df11812bd69f621f24e60fd62239ae8", "filename": "src/test/assembly/sparc-struct-abi.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/src%2Ftest%2Fassembly%2Fsparc-struct-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/src%2Ftest%2Fassembly%2Fsparc-struct-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fsparc-struct-abi.rs?ref=128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2", "patch": "@@ -0,0 +1,64 @@\n+// Test SPARC64 ABI\n+// - float structure members are passes in floating point registers\n+// (#86163)\n+\n+// assembly-output: emit-asm\n+// needs-llvm-components: sparc\n+// compile-flags: --target=sparcv9-sun-solaris -Copt-level=3\n+#![crate_type = \"lib\"]\n+#![feature(no_core, lang_items)]\n+#![no_core]\n+\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+\n+#[repr(C)]\n+pub struct Franta {\n+    a: f32,\n+    b: f32,\n+    c: f32,\n+    d: f32,\n+}\n+\n+// NB: due to delay slots the `ld` following the call is actually executed before the call.\n+#[no_mangle]\n+pub unsafe extern \"C\" fn callee(arg: Franta) {\n+    // CHECK-LABEL: callee:\n+    // CHECK: st %f3, [[PLACE_D:.*]]\n+    // CHECK: st %f2, [[PLACE_C:.*]]\n+    // CHECK: st %f1, [[PLACE_B:.*]]\n+    // CHECK: st %f0, [[PLACE_A:.*]]\n+    // CHECK: call tst_use\n+    // CHECK-NEXT: ld [[PLACE_A]], %f1\n+    // CHECK: call tst_use\n+    // CHECK-NEXT: ld [[PLACE_B]], %f1\n+    // CHECK: call tst_use\n+    // CHECK-NEXT: ld [[PLACE_C]], %f1\n+    // CHECK: call tst_use\n+    // CHECK-NEXT: ld [[PLACE_D]], %f1\n+    clobber();\n+    tst_use(arg.a);\n+    tst_use(arg.b);\n+    tst_use(arg.c);\n+    tst_use(arg.d);\n+}\n+\n+extern \"C\" {\n+    fn opaque_callee(arg: Franta, intarg: i32);\n+    fn tst_use(arg: f32);\n+    fn clobber();\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn caller() {\n+    // CHECK-LABEL: caller:\n+    // CHECK: ld [{{.*}}], %f0\n+    // CHECK: ld [{{.*}}], %f1\n+    // CHECK: ld [{{.*}}], %f2\n+    // CHECK: ld [{{.*}}], %f3\n+    // CHECK: call opaque_callee\n+    // CHECK: mov     3, %o2\n+    opaque_callee(Franta { a: 1.0, b: 2.0, c: 3.0, d: 4.0 }, 3);\n+}"}, {"sha": "b531dba46079d659154543ecfd709df5d0c47341", "filename": "src/test/codegen/sparc-struct-abi.rs", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/src%2Ftest%2Fcodegen%2Fsparc-struct-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2/src%2Ftest%2Fcodegen%2Fsparc-struct-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsparc-struct-abi.rs?ref=128ceec92d04a9b4feaf55804f5e7d1f3f1dbfd2", "patch": "@@ -1,5 +1,5 @@\n // Checks that we correctly codegen extern \"C\" functions returning structs.\n-// See issue #52638.\n+// See issues #52638 and #86163.\n \n // compile-flags: -O --target=sparc64-unknown-linux-gnu --crate-type=rlib\n // needs-llvm-components: sparc\n@@ -25,3 +25,59 @@ pub struct Bool {\n pub extern \"C\" fn structbool() -> Bool {\n     Bool { b: true }\n }\n+\n+\n+#[repr(C)]\n+pub struct BoolFloat {\n+    b: bool,\n+    f: f32,\n+}\n+\n+// CHECK: define inreg { i32, float } @structboolfloat()\n+// CHECK-NEXT: start:\n+// CHECK-NEXT: ret { i32, float } { i32 16777216, float 0x40091EB860000000 }\n+#[no_mangle]\n+pub extern \"C\" fn structboolfloat() -> BoolFloat {\n+    BoolFloat { b: true, f: 3.14 }\n+}\n+\n+// CHECK: define void @structboolfloat_input({ i32, float } inreg %0)\n+// CHECK-NEXT: start:\n+#[no_mangle]\n+pub extern \"C\" fn structboolfloat_input(a: BoolFloat) { }\n+\n+\n+#[repr(C)]\n+pub struct ShortDouble {\n+    s: i16,\n+    d: f64,\n+}\n+\n+// CHECK: define { i64, double } @structshortdouble()\n+// CHECK-NEXT: start:\n+// CHECK-NEXT: ret { i64, double } { i64 34621422135410688, double 3.140000e+00 }\n+#[no_mangle]\n+pub extern \"C\" fn structshortdouble() -> ShortDouble {\n+    ShortDouble { s: 123, d: 3.14 }\n+}\n+\n+// CHECK: define void @structshortdouble_input({ i64, double } %0)\n+// CHECK-NEXT: start:\n+#[no_mangle]\n+pub extern \"C\" fn structshortdouble_input(a: ShortDouble) { }\n+\n+\n+#[repr(C)]\n+pub struct FloatLongFloat {\n+    f: f32,\n+    i: i64,\n+    g: f32,\n+}\n+\n+// CHECK: define inreg { float, i32, i64, float, i32 } @structfloatlongfloat()\n+// CHECK-NEXT: start:\n+// CHECK-NEXT: ret { float, i32, i64, float, i32 } { float 0x3FB99999A0000000, i32 undef, i64 123, float 0x40091EB860000000, i32 undef }\n+#[no_mangle]\n+pub extern \"C\" fn structfloatlongfloat() -> FloatLongFloat {\n+    FloatLongFloat { f: 0.1, i: 123, g: 3.14 }\n+}"}]}