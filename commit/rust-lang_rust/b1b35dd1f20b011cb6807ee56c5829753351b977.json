{"sha": "b1b35dd1f20b011cb6807ee56c5829753351b977", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYjM1ZGQxZjIwYjAxMWNiNjgwN2VlNTZjNTgyOTc1MzM1MWI5Nzc=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-10-30T03:15:32Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-10-30T03:15:32Z"}, "message": "Implement env, reentrant mutex, and partially implement scoped thread locals. Better error messages for unsupported features", "tree": {"sha": "ed9e90dd374d63b4c1208b7523f35613e08cff67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed9e90dd374d63b4c1208b7523f35613e08cff67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1b35dd1f20b011cb6807ee56c5829753351b977", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1b35dd1f20b011cb6807ee56c5829753351b977", "html_url": "https://github.com/rust-lang/rust/commit/b1b35dd1f20b011cb6807ee56c5829753351b977", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1b35dd1f20b011cb6807ee56c5829753351b977/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68fd7eebe255bd8bd2231db353a266c1bc1e911f", "url": "https://api.github.com/repos/rust-lang/rust/commits/68fd7eebe255bd8bd2231db353a266c1bc1e911f", "html_url": "https://github.com/rust-lang/rust/commit/68fd7eebe255bd8bd2231db353a266c1bc1e911f"}], "stats": {"total": 223, "additions": 174, "deletions": 49}, "files": [{"sha": "b5234be567dd52b55f17f98b471e8f555e3cf806", "filename": "src/libstd/sys/redox/condvar.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs?ref=b1b35dd1f20b011cb6807ee56c5829753351b977", "patch": "@@ -20,11 +20,15 @@ impl Condvar {\n         }\n     }\n \n+    #[inline]\n     pub unsafe fn init(&self) {\n-\n+        *self.lock.get() = ptr::null_mut();\n+        *self.seq.get() = 0;\n     }\n \n+    #[inline]\n     pub fn notify_one(&self) {\n+        ::sys_common::util::dumb_print(format_args!(\"condvar notify_one\\n\"));\n         unsafe {\n             let seq = self.seq.get();\n \n@@ -34,7 +38,9 @@ impl Condvar {\n         }\n     }\n \n+    #[inline]\n     pub fn notify_all(&self) {\n+        ::sys_common::util::dumb_print(format_args!(\"condvar notify_all\\n\"));\n         unsafe {\n             let lock = self.lock.get();\n             let seq = self.seq.get();\n@@ -49,7 +55,9 @@ impl Condvar {\n         }\n     }\n \n+    #[inline]\n     pub fn wait(&self, mutex: &Mutex) {\n+        ::sys_common::util::dumb_print(format_args!(\"condvar wait\\n\"));\n         unsafe {\n             let lock = self.lock.get();\n             let seq = self.seq.get();\n@@ -74,12 +82,16 @@ impl Condvar {\n         }\n     }\n \n+    #[inline]\n     pub fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n+        ::sys_common::util::dumb_print(format_args!(\"condvar wait_timeout\\n\"));\n         unimplemented!();\n     }\n \n+    #[inline]\n     pub unsafe fn destroy(&self) {\n-\n+        *self.lock.get() = ptr::null_mut();\n+        *self.seq.get() = 0;\n     }\n }\n "}, {"sha": "4a3c0fdb37e966ccb8b507eb6d1733c3b777557d", "filename": "src/libstd/sys/redox/fd.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs?ref=b1b35dd1f20b011cb6807ee56c5829753351b977", "patch": "@@ -49,6 +49,7 @@ impl FileDesc {\n     }\n \n     pub fn set_cloexec(&self) -> io::Result<()> {\n+        ::sys_common::util::dumb_print(format_args!(\"Set cloexec\\n\"));\n         unimplemented!();\n         /*\n         unsafe {\n@@ -60,6 +61,7 @@ impl FileDesc {\n     }\n \n     pub fn set_nonblocking(&self, _nonblocking: bool) -> io::Result<()> {\n+        ::sys_common::util::dumb_print(format_args!(\"Set nonblocking\\n\"));\n         unimplemented!();\n         /*\n         unsafe {"}, {"sha": "3779c4c66775eaaef89899aa71b9703d1ed4f0e4", "filename": "src/libstd/sys/redox/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs?ref=b1b35dd1f20b011cb6807ee56c5829753351b977", "patch": "@@ -380,10 +380,12 @@ pub fn unlink(p: &Path) -> io::Result<()> {\n }\n \n pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n+    ::sys_common::util::dumb_print(format_args!(\"Rename\\n\"));\n     unimplemented!();\n }\n \n pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {\n+    ::sys_common::util::dumb_print(format_args!(\"Set perm\\n\"));\n     unimplemented!();\n }\n \n@@ -418,10 +420,12 @@ pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n }\n \n pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    ::sys_common::util::dumb_print(format_args!(\"Symlink\\n\"));\n     unimplemented!();\n }\n \n pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    ::sys_common::util::dumb_print(format_args!(\"Link\\n\"));\n     unimplemented!();\n }\n "}, {"sha": "aa808c2f8d45b60fdab13f8481f0fb8c9878de49", "filename": "src/libstd/sys/redox/mutex.rs", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs?ref=b1b35dd1f20b011cb6807ee56c5829753351b977", "patch": "@@ -2,7 +2,7 @@ use cell::UnsafeCell;\n use intrinsics::{atomic_cxchg, atomic_xchg};\n use ptr;\n \n-use libc::{futex, FUTEX_WAIT, FUTEX_WAKE};\n+use libc::{futex, getpid, FUTEX_WAIT, FUTEX_WAKE};\n \n pub unsafe fn mutex_try_lock(m: *mut i32) -> bool {\n     atomic_cxchg(m, 0, 1).0 == 0\n@@ -57,27 +57,36 @@ impl Mutex {\n         }\n     }\n \n+    #[inline]\n     pub unsafe fn init(&self) {\n-\n+        *self.lock.get() = 0;\n     }\n \n     /// Try to lock the mutex\n+    #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n+        ::sys_common::util::dumb_print(format_args!(\"mutex try lock\\n\"));\n         mutex_try_lock(self.lock.get())\n     }\n \n     /// Lock the mutex\n+    #[inline]\n     pub unsafe fn lock(&self) {\n-        mutex_lock(self.lock.get());\n+        ::sys_common::util::dumb_print(format_args!(\"mutex lock\\n\"));\n+        mutex_try_lock(self.lock.get());\n+        //mutex_lock(self.lock.get());\n     }\n \n     /// Unlock the mutex\n+    #[inline]\n     pub unsafe fn unlock(&self) {\n+        ::sys_common::util::dumb_print(format_args!(\"mutex unlock\\n\"));\n         mutex_unlock(self.lock.get());\n     }\n \n+    #[inline]\n     pub unsafe fn destroy(&self) {\n-\n+        *self.lock.get() = 0;\n     }\n }\n \n@@ -87,36 +96,78 @@ unsafe impl Sync for Mutex {}\n \n pub struct ReentrantMutex {\n     pub lock: UnsafeCell<i32>,\n+    pub owner: UnsafeCell<usize>,\n+    pub own_count: UnsafeCell<usize>,\n }\n \n impl ReentrantMutex {\n     pub const fn uninitialized() -> Self {\n         ReentrantMutex {\n             lock: UnsafeCell::new(0),\n+            owner: UnsafeCell::new(0),\n+            own_count: UnsafeCell::new(0),\n         }\n     }\n \n+    #[inline]\n     pub unsafe fn init(&mut self) {\n-\n+        *self.lock.get() = 0;\n+        *self.owner.get() = 0;\n+        *self.own_count.get() = 0;\n     }\n \n     /// Try to lock the mutex\n+    #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        mutex_try_lock(self.lock.get())\n+        ::sys_common::util::dumb_print(format_args!(\"remutex try_lock\\n\"));\n+        let pid = getpid().unwrap();\n+        if *self.own_count.get() > 0 && *self.owner.get() == pid {\n+            *self.own_count.get() += 1;\n+            true\n+        } else {\n+            if mutex_try_lock(self.lock.get()) {\n+                *self.owner.get() = pid;\n+                *self.own_count.get() = 1;\n+                true\n+            } else {\n+                false\n+            }\n+        }\n     }\n \n     /// Lock the mutex\n+    #[inline]\n     pub unsafe fn lock(&self) {\n-        mutex_lock(self.lock.get());\n+        ::sys_common::util::dumb_print(format_args!(\"remutex lock\\n\"));\n+        let pid = getpid().unwrap();\n+        if *self.own_count.get() > 0 && *self.owner.get() == pid {\n+            *self.own_count.get() += 1;\n+        } else {\n+            mutex_lock(self.lock.get());\n+            *self.owner.get() = pid;\n+            *self.own_count.get() = 1;\n+        }\n     }\n \n     /// Unlock the mutex\n+    #[inline]\n     pub unsafe fn unlock(&self) {\n-        mutex_unlock(self.lock.get());\n+        ::sys_common::util::dumb_print(format_args!(\"remutex unlock\\n\"));\n+        let pid = getpid().unwrap();\n+        if *self.own_count.get() > 0 && *self.owner.get() == pid {\n+            *self.own_count.get() -= 1;\n+            if *self.own_count.get() == 0 {\n+                *self.owner.get() = 0;\n+                mutex_unlock(self.lock.get());\n+            }\n+        }\n     }\n \n+    #[inline]\n     pub unsafe fn destroy(&self) {\n-\n+        *self.lock.get() = 0;\n+        *self.owner.get() = 0;\n+        *self.own_count.get() = 0;\n     }\n }\n "}, {"sha": "9524f2c28f9da9a8b89d3ffccf7bbe76fbbf5e9c", "filename": "src/libstd/sys/redox/os.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos.rs?ref=b1b35dd1f20b011cb6807ee56c5829753351b977", "patch": "@@ -17,7 +17,7 @@ use os::unix::prelude::*;\n use error::Error as StdError;\n use ffi::{CString, CStr, OsString, OsStr};\n use fmt;\n-use io;\n+use io::{self, Read, Write};\n use iter;\n use libc::{self, c_int, c_char, c_void};\n use marker::PhantomData;\n@@ -131,19 +131,48 @@ impl Iterator for Env {\n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n pub fn env() -> Env {\n-    unimplemented!();\n+    let mut variables: Vec<(OsString, OsString)> = Vec::new();\n+    if let Ok(mut file) = ::fs::File::open(\"env:\") {\n+        let mut string = String::new();\n+        if file.read_to_string(&mut string).is_ok() {\n+            for line in string.lines() {\n+                if let Some(equal_sign) = line.chars().position(|c| c == '=') {\n+                    let name = line.chars().take(equal_sign).collect::<String>();\n+                    let value = line.chars().skip(equal_sign+1).collect::<String>();\n+                    variables.push((OsString::from(name), OsString::from(value)));\n+                }\n+            }\n+        }\n+    }\n+    Env { iter: variables.into_iter(), _dont_send_or_sync_me: PhantomData }\n }\n \n-pub fn getenv(_k: &OsStr) -> io::Result<Option<OsString>> {\n-    unimplemented!();\n+pub fn getenv(key: &OsStr) -> io::Result<Option<OsString>> {\n+    if ! key.is_empty() {\n+        if let Ok(mut file) = ::fs::File::open(&(\"env:\".to_owned() + key.to_str().unwrap())) {\n+            let mut string = String::new();\n+            file.read_to_string(&mut string)?;\n+            Ok(Some(OsString::from(string)))\n+        } else {\n+            Ok(None)\n+        }\n+    } else {\n+        Ok(None)\n+    }\n }\n \n-pub fn setenv(_k: &OsStr, _v: &OsStr) -> io::Result<()> {\n-    unimplemented!();\n+pub fn setenv(key: &OsStr, value: &OsStr) -> io::Result<()> {\n+    if ! key.is_empty() {\n+        let mut file = ::fs::File::open(&(\"env:\".to_owned() + key.to_str().unwrap()))?;\n+        file.write_all(value.as_bytes())?;\n+        file.set_len(value.len() as u64)?;\n+    }\n+    Ok(())\n }\n \n-pub fn unsetenv(_n: &OsStr) -> io::Result<()> {\n-    unimplemented!();\n+pub fn unsetenv(key: &OsStr) -> io::Result<()> {\n+    ::fs::remove_file(&(\"env:\".to_owned() + key.to_str().unwrap()))?;\n+    Ok(())\n }\n \n pub fn page_size() -> usize {"}, {"sha": "a25ca048942727ad212b2b5fe8eb59b124a862aa", "filename": "src/libstd/sys/redox/pipe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs?ref=b1b35dd1f20b011cb6807ee56c5829753351b977", "patch": "@@ -54,6 +54,7 @@ pub fn read2(_p1: AnonPipe,\n              _v1: &mut Vec<u8>,\n              _p2: AnonPipe,\n              _v2: &mut Vec<u8>) -> io::Result<()> {\n+    ::sys_common::util::dumb_print(format_args!(\"read2\\n\"));\n     unimplemented!();\n     /*\n     // Set both pipes into nonblocking mode as we're gonna be reading from both"}, {"sha": "c752fa50ea9ddef6884beb8b7c598f9d6ef5e40c", "filename": "src/libstd/sys/redox/rwlock.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Frwlock.rs?ref=b1b35dd1f20b011cb6807ee56c5829753351b977", "patch": "@@ -8,48 +8,54 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct RWLock;\n+use super::mutex::Mutex;\n+\n+pub struct RWLock {\n+    mutex: Mutex\n+}\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n impl RWLock {\n     pub const fn new() -> RWLock {\n-        RWLock\n+        RWLock {\n+            mutex: Mutex::new()\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn read(&self) {\n-        unimplemented!();\n+        self.mutex.lock();\n     }\n \n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        unimplemented!();\n+        self.mutex.try_lock()\n     }\n \n     #[inline]\n     pub unsafe fn write(&self) {\n-        unimplemented!();\n+        self.mutex.lock();\n     }\n \n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        unimplemented!();\n+        self.mutex.try_lock()\n     }\n \n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        unimplemented!();\n+        self.mutex.unlock();\n     }\n \n     #[inline]\n     pub unsafe fn write_unlock(&self) {\n-        unimplemented!();\n+        self.mutex.unlock();\n     }\n \n     #[inline]\n     pub unsafe fn destroy(&self) {\n-\n+        self.mutex.destroy();\n     }\n }"}, {"sha": "92846bfe0c8d115a4bd43c0a5a3fff12cb8fb9a6", "filename": "src/libstd/sys/redox/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstack_overflow.rs?ref=b1b35dd1f20b011cb6807ee56c5829753351b977", "patch": "@@ -14,7 +14,7 @@ pub struct Handler;\n \n impl Handler {\n     pub unsafe fn new() -> Handler {\n-        unimplemented!();\n+        Handler\n     }\n }\n \n@@ -23,5 +23,5 @@ pub unsafe fn init() {\n }\n \n pub unsafe fn cleanup() {\n-    unimplemented!();\n+    \n }"}, {"sha": "b6685f14ec724e40952a7e35ba0ff3163e09abeb", "filename": "src/libstd/sys/redox/thread.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs?ref=b1b35dd1f20b011cb6807ee56c5829753351b977", "patch": "@@ -32,6 +32,8 @@ impl Thread {\n \n         start_thread(&*p as *const _ as *mut _);\n \n+        ::sys_common::util::dumb_print(format_args!(\"thread\\n\"));\n+\n         unimplemented!();\n     }\n \n@@ -41,7 +43,7 @@ impl Thread {\n     }\n \n     pub fn set_name(_name: &CStr) {\n-        unimplemented!();\n+\n     }\n \n     pub fn sleep(dur: Duration) {\n@@ -67,7 +69,8 @@ impl Thread {\n     }\n \n     pub fn join(self) {\n-        panic!();\n+        ::sys_common::util::dumb_print(format_args!(\"Thread::join\"));\n+        unimplemented!();\n     }\n \n     pub fn id(&self) -> libc::pid_t { self.id }\n@@ -81,7 +84,8 @@ impl Thread {\n \n impl Drop for Thread {\n     fn drop(&mut self) {\n-        panic!();\n+        ::sys_common::util::dumb_print(format_args!(\"Thread::drop\"));\n+        unimplemented!();\n     }\n }\n "}, {"sha": "b12ffebbcac1d6a7c370f5be1ce2247b5698bf00", "filename": "src/libstd/sys/redox/thread_local.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1b35dd1f20b011cb6807ee56c5829753351b977/src%2Flibstd%2Fsys%2Fredox%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread_local.rs?ref=b1b35dd1f20b011cb6807ee56c5829753351b977", "patch": "@@ -10,32 +10,48 @@\n \n #![allow(dead_code)] // not used on all platforms\n \n+use collections::BTreeMap;\n+use ptr;\n+\n pub type Key = usize;\n \n+type Dtor = unsafe extern fn(*mut u8);\n+\n+//TODO: Implement this properly\n+\n+static mut NEXT_KEY: Key = 0;\n+\n+static mut LOCALS: *mut BTreeMap<Key, (*mut u8, Option<Dtor>)> = ptr::null_mut();\n+\n+unsafe fn locals() -> &'static mut BTreeMap<Key, (*mut u8, Option<Dtor>)> {\n+    if LOCALS == ptr::null_mut() {\n+        LOCALS = Box::into_raw(Box::new(BTreeMap::new()));\n+    }\n+    &mut *LOCALS\n+}\n+\n #[inline]\n-pub unsafe fn create(_dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-    panic!(\"pthread key create not supported\");\n-    //let mut key = 0;\n-    //assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n-    //key\n+pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n+    let key = NEXT_KEY;\n+    NEXT_KEY += 1;\n+    locals().insert(key, (0 as *mut u8, dtor));\n+    key\n }\n \n #[inline]\n-pub unsafe fn set(_key: Key, _value: *mut u8) {\n-    panic!(\"pthread key set not supported\");\n-    //let r = libc::pthread_setspecific(key, value as *mut _);\n-    //debug_assert_eq!(r, 0);\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    locals().get_mut(&key).unwrap().0 = value;\n }\n \n #[inline]\n-pub unsafe fn get(_key: Key) -> *mut u8 {\n-    panic!(\"pthread key get not supported\");\n-    //libc::pthread_getspecific(key) as *mut u8\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    locals()[&key].0\n }\n \n #[inline]\n-pub unsafe fn destroy(_key: Key) {\n-    panic!(\"pthread key destroy not supported\");\n-    //let r = libc::pthread_key_delete(key);\n-    //debug_assert_eq!(r, 0);\n+pub unsafe fn destroy(key: Key) {\n+    let (value, dtor) = locals().remove(&key).unwrap();\n+    if let Some(dtor_fn) = dtor {\n+        dtor_fn(value);\n+    }\n }"}]}