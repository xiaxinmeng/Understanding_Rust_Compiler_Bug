{"sha": "a49ce7f11a7c1ec0d77b058caca4694540576cf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0OWNlN2YxMWE3YzFlYzBkNzdiMDU4Y2FjYTQ2OTQ1NDA1NzZjZjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-27T22:10:45Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-31T22:47:35Z"}, "message": "sync: Switch field privacy as necessary", "tree": {"sha": "3ee6fc4c34dd59de9504450ffef061030d4d0bd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ee6fc4c34dd59de9504450ffef061030d4d0bd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a49ce7f11a7c1ec0d77b058caca4694540576cf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a49ce7f11a7c1ec0d77b058caca4694540576cf5", "html_url": "https://github.com/rust-lang/rust/commit/a49ce7f11a7c1ec0d77b058caca4694540576cf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a49ce7f11a7c1ec0d77b058caca4694540576cf5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02cf3751dff06700504f7980e13155884e64289e", "url": "https://api.github.com/repos/rust-lang/rust/commits/02cf3751dff06700504f7980e13155884e64289e", "html_url": "https://github.com/rust-lang/rust/commit/02cf3751dff06700504f7980e13155884e64289e"}], "stats": {"total": 118, "additions": 61, "deletions": 57}, "files": [{"sha": "ae76357a2be830f3a81983312fba185185dc1eea", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=a49ce7f11a7c1ec0d77b058caca4694540576cf5", "patch": "@@ -46,7 +46,7 @@ use std::sync::atomics;\n /// ```\n #[unsafe_no_drop_flag]\n pub struct Arc<T> {\n-    priv x: *mut ArcInner<T>,\n+    x: *mut ArcInner<T>,\n }\n \n /// A weak pointer to an `Arc`.\n@@ -55,7 +55,7 @@ pub struct Arc<T> {\n /// used to break cycles between `Arc` pointers.\n #[unsafe_no_drop_flag]\n pub struct Weak<T> {\n-    priv x: *mut ArcInner<T>,\n+    x: *mut ArcInner<T>,\n }\n \n struct ArcInner<T> {"}, {"sha": "9e01b16ee9ba9b544fba49340c69f61d096478be", "filename": "src/libsync/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm.rs?ref=a49ce7f11a7c1ec0d77b058caca4694540576cf5", "patch": "@@ -20,8 +20,8 @@ use std::comm;\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n pub struct DuplexStream<S, R> {\n-    priv tx: Sender<S>,\n-    priv rx: Receiver<R>,\n+    tx: Sender<S>,\n+    rx: Receiver<R>,\n }\n \n /// Creates a bidirectional stream."}, {"sha": "cfe942afc129b1231ce43b294cf930f91490e63d", "filename": "src/libsync/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ffuture.rs?ref=a49ce7f11a7c1ec0d77b058caca4694540576cf5", "patch": "@@ -30,7 +30,7 @@ use std::mem::replace;\n \n /// A type encapsulating the result of a computation which may not be complete\n pub struct Future<A> {\n-    priv state: FutureState<A>,\n+    state: FutureState<A>,\n }\n \n enum FutureState<A> {"}, {"sha": "4ecf8d32470a7597d703def58f8f2438158bf44b", "filename": "src/libsync/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flib.rs?ref=a49ce7f11a7c1ec0d77b058caca4694540576cf5", "patch": "@@ -20,7 +20,11 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://static.rust-lang.org/doc/master\")]\n #![feature(phase)]\n-#![deny(missing_doc, deprecated_owned_vector)]\n+#![deny(deprecated_owned_vector)]\n+\n+// #![deny(missing_doc)] // NOTE: uncomment after a stage0 snap\n+#![allow(missing_doc)] // NOTE: remove after a stage0 snap\n+#![allow(visible_private_types)] // NOTE: remove after a stage0 snap\n \n #[cfg(test)]\n #[phase(syntax, link)] extern crate log;"}, {"sha": "67b725f040b4d3eb1da9d07961764a3bacf5ddf1", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=a49ce7f11a7c1ec0d77b058caca4694540576cf5", "patch": "@@ -79,12 +79,12 @@ impl<'b> Inner<'b> {\n /// A condition variable, a mechanism for unlock-and-descheduling and\n /// signaling, for use with the lock types.\n pub struct Condvar<'a> {\n-    priv name: &'static str,\n+    name: &'static str,\n     // n.b. Inner must be after PoisonOnFail because we must set the poison flag\n     //      *inside* the mutex, and struct fields are destroyed top-to-bottom\n     //      (destroy the lock guard last).\n-    priv poison: PoisonOnFail<'a>,\n-    priv inner: Inner<'a>,\n+    poison: PoisonOnFail<'a>,\n+    inner: Inner<'a>,\n }\n \n impl<'a> Condvar<'a> {\n@@ -166,18 +166,18 @@ impl<'a> Condvar<'a> {\n /// }\n /// ```\n pub struct Mutex<T> {\n-    priv lock: raw::Mutex,\n-    priv failed: Unsafe<bool>,\n-    priv data: Unsafe<T>,\n+    lock: raw::Mutex,\n+    failed: Unsafe<bool>,\n+    data: Unsafe<T>,\n }\n \n /// An guard which is created by locking a mutex. Through this guard the\n /// underlying data can be accessed.\n pub struct MutexGuard<'a, T> {\n-    priv data: &'a mut T,\n+    data: &'a mut T,\n     /// Inner condition variable connected to the locked mutex that this guard\n     /// was created from. This can be used for atomic-unlock-and-deschedule.\n-    cond: Condvar<'a>,\n+    pub cond: Condvar<'a>,\n }\n \n impl<T: Send> Mutex<T> {\n@@ -265,25 +265,25 @@ impl<'a, T> DerefMut<T> for MutexGuard<'a, T> {\n /// println!(\"{}\", *val);\n /// ```\n pub struct RWLock<T> {\n-    priv lock: raw::RWLock,\n-    priv failed: Unsafe<bool>,\n-    priv data: Unsafe<T>,\n+    lock: raw::RWLock,\n+    failed: Unsafe<bool>,\n+    data: Unsafe<T>,\n }\n \n /// A guard which is created by locking an rwlock in write mode. Through this\n /// guard the underlying data can be accessed.\n pub struct RWLockWriteGuard<'a, T> {\n-    priv data: &'a mut T,\n+    data: &'a mut T,\n     /// Inner condition variable that can be used to sleep on the write mode of\n     /// this rwlock.\n-    cond: Condvar<'a>,\n+    pub cond: Condvar<'a>,\n }\n \n /// A guard which is created by locking an rwlock in read mode. Through this\n /// guard the underlying data can be accessed.\n pub struct RWLockReadGuard<'a, T> {\n-    priv data: &'a T,\n-    priv guard: raw::RWLockReadGuard<'a>,\n+    data: &'a T,\n+    guard: raw::RWLockReadGuard<'a>,\n }\n \n impl<T: Send + Share> RWLock<T> {\n@@ -397,8 +397,8 @@ impl<'a, T> DerefMut<T> for RWLockWriteGuard<'a, T> {\n /// }\n /// ```\n pub struct Barrier {\n-    priv lock: Mutex<BarrierState>,\n-    priv num_tasks: uint,\n+    lock: Mutex<BarrierState>,\n+    num_tasks: uint,\n }\n \n // The inner state of a double barrier"}, {"sha": "14dfa8417fac9619f8f2bf4cfd1d5793a710279f", "filename": "src/libsync/mpsc_intrusive.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Fmpsc_intrusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Fmpsc_intrusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_intrusive.rs?ref=a49ce7f11a7c1ec0d77b058caca4694540576cf5", "patch": "@@ -41,18 +41,18 @@ use std::ty::Unsafe;\n // initialization.\n \n pub struct Node<T> {\n-    next: atomics::AtomicUint,\n-    data: T,\n+    pub next: atomics::AtomicUint,\n+    pub data: T,\n }\n \n pub struct DummyNode {\n-    next: atomics::AtomicUint,\n+    pub next: atomics::AtomicUint,\n }\n \n pub struct Queue<T> {\n-    head: atomics::AtomicUint,\n-    tail: Unsafe<*mut Node<T>>,\n-    stub: DummyNode,\n+    pub head: atomics::AtomicUint,\n+    pub tail: Unsafe<*mut Node<T>>,\n+    pub stub: DummyNode,\n }\n \n impl<T: Send> Queue<T> {"}, {"sha": "e41484c46bd75e1fb6e581c849680a09204f4d2c", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=a49ce7f11a7c1ec0d77b058caca4694540576cf5", "patch": "@@ -94,7 +94,7 @@ pub static NATIVE_BLOCKED: uint = 1 << 2;\n /// drop(guard); // unlock the lock\n /// ```\n pub struct Mutex {\n-    priv lock: StaticMutex,\n+    lock: StaticMutex,\n }\n \n #[deriving(Eq, Show)]\n@@ -128,28 +128,28 @@ enum Flavor {\n /// ```\n pub struct StaticMutex {\n     /// Current set of flags on this mutex\n-    priv state: atomics::AtomicUint,\n+    state: atomics::AtomicUint,\n     /// an OS mutex used by native threads\n-    priv lock: mutex::StaticNativeMutex,\n+    lock: mutex::StaticNativeMutex,\n \n     /// Type of locking operation currently on this mutex\n-    priv flavor: Unsafe<Flavor>,\n+    flavor: Unsafe<Flavor>,\n     /// uint-cast of the green thread waiting for this mutex\n-    priv green_blocker: Unsafe<uint>,\n+    green_blocker: Unsafe<uint>,\n     /// uint-cast of the native thread waiting for this mutex\n-    priv native_blocker: Unsafe<uint>,\n+    native_blocker: Unsafe<uint>,\n \n     /// A concurrent mpsc queue used by green threads, along with a count used\n     /// to figure out when to dequeue and enqueue.\n-    priv q: q::Queue<uint>,\n-    priv green_cnt: atomics::AtomicUint,\n+    q: q::Queue<uint>,\n+    green_cnt: atomics::AtomicUint,\n }\n \n /// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n /// dropped (falls out of scope), the lock will be unlocked.\n #[must_use]\n pub struct Guard<'a> {\n-    priv lock: &'a StaticMutex,\n+    lock: &'a StaticMutex,\n }\n \n /// Static initialization of a mutex. This constant can be used to initialize"}, {"sha": "7da6f39b840e57a6c933dfe3929289adf643a5ea", "filename": "src/libsync/one.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Fone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Fone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fone.rs?ref=a49ce7f11a7c1ec0d77b058caca4694540576cf5", "patch": "@@ -41,9 +41,9 @@ use mutex::{StaticMutex, MUTEX_INIT};\n /// }\n /// ```\n pub struct Once {\n-    priv mutex: StaticMutex,\n-    priv cnt: atomics::AtomicInt,\n-    priv lock_cnt: atomics::AtomicInt,\n+    mutex: StaticMutex,\n+    cnt: atomics::AtomicInt,\n+    lock_cnt: atomics::AtomicInt,\n }\n \n /// Initialization value for static `Once` values."}, {"sha": "9bb7a81a2ff00b88c4635a659687d628ba39c978", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=a49ce7f11a7c1ec0d77b058caca4694540576cf5", "patch": "@@ -209,16 +209,16 @@ enum ReacquireOrderLock<'a> {\n pub struct Condvar<'a> {\n     // The 'Sem' object associated with this condvar. This is the one that's\n     // atomically-unlocked-and-descheduled upon and reacquired during wakeup.\n-    priv sem: &'a Sem<Vec<WaitQueue> >,\n+    sem: &'a Sem<Vec<WaitQueue> >,\n     // This is (can be) an extra semaphore which is held around the reacquire\n     // operation on the first one. This is only used in cvars associated with\n     // rwlocks, and is needed to ensure that, when a downgrader is trying to\n     // hand off the access lock (which would be the first field, here), a 2nd\n     // writer waking up from a cvar wait can't race with a reader to steal it,\n     // See the comment in write_cond for more detail.\n-    priv order: ReacquireOrderLock<'a>,\n+    order: ReacquireOrderLock<'a>,\n     // Make sure condvars are non-copyable.\n-    priv nocopy: marker::NoCopy,\n+    nocopy: marker::NoCopy,\n }\n \n impl<'a> Condvar<'a> {\n@@ -362,14 +362,14 @@ struct SemCondGuard<'a> {\n \n /// A counting, blocking, bounded-waiting semaphore.\n pub struct Semaphore {\n-    priv sem: Sem<()>,\n+    sem: Sem<()>,\n }\n \n /// An RAII guard used to represent an acquired resource to a semaphore. When\n /// dropped, this value will release the resource back to the semaphore.\n #[must_use]\n pub struct SemaphoreGuard<'a> {\n-    priv guard: SemGuard<'a, ()>,\n+    guard: SemGuard<'a, ()>,\n }\n \n impl Semaphore {\n@@ -404,18 +404,18 @@ impl Semaphore {\n /// A task which fails while holding a mutex will unlock the mutex as it\n /// unwinds.\n pub struct Mutex {\n-    priv sem: Sem<Vec<WaitQueue>>,\n+    sem: Sem<Vec<WaitQueue>>,\n }\n \n /// An RAII structure which is used to gain access to a mutex's condition\n /// variable. Additionally, when a value of this type is dropped, the\n /// corresponding mutex is also unlocked.\n #[must_use]\n pub struct MutexGuard<'a> {\n-    priv guard: SemGuard<'a, Vec<WaitQueue>>,\n+    guard: SemGuard<'a, Vec<WaitQueue>>,\n     /// Inner condition variable which is connected to the outer mutex, and can\n     /// be used for atomic-unlock-and-deschedule.\n-    cond: Condvar<'a>,\n+    pub cond: Condvar<'a>,\n }\n \n impl Mutex {\n@@ -452,8 +452,8 @@ impl Mutex {\n /// A task which fails while holding an rwlock will unlock the rwlock as it\n /// unwinds.\n pub struct RWLock {\n-    priv order_lock:  Semaphore,\n-    priv access_lock: Sem<Vec<WaitQueue>>,\n+    order_lock:  Semaphore,\n+    access_lock: Sem<Vec<WaitQueue>>,\n \n     // The only way the count flag is ever accessed is with xadd. Since it is\n     // a read-modify-write operation, multiple xadds on different cores will\n@@ -462,14 +462,14 @@ pub struct RWLock {\n     //\n     // FIXME(#6598): The atomics module has no relaxed ordering flag, so I use\n     // acquire/release orderings superfluously. Change these someday.\n-    priv read_count: atomics::AtomicUint,\n+    read_count: atomics::AtomicUint,\n }\n \n /// An RAII helper which is created by acquiring a read lock on an RWLock. When\n /// dropped, this will unlock the RWLock.\n #[must_use]\n pub struct RWLockReadGuard<'a> {\n-    priv lock: &'a RWLock,\n+    lock: &'a RWLock,\n }\n \n /// An RAII helper which is created by acquiring a write lock on an RWLock. When\n@@ -478,10 +478,10 @@ pub struct RWLockReadGuard<'a> {\n /// A value of this type can also be consumed to downgrade to a read-only lock.\n #[must_use]\n pub struct RWLockWriteGuard<'a> {\n-    priv lock: &'a RWLock,\n+    lock: &'a RWLock,\n     /// Inner condition variable that is connected to the write-mode of the\n     /// outer rwlock.\n-    cond: Condvar<'a>,\n+    pub cond: Condvar<'a>,\n }\n \n impl RWLock {"}, {"sha": "fc249996882dfcf8757e93529bb13a106c45113d", "filename": "src/libsync/task_pool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ce7f11a7c1ec0d77b058caca4694540576cf5/src%2Flibsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ftask_pool.rs?ref=a49ce7f11a7c1ec0d77b058caca4694540576cf5", "patch": "@@ -21,8 +21,8 @@ enum Msg<T> {\n }\n \n pub struct TaskPool<T> {\n-    priv channels: Vec<Sender<Msg<T>>>,\n-    priv next_index: uint,\n+    channels: Vec<Sender<Msg<T>>>,\n+    next_index: uint,\n }\n \n #[unsafe_destructor]"}]}