{"sha": "50a0ec91e066237acd8cc416cd1c0457c8240b96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwYTBlYzkxZTA2NjIzN2FjZDhjYzQxNmNkMWMwNDU3YzgyNDBiOTY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-07T22:55:38Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-09T14:44:23Z"}, "message": "check_match: refactor + improve non-exhaustive diag for default binding modes.", "tree": {"sha": "8f05e8d65a130a261f8acc23a81d461710c6d1a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f05e8d65a130a261f8acc23a81d461710c6d1a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50a0ec91e066237acd8cc416cd1c0457c8240b96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50a0ec91e066237acd8cc416cd1c0457c8240b96", "html_url": "https://github.com/rust-lang/rust/commit/50a0ec91e066237acd8cc416cd1c0457c8240b96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50a0ec91e066237acd8cc416cd1c0457c8240b96/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "824383d4ab66abd32abc6e19b68d78ecfddcb7d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/824383d4ab66abd32abc6e19b68d78ecfddcb7d4", "html_url": "https://github.com/rust-lang/rust/commit/824383d4ab66abd32abc6e19b68d78ecfddcb7d4"}], "stats": {"total": 441, "additions": 339, "deletions": 102}, "files": [{"sha": "78d94df4fa03be353a56fe6b7f6bceee41d60104", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/50a0ec91e066237acd8cc416cd1c0457c8240b96/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0ec91e066237acd8cc416cd1c0457c8240b96/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=50a0ec91e066237acd8cc416cd1c0457c8240b96", "patch": "@@ -996,6 +996,24 @@ impl<'tcx> ty::TyS<'tcx> {\n         debug!(\"is_type_representable: {:?} is {:?}\", self, r);\n         r\n     }\n+\n+    /// Peel off all reference types in this type until there are none left.\n+    ///\n+    /// This method is idempotent, i.e. `ty.peel_refs().peel_refs() == ty.peel_refs()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// - `u8` -> `u8`\n+    /// - `&'a mut u8` -> `u8`\n+    /// - `&'a &'b u8` -> `u8`\n+    /// - `&'a *const &'b u8 -> *const &'b u8`\n+    pub fn peel_refs(&'tcx self) -> Ty<'tcx> {\n+        let mut ty = self;\n+        while let Ref(_, inner_ty, _) = ty.sty {\n+            ty = inner_ty;\n+        }\n+        ty\n+    }\n }\n \n fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {"}, {"sha": "c58f5d747e0a2f6ec60cfc45359cf8f22867d2ae", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 102, "deletions": 102, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/50a0ec91e066237acd8cc416cd1c0457c8240b96/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0ec91e066237acd8cc416cd1c0457c8240b96/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=50a0ec91e066237acd8cc416cd1c0457c8240b96", "patch": "@@ -1,4 +1,4 @@\n-use super::_match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n+use super::_match::{MatchCheckCtxt, Matrix, Witness, expand_pattern, is_useful};\n use super::_match::Usefulness::*;\n use super::_match::WitnessPreference::*;\n \n@@ -61,7 +61,7 @@ struct MatchVisitor<'a, 'tcx> {\n     signalled_error: SignalledError,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n@@ -98,8 +98,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n     }\n }\n \n-\n-impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n+impl PatternContext<'_, '_> {\n     fn report_inlining_errors(&self, pat_span: Span) {\n         for error in &self.errors {\n             match *error {\n@@ -131,7 +130,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n+impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_patterns(&mut self, has_guard: bool, pats: &[P<Pat>]) {\n         check_legality_of_move_bindings(self, has_guard, pats);\n         for pat in pats {\n@@ -277,15 +276,9 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 expand_pattern(cx, pattern)\n             ]].into_iter().collect();\n \n-            let wild_pattern = Pattern {\n-                ty: pattern_ty,\n-                span: DUMMY_SP,\n-                kind: box PatternKind::Wild,\n-            };\n-            let witness = match is_useful(cx, &pats, &[&wild_pattern], ConstructWitness) {\n-                UsefulWithWitness(witness) => witness,\n-                NotUseful => return,\n-                Useful => bug!()\n+            let witness = match check_not_useful(cx, pattern_ty, &pats) {\n+                Ok(_) => return,\n+                Err((witness, _)) => witness,\n             };\n \n             let pattern_string = witness[0].single_pattern().to_string();\n@@ -294,20 +287,15 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 \"refutable pattern in {}: `{}` not covered\",\n                 origin, pattern_string\n             );\n-            let label_msg = match pat.node {\n+            err.span_label(pat.span, match pat.node {\n                 PatKind::Path(hir::QPath::Resolved(None, ref path))\n                         if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n                     format!(\"interpreted as {} {} pattern, not new variable\",\n                             path.res.article(), path.res.descr())\n                 }\n                 _ => format!(\"pattern `{}` not covered\", pattern_string),\n-            };\n-            err.span_label(pat.span, label_msg);\n-            if let ty::Adt(def, _) = pattern_ty.sty {\n-                if let Some(sp) = self.tcx.hir().span_if_local(def.did){\n-                    err.span_label(sp, format!(\"`{}` defined here\", pattern_ty));\n-                }\n-            }\n+            });\n+            adt_defined_here(cx, pattern_ty.peel_refs(), &mut err);\n             err.emit();\n         });\n     }\n@@ -362,9 +350,9 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n }\n \n // Check for unreachable patterns\n-fn check_arms<'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    arms: &[(Vec<(&'a Pattern<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n+fn check_arms<'tcx>(\n+    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+    arms: &[(Vec<(&Pattern<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n     source: hir::MatchSource,\n ) {\n     let mut seen = Matrix::empty();\n@@ -445,104 +433,116 @@ fn check_arms<'a, 'tcx>(\n     }\n }\n \n-fn check_exhaustive<'p, 'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+fn check_not_useful(\n+    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+    ty: Ty<'tcx>,\n+    matrix: &Matrix<'_, 'tcx>,\n+) -> Result<(), (Vec<Witness<'tcx>>, Pattern<'tcx>)> {\n+    let wild_pattern = Pattern { ty, span: DUMMY_SP, kind: box PatternKind::Wild };\n+    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n+        NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n+        UsefulWithWitness(pats) => Err((pats, wild_pattern)),\n+        Useful => bug!(),\n+    }\n+}\n+\n+fn check_exhaustive<'tcx>(\n+    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n-    matrix: &Matrix<'p, 'tcx>,\n+    matrix: &Matrix<'_, 'tcx>,\n ) {\n-    let wild_pattern = Pattern {\n-        ty: scrut_ty,\n-        span: DUMMY_SP,\n-        kind: box PatternKind::Wild,\n+    let (pats, wild_pattern) = match check_not_useful(cx, scrut_ty, matrix) {\n+        Ok(_) => return,\n+        Err(err) => err,\n     };\n-    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n-        UsefulWithWitness(pats) => {\n-            let witnesses = if pats.is_empty() {\n-                vec![&wild_pattern]\n-            } else {\n-                pats.iter().map(|w| w.single_pattern()).collect()\n-            };\n \n-            const LIMIT: usize = 3;\n-            let joined_patterns = match witnesses.len() {\n-                0 => bug!(),\n-                1 => format!(\"`{}`\", witnesses[0]),\n-                2..=LIMIT => {\n-                    let (tail, head) = witnesses.split_last().unwrap();\n-                    let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n-                    format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail)\n-                }\n-                _ => {\n-                    let (head, tail) = witnesses.split_at(LIMIT);\n-                    let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n-                    format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n-                }\n-            };\n+    let witnesses = if pats.is_empty() {\n+        vec![&wild_pattern]\n+    } else {\n+        pats.iter().map(|w| w.single_pattern()).collect()\n+    };\n \n-            let label_text = match witnesses.len() {\n-                1 => format!(\"pattern {} not covered\", joined_patterns),\n-                _ => format!(\"patterns {} not covered\", joined_patterns),\n-            };\n-            let mut err = create_e0004(cx.tcx.sess, sp, format!(\n-                \"non-exhaustive patterns: {} not covered\",\n-                joined_patterns,\n-            ));\n-            err.span_label(sp, label_text);\n-            // point at the definition of non-covered enum variants\n-            if let ty::Adt(def, _) = scrut_ty.sty {\n-                if let Some(sp) = cx.tcx.hir().span_if_local(def.did){\n-                    err.span_label(sp, format!(\"`{}` defined here\", scrut_ty));\n-                }\n-            }\n-            let patterns = witnesses.iter().map(|p| (**p).clone()).collect::<Vec<Pattern<'_>>>();\n-            if patterns.len() < 4 {\n-                for sp in maybe_point_at_variant(cx, scrut_ty, patterns.as_slice()) {\n-                    err.span_label(sp, \"not covered\");\n-                }\n-            }\n-            err.help(\"ensure that all possible cases are being handled, \\\n-                      possibly by adding wildcards or more match arms\");\n-            err.emit();\n+    const LIMIT: usize = 3;\n+    let joined_patterns = match witnesses.len() {\n+        0 => bug!(),\n+        1 => format!(\"`{}`\", witnesses[0]),\n+        2..=LIMIT => {\n+            let (tail, head) = witnesses.split_last().unwrap();\n+            let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n+            format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail)\n         }\n-        NotUseful => {\n-            // This is good, wildcard pattern isn't reachable\n+        _ => {\n+            let (head, tail) = witnesses.split_at(LIMIT);\n+            let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n+            format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n+        }\n+    };\n+\n+    let mut err = create_e0004(cx.tcx.sess, sp, format!(\n+        \"non-exhaustive patterns: {} not covered\",\n+        joined_patterns,\n+    ));\n+    err.span_label(sp, match witnesses.len() {\n+        1 => format!(\"pattern {} not covered\", joined_patterns),\n+        _ => format!(\"patterns {} not covered\", joined_patterns),\n+    });\n+    // point at the definition of non-covered enum variants\n+    let scrut_ty = scrut_ty.peel_refs();\n+    adt_defined_here(cx, scrut_ty, &mut err);\n+    let patterns = witnesses.iter().map(|p| (**p).clone()).collect::<Vec<Pattern<'_>>>();\n+    if patterns.len() < 4 {\n+        for sp in maybe_point_at_variant(scrut_ty, &patterns) {\n+            err.span_label(sp, \"not covered\");\n         }\n-        _ => bug!()\n     }\n+    err.help(\"ensure that all possible cases are being handled, \\\n+                possibly by adding wildcards or more match arms\");\n+    err.emit();\n }\n \n-fn maybe_point_at_variant(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    ty: Ty<'tcx>,\n-    patterns: &[Pattern<'_>],\n-) -> Vec<Span> {\n+fn adt_defined_here(cx: &mut MatchCheckCtxt<'_, '_>, ty: Ty<'_>, err: &mut DiagnosticBuilder<'_>) {\n+    if let ty::Adt(def, _) = ty.sty {\n+        if let Some(sp) = cx.tcx.hir().span_if_local(def.did) {\n+            err.span_label(sp, format!(\"`{}` defined here\", ty));\n+        }\n+    }\n+}\n+\n+fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[Pattern<'_>]) -> Vec<Span> {\n     let mut covered = vec![];\n     if let ty::Adt(def, _) = ty.sty {\n         // Don't point at variants that have already been covered due to other patterns to avoid\n-        // visual clutter\n+        // visual clutter.\n         for pattern in patterns {\n-            let pk: &PatternKind<'_> = &pattern.kind;\n-            if let PatternKind::Variant { adt_def, variant_index, subpatterns, .. } = pk {\n-                if adt_def.did == def.did {\n+            use PatternKind::{AscribeUserType, Deref, Variant, Or, Leaf};\n+            match &*pattern.kind {\n+                AscribeUserType { subpattern, .. } | Deref { subpattern } => {\n+                    covered.extend(maybe_point_at_variant(ty, slice::from_ref(&subpattern)));\n+                }\n+                Variant { adt_def, variant_index, subpatterns, .. } if adt_def.did == def.did => {\n                     let sp = def.variants[*variant_index].ident.span;\n                     if covered.contains(&sp) {\n                         continue;\n                     }\n                     covered.push(sp);\n-                    let subpatterns = subpatterns.iter()\n+\n+                    let pats = subpatterns.iter()\n                         .map(|field_pattern| field_pattern.pattern.clone())\n-                        .collect::<Vec<_>>();\n-                    covered.extend(\n-                        maybe_point_at_variant(cx, ty, subpatterns.as_slice()),\n-                    );\n+                        .collect::<Box<[_]>>();\n+                    covered.extend(maybe_point_at_variant(ty, &pats));\n                 }\n-            }\n-            if let PatternKind::Leaf { subpatterns } = pk {\n-                let subpatterns = subpatterns.iter()\n-                    .map(|field_pattern| field_pattern.pattern.clone())\n-                    .collect::<Vec<_>>();\n-                covered.extend(maybe_point_at_variant(cx, ty, subpatterns.as_slice()));\n+                Leaf { subpatterns } => {\n+                    let pats = subpatterns.iter()\n+                        .map(|field_pattern| field_pattern.pattern.clone())\n+                        .collect::<Box<[_]>>();\n+                    covered.extend(maybe_point_at_variant(ty, &pats));\n+                }\n+                Or { pats } => {\n+                    let pats = pats.iter().cloned().collect::<Box<[_]>>();\n+                    covered.extend(maybe_point_at_variant(ty, &pats));\n+                }\n+                _ => {}\n             }\n         }\n     }\n@@ -709,7 +709,7 @@ struct AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     bindings_allowed: bool\n }\n \n-impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n+impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n         NestedVisitorMap::None\n     }"}, {"sha": "bf0bd3aca97a4bf26b1809057c42dc51c72a2ee0", "filename": "src/test/ui/consts/match_ice.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50a0ec91e066237acd8cc416cd1c0457c8240b96/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50a0ec91e066237acd8cc416cd1c0457c8240b96/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr?ref=50a0ec91e066237acd8cc416cd1c0457c8240b96", "patch": "@@ -7,6 +7,9 @@ LL |         C => {}\n error[E0004]: non-exhaustive patterns: `&T` not covered\n   --> $DIR/match_ice.rs:15:11\n    |\n+LL | struct T;\n+   | --------- `T` defined here\n+...\n LL |     match K {\n    |           ^ pattern `&T` not covered\n    |"}, {"sha": "1ba7c2a66ba57dd0cbe48d844ce0d8949db700c2", "filename": "src/test/ui/match/non-exhaustive-defined-here.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/50a0ec91e066237acd8cc416cd1c0457c8240b96/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a0ec91e066237acd8cc416cd1c0457c8240b96/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.rs?ref=50a0ec91e066237acd8cc416cd1c0457c8240b96", "patch": "@@ -0,0 +1,65 @@\n+// Test the \"defined here\" and \"not covered\" diagnostic hints.\n+// We also make sure that references are peeled off from the scrutinee type\n+// so that the diagnostics work better with default binding modes.\n+\n+#[derive(Clone)]\n+enum E {\n+//~^ `E` defined here\n+//~| `E` defined here\n+//~| `E` defined here\n+//~| `E` defined here\n+//~| `E` defined here\n+//~| `E` defined here\n+    A,\n+    B,\n+    //~^ not covered\n+    //~| not covered\n+    //~| not covered\n+    C\n+    //~^ not covered\n+    //~| not covered\n+    //~| not covered\n+}\n+\n+fn by_val(e: E) {\n+    let e1 = e.clone();\n+    match e1 { //~ ERROR non-exhaustive patterns: `B` and `C` not covered\n+        E::A => {}\n+    }\n+\n+    let E::A = e; //~ ERROR refutable pattern in local binding: `B` not covered\n+}\n+\n+fn by_ref_once(e: &E) {\n+    match e { //~ ERROR non-exhaustive patterns: `&B` and `&C` not covered\n+        E::A => {}\n+    }\n+\n+    let E::A = e; //~ ERROR refutable pattern in local binding: `&B` not covered\n+}\n+\n+fn by_ref_thrice(e: & &mut &E) {\n+    match e { //~ ERROR non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n+        E::A => {}\n+    }\n+\n+    let E::A = e; //~ ERROR refutable pattern in local binding: `&&mut &B` not covered\n+}\n+\n+enum Opt {\n+//~^ `Opt` defined here\n+//~| `Opt` defined here\n+    Some(u8),\n+    None,\n+    //~^ not covered\n+}\n+\n+fn ref_pat(e: Opt) {\n+    match e {//~ ERROR non-exhaustive patterns: `None` not covered\n+        Opt::Some(ref _x) => {}\n+    }\n+\n+    let Opt::Some(ref _x) = e; //~ ERROR refutable pattern in local binding: `None` not covered\n+}\n+\n+fn main() {}"}, {"sha": "b0dccc975ab874c3dcdcca0f6a28a6f21dbb36b3", "filename": "src/test/ui/match/non-exhaustive-defined-here.stderr", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/50a0ec91e066237acd8cc416cd1c0457c8240b96/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50a0ec91e066237acd8cc416cd1c0457c8240b96/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr?ref=50a0ec91e066237acd8cc416cd1c0457c8240b96", "patch": "@@ -0,0 +1,151 @@\n+error[E0004]: non-exhaustive patterns: `B` and `C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:26:11\n+   |\n+LL | / enum E {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     B,\n+   | |     - not covered\n+...  |\n+LL | |     C\n+   | |     - not covered\n+...  |\n+LL | |\n+LL | | }\n+   | |_- `E` defined here\n+...\n+LL |       match e1 {\n+   |             ^^ patterns `B` and `C` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0005]: refutable pattern in local binding: `B` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:30:9\n+   |\n+LL | / enum E {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |\n+LL | | }\n+   | |_- `E` defined here\n+...\n+LL |       let E::A = e;\n+   |           ^^^^ pattern `B` not covered\n+\n+error[E0004]: non-exhaustive patterns: `&B` and `&C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:34:11\n+   |\n+LL | / enum E {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     B,\n+   | |     - not covered\n+...  |\n+LL | |     C\n+   | |     - not covered\n+...  |\n+LL | |\n+LL | | }\n+   | |_- `E` defined here\n+...\n+LL |       match e {\n+   |             ^ patterns `&B` and `&C` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0005]: refutable pattern in local binding: `&B` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:38:9\n+   |\n+LL | / enum E {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |\n+LL | | }\n+   | |_- `E` defined here\n+...\n+LL |       let E::A = e;\n+   |           ^^^^ pattern `&B` not covered\n+\n+error[E0004]: non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:42:11\n+   |\n+LL | / enum E {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     B,\n+   | |     - not covered\n+...  |\n+LL | |     C\n+   | |     - not covered\n+...  |\n+LL | |\n+LL | | }\n+   | |_- `E` defined here\n+...\n+LL |       match e {\n+   |             ^ patterns `&&mut &B` and `&&mut &C` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0005]: refutable pattern in local binding: `&&mut &B` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:46:9\n+   |\n+LL | / enum E {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |\n+LL | | }\n+   | |_- `E` defined here\n+...\n+LL |       let E::A = e;\n+   |           ^^^^ pattern `&&mut &B` not covered\n+\n+error[E0004]: non-exhaustive patterns: `None` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:58:11\n+   |\n+LL | / enum Opt {\n+LL | |\n+LL | |\n+LL | |     Some(u8),\n+LL | |     None,\n+   | |     ---- not covered\n+LL | |\n+LL | | }\n+   | |_- `Opt` defined here\n+...\n+LL |       match e {\n+   |             ^ pattern `None` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0005]: refutable pattern in local binding: `None` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:62:9\n+   |\n+LL | / enum Opt {\n+LL | |\n+LL | |\n+LL | |     Some(u8),\n+LL | |     None,\n+LL | |\n+LL | | }\n+   | |_- `Opt` defined here\n+...\n+LL |       let Opt::Some(ref _x) = e;\n+   |           ^^^^^^^^^^^^^^^^^ pattern `None` not covered\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0004, E0005.\n+For more information about an error, try `rustc --explain E0004`."}]}