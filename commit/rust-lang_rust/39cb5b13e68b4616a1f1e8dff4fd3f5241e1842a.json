{"sha": "39cb5b13e68b4616a1f1e8dff4fd3f5241e1842a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5Y2I1YjEzZTY4YjQ2MTZhMWYxZThkZmY0ZmQzZjUyNDFlMTg0MmE=", "commit": {"author": {"name": "Jonathan S", "email": "gereeter@gmail.com", "date": "2014-05-12T00:34:33Z"}, "committer": {"name": "Jonathan S", "email": "gereeter@gmail.com", "date": "2014-05-15T01:34:43Z"}, "message": "Switched to the two-way algorithm for string searching\n\ntest str::bench::bench_contains_bad_naive                   ... bench:       300 ns/iter (+/- 12)     from 1309 ns/iter (+/- 36)\ntest str::bench::bench_contains_equal                       ... bench:       154 ns/iter (+/- 7)      from  137 ns/iter (+/- 2)\ntest str::bench::bench_contains_short_long                  ... bench:      2998 ns/iter (+/- 74)     from 5473 ns/iter (+/- 14)\ntest str::bench::bench_contains_short_short                 ... bench:        65 ns/iter (+/- 2)      from   57 ns/iter (+/- 6)", "tree": {"sha": "86921188f1233891b02d714825429d910afbd19a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86921188f1233891b02d714825429d910afbd19a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39cb5b13e68b4616a1f1e8dff4fd3f5241e1842a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39cb5b13e68b4616a1f1e8dff4fd3f5241e1842a", "html_url": "https://github.com/rust-lang/rust/commit/39cb5b13e68b4616a1f1e8dff4fd3f5241e1842a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39cb5b13e68b4616a1f1e8dff4fd3f5241e1842a/comments", "author": null, "committer": null, "parents": [{"sha": "8a32a2a8726eb882a6e3962e40d04cad2ca9555e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a32a2a8726eb882a6e3962e40d04cad2ca9555e", "html_url": "https://github.com/rust-lang/rust/commit/8a32a2a8726eb882a6e3962e40d04cad2ca9555e"}], "stats": {"total": 232, "additions": 206, "deletions": 26}, "files": [{"sha": "1200bf8fa3489a4b02bbd97280309388acf0d409", "filename": "src/libcore/str.rs", "status": "modified", "additions": 206, "deletions": 26, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/39cb5b13e68b4616a1f1e8dff4fd3f5241e1842a/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39cb5b13e68b4616a1f1e8dff4fd3f5241e1842a/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=39cb5b13e68b4616a1f1e8dff4fd3f5241e1842a", "patch": "@@ -15,16 +15,19 @@\n use mem;\n use char;\n use clone::Clone;\n+use cmp;\n use cmp::{Eq, TotalEq};\n use container::Container;\n use default::Default;\n use iter::{Filter, Map, Iterator};\n use iter::{Rev, DoubleEndedIterator, ExactSize};\n+use iter::range;\n use num::Saturating;\n use option::{None, Option, Some};\n use raw::Repr;\n use slice::{ImmutableVector, Vector};\n use slice;\n+use uint;\n \n /*\n Section: Creating a string\n@@ -316,13 +319,207 @@ impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitsN<'a, Sep> {\n     }\n }\n \n+/// The internal state of an iterator that searches for matches of a substring\n+/// within a larger string using naive search\n+#[deriving(Clone)]\n+struct NaiveSearcher {\n+    position: uint\n+}\n+\n+impl NaiveSearcher {\n+    fn new() -> NaiveSearcher {\n+        NaiveSearcher { position: 0 }\n+    }\n+\n+    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n+        while self.position + needle.len() <= haystack.len() {\n+            if haystack.slice(self.position, self.position + needle.len()) == needle {\n+                let matchPos = self.position;\n+                self.position += needle.len(); // add 1 for all matches\n+                return Some((matchPos, matchPos + needle.len()));\n+            } else {\n+                self.position += 1;\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+/// The internal state of an iterator that searches for matches of a substring\n+/// within a larger string using two-way search\n+#[deriving(Clone)]\n+struct TwoWaySearcher {\n+    // constants\n+    critPos: uint,\n+    period: uint,\n+    byteset: u64,\n+\n+    // variables\n+    position: uint,\n+    memory: uint\n+}\n+\n+impl TwoWaySearcher {\n+    fn new(needle: &[u8]) -> TwoWaySearcher {\n+        let (critPos1, period1) = TwoWaySearcher::maximal_suffix(needle, false);\n+        let (critPos2, period2) = TwoWaySearcher::maximal_suffix(needle, true);\n+\n+        let critPos;\n+        let period;\n+        if critPos1 > critPos2 {\n+            critPos = critPos1;\n+            period = period1;\n+        } else {\n+            critPos = critPos2;\n+            period = period2;\n+        }\n+\n+        let byteset = needle.iter().fold(0, |a, &b| (1 << (b & 0x3f)) | a);\n+\n+        if needle.slice_to(critPos) == needle.slice_from(needle.len() - critPos) {\n+            TwoWaySearcher {\n+                critPos: critPos,\n+                period: period,\n+                byteset: byteset,\n+\n+                position: 0,\n+                memory: 0\n+            }\n+        } else {\n+            TwoWaySearcher {\n+                critPos: critPos,\n+                period: cmp::max(critPos, needle.len() - critPos) + 1,\n+                byteset: byteset,\n+\n+                position: 0,\n+                memory: uint::MAX // Dummy value to signify that the period is long\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn next(&mut self, haystack: &[u8], needle: &[u8], longPeriod: bool) -> Option<(uint, uint)> {\n+        'search: loop {\n+            // Check that we have room to search in\n+            if self.position + needle.len() > haystack.len() {\n+                return None;\n+            }\n+\n+            // Quickly skip by large portions unrelated to our substring\n+            if (self.byteset >> (haystack[self.position + needle.len() - 1] & 0x3f)) & 1 == 0 {\n+                self.position += needle.len();\n+                continue 'search;\n+            }\n+\n+            // See if the right part of the needle matches\n+            let start = if longPeriod { self.critPos } else { cmp::max(self.critPos, self.memory) };\n+            for i in range(start, needle.len()) {\n+                if needle[i] != haystack[self.position + i] {\n+                    self.position += i - self.critPos + 1;\n+                    if !longPeriod {\n+                        self.memory = 0;\n+                    }\n+                    continue 'search;\n+                }\n+            }\n+\n+            // See if the left part of the needle matches\n+            let start = if longPeriod { 0 } else { self.memory };\n+            for i in range(start, self.critPos).rev() {\n+                if needle[i] != haystack[self.position + i] {\n+                    self.position += self.period;\n+                    if !longPeriod {\n+                        self.memory = needle.len() - self.period;\n+                    }\n+                    continue 'search;\n+                }\n+            }\n+\n+            // We have found a match!\n+            let matchPos = self.position;\n+            self.position += needle.len(); // add self.period for all matches\n+            if !longPeriod {\n+                self.memory = 0; // set to needle.len() - self.period for all matches\n+            }\n+            return Some((matchPos, matchPos + needle.len()));\n+        }\n+    }\n+\n+    #[inline]\n+    fn maximal_suffix(arr: &[u8], reversed: bool) -> (uint, uint) {\n+        let mut left = -1; // Corresponds to i in the paper\n+        let mut right = 0; // Corresponds to j in the paper\n+        let mut offset = 1; // Corresponds to k in the paper\n+        let mut period = 1; // Corresponds to p in the paper\n+\n+        while right + offset < arr.len() {\n+            let a;\n+            let b;\n+            if reversed {\n+                a = arr[left + offset];\n+                b = arr[right + offset];\n+            } else {\n+                a = arr[right + offset];\n+                b = arr[left + offset];\n+            }\n+            if a < b {\n+                // Suffix is smaller, period is entire prefix so far.\n+                right += offset;\n+                offset = 1;\n+                period = right - left;\n+            } else if a == b {\n+                // Advance through repetition of the current period.\n+                if offset == period {\n+                    right += offset;\n+                    offset = 1;\n+                } else {\n+                    offset += 1;\n+                }\n+            } else {\n+                // Suffix is larger, start over from current location.\n+                left = right;\n+                right += 1;\n+                offset = 1;\n+                period = 1;\n+            }\n+        }\n+        (left + 1, period)\n+    }\n+}\n+\n+/// The internal state of an iterator that searches for matches of a substring\n+/// within a larger string using a dynamically chosed search algorithm\n+#[deriving(Clone)]\n+enum Searcher {\n+    Naive(NaiveSearcher),\n+    TwoWay(TwoWaySearcher),\n+    TwoWayLong(TwoWaySearcher)\n+}\n+\n+impl Searcher {\n+    fn new(haystack: &[u8], needle: &[u8]) -> Searcher {\n+        // FIXME: Tune this.\n+        if needle.len() > haystack.len() - 20 {\n+            Naive(NaiveSearcher::new())\n+        } else {\n+            let searcher = TwoWaySearcher::new(needle);\n+            if searcher.memory == uint::MAX { // If the period is long\n+                TwoWayLong(searcher)\n+            } else {\n+                TwoWay(searcher)\n+            }\n+        }\n+    }\n+}\n+\n /// An iterator over the start and end indices of the matches of a\n /// substring within a larger string\n #[deriving(Clone)]\n pub struct MatchIndices<'a> {\n+    // constants\n     haystack: &'a str,\n     needle: &'a str,\n-    position: uint,\n+    searcher: Searcher\n }\n \n /// An iterator over the substrings of a string separated by a given\n@@ -337,31 +534,14 @@ pub struct StrSplits<'a> {\n impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, uint)> {\n-        // See Issue #1932 for why this is a naive search\n-        let (h_len, n_len) = (self.haystack.len(), self.needle.len());\n-        let mut match_start = 0;\n-        let mut match_i = 0;\n-\n-        while self.position < h_len {\n-            if self.haystack[self.position] == self.needle[match_i] {\n-                if match_i == 0 { match_start = self.position; }\n-                match_i += 1;\n-                self.position += 1;\n-\n-                if match_i == n_len {\n-                    // found a match!\n-                    return Some((match_start, self.position));\n-                }\n-            } else {\n-                // failed match, backtrack\n-                if match_i > 0 {\n-                    match_i = 0;\n-                    self.position = match_start;\n-                }\n-                self.position += 1;\n-            }\n+        match self.searcher {\n+            Naive(ref mut searcher)\n+                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes()),\n+            TwoWay(ref mut searcher)\n+                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), false),\n+            TwoWayLong(ref mut searcher)\n+                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), true)\n         }\n-        None\n     }\n }\n \n@@ -1581,7 +1761,7 @@ impl<'a> StrSlice<'a> for &'a str {\n         MatchIndices {\n             haystack: *self,\n             needle: sep,\n-            position: 0\n+            searcher: Searcher::new(self.as_bytes(), sep.as_bytes())\n         }\n     }\n "}]}