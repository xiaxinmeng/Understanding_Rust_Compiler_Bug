{"sha": "d757c4b904869967f1e665dc2bb9a2ca5122bc96", "node_id": "C_kwDOAAsO6NoAKGQ3NTdjNGI5MDQ4Njk5NjdmMWU2NjVkYzJiYjlhMmNhNTEyMmJjOTY", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-04-06T23:24:32Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-04-09T18:16:50Z"}, "message": "Handle not all immediates having `abi::Scalar`s", "tree": {"sha": "c5bce969e1b74802a308081b10a9f75380e62ba8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5bce969e1b74802a308081b10a9f75380e62ba8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d757c4b904869967f1e665dc2bb9a2ca5122bc96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d757c4b904869967f1e665dc2bb9a2ca5122bc96", "html_url": "https://github.com/rust-lang/rust/commit/d757c4b904869967f1e665dc2bb9a2ca5122bc96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d757c4b904869967f1e665dc2bb9a2ca5122bc96/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "454bca514aab74a8c3c746908cac2d9c61300941", "url": "https://api.github.com/repos/rust-lang/rust/commits/454bca514aab74a8c3c746908cac2d9c61300941", "html_url": "https://github.com/rust-lang/rust/commit/454bca514aab74a8c3c746908cac2d9c61300941"}], "stats": {"total": 147, "additions": 134, "deletions": 13}, "files": [{"sha": "d88226f5db05335ee404e996c8fc5c6969b81333", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d757c4b904869967f1e665dc2bb9a2ca5122bc96/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d757c4b904869967f1e665dc2bb9a2ca5122bc96/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=d757c4b904869967f1e665dc2bb9a2ca5122bc96", "patch": "@@ -223,13 +223,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let OperandValueKind::Immediate(in_scalar) = operand_kind else {\n                     bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n                 };\n-                if let OperandValueKind::Immediate(out_scalar) = cast_kind\n-                    && in_scalar.size(self.cx) == out_scalar.size(self.cx)\n-                {\n-                    let cast_bty = bx.backend_type(cast);\n-                    Some(OperandValue::Immediate(\n-                        self.transmute_immediate(bx, imm, in_scalar, out_scalar, cast_bty),\n-                    ))\n+                if let OperandValueKind::Immediate(out_scalar) = cast_kind {\n+                    match (in_scalar, out_scalar) {\n+                        (ScalarOrZst::Zst, ScalarOrZst::Zst) => {\n+                            Some(OperandRef::new_zst(bx, cast).val)\n+                        }\n+                        (ScalarOrZst::Scalar(in_scalar), ScalarOrZst::Scalar(out_scalar))\n+                            if in_scalar.size(self.cx) == out_scalar.size(self.cx) =>\n+                        {\n+                            let cast_bty = bx.backend_type(cast);\n+                            Some(OperandValue::Immediate(\n+                                self.transmute_immediate(bx, imm, in_scalar, out_scalar, cast_bty),\n+                            ))\n+                        }\n+                        _ => None,\n+                    }\n                 } else {\n                     None\n                 }\n@@ -892,13 +900,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if self.cx.is_backend_immediate(layout) {\n             debug_assert!(!self.cx.is_backend_scalar_pair(layout));\n             OperandValueKind::Immediate(match layout.abi {\n-                abi::Abi::Scalar(s) => s,\n-                abi::Abi::Vector { element, .. } => element,\n-                x => bug!(\"Couldn't translate {x:?} as backend immediate\"),\n+                abi::Abi::Scalar(s) => ScalarOrZst::Scalar(s),\n+                abi::Abi::Vector { element, .. } => ScalarOrZst::Scalar(element),\n+                _ if layout.is_zst() => ScalarOrZst::Zst,\n+                x => span_bug!(self.mir.span, \"Couldn't translate {x:?} as backend immediate\"),\n             })\n         } else if self.cx.is_backend_scalar_pair(layout) {\n             let abi::Abi::ScalarPair(s1, s2) = layout.abi else {\n-                bug!(\"Couldn't translate {:?} as backend scalar pair\", layout.abi)\n+                span_bug!(\n+                    self.mir.span,\n+                    \"Couldn't translate {:?} as backend scalar pair\",\n+                    layout.abi,\n+                );\n             };\n             OperandValueKind::Pair(s1, s2)\n         } else {\n@@ -907,9 +920,26 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n }\n \n+/// The variants of this match [`OperandValue`], giving details about the\n+/// backend values that will be held in that other type.\n #[derive(Debug, Copy, Clone)]\n enum OperandValueKind {\n     Ref,\n-    Immediate(abi::Scalar),\n+    Immediate(ScalarOrZst),\n     Pair(abi::Scalar, abi::Scalar),\n }\n+\n+#[derive(Debug, Copy, Clone)]\n+enum ScalarOrZst {\n+    Zst,\n+    Scalar(abi::Scalar),\n+}\n+\n+impl ScalarOrZst {\n+    pub fn size(self, cx: &impl abi::HasDataLayout) -> abi::Size {\n+        match self {\n+            ScalarOrZst::Zst => abi::Size::ZERO,\n+            ScalarOrZst::Scalar(s) => s.size(cx),\n+        }\n+    }\n+}"}, {"sha": "99d258c62040fed5c5cc72b84d84b759c9352d04", "filename": "tests/codegen/intrinsics/transmute-x64.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d757c4b904869967f1e665dc2bb9a2ca5122bc96/tests%2Fcodegen%2Fintrinsics%2Ftransmute-x64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d757c4b904869967f1e665dc2bb9a2ca5122bc96/tests%2Fcodegen%2Fintrinsics%2Ftransmute-x64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute-x64.rs?ref=d757c4b904869967f1e665dc2bb9a2ca5122bc96", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -O -C no-prepopulate-passes\n+// only-x86_64 (it's using arch-specific types)\n+// min-llvm-version: 15.0 # this test assumes `ptr`s\n+\n+#![crate_type = \"lib\"]\n+\n+use std::arch::x86_64::{__m128, __m128i, __m256i};\n+use std::mem::transmute;\n+\n+// CHECK-LABEL: @check_sse_float_to_int(\n+#[no_mangle]\n+pub unsafe fn check_sse_float_to_int(x: __m128) -> __m128i {\n+    // CHECK-NOT: alloca\n+    // CHECK: %1 = load <4 x float>, ptr %x, align 16\n+    // CHECK: store <4 x float> %1, ptr %0, align 16\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_sse_pair_to_avx(\n+#[no_mangle]\n+pub unsafe fn check_sse_pair_to_avx(x: (__m128i, __m128i)) -> __m256i {\n+    // CHECK-NOT: alloca\n+    // CHECK: %1 = load <4 x i64>, ptr %x, align 16\n+    // CHECK: store <4 x i64> %1, ptr %0, align 32\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_sse_pair_from_avx(\n+#[no_mangle]\n+pub unsafe fn check_sse_pair_from_avx(x: __m256i) -> (__m128i, __m128i) {\n+    // CHECK-NOT: alloca\n+    // CHECK: %1 = load <4 x i64>, ptr %x, align 32\n+    // CHECK: store <4 x i64> %1, ptr %0, align 16\n+    transmute(x)\n+}"}, {"sha": "57f901c6719921b284e79863307ed9462c154b2a", "filename": "tests/codegen/intrinsics/transmute.rs", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d757c4b904869967f1e665dc2bb9a2ca5122bc96/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d757c4b904869967f1e665dc2bb9a2ca5122bc96/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs?ref=d757c4b904869967f1e665dc2bb9a2ca5122bc96", "patch": "@@ -8,7 +8,7 @@\n #![feature(inline_const)]\n #![allow(unreachable_code)]\n \n-use std::mem::transmute;\n+use std::mem::{transmute, MaybeUninit};\n \n // Some of the cases here are statically rejected by `mem::transmute`, so\n // we need to generate custom MIR for those cases to get to codegen.\n@@ -373,3 +373,59 @@ pub unsafe fn check_pair_to_dst_ref<'a>(x: (usize, usize)) -> &'a [u8] {\n     // CHECK: ret { ptr, i64 } %2\n     transmute(x)\n }\n+\n+// CHECK-LABEL: @check_issue_109992(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_issue_109992(x: ()) -> [(); 1] {\n+    // This uses custom MIR to avoid MIR optimizations having removed ZST ops.\n+\n+    // CHECK: start\n+    // CHECK-NEXT: ret void\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_maybe_uninit_pair(i16 %x.0, i64 %x.1)\n+#[no_mangle]\n+pub unsafe fn check_maybe_uninit_pair(\n+    x: (MaybeUninit<u16>, MaybeUninit<u64>),\n+) -> (MaybeUninit<i64>, MaybeUninit<i16>) {\n+    // Thanks to `MaybeUninit` this is actually defined behaviour,\n+    // unlike the examples above with pairs of primitives.\n+\n+    // CHECK: store i16 %x.0\n+    // CHECK: store i64 %x.1\n+    // CHECK: load i64\n+    // CHECK-NOT: noundef\n+    // CHECK: load i16\n+    // CHECK-NOT: noundef\n+    // CHECK: ret { i64, i16 }\n+    transmute(x)\n+}\n+\n+#[repr(align(8))]\n+pub struct HighAlignScalar(u8);\n+\n+// CHECK-LABEL: @check_to_overalign(\n+#[no_mangle]\n+pub unsafe fn check_to_overalign(x: u64) -> HighAlignScalar {\n+    // CHECK: %0 = alloca %HighAlignScalar, align 8\n+    // CHECK: store i64 %x, ptr %0, align 8\n+    // CHECK: %1 = load i64, ptr %0, align 8\n+    // CHECK: ret i64 %1\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_from_overalign(\n+#[no_mangle]\n+pub unsafe fn check_from_overalign(x: HighAlignScalar) -> u64 {\n+    // CHECK: %x = alloca %HighAlignScalar, align 8\n+    // CHECK: %[[VAL:.+]] = load i64, ptr %x, align 8\n+    // CHECK: ret i64 %[[VAL]]\n+    transmute(x)\n+}"}]}