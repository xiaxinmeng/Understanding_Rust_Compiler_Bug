{"sha": "f3ef4a416d162c0a3f18c627d27fdb3676df336c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzZWY0YTQxNmQxNjJjMGEzZjE4YzYyN2QyN2ZkYjM2NzZkZjMzNmM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-08T05:44:24Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-21T17:34:00Z"}, "message": "extract parse_ty_tuple_or_parens", "tree": {"sha": "ba0cabde858b5bfe5e8a4fa47c672664c6160314", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba0cabde858b5bfe5e8a4fa47c672664c6160314"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3ef4a416d162c0a3f18c627d27fdb3676df336c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3ef4a416d162c0a3f18c627d27fdb3676df336c", "html_url": "https://github.com/rust-lang/rust/commit/f3ef4a416d162c0a3f18c627d27fdb3676df336c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3ef4a416d162c0a3f18c627d27fdb3676df336c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "url": "https://api.github.com/repos/rust-lang/rust/commits/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "html_url": "https://github.com/rust-lang/rust/commit/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06"}], "stats": {"total": 82, "additions": 44, "deletions": 38}, "files": [{"sha": "ae660432923e5620f4e0e300844b57d9403c1e9e", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f3ef4a416d162c0a3f18c627d27fdb3676df336c/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ef4a416d162c0a3f18c627d27fdb3676df336c/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=f3ef4a416d162c0a3f18c627d27fdb3676df336c", "patch": "@@ -74,44 +74,7 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let mut impl_dyn_multi = false;\n         let kind = if self.eat(&token::OpenDelim(token::Paren)) {\n-            // `(TYPE)` is a parenthesized type.\n-            // `(TYPE,)` is a tuple with a single field of type TYPE.\n-            let mut ts = vec![];\n-            let mut last_comma = false;\n-            while self.token != token::CloseDelim(token::Paren) {\n-                ts.push(self.parse_ty()?);\n-                if self.eat(&token::Comma) {\n-                    last_comma = true;\n-                } else {\n-                    last_comma = false;\n-                    break;\n-                }\n-            }\n-            let trailing_plus = self.prev_token_kind == PrevTokenKind::Plus;\n-            self.expect(&token::CloseDelim(token::Paren))?;\n-\n-            if ts.len() == 1 && !last_comma {\n-                let ty = ts.into_iter().nth(0).unwrap().into_inner();\n-                let maybe_bounds = allow_plus && self.token.is_like_plus();\n-                match ty.kind {\n-                    // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n-                    TyKind::Path(None, ref path) if maybe_bounds => {\n-                        self.parse_remaining_bounds(Vec::new(), path.clone(), lo, true)?\n-                    }\n-                    TyKind::TraitObject(ref bounds, TraitObjectSyntax::None)\n-                            if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n-                        let path = match bounds[0] {\n-                            GenericBound::Trait(ref pt, ..) => pt.trait_ref.path.clone(),\n-                            GenericBound::Outlives(..) => self.bug(\"unexpected lifetime bound\"),\n-                        };\n-                        self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n-                    }\n-                    // `(TYPE)`\n-                    _ => TyKind::Paren(P(ty))\n-                }\n-            } else {\n-                TyKind::Tup(ts)\n-            }\n+            self.parse_ty_tuple_or_parens(allow_plus)?\n         } else if self.eat(&token::Not) {\n             // Never type `!`\n             TyKind::Never\n@@ -242,6 +205,49 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(ty, allow_qpath_recovery)\n     }\n \n+    /// Parses either:\n+    /// - `(TYPE)`, a parenthesized type.\n+    /// - `(TYPE,)`, a tuple with a single field of type TYPE.\n+    fn parse_ty_tuple_or_parens(&mut self, allow_plus: bool) -> PResult<'a, TyKind> {\n+        let lo = self.token.span;\n+        let mut ts = vec![];\n+        let mut last_comma = false;\n+        while self.token != token::CloseDelim(token::Paren) {\n+            ts.push(self.parse_ty()?);\n+            if self.eat(&token::Comma) {\n+                last_comma = true;\n+            } else {\n+                last_comma = false;\n+                break;\n+            }\n+        }\n+        let trailing_plus = self.prev_token_kind == PrevTokenKind::Plus;\n+        self.expect(&token::CloseDelim(token::Paren))?;\n+\n+        if ts.len() == 1 && !last_comma {\n+            let ty = ts.into_iter().nth(0).unwrap().into_inner();\n+            let maybe_bounds = allow_plus && self.token.is_like_plus();\n+            match ty.kind {\n+                // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n+                TyKind::Path(None, ref path) if maybe_bounds => {\n+                    self.parse_remaining_bounds(Vec::new(), path.clone(), lo, true)\n+                }\n+                TyKind::TraitObject(ref bounds, TraitObjectSyntax::None)\n+                        if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n+                    let path = match bounds[0] {\n+                        GenericBound::Trait(ref pt, ..) => pt.trait_ref.path.clone(),\n+                        GenericBound::Outlives(..) => self.bug(\"unexpected lifetime bound\"),\n+                    };\n+                    self.parse_remaining_bounds(Vec::new(), path, lo, true)\n+                }\n+                // `(TYPE)`\n+                _ => Ok(TyKind::Paren(P(ty)))\n+            }\n+        } else {\n+            Ok(TyKind::Tup(ts))\n+        }\n+    }\n+\n     fn parse_remaining_bounds(&mut self, generic_params: Vec<GenericParam>, path: ast::Path,\n                               lo: Span, parse_plus: bool) -> PResult<'a, TyKind> {\n         let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));"}]}