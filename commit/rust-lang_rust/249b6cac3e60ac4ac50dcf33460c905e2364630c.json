{"sha": "249b6cac3e60ac4ac50dcf33460c905e2364630c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0OWI2Y2FjM2U2MGFjNGFjNTBkY2YzMzQ2MGM5MDVlMjM2NDYzMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-04T06:45:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-04T06:45:04Z"}, "message": "Auto merge of #4625 - phansch:rollup-qp7ki0h, r=phansch\n\nRollup of 2 pull requests\n\nSuccessful merges:\n\n - #4509 (Fix false-positive of redundant_clone and move to clippy::perf)\n - #4614 (Allow casts from the result of `abs` to unsigned)\n\nFailed merges:\n\nchangelog: none\n\nr? @ghost", "tree": {"sha": "8cdb1a41f1d21592c46bb9527ff9d02b6386a48c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cdb1a41f1d21592c46bb9527ff9d02b6386a48c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/249b6cac3e60ac4ac50dcf33460c905e2364630c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/249b6cac3e60ac4ac50dcf33460c905e2364630c", "html_url": "https://github.com/rust-lang/rust/commit/249b6cac3e60ac4ac50dcf33460c905e2364630c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/249b6cac3e60ac4ac50dcf33460c905e2364630c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c926f1b571286ff131d28de062a09e1224736c1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c926f1b571286ff131d28de062a09e1224736c1b", "html_url": "https://github.com/rust-lang/rust/commit/c926f1b571286ff131d28de062a09e1224736c1b"}, {"sha": "19c58d260bca9702a4fb4079e360b61248ac8738", "url": "https://api.github.com/repos/rust-lang/rust/commits/19c58d260bca9702a4fb4079e360b61248ac8738", "html_url": "https://github.com/rust-lang/rust/commit/19c58d260bca9702a4fb4079e360b61248ac8738"}], "stats": {"total": 938, "additions": 733, "deletions": 205}, "files": [{"sha": "3c90aa4b50759e57dceeb048d94d9c249c51db82", "filename": "clippy_dev/src/fmt.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/clippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/clippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Ffmt.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -100,10 +100,7 @@ pub fn run(check: bool, verbose: bool) {\n }\n \n fn format_command(program: impl AsRef<OsStr>, dir: impl AsRef<Path>, args: &[impl AsRef<OsStr>]) -> String {\n-    let arg_display: Vec<_> = args\n-        .iter()\n-        .map(|a| escape(a.as_ref().to_string_lossy()).to_owned())\n-        .collect();\n+    let arg_display: Vec<_> = args.iter().map(|a| escape(a.as_ref().to_string_lossy())).collect();\n \n     format!(\n         \"cd {} && {} {}\","}, {"sha": "c5da0af6f4d1018ad97147baa37c38c4ec1af7e8", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -343,7 +343,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n \n             let stats = terminal_stats(&expr);\n             let mut simplified = expr.simplify();\n-            for simple in Bool::Not(Box::new(expr.clone())).simplify() {\n+            for simple in Bool::Not(Box::new(expr)).simplify() {\n                 match simple {\n                     Bool::Not(_) | Bool::True | Bool::False => {},\n                     _ => simplified.push(Bool::Not(Box::new(simple.clone()))),"}, {"sha": "490f47424b1e915b34d09f7a7ed3b38a7f5dffbd", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -27,6 +27,8 @@ extern crate rustc_driver;\n #[allow(unused_extern_crates)]\n extern crate rustc_errors;\n #[allow(unused_extern_crates)]\n+extern crate rustc_index;\n+#[allow(unused_extern_crates)]\n extern crate rustc_mir;\n #[allow(unused_extern_crates)]\n extern crate rustc_target;\n@@ -864,6 +866,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         ranges::RANGE_MINUS_ONE,\n         ranges::RANGE_PLUS_ONE,\n         ranges::RANGE_ZIP_WITH_LEN,\n+        redundant_clone::REDUNDANT_CLONE,\n         redundant_field_names::REDUNDANT_FIELD_NAMES,\n         redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING,\n         redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES,\n@@ -1169,6 +1172,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         methods::SINGLE_CHAR_PATTERN,\n         misc::CMP_OWNED,\n         mutex_atomic::MUTEX_ATOMIC,\n+        redundant_clone::REDUNDANT_CLONE,\n         slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n         trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF,\n         types::BOX_VEC,\n@@ -1188,7 +1192,6 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         mutex_atomic::MUTEX_INTEGER,\n         needless_borrow::NEEDLESS_BORROW,\n         path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE,\n-        redundant_clone::REDUNDANT_CLONE,\n     ]);\n }\n "}, {"sha": "478ca2e04ffb8d5d2b27f5d0ab12c79a85264b11", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 341, "deletions": 82, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -9,12 +9,16 @@ use rustc::hir::{def_id, Body, FnDecl, HirId};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::mir::{\n     self, traversal,\n-    visit::{MutatingUseContext, PlaceContext, Visitor},\n-    TerminatorKind,\n+    visit::{MutatingUseContext, PlaceContext, Visitor as _},\n };\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, fold::TypeVisitor, Ty};\n use rustc::{declare_lint_pass, declare_tool_lint};\n+use rustc_data_structures::{fx::FxHashMap, transitive_relation::TransitiveRelation};\n use rustc_errors::Applicability;\n+use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_mir::dataflow::{\n+    do_dataflow, BitDenotation, BottomValue, DataflowResults, DataflowResultsCursor, DebugFormatted, GenKillSet,\n+};\n use std::convert::TryFrom;\n use syntax::source_map::{BytePos, Span};\n \n@@ -36,17 +40,7 @@ declare_clippy_lint! {\n     ///\n     /// **Known problems:**\n     ///\n-    /// * Suggestions made by this lint could require NLL to be enabled.\n-    /// * False-positive if there is a borrow preventing the value from moving out.\n-    ///\n-    /// ```rust\n-    /// # fn foo(x: String) {}\n-    /// let x = String::new();\n-    ///\n-    /// let y = &x;\n-    ///\n-    /// foo(x.clone()); // This lint suggests to remove this `clone()`\n-    /// ```\n+    /// False-negatives: analysis performed by this lint is conservative and limited.\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -68,7 +62,7 @@ declare_clippy_lint! {\n     /// Path::new(\"/a/b\").join(\"c\").to_path_buf();\n     /// ```\n     pub REDUNDANT_CLONE,\n-    nursery,\n+    perf,\n     \"`clone()` of an owned value that is going to be dropped immediately\"\n }\n \n@@ -88,6 +82,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n         let def_id = cx.tcx.hir().body_owner_def_id(body.id());\n         let mir = cx.tcx.optimized_mir(def_id);\n \n+        let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n+        let maybe_storage_live_result = do_dataflow(\n+            cx.tcx,\n+            mir,\n+            def_id,\n+            &[],\n+            &dead_unwinds,\n+            MaybeStorageLive::new(mir),\n+            |bd, p| DebugFormatted::new(&bd.body.local_decls[p]),\n+        );\n+        let mut possible_borrower = {\n+            let mut vis = PossibleBorrowerVisitor::new(cx, mir);\n+            vis.visit_body(mir);\n+            vis.into_map(cx, maybe_storage_live_result)\n+        };\n+\n         for (bb, bbdata) in mir.basic_blocks().iter_enumerated() {\n             let terminator = bbdata.terminator();\n \n@@ -114,29 +124,35 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n                 continue;\n             }\n \n-            // _1 in MIR `{ _2 = &_1; clone(move _2); }` or `{ _2 = _1; to_path_buf(_2); } (from_deref)\n-            // In case of `from_deref`, `arg` is already a reference since it is `deref`ed in the previous\n-            // block.\n-            let (cloned, cannot_move_out) = unwrap_or_continue!(find_stmt_assigns_to(\n-                cx,\n-                mir,\n-                arg,\n-                from_borrow,\n-                bbdata.statements.iter()\n-            ));\n-\n-            if from_borrow && cannot_move_out {\n-                continue;\n-            }\n+            // `{ cloned = &arg; clone(move cloned); }` or `{ cloned = &arg; to_path_buf(cloned); }`\n+            let (cloned, cannot_move_out) = unwrap_or_continue!(find_stmt_assigns_to(cx, mir, arg, from_borrow, bb));\n+\n+            let loc = mir::Location {\n+                block: bb,\n+                statement_index: bbdata.statements.len(),\n+            };\n+\n+            // Cloned local\n+            let local = if from_borrow {\n+                // `res = clone(arg)` can be turned into `res = move arg;`\n+                // if `arg` is the only borrow of `cloned` at this point.\n+\n+                if cannot_move_out || !possible_borrower.only_borrowers(&[arg], cloned, loc) {\n+                    continue;\n+                }\n+\n+                cloned\n+            } else {\n+                // `arg` is a reference as it is `.deref()`ed in the previous block.\n+                // Look into the predecessor block and find out the source of deref.\n \n-            // _1 in MIR `{ _2 = &_1; _3 = deref(move _2); } -> { _4 = _3; to_path_buf(move _4); }`\n-            let referent = if from_deref {\n                 let ps = mir.predecessors_for(bb);\n                 if ps.len() != 1 {\n                     continue;\n                 }\n                 let pred_terminator = mir[ps[0]].terminator();\n \n+                // receiver of the `deref()` call\n                 let pred_arg = if_chain! {\n                     if let Some((pred_fn_def_id, pred_arg, pred_arg_ty, Some(res))) =\n                         is_call_with_ref_arg(cx, mir, &pred_terminator.kind);\n@@ -151,29 +167,39 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n                     }\n                 };\n \n-                let (local, cannot_move_out) = unwrap_or_continue!(find_stmt_assigns_to(\n-                    cx,\n-                    mir,\n-                    pred_arg,\n-                    true,\n-                    mir[ps[0]].statements.iter()\n-                ));\n-                if cannot_move_out {\n+                let (local, cannot_move_out) =\n+                    unwrap_or_continue!(find_stmt_assigns_to(cx, mir, pred_arg, true, ps[0]));\n+                let loc = mir::Location {\n+                    block: bb,\n+                    statement_index: mir.basic_blocks()[bb].statements.len(),\n+                };\n+\n+                // This can be turned into `res = move local` if `arg` and `cloned` are not borrowed\n+                // at the last statement:\n+                //\n+                // ```\n+                // pred_arg = &local;\n+                // cloned = deref(pred_arg);\n+                // arg = &cloned;\n+                // StorageDead(pred_arg);\n+                // res = to_path_buf(cloned);\n+                // ```\n+                if cannot_move_out || !possible_borrower.only_borrowers(&[arg, cloned], local, loc) {\n                     continue;\n                 }\n+\n                 local\n-            } else {\n-                cloned\n             };\n \n+            // `local` cannot be moved out if it is used later\n             let used_later = traversal::ReversePostorder::new(&mir, bb).skip(1).any(|(tbb, tdata)| {\n                 // Give up on loops\n                 if tdata.terminator().successors().any(|s| *s == bb) {\n                     return true;\n                 }\n \n                 let mut vis = LocalUseVisitor {\n-                    local: referent,\n+                    local,\n                     used_other_than_drop: false,\n                 };\n                 vis.visit_basic_block_data(tbb, tdata);\n@@ -195,13 +221,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n                         let sugg_span = span.with_lo(\n                             span.lo() + BytePos(u32::try_from(dot).unwrap())\n                         );\n+                        let mut app = Applicability::MaybeIncorrect;\n+\n+                        let mut call_snip = &snip[dot + 1..];\n+                        // Machine applicable when `call_snip` looks like `foobar()`\n+                        if call_snip.ends_with(\"()\") {\n+                            call_snip = call_snip[..call_snip.len()-2].trim();\n+                            if call_snip.as_bytes().iter().all(|b| b.is_ascii_alphabetic() || *b == b'_') {\n+                                app = Applicability::MachineApplicable;\n+                            }\n+                        }\n \n                         span_lint_hir_and_then(cx, REDUNDANT_CLONE, node, sugg_span, \"redundant clone\", |db| {\n                             db.span_suggestion(\n                                 sugg_span,\n                                 \"remove this\",\n                                 String::new(),\n-                                Applicability::MaybeIncorrect,\n+                                app,\n                             );\n                             db.span_note(\n                                 span.with_hi(span.lo() + BytePos(u32::try_from(dot).unwrap())),\n@@ -224,7 +260,7 @@ fn is_call_with_ref_arg<'tcx>(\n     kind: &'tcx mir::TerminatorKind<'tcx>,\n ) -> Option<(def_id::DefId, mir::Local, Ty<'tcx>, Option<&'tcx mir::Place<'tcx>>)> {\n     if_chain! {\n-        if let TerminatorKind::Call { func, args, destination, .. } = kind;\n+        if let mir::TerminatorKind::Call { func, args, destination, .. } = kind;\n         if args.len() == 1;\n         if let mir::Operand::Move(mir::Place { base: mir::PlaceBase::Local(local), .. }) = &args[0];\n         if let ty::FnDef(def_id, _) = func.ty(&*mir, cx.tcx).kind;\n@@ -241,42 +277,35 @@ fn is_call_with_ref_arg<'tcx>(\n type CannotMoveOut = bool;\n \n /// Finds the first `to = (&)from`, and returns\n-/// ``Some((from, [`true` if `from` cannot be moved out]))``.\n-fn find_stmt_assigns_to<'a, 'tcx: 'a>(\n+/// ``Some((from, whether `from` cannot be moved out))``.\n+fn find_stmt_assigns_to<'tcx>(\n     cx: &LateContext<'_, 'tcx>,\n     mir: &mir::Body<'tcx>,\n-    to: mir::Local,\n+    to_local: mir::Local,\n     by_ref: bool,\n-    stmts: impl DoubleEndedIterator<Item = &'a mir::Statement<'tcx>>,\n+    bb: mir::BasicBlock,\n ) -> Option<(mir::Local, CannotMoveOut)> {\n-    stmts\n-        .rev()\n-        .find_map(|stmt| {\n-            if let mir::StatementKind::Assign(box (\n-                mir::Place {\n-                    base: mir::PlaceBase::Local(local),\n-                    ..\n-                },\n-                v,\n-            )) = &stmt.kind\n-            {\n-                if *local == to {\n-                    return Some(v);\n-                }\n-            }\n+    let rvalue = mir.basic_blocks()[bb].statements.iter().rev().find_map(|stmt| {\n+        if let mir::StatementKind::Assign(box (\n+            mir::Place {\n+                base: mir::PlaceBase::Local(local),\n+                ..\n+            },\n+            v,\n+        )) = &stmt.kind\n+        {\n+            return if *local == to_local { Some(v) } else { None };\n+        }\n \n-            None\n-        })\n-        .and_then(|v| {\n-            if by_ref {\n-                if let mir::Rvalue::Ref(_, _, ref place) = v {\n-                    return base_local_and_movability(cx, mir, place);\n-                }\n-            } else if let mir::Rvalue::Use(mir::Operand::Copy(ref place)) = v {\n-                return base_local_and_movability(cx, mir, place);\n-            }\n-            None\n-        })\n+        None\n+    })?;\n+\n+    match (by_ref, &*rvalue) {\n+        (true, mir::Rvalue::Ref(_, _, place)) | (false, mir::Rvalue::Use(mir::Operand::Copy(place))) => {\n+            base_local_and_movability(cx, mir, place)\n+        },\n+        _ => None,\n+    }\n }\n \n /// Extracts and returns the undermost base `Local` of given `place`. Returns `place` itself\n@@ -288,8 +317,6 @@ fn base_local_and_movability<'tcx>(\n     mir: &mir::Body<'tcx>,\n     place: &mir::Place<'tcx>,\n ) -> Option<(mir::Local, CannotMoveOut)> {\n-    use rustc::mir::Place;\n-    use rustc::mir::PlaceBase;\n     use rustc::mir::PlaceRef;\n \n     // Dereference. You cannot move things out from a borrowed value.\n@@ -301,13 +328,15 @@ fn base_local_and_movability<'tcx>(\n         base: place_base,\n         mut projection,\n     } = place.as_ref();\n-    if let PlaceBase::Local(local) = place_base {\n+    if let mir::PlaceBase::Local(local) = place_base {\n         while let [base @ .., elem] = projection {\n             projection = base;\n-            deref = matches!(elem, mir::ProjectionElem::Deref);\n-            field = !field\n-                && matches!(elem, mir::ProjectionElem::Field(..))\n-                && has_drop(cx, Place::ty_from(place_base, projection, &mir.local_decls, cx.tcx).ty);\n+            deref |= matches!(elem, mir::ProjectionElem::Deref);\n+            field |= matches!(elem, mir::ProjectionElem::Field(..))\n+                && has_drop(\n+                    cx,\n+                    mir::Place::ty_from(place_base, projection, &mir.local_decls, cx.tcx).ty,\n+                );\n         }\n \n         Some((*local, deref || field))\n@@ -353,3 +382,233 @@ impl<'tcx> mir::visit::Visitor<'tcx> for LocalUseVisitor {\n         }\n     }\n }\n+\n+/// Determines liveness of each local purely based on `StorageLive`/`Dead`.\n+#[derive(Copy, Clone)]\n+struct MaybeStorageLive<'a, 'tcx> {\n+    body: &'a mir::Body<'tcx>,\n+}\n+\n+impl<'a, 'tcx> MaybeStorageLive<'a, 'tcx> {\n+    fn new(body: &'a mir::Body<'tcx>) -> Self {\n+        MaybeStorageLive { body }\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n+    type Idx = mir::Local;\n+    fn name() -> &'static str {\n+        \"maybe_storage_live\"\n+    }\n+    fn bits_per_block(&self) -> usize {\n+        self.body.local_decls.len()\n+    }\n+\n+    fn start_block_effect(&self, on_entry: &mut BitSet<mir::Local>) {\n+        for arg in self.body.args_iter() {\n+            on_entry.insert(arg);\n+        }\n+    }\n+\n+    fn statement_effect(&self, trans: &mut GenKillSet<mir::Local>, loc: mir::Location) {\n+        let stmt = &self.body[loc.block].statements[loc.statement_index];\n+\n+        match stmt.kind {\n+            mir::StatementKind::StorageLive(l) => trans.gen(l),\n+            mir::StatementKind::StorageDead(l) => trans.kill(l),\n+            _ => (),\n+        }\n+    }\n+\n+    fn terminator_effect(&self, _trans: &mut GenKillSet<mir::Local>, _loc: mir::Location) {}\n+\n+    fn propagate_call_return(\n+        &self,\n+        _in_out: &mut BitSet<mir::Local>,\n+        _call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        _dest_place: &mir::Place<'tcx>,\n+    ) {\n+        // Nothing to do when a call returns successfully\n+    }\n+}\n+\n+impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n+    /// bottom = dead\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+/// Collects the possible borrowers of each local.\n+/// For example, `b = &a; c = &a;` will make `b` and (transitively) `c`\n+/// possible borrowers of `a`.\n+struct PossibleBorrowerVisitor<'a, 'tcx> {\n+    possible_borrower: TransitiveRelation<mir::Local>,\n+    body: &'a mir::Body<'tcx>,\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'a, 'tcx>, body: &'a mir::Body<'tcx>) -> Self {\n+        Self {\n+            possible_borrower: TransitiveRelation::default(),\n+            cx,\n+            body,\n+        }\n+    }\n+\n+    fn into_map(\n+        self,\n+        cx: &LateContext<'a, 'tcx>,\n+        maybe_live: DataflowResults<'tcx, MaybeStorageLive<'a, 'tcx>>,\n+    ) -> PossibleBorrower<'a, 'tcx> {\n+        let mut map = FxHashMap::default();\n+        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n+            if is_copy(cx, self.body.local_decls[row].ty) {\n+                continue;\n+            }\n+\n+            let borrowers = self.possible_borrower.reachable_from(&row);\n+            if !borrowers.is_empty() {\n+                let mut bs = HybridBitSet::new_empty(self.body.local_decls.len());\n+                for &c in borrowers {\n+                    if c != mir::Local::from_usize(0) {\n+                        bs.insert(c);\n+                    }\n+                }\n+\n+                if !bs.is_empty() {\n+                    map.insert(row, bs);\n+                }\n+            }\n+        }\n+\n+        let bs = BitSet::new_empty(self.body.local_decls.len());\n+        PossibleBorrower {\n+            map,\n+            maybe_live: DataflowResultsCursor::new(maybe_live, self.body),\n+            bitset: (bs.clone(), bs),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n+    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n+        if let mir::PlaceBase::Local(lhs) = place.base {\n+            match rvalue {\n+                mir::Rvalue::Ref(_, _, borrowed) => {\n+                    if let mir::PlaceBase::Local(borrowed_local) = borrowed.base {\n+                        self.possible_borrower.add(borrowed_local, lhs);\n+                    }\n+                },\n+                other => {\n+                    if !ContainsRegion.visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty) {\n+                        return;\n+                    }\n+                    rvalue_locals(other, |rhs| {\n+                        if lhs != rhs {\n+                            self.possible_borrower.add(rhs, lhs);\n+                        }\n+                    });\n+                },\n+            }\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'_>, _loc: mir::Location) {\n+        if let mir::TerminatorKind::Call {\n+            args,\n+            destination:\n+                Some((\n+                    mir::Place {\n+                        base: mir::PlaceBase::Local(dest),\n+                        ..\n+                    },\n+                    _,\n+                )),\n+            ..\n+        } = &terminator.kind\n+        {\n+            // If the call returns something with lifetimes,\n+            // let's conservatively assume the returned value contains lifetime of all the arguments.\n+            // For example, given `let y: Foo<'a> = foo(x)`, `y` is considered to be a possible borrower of `x`.\n+            if !ContainsRegion.visit_ty(&self.body.local_decls[*dest].ty) {\n+                return;\n+            }\n+\n+            for op in args {\n+                match op {\n+                    mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n+                        if let mir::PlaceBase::Local(arg) = p.base {\n+                            self.possible_borrower.add(arg, *dest);\n+                        }\n+                    },\n+                    _ => (),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct ContainsRegion;\n+\n+impl TypeVisitor<'_> for ContainsRegion {\n+    fn visit_region(&mut self, _: ty::Region<'_>) -> bool {\n+        true\n+    }\n+}\n+\n+fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n+    use rustc::mir::Rvalue::*;\n+\n+    let mut visit_op = |op: &mir::Operand<'_>| match op {\n+        mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n+            if let mir::PlaceBase::Local(l) = p.base {\n+                visit(l)\n+            }\n+        },\n+        _ => (),\n+    };\n+\n+    match rvalue {\n+        Use(op) | Repeat(op, _) | Cast(_, op, _) | UnaryOp(_, op) => visit_op(op),\n+        Aggregate(_, ops) => ops.iter().for_each(visit_op),\n+        BinaryOp(_, lhs, rhs) | CheckedBinaryOp(_, lhs, rhs) => {\n+            visit_op(lhs);\n+            visit_op(rhs);\n+        },\n+        _ => (),\n+    }\n+}\n+\n+/// Result of `PossibleBorrowerVisitor`.\n+struct PossibleBorrower<'a, 'tcx> {\n+    /// Mapping `Local -> its possible borrowers`\n+    map: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+    maybe_live: DataflowResultsCursor<'a, 'tcx, MaybeStorageLive<'a, 'tcx>>,\n+    // Caches to avoid allocation of `BitSet` on every query\n+    bitset: (BitSet<mir::Local>, BitSet<mir::Local>),\n+}\n+\n+impl PossibleBorrower<'_, '_> {\n+    /// Returns true if the set of borrowers of `borrowed` living at `at` matches with `borrowers`.\n+    fn only_borrowers(&mut self, borrowers: &[mir::Local], borrowed: mir::Local, at: mir::Location) -> bool {\n+        self.maybe_live.seek(at);\n+\n+        self.bitset.0.clear();\n+        let maybe_live = &mut self.maybe_live;\n+        if let Some(bitset) = self.map.get(&borrowed) {\n+            for b in bitset.iter().filter(move |b| maybe_live.contains(*b)) {\n+                self.bitset.0.insert(b);\n+            }\n+        } else {\n+            return false;\n+        }\n+\n+        self.bitset.1.clear();\n+        for b in borrowers {\n+            self.bitset.1.insert(*b);\n+        }\n+\n+        self.bitset.0 == self.bitset.1\n+    }\n+}"}, {"sha": "133001e35f77ec0a1fbdba2ea6660f790b48bca2", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -986,6 +986,17 @@ fn check_loss_of_sign(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_fro\n         }\n     }\n \n+    // don't lint for the result of `abs`\n+    // `abs` is an inherent impl of `i{N}`, so a method call with ident `abs` will always\n+    // resolve to that spesific method\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref path, _, _) = op.kind;\n+        if path.ident.name.as_str() == \"abs\";\n+        then {\n+            return\n+        }\n+    }\n+\n     span_lint(\n         cx,\n         CAST_SIGN_LOSS,"}, {"sha": "d56ccdfd08927b6faa31404ac61f1bdc6102293a", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -1542,7 +1542,7 @@ pub const ALL_LINTS: [Lint; 318] = [\n     },\n     Lint {\n         name: \"redundant_clone\",\n-        group: \"nursery\",\n+        group: \"perf\",\n         desc: \"`clone()` of an owned value that is going to be dropped immediately\",\n         deprecation: None,\n         module: \"redundant_clone\","}, {"sha": "e65a4a9a40ac901c6e7c2381a10ddebeb6f22899", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -38,8 +38,7 @@ fn config(mode: &str, dir: PathBuf) -> compiletest::Config {\n \n     let cfg_mode = mode.parse().expect(\"Invalid mode\");\n     if let Ok(name) = var::<&str>(\"TESTNAME\") {\n-        let s: String = name.to_owned();\n-        config.filter = Some(s)\n+        config.filter = Some(name)\n     }\n \n     if rustc_test_suite().is_some() {"}, {"sha": "80329a52c2d0d90dd0e768cbf38351fd1b57f9af", "filename": "tests/ui/cast.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -42,4 +42,9 @@ fn main() {\n     i32::max_value() as u32;\n     i64::max_value() as u64;\n     i128::max_value() as u128;\n+    (-1i8).abs() as u8;\n+    (-1i16).abs() as u16;\n+    (-1i32).abs() as u32;\n+    (-1i64).abs() as u64;\n+    (-1isize).abs() as usize;\n }"}, {"sha": "086548e58ed677b2ca1f85e53c925c956f39f0fc", "filename": "tests/ui/crashes/auxiliary/proc_macro_crash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fcrashes%2Fauxiliary%2Fproc_macro_crash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fcrashes%2Fauxiliary%2Fproc_macro_crash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fauxiliary%2Fproc_macro_crash.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -30,7 +30,7 @@ pub fn macro_test(input_stream: TokenStream) -> TokenStream {\n                 TokenTree::Ident(Ident::new(\"true\", Span::call_site())),\n                 TokenTree::Group(clause.clone()),\n                 TokenTree::Ident(Ident::new(\"else\", Span::call_site())),\n-                TokenTree::Group(clause.clone()),\n+                TokenTree::Group(clause),\n             ])\n         })),\n     ])"}, {"sha": "d435484d3e3d3f1a5e8cb864d17a7385f3548e6d", "filename": "tests/ui/escape_analysis.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fescape_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fescape_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -1,5 +1,10 @@\n #![feature(box_syntax)]\n-#![allow(clippy::borrowed_box, clippy::needless_pass_by_value, clippy::unused_unit)]\n+#![allow(\n+    clippy::borrowed_box,\n+    clippy::needless_pass_by_value,\n+    clippy::unused_unit,\n+    clippy::redundant_clone\n+)]\n #![warn(clippy::boxed_local)]\n \n #[derive(Clone)]"}, {"sha": "73fa9bfe19b5e4a2a6633372efa5dd23287a0e7b", "filename": "tests/ui/escape_analysis.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fescape_analysis.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fescape_analysis.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.stderr?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -1,19 +1,19 @@\n error: local variable doesn't need to be boxed here\n-  --> $DIR/escape_analysis.rs:34:13\n+  --> $DIR/escape_analysis.rs:39:13\n    |\n LL | fn warn_arg(x: Box<A>) {\n    |             ^\n    |\n    = note: `-D clippy::boxed-local` implied by `-D warnings`\n \n error: local variable doesn't need to be boxed here\n-  --> $DIR/escape_analysis.rs:125:12\n+  --> $DIR/escape_analysis.rs:130:12\n    |\n LL | pub fn new(_needs_name: Box<PeekableSeekable<&()>>) -> () {}\n    |            ^^^^^^^^^^^\n \n error: local variable doesn't need to be boxed here\n-  --> $DIR/escape_analysis.rs:165:23\n+  --> $DIR/escape_analysis.rs:170:23\n    |\n LL |     fn closure_borrow(x: Box<A>) {\n    |                       ^"}, {"sha": "2029c81d0d5aa7b9f40d267da2de7cfd0e5e832c", "filename": "tests/ui/map_clone.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fmap_clone.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fmap_clone.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.fixed?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n #![warn(clippy::all, clippy::pedantic)]\n #![allow(clippy::iter_cloned_collect)]\n-#![allow(clippy::clone_on_copy)]\n+#![allow(clippy::clone_on_copy, clippy::redundant_clone)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::redundant_closure_for_method_calls)]\n "}, {"sha": "495c18f311f5cc2a59a5e87431995b786f02ea88", "filename": "tests/ui/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n #![warn(clippy::all, clippy::pedantic)]\n #![allow(clippy::iter_cloned_collect)]\n-#![allow(clippy::clone_on_copy)]\n+#![allow(clippy::clone_on_copy, clippy::redundant_clone)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::redundant_closure_for_method_calls)]\n "}, {"sha": "ca94daa24e84bdbb3c4e84e52811cfb49367fdd9", "filename": "tests/ui/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -4,7 +4,8 @@\n     clippy::single_match,\n     clippy::redundant_pattern_matching,\n     clippy::many_single_char_names,\n-    clippy::option_option\n+    clippy::option_option,\n+    clippy::redundant_clone\n )]\n \n use std::borrow::Borrow;"}, {"sha": "5efeea0685c64e5e061a7eff21892d56f08fcef9", "filename": "tests/ui/needless_pass_by_value.stderr", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fneedless_pass_by_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fneedless_pass_by_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.stderr?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -1,31 +1,31 @@\n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:16:23\n+  --> $DIR/needless_pass_by_value.rs:17:23\n    |\n LL | fn foo<T: Default>(v: Vec<T>, w: Vec<T>, mut x: Vec<T>, y: Vec<T>) -> Vec<T> {\n    |                       ^^^^^^ help: consider changing the type to: `&[T]`\n    |\n    = note: `-D clippy::needless-pass-by-value` implied by `-D warnings`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:30:11\n+  --> $DIR/needless_pass_by_value.rs:31:11\n    |\n LL | fn bar(x: String, y: Wrapper) {\n    |           ^^^^^^ help: consider changing the type to: `&str`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:30:22\n+  --> $DIR/needless_pass_by_value.rs:31:22\n    |\n LL | fn bar(x: String, y: Wrapper) {\n    |                      ^^^^^^^ help: consider taking a reference instead: `&Wrapper`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:36:71\n+  --> $DIR/needless_pass_by_value.rs:37:71\n    |\n LL | fn test_borrow_trait<T: Borrow<str>, U: AsRef<str>, V>(t: T, u: U, v: V) {\n    |                                                                       ^ help: consider taking a reference instead: `&V`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:48:18\n+  --> $DIR/needless_pass_by_value.rs:49:18\n    |\n LL | fn test_match(x: Option<Option<String>>, y: Option<Option<String>>) {\n    |                  ^^^^^^^^^^^^^^^^^^^^^^\n@@ -36,13 +36,13 @@ LL |     match *x {\n    |\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:61:24\n+  --> $DIR/needless_pass_by_value.rs:62:24\n    |\n LL | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n    |                        ^^^^^^^ help: consider taking a reference instead: `&Wrapper`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:61:36\n+  --> $DIR/needless_pass_by_value.rs:62:36\n    |\n LL | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n    |                                    ^^^^^^^\n@@ -55,19 +55,19 @@ LL |     let Wrapper(_) = *y; // still not moved\n    |\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:77:49\n+  --> $DIR/needless_pass_by_value.rs:78:49\n    |\n LL | fn test_blanket_ref<T: Foo, S: Serialize>(_foo: T, _serializable: S) {}\n    |                                                 ^ help: consider taking a reference instead: `&T`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:79:18\n+  --> $DIR/needless_pass_by_value.rs:80:18\n    |\n LL | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n    |                  ^^^^^^ help: consider taking a reference instead: `&String`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:79:29\n+  --> $DIR/needless_pass_by_value.rs:80:29\n    |\n LL | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n    |                             ^^^^^^\n@@ -81,13 +81,13 @@ LL |     let _ = t.to_string();\n    |             ^^^^^^^^^^^^^\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:79:40\n+  --> $DIR/needless_pass_by_value.rs:80:40\n    |\n LL | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n    |                                        ^^^^^^^^ help: consider taking a reference instead: `&Vec<i32>`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:79:53\n+  --> $DIR/needless_pass_by_value.rs:80:53\n    |\n LL | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n    |                                                     ^^^^^^^^\n@@ -101,61 +101,61 @@ LL |     let _ = v.to_owned();\n    |             ^^^^^^^^^^^^\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:92:12\n+  --> $DIR/needless_pass_by_value.rs:93:12\n    |\n LL |         s: String,\n    |            ^^^^^^ help: consider changing the type to: `&str`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:93:12\n+  --> $DIR/needless_pass_by_value.rs:94:12\n    |\n LL |         t: String,\n    |            ^^^^^^ help: consider taking a reference instead: `&String`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:102:23\n+  --> $DIR/needless_pass_by_value.rs:103:23\n    |\n LL |     fn baz(&self, _u: U, _s: Self) {}\n    |                       ^ help: consider taking a reference instead: `&U`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:102:30\n+  --> $DIR/needless_pass_by_value.rs:103:30\n    |\n LL |     fn baz(&self, _u: U, _s: Self) {}\n    |                              ^^^^ help: consider taking a reference instead: `&Self`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:124:24\n+  --> $DIR/needless_pass_by_value.rs:125:24\n    |\n LL | fn bar_copy(x: u32, y: CopyWrapper) {\n    |                        ^^^^^^^^^^^ help: consider taking a reference instead: `&CopyWrapper`\n    |\n help: consider marking this type as Copy\n-  --> $DIR/needless_pass_by_value.rs:122:1\n+  --> $DIR/needless_pass_by_value.rs:123:1\n    |\n LL | struct CopyWrapper(u32);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:130:29\n+  --> $DIR/needless_pass_by_value.rs:131:29\n    |\n LL | fn test_destructure_copy(x: CopyWrapper, y: CopyWrapper, z: CopyWrapper) {\n    |                             ^^^^^^^^^^^ help: consider taking a reference instead: `&CopyWrapper`\n    |\n help: consider marking this type as Copy\n-  --> $DIR/needless_pass_by_value.rs:122:1\n+  --> $DIR/needless_pass_by_value.rs:123:1\n    |\n LL | struct CopyWrapper(u32);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:130:45\n+  --> $DIR/needless_pass_by_value.rs:131:45\n    |\n LL | fn test_destructure_copy(x: CopyWrapper, y: CopyWrapper, z: CopyWrapper) {\n    |                                             ^^^^^^^^^^^\n    |\n help: consider marking this type as Copy\n-  --> $DIR/needless_pass_by_value.rs:122:1\n+  --> $DIR/needless_pass_by_value.rs:123:1\n    |\n LL | struct CopyWrapper(u32);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -168,13 +168,13 @@ LL |     let CopyWrapper(_) = *y; // still not moved\n    |\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:130:61\n+  --> $DIR/needless_pass_by_value.rs:131:61\n    |\n LL | fn test_destructure_copy(x: CopyWrapper, y: CopyWrapper, z: CopyWrapper) {\n    |                                                             ^^^^^^^^^^^\n    |\n help: consider marking this type as Copy\n-  --> $DIR/needless_pass_by_value.rs:122:1\n+  --> $DIR/needless_pass_by_value.rs:123:1\n    |\n LL | struct CopyWrapper(u32);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -185,13 +185,13 @@ LL |     let CopyWrapper(s) = *z; // moved\n    |\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:142:40\n+  --> $DIR/needless_pass_by_value.rs:143:40\n    |\n LL | fn some_fun<'b, S: Bar<'b, ()>>(_item: S) {}\n    |                                        ^ help: consider taking a reference instead: `&S`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:147:20\n+  --> $DIR/needless_pass_by_value.rs:148:20\n    |\n LL | fn more_fun(_item: impl Club<'static, i32>) {}\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^ help: consider taking a reference instead: `&impl Club<'static, i32>`"}, {"sha": "30f39e9b06398519302fc7a870da680f0fe5806b", "filename": "tests/ui/ptr_arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -1,4 +1,4 @@\n-#![allow(unused, clippy::many_single_char_names)]\n+#![allow(unused, clippy::many_single_char_names, clippy::redundant_clone)]\n #![warn(clippy::ptr_arg)]\n \n use std::borrow::Cow;"}, {"sha": "57237c52e8c9a4f628a6a0753cd3eb0619842495", "filename": "tests/ui/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -104,7 +104,7 @@ fn main() {\n     };\n     move_struct.ref_func();\n     move_struct.clone().mov_func_reuse();\n-    move_struct.clone().mov_func_no_use();\n+    move_struct.mov_func_no_use();\n \n     let so = SeemsOption::Some(45);\n     returns_something_similar_to_option(so);"}, {"sha": "614a9bf4d90028074a74bdfa4c3f94f0ac844bce", "filename": "tests/ui/redundant_clone.fixed", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fredundant_clone.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fredundant_clone.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.fixed?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -0,0 +1,132 @@\n+// run-rustfix\n+// rustfix-only-machine-applicable\n+use std::ffi::OsString;\n+use std::path::Path;\n+\n+fn main() {\n+    let _s = [\"lorem\", \"ipsum\"].join(\" \");\n+\n+    let s = String::from(\"foo\");\n+    let _s = s;\n+\n+    let s = String::from(\"foo\");\n+    let _s = s;\n+\n+    let s = String::from(\"foo\");\n+    let _s = s;\n+\n+    let _s = Path::new(\"/a/b/\").join(\"c\");\n+\n+    let _s = Path::new(\"/a/b/\").join(\"c\");\n+\n+    let _s = OsString::new();\n+\n+    let _s = OsString::new();\n+\n+    // Check that lint level works\n+    #[allow(clippy::redundant_clone)]\n+    let _s = String::new().to_string();\n+\n+    let tup = (String::from(\"foo\"),);\n+    let _t = tup.0;\n+\n+    let tup_ref = &(String::from(\"foo\"),);\n+    let _s = tup_ref.0.clone(); // this `.clone()` cannot be removed\n+\n+    {\n+        let x = String::new();\n+        let y = &x;\n+\n+        let _x = x.clone(); // ok; `x` is borrowed by `y`\n+\n+        let _ = y.len();\n+    }\n+\n+    let x = (String::new(),);\n+    let _ = Some(String::new()).unwrap_or_else(|| x.0.clone()); // ok; closure borrows `x`\n+\n+    with_branch(Alpha, true);\n+    cannot_move_from_type_with_drop();\n+    borrower_propagation();\n+}\n+\n+#[derive(Clone)]\n+struct Alpha;\n+fn with_branch(a: Alpha, b: bool) -> (Alpha, Alpha) {\n+    if b {\n+        (a.clone(), a)\n+    } else {\n+        (Alpha, a)\n+    }\n+}\n+\n+struct TypeWithDrop {\n+    x: String,\n+}\n+\n+impl Drop for TypeWithDrop {\n+    fn drop(&mut self) {}\n+}\n+\n+fn cannot_move_from_type_with_drop() -> String {\n+    let s = TypeWithDrop { x: String::new() };\n+    s.x.clone() // removing this `clone()` summons E0509\n+}\n+\n+fn borrower_propagation() {\n+    let s = String::new();\n+    let t = String::new();\n+\n+    {\n+        fn b() -> bool {\n+            unimplemented!()\n+        }\n+        let _u = if b() { &s } else { &t };\n+\n+        // ok; `s` and `t` are possibly borrowed\n+        let _s = s.clone();\n+        let _t = t.clone();\n+    }\n+\n+    {\n+        let _u = || s.len();\n+        let _v = [&t; 32];\n+        let _s = s.clone(); // ok\n+        let _t = t.clone(); // ok\n+    }\n+\n+    {\n+        let _u = {\n+            let u = Some(&s);\n+            let _ = s.clone(); // ok\n+            u\n+        };\n+        let _s = s.clone(); // ok\n+    }\n+\n+    {\n+        use std::convert::identity as id;\n+        let _u = id(id(&s));\n+        let _s = s.clone(); // ok, `u` borrows `s`\n+    }\n+\n+    let _s = s;\n+    let _t = t;\n+\n+    #[derive(Clone)]\n+    struct Foo {\n+        x: usize,\n+    }\n+\n+    {\n+        let f = Foo { x: 123 };\n+        let _x = Some(f.x);\n+        let _f = f;\n+    }\n+\n+    {\n+        let f = Foo { x: 123 };\n+        let _x = &f.x;\n+        let _f = f.clone(); // ok\n+    }\n+}"}, {"sha": "48687c82c2fbb08841af746aac7c36591b5f5658", "filename": "tests/ui/redundant_clone.rs", "status": "modified", "additions": 86, "deletions": 12, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -1,37 +1,53 @@\n-#![warn(clippy::redundant_clone)]\n-\n+// run-rustfix\n+// rustfix-only-machine-applicable\n use std::ffi::OsString;\n use std::path::Path;\n \n fn main() {\n-    let _ = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n+    let _s = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n \n     let s = String::from(\"foo\");\n-    let _ = s.clone();\n+    let _s = s.clone();\n \n     let s = String::from(\"foo\");\n-    let _ = s.to_string();\n+    let _s = s.to_string();\n \n     let s = String::from(\"foo\");\n-    let _ = s.to_owned();\n+    let _s = s.to_owned();\n \n-    let _ = Path::new(\"/a/b/\").join(\"c\").to_owned();\n+    let _s = Path::new(\"/a/b/\").join(\"c\").to_owned();\n \n-    let _ = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n+    let _s = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n \n-    let _ = OsString::new().to_owned();\n+    let _s = OsString::new().to_owned();\n \n-    let _ = OsString::new().to_os_string();\n+    let _s = OsString::new().to_os_string();\n \n     // Check that lint level works\n     #[allow(clippy::redundant_clone)]\n-    let _ = String::new().to_string();\n+    let _s = String::new().to_string();\n \n     let tup = (String::from(\"foo\"),);\n-    let _ = tup.0.clone();\n+    let _t = tup.0.clone();\n \n     let tup_ref = &(String::from(\"foo\"),);\n     let _s = tup_ref.0.clone(); // this `.clone()` cannot be removed\n+\n+    {\n+        let x = String::new();\n+        let y = &x;\n+\n+        let _x = x.clone(); // ok; `x` is borrowed by `y`\n+\n+        let _ = y.len();\n+    }\n+\n+    let x = (String::new(),);\n+    let _ = Some(String::new()).unwrap_or_else(|| x.0.clone()); // ok; closure borrows `x`\n+\n+    with_branch(Alpha, true);\n+    cannot_move_from_type_with_drop();\n+    borrower_propagation();\n }\n \n #[derive(Clone)]\n@@ -56,3 +72,61 @@ fn cannot_move_from_type_with_drop() -> String {\n     let s = TypeWithDrop { x: String::new() };\n     s.x.clone() // removing this `clone()` summons E0509\n }\n+\n+fn borrower_propagation() {\n+    let s = String::new();\n+    let t = String::new();\n+\n+    {\n+        fn b() -> bool {\n+            unimplemented!()\n+        }\n+        let _u = if b() { &s } else { &t };\n+\n+        // ok; `s` and `t` are possibly borrowed\n+        let _s = s.clone();\n+        let _t = t.clone();\n+    }\n+\n+    {\n+        let _u = || s.len();\n+        let _v = [&t; 32];\n+        let _s = s.clone(); // ok\n+        let _t = t.clone(); // ok\n+    }\n+\n+    {\n+        let _u = {\n+            let u = Some(&s);\n+            let _ = s.clone(); // ok\n+            u\n+        };\n+        let _s = s.clone(); // ok\n+    }\n+\n+    {\n+        use std::convert::identity as id;\n+        let _u = id(id(&s));\n+        let _s = s.clone(); // ok, `u` borrows `s`\n+    }\n+\n+    let _s = s.clone();\n+    let _t = t.clone();\n+\n+    #[derive(Clone)]\n+    struct Foo {\n+        x: usize,\n+    }\n+\n+    {\n+        let f = Foo { x: 123 };\n+        let _x = Some(f.x);\n+        let _f = f.clone();\n+    }\n+\n+    {\n+        let f = Foo { x: 123 };\n+        let _x = &f.x;\n+        let _f = f.clone(); // ok\n+    }\n+}"}, {"sha": "feafbd78b4eafc7a9ecda691313dba5ebd2e7ab8", "filename": "tests/ui/redundant_clone.stderr", "status": "modified", "additions": 93, "deletions": 57, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fredundant_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fredundant_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.stderr?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -1,123 +1,159 @@\n error: redundant clone\n-  --> $DIR/redundant_clone.rs:7:41\n+  --> $DIR/redundant_clone.rs:7:42\n    |\n-LL |     let _ = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n-   |                                         ^^^^^^^^^^^^ help: remove this\n+LL |     let _s = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n+   |                                          ^^^^^^^^^^^^ help: remove this\n    |\n    = note: `-D clippy::redundant-clone` implied by `-D warnings`\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:7:13\n+  --> $DIR/redundant_clone.rs:7:14\n    |\n-LL |     let _ = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _s = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:10:14\n+  --> $DIR/redundant_clone.rs:10:15\n    |\n-LL |     let _ = s.clone();\n-   |              ^^^^^^^^ help: remove this\n+LL |     let _s = s.clone();\n+   |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:10:13\n+  --> $DIR/redundant_clone.rs:10:14\n    |\n-LL |     let _ = s.clone();\n-   |             ^\n+LL |     let _s = s.clone();\n+   |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:13:14\n+  --> $DIR/redundant_clone.rs:13:15\n    |\n-LL |     let _ = s.to_string();\n-   |              ^^^^^^^^^^^^ help: remove this\n+LL |     let _s = s.to_string();\n+   |               ^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:13:13\n+  --> $DIR/redundant_clone.rs:13:14\n    |\n-LL |     let _ = s.to_string();\n-   |             ^\n+LL |     let _s = s.to_string();\n+   |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:16:14\n+  --> $DIR/redundant_clone.rs:16:15\n    |\n-LL |     let _ = s.to_owned();\n-   |              ^^^^^^^^^^^ help: remove this\n+LL |     let _s = s.to_owned();\n+   |               ^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:16:13\n+  --> $DIR/redundant_clone.rs:16:14\n    |\n-LL |     let _ = s.to_owned();\n-   |             ^\n+LL |     let _s = s.to_owned();\n+   |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:18:41\n+  --> $DIR/redundant_clone.rs:18:42\n    |\n-LL |     let _ = Path::new(\"/a/b/\").join(\"c\").to_owned();\n-   |                                         ^^^^^^^^^^^ help: remove this\n+LL |     let _s = Path::new(\"/a/b/\").join(\"c\").to_owned();\n+   |                                          ^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:18:13\n+  --> $DIR/redundant_clone.rs:18:14\n    |\n-LL |     let _ = Path::new(\"/a/b/\").join(\"c\").to_owned();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _s = Path::new(\"/a/b/\").join(\"c\").to_owned();\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:20:41\n+  --> $DIR/redundant_clone.rs:20:42\n    |\n-LL |     let _ = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n-   |                                         ^^^^^^^^^^^^^^ help: remove this\n+LL |     let _s = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n+   |                                          ^^^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:20:13\n+  --> $DIR/redundant_clone.rs:20:14\n    |\n-LL |     let _ = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _s = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:22:28\n+  --> $DIR/redundant_clone.rs:22:29\n    |\n-LL |     let _ = OsString::new().to_owned();\n-   |                            ^^^^^^^^^^^ help: remove this\n+LL |     let _s = OsString::new().to_owned();\n+   |                             ^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:22:13\n+  --> $DIR/redundant_clone.rs:22:14\n    |\n-LL |     let _ = OsString::new().to_owned();\n-   |             ^^^^^^^^^^^^^^^\n+LL |     let _s = OsString::new().to_owned();\n+   |              ^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:24:28\n+  --> $DIR/redundant_clone.rs:24:29\n    |\n-LL |     let _ = OsString::new().to_os_string();\n-   |                            ^^^^^^^^^^^^^^^ help: remove this\n+LL |     let _s = OsString::new().to_os_string();\n+   |                             ^^^^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:24:13\n+  --> $DIR/redundant_clone.rs:24:14\n    |\n-LL |     let _ = OsString::new().to_os_string();\n-   |             ^^^^^^^^^^^^^^^\n+LL |     let _s = OsString::new().to_os_string();\n+   |              ^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:31:18\n+  --> $DIR/redundant_clone.rs:31:19\n    |\n-LL |     let _ = tup.0.clone();\n-   |                  ^^^^^^^^ help: remove this\n+LL |     let _t = tup.0.clone();\n+   |                   ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:31:13\n+  --> $DIR/redundant_clone.rs:31:14\n    |\n-LL |     let _ = tup.0.clone();\n-   |             ^^^^^\n+LL |     let _t = tup.0.clone();\n+   |              ^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:41:22\n+  --> $DIR/redundant_clone.rs:57:22\n    |\n LL |         (a.clone(), a.clone())\n    |                      ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:41:21\n+  --> $DIR/redundant_clone.rs:57:21\n    |\n LL |         (a.clone(), a.clone())\n    |                     ^\n \n-error: aborting due to 10 previous errors\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:113:15\n+   |\n+LL |     let _s = s.clone();\n+   |               ^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:113:14\n+   |\n+LL |     let _s = s.clone();\n+   |              ^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:114:15\n+   |\n+LL |     let _t = t.clone();\n+   |               ^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:114:14\n+   |\n+LL |     let _t = t.clone();\n+   |              ^\n+\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:124:19\n+   |\n+LL |         let _f = f.clone();\n+   |                   ^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:124:18\n+   |\n+LL |         let _f = f.clone();\n+   |                  ^\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "b508c1ee0096479d62100acd4bfac92baed1528b", "filename": "tests/ui/swap.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -1,5 +1,11 @@\n #![warn(clippy::all)]\n-#![allow(clippy::blacklisted_name, clippy::no_effect, redundant_semicolon, unused_assignments)]\n+#![allow(\n+    clippy::blacklisted_name,\n+    clippy::no_effect,\n+    clippy::redundant_clone,\n+    redundant_semicolon,\n+    unused_assignments\n+)]\n \n struct Foo(u32);\n "}, {"sha": "b45187b5805015cc39c70a97dee9a613abf390a5", "filename": "tests/ui/swap.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fswap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Fswap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.stderr?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -1,5 +1,5 @@\n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:27:5\n+  --> $DIR/swap.rs:33:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n@@ -9,23 +9,23 @@ LL | |     foo[1] = temp;\n    = note: `-D clippy::manual-swap` implied by `-D warnings`\n \n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:36:5\n+  --> $DIR/swap.rs:42:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n \n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:45:5\n+  --> $DIR/swap.rs:51:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n \n error: this looks like you are swapping `a` and `b` manually\n-  --> $DIR/swap.rs:65:7\n+  --> $DIR/swap.rs:71:7\n    |\n LL |       ; let t = a;\n    |  _______^\n@@ -36,7 +36,7 @@ LL | |     b = t;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are swapping `c.0` and `a` manually\n-  --> $DIR/swap.rs:74:7\n+  --> $DIR/swap.rs:80:7\n    |\n LL |       ; let t = c.0;\n    |  _______^\n@@ -47,7 +47,7 @@ LL | |     a = t;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are trying to swap `a` and `b`\n-  --> $DIR/swap.rs:62:5\n+  --> $DIR/swap.rs:68:5\n    |\n LL | /     a = b;\n LL | |     b = a;\n@@ -57,7 +57,7 @@ LL | |     b = a;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are trying to swap `c.0` and `a`\n-  --> $DIR/swap.rs:71:5\n+  --> $DIR/swap.rs:77:5\n    |\n LL | /     c.0 = a;\n LL | |     a = c.0;"}, {"sha": "6dff8d87bae0df29acfe224711372217a6193176", "filename": "tests/ui/unnecessary_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Funnecessary_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249b6cac3e60ac4ac50dcf33460c905e2364630c/tests%2Fui%2Funnecessary_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_clone.rs?ref=249b6cac3e60ac4ac50dcf33460c905e2364630c", "patch": "@@ -1,7 +1,7 @@\n // does not test any rustfixable lints\n \n #![warn(clippy::clone_on_ref_ptr)]\n-#![allow(unused)]\n+#![allow(unused, clippy::redundant_clone)]\n \n use std::cell::RefCell;\n use std::rc::{self, Rc};"}]}