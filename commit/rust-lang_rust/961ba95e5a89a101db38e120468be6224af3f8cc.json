{"sha": "961ba95e5a89a101db38e120468be6224af3f8cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MWJhOTVlNWE4OWExMDFkYjM4ZTEyMDQ2OGJlNjIyNGFmM2Y4Y2M=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-04-13T00:03:03Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-04-25T17:28:09Z"}, "message": "Describe generator variants in debuginfo", "tree": {"sha": "368a9427430a04175756cf71bdcbb133207936ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/368a9427430a04175756cf71bdcbb133207936ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/961ba95e5a89a101db38e120468be6224af3f8cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/961ba95e5a89a101db38e120468be6224af3f8cc", "html_url": "https://github.com/rust-lang/rust/commit/961ba95e5a89a101db38e120468be6224af3f8cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/961ba95e5a89a101db38e120468be6224af3f8cc/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "html_url": "https://github.com/rust-lang/rust/commit/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b"}], "stats": {"total": 385, "additions": 288, "deletions": 97}, "files": [{"sha": "af447fc8a489649f2276e98fe824886b37d0aea3", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/961ba95e5a89a101db38e120468be6224af3f8cc/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba95e5a89a101db38e120468be6224af3f8cc/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=961ba95e5a89a101db38e120468be6224af3f8cc", "patch": "@@ -11,6 +11,7 @@ use rustc_macros::HashStable;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef, Kind, UnpackedKind};\n use crate::ty::{self, AdtDef, DefIdTree, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{List, TyS, ParamEnvAnd, ParamEnv};\n+use crate::ty::layout::VariantIdx;\n use crate::util::captures::Captures;\n use crate::mir::interpret::{Scalar, Pointer};\n \n@@ -466,7 +467,44 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n+    /// Generator have not been resumed yet\n+    pub const UNRESUMED: usize = 0;\n+    /// Generator has returned / is completed\n+    pub const RETURNED: usize = 1;\n+    /// Generator has been poisoned\n+    pub const POISONED: usize = 2;\n+\n+    const UNRESUMED_NAME: &'static str = \"Unresumed\";\n+    const RETURNED_NAME: &'static str = \"Returned\";\n+    const POISONED_NAME: &'static str = \"Panicked\";\n+\n+    /// The variants of this Generator.\n+    #[inline]\n+    pub fn variants(&self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n+        impl Iterator<Item = VariantIdx>\n+    {\n+        // FIXME requires optimized MIR\n+        let num_variants = self.state_tys(def_id, tcx).count();\n+        (0..num_variants).map(VariantIdx::new)\n+    }\n+\n+    /// Calls `f` with a reference to the name of the enumerator for the given\n+    /// variant `v`.\n+    #[inline]\n+    pub fn map_variant_name<R>(&self, v: VariantIdx, f: impl FnOnce(&str) -> R) -> R {\n+        let name = match v.as_usize() {\n+            Self::UNRESUMED => Self::UNRESUMED_NAME,\n+            Self::RETURNED => Self::RETURNED_NAME,\n+            Self::POISONED => Self::POISONED_NAME,\n+            _ => {\n+                return f(&format!(\"variant#{}\", v.as_usize()));\n+            }\n+        };\n+        f(name)\n+    }\n+\n     /// The type of the state \"discriminant\" used in the generator type.\n+    #[inline]\n     pub fn discr_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         tcx.types.u32\n     }\n@@ -477,6 +515,7 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     ///\n     /// The locals are grouped by their variant number. Note that some locals may\n     /// be repeated in multiple variants.\n+    #[inline]\n     pub fn state_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n         impl Iterator<Item=impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a>\n     {\n@@ -487,6 +526,7 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n \n     /// This is the types of the fields of a generator which are not stored in a\n     /// variant.\n+    #[inline]\n     pub fn prefix_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n         impl Iterator<Item=Ty<'tcx>> + 'a\n     {"}, {"sha": "0b1ac1ad788660e66c2e1cd66870ed1642d684bd", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 176, "deletions": 94, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/961ba95e5a89a101db38e120468be6224af3f8cc/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba95e5a89a101db38e120468be6224af3f8cc/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=961ba95e5a89a101db38e120468be6224af3f8cc", "patch": "@@ -28,7 +28,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::ty::Instance;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, Integer, IntegerExt, LayoutOf,\n-                        PrimitiveExt, Size, TyLayout};\n+                        PrimitiveExt, Size, TyLayout, VariantIdx};\n use rustc::ty::subst::UnpackedKind;\n use rustc::session::config;\n use rustc::util::nodemap::FxHashMap;\n@@ -691,17 +691,15 @@ pub fn type_metadata(\n                                    usage_site_span).finalize(cx)\n         }\n         ty::Generator(def_id, substs,  _) => {\n-            // TODO handle variant fields\n             let upvar_tys : Vec<_> = substs.prefix_tys(def_id, cx.tcx).map(|t| {\n                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t)\n             }).collect();\n-            // TODO use prepare_enum_metadata and update it to handle multiple\n-            // fields in the outer layout.\n-            prepare_tuple_metadata(cx,\n-                                   t,\n-                                   &upvar_tys,\n-                                   unique_type_id,\n-                                   usage_site_span).finalize(cx)\n+            prepare_enum_metadata(cx,\n+                                  t,\n+                                  def_id,\n+                                  unique_type_id,\n+                                  usage_site_span,\n+                                  upvar_tys).finalize(cx)\n         }\n         ty::Adt(def, ..) => match def.adt_kind() {\n             AdtKind::Struct => {\n@@ -721,7 +719,8 @@ pub fn type_metadata(\n                                       t,\n                                       def.did,\n                                       unique_type_id,\n-                                      usage_site_span).finalize(cx)\n+                                      usage_site_span,\n+                                      vec![]).finalize(cx)\n             }\n         },\n         ty::Tuple(ref elements) => {\n@@ -998,6 +997,31 @@ struct MemberDescription<'ll> {\n     discriminant: Option<u64>,\n }\n \n+impl<'ll> MemberDescription<'ll> {\n+    fn into_metadata(self,\n+                     cx: &CodegenCx<'ll, '_>,\n+                     composite_type_metadata: &'ll DIScope) -> &'ll DIType {\n+        let member_name = CString::new(self.name).unwrap();\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateVariantMemberType(\n+                DIB(cx),\n+                composite_type_metadata,\n+                member_name.as_ptr(),\n+                unknown_file_metadata(cx),\n+                UNKNOWN_LINE_NUMBER,\n+                self.size.bits(),\n+                self.align.bits() as u32,\n+                self.offset.bits(),\n+                match self.discriminant {\n+                    None => None,\n+                    Some(value) => Some(cx.const_u64(value)),\n+                },\n+                self.flags,\n+                self.type_metadata)\n+        }\n+    }\n+}\n+\n // A factory for MemberDescriptions. It produces a list of member descriptions\n // for some record-like type. MemberDescriptionFactories are used to defer the\n // creation of type member descriptions in order to break cycles arising from\n@@ -1264,7 +1288,13 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n                                   -> Vec<MemberDescription<'ll>> {\n-        let adt = &self.enum_type.ty_adt_def().unwrap();\n+        let variant_info_for = |index: VariantIdx| {\n+            match &self.enum_type.sty {\n+                ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index]),\n+                ty::Generator(_, substs, _) => VariantInfo::Generator(*substs, index),\n+                _ => bug!(),\n+            }\n+        };\n \n         // This will always find the metadata in the type map.\n         let fallback = use_enum_fallback(cx);\n@@ -1275,12 +1305,18 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n         };\n \n         match self.layout.variants {\n-            layout::Variants::Single { .. } if adt.variants.is_empty() => vec![],\n             layout::Variants::Single { index } => {\n+                if let ty::Adt(adt, _) = &self.enum_type.sty {\n+                    if adt.variants.is_empty() {\n+                        return vec![];\n+                    }\n+                }\n+\n+                let variant_info = variant_info_for(index);\n                 let (variant_type_metadata, member_description_factory) =\n                     describe_enum_variant(cx,\n                                           self.layout,\n-                                          &adt.variants[index],\n+                                          variant_info,\n                                           NoDiscriminant,\n                                           self_metadata,\n                                           self.span);\n@@ -1297,7 +1333,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         name: if fallback {\n                             String::new()\n                         } else {\n-                            adt.variants[index].ident.as_str().to_string()\n+                            variant_info.name_as_string()\n                         },\n                         type_metadata: variant_type_metadata,\n                         offset: Size::ZERO,\n@@ -1325,10 +1361,11 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 };\n                 variants.iter_enumerated().map(|(i, _)| {\n                     let variant = self.layout.for_variant(cx, i);\n+                    let variant_info = variant_info_for(i);\n                     let (variant_type_metadata, member_desc_factory) =\n                         describe_enum_variant(cx,\n                                               variant,\n-                                              &adt.variants[i],\n+                                              variant_info,\n                                               discriminant_info,\n                                               self_metadata,\n                                               self.span);\n@@ -1340,20 +1377,25 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                                   self.enum_type,\n                                                   variant_type_metadata,\n                                                   member_descriptions);\n+\n+                    // TODO make this into a helper\n+                    let discriminant = match &self.layout.ty.sty {\n+                        ty::Adt(adt, _) => adt.discriminant_for_variant(cx.tcx, i).val as u64,\n+                        ty::Generator(..) => i.as_usize() as u64,\n+                        _ => bug!(),\n+                    }.into();\n                     MemberDescription {\n                         name: if fallback {\n                             String::new()\n                         } else {\n-                            adt.variants[i].ident.as_str().to_string()\n+                            variant_info.name_as_string()\n                         },\n                         type_metadata: variant_type_metadata,\n                         offset: Size::ZERO,\n                         size: self.layout.size,\n                         align: self.layout.align.abi,\n                         flags: DIFlags::FlagZero,\n-                        discriminant: Some(self.layout.ty.ty_adt_def().unwrap()\n-                                           .discriminant_for_variant(cx.tcx, i)\n-                                           .val as u64),\n+                        discriminant,\n                     }\n                 }).collect()\n             }\n@@ -1373,7 +1415,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     let (variant_type_metadata, member_description_factory) =\n                         describe_enum_variant(cx,\n                                               variant,\n-                                              &adt.variants[dataful_variant],\n+                                              variant_info_for(dataful_variant),\n                                               OptimizedDiscriminant,\n                                               self.containing_scope,\n                                               self.span);\n@@ -1413,7 +1455,9 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                        self.layout,\n                                        self.layout.fields.offset(discr_index),\n                                        self.layout.field(cx, discr_index).size);\n-                    name.push_str(&adt.variants[*niche_variants.start()].ident.as_str());\n+                    variant_info_for(*niche_variants.start()).map_name(|variant_name| {\n+                        name.push_str(variant_name);\n+                    });\n \n                     // Create the (singleton) list of descriptions of union members.\n                     vec![\n@@ -1430,10 +1474,11 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 } else {\n                     variants.iter_enumerated().map(|(i, _)| {\n                         let variant = self.layout.for_variant(cx, i);\n+                        let variant_info = variant_info_for(i);\n                         let (variant_type_metadata, member_desc_factory) =\n                             describe_enum_variant(cx,\n                                                   variant,\n-                                                  &adt.variants[i],\n+                                                  variant_info,\n                                                   OptimizedDiscriminant,\n                                                   self_metadata,\n                                                   self.span);\n@@ -1461,7 +1506,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         };\n \n                         MemberDescription {\n-                            name: adt.variants[i].ident.as_str().to_string(),\n+                            name: variant_info.name_as_string(),\n                             type_metadata: variant_type_metadata,\n                             offset: Size::ZERO,\n                             size: self.layout.size,\n@@ -1519,39 +1564,59 @@ enum EnumDiscriminantInfo<'ll> {\n     NoDiscriminant\n }\n \n+#[derive(Copy, Clone)]\n+enum VariantInfo<'tcx> {\n+    Adt(&'tcx ty::VariantDef),\n+    Generator(ty::GeneratorSubsts<'tcx>, VariantIdx),\n+}\n+\n+impl<'tcx> VariantInfo<'tcx> {\n+    fn map_name<R>(&self, f: impl FnOnce(&str) -> R) -> R {\n+        match self {\n+            VariantInfo::Adt(variant) => f(&variant.ident.as_str()),\n+            VariantInfo::Generator(substs, variant_index) =>\n+                substs.map_variant_name(*variant_index, f),\n+        }\n+    }\n+\n+    fn name_as_string(&self) -> String {\n+        self.map_name(|name| name.to_string())\n+    }\n+\n+    fn field_name(&self, i: usize) -> String {\n+        match self {\n+            VariantInfo::Adt(variant) if variant.ctor_kind != CtorKind::Fn =>\n+                variant.fields[i].ident.to_string(),\n+            _ => format!(\"__{}\", i),\n+        }\n+    }\n+}\n+\n // Returns a tuple of (1) type_metadata_stub of the variant, (2) a\n // MemberDescriptionFactory for producing the descriptions of the\n // fields of the variant. This is a rudimentary version of a full\n // RecursiveTypeDescription.\n fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyLayout<'tcx>,\n-    variant: &'tcx ty::VariantDef,\n+    variant: VariantInfo<'tcx>,\n     discriminant_info: EnumDiscriminantInfo<'ll>,\n     containing_scope: &'ll DIScope,\n     span: Span,\n ) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n-    let variant_name = variant.ident.as_str();\n-    let unique_type_id = debug_context(cx).type_map\n-                                          .borrow_mut()\n-                                          .get_unique_type_id_of_enum_variant(\n-                                              cx,\n-                                              layout.ty,\n-                                              &variant_name);\n-\n-    let metadata_stub = create_struct_stub(cx,\n-                                           layout.ty,\n-                                           &variant_name,\n-                                           unique_type_id,\n-                                           Some(containing_scope));\n-\n-    let arg_name = |i: usize| {\n-        if variant.ctor_kind == CtorKind::Fn {\n-            format!(\"__{}\", i)\n-        } else {\n-            variant.fields[i].ident.to_string()\n-        }\n-    };\n+    let metadata_stub = variant.map_name(|variant_name| {\n+        let unique_type_id = debug_context(cx).type_map\n+                                              .borrow_mut()\n+                                              .get_unique_type_id_of_enum_variant(\n+                                                  cx,\n+                                                  layout.ty,\n+                                                  &variant_name);\n+        create_struct_stub(cx,\n+                           layout.ty,\n+                           &variant_name,\n+                           unique_type_id,\n+                           Some(containing_scope))\n+    });\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n     let (offsets, args) = if use_enum_fallback(cx) {\n@@ -1573,7 +1638,7 @@ fn describe_enum_variant(\n                 layout.fields.offset(i)\n             })).collect(),\n             discr_arg.into_iter().chain((0..layout.fields.count()).map(|i| {\n-                (arg_name(i), layout.field(cx, i).ty)\n+                (variant.field_name(i), layout.field(cx, i).ty)\n             })).collect()\n         )\n     } else {\n@@ -1582,7 +1647,7 @@ fn describe_enum_variant(\n                 layout.fields.offset(i)\n             }).collect(),\n             (0..layout.fields.count()).map(|i| {\n-                (arg_name(i), layout.field(cx, i).ty)\n+                (variant.field_name(i), layout.field(cx, i).ty)\n             }).collect()\n         )\n     };\n@@ -1609,6 +1674,7 @@ fn prepare_enum_metadata(\n     enum_def_id: DefId,\n     unique_type_id: UniqueTypeId,\n     span: Span,\n+    outer_field_tys: Vec<Ty<'tcx>>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let enum_name = compute_debuginfo_type_name(cx.tcx, enum_type, false);\n \n@@ -1622,20 +1688,36 @@ fn prepare_enum_metadata(\n     let file_metadata = unknown_file_metadata(cx);\n \n     let discriminant_type_metadata = |discr: layout::Primitive| {\n-        let def = enum_type.ty_adt_def().unwrap();\n-        let enumerators_metadata: Vec<_> = def.discriminants(cx.tcx)\n-            .zip(&def.variants)\n-            .map(|((_, discr), v)| {\n-                let name = SmallCStr::new(&v.ident.as_str());\n-                unsafe {\n-                    Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n-                        DIB(cx),\n-                        name.as_ptr(),\n-                        // FIXME: what if enumeration has i128 discriminant?\n-                        discr.val as u64))\n-                }\n-            })\n-            .collect();\n+        let enumerators_metadata: Vec<_> = match enum_type.sty {\n+            ty::Adt(def, _) => def\n+                .discriminants(cx.tcx)\n+                .zip(&def.variants)\n+                .map(|((_, discr), v)| {\n+                    let name = SmallCStr::new(&v.ident.as_str());\n+                    unsafe {\n+                        Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n+                            DIB(cx),\n+                            name.as_ptr(),\n+                            // FIXME: what if enumeration has i128 discriminant?\n+                            discr.val as u64))\n+                    }\n+                })\n+                .collect(),\n+            ty::Generator(_, substs, _) => substs\n+                .variants(enum_def_id, cx.tcx)\n+                .map(|v| substs.map_variant_name(v, |name| {\n+                    let name = SmallCStr::new(name);\n+                    unsafe {\n+                        Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n+                            DIB(cx),\n+                            name.as_ptr(),\n+                            // FIXME: what if enumeration has i128 discriminant?\n+                            v.as_usize() as u64))\n+                    }\n+                }))\n+                .collect(),\n+            _ => bug!(),\n+        };\n \n         let disr_type_key = (enum_def_id, discr);\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n@@ -1648,14 +1730,18 @@ fn prepare_enum_metadata(\n                     (discr.size(cx), discr.align(cx));\n                 let discriminant_base_type_metadata =\n                     type_metadata(cx, discr.to_ty(cx.tcx), syntax_pos::DUMMY_SP);\n-                let discriminant_name = get_enum_discriminant_name(cx, enum_def_id).as_str();\n \n-                let name = SmallCStr::new(&discriminant_name);\n+                let discriminant_name = match enum_type.sty {\n+                    ty::Adt(..) => SmallCStr::new(&cx.tcx.item_name(enum_def_id).as_str()),\n+                    ty::Generator(..) => SmallCStr::new(&enum_name),\n+                    _ => bug!(),\n+                };\n+\n                 let discriminant_type_metadata = unsafe {\n                     llvm::LLVMRustDIBuilderCreateEnumerationType(\n                         DIB(cx),\n                         containing_scope,\n-                        name.as_ptr(),\n+                        discriminant_name.as_ptr(),\n                         file_metadata,\n                         UNKNOWN_LINE_NUMBER,\n                         discriminant_size.bits(),\n@@ -1736,6 +1822,11 @@ fn prepare_enum_metadata(\n         );\n     }\n \n+    let discriminator_name = match &enum_type.sty {\n+        ty::Generator(..) => Some(SmallCStr::new(&\"__state\")),\n+        _ => None,\n+    };\n+    let discriminator_name = discriminator_name.map(|n| n.as_ptr()).unwrap_or(ptr::null_mut());\n     let discriminator_metadata = match layout.variants {\n         // A single-variant enum has no discriminant.\n         layout::Variants::Single { .. } => None,\n@@ -1762,7 +1853,7 @@ fn prepare_enum_metadata(\n                 Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n                     containing_scope,\n-                    ptr::null_mut(),\n+                    discriminator_name,\n                     file_metadata,\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n@@ -1787,7 +1878,7 @@ fn prepare_enum_metadata(\n                 Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n                     containing_scope,\n-                    ptr::null_mut(),\n+                    discriminator_name,\n                     file_metadata,\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n@@ -1799,6 +1890,22 @@ fn prepare_enum_metadata(\n         },\n     };\n \n+    let mut outer_fields = match layout.variants {\n+        layout::Variants::Single { .. } => vec![],\n+        layout::Variants::Multiple { .. } => {\n+            let tuple_mdf = TupleMemberDescriptionFactory {\n+                ty: enum_type,\n+                component_types: outer_field_tys,\n+                span\n+            };\n+            tuple_mdf\n+                .create_member_descriptions(cx)\n+                .into_iter()\n+                .map(|desc| Some(desc.into_metadata(cx, containing_scope)))\n+                .collect()\n+        }\n+    };\n+\n     let variant_part_unique_type_id_str = SmallCStr::new(\n         debug_context(cx).type_map\n             .borrow_mut()\n@@ -1819,10 +1926,10 @@ fn prepare_enum_metadata(\n             empty_array,\n             variant_part_unique_type_id_str.as_ptr())\n     };\n+    outer_fields.push(Some(variant_part));\n \n     // The variant part must be wrapped in a struct according to DWARF.\n-    // TODO create remaining fields here, if any.\n-    let type_array = create_DIArray(DIB(cx), &[Some(variant_part)]);\n+    let type_array = create_DIArray(DIB(cx), &outer_fields);\n     let struct_wrapper = unsafe {\n         llvm::LLVMRustDIBuilderCreateStructType(\n             DIB(cx),\n@@ -1854,12 +1961,6 @@ fn prepare_enum_metadata(\n             span,\n         }),\n     );\n-\n-    fn get_enum_discriminant_name(cx: &CodegenCx<'_, '_>,\n-                                  def_id: DefId)\n-                                  -> InternedString {\n-        cx.tcx.item_name(def_id)\n-    }\n }\n \n /// Creates debug information for a composite type, that is, anything that\n@@ -1917,26 +2018,7 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, 'tcx>,\n \n     let member_metadata: Vec<_> = member_descriptions\n         .into_iter()\n-        .map(|member_description| {\n-            let member_name = CString::new(member_description.name).unwrap();\n-            unsafe {\n-                Some(llvm::LLVMRustDIBuilderCreateVariantMemberType(\n-                    DIB(cx),\n-                    composite_type_metadata,\n-                    member_name.as_ptr(),\n-                    unknown_file_metadata(cx),\n-                    UNKNOWN_LINE_NUMBER,\n-                    member_description.size.bits(),\n-                    member_description.align.bits() as u32,\n-                    member_description.offset.bits(),\n-                    match member_description.discriminant {\n-                        None => None,\n-                        Some(value) => Some(cx.const_u64(value)),\n-                    },\n-                    member_description.flags,\n-                    member_description.type_metadata))\n-            }\n-        })\n+        .map(|desc| Some(desc.into_metadata(cx, composite_type_metadata)))\n         .collect();\n \n     let type_params = compute_type_parameters(cx, composite_type);"}, {"sha": "36db8c0b7ef79001fd11e805ee06827fbb64e40f", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/961ba95e5a89a101db38e120468be6224af3f8cc/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba95e5a89a101db38e120468be6224af3f8cc/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=961ba95e5a89a101db38e120468be6224af3f8cc", "patch": "@@ -54,6 +54,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty};\n+use rustc::ty::GeneratorSubsts;\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::subst::SubstsRef;\n use rustc_data_structures::fx::FxHashMap;\n@@ -145,11 +146,11 @@ fn self_arg() -> Local {\n }\n \n /// Generator have not been resumed yet\n-const UNRESUMED: usize = 0;\n+const UNRESUMED: usize = GeneratorSubsts::UNRESUMED;\n /// Generator has returned / is completed\n-const RETURNED: usize = 1;\n+const RETURNED: usize = GeneratorSubsts::RETURNED;\n /// Generator has been poisoned\n-const POISONED: usize = 2;\n+const POISONED: usize = GeneratorSubsts::POISONED;\n \n struct SuspensionPoint {\n     state: usize,"}, {"sha": "59dbfecc39ffc28f65a85ed35dc0637243a05183", "filename": "src/test/debuginfo/generator-locals.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/961ba95e5a89a101db38e120468be6224af3f8cc/src%2Ftest%2Fdebuginfo%2Fgenerator-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba95e5a89a101db38e120468be6224af3f8cc/src%2Ftest%2Fdebuginfo%2Fgenerator-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgenerator-locals.rs?ref=961ba95e5a89a101db38e120468be6224af3f8cc", "previous_filename": "src/test/debuginfo/generators.rs"}, {"sha": "a7c1ac1e902bdbf3b95af1c42db19f339bf4e864", "filename": "src/test/debuginfo/generator-objects.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/961ba95e5a89a101db38e120468be6224af3f8cc/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961ba95e5a89a101db38e120468be6224af3f8cc/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs?ref=961ba95e5a89a101db38e120468be6224af3f8cc", "patch": "@@ -0,0 +1,68 @@\n+// ignore-tidy-linelength\n+\n+// Require LLVM with DW_TAG_variant_part and a gdb that can read it.\n+// min-system-llvm-version: 8.0\n+// min-gdb-version: 8.2\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+// gdb-command:print b\n+// gdb-check:$1 = generator_objects::main::generator {__0: 0x[...], <<variant>>: {__state: 0, Unresumed: generator_objects::main::generator::Unresumed, Returned: generator_objects::main::generator::Returned, Panicked: generator_objects::main::generator::Panicked, variant#3: generator_objects::main::generator::variant#3 ([...]), variant#4: generator_objects::main::generator::variant#4 ([...])}}\n+// gdb-command:continue\n+// gdb-command:print b\n+// gdb-check:$2 = generator_objects::main::generator {__0: 0x[...], <<variant>>: {__state: 3, Unresumed: generator_objects::main::generator::Unresumed, Returned: generator_objects::main::generator::Returned, Panicked: generator_objects::main::generator::Panicked, variant#3: generator_objects::main::generator::variant#3 (6, 7), variant#4: generator_objects::main::generator::variant#4 ([...])}}\n+// gdb-command:continue\n+// gdb-command:print b\n+// gdb-check:$3 = generator_objects::main::generator {__0: 0x[...], <<variant>>: {__state: 4, Unresumed: generator_objects::main::generator::Unresumed, Returned: generator_objects::main::generator::Returned, Panicked: generator_objects::main::generator::Panicked, variant#3: generator_objects::main::generator::variant#3 ([...]), variant#4: generator_objects::main::generator::variant#4 (7, 8)}}\n+// gdb-command:continue\n+// gdb-command:print b\n+// gdb-check:$4 = generator_objects::main::generator {__0: 0x[...], <<variant>>: {__state: 1, Unresumed: generator_objects::main::generator::Unresumed, Returned: generator_objects::main::generator::Returned, Panicked: generator_objects::main::generator::Panicked, variant#3: generator_objects::main::generator::variant#3 ([...]), variant#4: generator_objects::main::generator::variant#4 ([...])}}\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+// lldb-command:print b\n+// lldbg-check:(generator_objects::main::generator) $0 = generator(&0x[...])\n+// lldb-command:continue\n+// lldb-command:print b\n+// lldbg-check:(generator_objects::main::generator) $1 = generator(&0x[...])\n+// lldb-command:continue\n+// lldb-command:print b\n+// lldbg-check:(generator_objects::main::generator) $2 = generator(&0x[...])\n+// lldb-command:continue\n+// lldb-command:print b\n+// lldbg-check:(generator_objects::main::generator) $3 = generator(&0x[...])\n+\n+#![feature(omit_gdb_pretty_printer_section, generators, generator_trait)]\n+#![omit_gdb_pretty_printer_section]\n+\n+use std::ops::Generator;\n+use std::pin::Pin;\n+\n+fn main() {\n+    let mut a = 5;\n+    let mut b = || {\n+        let mut c = 6;\n+        let mut d = 7;\n+\n+        yield;\n+        a += 1;\n+        c += 1;\n+        d += 1;\n+\n+        yield;\n+        println!(\"{} {} {}\", a, c, d);\n+    };\n+    _zzz(); // #break\n+    Pin::new(&mut b).resume();\n+    _zzz(); // #break\n+    Pin::new(&mut b).resume();\n+    _zzz(); // #break\n+    Pin::new(&mut b).resume();\n+    _zzz(); // #break\n+}\n+\n+fn _zzz() {()}"}]}