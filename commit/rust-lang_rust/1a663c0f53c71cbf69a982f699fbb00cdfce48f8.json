{"sha": "1a663c0f53c71cbf69a982f699fbb00cdfce48f8", "node_id": "C_kwDOAAsO6NoAKDFhNjYzYzBmNTNjNzFjYmY2OWE5ODJmNjk5ZmJiMDBjZGZjZTQ4Zjg", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-09-11T07:53:54Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2023-02-10T01:38:27Z"}, "message": "Cleanup free_region_relations a bit", "tree": {"sha": "24cffaaee470c90d260f7a759ae4767ab3ce4434", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24cffaaee470c90d260f7a759ae4767ab3ce4434"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a663c0f53c71cbf69a982f699fbb00cdfce48f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a663c0f53c71cbf69a982f699fbb00cdfce48f8", "html_url": "https://github.com/rust-lang/rust/commit/1a663c0f53c71cbf69a982f699fbb00cdfce48f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8996ea93b6e554148c4286e62b613f12a3ee505c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8996ea93b6e554148c4286e62b613f12a3ee505c", "html_url": "https://github.com/rust-lang/rust/commit/8996ea93b6e554148c4286e62b613f12a3ee505c"}], "stats": {"total": 161, "additions": 90, "deletions": 71}, "files": [{"sha": "6a3748fded5549497501ea1a067af2b8c2d259f6", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=1a663c0f53c71cbf69a982f699fbb00cdfce48f8", "patch": "@@ -187,6 +187,7 @@ pub(crate) struct PlaceholderIndices {\n }\n \n impl PlaceholderIndices {\n+    /// Returns the `PlaceholderIndex` for the inserted `PlaceholderRegion`\n     pub(crate) fn insert(&mut self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n         let (index, _) = self.indices.insert_full(placeholder);\n         index.into()"}, {"sha": "f0d964ae78fcd24ec0744ff2f6ec9045ba066c41", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 83, "deletions": 69, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=1a663c0f53c71cbf69a982f699fbb00cdfce48f8", "patch": "@@ -8,6 +8,7 @@ use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::query::OutlivesBound;\n use rustc_middle::ty::{self, RegionVid, Ty};\n+use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOp};\n use std::rc::Rc;\n use type_op::TypeOpOutput;\n@@ -217,8 +218,28 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         self.inverse_outlives.add(fr_b, fr_a);\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn create(mut self) -> CreateResult<'tcx> {\n         let span = self.infcx.tcx.def_span(self.universal_regions.defining_ty.def_id());\n+\n+        // Insert the facts we know from the predicates. Why? Why not.\n+        let param_env = self.param_env;\n+        self.add_outlives_bounds(outlives::explicit_outlives_bounds(param_env));\n+\n+        // Finally:\n+        // - outlives is reflexive, so `'r: 'r` for every region `'r`\n+        // - `'static: 'r` for every region `'r`\n+        // - `'r: 'fn_body` for every (other) universally quantified\n+        //   region `'r`, all of which are provided by our caller\n+        let fr_static = self.universal_regions.fr_static;\n+        let fr_fn_body = self.universal_regions.fr_fn_body;\n+        for fr in self.universal_regions.universal_regions() {\n+            debug!(\"build: relating free region {:?} to itself and to 'static\", fr);\n+            self.relate_universal_regions(fr, fr);\n+            self.relate_universal_regions(fr_static, fr);\n+            self.relate_universal_regions(fr, fr_fn_body);\n+        }\n+\n         let unnormalized_input_output_tys = self\n             .universal_regions\n             .unnormalized_input_tys\n@@ -236,78 +257,52 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         //   the `relations` is built.\n         let mut normalized_inputs_and_output =\n             Vec::with_capacity(self.universal_regions.unnormalized_input_tys.len() + 1);\n-        let constraint_sets: Vec<_> = unnormalized_input_output_tys\n-            .flat_map(|ty| {\n-                debug!(\"build: input_or_output={:?}\", ty);\n-                // We add implied bounds from both the unnormalized and normalized ty.\n-                // See issue #87748\n-                let constraints_implied1 = self.add_implied_bounds(ty);\n-                let TypeOpOutput { output: norm_ty, constraints: constraints1, .. } = self\n-                    .param_env\n-                    .and(type_op::normalize::Normalize::new(ty))\n-                    .fully_perform(self.infcx)\n-                    .unwrap_or_else(|_| {\n-                        let reported = self\n-                            .infcx\n-                            .tcx\n-                            .sess\n-                            .delay_span_bug(span, &format!(\"failed to normalize {:?}\", ty));\n-                        TypeOpOutput {\n-                            output: self.infcx.tcx.ty_error_with_guaranteed(reported),\n-                            constraints: None,\n-                            error_info: None,\n-                        }\n-                    });\n-                // Note: we need this in examples like\n-                // ```\n-                // trait Foo {\n-                //   type Bar;\n-                //   fn foo(&self) -> &Self::Bar;\n-                // }\n-                // impl Foo for () {\n-                //   type Bar = ();\n-                //   fn foo(&self) -> &() {}\n-                // }\n-                // ```\n-                // Both &Self::Bar and &() are WF\n-                let constraints_implied2 =\n-                    if ty != norm_ty { self.add_implied_bounds(norm_ty) } else { None };\n-                normalized_inputs_and_output.push(norm_ty);\n-                constraints1.into_iter().chain(constraints_implied1).chain(constraints_implied2)\n-            })\n-            .collect();\n-\n-        // Insert the facts we know from the predicates. Why? Why not.\n-        let param_env = self.param_env;\n-        self.add_outlives_bounds(outlives::explicit_outlives_bounds(param_env));\n+        let mut constraints = vec![];\n+        for ty in unnormalized_input_output_tys {\n+            debug!(\"build: input_or_output={:?}\", ty);\n+            // We add implied bounds from both the unnormalized and normalized ty.\n+            // See issue #87748\n+            let constraints_unnorm = self.add_implied_bounds(ty);\n+            constraints_unnorm.map(|c| constraints.push(c));\n+            let TypeOpOutput { output: norm_ty, constraints: constraints_normalize, .. } = self\n+                .param_env\n+                .and(type_op::normalize::Normalize::new(ty))\n+                .fully_perform(self.infcx)\n+                .unwrap_or_else(|_| {\n+                    self.infcx\n+                        .tcx\n+                        .sess\n+                        .delay_span_bug(span, &format!(\"failed to normalize {:?}\", ty));\n+                    TypeOpOutput {\n+                        output: self.infcx.tcx.ty_error(),\n+                        constraints: None,\n+                        error_info: None,\n+                    }\n+                });\n+            constraints_normalize.map(|c| constraints.push(c));\n+\n+            // Note: we need this in examples like\n+            // ```\n+            // trait Foo {\n+            //   type Bar;\n+            //   fn foo(&self) -> &Self::Bar;\n+            // }\n+            // impl Foo for () {\n+            //   type Bar = ();\n+            //   fn foo(&self) ->&() {}\n+            // }\n+            // ```\n+            // Both &Self::Bar and &() are WF\n+            if ty != norm_ty {\n+                let constraints_norm = self.add_implied_bounds(norm_ty);\n+                constraints_norm.map(|c| constraints.push(c));\n+            }\n \n-        // Finally:\n-        // - outlives is reflexive, so `'r: 'r` for every region `'r`\n-        // - `'static: 'r` for every region `'r`\n-        // - `'r: 'fn_body` for every (other) universally quantified\n-        //   region `'r`, all of which are provided by our caller\n-        let fr_static = self.universal_regions.fr_static;\n-        let fr_fn_body = self.universal_regions.fr_fn_body;\n-        for fr in self.universal_regions.universal_regions() {\n-            debug!(\"build: relating free region {:?} to itself and to 'static\", fr);\n-            self.relate_universal_regions(fr, fr);\n-            self.relate_universal_regions(fr_static, fr);\n-            self.relate_universal_regions(fr, fr_fn_body);\n+            normalized_inputs_and_output.push(norm_ty);\n         }\n \n-        for data in &constraint_sets {\n-            constraint_conversion::ConstraintConversion::new(\n-                self.infcx,\n-                &self.universal_regions,\n-                &self.region_bound_pairs,\n-                self.implicit_region_bound,\n-                self.param_env,\n-                Locations::All(span),\n-                span,\n-                ConstraintCategory::Internal,\n-                &mut self.constraints,\n-            )\n-            .convert_all(data);\n+        for c in constraints {\n+            self.push_region_constraints(c, span);\n         }\n \n         CreateResult {\n@@ -321,6 +316,24 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, data), level = \"debug\")]\n+    fn push_region_constraints(&mut self, data: &QueryRegionConstraints<'tcx>, span: Span) {\n+        debug!(\"constraints generated: {:#?}\", data);\n+\n+        constraint_conversion::ConstraintConversion::new(\n+            self.infcx,\n+            &self.universal_regions,\n+            &self.region_bound_pairs,\n+            self.implicit_region_bound,\n+            self.param_env,\n+            Locations::All(span),\n+            span,\n+            ConstraintCategory::Internal,\n+            &mut self.constraints,\n+        )\n+        .convert_all(data);\n+    }\n+\n     /// Update the type of a single local, which should represent\n     /// either the return type of the MIR or one of its arguments. At\n     /// the same time, compute and add any implied bounds that come\n@@ -332,6 +345,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n             .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n             .fully_perform(self.infcx)\n             .unwrap_or_else(|_| bug!(\"failed to compute implied bounds {:?}\", ty));\n+        debug!(?bounds, ?constraints);\n         self.add_outlives_bounds(bounds);\n         constraints\n     }"}, {"sha": "8273113295c02a5891b0f7f6ed4064fef0563813", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=1a663c0f53c71cbf69a982f699fbb00cdfce48f8", "patch": "@@ -910,6 +910,8 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n }\n \n impl<'tcx> MirTypeckRegionConstraints<'tcx> {\n+    /// Creates a `Region` that for a given `PlaceholderRegion`, or returns the\n+    /// region that corresponds to a previously created one.\n     fn placeholder_region(\n         &mut self,\n         infcx: &InferCtxt<'tcx>,"}, {"sha": "bae246418b05ac7a167ab9bd794fd6ab12771b50", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=1a663c0f53c71cbf69a982f699fbb00cdfce48f8", "patch": "@@ -207,6 +207,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     ///\n     /// In some cases, such as when `erased_ty` represents a `ty::Param`, however,\n     /// the result is precise.\n+    #[instrument(level = \"debug\", skip(self))]\n     fn declared_generic_bounds_from_env_for_erased_ty(\n         &self,\n         erased_ty: Ty<'tcx>,"}, {"sha": "e2fb80d51caedabe048b6d723bd817ca210dbc26", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=1a663c0f53c71cbf69a982f699fbb00cdfce48f8", "patch": "@@ -81,6 +81,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // From the full set of obligations, just filter down to the\n         // region relationships.\n         outlives_bounds.extend(obligations.into_iter().filter_map(|obligation| {\n+            debug!(?obligation);\n             assert!(!obligation.has_escaping_bound_vars());\n             match obligation.predicate.kind().no_bound_vars() {\n                 None => None,"}, {"sha": "5991c1104c8a2875110b636b5fe950ff002393b4", "filename": "tests/ui/nll/issue-52057.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/tests%2Fui%2Fnll%2Fissue-52057.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a663c0f53c71cbf69a982f699fbb00cdfce48f8/tests%2Fui%2Fnll%2Fissue-52057.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-52057.rs?ref=1a663c0f53c71cbf69a982f699fbb00cdfce48f8", "patch": "@@ -1,6 +1,6 @@\n // Regression test for #52057. There is an implied bound\n-// that `I: 'a` where `'a` is the lifetime of `self` in `parse_first`;\n-// but to observe that, one must normalize first.\n+// that `I: 'x` where `'x` is the lifetime of the reference `&mut Self::Input`\n+// in `parse_first`; but to observe that, one must normalize first.\n //\n // run-pass\n "}]}