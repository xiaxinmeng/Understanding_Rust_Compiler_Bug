{"sha": "29abe6f9e86829d55ba180a5957f203a64a96b65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YWJlNmY5ZTg2ODI5ZDU1YmExODBhNTk1N2YyMDNhNjRhOTZiNjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-24T06:26:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-24T06:26:44Z"}, "message": "Auto merge of #37890 - eddyb:rustdoc-1, r=nrc\n\nrustdoc: separate test collection from the main \"clean\"-ing pipeline.\n\nWhile reusing the documentation \"clean\"-ing infrastructure for collecting code examples to test may have seemed appealing at some point, doing the same through a HIR visitor is barely any harder.\nAt the same time, supporting both \"regular documentation\" and \"test collection\" modes in `rustdoc::clean` has its cost, requiring any use of a `TyCtxt` to be speculative, and provide some sort of fallback.\n\nThis simplification is the first step towards bringing rustdoc closer to the compiler, and perhaps even unifying the \"local crate\" (based on the HIR AST) and \"inlinined across crates\" (based on crate metadata and typesystem information) implementations of rustdoc.\n\nSadly, not all possible changes to rustdoc will be uncontroversial, so I'm starting small with this patch.", "tree": {"sha": "5810ce245eda593ec96190c8f87567ed6dd06d23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5810ce245eda593ec96190c8f87567ed6dd06d23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29abe6f9e86829d55ba180a5957f203a64a96b65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29abe6f9e86829d55ba180a5957f203a64a96b65", "html_url": "https://github.com/rust-lang/rust/commit/29abe6f9e86829d55ba180a5957f203a64a96b65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29abe6f9e86829d55ba180a5957f203a64a96b65/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "696fab844aef55eb4bcbeb470c01ce7d301c51ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/696fab844aef55eb4bcbeb470c01ce7d301c51ed", "html_url": "https://github.com/rust-lang/rust/commit/696fab844aef55eb4bcbeb470c01ce7d301c51ed"}, {"sha": "4be778633073cb3b4a036b8ecc469b2892f12367", "url": "https://api.github.com/repos/rust-lang/rust/commits/4be778633073cb3b4a036b8ecc469b2892f12367", "html_url": "https://github.com/rust-lang/rust/commit/4be778633073cb3b4a036b8ecc469b2892f12367"}], "stats": {"total": 1241, "additions": 575, "deletions": 666}, "files": [{"sha": "c5562ae3b7febf5753f6a649a011ccc824847e1c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 86, "deletions": 107, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=29abe6f9e86829d55ba180a5957f203a64a96b65", "patch": "@@ -18,7 +18,7 @@ use rustc::hir;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::print as pprust;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty;\n use rustc::util::nodemap::FxHashSet;\n \n use rustc_const_eval::lookup_const_by_id;\n@@ -43,17 +43,13 @@ use super::Clean;\n /// of a vector of items if it was successfully expanded.\n pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Name>)\n                   -> Option<Vec<clean::Item>> {\n-    let tcx = match cx.tcx_opt() {\n-        Some(tcx) => tcx,\n-        None => return None,\n-    };\n-    let def = match tcx.expect_def_or_none(id) {\n+    let def = match cx.tcx.expect_def_or_none(id) {\n         Some(def) => def,\n         None => return None,\n     };\n     let did = def.def_id();\n     if did.is_local() { return None }\n-    try_inline_def(cx, tcx, def).map(|vec| {\n+    try_inline_def(cx, def).map(|vec| {\n         vec.into_iter().map(|mut item| {\n             match into {\n                 Some(into) if item.name.is_some() => {\n@@ -66,39 +62,38 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Name>)\n     })\n }\n \n-fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            def: Def) -> Option<Vec<clean::Item>> {\n+fn try_inline_def(cx: &DocContext, def: Def) -> Option<Vec<clean::Item>> {\n+    let tcx = cx.tcx;\n     let mut ret = Vec::new();\n-    let did = def.def_id();\n     let inner = match def {\n         Def::Trait(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Trait);\n-            ret.extend(build_impls(cx, tcx, did));\n-            clean::TraitItem(build_external_trait(cx, tcx, did))\n+            ret.extend(build_impls(cx, did));\n+            clean::TraitItem(build_external_trait(cx, did))\n         }\n         Def::Fn(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Function);\n-            clean::FunctionItem(build_external_function(cx, tcx, did))\n+            clean::FunctionItem(build_external_function(cx, did))\n         }\n         Def::Struct(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Struct);\n-            ret.extend(build_impls(cx, tcx, did));\n-            clean::StructItem(build_struct(cx, tcx, did))\n+            ret.extend(build_impls(cx, did));\n+            clean::StructItem(build_struct(cx, did))\n         }\n         Def::Union(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Union);\n-            ret.extend(build_impls(cx, tcx, did));\n-            clean::UnionItem(build_union(cx, tcx, did))\n+            ret.extend(build_impls(cx, did));\n+            clean::UnionItem(build_union(cx, did))\n         }\n         Def::TyAlias(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Typedef);\n-            ret.extend(build_impls(cx, tcx, did));\n-            clean::TypedefItem(build_type_alias(cx, tcx, did), false)\n+            ret.extend(build_impls(cx, did));\n+            clean::TypedefItem(build_type_alias(cx, did), false)\n         }\n         Def::Enum(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Enum);\n-            ret.extend(build_impls(cx, tcx, did));\n-            clean::EnumItem(build_enum(cx, tcx, did))\n+            ret.extend(build_impls(cx, did));\n+            clean::EnumItem(build_enum(cx, did))\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n@@ -108,23 +103,24 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Def::StructCtor(..) => return Some(Vec::new()),\n         Def::Mod(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Module);\n-            clean::ModuleItem(build_module(cx, tcx, did))\n+            clean::ModuleItem(build_module(cx, did))\n         }\n         Def::Static(did, mtbl) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Static);\n-            clean::StaticItem(build_static(cx, tcx, did, mtbl))\n+            clean::StaticItem(build_static(cx, did, mtbl))\n         }\n         Def::Const(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Const);\n-            clean::ConstantItem(build_const(cx, tcx, did))\n+            clean::ConstantItem(build_const(cx, did))\n         }\n         _ => return None,\n     };\n+    let did = def.def_id();\n     cx.renderinfo.borrow_mut().inlined.insert(did);\n     ret.push(clean::Item {\n         source: clean::Span::empty(),\n         name: Some(tcx.item_name(did).to_string()),\n-        attrs: load_attrs(cx, tcx, did),\n+        attrs: load_attrs(cx, did),\n         inner: inner,\n         visibility: Some(clean::Public),\n         stability: tcx.lookup_stability(did).clean(cx),\n@@ -134,37 +130,33 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Some(ret)\n }\n \n-pub fn load_attrs<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            did: DefId) -> Vec<clean::Attribute> {\n-    tcx.get_attrs(did).iter().map(|a| a.clean(cx)).collect()\n+pub fn load_attrs(cx: &DocContext, did: DefId) -> clean::Attributes {\n+    cx.tcx.get_attrs(did).clean(cx)\n }\n \n /// Record an external fully qualified name in the external_paths cache.\n ///\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n-    if let Some(tcx) = cx.tcx_opt() {\n-        let crate_name = tcx.sess.cstore.crate_name(did.krate).to_string();\n-        let relative = tcx.def_path(did).data.into_iter().filter_map(|elem| {\n-            // extern blocks have an empty name\n-            let s = elem.data.to_string();\n-            if !s.is_empty() {\n-                Some(s)\n-            } else {\n-                None\n-            }\n-        });\n-        let fqn = once(crate_name).chain(relative).collect();\n-        cx.renderinfo.borrow_mut().external_paths.insert(did, (fqn, kind));\n-    }\n+    let crate_name = cx.tcx.sess.cstore.crate_name(did.krate).to_string();\n+    let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n+        // extern blocks have an empty name\n+        let s = elem.data.to_string();\n+        if !s.is_empty() {\n+            Some(s)\n+        } else {\n+            None\n+        }\n+    });\n+    let fqn = once(crate_name).chain(relative).collect();\n+    cx.renderinfo.borrow_mut().external_paths.insert(did, (fqn, kind));\n }\n \n-pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      did: DefId) -> clean::Trait {\n-    let def = tcx.lookup_trait_def(did);\n-    let trait_items = tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n-    let predicates = tcx.item_predicates(did);\n+pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n+    let def = cx.tcx.lookup_trait_def(did);\n+    let trait_items = cx.tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n+    let predicates = cx.tcx.item_predicates(did);\n     let generics = (def.generics, &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n@@ -176,90 +168,84 @@ pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tc\n     }\n }\n \n-fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     did: DefId) -> clean::Function {\n-    let ty = tcx.item_type(did);\n+fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n+    let ty = cx.tcx.item_type(did);\n     let (decl, style, abi) = match ty.sty {\n         ty::TyFnDef(.., ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n         _ => panic!(\"bad function\"),\n     };\n \n-    let constness = if tcx.sess.cstore.is_const_fn(did) {\n+    let constness = if cx.tcx.sess.cstore.is_const_fn(did) {\n         hir::Constness::Const\n     } else {\n         hir::Constness::NotConst\n     };\n \n-    let predicates = tcx.item_predicates(did);\n+    let predicates = cx.tcx.item_predicates(did);\n     clean::Function {\n         decl: decl,\n-        generics: (tcx.item_generics(did), &predicates).clean(cx),\n+        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n         unsafety: style,\n         constness: constness,\n         abi: abi,\n     }\n }\n \n-fn build_enum<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        did: DefId) -> clean::Enum {\n-    let predicates = tcx.item_predicates(did);\n+fn build_enum(cx: &DocContext, did: DefId) -> clean::Enum {\n+    let predicates = cx.tcx.item_predicates(did);\n \n     clean::Enum {\n-        generics: (tcx.item_generics(did), &predicates).clean(cx),\n+        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n         variants_stripped: false,\n-        variants: tcx.lookup_adt_def(did).variants.clean(cx),\n+        variants: cx.tcx.lookup_adt_def(did).variants.clean(cx),\n     }\n }\n \n-fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          did: DefId) -> clean::Struct {\n-    let predicates = tcx.item_predicates(did);\n-    let variant = tcx.lookup_adt_def(did).struct_variant();\n+fn build_struct(cx: &DocContext, did: DefId) -> clean::Struct {\n+    let predicates = cx.tcx.item_predicates(did);\n+    let variant = cx.tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Struct {\n         struct_type: match variant.ctor_kind {\n             CtorKind::Fictive => doctree::Plain,\n             CtorKind::Fn => doctree::Tuple,\n             CtorKind::Const => doctree::Unit,\n         },\n-        generics: (tcx.item_generics(did), &predicates).clean(cx),\n+        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n-fn build_union<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          did: DefId) -> clean::Union {\n-    let predicates = tcx.item_predicates(did);\n-    let variant = tcx.lookup_adt_def(did).struct_variant();\n+fn build_union(cx: &DocContext, did: DefId) -> clean::Union {\n+    let predicates = cx.tcx.item_predicates(did);\n+    let variant = cx.tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Union {\n         struct_type: doctree::Plain,\n-        generics: (tcx.item_generics(did), &predicates).clean(cx),\n+        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n-fn build_type_alias<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              did: DefId) -> clean::Typedef {\n-    let predicates = tcx.item_predicates(did);\n+fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n+    let predicates = cx.tcx.item_predicates(did);\n \n     clean::Typedef {\n-        type_: tcx.item_type(did).clean(cx),\n-        generics: (tcx.item_generics(did), &predicates).clean(cx),\n+        type_: cx.tcx.item_type(did).clean(cx),\n+        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n     }\n }\n \n-pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n-                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             did: DefId) -> Vec<clean::Item> {\n+pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n+    let tcx = cx.tcx;\n     tcx.populate_inherent_implementations_for_type_if_necessary(did);\n     let mut impls = Vec::new();\n \n     if let Some(i) = tcx.inherent_impls.borrow().get(&did) {\n         for &did in i.iter() {\n-            build_impl(cx, tcx, did, &mut impls);\n+            build_impl(cx, did, &mut impls);\n         }\n     }\n     // If this is the first time we've inlined something from another crate, then\n@@ -277,7 +263,7 @@ pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n     cx.populated_all_crate_impls.set(true);\n \n     for did in tcx.sess.cstore.implementations_of_trait(None) {\n-        build_impl(cx, tcx, did, &mut impls);\n+        build_impl(cx, did, &mut impls);\n     }\n \n     // Also try to inline primitive impls from other crates.\n@@ -303,22 +289,20 @@ pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n \n     for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n         if !def_id.is_local() {\n-            build_impl(cx, tcx, def_id, &mut impls);\n+            build_impl(cx, def_id, &mut impls);\n         }\n     }\n \n     impls\n }\n \n-pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n-                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            did: DefId,\n-                            ret: &mut Vec<clean::Item>) {\n+pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n     if !cx.renderinfo.borrow_mut().inlined.insert(did) {\n         return\n     }\n \n-    let attrs = load_attrs(cx, tcx, did);\n+    let attrs = load_attrs(cx, did);\n+    let tcx = cx.tcx;\n     let associated_trait = tcx.impl_trait_ref(did);\n \n     // Only inline impl if the implemented trait is\n@@ -377,7 +361,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                         default,\n                     ),\n                     source: clean::Span::empty(),\n-                    attrs: vec![],\n+                    attrs: clean::Attributes::default(),\n                     visibility: None,\n                     stability: tcx.lookup_stability(item.def_id).clean(cx),\n                     deprecation: tcx.lookup_deprecation(item.def_id).clean(cx),\n@@ -424,7 +408,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                     name: Some(item.name.clean(cx)),\n                     inner: clean::TypedefItem(typedef, true),\n                     source: clean::Span::empty(),\n-                    attrs: vec![],\n+                    attrs: clean::Attributes::default(),\n                     visibility: None,\n                     stability: tcx.lookup_stability(item.def_id).clean(cx),\n                     deprecation: tcx.lookup_deprecation(item.def_id).clean(cx),\n@@ -440,15 +424,15 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             clean::RegionBound(..) => unreachable!(),\n         }\n     });\n-    if trait_.def_id() == cx.deref_trait_did.get() {\n+    if trait_.def_id() == tcx.lang_items.deref_trait() {\n         super::build_deref_target_impls(cx, &trait_items, ret);\n     }\n \n     let provided = trait_.def_id().map(|did| {\n-        cx.tcx().provided_trait_methods(did)\n-                .into_iter()\n-                .map(|meth| meth.name.to_string())\n-                .collect()\n+        tcx.provided_trait_methods(did)\n+            .into_iter()\n+            .map(|meth| meth.name.to_string())\n+            .collect()\n     }).unwrap_or(FxHashSet());\n \n     ret.push(clean::Item {\n@@ -471,53 +455,48 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n     });\n }\n \n-fn build_module<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          did: DefId) -> clean::Module {\n+fn build_module(cx: &DocContext, did: DefId) -> clean::Module {\n     let mut items = Vec::new();\n-    fill_in(cx, tcx, did, &mut items);\n+    fill_in(cx, did, &mut items);\n     return clean::Module {\n         items: items,\n         is_crate: false,\n     };\n \n-    fn fill_in<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         did: DefId, items: &mut Vec<clean::Item>) {\n+    fn fill_in(cx: &DocContext, did: DefId, items: &mut Vec<clean::Item>) {\n         // If we're reexporting a reexport it may actually reexport something in\n         // two namespaces, so the target may be listed twice. Make sure we only\n         // visit each node at most once.\n         let mut visited = FxHashSet();\n-        for item in tcx.sess.cstore.item_children(did) {\n+        for item in cx.tcx.sess.cstore.item_children(did) {\n             let def_id = item.def.def_id();\n-            if tcx.sess.cstore.visibility(def_id) == ty::Visibility::Public {\n+            if cx.tcx.sess.cstore.visibility(def_id) == ty::Visibility::Public {\n                 if !visited.insert(def_id) { continue }\n-                if let Some(i) = try_inline_def(cx, tcx, item.def) {\n+                if let Some(i) = try_inline_def(cx, item.def) {\n                     items.extend(i)\n                 }\n             }\n         }\n     }\n }\n \n-fn build_const<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         did: DefId) -> clean::Constant {\n-    let (expr, ty) = lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n+fn build_const(cx: &DocContext, did: DefId) -> clean::Constant {\n+    let (expr, ty) = lookup_const_by_id(cx.tcx, did, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });\n     debug!(\"converting constant expr {:?} to snippet\", expr);\n     let sn = pprust::expr_to_string(expr);\n     debug!(\"got snippet {}\", sn);\n \n     clean::Constant {\n-        type_: ty.map(|t| t.clean(cx)).unwrap_or_else(|| tcx.item_type(did).clean(cx)),\n+        type_: ty.map(|t| t.clean(cx)).unwrap_or_else(|| cx.tcx.item_type(did).clean(cx)),\n         expr: sn\n     }\n }\n \n-fn build_static<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          did: DefId,\n-                          mutable: bool) -> clean::Static {\n+fn build_static(cx: &DocContext, did: DefId, mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: tcx.item_type(did).clean(cx),\n+        type_: cx.tcx.item_type(did).clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }"}, {"sha": "a19ec4e8b5edbf6bd57d71163b324764f2f7db5b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 204, "deletions": 238, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=29abe6f9e86829d55ba180a5957f203a64a96b65", "patch": "@@ -14,7 +14,6 @@\n pub use self::Type::*;\n pub use self::Mutability::*;\n pub use self::ItemEnum::*;\n-pub use self::Attribute::*;\n pub use self::TyParamBound::*;\n pub use self::SelfTy::*;\n pub use self::FunctionRetTy::*;\n@@ -25,7 +24,6 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap::Spanned;\n use syntax::ptr::P;\n-use syntax::print::pprust as syntax_pprust;\n use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n@@ -44,6 +42,7 @@ use rustc::hir;\n \n use std::path::PathBuf;\n use std::rc::Rc;\n+use std::slice;\n use std::sync::Arc;\n use std::u32;\n use std::env::current_dir;\n@@ -59,11 +58,11 @@ mod simplify;\n \n // extract the stability index for a node from tcx, if possible\n fn get_stability(cx: &DocContext, def_id: DefId) -> Option<Stability> {\n-    cx.tcx_opt().and_then(|tcx| tcx.lookup_stability(def_id)).clean(cx)\n+    cx.tcx.lookup_stability(def_id).clean(cx)\n }\n \n fn get_deprecation(cx: &DocContext, def_id: DefId) -> Option<Deprecation> {\n-    cx.tcx_opt().and_then(|tcx| tcx.lookup_deprecation(def_id)).clean(cx)\n+    cx.tcx.lookup_deprecation(def_id).clean(cx)\n }\n \n pub trait Clean<T> {\n@@ -126,20 +125,17 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n         use rustc::session::config::Input;\n         use ::visit_lib::LibEmbargoVisitor;\n \n-        if let Some(t) = cx.tcx_opt() {\n-            cx.deref_trait_did.set(t.lang_items.deref_trait());\n-            cx.renderinfo.borrow_mut().deref_trait_did = cx.deref_trait_did.get();\n-            cx.deref_mut_trait_did.set(t.lang_items.deref_mut_trait());\n-            cx.renderinfo.borrow_mut().deref_mut_trait_did = cx.deref_mut_trait_did.get();\n+        {\n+            let mut r = cx.renderinfo.borrow_mut();\n+            r.deref_trait_did = cx.tcx.lang_items.deref_trait();\n+            r.deref_mut_trait_did = cx.tcx.lang_items.deref_mut_trait();\n         }\n \n         let mut externs = Vec::new();\n         for cnum in cx.sess().cstore.crates() {\n             externs.push((cnum, CrateNum(cnum).clean(cx)));\n-            if cx.tcx_opt().is_some() {\n-                // Analyze doc-reachability for extern items\n-                LibEmbargoVisitor::new(cx).visit_lib(cnum);\n-            }\n+            // Analyze doc-reachability for extern items\n+            LibEmbargoVisitor::new(cx).visit_lib(cnum);\n         }\n         externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n@@ -227,20 +223,18 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ExternalCrate {\n     pub name: String,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: Attributes,\n     pub primitives: Vec<PrimitiveType>,\n }\n \n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext) -> ExternalCrate {\n         let mut primitives = Vec::new();\n         let root = DefId { krate: self.0, index: CRATE_DEF_INDEX };\n-        cx.tcx_opt().map(|tcx| {\n-            for item in tcx.sess.cstore.item_children(root) {\n-                let attrs = inline::load_attrs(cx, tcx, item.def.def_id());\n-                PrimitiveType::find(&attrs).map(|prim| primitives.push(prim));\n-            }\n-        });\n+        for item in cx.tcx.sess.cstore.item_children(root) {\n+            let attrs = inline::load_attrs(cx, item.def.def_id());\n+            PrimitiveType::find(&attrs).map(|prim| primitives.push(prim));\n+        }\n         ExternalCrate {\n             name: cx.sess().cstore.crate_name(self.0).to_string(),\n             attrs: cx.sess().cstore.item_attrs(root).clean(cx),\n@@ -258,7 +252,7 @@ pub struct Item {\n     pub source: Span,\n     /// Not everything has a name. E.g., impls\n     pub name: Option<String>,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: Attributes,\n     pub inner: ItemEnum,\n     pub visibility: Option<Visibility>,\n     pub def_id: DefId,\n@@ -270,7 +264,7 @@ impl Item {\n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n     pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n-        self.attrs.value(\"doc\")\n+        self.attrs.doc_value()\n     }\n     pub fn is_crate(&self) -> bool {\n         match self.inner {\n@@ -450,7 +444,7 @@ impl Clean<Item> for doctree::Module {\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n                items: items\n@@ -459,86 +453,104 @@ impl Clean<Item> for doctree::Module {\n     }\n }\n \n-pub trait Attributes {\n-    fn has_word(&self, &str) -> bool;\n-    fn value<'a>(&'a self, &str) -> Option<&'a str>;\n-    fn list<'a>(&'a self, &str) -> &'a [Attribute];\n+pub struct ListAttributesIter<'a> {\n+    attrs: slice::Iter<'a, ast::Attribute>,\n+    current_list: slice::Iter<'a, ast::NestedMetaItem>,\n+    name: &'a str\n }\n \n-impl Attributes for [Attribute] {\n-    /// Returns whether the attribute list contains a specific `Word`\n-    fn has_word(&self, word: &str) -> bool {\n-        for attr in self {\n-            if let Word(ref w) = *attr {\n-                if word == *w {\n-                    return true;\n-                }\n-            }\n+impl<'a> Iterator for ListAttributesIter<'a> {\n+    type Item = &'a ast::NestedMetaItem;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(nested) = self.current_list.next() {\n+            return Some(nested);\n         }\n-        false\n-    }\n \n-    /// Finds an attribute as NameValue and returns the corresponding value found.\n-    fn value<'a>(&'a self, name: &str) -> Option<&'a str> {\n-        for attr in self {\n-            if let NameValue(ref x, ref v) = *attr {\n-                if name == *x {\n-                    return Some(v);\n+        for attr in &mut self.attrs {\n+            if let Some(ref list) = attr.meta_item_list() {\n+                if attr.check_name(self.name) {\n+                    self.current_list = list.iter();\n+                    if let Some(nested) = self.current_list.next() {\n+                        return Some(nested);\n+                    }\n                 }\n             }\n         }\n+\n         None\n     }\n+}\n \n+pub trait AttributesExt {\n     /// Finds an attribute as List and returns the list of attributes nested inside.\n-    fn list<'a>(&'a self, name: &str) -> &'a [Attribute] {\n-        for attr in self {\n-            if let List(ref x, ref list) = *attr {\n-                if name == *x {\n-                    return &list[..];\n-                }\n-            }\n+    fn lists<'a>(&'a self, &'a str) -> ListAttributesIter<'a>;\n+}\n+\n+impl AttributesExt for [ast::Attribute] {\n+    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n+        ListAttributesIter {\n+            attrs: self.iter(),\n+            current_list: [].iter(),\n+            name: name\n         }\n-        &[]\n     }\n }\n \n-/// This is a flattened version of the AST's Attribute + MetaItem.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n-pub enum Attribute {\n-    Word(String),\n-    List(String, Vec<Attribute>),\n-    NameValue(String, String),\n-    Literal(String),\n+pub trait NestedAttributesExt {\n+    /// Returns whether the attribute list contains a specific `Word`\n+    fn has_word(self, &str) -> bool;\n+}\n+\n+impl<'a, I: IntoIterator<Item=&'a ast::NestedMetaItem>> NestedAttributesExt for I {\n+    fn has_word(self, word: &str) -> bool {\n+        self.into_iter().any(|attr| attr.is_word() && attr.check_name(word))\n+    }\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug, Default)]\n+pub struct Attributes {\n+    pub doc_strings: Vec<String>,\n+    pub other_attrs: Vec<ast::Attribute>\n }\n \n-impl Clean<Attribute> for ast::NestedMetaItem {\n-    fn clean(&self, cx: &DocContext) -> Attribute {\n-        if let Some(mi) = self.meta_item() {\n-            mi.clean(cx)\n-        } else { // must be a literal\n-            let lit = self.literal().unwrap();\n-            Literal(syntax_pprust::lit_to_string(lit))\n+impl Attributes {\n+    pub fn from_ast(attrs: &[ast::Attribute]) -> Attributes {\n+        let mut doc_strings = vec![];\n+        let other_attrs = attrs.iter().filter_map(|attr| {\n+            attr.with_desugared_doc(|attr| {\n+                if let Some(value) = attr.value_str() {\n+                    if attr.check_name(\"doc\") {\n+                        doc_strings.push(value.to_string());\n+                        return None;\n+                    }\n+                }\n+\n+                Some(attr.clone())\n+            })\n+        }).collect();\n+        Attributes {\n+            doc_strings: doc_strings,\n+            other_attrs: other_attrs\n         }\n     }\n+\n+    /// Finds the `doc` attribute as a NameValue and returns the corresponding\n+    /// value found.\n+    pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n+        self.doc_strings.first().map(|s| &s[..])\n+    }\n }\n \n-impl Clean<Attribute> for ast::MetaItem {\n-    fn clean(&self, cx: &DocContext) -> Attribute {\n-        if self.is_word() {\n-            Word(self.name().to_string())\n-        } else if let Some(v) = self.value_str() {\n-            NameValue(self.name().to_string(), v.to_string())\n-        } else { // must be a list\n-            let l = self.meta_item_list().unwrap();\n-            List(self.name().to_string(), l.clean(cx))\n-       }\n+impl AttributesExt for Attributes {\n+    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n+        self.other_attrs.lists(name)\n     }\n }\n \n-impl Clean<Attribute> for ast::Attribute {\n-    fn clean(&self, cx: &DocContext) -> Attribute {\n-        self.with_desugared_doc(|a| a.meta().clean(cx))\n+impl Clean<Attributes> for [ast::Attribute] {\n+    fn clean(&self, _cx: &DocContext) -> Attributes {\n+        Attributes::from_ast(self)\n     }\n }\n \n@@ -554,7 +566,7 @@ impl Clean<TyParam> for hir::TyParam {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         TyParam {\n             name: self.name.clean(cx),\n-            did: cx.map.local_def_id(self.id),\n+            did: cx.tcx.map.local_def_id(self.id),\n             bounds: self.bounds.clean(cx),\n             default: self.default.clean(cx),\n         }\n@@ -591,11 +603,9 @@ impl TyParamBound {\n \n     fn is_sized_bound(&self, cx: &DocContext) -> bool {\n         use rustc::hir::TraitBoundModifier as TBM;\n-        if let Some(tcx) = cx.tcx_opt() {\n-            if let TyParamBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n-                if trait_.def_id() == tcx.lang_items.sized_trait() {\n-                    return true;\n-                }\n+        if let TyParamBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n+            if trait_.def_id() == cx.tcx.lang_items.sized_trait() {\n+                return true;\n             }\n         }\n         false\n@@ -616,9 +626,9 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: boo\n     let lifetimes = substs.regions().filter_map(|v| v.clean(cx)).collect();\n     let types = substs.types().skip(has_self as usize).collect::<Vec<_>>();\n \n-    match (trait_did, cx.tcx_opt()) {\n+    match trait_did {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        (Some(did), Some(ref tcx)) if tcx.lang_items.fn_trait_kind(did).is_some() => {\n+        Some(did) if cx.tcx.lang_items.fn_trait_kind(did).is_some() => {\n             assert_eq!(types.len(), 1);\n             let inputs = match types[0].sty {\n                 ty::TyTuple(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n@@ -641,7 +651,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: boo\n                 output: output\n             }\n         },\n-        (..) => {\n+        _ => {\n             PathParameters::AngleBracketed {\n                 lifetimes: lifetimes,\n                 types: types.clean(cx),\n@@ -666,10 +676,7 @@ fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self\n \n impl Clean<TyParamBound> for ty::BuiltinBound {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n-        let tcx = match cx.tcx_opt() {\n-            Some(tcx) => tcx,\n-            None => return RegionBound(Lifetime::statik())\n-        };\n+        let tcx = cx.tcx;\n         let empty = tcx.intern_substs(&[]);\n         let (did, path) = match *self {\n             ty::BoundSend =>\n@@ -700,12 +707,8 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n \n impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n-        let tcx = match cx.tcx_opt() {\n-            Some(tcx) => tcx,\n-            None => return RegionBound(Lifetime::statik())\n-        };\n         inline::record_extern_fqn(cx, self.def_id, TypeKind::Trait);\n-        let path = external_path(cx, &tcx.item_name(self.def_id).as_str(),\n+        let path = external_path(cx, &cx.tcx.item_name(self.def_id).as_str(),\n                                  Some(self.def_id), true, vec![], self.substs);\n \n         debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", self.substs);\n@@ -772,18 +775,16 @@ impl Lifetime {\n \n impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &DocContext) -> Lifetime {\n-        if let Some(tcx) = cx.tcx_opt() {\n-            let def = tcx.named_region_map.defs.get(&self.id).cloned();\n-            match def {\n-                Some(DefEarlyBoundRegion(_, node_id)) |\n-                Some(DefLateBoundRegion(_, node_id)) |\n-                Some(DefFreeRegion(_, node_id)) => {\n-                    if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n-                        return lt;\n-                    }\n+        let def = cx.tcx.named_region_map.defs.get(&self.id).cloned();\n+        match def {\n+            Some(DefEarlyBoundRegion(_, node_id)) |\n+            Some(DefLateBoundRegion(_, node_id)) |\n+            Some(DefFreeRegion(_, node_id)) => {\n+                if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n+                    return lt;\n                 }\n-                _ => {}\n             }\n+            _ => {}\n         }\n         Lifetime(self.name.to_string())\n     }\n@@ -1048,7 +1049,7 @@ impl Clean<Method> for hir::MethodSig {\n             },\n             output: self.decl.output.clean(cx),\n             variadic: false,\n-            attrs: Vec::new()\n+            attrs: Attributes::default()\n         };\n         Method {\n             generics: self.generics.clean(cx),\n@@ -1076,7 +1077,7 @@ impl Clean<TyMethod> for hir::MethodSig {\n             },\n             output: self.decl.output.clean(cx),\n             variadic: false,\n-            attrs: Vec::new()\n+            attrs: Attributes::default()\n         };\n         TyMethod {\n             unsafety: self.unsafety.clone(),\n@@ -1105,7 +1106,7 @@ impl Clean<Item> for doctree::Function {\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             inner: FunctionItem(Function {\n                 decl: self.decl.clean(cx),\n                 generics: self.generics.clean(cx),\n@@ -1122,7 +1123,7 @@ pub struct FnDecl {\n     pub inputs: Arguments,\n     pub output: FunctionRetTy,\n     pub variadic: bool,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: Attributes,\n }\n \n impl FnDecl {\n@@ -1148,22 +1149,22 @@ impl Clean<FnDecl> for hir::FnDecl {\n             },\n             output: self.output.clean(cx),\n             variadic: self.variadic,\n-            attrs: Vec::new()\n+            attrs: Attributes::default()\n         }\n     }\n }\n \n impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n-        let mut names = if cx.map.as_local_node_id(did).is_some() {\n+        let mut names = if cx.tcx.map.as_local_node_id(did).is_some() {\n             vec![].into_iter()\n         } else {\n-            cx.tcx().sess.cstore.fn_arg_names(did).into_iter()\n+            cx.tcx.sess.cstore.fn_arg_names(did).into_iter()\n         }.peekable();\n         FnDecl {\n             output: Return(sig.0.output.clean(cx)),\n-            attrs: Vec::new(),\n+            attrs: Attributes::default(),\n             variadic: sig.0.variadic,\n             inputs: Arguments {\n                 values: sig.0.inputs.iter().map(|t| {\n@@ -1247,7 +1248,7 @@ impl Clean<Item> for doctree::Trait {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -1297,10 +1298,10 @@ impl Clean<Item> for hir::TraitItem {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: None,\n-            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n+            stability: get_stability(cx, cx.tcx.map.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.map.local_def_id(self.id)),\n             inner: inner\n         }\n     }\n@@ -1329,10 +1330,10 @@ impl Clean<Item> for hir::ImplItem {\n             name: Some(self.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n+            stability: get_stability(cx, cx.tcx.map.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.map.local_def_id(self.id)),\n             inner: inner\n         }\n     }\n@@ -1342,13 +1343,13 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.kind {\n             ty::AssociatedKind::Const => {\n-                let ty = cx.tcx().item_type(self.def_id);\n+                let ty = cx.tcx.item_type(self.def_id);\n                 AssociatedConstItem(ty.clean(cx), None)\n             }\n             ty::AssociatedKind::Method => {\n-                let generics = (cx.tcx().item_generics(self.def_id),\n-                                &cx.tcx().item_predicates(self.def_id)).clean(cx);\n-                let fty = match cx.tcx().item_type(self.def_id).sty {\n+                let generics = (cx.tcx.item_generics(self.def_id),\n+                                &cx.tcx.item_predicates(self.def_id)).clean(cx);\n+                let fty = match cx.tcx.item_type(self.def_id).sty {\n                     ty::TyFnDef(_, _, f) => f,\n                     _ => unreachable!()\n                 };\n@@ -1357,9 +1358,9 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                 if self.method_has_self_argument {\n                     let self_ty = match self.container {\n                         ty::ImplContainer(def_id) => {\n-                            cx.tcx().item_type(def_id)\n+                            cx.tcx.item_type(def_id)\n                         }\n-                        ty::TraitContainer(_) => cx.tcx().mk_self_type()\n+                        ty::TraitContainer(_) => cx.tcx.mk_self_type()\n                     };\n                     let self_arg_ty = *fty.sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n@@ -1405,8 +1406,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     // are actually located on the trait/impl itself, so we need to load\n                     // all of the generics from there and then look for bounds that are\n                     // applied to this associated type in question.\n-                    let def = cx.tcx().lookup_trait_def(did);\n-                    let predicates = cx.tcx().item_predicates(did);\n+                    let def = cx.tcx.lookup_trait_def(did);\n+                    let predicates = cx.tcx.item_predicates(did);\n                     let generics = (def.generics, &predicates).clean(cx);\n                     generics.where_predicates.iter().filter_map(|pred| {\n                         let (name, self_type, trait_, bounds) = match *pred {\n@@ -1442,7 +1443,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                 }\n \n                 let ty = if self.defaultness.has_value() {\n-                    Some(cx.tcx().item_type(self.def_id))\n+                    Some(cx.tcx.item_type(self.def_id))\n                 } else {\n                     None\n                 };\n@@ -1457,7 +1458,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n             stability: get_stability(cx, self.def_id),\n             deprecation: get_deprecation(cx, self.def_id),\n             def_id: self.def_id,\n-            attrs: inline::load_attrs(cx, cx.tcx(), self.def_id),\n+            attrs: inline::load_attrs(cx, self.def_id),\n             source: Span::empty(),\n             inner: inner,\n         }\n@@ -1616,11 +1617,11 @@ impl PrimitiveType {\n         }\n     }\n \n-    fn find(attrs: &[Attribute]) -> Option<PrimitiveType> {\n-        for attr in attrs.list(\"doc\") {\n-            if let NameValue(ref k, ref v) = *attr {\n-                if \"primitive\" == *k {\n-                    if let ret@Some(..) = PrimitiveType::from_str(v) {\n+    fn find(attrs: &Attributes) -> Option<PrimitiveType> {\n+        for attr in attrs.lists(\"doc\") {\n+            if let Some(v) = attr.value_str() {\n+                if attr.check_name(\"primitive\") {\n+                    if let ret@Some(..) = PrimitiveType::from_str(&v.as_str()) {\n                         return ret;\n                     }\n                 }\n@@ -1710,53 +1711,44 @@ impl Clean<Type> for hir::Ty {\n                              type_: box m.ty.clean(cx)},\n             TySlice(ref ty) => Vector(box ty.clean(cx)),\n             TyArray(ref ty, ref e) => {\n-                let n = if let Some(tcx) = cx.tcx_opt() {\n-                    use rustc_const_math::{ConstInt, ConstUsize};\n-                    use rustc_const_eval::eval_const_expr;\n-                    use rustc::middle::const_val::ConstVal;\n-                    match eval_const_expr(tcx, e) {\n-                        ConstVal::Integral(ConstInt::Usize(u)) => match u {\n-                            ConstUsize::Us16(u) => u.to_string(),\n-                            ConstUsize::Us32(u) => u.to_string(),\n-                            ConstUsize::Us64(u) => u.to_string(),\n-                        },\n-                        // after type checking this can't fail\n-                        _ => unreachable!(),\n-                    }\n-                } else {\n-                    pprust::expr_to_string(e)\n+                use rustc_const_math::{ConstInt, ConstUsize};\n+                use rustc_const_eval::eval_const_expr;\n+                use rustc::middle::const_val::ConstVal;\n+\n+                let n = match eval_const_expr(cx.tcx, e) {\n+                    ConstVal::Integral(ConstInt::Usize(u)) => match u {\n+                        ConstUsize::Us16(u) => u.to_string(),\n+                        ConstUsize::Us32(u) => u.to_string(),\n+                        ConstUsize::Us64(u) => u.to_string(),\n+                    },\n+                    // after type checking this can't fail\n+                    _ => unreachable!(),\n                 };\n                 FixedVector(box ty.clean(cx), n)\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(None, ref path) => {\n-                let tcx_and_def = cx.tcx_opt().map(|tcx| (tcx, tcx.expect_def(self.id)));\n-                if let Some((_, def)) = tcx_and_def {\n-                    if let Some(new_ty) = cx.ty_substs.borrow().get(&def).cloned() {\n-                        return new_ty;\n-                    }\n+                let def = cx.tcx.expect_def(self.id);\n+                if let Some(new_ty) = cx.ty_substs.borrow().get(&def).cloned() {\n+                    return new_ty;\n                 }\n \n-                let tcx_and_alias = tcx_and_def.and_then(|(tcx, def)| {\n-                    if let Def::TyAlias(def_id) = def {\n-                        // Substitute private type aliases\n-                        tcx.map.as_local_node_id(def_id).and_then(|node_id| {\n-                            if !cx.access_levels.borrow().is_exported(def_id) {\n-                                Some((tcx, &tcx.map.expect_item(node_id).node))\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                    } else {\n-                        None\n+                let mut alias = None;\n+                if let Def::TyAlias(def_id) = def {\n+                    // Substitute private type aliases\n+                    if let Some(node_id) = cx.tcx.map.as_local_node_id(def_id) {\n+                        if !cx.access_levels.borrow().is_exported(def_id) {\n+                            alias = Some(&cx.tcx.map.expect_item(node_id).node);\n+                        }\n                     }\n-                });\n-                if let Some((tcx, &hir::ItemTy(ref ty, ref generics))) = tcx_and_alias {\n+                };\n+\n+                if let Some(&hir::ItemTy(ref ty, ref generics)) = alias {\n                     let provided_params = &path.segments.last().unwrap().parameters;\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n                     for (i, ty_param) in generics.ty_params.iter().enumerate() {\n-                        let ty_param_def = tcx.expect_def(ty_param.id);\n+                        let ty_param_def = cx.tcx.expect_def(ty_param.id);\n                         if let Some(ty) = provided_params.types().get(i).cloned()\n                                                                         .cloned() {\n                             ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n@@ -1824,9 +1816,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyFloat(float_ty) => Primitive(float_ty.into()),\n             ty::TyStr => Primitive(PrimitiveType::Str),\n             ty::TyBox(t) => {\n-                let box_did = cx.tcx_opt().and_then(|tcx| {\n-                    tcx.lang_items.owned_box()\n-                });\n+                let box_did = cx.tcx.lang_items.owned_box();\n                 lang_struct(cx, box_did, t, \"Box\", Unique)\n             }\n             ty::TySlice(ty) => Vector(box ty.clean(cx)),\n@@ -1846,7 +1836,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     type_params: Vec::new(),\n                     where_predicates: Vec::new()\n                 },\n-                decl: (cx.map.local_def_id(ast::CRATE_NODE_ID), &fty.sig).clean(cx),\n+                decl: (cx.tcx.map.local_def_id(ast::CRATE_NODE_ID), &fty.sig).clean(cx),\n                 abi: fty.abi,\n             }),\n             ty::TyAdt(def, substs) => {\n@@ -1857,7 +1847,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     AdtKind::Enum => TypeKind::Enum,\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n-                let path = external_path(cx, &cx.tcx().item_name(did).as_str(),\n+                let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n                                          None, false, vec![], substs);\n                 ResolvedPath {\n                     path: path,\n@@ -1884,7 +1874,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     });\n                 }\n \n-                let path = external_path(cx, &cx.tcx().item_name(did).as_str(),\n+                let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n                                          Some(did), false, bindings, obj.principal.0.substs);\n                 ResolvedPath {\n                     path: path,\n@@ -1902,9 +1892,9 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyAnon(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n-                let item_predicates = cx.tcx().item_predicates(def_id);\n-                let substs = cx.tcx().lift(&substs).unwrap();\n-                let bounds = item_predicates.instantiate(cx.tcx(), substs);\n+                let item_predicates = cx.tcx.item_predicates(def_id);\n+                let substs = cx.tcx.lift(&substs).unwrap();\n+                let bounds = item_predicates.instantiate(cx.tcx, substs);\n                 ImplTrait(bounds.predicates.into_iter().filter_map(|predicate| {\n                     predicate.to_opt_poly_trait_ref().clean(cx)\n                 }).collect())\n@@ -1925,9 +1915,9 @@ impl Clean<Item> for hir::StructField {\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n-            def_id: cx.map.local_def_id(self.id),\n+            stability: get_stability(cx, cx.tcx.map.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.map.local_def_id(self.id)),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             inner: StructFieldItem(self.ty.clean(cx)),\n         }\n     }\n@@ -1937,7 +1927,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n             name: Some(self.name).clean(cx),\n-            attrs: cx.tcx().get_attrs(self.did).clean(cx),\n+            attrs: cx.tcx.get_attrs(self.did).clean(cx),\n             source: Span::empty(),\n             visibility: self.vis.clean(cx),\n             stability: get_stability(cx, self.did),\n@@ -1988,7 +1978,7 @@ impl Clean<Item> for doctree::Struct {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2008,7 +1998,7 @@ impl Clean<Item> for doctree::Union {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2055,7 +2045,7 @@ impl Clean<Item> for doctree::Enum {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2082,7 +2072,7 @@ impl Clean<Item> for doctree::Variant {\n             visibility: None,\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.map.local_def_id(self.def.id()),\n+            def_id: cx.tcx.map.local_def_id(self.def.id()),\n             inner: VariantItem(Variant {\n                 kind: self.def.clean(cx),\n             }),\n@@ -2107,7 +2097,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                         Item {\n                             source: Span::empty(),\n                             name: Some(field.name.clean(cx)),\n-                            attrs: cx.tcx().get_attrs(field.did).clean(cx),\n+                            attrs: cx.tcx.get_attrs(field.did).clean(cx),\n                             visibility: field.vis.clean(cx),\n                             def_id: field.did,\n                             stability: get_stability(cx, field.did),\n@@ -2120,7 +2110,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n         };\n         Item {\n             name: Some(self.name.clean(cx)),\n-            attrs: inline::load_attrs(cx, cx.tcx(), self.did),\n+            attrs: inline::load_attrs(cx, self.did),\n             source: Span::empty(),\n             visibility: Some(Inherited),\n             def_id: self.did,\n@@ -2305,7 +2295,7 @@ impl Clean<Item> for doctree::Typedef {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id.clone()),\n+            def_id: cx.tcx.map.local_def_id(self.id.clone()),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2357,7 +2347,7 @@ impl Clean<Item> for doctree::Static {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2382,7 +2372,7 @@ impl Clean<Item> for doctree::Constant {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2443,24 +2433,22 @@ impl Clean<Vec<Item>> for doctree::Impl {\n \n         // If this impl block is an implementation of the Deref trait, then we\n         // need to try inlining the target's inherent impl blocks as well.\n-        if trait_.def_id() == cx.deref_trait_did.get() {\n+        if trait_.def_id() == cx.tcx.lang_items.deref_trait() {\n             build_deref_target_impls(cx, &items, &mut ret);\n         }\n \n-        let provided = trait_.def_id().and_then(|did| {\n-            cx.tcx_opt().map(|tcx| {\n-                tcx.provided_trait_methods(did)\n-                   .into_iter()\n-                   .map(|meth| meth.name.to_string())\n-                   .collect()\n-            })\n+        let provided = trait_.def_id().map(|did| {\n+            cx.tcx.provided_trait_methods(did)\n+                  .into_iter()\n+                  .map(|meth| meth.name.to_string())\n+                  .collect()\n         }).unwrap_or(FxHashSet());\n \n         ret.push(Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2481,10 +2469,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n fn build_deref_target_impls(cx: &DocContext,\n                             items: &[Item],\n                             ret: &mut Vec<Item>) {\n-    let tcx = match cx.tcx_opt() {\n-        Some(t) => t,\n-        None => return,\n-    };\n+    let tcx = cx.tcx;\n \n     for item in items {\n         let target = match item.inner {\n@@ -2494,7 +2479,7 @@ fn build_deref_target_impls(cx: &DocContext,\n         let primitive = match *target {\n             ResolvedPath { did, .. } if did.is_local() => continue,\n             ResolvedPath { did, .. } => {\n-                ret.extend(inline::build_impls(cx, tcx, did));\n+                ret.extend(inline::build_impls(cx, did));\n                 continue\n             }\n             _ => match target.primitive_type() {\n@@ -2525,7 +2510,7 @@ fn build_deref_target_impls(cx: &DocContext,\n         };\n         if let Some(did) = did {\n             if !did.is_local() {\n-                inline::build_impl(cx, tcx, did, ret);\n+                inline::build_impl(cx, did, ret);\n             }\n         }\n     }\n@@ -2543,7 +2528,7 @@ impl Clean<Item> for doctree::DefaultImpl {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: Some(Public),\n             stability: None,\n             deprecation: None,\n@@ -2627,7 +2612,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(ast::CRATE_NODE_ID),\n+            def_id: cx.tcx.map.local_def_id(ast::CRATE_NODE_ID),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             deprecation: None,\n@@ -2706,10 +2691,10 @@ impl Clean<Item> for hir::ForeignItem {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n+            stability: get_stability(cx, cx.tcx.map.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.map.local_def_id(self.id)),\n             inner: inner,\n         }\n     }\n@@ -2776,22 +2761,7 @@ fn resolve_type(cx: &DocContext,\n                 path: Path,\n                 id: ast::NodeId) -> Type {\n     debug!(\"resolve_type({:?},{:?})\", path, id);\n-    let tcx = match cx.tcx_opt() {\n-        Some(tcx) => tcx,\n-        // If we're extracting tests, this return value's accuracy is not\n-        // important, all we want is a string representation to help people\n-        // figure out what doctests are failing.\n-        None => {\n-            let did = DefId::local(DefIndex::from_u32(0));\n-            return ResolvedPath {\n-                path: path,\n-                typarams: None,\n-                did: did,\n-                is_generic: false\n-            };\n-        }\n-    };\n-    let def = tcx.expect_def(id);\n+    let def = cx.tcx.expect_def(id);\n     debug!(\"resolve_type: def={:?}\", def);\n \n     let is_generic = match def {\n@@ -2816,8 +2786,6 @@ fn resolve_type(cx: &DocContext,\n fn register_def(cx: &DocContext, def: Def) -> DefId {\n     debug!(\"register_def({:?})\", def);\n \n-    let tcx = cx.tcx();\n-\n     let (did, kind) = match def {\n         Def::Fn(i) => (i, TypeKind::Function),\n         Def::TyAlias(i) => (i, TypeKind::Typedef),\n@@ -2827,7 +2795,7 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::Union(i) => (i, TypeKind::Union),\n         Def::Mod(i) => (i, TypeKind::Module),\n         Def::Static(i, _) => (i, TypeKind::Static),\n-        Def::Variant(i) => (tcx.parent_def_id(i).unwrap(), TypeKind::Enum),\n+        Def::Variant(i) => (cx.tcx.parent_def_id(i).unwrap(), TypeKind::Enum),\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n         Def::SelfTy(_, Some(impl_def_id)) => {\n             return impl_def_id\n@@ -2837,7 +2805,7 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n     if did.is_local() { return did }\n     inline::record_extern_fqn(cx, did, kind);\n     if let TypeKind::Trait = kind {\n-        let t = inline::build_external_trait(cx, tcx, did);\n+        let t = inline::build_external_trait(cx, did);\n         cx.external_traits.borrow_mut().insert(did, t);\n     }\n     did\n@@ -2851,9 +2819,7 @@ fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSou\n }\n \n fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<DefId> {\n-    cx.tcx_opt().and_then(|tcx| {\n-        tcx.expect_def_or_none(id).map(|def| register_def(cx, def))\n-    })\n+    cx.tcx.expect_def_or_none(id).map(|def| register_def(cx, def))\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -2872,7 +2838,7 @@ impl Clean<Item> for doctree::Macro {\n             visibility: Some(Public),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             inner: MacroItem(Macro {\n                 source: format!(\"macro_rules! {} {{\\n{}}}\",\n                                 name,"}, {"sha": "7240f0aedbd2770fd38ab4da16a0fdff138faa41", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=29abe6f9e86829d55ba180a5957f203a64a96b65", "patch": "@@ -153,7 +153,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n     if child == trait_ {\n         return true\n     }\n-    let predicates = cx.tcx().item_super_predicates(child).predicates;\n+    let predicates = cx.tcx.item_super_predicates(child).predicates;\n     predicates.iter().filter_map(|pred| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n             if pred.0.trait_ref.self_ty().is_self() {"}, {"sha": "7d7b7fead5854d9fbd9944dc32f7e904fb6e8d32", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=29abe6f9e86829d55ba180a5957f203a64a96b65", "patch": "@@ -7,7 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-pub use self::MaybeTyped::*;\n \n use rustc_lint;\n use rustc_driver::{driver, target_features, abort_on_err};\n@@ -42,21 +41,12 @@ use html::render::RenderInfo;\n pub use rustc::session::config::Input;\n pub use rustc::session::search_paths::SearchPaths;\n \n-/// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n-pub enum MaybeTyped<'a, 'tcx: 'a> {\n-    Typed(TyCtxt<'a, 'tcx, 'tcx>),\n-    NotTyped(&'a session::Session)\n-}\n-\n pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n-    pub map: &'a hir_map::Map<'tcx>,\n-    pub maybe_typed: MaybeTyped<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub input: Input,\n     pub populated_all_crate_impls: Cell<bool>,\n-    pub deref_trait_did: Cell<Option<DefId>>,\n-    pub deref_mut_trait_did: Cell<Option<DefId>>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the access levels from crateanalysis.\n@@ -77,24 +67,9 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub export_map: ExportMap,\n }\n \n-impl<'b, 'tcx> DocContext<'b, 'tcx> {\n-    pub fn sess<'a>(&'a self) -> &'a session::Session {\n-        match self.maybe_typed {\n-            Typed(tcx) => &tcx.sess,\n-            NotTyped(ref sess) => sess\n-        }\n-    }\n-\n-    pub fn tcx_opt<'a>(&'a self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n-        match self.maybe_typed {\n-            Typed(tcx) => Some(tcx),\n-            NotTyped(_) => None\n-        }\n-    }\n-\n-    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        let tcx_opt = self.tcx_opt();\n-        tcx_opt.expect(\"tcx not present\")\n+impl<'a, 'tcx> DocContext<'a, 'tcx> {\n+    pub fn sess(&self) -> &session::Session {\n+        &self.tcx.sess\n     }\n \n     /// Call the closure with the given parameters set as\n@@ -208,24 +183,21 @@ pub fn run_core(search_paths: SearchPaths,\n         };\n \n         let ctxt = DocContext {\n-            map: &tcx.map,\n-            maybe_typed: Typed(tcx),\n+            tcx: tcx,\n             input: input,\n             populated_all_crate_impls: Cell::new(false),\n-            deref_trait_did: Cell::new(None),\n-            deref_mut_trait_did: Cell::new(None),\n             access_levels: RefCell::new(access_levels),\n             external_traits: Default::default(),\n             renderinfo: Default::default(),\n             ty_substs: Default::default(),\n             lt_substs: Default::default(),\n             export_map: export_map,\n         };\n-        debug!(\"crate: {:?}\", ctxt.map.krate());\n+        debug!(\"crate: {:?}\", tcx.map.krate());\n \n         let krate = {\n             let mut v = RustdocVisitor::new(&ctxt);\n-            v.visit(ctxt.map.krate());\n+            v.visit(tcx.map.krate());\n             v.clean(&ctxt)\n         };\n "}, {"sha": "757db81c4402196fc43e77a6547639117b591b0e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 50, "deletions": 53, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=29abe6f9e86829d55ba180a5957f203a64a96b65", "patch": "@@ -53,7 +53,7 @@ use std::sync::Arc;\n use externalfiles::ExternalHtml;\n \n use serialize::json::{ToJson, Json, as_json};\n-use syntax::abi;\n+use syntax::{abi, ast};\n use syntax::feature_gate::UnstableFeatures;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevels;\n@@ -62,7 +62,7 @@ use rustc::hir;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::flock;\n \n-use clean::{self, Attributes, GetDefId, SelfTy, Mutability};\n+use clean::{self, AttributesExt, GetDefId, SelfTy, Mutability};\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n@@ -453,30 +453,26 @@ pub fn run(mut krate: clean::Crate,\n \n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n-    if let Some(attrs) = krate.module.as_ref().map(|m| m.attrs.list(\"doc\")) {\n-        for attr in attrs {\n-            match *attr {\n-                clean::NameValue(ref x, ref s)\n-                        if \"html_favicon_url\" == *x => {\n+    if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n+        for attr in attrs.lists(\"doc\") {\n+            let name = attr.name().map(|s| s.as_str());\n+            match (name.as_ref().map(|s| &s[..]), attr.value_str()) {\n+                (Some(\"html_favicon_url\"), Some(s)) => {\n                     scx.layout.favicon = s.to_string();\n                 }\n-                clean::NameValue(ref x, ref s)\n-                        if \"html_logo_url\" == *x => {\n+                (Some(\"html_logo_url\"), Some(s)) => {\n                     scx.layout.logo = s.to_string();\n                 }\n-                clean::NameValue(ref x, ref s)\n-                        if \"html_playground_url\" == *x => {\n+                (Some(\"html_playground_url\"), Some(s)) => {\n                     markdown::PLAYGROUND.with(|slot| {\n                         let name = krate.name.clone();\n-                        *slot.borrow_mut() = Some((Some(name), s.clone()));\n+                        *slot.borrow_mut() = Some((Some(name), s.to_string()));\n                     });\n                 }\n-                clean::NameValue(ref x, ref s)\n-                        if \"issue_tracker_base_url\" == *x => {\n+                (Some(\"issue_tracker_base_url\"), Some(s)) => {\n                     scx.issue_tracker_base_url = Some(s.to_string());\n                 }\n-                clean::Word(ref x)\n-                        if \"html_no_source\" == *x => {\n+                (Some(\"html_no_source\"), None) if attr.is_word() => {\n                     scx.include_sources = false;\n                 }\n                 _ => {}\n@@ -860,13 +856,16 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n \n     // Failing that, see if there's an attribute specifying where to find this\n     // external crate\n-    e.attrs.list(\"doc\").value(\"html_root_url\").map(|url| {\n-        let mut url = url.to_owned();\n+    e.attrs.lists(\"doc\")\n+     .filter(|a| a.check_name(\"html_root_url\"))\n+     .filter_map(|a| a.value_str())\n+     .map(|url| {\n+        let mut url = url.to_string();\n         if !url.ends_with(\"/\") {\n             url.push('/')\n         }\n         Remote(url)\n-    }).unwrap_or(Unknown) // Well, at least we tried.\n+    }).next().unwrap_or(Unknown) // Well, at least we tried.\n }\n \n impl<'a> DocFolder for SourceCollector<'a> {\n@@ -2511,49 +2510,47 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     Ok(())\n }\n \n-fn attribute_without_value(s: &str) -> bool {\n-    [\"must_use\", \"no_mangle\", \"unsafe_destructor_blind_to_params\"].iter().any(|x| x == &s)\n-}\n-\n-fn attribute_with_value(s: &str) -> bool {\n-    [\"export_name\", \"lang\", \"link_section\", \"must_use\"].iter().any(|x| x == &s)\n-}\n-\n-fn attribute_with_values(s: &str) -> bool {\n-    [\"repr\"].iter().any(|x| x == &s)\n-}\n+fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n+    let name = attr.name();\n \n-fn render_attribute(attr: &clean::Attribute, recurse: bool) -> Option<String> {\n-    match *attr {\n-        clean::Word(ref s) if attribute_without_value(&*s) || recurse => {\n-            Some(format!(\"{}\", s))\n-        }\n-        clean::NameValue(ref k, ref v) if attribute_with_value(&*k) => {\n-            Some(format!(\"{} = \\\"{}\\\"\", k, v))\n-        }\n-        clean::List(ref k, ref values) if attribute_with_values(&*k) => {\n-            let display: Vec<_> = values.iter()\n-                                        .filter_map(|value| render_attribute(value, true))\n-                                        .map(|entry| format!(\"{}\", entry))\n-                                        .collect();\n+    if attr.is_word() {\n+        Some(format!(\"{}\", name))\n+    } else if let Some(v) = attr.value_str() {\n+        Some(format!(\"{} = {:?}\", name, &v.as_str()[..]))\n+    } else if let Some(values) = attr.meta_item_list() {\n+        let display: Vec<_> = values.iter().filter_map(|attr| {\n+            attr.meta_item().and_then(|mi| render_attribute(mi))\n+        }).collect();\n \n-            if display.len() > 0 {\n-                Some(format!(\"{}({})\", k, display.join(\", \")))\n-            } else {\n-                None\n-            }\n-        }\n-        _ => {\n+        if display.len() > 0 {\n+            Some(format!(\"{}({})\", name, display.join(\", \")))\n+        } else {\n             None\n         }\n+    } else {\n+        None\n     }\n }\n \n+const ATTRIBUTE_WHITELIST: &'static [&'static str] = &[\n+    \"export_name\",\n+    \"lang\",\n+    \"link_section\",\n+    \"must_use\",\n+    \"no_mangle\",\n+    \"repr\",\n+    \"unsafe_destructor_blind_to_params\"\n+];\n+\n fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     let mut attrs = String::new();\n \n-    for attr in &it.attrs {\n-        if let Some(s) = render_attribute(attr, false) {\n+    for attr in &it.attrs.other_attrs {\n+        let name = attr.name();\n+        if !ATTRIBUTE_WHITELIST.contains(&&name.as_str()[..]) {\n+            continue;\n+        }\n+        if let Some(s) = render_attribute(attr.meta()) {\n             attrs.push_str(&format!(\"#[{}]\\n\", s));\n         }\n     }\n@@ -2810,7 +2807,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         }\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;\n-        if let Some(ref dox) = i.impl_item.attrs.value(\"doc\") {\n+        if let Some(ref dox) = i.impl_item.doc_value() {\n             write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox))?;\n         }\n     }"}, {"sha": "60ce7ea53953a5c5dbdef176dd55d0b4d3408785", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 89, "deletions": 83, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=29abe6f9e86829d55ba180a5957f203a64a96b65", "patch": "@@ -89,7 +89,7 @@ pub mod visit_ast;\n pub mod visit_lib;\n pub mod test;\n \n-use clean::Attributes;\n+use clean::AttributesExt;\n \n struct Output {\n     krate: clean::Crate,\n@@ -280,43 +280,45 @@ pub fn main_args(args: &[String]) -> isize {\n                                                  !matches.opt_present(\"markdown-no-toc\")),\n         (false, false) => {}\n     }\n-    let out = match acquire_input(input, externs, &matches) {\n-        Ok(out) => out,\n-        Err(s) => {\n-            println!(\"input error: {}\", s);\n-            return 1;\n-        }\n-    };\n-    let Output { krate, passes, renderinfo } = out;\n-    info!(\"going to format\");\n-    match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n-        Some(\"html\") | None => {\n-            html::render::run(krate, &external_html,\n-                              output.unwrap_or(PathBuf::from(\"doc\")),\n-                              passes.into_iter().collect(),\n-                              css_file_extension,\n-                              renderinfo)\n-                .expect(\"failed to generate documentation\");\n-            0\n-        }\n-        Some(s) => {\n-            println!(\"unknown output format: {}\", s);\n-            1\n+\n+    let output_format = matches.opt_str(\"w\");\n+    let res = acquire_input(input, externs, &matches, move |out| {\n+        let Output { krate, passes, renderinfo } = out;\n+        info!(\"going to format\");\n+        match output_format.as_ref().map(|s| &**s) {\n+            Some(\"html\") | None => {\n+                html::render::run(krate, &external_html,\n+                                  output.unwrap_or(PathBuf::from(\"doc\")),\n+                                  passes.into_iter().collect(),\n+                                  css_file_extension,\n+                                  renderinfo)\n+                    .expect(\"failed to generate documentation\");\n+                0\n+            }\n+            Some(s) => {\n+                println!(\"unknown output format: {}\", s);\n+                1\n+            }\n         }\n-    }\n+    });\n+    res.unwrap_or_else(|s| {\n+        println!(\"input error: {}\", s);\n+        1\n+    })\n }\n \n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n-fn acquire_input(input: &str,\n-                 externs: Externs,\n-                 matches: &getopts::Matches) -> Result<Output, String> {\n+fn acquire_input<R, F>(input: &str,\n+                       externs: Externs,\n+                       matches: &getopts::Matches,\n+                       f: F)\n+                       -> Result<R, String>\n+where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n     match matches.opt_str(\"r\").as_ref().map(|s| &**s) {\n-        Some(\"rust\") => Ok(rust_input(input, externs, matches)),\n+        Some(\"rust\") => Ok(rust_input(input, externs, matches, f)),\n         Some(s) => Err(format!(\"unknown input format: {}\", s)),\n-        None => {\n-            Ok(rust_input(input, externs, matches))\n-        }\n+        None => Ok(rust_input(input, externs, matches, f))\n     }\n }\n \n@@ -342,7 +344,8 @@ fn parse_externs(matches: &getopts::Matches) -> Result<Externs, String> {\n /// generated from the cleaned AST of the crate.\n ///\n /// This form of input will run all of the plug/cleaning passes\n-fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) -> Output {\n+fn rust_input<R, F>(cratefile: &str, externs: Externs, matches: &getopts::Matches, f: F) -> R\n+where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n     let mut default_passes = !matches.opt_present(\"no-defaults\");\n     let mut passes = matches.opt_strs(\"passes\");\n     let mut plugins = matches.opt_strs(\"plugins\");\n@@ -355,6 +358,8 @@ fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) ->\n     let cfgs = matches.opt_strs(\"cfg\");\n     let triple = matches.opt_str(\"target\");\n     let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n+    let crate_name = matches.opt_str(\"crate-name\");\n+    let plugin_path = matches.opt_str(\"plugin-path\");\n \n     let cr = PathBuf::from(cratefile);\n     info!(\"starting to run rustc\");\n@@ -363,67 +368,68 @@ fn rust_input(cratefile: &str, externs: Externs, matches: &getopts::Matches) ->\n     rustc_driver::monitor(move || {\n         use rustc::session::config::Input;\n \n-        tx.send(core::run_core(paths, cfgs, externs, Input::File(cr),\n-                               triple, maybe_sysroot)).unwrap();\n-    });\n-    let (mut krate, renderinfo) = rx.recv().unwrap();\n-    info!(\"finished with rustc\");\n+        let (mut krate, renderinfo) =\n+            core::run_core(paths, cfgs, externs, Input::File(cr), triple, maybe_sysroot);\n \n-    if let Some(name) = matches.opt_str(\"crate-name\") {\n-        krate.name = name\n-    }\n+        info!(\"finished with rustc\");\n \n-    // Process all of the crate attributes, extracting plugin metadata along\n-    // with the passes which we are supposed to run.\n-    for attr in krate.module.as_ref().unwrap().attrs.list(\"doc\") {\n-        match *attr {\n-            clean::Word(ref w) if \"no_default_passes\" == *w => {\n-                default_passes = false;\n-            },\n-            clean::NameValue(ref name, ref value) => {\n-                let sink = match &name[..] {\n-                    \"passes\" => &mut passes,\n-                    \"plugins\" => &mut plugins,\n+        if let Some(name) = crate_name {\n+            krate.name = name\n+        }\n+\n+        // Process all of the crate attributes, extracting plugin metadata along\n+        // with the passes which we are supposed to run.\n+        for attr in krate.module.as_ref().unwrap().attrs.lists(\"doc\") {\n+            let name = attr.name().map(|s| s.as_str());\n+            let name = name.as_ref().map(|s| &s[..]);\n+            if attr.is_word() {\n+                if name == Some(\"no_default_passes\") {\n+                    default_passes = false;\n+                }\n+            } else if let Some(value) = attr.value_str() {\n+                let sink = match name {\n+                    Some(\"passes\") => &mut passes,\n+                    Some(\"plugins\") => &mut plugins,\n                     _ => continue,\n                 };\n-                for p in value.split_whitespace() {\n+                for p in value.as_str().split_whitespace() {\n                     sink.push(p.to_string());\n                 }\n             }\n-            _ => (),\n         }\n-    }\n \n-    if default_passes {\n-        for name in passes::DEFAULT_PASSES.iter().rev() {\n-            passes.insert(0, name.to_string());\n+        if default_passes {\n+            for name in passes::DEFAULT_PASSES.iter().rev() {\n+                passes.insert(0, name.to_string());\n+            }\n         }\n-    }\n \n-    // Load all plugins/passes into a PluginManager\n-    let path = matches.opt_str(\"plugin-path\")\n-                      .unwrap_or(\"/tmp/rustdoc/plugins\".to_string());\n-    let mut pm = plugins::PluginManager::new(PathBuf::from(path));\n-    for pass in &passes {\n-        let plugin = match passes::PASSES.iter()\n-                                         .position(|&(p, ..)| {\n-                                             p == *pass\n-                                         }) {\n-            Some(i) => passes::PASSES[i].1,\n-            None => {\n-                error!(\"unknown pass {}, skipping\", *pass);\n-                continue\n-            },\n-        };\n-        pm.add_plugin(plugin);\n-    }\n-    info!(\"loading plugins...\");\n-    for pname in plugins {\n-        pm.load_plugin(pname);\n-    }\n+        // Load all plugins/passes into a PluginManager\n+        let path = plugin_path.unwrap_or(\"/tmp/rustdoc/plugins\".to_string());\n+        let mut pm = plugins::PluginManager::new(PathBuf::from(path));\n+        for pass in &passes {\n+            let plugin = match passes::PASSES.iter()\n+                                             .position(|&(p, ..)| {\n+                                                 p == *pass\n+                                             }) {\n+                Some(i) => passes::PASSES[i].1,\n+                None => {\n+                    error!(\"unknown pass {}, skipping\", *pass);\n+                    continue\n+                },\n+            };\n+            pm.add_plugin(plugin);\n+        }\n+        info!(\"loading plugins...\");\n+        for pname in plugins {\n+            pm.load_plugin(pname);\n+        }\n+\n+        // Run everything!\n+        info!(\"Executing passes/plugins\");\n+        let krate = pm.run_plugins(krate);\n \n-    // Run everything!\n-    info!(\"Executing passes/plugins\");\n-    let krate = pm.run_plugins(krate);\n-    Output { krate: krate, renderinfo: renderinfo, passes: passes }\n+        tx.send(f(Output { krate: krate, renderinfo: renderinfo, passes: passes })).unwrap();\n+    });\n+    rx.recv().unwrap()\n }"}, {"sha": "3c63302127c5eef17b7df6e4818d3851d1f9db0d", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=29abe6f9e86829d55ba180a5957f203a64a96b65", "patch": "@@ -8,40 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::string::String;\n-\n use clean::{self, Item};\n use plugins;\n use fold;\n use fold::DocFolder;\n \n pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n-    let mut collapser = Collapser;\n-    let krate = collapser.fold_crate(krate);\n-    krate\n+    Collapser.fold_crate(krate)\n }\n \n struct Collapser;\n \n impl fold::DocFolder for Collapser {\n     fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-        let mut docstr = String::new();\n-        for attr in &i.attrs {\n-            if let clean::NameValue(ref x, ref s) = *attr {\n-                if \"doc\" == *x {\n-                    docstr.push_str(s);\n-                    docstr.push('\\n');\n-                }\n-            }\n-        }\n-        let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n-            &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n-            _ => true\n-        }).cloned().collect();\n-        if !docstr.is_empty() {\n-            a.push(clean::NameValue(\"doc\".to_string(), docstr));\n-        }\n-        i.attrs = a;\n+        i.attrs.collapse_doc_comments();\n         self.fold_item_recur(i)\n     }\n }\n+\n+impl clean::Attributes {\n+    pub fn collapse_doc_comments(&mut self) {\n+        let mut doc_string = self.doc_strings.join(\"\\n\");\n+        if doc_string.is_empty() {\n+            self.doc_strings = vec![];\n+        } else {\n+            // FIXME(eddyb) Is this still needed?\n+            doc_string.push('\\n');\n+            self.doc_strings = vec![doc_string];\n+        }\n+    }\n+}"}, {"sha": "68c1231fc6f7c58e7266ee3e3c52708fa36e7b68", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=29abe6f9e86829d55ba180a5957f203a64a96b65", "patch": "@@ -11,7 +11,7 @@\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n \n-use clean::{self, Attributes};\n+use clean::{self, AttributesExt, NestedAttributesExt};\n use clean::Item;\n use plugins;\n use fold;\n@@ -41,7 +41,7 @@ struct Stripper<'a> {\n \n impl<'a> fold::DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if i.attrs.list(\"doc\").has_word(\"hidden\") {\n+        if i.attrs.lists(\"doc\").has_word(\"hidden\") {\n             debug!(\"found one in strip_hidden; removing\");\n             // use a dedicated hidden item for given item type if any\n             match i.inner {"}, {"sha": "4d94c30847852f42ce5393049f4b3ee22d6cecea", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=29abe6f9e86829d55ba180a5957f203a64a96b65", "patch": "@@ -17,31 +17,26 @@ use plugins;\n use fold::{self, DocFolder};\n \n pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n-    let mut cleaner = CommentCleaner;\n-    let krate = cleaner.fold_crate(krate);\n-    krate\n+    CommentCleaner.fold_crate(krate)\n }\n \n struct CommentCleaner;\n \n impl fold::DocFolder for CommentCleaner {\n     fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-        let mut avec: Vec<clean::Attribute> = Vec::new();\n-        for attr in &i.attrs {\n-            match attr {\n-                &clean::NameValue(ref x, ref s)\n-                        if \"doc\" == *x => {\n-                    avec.push(clean::NameValue(\"doc\".to_string(),\n-                                               unindent(s)))\n-                }\n-                x => avec.push(x.clone())\n-            }\n-        }\n-        i.attrs = avec;\n+        i.attrs.unindent_doc_comments();\n         self.fold_item_recur(i)\n     }\n }\n \n+impl clean::Attributes {\n+    pub fn unindent_doc_comments(&mut self) {\n+        for doc_string in &mut self.doc_strings {\n+            *doc_string = unindent(doc_string);\n+        }\n+    }\n+}\n+\n fn unindent(s: &str) -> String {\n     let lines = s.lines().collect::<Vec<&str> >();\n     let mut saw_first_line = false;"}, {"sha": "9f29319430dd5f4688444904fa55295170f32ed8", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 93, "deletions": 80, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=29abe6f9e86829d55ba180a5957f203a64a96b65", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::Cell;\n use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n@@ -23,7 +22,8 @@ use std::sync::{Arc, Mutex};\n use testing;\n use rustc_lint;\n use rustc::dep_graph::DepGraph;\n-use rustc::hir::map as hir_map;\n+use rustc::hir;\n+use rustc::hir::intravisit;\n use rustc::session::{self, config};\n use rustc::session::config::{OutputType, OutputTypes, Externs};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n@@ -33,18 +33,15 @@ use rustc_driver::{driver, Compilation};\n use rustc_driver::driver::phase_2_configure_and_expand;\n use rustc_metadata::cstore::CStore;\n use rustc_resolve::MakeGlobMap;\n+use rustc_trans::back::link;\n+use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::feature_gate::UnstableFeatures;\n use errors;\n use errors::emitter::ColorConfig;\n \n-use core;\n-use clean;\n-use clean::Clean;\n-use fold::DocFolder;\n+use clean::Attributes;\n use html::markdown;\n-use passes;\n-use visit_ast::RustdocVisitor;\n \n #[derive(Clone, Default)]\n pub struct TestOptions {\n@@ -87,48 +84,36 @@ pub fn run(input: &str,\n         config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n \n     let krate = panictry!(driver::phase_1_parse_input(&sess, &input));\n-    let driver::ExpansionResult { defs, mut hir_forest, analysis, .. } = {\n+    let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n         phase_2_configure_and_expand(\n             &sess, &cstore, krate, None, \"rustdoc-test\", None, MakeGlobMap::No, |_| Ok(())\n         ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n     };\n \n-    let dep_graph = DepGraph::new(false);\n+    let crate_name = crate_name.unwrap_or_else(|| {\n+        link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n+    });\n     let opts = scrape_test_config(hir_forest.krate());\n-    let _ignore = dep_graph.in_ignore();\n-    let map = hir_map::map_crate(&mut hir_forest, defs);\n-\n-    let ctx = core::DocContext {\n-        map: &map,\n-        maybe_typed: core::NotTyped(&sess),\n-        input: input,\n-        populated_all_crate_impls: Cell::new(false),\n-        external_traits: Default::default(),\n-        deref_trait_did: Cell::new(None),\n-        deref_mut_trait_did: Cell::new(None),\n-        access_levels: Default::default(),\n-        renderinfo: Default::default(),\n-        ty_substs: Default::default(),\n-        lt_substs: Default::default(),\n-        export_map: analysis.export_map,\n-    };\n-\n-    let mut v = RustdocVisitor::new(&ctx);\n-    v.visit(ctx.map.krate());\n-    let mut krate = v.clean(&ctx);\n-    if let Some(name) = crate_name {\n-        krate.name = name;\n-    }\n-    let krate = passes::collapse_docs(krate);\n-    let krate = passes::unindent_comments(krate);\n-\n-    let mut collector = Collector::new(krate.name.to_string(),\n+    let mut collector = Collector::new(crate_name,\n                                        cfgs,\n                                        libs,\n                                        externs,\n                                        false,\n                                        opts);\n-    collector.fold_crate(krate);\n+\n+    {\n+        let dep_graph = DepGraph::new(false);\n+        let _ignore = dep_graph.in_ignore();\n+        let map = hir::map::map_crate(&mut hir_forest, defs);\n+        let krate = map.krate();\n+        let mut hir_collector = HirCollector {\n+            collector: &mut collector,\n+            map: &map\n+        };\n+        hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n+            intravisit::walk_crate(this, krate);\n+        });\n+    }\n \n     test_args.insert(0, \"rustdoctest\".to_string());\n \n@@ -472,56 +457,84 @@ impl Collector {\n     }\n }\n \n-impl DocFolder for Collector {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        let current_name = match item.name {\n-            Some(ref name) if !name.is_empty() => Some(name.clone()),\n-            _ => typename_if_impl(&item)\n-        };\n+struct HirCollector<'a, 'hir: 'a> {\n+    collector: &'a mut Collector,\n+    map: &'a hir::map::Map<'hir>\n+}\n \n-        let pushed = current_name.map(|name| self.names.push(name)).is_some();\n+impl<'a, 'hir> HirCollector<'a, 'hir> {\n+    fn visit_testable<F: FnOnce(&mut Self)>(&mut self,\n+                                            name: String,\n+                                            attrs: &[ast::Attribute],\n+                                            nested: F) {\n+        let has_name = !name.is_empty();\n+        if has_name {\n+            self.collector.names.push(name);\n+        }\n \n-        if let Some(doc) = item.doc_value() {\n-            self.cnt = 0;\n-            markdown::find_testable_code(doc, &mut *self);\n+        let mut attrs = Attributes::from_ast(attrs);\n+        attrs.collapse_doc_comments();\n+        attrs.unindent_doc_comments();\n+        if let Some(doc) = attrs.doc_value() {\n+            self.collector.cnt = 0;\n+            markdown::find_testable_code(doc, self.collector);\n         }\n \n-        let ret = self.fold_item_recur(item);\n-        if pushed {\n-            self.names.pop();\n+        nested(self);\n+\n+        if has_name {\n+            self.collector.names.pop();\n         }\n+    }\n+}\n+\n+impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'hir>> {\n+        Some(self.map)\n+    }\n+\n+    fn visit_item(&mut self, item: &'hir hir::Item) {\n+        let name = if let hir::ItemImpl(.., ref ty, _) = item.node {\n+            hir::print::ty_to_string(ty)\n+        } else {\n+            item.name.to_string()\n+        };\n \n-        return ret;\n+        self.visit_testable(name, &item.attrs, |this| {\n+            intravisit::walk_item(this, item);\n+        });\n+    }\n \n-        // FIXME: it would be better to not have the escaped version in the first place\n-        fn unescape_for_testname(mut s: String) -> String {\n-            // for refs `&foo`\n-            if s.contains(\"&amp;\") {\n-                s = s.replace(\"&amp;\", \"&\");\n+    fn visit_trait_item(&mut self, item: &'hir hir::TraitItem) {\n+        self.visit_testable(item.name.to_string(), &item.attrs, |this| {\n+            intravisit::walk_trait_item(this, item);\n+        });\n+    }\n \n-                // `::&'a mut Foo::` looks weird, let's make it `::<&'a mut Foo>`::\n-                if let Some('&') = s.chars().nth(0) {\n-                    s = format!(\"<{}>\", s);\n-                }\n-            }\n+    fn visit_impl_item(&mut self, item: &'hir hir::ImplItem) {\n+        self.visit_testable(item.name.to_string(), &item.attrs, |this| {\n+            intravisit::walk_impl_item(this, item);\n+        });\n+    }\n \n-            // either `<..>` or `->`\n-            if s.contains(\"&gt;\") {\n-                s.replace(\"&gt;\", \">\")\n-                 .replace(\"&lt;\", \"<\")\n-            } else {\n-                s\n-            }\n-        }\n+    fn visit_foreign_item(&mut self, item: &'hir hir::ForeignItem) {\n+        self.visit_testable(item.name.to_string(), &item.attrs, |this| {\n+            intravisit::walk_foreign_item(this, item);\n+        });\n+    }\n \n-        fn typename_if_impl(item: &clean::Item) -> Option<String> {\n-            if let clean::ItemEnum::ImplItem(ref impl_) = item.inner {\n-                let path = impl_.for_.to_string();\n-                let unescaped_path = unescape_for_testname(path);\n-                Some(unescaped_path)\n-            } else {\n-                None\n-            }\n-        }\n+    fn visit_variant(&mut self,\n+                     v: &'hir hir::Variant,\n+                     g: &'hir hir::Generics,\n+                     item_id: ast::NodeId) {\n+        self.visit_testable(v.node.name.to_string(), &v.node.attrs, |this| {\n+            intravisit::walk_variant(this, v, g, item_id);\n+        });\n+    }\n+\n+    fn visit_struct_field(&mut self, f: &'hir hir::StructField) {\n+        self.visit_testable(f.name.to_string(), &f.attrs, |this| {\n+            intravisit::walk_struct_field(this, f);\n+        });\n     }\n }"}, {"sha": "8ed0567d820ac4af27ea5df04f26f3700374e3ee", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=29abe6f9e86829d55ba180a5957f203a64a96b65", "patch": "@@ -28,7 +28,7 @@ use rustc::util::nodemap::FxHashSet;\n use rustc::hir;\n \n use core;\n-use clean::{self, Clean, Attributes};\n+use clean::{self, AttributesExt, NestedAttributesExt};\n use doctree::*;\n \n // looks to me like the first two of these are actually\n@@ -65,18 +65,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n-        self.cx.tcx_opt().and_then(|tcx| {\n-            self.cx.map.opt_local_def_id(id)\n-                       .and_then(|def_id| tcx.lookup_stability(def_id))\n-                       .cloned()\n-        })\n+        self.cx.tcx.map.opt_local_def_id(id)\n+            .and_then(|def_id| self.cx.tcx.lookup_stability(def_id)).cloned()\n     }\n \n     fn deprecation(&self, id: ast::NodeId) -> Option<attr::Deprecation> {\n-        self.cx.tcx_opt().and_then(|tcx| {\n-            self.cx.map.opt_local_def_id(id)\n-                       .and_then(|def_id| tcx.lookup_deprecation(def_id))\n-        })\n+        self.cx.tcx.map.opt_local_def_id(id)\n+            .and_then(|def_id| self.cx.tcx.lookup_deprecation(def_id))\n     }\n \n     pub fn visit(&mut self, krate: &hir::Crate) {\n@@ -196,7 +191,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= vis == hir::Public;\n         for i in &m.item_ids {\n-            let item = self.cx.map.expect_item(i.id);\n+            let item = self.cx.tcx.map.expect_item(i.id);\n             self.visit_item(item, None, &mut om);\n         }\n         self.inside_public_path = orig_inside_public_path;\n@@ -279,10 +274,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                   glob: bool, om: &mut Module, please_inline: bool) -> bool {\n \n         fn inherits_doc_hidden(cx: &core::DocContext, mut node: ast::NodeId) -> bool {\n-            while let Some(id) = cx.map.get_enclosing_scope(node) {\n+            while let Some(id) = cx.tcx.map.get_enclosing_scope(node) {\n                 node = id;\n-                let attrs = cx.map.attrs(node).clean(cx);\n-                if attrs.list(\"doc\").has_word(\"hidden\") {\n+                if cx.tcx.map.attrs(node).lists(\"doc\").has_word(\"hidden\") {\n                     return true;\n                 }\n                 if node == ast::CRATE_NODE_ID {\n@@ -292,25 +286,22 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             false\n         }\n \n-        let tcx = match self.cx.tcx_opt() {\n-            Some(tcx) => tcx,\n-            None => return false\n-        };\n+        let tcx = self.cx.tcx;\n         let def = tcx.expect_def(id);\n         let def_did = def.def_id();\n \n-        let use_attrs = tcx.map.attrs(id).clean(self.cx);\n+        let use_attrs = tcx.map.attrs(id);\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n-        let is_no_inline = use_attrs.list(\"doc\").has_word(\"no_inline\") ||\n-                           use_attrs.list(\"doc\").has_word(\"hidden\");\n+        let is_no_inline = use_attrs.lists(\"doc\").has_word(\"no_inline\") ||\n+                           use_attrs.lists(\"doc\").has_word(\"hidden\");\n \n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation - a previously nonreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront)\n         if !def_did.is_local() && !is_no_inline {\n-            let attrs = clean::inline::load_attrs(self.cx, tcx, def_did);\n-            let self_is_hidden = attrs.list(\"doc\").has_word(\"hidden\");\n+            let attrs = clean::inline::load_attrs(self.cx, def_did);\n+            let self_is_hidden = attrs.lists(\"doc\").has_word(\"hidden\");\n             match def {\n                 Def::Trait(did) |\n                 Def::Struct(did) |\n@@ -348,7 +339,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     match it.node {\n                         hir::ItemMod(ref m) => {\n                             for i in &m.item_ids {\n-                                let i = self.cx.map.expect_item(i.id);\n+                                let i = self.cx.tcx.map.expect_item(i.id);\n                                 self.visit_item(i, None, om);\n                             }\n                         }\n@@ -507,7 +498,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 // regardless of where they're located.\n                 if !self.inlining {\n                     let items = item_ids.iter()\n-                                        .map(|ii| self.cx.map.impl_item(ii.id).clone())\n+                                        .map(|ii| self.cx.tcx.map.impl_item(ii.id).clone())\n                                         .collect();\n                     let i = Impl {\n                         unsafety: unsafety,"}, {"sha": "cee292f99153e4fc318463094d1633f8ac8e6074", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29abe6f9e86829d55ba180a5957f203a64a96b65/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=29abe6f9e86829d55ba180a5957f203a64a96b65", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::Visibility;\n \n use std::cell::RefMut;\n \n-use clean::{Attributes, Clean};\n+use clean::{AttributesExt, NestedAttributesExt};\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n@@ -49,10 +49,7 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n \n     // Updates node level and returns the updated level\n     fn update(&mut self, did: DefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n-        let attrs: Vec<_> = self.cx.tcx().get_attrs(did).iter()\n-                                                        .map(|a| a.clean(self.cx))\n-                                                        .collect();\n-        let is_hidden = attrs.list(\"doc\").has_word(\"hidden\");\n+        let is_hidden = self.cx.tcx.get_attrs(did).lists(\"doc\").has_word(\"hidden\");\n \n         let old_level = self.access_levels.map.get(&did).cloned();\n         // Accessibility levels can only grow"}]}