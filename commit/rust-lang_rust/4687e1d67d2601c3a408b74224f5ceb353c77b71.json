{"sha": "4687e1d67d2601c3a408b74224f5ceb353c77b71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ODdlMWQ2N2QyNjAxYzNhNDA4Yjc0MjI0ZjVjZWIzNTNjNzdiNzE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-02-21T12:25:17Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-02-22T07:04:25Z"}, "message": "remove the TyDesc from TypedArena\n\nThis prevents generating visit glue when using a TypedArena. The problem\nstill exists for the untyped Arena.", "tree": {"sha": "ab8e8ee5381c1ffbef3f2ad9db744853d1bcf11d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab8e8ee5381c1ffbef3f2ad9db744853d1bcf11d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4687e1d67d2601c3a408b74224f5ceb353c77b71", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4687e1d67d2601c3a408b74224f5ceb353c77b71", "html_url": "https://github.com/rust-lang/rust/commit/4687e1d67d2601c3a408b74224f5ceb353c77b71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4687e1d67d2601c3a408b74224f5ceb353c77b71/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "698042de238644341b798238bd5a61ea2f3c0f20", "url": "https://api.github.com/repos/rust-lang/rust/commits/698042de238644341b798238bd5a61ea2f3c0f20", "html_url": "https://github.com/rust-lang/rust/commit/698042de238644341b798238bd5a61ea2f3c0f20"}], "stats": {"total": 74, "additions": 29, "deletions": 45}, "files": [{"sha": "3f5c268606449fe963f84e959df6a09f608dab7d", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 29, "deletions": 45, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4687e1d67d2601c3a408b74224f5ceb353c77b71/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4687e1d67d2601c3a408b74224f5ceb353c77b71/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=4687e1d67d2601c3a408b74224f5ceb353c77b71", "patch": "@@ -31,6 +31,7 @@ use std::cast::{transmute, transmute_mut, transmute_mut_region};\n use std::cast;\n use std::cell::{Cell, RefCell};\n use std::mem;\n+use std::ptr::read;\n use std::cmp;\n use std::num;\n use std::kinds::marker;\n@@ -345,37 +346,32 @@ pub struct TypedArena<T> {\n     /// reached, a new chunk is allocated.\n     priv end: *T,\n \n-    /// The type descriptor of the objects in the arena. This should not be\n-    /// necessary, but is until generic destructors are supported.\n-    priv tydesc: *TyDesc,\n-\n     /// A pointer to the first arena segment.\n-    priv first: Option<~TypedArenaChunk>,\n+    priv first: Option<~TypedArenaChunk<T>>,\n }\n \n-struct TypedArenaChunk {\n+struct TypedArenaChunk<T> {\n     /// Pointer to the next arena segment.\n-    next: Option<~TypedArenaChunk>,\n+    next: Option<~TypedArenaChunk<T>>,\n \n     /// The number of elements that this chunk can hold.\n     capacity: uint,\n \n     // Objects follow here, suitably aligned.\n }\n \n-impl TypedArenaChunk {\n+impl<T> TypedArenaChunk<T> {\n     #[inline]\n-    fn new<T>(next: Option<~TypedArenaChunk>, capacity: uint)\n-           -> ~TypedArenaChunk {\n-        let mut size = mem::size_of::<TypedArenaChunk>();\n+    fn new(next: Option<~TypedArenaChunk<T>>, capacity: uint) -> ~TypedArenaChunk<T> {\n+        let mut size = mem::size_of::<TypedArenaChunk<T>>();\n         size = round_up(size, mem::min_align_of::<T>());\n         let elem_size = mem::size_of::<T>();\n         let elems_size = elem_size.checked_mul(&capacity).unwrap();\n         size = size.checked_add(&elems_size).unwrap();\n \n         let mut chunk = unsafe {\n             let chunk = global_heap::exchange_malloc(size);\n-            let mut chunk: ~TypedArenaChunk = cast::transmute(chunk);\n+            let mut chunk: ~TypedArenaChunk<T> = cast::transmute(chunk);\n             mem::move_val_init(&mut chunk.next, next);\n             chunk\n         };\n@@ -387,16 +383,13 @@ impl TypedArenaChunk {\n     /// Destroys this arena chunk. If the type descriptor is supplied, the\n     /// drop glue is called; otherwise, drop glue is not called.\n     #[inline]\n-    unsafe fn destroy(&mut self, len: uint, opt_tydesc: Option<*TyDesc>) {\n+    unsafe fn destroy(&mut self, len: uint) {\n         // Destroy all the allocated objects.\n-        match opt_tydesc {\n-            None => {}\n-            Some(tydesc) => {\n-                let mut start = self.start(tydesc);\n-                for _ in range(0, len) {\n-                    ((*tydesc).drop_glue)(start as *i8);\n-                    start = start.offset((*tydesc).size as int)\n-                }\n+        if intrinsics::needs_drop::<T>() {\n+            let mut start = self.start();\n+            for _ in range(0, len) {\n+                read(start as *T); // run the destructor on the pointer\n+                start = start.offset(mem::size_of::<T>() as int)\n             }\n         }\n \n@@ -406,26 +399,26 @@ impl TypedArenaChunk {\n             None => {}\n             Some(mut next) => {\n                 // We assume that the next chunk is completely filled.\n-                next.destroy(next.capacity, opt_tydesc)\n+                next.destroy(next.capacity)\n             }\n         }\n     }\n \n     // Returns a pointer to the first allocated object.\n     #[inline]\n-    fn start(&self, tydesc: *TyDesc) -> *u8 {\n-        let this: *TypedArenaChunk = self;\n+    fn start(&self) -> *u8 {\n+        let this: *TypedArenaChunk<T> = self;\n         unsafe {\n-            cast::transmute(round_up(this.offset(1) as uint, (*tydesc).align))\n+            cast::transmute(round_up(this.offset(1) as uint, mem::min_align_of::<T>()))\n         }\n     }\n \n     // Returns a pointer to the end of the allocated space.\n     #[inline]\n-    fn end(&self, tydesc: *TyDesc) -> *u8 {\n+    fn end(&self) -> *u8 {\n         unsafe {\n-            let size = (*tydesc).size.checked_mul(&self.capacity).unwrap();\n-            self.start(tydesc).offset(size as int)\n+            let size = mem::size_of::<T>().checked_mul(&self.capacity).unwrap();\n+            self.start().offset(size as int)\n         }\n     }\n }\n@@ -441,14 +434,10 @@ impl<T> TypedArena<T> {\n     /// objects.\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n-        let chunk = TypedArenaChunk::new::<T>(None, capacity);\n-        let tydesc = unsafe {\n-            intrinsics::get_tydesc::<T>()\n-        };\n+        let chunk = TypedArenaChunk::<T>::new(None, capacity);\n         TypedArena {\n-            ptr: chunk.start(tydesc) as *T,\n-            end: chunk.end(tydesc) as *T,\n-            tydesc: tydesc,\n+            ptr: chunk.start() as *T,\n+            end: chunk.end() as *T,\n             first: Some(chunk),\n         }\n     }\n@@ -475,9 +464,9 @@ impl<T> TypedArena<T> {\n     fn grow(&mut self) {\n         let chunk = self.first.take_unwrap();\n         let new_capacity = chunk.capacity.checked_mul(&2).unwrap();\n-        let chunk = TypedArenaChunk::new::<T>(Some(chunk), new_capacity);\n-        self.ptr = chunk.start(self.tydesc) as *T;\n-        self.end = chunk.end(self.tydesc) as *T;\n+        let chunk = TypedArenaChunk::<T>::new(Some(chunk), new_capacity);\n+        self.ptr = chunk.start() as *T;\n+        self.end = chunk.end() as *T;\n         self.first = Some(chunk)\n     }\n }\n@@ -486,18 +475,13 @@ impl<T> TypedArena<T> {\n impl<T> Drop for TypedArena<T> {\n     fn drop(&mut self) {\n         // Determine how much was filled.\n-        let start = self.first.get_ref().start(self.tydesc) as uint;\n+        let start = self.first.get_ref().start() as uint;\n         let end = self.ptr as uint;\n         let diff = (end - start) / mem::size_of::<T>();\n \n         // Pass that to the `destroy` method.\n         unsafe {\n-            let opt_tydesc = if intrinsics::needs_drop::<T>() {\n-                Some(self.tydesc)\n-            } else {\n-                None\n-            };\n-            self.first.get_mut_ref().destroy(diff, opt_tydesc)\n+            self.first.get_mut_ref().destroy(diff)\n         }\n     }\n }"}]}