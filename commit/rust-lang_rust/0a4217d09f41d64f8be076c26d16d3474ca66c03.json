{"sha": "0a4217d09f41d64f8be076c26d16d3474ca66c03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNDIxN2QwOWY0MWQ2NGY4YmUwNzZjMjZkMTZkMzQ3NGNhNjZjMDM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-07-05T07:39:15Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-07-18T10:06:04Z"}, "message": "rustc_metadata: Make crate loading fully speculative", "tree": {"sha": "c9b9cc76c0386d3ae0f63041c2d3508083da1734", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9b9cc76c0386d3ae0f63041c2d3508083da1734"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a4217d09f41d64f8be076c26d16d3474ca66c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a4217d09f41d64f8be076c26d16d3474ca66c03", "html_url": "https://github.com/rust-lang/rust/commit/0a4217d09f41d64f8be076c26d16d3474ca66c03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a4217d09f41d64f8be076c26d16d3474ca66c03/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4044cbc559be2c00a4718a086c3443d429032446", "url": "https://api.github.com/repos/rust-lang/rust/commits/4044cbc559be2c00a4718a086c3443d429032446", "html_url": "https://github.com/rust-lang/rust/commit/4044cbc559be2c00a4718a086c3443d429032446"}], "stats": {"total": 924, "additions": 453, "deletions": 471}, "files": [{"sha": "0d2101cb2cb0821f5bec673e3580f00f6291f4b1", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 78, "deletions": 105, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -1,22 +1,20 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::locator::{CrateLocator, CratePaths};\n+use crate::dynamic_lib::DynamicLibrary;\n+use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n use rustc_ast::expand::allocator::{global_allocator_spans, AllocatorKind};\n use rustc_ast::{ast, attr};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::struct_span_err;\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::middle::cstore::DepKind;\n-use rustc_middle::middle::cstore::{\n-    CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn,\n-};\n+use rustc_middle::middle::cstore::{CrateSource, DepKind, ExternCrate};\n+use rustc_middle::middle::cstore::{ExternCrateSource, MetadataLoaderDyn};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, CrateType, ExternLocation};\n use rustc_session::lint;\n@@ -31,7 +29,7 @@ use rustc_target::spec::{PanicStrategy, TargetTriple};\n use log::{debug, info, log_enabled};\n use proc_macro::bridge::client::ProcMacro;\n use std::path::Path;\n-use std::{cmp, fs};\n+use std::{cmp, env, fs};\n \n #[derive(Clone)]\n pub struct CStore {\n@@ -69,18 +67,6 @@ enum LoadResult {\n     Loaded(Library),\n }\n \n-enum LoadError<'a> {\n-    LocatorError(CrateLocator<'a>),\n-}\n-\n-impl<'a> LoadError<'a> {\n-    fn report(self) -> ! {\n-        match self {\n-            LoadError::LocatorError(locator) => locator.report_errs(),\n-        }\n-    }\n-}\n-\n /// A reference to `CrateMetadata` that can also give access to whole crate store when necessary.\n #[derive(Clone, Copy)]\n crate struct CrateMetadataRef<'a> {\n@@ -280,60 +266,43 @@ impl<'a> CrateLoader<'a> {\n         ret\n     }\n \n-    fn verify_no_symbol_conflicts(&self, span: Span, root: &CrateRoot<'_>) {\n+    fn verify_no_symbol_conflicts(&self, root: &CrateRoot<'_>) -> Result<(), CrateError> {\n         // Check for (potential) conflicts with the local crate\n         if self.local_crate_name == root.name()\n             && self.sess.local_crate_disambiguator() == root.disambiguator()\n         {\n-            struct_span_err!(\n-                self.sess,\n-                span,\n-                E0519,\n-                \"the current crate is indistinguishable from one of its \\\n-                         dependencies: it has the same crate-name `{}` and was \\\n-                         compiled with the same `-C metadata` arguments. This \\\n-                         will result in symbol conflicts between the two.\",\n-                root.name()\n-            )\n-            .emit()\n+            return Err(CrateError::SymbolConflictsCurrent(root.name()));\n         }\n \n         // Check for conflicts with any crate loaded so far\n+        let mut res = Ok(());\n         self.cstore.iter_crate_data(|_, other| {\n             if other.name() == root.name() && // same crate-name\n-               other.disambiguator() == root.disambiguator() &&  // same crate-disambiguator\n+               other.disambiguator() == root.disambiguator() && // same crate-disambiguator\n                other.hash() != root.hash()\n             {\n                 // but different SVH\n-                struct_span_err!(\n-                    self.sess,\n-                    span,\n-                    E0523,\n-                    \"found two different crates with name `{}` that are \\\n-                         not distinguished by differing `-C metadata`. This \\\n-                         will result in symbol conflicts between the two.\",\n-                    root.name()\n-                )\n-                .emit();\n+                res = Err(CrateError::SymbolConflictsOthers(root.name()));\n             }\n         });\n+\n+        res\n     }\n \n     fn register_crate(\n         &mut self,\n         host_lib: Option<Library>,\n         root: Option<&CratePaths>,\n-        span: Span,\n         lib: Library,\n         dep_kind: DepKind,\n         name: Symbol,\n-    ) -> CrateNum {\n+    ) -> Result<CrateNum, CrateError> {\n         let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n \n         let Library { source, metadata } = lib;\n         let crate_root = metadata.get_root();\n         let host_hash = host_lib.as_ref().map(|lib| lib.metadata.get_root().hash());\n-        self.verify_no_symbol_conflicts(span, &crate_root);\n+        self.verify_no_symbol_conflicts(&crate_root)?;\n \n         let private_dep =\n             self.sess.opts.externs.get(&name.as_str()).map(|e| e.is_private_dep).unwrap_or(false);\n@@ -353,7 +322,7 @@ impl<'a> CrateLoader<'a> {\n             &crate_paths\n         };\n \n-        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n+        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, dep_kind)?;\n \n         let raw_proc_macros = if crate_root.is_proc_macro_crate() {\n             let temp_root;\n@@ -365,7 +334,7 @@ impl<'a> CrateLoader<'a> {\n                 None => (&source, &crate_root),\n             };\n             let dlsym_dylib = dlsym_source.dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n-            Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator(), span))\n+            Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator())?)\n         } else {\n             None\n         };\n@@ -386,14 +355,14 @@ impl<'a> CrateLoader<'a> {\n             ),\n         );\n \n-        cnum\n+        Ok(cnum)\n     }\n \n     fn load_proc_macro<'b>(\n         &self,\n         locator: &mut CrateLocator<'b>,\n         path_kind: PathKind,\n-    ) -> Option<(LoadResult, Option<Library>)>\n+    ) -> Result<Option<(LoadResult, Option<Library>)>, CrateError>\n     where\n         'a: 'b,\n     {\n@@ -408,8 +377,11 @@ impl<'a> CrateLoader<'a> {\n         let (locator, target_result) = if self.sess.opts.debugging_opts.dual_proc_macros {\n             proc_macro_locator.reset();\n             let result = match self.load(&mut proc_macro_locator)? {\n-                LoadResult::Previous(cnum) => return Some((LoadResult::Previous(cnum), None)),\n-                LoadResult::Loaded(library) => Some(LoadResult::Loaded(library)),\n+                Some(LoadResult::Previous(cnum)) => {\n+                    return Ok(Some((LoadResult::Previous(cnum), None)));\n+                }\n+                Some(LoadResult::Loaded(library)) => Some(LoadResult::Loaded(library)),\n+                None => return Ok(None),\n             };\n             locator.hash = locator.host_hash;\n             // Use the locator when looking for the host proc macro crate, as that is required\n@@ -427,9 +399,12 @@ impl<'a> CrateLoader<'a> {\n         locator.triple = TargetTriple::from_triple(config::host_triple());\n         locator.filesearch = self.sess.host_filesearch(path_kind);\n \n-        let host_result = self.load(locator)?;\n+        let host_result = match self.load(locator)? {\n+            Some(host_result) => host_result,\n+            None => return Ok(None),\n+        };\n \n-        Some(if self.sess.opts.debugging_opts.dual_proc_macros {\n+        Ok(Some(if self.sess.opts.debugging_opts.dual_proc_macros {\n             let host_result = match host_result {\n                 LoadResult::Previous(..) => {\n                     panic!(\"host and target proc macros must be loaded in lock-step\")\n@@ -439,7 +414,7 @@ impl<'a> CrateLoader<'a> {\n             (target_result.unwrap(), Some(host_result))\n         } else {\n             (host_result, None)\n-        })\n+        }))\n     }\n \n     fn resolve_crate<'b>(\n@@ -452,25 +427,20 @@ impl<'a> CrateLoader<'a> {\n         if dep.is_none() {\n             self.used_extern_options.insert(name);\n         }\n-        if !name.as_str().is_ascii() {\n-            self.sess\n-                .struct_span_err(\n-                    span,\n-                    &format!(\"cannot load a crate with a non-ascii name `{}`\", name,),\n-                )\n-                .emit();\n-        }\n-        self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n+        self.maybe_resolve_crate(name, dep_kind, dep)\n+            .unwrap_or_else(|err| err.report(self.sess, span))\n     }\n \n     fn maybe_resolve_crate<'b>(\n         &'b mut self,\n         name: Symbol,\n-        span: Span,\n         mut dep_kind: DepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n-    ) -> Result<CrateNum, LoadError<'b>> {\n+    ) -> Result<CrateNum, CrateError> {\n         info!(\"resolving crate `{}`\", name);\n+        if !name.as_str().is_ascii() {\n+            return Err(CrateError::NonAsciiName(name));\n+        }\n         let (root, hash, host_hash, extra_filename, path_kind) = match dep {\n             Some((root, dep)) => (\n                 Some(root),\n@@ -494,18 +464,20 @@ impl<'a> CrateLoader<'a> {\n                 extra_filename,\n                 false, // is_host\n                 path_kind,\n-                span,\n                 root,\n                 Some(false), // is_proc_macro\n             );\n \n-            self.load(&mut locator)\n-                .map(|r| (r, None))\n-                .or_else(|| {\n+            match self.load(&mut locator)? {\n+                Some(res) => (res, None),\n+                None => {\n                     dep_kind = DepKind::MacrosOnly;\n-                    self.load_proc_macro(&mut locator, path_kind)\n-                })\n-                .ok_or_else(move || LoadError::LocatorError(locator))?\n+                    match self.load_proc_macro(&mut locator, path_kind)? {\n+                        Some(res) => res,\n+                        None => return Err(locator.into_error()),\n+                    }\n+                }\n+            }\n         };\n \n         match result {\n@@ -518,14 +490,17 @@ impl<'a> CrateLoader<'a> {\n                 Ok(cnum)\n             }\n             (LoadResult::Loaded(library), host_library) => {\n-                Ok(self.register_crate(host_library, root, span, library, dep_kind, name))\n+                self.register_crate(host_library, root, library, dep_kind, name)\n             }\n             _ => panic!(),\n         }\n     }\n \n-    fn load(&self, locator: &mut CrateLocator<'_>) -> Option<LoadResult> {\n-        let library = locator.maybe_load_library_crate()?;\n+    fn load(&self, locator: &mut CrateLocator<'_>) -> Result<Option<LoadResult>, CrateError> {\n+        let library = match locator.maybe_load_library_crate()? {\n+            Some(library) => library,\n+            None => return Ok(None),\n+        };\n \n         // In the case that we're loading a crate, but not matching\n         // against a hash, we could load a crate which has the same hash\n@@ -536,7 +511,7 @@ impl<'a> CrateLoader<'a> {\n         // don't want to match a host crate against an equivalent target one\n         // already loaded.\n         let root = library.metadata.get_root();\n-        if locator.triple == self.sess.opts.target_triple {\n+        Ok(Some(if locator.triple == self.sess.opts.target_triple {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n                 if data.name() == root.name() && root.hash() == data.hash() {\n@@ -545,10 +520,10 @@ impl<'a> CrateLoader<'a> {\n                     result = LoadResult::Previous(cnum);\n                 }\n             });\n-            Some(result)\n+            result\n         } else {\n-            Some(LoadResult::Loaded(library))\n-        }\n+            LoadResult::Loaded(library)\n+        }))\n     }\n \n     fn update_extern_crate(&self, cnum: CrateNum, extern_crate: ExternCrate) {\n@@ -569,53 +544,51 @@ impl<'a> CrateLoader<'a> {\n         crate_root: &CrateRoot<'_>,\n         metadata: &MetadataBlob,\n         krate: CrateNum,\n-        span: Span,\n         dep_kind: DepKind,\n-    ) -> CrateNumMap {\n+    ) -> Result<CrateNumMap, CrateError> {\n         debug!(\"resolving deps of external crate\");\n         if crate_root.is_proc_macro_crate() {\n-            return CrateNumMap::new();\n+            return Ok(CrateNumMap::new());\n         }\n \n         // The map from crate numbers in the crate we're resolving to local crate numbers.\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n-        std::iter::once(krate)\n-            .chain(crate_root.decode_crate_deps(metadata).map(|dep| {\n-                info!(\n-                    \"resolving dep crate {} hash: `{}` extra filename: `{}`\",\n-                    dep.name, dep.hash, dep.extra_filename\n-                );\n-                let dep_kind = match dep_kind {\n-                    DepKind::MacrosOnly => DepKind::MacrosOnly,\n-                    _ => dep.kind,\n-                };\n-                self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep)))\n-            }))\n-            .collect()\n+        let deps = crate_root.decode_crate_deps(metadata);\n+        let mut crate_num_map = CrateNumMap::with_capacity(1 + deps.len());\n+        crate_num_map.push(krate);\n+        for dep in deps {\n+            info!(\n+                \"resolving dep crate {} hash: `{}` extra filename: `{}`\",\n+                dep.name, dep.hash, dep.extra_filename\n+            );\n+            let dep_kind = match dep_kind {\n+                DepKind::MacrosOnly => DepKind::MacrosOnly,\n+                _ => dep.kind,\n+            };\n+            let cnum = self.maybe_resolve_crate(dep.name, dep_kind, Some((root, &dep)))?;\n+            crate_num_map.push(cnum);\n+        }\n+        Ok(crate_num_map)\n     }\n \n     fn dlsym_proc_macros(\n         &self,\n         path: &Path,\n         disambiguator: CrateDisambiguator,\n-        span: Span,\n-    ) -> &'static [ProcMacro] {\n-        use crate::dynamic_lib::DynamicLibrary;\n-        use std::env;\n-\n+    ) -> Result<&'static [ProcMacro], CrateError> {\n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(path);\n         let lib = match DynamicLibrary::open(&path) {\n             Ok(lib) => lib,\n-            Err(err) => self.sess.span_fatal(span, &err),\n+            Err(s) => return Err(CrateError::DlOpen(s)),\n         };\n \n         let sym = self.sess.generate_proc_macro_decls_symbol(disambiguator);\n         let decls = unsafe {\n             let sym = match lib.symbol(&sym) {\n                 Ok(f) => f,\n-                Err(err) => self.sess.span_fatal(span, &err),\n+                Err(s) => return Err(CrateError::DlSym(s)),\n             };\n             *(sym as *const &[ProcMacro])\n         };\n@@ -624,7 +597,7 @@ impl<'a> CrateLoader<'a> {\n         // since the library can make things that will live arbitrarily long.\n         std::mem::forget(lib);\n \n-        decls\n+        Ok(decls)\n     }\n \n     fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n@@ -952,7 +925,7 @@ impl<'a> CrateLoader<'a> {\n         cnum\n     }\n \n-    pub fn maybe_process_path_extern(&mut self, name: Symbol, span: Span) -> Option<CrateNum> {\n-        self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()\n+    pub fn maybe_process_path_extern(&mut self, name: Symbol) -> Option<CrateNum> {\n+        self.maybe_resolve_crate(name, DepKind::Explicit, None).ok()\n     }\n }"}, {"sha": "371ec4cd91148686345129677de65ed4b2735503", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 357, "deletions": 316, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -216,9 +216,10 @@ use crate::creader::Library;\n use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n-use rustc_errors::{struct_span_err, DiagnosticBuilder};\n+use rustc_errors::struct_span_err;\n use rustc_middle::middle::cstore::{CrateSource, MetadataLoader};\n use rustc_session::config::{self, CrateType};\n use rustc_session::filesearch::{FileDoesntMatch, FileMatches, FileSearch};\n@@ -228,24 +229,12 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::{Target, TargetTriple};\n \n-use std::cmp;\n-use std::fmt;\n-use std::fs;\n-use std::io::{self, Read};\n-use std::ops::Deref;\n-use std::path::{Path, PathBuf};\n-\n use flate2::read::DeflateDecoder;\n-\n-use rustc_data_structures::owning_ref::OwningRef;\n-\n use log::{debug, info, warn};\n-\n-#[derive(Clone)]\n-struct CrateMismatch {\n-    path: PathBuf,\n-    got: String,\n-}\n+use std::io::{Read, Result as IoResult, Write};\n+use std::ops::Deref;\n+use std::path::{Path, PathBuf};\n+use std::{cmp, fmt, fs};\n \n #[derive(Clone)]\n crate struct CrateLocator<'a> {\n@@ -262,7 +251,6 @@ crate struct CrateLocator<'a> {\n     pub target: &'a Target,\n     pub triple: TargetTriple,\n     pub filesearch: FileSearch<'a>,\n-    span: Span,\n     root: Option<&'a CratePaths>,\n     pub is_proc_macro: Option<bool>,\n \n@@ -274,6 +262,7 @@ crate struct CrateLocator<'a> {\n     rejected_via_filename: Vec<CrateMismatch>,\n }\n \n+#[derive(Clone)]\n crate struct CratePaths {\n     name: Symbol,\n     source: CrateSource,\n@@ -286,7 +275,7 @@ impl CratePaths {\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-enum CrateFlavor {\n+crate enum CrateFlavor {\n     Rlib,\n     Rmeta,\n     Dylib,\n@@ -312,7 +301,6 @@ impl<'a> CrateLocator<'a> {\n         extra_filename: Option<&'a str>,\n         is_host: bool,\n         path_kind: PathKind,\n-        span: Span,\n         root: Option<&'a CratePaths>,\n         is_proc_macro: Option<bool>,\n     ) -> CrateLocator<'a> {\n@@ -348,7 +336,6 @@ impl<'a> CrateLocator<'a> {\n             } else {\n                 sess.target_filesearch(path_kind)\n             },\n-            span,\n             root,\n             is_proc_macro,\n             rejected_via_hash: Vec::new(),\n@@ -367,158 +354,24 @@ impl<'a> CrateLocator<'a> {\n         self.rejected_via_filename.clear();\n     }\n \n-    crate fn maybe_load_library_crate(&mut self) -> Option<Library> {\n+    crate fn maybe_load_library_crate(&mut self) -> Result<Option<Library>, CrateError> {\n         if !self.exact_paths.is_empty() {\n             return self.find_commandline_library();\n         }\n         let mut seen_paths = FxHashSet::default();\n-        match self.extra_filename {\n-            Some(s) => self\n-                .find_library_crate(s, &mut seen_paths)\n-                .or_else(|| self.find_library_crate(\"\", &mut seen_paths)),\n-            None => self.find_library_crate(\"\", &mut seen_paths),\n-        }\n-    }\n-\n-    crate fn report_errs(self) -> ! {\n-        let add = match self.root {\n-            None => String::new(),\n-            Some(r) => format!(\" which `{}` depends on\", r.name),\n-        };\n-        let mut msg = \"the following crate versions were found:\".to_string();\n-        let mut err = if !self.rejected_via_hash.is_empty() {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0460,\n-                \"found possibly newer version of crate `{}`{}\",\n-                self.crate_name,\n-                add\n-            );\n-            err.note(\"perhaps that crate needs to be recompiled?\");\n-            let mismatches = self.rejected_via_hash.iter();\n-            for &CrateMismatch { ref path, .. } in mismatches {\n-                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.crate_name, path.display()));\n-            }\n-            match self.root {\n-                None => {}\n-                Some(r) => {\n-                    for path in r.source.paths() {\n-                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.name, path.display()));\n-                    }\n-                }\n-            }\n-            err.note(&msg);\n-            err\n-        } else if !self.rejected_via_triple.is_empty() {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0461,\n-                \"couldn't find crate `{}` \\\n-                                            with expected target triple {}{}\",\n-                self.crate_name,\n-                self.triple,\n-                add\n-            );\n-            let mismatches = self.rejected_via_triple.iter();\n-            for &CrateMismatch { ref path, ref got } in mismatches {\n-                msg.push_str(&format!(\n-                    \"\\ncrate `{}`, target triple {}: {}\",\n-                    self.crate_name,\n-                    got,\n-                    path.display()\n-                ));\n-            }\n-            err.note(&msg);\n-            err\n-        } else if !self.rejected_via_kind.is_empty() {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0462,\n-                \"found staticlib `{}` instead of rlib or dylib{}\",\n-                self.crate_name,\n-                add\n-            );\n-            err.help(\"please recompile that crate using --crate-type lib\");\n-            let mismatches = self.rejected_via_kind.iter();\n-            for &CrateMismatch { ref path, .. } in mismatches {\n-                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.crate_name, path.display()));\n-            }\n-            err.note(&msg);\n-            err\n-        } else if !self.rejected_via_version.is_empty() {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0514,\n-                \"found crate `{}` compiled by an incompatible version \\\n-                                            of rustc{}\",\n-                self.crate_name,\n-                add\n-            );\n-            err.help(&format!(\n-                \"please recompile that crate using this compiler ({})\",\n-                rustc_version()\n-            ));\n-            let mismatches = self.rejected_via_version.iter();\n-            for &CrateMismatch { ref path, ref got } in mismatches {\n-                msg.push_str(&format!(\n-                    \"\\ncrate `{}` compiled by {}: {}\",\n-                    self.crate_name,\n-                    got,\n-                    path.display()\n-                ));\n-            }\n-            err.note(&msg);\n-            err\n-        } else {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                self.span,\n-                E0463,\n-                \"can't find crate for `{}`{}\",\n-                self.crate_name,\n-                add\n-            );\n-\n-            if (self.crate_name == sym::std || self.crate_name == sym::core)\n-                && self.triple != TargetTriple::from_triple(config::host_triple())\n-            {\n-                err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n-            } else if self.crate_name == sym::profiler_builtins {\n-                err.note(&\"the compiler may have been built without the profiler runtime\");\n-            }\n-            err.span_label(self.span, \"can't find crate\");\n-            err\n-        };\n-\n-        if !self.rejected_via_filename.is_empty() {\n-            let mismatches = self.rejected_via_filename.iter();\n-            for &CrateMismatch { ref path, .. } in mismatches {\n-                err.note(&format!(\n-                    \"extern location for {} is of an unknown type: {}\",\n-                    self.crate_name,\n-                    path.display()\n-                ))\n-                .help(&format!(\n-                    \"file name should be lib*.rlib or {}*.{}\",\n-                    self.target.options.dll_prefix, self.target.options.dll_suffix\n-                ));\n+        if let Some(extra_filename) = self.extra_filename {\n+            if let library @ Some(_) = self.find_library_crate(extra_filename, &mut seen_paths)? {\n+                return Ok(library);\n             }\n         }\n-\n-        err.emit();\n-        self.sess.abort_if_errors();\n-        unreachable!();\n+        self.find_library_crate(\"\", &mut seen_paths)\n     }\n \n     fn find_library_crate(\n         &mut self,\n         extra_prefix: &str,\n         seen_paths: &mut FxHashSet<PathBuf>,\n-    ) -> Option<Library> {\n+    ) -> Result<Option<Library>, CrateError> {\n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n         let dylib_prefix =\n             format!(\"{}{}{}\", self.target.options.dll_prefix, self.crate_name, extra_prefix);\n@@ -572,26 +425,18 @@ impl<'a> CrateLocator<'a> {\n \n             info!(\"lib candidate: {}\", spf.path.display());\n \n-            let hash_str = hash.to_string();\n-            let slot = candidates.entry(hash_str).or_default();\n-            let (ref mut rlibs, ref mut rmetas, ref mut dylibs) = *slot;\n+            let (rlibs, rmetas, dylibs) = candidates.entry(hash.to_string()).or_default();\n             fs::canonicalize(&spf.path)\n                 .map(|p| {\n                     if seen_paths.contains(&p) {\n                         return FileDoesntMatch;\n                     };\n                     seen_paths.insert(p.clone());\n                     match found_kind {\n-                        CrateFlavor::Rlib => {\n-                            rlibs.insert(p, kind);\n-                        }\n-                        CrateFlavor::Rmeta => {\n-                            rmetas.insert(p, kind);\n-                        }\n-                        CrateFlavor::Dylib => {\n-                            dylibs.insert(p, kind);\n-                        }\n-                    }\n+                        CrateFlavor::Rlib => rlibs.insert(p, kind),\n+                        CrateFlavor::Rmeta => rmetas.insert(p, kind),\n+                        CrateFlavor::Dylib => dylibs.insert(p, kind),\n+                    };\n                     FileMatches\n                 })\n                 .unwrap_or(FileDoesntMatch)\n@@ -608,7 +453,7 @@ impl<'a> CrateLocator<'a> {\n         // search is being performed for.\n         let mut libraries = FxHashMap::default();\n         for (_hash, (rlibs, rmetas, dylibs)) in candidates {\n-            if let Some((svh, lib)) = self.extract_lib(rlibs, rmetas, dylibs) {\n+            if let Some((svh, lib)) = self.extract_lib(rlibs, rmetas, dylibs)? {\n                 libraries.insert(svh, lib);\n             }\n         }\n@@ -617,39 +462,9 @@ impl<'a> CrateLocator<'a> {\n         // what we've got and figure out if we found multiple candidates for\n         // libraries or not.\n         match libraries.len() {\n-            0 => None,\n-            1 => Some(libraries.into_iter().next().unwrap().1),\n-            _ => {\n-                let mut err = struct_span_err!(\n-                    self.sess,\n-                    self.span,\n-                    E0464,\n-                    \"multiple matching crates for `{}`\",\n-                    self.crate_name\n-                );\n-                let candidates = libraries\n-                    .iter()\n-                    .filter_map(|(_, lib)| {\n-                        let crate_name = &lib.metadata.get_root().name().as_str();\n-                        match &(&lib.source.dylib, &lib.source.rlib) {\n-                            &(&Some((ref pd, _)), &Some((ref pr, _))) => Some(format!(\n-                                \"\\ncrate `{}`: {}\\n{:>padding$}\",\n-                                crate_name,\n-                                pd.display(),\n-                                pr.display(),\n-                                padding = 8 + crate_name.len()\n-                            )),\n-                            &(&Some((ref p, _)), &None) | &(&None, &Some((ref p, _))) => {\n-                                Some(format!(\"\\ncrate `{}`: {}\", crate_name, p.display()))\n-                            }\n-                            &(&None, &None) => None,\n-                        }\n-                    })\n-                    .collect::<String>();\n-                err.note(&format!(\"candidates:{}\", candidates));\n-                err.emit();\n-                None\n-            }\n+            0 => Ok(None),\n+            1 => Ok(Some(libraries.into_iter().next().unwrap().1)),\n+            _ => Err(CrateError::MultipleMatchingCrates(self.crate_name, libraries)),\n         }\n     }\n \n@@ -658,16 +473,16 @@ impl<'a> CrateLocator<'a> {\n         rlibs: FxHashMap<PathBuf, PathKind>,\n         rmetas: FxHashMap<PathBuf, PathKind>,\n         dylibs: FxHashMap<PathBuf, PathKind>,\n-    ) -> Option<(Svh, Library)> {\n+    ) -> Result<Option<(Svh, Library)>, CrateError> {\n         let mut slot = None;\n         // Order here matters, rmeta should come first. See comment in\n         // `extract_one` below.\n         let source = CrateSource {\n-            rmeta: self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot),\n-            rlib: self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot),\n-            dylib: self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot),\n+            rmeta: self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot)?,\n+            rlib: self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot)?,\n+            dylib: self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot)?,\n         };\n-        slot.map(|(svh, metadata)| (svh, Library { source, metadata }))\n+        Ok(slot.map(|(svh, metadata)| (svh, Library { source, metadata })))\n     }\n \n     fn needs_crate_flavor(&self, flavor: CrateFlavor) -> bool {\n@@ -703,10 +518,7 @@ impl<'a> CrateLocator<'a> {\n         m: FxHashMap<PathBuf, PathKind>,\n         flavor: CrateFlavor,\n         slot: &mut Option<(Svh, MetadataBlob)>,\n-    ) -> Option<(PathBuf, PathKind)> {\n-        let mut ret: Option<(PathBuf, PathKind)> = None;\n-        let mut error = 0;\n-\n+    ) -> Result<Option<(PathBuf, PathKind)>, CrateError> {\n         // If we are producing an rlib, and we've already loaded metadata, then\n         // we should not attempt to discover further crate sources (unless we're\n         // locating a proc macro; exact logic is in needs_crate_flavor). This means\n@@ -723,13 +535,14 @@ impl<'a> CrateLocator<'a> {\n         // from the other crate sources.\n         if slot.is_some() {\n             if m.is_empty() || !self.needs_crate_flavor(flavor) {\n-                return None;\n+                return Ok(None);\n             } else if m.len() == 1 {\n-                return Some(m.into_iter().next().unwrap());\n+                return Ok(Some(m.into_iter().next().unwrap()));\n             }\n         }\n \n-        let mut err: Option<DiagnosticBuilder<'_>> = None;\n+        let mut ret: Option<(PathBuf, PathKind)> = None;\n+        let mut err_data: Option<Vec<PathBuf>> = None;\n         for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let (hash, metadata) =\n@@ -749,30 +562,18 @@ impl<'a> CrateLocator<'a> {\n                 };\n             // If we see multiple hashes, emit an error about duplicate candidates.\n             if slot.as_ref().map_or(false, |s| s.0 != hash) {\n-                let mut e = struct_span_err!(\n-                    self.sess,\n-                    self.span,\n-                    E0465,\n-                    \"multiple {} candidates for `{}` found\",\n-                    flavor,\n-                    self.crate_name\n-                );\n-                e.span_note(\n-                    self.span,\n-                    &format!(r\"candidate #1: {}\", ret.as_ref().unwrap().0.display()),\n-                );\n-                if let Some(ref mut e) = err {\n-                    e.emit();\n+                if let Some(candidates) = err_data {\n+                    return Err(CrateError::MultipleCandidates(\n+                        self.crate_name,\n+                        flavor,\n+                        candidates,\n+                    ));\n                 }\n-                err = Some(e);\n-                error = 1;\n+                err_data = Some(vec![ret.as_ref().unwrap().0.clone()]);\n                 *slot = None;\n             }\n-            if error > 0 {\n-                error += 1;\n-                err.as_mut()\n-                    .unwrap()\n-                    .span_note(self.span, &format!(r\"candidate #{}: {}\", error, lib.display()));\n+            if let Some(candidates) = &mut err_data {\n+                candidates.push(lib);\n                 continue;\n             }\n \n@@ -795,7 +596,7 @@ impl<'a> CrateLocator<'a> {\n             // As a result, we favor the sysroot crate here. Note that the\n             // candidates are all canonicalized, so we canonicalize the sysroot\n             // as well.\n-            if let Some((ref prev, _)) = ret {\n+            if let Some((prev, _)) = &ret {\n                 let sysroot = &self.sess.sysroot;\n                 let sysroot = sysroot.canonicalize().unwrap_or_else(|_| sysroot.to_path_buf());\n                 if prev.starts_with(&sysroot) {\n@@ -806,11 +607,10 @@ impl<'a> CrateLocator<'a> {\n             ret = Some((lib, kind));\n         }\n \n-        if error > 0 {\n-            err.unwrap().emit();\n-            None\n+        if let Some(candidates) = err_data {\n+            Err(CrateError::MultipleCandidates(self.crate_name, flavor, candidates))\n         } else {\n-            ret\n+            Ok(ret)\n         }\n     }\n \n@@ -865,69 +665,59 @@ impl<'a> CrateLocator<'a> {\n         Some(hash)\n     }\n \n-    fn find_commandline_library(&mut self) -> Option<Library> {\n+    fn find_commandline_library(&mut self) -> Result<Option<Library>, CrateError> {\n         // First, filter out all libraries that look suspicious. We only accept\n         // files which actually exist that have the correct naming scheme for\n         // rlibs/dylibs.\n-        let sess = self.sess;\n         let mut rlibs = FxHashMap::default();\n         let mut rmetas = FxHashMap::default();\n         let mut dylibs = FxHashMap::default();\n-        {\n-            let crate_name = self.crate_name;\n-            let rejected_via_filename = &mut self.rejected_via_filename;\n-            let dll_prefix = &self.target.options.dll_prefix;\n-            let dll_suffix = &self.target.options.dll_suffix;\n-            let locs = self.exact_paths.iter().filter(|loc| {\n-                if !loc.exists() {\n-                    sess.err(&format!(\n-                        \"extern location for {} does not exist: {}\",\n-                        crate_name,\n-                        loc.display()\n-                    ));\n-                    return false;\n-                }\n-                let file = match loc.file_name().and_then(|s| s.to_str()) {\n-                    Some(file) => file,\n-                    None => {\n-                        sess.err(&format!(\n-                            \"extern location for {} is not a file: {}\",\n-                            crate_name,\n-                            loc.display()\n-                        ));\n-                        return false;\n-                    }\n-                };\n-                if file.starts_with(\"lib\") && (file.ends_with(\".rlib\") || file.ends_with(\".rmeta\"))\n-                {\n-                    return true;\n-                } else {\n-                    if file.starts_with(dll_prefix) && file.ends_with(dll_suffix) {\n-                        return true;\n-                    }\n+        for loc in &self.exact_paths {\n+            if !loc.exists() {\n+                return Err(CrateError::ExternLocationNotExist(self.crate_name, loc.clone()));\n+            }\n+            let file = match loc.file_name().and_then(|s| s.to_str()) {\n+                Some(file) => file,\n+                None => {\n+                    return Err(CrateError::ExternLocationNotFile(self.crate_name, loc.clone()));\n                 }\n+            };\n \n-                rejected_via_filename\n-                    .push(CrateMismatch { path: (*loc).clone(), got: String::new() });\n-\n-                false\n-            });\n-\n-            // Now that we have an iterator of good candidates, make sure\n-            // there's at most one rlib and at most one dylib.\n-            for loc in locs {\n+            if file.starts_with(\"lib\") && (file.ends_with(\".rlib\") || file.ends_with(\".rmeta\"))\n+                || file.starts_with(&self.target.options.dll_prefix)\n+                    && file.ends_with(&self.target.options.dll_suffix)\n+            {\n+                // Make sure there's at most one rlib and at most one dylib.\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n                     rlibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 } else if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rmeta\") {\n                     rmetas.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 } else {\n                     dylibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 }\n+            } else {\n+                self.rejected_via_filename\n+                    .push(CrateMismatch { path: loc.clone(), got: String::new() });\n             }\n-        };\n+        }\n \n         // Extract the dylib/rlib/rmeta triple.\n-        self.extract_lib(rlibs, rmetas, dylibs).map(|(_, lib)| lib)\n+        Ok(self.extract_lib(rlibs, rmetas, dylibs)?.map(|(_, lib)| lib))\n+    }\n+\n+    crate fn into_error(self) -> CrateError {\n+        CrateError::LocatorCombined(CombinedLocatorError {\n+            crate_name: self.crate_name,\n+            root: self.root.cloned(),\n+            triple: self.triple,\n+            dll_prefix: self.target.options.dll_prefix.clone(),\n+            dll_suffix: self.target.options.dll_suffix.clone(),\n+            rejected_via_hash: self.rejected_via_hash,\n+            rejected_via_triple: self.rejected_via_triple,\n+            rejected_via_kind: self.rejected_via_kind,\n+            rejected_via_version: self.rejected_via_version,\n+            rejected_via_filename: self.rejected_via_filename,\n+        })\n     }\n }\n \n@@ -1004,7 +794,18 @@ pub fn find_plugin_registrar(\n     metadata_loader: &dyn MetadataLoader,\n     span: Span,\n     name: Symbol,\n-) -> Option<(PathBuf, CrateDisambiguator)> {\n+) -> (PathBuf, CrateDisambiguator) {\n+    match find_plugin_registrar_impl(sess, metadata_loader, name) {\n+        Ok(res) => res,\n+        Err(err) => err.report(sess, span),\n+    }\n+}\n+\n+fn find_plugin_registrar_impl<'a>(\n+    sess: &'a Session,\n+    metadata_loader: &dyn MetadataLoader,\n+    name: Symbol,\n+) -> Result<(PathBuf, CrateDisambiguator), CrateError> {\n     info!(\"find plugin registrar `{}`\", name);\n     let mut locator = CrateLocator::new(\n         sess,\n@@ -1015,32 +816,16 @@ pub fn find_plugin_registrar(\n         None, // extra_filename\n         true, // is_host\n         PathKind::Crate,\n-        span,\n         None, // root\n         None, // is_proc_macro\n     );\n \n-    let library = match locator.maybe_load_library_crate() {\n-        Some(library) => library,\n-        None => locator.report_errs(),\n-    };\n-\n-    match library.source.dylib {\n-        Some(dylib) => Some((dylib.0, library.metadata.get_root().disambiguator())),\n-        None => {\n-            struct_span_err!(\n-                sess,\n-                span,\n-                E0457,\n-                \"plugin `{}` only found in rlib format, but must be available \\\n-                        in dylib format\",\n-                name\n-            )\n-            .emit();\n-            // No need to abort because the loading code will just ignore this\n-            // empty dylib.\n-            None\n-        }\n+    match locator.maybe_load_library_crate()? {\n+        Some(library) => match library.source.dylib {\n+            Some(dylib) => Ok((dylib.0, library.metadata.get_root().disambiguator())),\n+            None => Err(CrateError::NonDylibPlugin(name)),\n+        },\n+        None => Err(locator.into_error()),\n     }\n }\n \n@@ -1049,8 +834,8 @@ pub fn list_file_metadata(\n     target: &Target,\n     path: &Path,\n     metadata_loader: &dyn MetadataLoader,\n-    out: &mut dyn io::Write,\n-) -> io::Result<()> {\n+    out: &mut dyn Write,\n+) -> IoResult<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n     let flavor = if filename.ends_with(\".rlib\") {\n         CrateFlavor::Rlib\n@@ -1064,3 +849,259 @@ pub fn list_file_metadata(\n         Err(msg) => write!(out, \"{}\\n\", msg),\n     }\n }\n+\n+// ------------------------------------------ Error reporting -------------------------------------\n+\n+#[derive(Clone)]\n+struct CrateMismatch {\n+    path: PathBuf,\n+    got: String,\n+}\n+\n+/// Candidate rejection reasons collected during crate search.\n+/// If no candidate is accepted, then these reasons are presented to the user,\n+/// otherwise they are ignored.\n+crate struct CombinedLocatorError {\n+    crate_name: Symbol,\n+    root: Option<CratePaths>,\n+    triple: TargetTriple,\n+    dll_prefix: String,\n+    dll_suffix: String,\n+    rejected_via_hash: Vec<CrateMismatch>,\n+    rejected_via_triple: Vec<CrateMismatch>,\n+    rejected_via_kind: Vec<CrateMismatch>,\n+    rejected_via_version: Vec<CrateMismatch>,\n+    rejected_via_filename: Vec<CrateMismatch>,\n+}\n+\n+crate enum CrateError {\n+    NonAsciiName(Symbol),\n+    ExternLocationNotExist(Symbol, PathBuf),\n+    ExternLocationNotFile(Symbol, PathBuf),\n+    MultipleCandidates(Symbol, CrateFlavor, Vec<PathBuf>),\n+    MultipleMatchingCrates(Symbol, FxHashMap<Svh, Library>),\n+    SymbolConflictsCurrent(Symbol),\n+    SymbolConflictsOthers(Symbol),\n+    DlOpen(String),\n+    DlSym(String),\n+    LocatorCombined(CombinedLocatorError),\n+    NonDylibPlugin(Symbol),\n+}\n+\n+impl CrateError {\n+    crate fn report(self, sess: &Session, span: Span) -> ! {\n+        let mut err = match self {\n+            CrateError::NonAsciiName(crate_name) => sess.struct_span_err(\n+                span,\n+                &format!(\"cannot load a crate with a non-ascii name `{}`\", crate_name),\n+            ),\n+            CrateError::ExternLocationNotExist(crate_name, loc) => sess.struct_span_err(\n+                span,\n+                &format!(\"extern location for {} does not exist: {}\", crate_name, loc.display()),\n+            ),\n+            CrateError::ExternLocationNotFile(crate_name, loc) => sess.struct_span_err(\n+                span,\n+                &format!(\"extern location for {} is not a file: {}\", crate_name, loc.display()),\n+            ),\n+            CrateError::MultipleCandidates(crate_name, flavor, candidates) => {\n+                let mut err = struct_span_err!(\n+                    sess,\n+                    span,\n+                    E0465,\n+                    \"multiple {} candidates for `{}` found\",\n+                    flavor,\n+                    crate_name,\n+                );\n+                for (i, candidate) in candidates.iter().enumerate() {\n+                    err.span_note(span, &format!(\"candidate #{}: {}\", i + 1, candidate.display()));\n+                }\n+                err\n+            }\n+            CrateError::MultipleMatchingCrates(crate_name, libraries) => {\n+                let mut err = struct_span_err!(\n+                    sess,\n+                    span,\n+                    E0464,\n+                    \"multiple matching crates for `{}`\",\n+                    crate_name\n+                );\n+                let candidates = libraries\n+                    .iter()\n+                    .filter_map(|(_, lib)| {\n+                        let crate_name = &lib.metadata.get_root().name().as_str();\n+                        match (&lib.source.dylib, &lib.source.rlib) {\n+                            (Some((pd, _)), Some((pr, _))) => Some(format!(\n+                                \"\\ncrate `{}`: {}\\n{:>padding$}\",\n+                                crate_name,\n+                                pd.display(),\n+                                pr.display(),\n+                                padding = 8 + crate_name.len()\n+                            )),\n+                            (Some((p, _)), None) | (None, Some((p, _))) => {\n+                                Some(format!(\"\\ncrate `{}`: {}\", crate_name, p.display()))\n+                            }\n+                            (None, None) => None,\n+                        }\n+                    })\n+                    .collect::<String>();\n+                err.note(&format!(\"candidates:{}\", candidates));\n+                err\n+            }\n+            CrateError::SymbolConflictsCurrent(root_name) => struct_span_err!(\n+                sess,\n+                span,\n+                E0519,\n+                \"the current crate is indistinguishable from one of its dependencies: it has the \\\n+                 same crate-name `{}` and was compiled with the same `-C metadata` arguments. \\\n+                 This will result in symbol conflicts between the two.\",\n+                root_name,\n+            ),\n+            CrateError::SymbolConflictsOthers(root_name) => struct_span_err!(\n+                sess,\n+                span,\n+                E0523,\n+                \"found two different crates with name `{}` that are not distinguished by differing \\\n+                 `-C metadata`. This will result in symbol conflicts between the two.\",\n+                root_name,\n+            ),\n+            CrateError::DlOpen(s) | CrateError::DlSym(s) => sess.struct_span_err(span, &s),\n+            CrateError::LocatorCombined(locator) => {\n+                let crate_name = locator.crate_name;\n+                let add = match &locator.root {\n+                    None => String::new(),\n+                    Some(r) => format!(\" which `{}` depends on\", r.name),\n+                };\n+                let mut msg = \"the following crate versions were found:\".to_string();\n+                let mut err = if !locator.rejected_via_hash.is_empty() {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0460,\n+                        \"found possibly newer version of crate `{}`{}\",\n+                        crate_name,\n+                        add,\n+                    );\n+                    err.note(\"perhaps that crate needs to be recompiled?\");\n+                    let mismatches = locator.rejected_via_hash.iter();\n+                    for CrateMismatch { path, .. } in mismatches {\n+                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", crate_name, path.display()));\n+                    }\n+                    if let Some(r) = locator.root {\n+                        for path in r.source.paths() {\n+                            msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.name, path.display()));\n+                        }\n+                    }\n+                    err.note(&msg);\n+                    err\n+                } else if !locator.rejected_via_triple.is_empty() {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0461,\n+                        \"couldn't find crate `{}` with expected target triple {}{}\",\n+                        crate_name,\n+                        locator.triple,\n+                        add,\n+                    );\n+                    let mismatches = locator.rejected_via_triple.iter();\n+                    for CrateMismatch { path, got } in mismatches {\n+                        msg.push_str(&format!(\n+                            \"\\ncrate `{}`, target triple {}: {}\",\n+                            crate_name,\n+                            got,\n+                            path.display(),\n+                        ));\n+                    }\n+                    err.note(&msg);\n+                    err\n+                } else if !locator.rejected_via_kind.is_empty() {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0462,\n+                        \"found staticlib `{}` instead of rlib or dylib{}\",\n+                        crate_name,\n+                        add,\n+                    );\n+                    err.help(\"please recompile that crate using --crate-type lib\");\n+                    let mismatches = locator.rejected_via_kind.iter();\n+                    for CrateMismatch { path, .. } in mismatches {\n+                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", crate_name, path.display()));\n+                    }\n+                    err.note(&msg);\n+                    err\n+                } else if !locator.rejected_via_version.is_empty() {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0514,\n+                        \"found crate `{}` compiled by an incompatible version of rustc{}\",\n+                        crate_name,\n+                        add,\n+                    );\n+                    err.help(&format!(\n+                        \"please recompile that crate using this compiler ({})\",\n+                        rustc_version(),\n+                    ));\n+                    let mismatches = locator.rejected_via_version.iter();\n+                    for CrateMismatch { path, got } in mismatches {\n+                        msg.push_str(&format!(\n+                            \"\\ncrate `{}` compiled by {}: {}\",\n+                            crate_name,\n+                            got,\n+                            path.display(),\n+                        ));\n+                    }\n+                    err.note(&msg);\n+                    err\n+                } else {\n+                    let mut err = struct_span_err!(\n+                        sess,\n+                        span,\n+                        E0463,\n+                        \"can't find crate for `{}`{}\",\n+                        crate_name,\n+                        add,\n+                    );\n+\n+                    if (crate_name == sym::std || crate_name == sym::core)\n+                        && locator.triple != TargetTriple::from_triple(config::host_triple())\n+                    {\n+                        err.note(&format!(\"the `{}` target may not be installed\", locator.triple));\n+                    } else if crate_name == sym::profiler_builtins {\n+                        err.note(&\"the compiler may have been built without the profiler runtime\");\n+                    }\n+                    err.span_label(span, \"can't find crate\");\n+                    err\n+                };\n+\n+                if !locator.rejected_via_filename.is_empty() {\n+                    let mismatches = locator.rejected_via_filename.iter();\n+                    for CrateMismatch { path, .. } in mismatches {\n+                        err.note(&format!(\n+                            \"extern location for {} is of an unknown type: {}\",\n+                            crate_name,\n+                            path.display(),\n+                        ))\n+                        .help(&format!(\n+                            \"file name should be lib*.rlib or {}*.{}\",\n+                            locator.dll_prefix, locator.dll_suffix\n+                        ));\n+                    }\n+                }\n+                err\n+            }\n+            CrateError::NonDylibPlugin(crate_name) => struct_span_err!(\n+                sess,\n+                span,\n+                E0457,\n+                \"plugin `{}` only found in rlib format, but must be available in dylib format\",\n+                crate_name,\n+            ),\n+        };\n+\n+        err.emit();\n+        sess.abort_if_errors();\n+        unreachable!();\n+    }\n+}"}, {"sha": "62a87b47a2f74e7215a85d1310841273289f7a16", "filename": "src/librustc_plugin_impl/load.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Flibrustc_plugin_impl%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Flibrustc_plugin_impl%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fload.rs?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -55,13 +55,11 @@ fn load_plugin(\n     metadata_loader: &dyn MetadataLoader,\n     ident: Ident,\n ) {\n-    let registrar = locator::find_plugin_registrar(sess, metadata_loader, ident.span, ident.name);\n-\n-    if let Some((lib, disambiguator)) = registrar {\n-        let symbol = sess.generate_plugin_registrar_symbol(disambiguator);\n-        let fun = dylink_registrar(sess, ident.span, lib, symbol);\n-        plugins.push(fun);\n-    }\n+    let (lib, disambiguator) =\n+        locator::find_plugin_registrar(sess, metadata_loader, ident.span, ident.name);\n+    let symbol = sess.generate_plugin_registrar_symbol(disambiguator);\n+    let fun = dylink_registrar(sess, ident.span, lib, symbol);\n+    plugins.push(fun);\n }\n \n // Dynamically link a registrar function into the compiler process."}, {"sha": "a7a005bdeb9f2e3b59b2d0796c2947bc6ae6dddd", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -859,9 +859,7 @@ impl<'a> Resolver<'a> {\n                     // otherwise cause duplicate suggestions.\n                     continue;\n                 }\n-                if let Some(crate_id) =\n-                    self.crate_loader.maybe_process_path_extern(ident.name, ident.span)\n-                {\n+                if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name) {\n                     let crate_root =\n                         self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                     suggestions.extend(self.lookup_import_candidates_from_module("}, {"sha": "9323c15a94109b9cdb6ad278051bcc451719cb8d", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -760,10 +760,8 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                         if !module.no_implicit_prelude {\n                             let extern_prelude = self.r.extern_prelude.clone();\n                             names.extend(extern_prelude.iter().flat_map(|(ident, _)| {\n-                                self.r\n-                                    .crate_loader\n-                                    .maybe_process_path_extern(ident.name, ident.span)\n-                                    .and_then(|crate_id| {\n+                                self.r.crate_loader.maybe_process_path_extern(ident.name).and_then(\n+                                    |crate_id| {\n                                         let crate_mod = Res::Def(\n                                             DefKind::Mod,\n                                             DefId { krate: crate_id, index: CRATE_DEF_INDEX },\n@@ -774,7 +772,8 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                                         } else {\n                                             None\n                                         }\n-                                    })\n+                                    },\n+                                )\n                             }));\n \n                             if let Some(prelude) = self.r.prelude {"}, {"sha": "da39f79efcd3bc487d8889a90a4d4bab146e8b29", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -2957,7 +2957,7 @@ impl<'a> Resolver<'a> {\n                 let crate_id = if !speculative {\n                     self.crate_loader.process_path_extern(ident.name, ident.span)\n                 } else {\n-                    self.crate_loader.maybe_process_path_extern(ident.name, ident.span)?\n+                    self.crate_loader.maybe_process_path_extern(ident.name)?\n                 };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 Some("}, {"sha": "d3cb5aaaeba89095fed6fbae4ac5cdfc7427d8ac", "filename": "src/test/compile-fail/empty-extern-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-extern-arg.rs?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -1,4 +1,4 @@\n // compile-flags: --extern std=\n-// error-pattern: can't find crate for `std`\n+// error-pattern: extern location for std does not exist\n \n fn main() {}"}, {"sha": "1fd514c6173290945a775d5873b56f72124593a8", "filename": "src/test/ui-fulldeps/macro-crate-rlib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.rs?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -1,10 +1,8 @@\n // aux-build:rlib-crate-test.rs\n-// ignore-tidy-linelength\n // ignore-cross-compile gives a different error message\n \n #![feature(plugin)]\n #![plugin(rlib_crate_test)]\n-//~^ ERROR: plugin `rlib_crate_test` only found in rlib format, but must be available in dylib format\n-//~| WARN use of deprecated attribute `plugin`: compiler plugins are deprecated\n+//~^ ERROR: plugin `rlib_crate_test` only found in rlib format, but must be available in dylib\n \n fn main() {}"}, {"sha": "7b31f28a26e7d3555411b265c23af8d0fd6fb50c", "filename": "src/test/ui-fulldeps/macro-crate-rlib.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-rlib.stderr?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -1,16 +1,8 @@\n error[E0457]: plugin `rlib_crate_test` only found in rlib format, but must be available in dylib format\n-  --> $DIR/macro-crate-rlib.rs:6:11\n+  --> $DIR/macro-crate-rlib.rs:5:11\n    |\n LL | #![plugin(rlib_crate_test)]\n    |           ^^^^^^^^^^^^^^^\n \n-warning: use of deprecated attribute `plugin`: compiler plugins are deprecated. See https://github.com/rust-lang/rust/pull/64675\n-  --> $DIR/macro-crate-rlib.rs:6:1\n-   |\n-LL | #![plugin(rlib_crate_test)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: may be removed in a future compiler version\n-   |\n-   = note: `#[warn(deprecated)]` on by default\n-\n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n "}, {"sha": "3ba124159e0002d41d448fa6bc885da5ffc118ad", "filename": "src/test/ui/extern/extern-prelude-no-speculative.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui%2Fextern%2Fextern-prelude-no-speculative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui%2Fextern%2Fextern-prelude-no-speculative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-prelude-no-speculative.rs?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n #![allow(unused_variables)]\n-// compile-flags: --extern LooksLikeExternCrate\n+// compile-flags: --extern LooksLikeExternCrate=/path/to/nowhere\n \n mod m {\n     pub struct LooksLikeExternCrate;"}, {"sha": "310545b92d5492d23f7d698790a9dfdcbe47001e", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -1,6 +1,5 @@\n #![feature(non_ascii_idents)]\n \n extern crate \u044c\u0430\u0433; //~ ERROR cannot load a crate with a non-ascii name `\u044c\u0430\u0433`\n-//~| ERROR can't find crate for `\u044c\u0430\u0433`\n \n fn main() {}"}, {"sha": "11108f2fb86789ce88b273be499e3a7c0a54b750", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-1.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -4,12 +4,5 @@ error: cannot load a crate with a non-ascii name `\u044c\u0430\u0433`\n LL | extern crate \u044c\u0430\u0433;\n    | ^^^^^^^^^^^^^^^^^\n \n-error[E0463]: can't find crate for `\u044c\u0430\u0433`\n-  --> $DIR/crate_name_nonascii_forbidden-1.rs:3:1\n-   |\n-LL | extern crate \u044c\u0430\u0433;\n-   | ^^^^^^^^^^^^^^^^^ can't find crate\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0463`."}, {"sha": "0249848b35ac0b12621a0b0739ba1e1dcd72f53f", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -3,7 +3,5 @@\n #![feature(non_ascii_idents)]\n \n use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz; //~  ERROR cannot load a crate with a non-ascii name `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n-                   //~| can't find crate for `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n-\n \n fn main() {}"}, {"sha": "8d3548ed33dcf8a70047df8c8cb1cbbe97382eab", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-2.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a4217d09f41d64f8be076c26d16d3474ca66c03/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr?ref=0a4217d09f41d64f8be076c26d16d3474ca66c03", "patch": "@@ -4,12 +4,5 @@ error: cannot load a crate with a non-ascii name `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n LL | use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz;\n    |     ^^^^^^^^\n \n-error[E0463]: can't find crate for `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n-  --> $DIR/crate_name_nonascii_forbidden-2.rs:5:5\n-   |\n-LL | use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz;\n-   |     ^^^^^^^^ can't find crate\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0463`."}]}