{"sha": "8ffc9444a3275079ce24883ec57b041485c358a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZmM5NDQ0YTMyNzUwNzljZTI0ODgzZWM1N2IwNDE0ODVjMzU4YTM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-25T17:19:08Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-25T17:36:05Z"}, "message": "Don't move stuff out of Compiler::enter.", "tree": {"sha": "025ae8bd3c8221387586d7fca2ccd78db2655b1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/025ae8bd3c8221387586d7fca2ccd78db2655b1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ffc9444a3275079ce24883ec57b041485c358a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ffc9444a3275079ce24883ec57b041485c358a3", "html_url": "https://github.com/rust-lang/rust/commit/8ffc9444a3275079ce24883ec57b041485c358a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ffc9444a3275079ce24883ec57b041485c358a3/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d01b6ccf0232c8bb1de73033d05c3e5e89b463f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d01b6ccf0232c8bb1de73033d05c3e5e89b463f", "html_url": "https://github.com/rust-lang/rust/commit/7d01b6ccf0232c8bb1de73033d05c3e5e89b463f"}], "stats": {"total": 242, "additions": 120, "deletions": 122}, "files": [{"sha": "b5b331928b967d0795118e1c39e8aad1859939bb", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 102, "deletions": 104, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/8ffc9444a3275079ce24883ec57b041485c358a3/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ffc9444a3275079ce24883ec57b041485c358a3/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=8ffc9444a3275079ce24883ec57b041485c358a3", "patch": "@@ -344,9 +344,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     };\n \n     interface::run_compiler_in_existing_thread_pool(config, |compiler| {\n-        let sess = compiler.session();\n+        compiler.enter(|queries| {\n+            let sess = compiler.session();\n \n-        let (resolver, mut global_ctxt) = compiler.enter(|queries| {\n             // We need to hold on to the complete resolver, so we cause everything to be\n             // cloned for the analysis passes to use. Suboptimal, but necessary in the\n             // current architecture.\n@@ -375,121 +375,119 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                 sess.fatal(\"Compilation failed, aborting rustdoc\");\n             }\n \n-            let global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n-\n-            (resolver, global_ctxt)\n-        });\n-\n-        global_ctxt.enter(|tcx| {\n-            tcx.analysis(LOCAL_CRATE).ok();\n-\n-            // Abort if there were any errors so far\n-            sess.abort_if_errors();\n-\n-            let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n-            // Convert from a HirId set to a DefId set since we don't always have easy access\n-            // to the map from defid -> hirid\n-            let access_levels = AccessLevels {\n-                map: access_levels.map.iter()\n-                                    .map(|(&k, &v)| (tcx.hir().local_def_id(k), v))\n-                                    .collect()\n-            };\n-\n-            let mut renderinfo = RenderInfo::default();\n-            renderinfo.access_levels = access_levels;\n-\n-            let mut ctxt = DocContext {\n-                tcx,\n-                resolver,\n-                external_traits: Default::default(),\n-                active_extern_traits: Default::default(),\n-                renderinfo: RefCell::new(renderinfo),\n-                ty_substs: Default::default(),\n-                lt_substs: Default::default(),\n-                ct_substs: Default::default(),\n-                impl_trait_bounds: Default::default(),\n-                fake_def_ids: Default::default(),\n-                all_fake_def_ids: Default::default(),\n-                generated_synthetics: Default::default(),\n-                auto_traits: tcx.all_traits(LOCAL_CRATE).iter().cloned().filter(|trait_def_id| {\n-                    tcx.trait_is_auto(*trait_def_id)\n-                }).collect(),\n-            };\n-            debug!(\"crate: {:?}\", tcx.hir().krate());\n-\n-            let mut krate = clean::krate(&mut ctxt);\n-\n-            fn report_deprecated_attr(name: &str, diag: &errors::Handler) {\n-                let mut msg = diag.struct_warn(&format!(\"the `#![doc({})]` attribute is \\\n-                                                         considered deprecated\", name));\n-                msg.warn(\"please see https://github.com/rust-lang/rust/issues/44136\");\n+            let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n+\n+            global_ctxt.enter(|tcx| {\n+                tcx.analysis(LOCAL_CRATE).ok();\n+\n+                // Abort if there were any errors so far\n+                sess.abort_if_errors();\n+\n+                let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n+                // Convert from a HirId set to a DefId set since we don't always have easy access\n+                // to the map from defid -> hirid\n+                let access_levels = AccessLevels {\n+                    map: access_levels.map.iter()\n+                                        .map(|(&k, &v)| (tcx.hir().local_def_id(k), v))\n+                                        .collect()\n+                };\n+\n+                let mut renderinfo = RenderInfo::default();\n+                renderinfo.access_levels = access_levels;\n+\n+                let mut ctxt = DocContext {\n+                    tcx,\n+                    resolver,\n+                    external_traits: Default::default(),\n+                    active_extern_traits: Default::default(),\n+                    renderinfo: RefCell::new(renderinfo),\n+                    ty_substs: Default::default(),\n+                    lt_substs: Default::default(),\n+                    ct_substs: Default::default(),\n+                    impl_trait_bounds: Default::default(),\n+                    fake_def_ids: Default::default(),\n+                    all_fake_def_ids: Default::default(),\n+                    generated_synthetics: Default::default(),\n+                    auto_traits: tcx.all_traits(LOCAL_CRATE).iter().cloned().filter(|trait_def_id| {\n+                        tcx.trait_is_auto(*trait_def_id)\n+                    }).collect(),\n+                };\n+                debug!(\"crate: {:?}\", tcx.hir().krate());\n+\n+                let mut krate = clean::krate(&mut ctxt);\n+\n+                fn report_deprecated_attr(name: &str, diag: &errors::Handler) {\n+                    let mut msg = diag.struct_warn(&format!(\"the `#![doc({})]` attribute is \\\n+                                                             considered deprecated\", name));\n+                    msg.warn(\"please see https://github.com/rust-lang/rust/issues/44136\");\n+\n+                    if name == \"no_default_passes\" {\n+                        msg.help(\"you may want to use `#![doc(document_private_items)]`\");\n+                    }\n \n-                if name == \"no_default_passes\" {\n-                    msg.help(\"you may want to use `#![doc(document_private_items)]`\");\n+                    msg.emit();\n                 }\n \n-                msg.emit();\n-            }\n-\n-            // Process all of the crate attributes, extracting plugin metadata along\n-            // with the passes which we are supposed to run.\n-            for attr in krate.module.as_ref().unwrap().attrs.lists(sym::doc) {\n-                let diag = ctxt.sess().diagnostic();\n-\n-                let name = attr.name_or_empty();\n-                if attr.is_word() {\n-                    if name == sym::no_default_passes {\n-                        report_deprecated_attr(\"no_default_passes\", diag);\n-                        if default_passes == passes::DefaultPassOption::Default {\n-                            default_passes = passes::DefaultPassOption::None;\n+                // Process all of the crate attributes, extracting plugin metadata along\n+                // with the passes which we are supposed to run.\n+                for attr in krate.module.as_ref().unwrap().attrs.lists(sym::doc) {\n+                    let diag = ctxt.sess().diagnostic();\n+\n+                    let name = attr.name_or_empty();\n+                    if attr.is_word() {\n+                        if name == sym::no_default_passes {\n+                            report_deprecated_attr(\"no_default_passes\", diag);\n+                            if default_passes == passes::DefaultPassOption::Default {\n+                                default_passes = passes::DefaultPassOption::None;\n+                            }\n+                        }\n+                    } else if let Some(value) = attr.value_str() {\n+                        let sink = match name {\n+                            sym::passes => {\n+                                report_deprecated_attr(\"passes = \\\"...\\\"\", diag);\n+                                &mut manual_passes\n+                            },\n+                            sym::plugins => {\n+                                report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n+                                eprintln!(\"WARNING: `#![doc(plugins = \\\"...\\\")]` \\\n+                                          no longer functions; see CVE-2018-1000622\");\n+                                continue\n+                            },\n+                            _ => continue,\n+                        };\n+                        for name in value.as_str().split_whitespace() {\n+                            sink.push(name.to_string());\n                         }\n                     }\n-                } else if let Some(value) = attr.value_str() {\n-                    let sink = match name {\n-                        sym::passes => {\n-                            report_deprecated_attr(\"passes = \\\"...\\\"\", diag);\n-                            &mut manual_passes\n-                        },\n-                        sym::plugins => {\n-                            report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n-                            eprintln!(\"WARNING: `#![doc(plugins = \\\"...\\\")]` no longer functions; \\\n-                                      see CVE-2018-1000622\");\n-                            continue\n-                        },\n-                        _ => continue,\n-                    };\n-                    for name in value.as_str().split_whitespace() {\n-                        sink.push(name.to_string());\n-                    }\n-                }\n \n-                if attr.is_word() && name == sym::document_private_items {\n-                    if default_passes == passes::DefaultPassOption::Default {\n-                        default_passes = passes::DefaultPassOption::Private;\n+                    if attr.is_word() && name == sym::document_private_items {\n+                        if default_passes == passes::DefaultPassOption::Default {\n+                            default_passes = passes::DefaultPassOption::Private;\n+                        }\n                     }\n                 }\n-            }\n \n-            let passes = passes::defaults(default_passes).iter().chain(manual_passes.into_iter()\n-                .flat_map(|name| {\n-                    if let Some(pass) = passes::find_pass(&name) {\n-                        Some(pass)\n-                    } else {\n-                        error!(\"unknown pass {}, skipping\", name);\n-                        None\n-                    }\n-                }));\n+                let passes = passes::defaults(default_passes).iter().chain(manual_passes.into_iter()\n+                    .flat_map(|name| {\n+                        if let Some(pass) = passes::find_pass(&name) {\n+                            Some(pass)\n+                        } else {\n+                            error!(\"unknown pass {}, skipping\", name);\n+                            None\n+                        }\n+                    }));\n \n-            info!(\"Executing passes\");\n+                info!(\"Executing passes\");\n \n-            for pass in passes {\n-                debug!(\"running pass {}\", pass.name);\n-                krate = (pass.pass)(krate, &ctxt);\n-            }\n+                for pass in passes {\n+                    debug!(\"running pass {}\", pass.name);\n+                    krate = (pass.pass)(krate, &ctxt);\n+                }\n \n-            ctxt.sess().abort_if_errors();\n+                ctxt.sess().abort_if_errors();\n \n-            (krate, ctxt.renderinfo.into_inner(), render_options)\n+                (krate, ctxt.renderinfo.into_inner(), render_options)\n+            })\n         })\n     })\n }"}, {"sha": "47eb993dfc31bc4142bd6528bfe36a5caa73d67d", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8ffc9444a3275079ce24883ec57b041485c358a3/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ffc9444a3275079ce24883ec57b041485c358a3/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=8ffc9444a3275079ce24883ec57b041485c358a3", "patch": "@@ -86,13 +86,13 @@ pub fn run(options: Options) -> i32 {\n     let display_warnings = options.display_warnings;\n \n     let tests = interface::run_compiler(config, |compiler| -> Result<_, ErrorReported> {\n-        let (mut collector, mut global_ctxt) = compiler.enter(|queries| {\n+        compiler.enter(|queries| {\n             let lower_to_hir = queries.lower_to_hir()?;\n \n             let mut opts = scrape_test_config(lower_to_hir.peek().0.borrow().krate());\n             opts.display_warnings |= options.display_warnings;\n             let enable_per_target_ignores = options.enable_per_target_ignores;\n-            let collector = Collector::new(\n+            let mut collector = Collector::new(\n                 queries.crate_name()?.peek().to_string(),\n                 options,\n                 false,\n@@ -102,24 +102,24 @@ pub fn run(options: Options) -> i32 {\n                 enable_per_target_ignores,\n             );\n \n-            let global_ctxt = queries.global_ctxt()?.take();\n-            Ok((collector, global_ctxt))\n-        })?;\n-        global_ctxt.enter(|tcx| {\n-            let krate = tcx.hir().krate();\n-            let mut hir_collector = HirCollector {\n-                sess: compiler.session(),\n-                collector: &mut collector,\n-                map: tcx.hir(),\n-                codes: ErrorCodes::from(compiler.session().opts\n-                                                .unstable_features.is_nightly_build()),\n-            };\n-            hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n-                intravisit::walk_crate(this, krate);\n+            let mut global_ctxt = queries.global_ctxt()?.take();\n+\n+            global_ctxt.enter(|tcx| {\n+                let krate = tcx.hir().krate();\n+                let mut hir_collector = HirCollector {\n+                    sess: compiler.session(),\n+                    collector: &mut collector,\n+                    map: tcx.hir(),\n+                    codes: ErrorCodes::from(compiler.session().opts\n+                                                    .unstable_features.is_nightly_build()),\n+                };\n+                hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n+                    intravisit::walk_crate(this, krate);\n+                });\n             });\n-        });\n \n-        Ok(collector.tests)\n+            Ok(collector.tests)\n+        })\n     }).expect(\"compiler aborted in rustdoc!\");\n \n     test_args.insert(0, \"rustdoctest\".to_string());"}]}