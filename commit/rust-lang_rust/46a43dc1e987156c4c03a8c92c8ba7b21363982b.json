{"sha": "46a43dc1e987156c4c03a8c92c8ba7b21363982b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2YTQzZGMxZTk4NzE1NmM0YzAzYThjOTJjOGJhN2IyMTM2Mzk4MmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-26T15:33:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-26T15:33:43Z"}, "message": "Auto merge of #57852 - davidtwco:issue-57819, r=estebank\n\nSuggest removing leading left angle brackets.\n\nFixes #57819.\n\nThis PR adds errors and accompanying suggestions as below:\n\n```\nbar::<<<<<T as Foo>::Output>();\n     ^^^ help: remove extra angle brackets\n```\n\nr? @estebank", "tree": {"sha": "dcd55be4f60a71d56ad29e2756791ef14820fa55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcd55be4f60a71d56ad29e2756791ef14820fa55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46a43dc1e987156c4c03a8c92c8ba7b21363982b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46a43dc1e987156c4c03a8c92c8ba7b21363982b", "html_url": "https://github.com/rust-lang/rust/commit/46a43dc1e987156c4c03a8c92c8ba7b21363982b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46a43dc1e987156c4c03a8c92c8ba7b21363982b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccd428befd2d90736a7c8d05ba35c430f59c9a11", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd428befd2d90736a7c8d05ba35c430f59c9a11", "html_url": "https://github.com/rust-lang/rust/commit/ccd428befd2d90736a7c8d05ba35c430f59c9a11"}, {"sha": "8ab12f6cc06033f483d085b37b766d681dcc61ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ab12f6cc06033f483d085b37b766d681dcc61ca", "html_url": "https://github.com/rust-lang/rust/commit/8ab12f6cc06033f483d085b37b766d681dcc61ca"}], "stats": {"total": 336, "additions": 328, "deletions": 8}, "files": [{"sha": "92da05a648152c04f84fdce10bd765139c29f699", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 190, "deletions": 8, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/46a43dc1e987156c4c03a8c92c8ba7b21363982b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a43dc1e987156c4c03a8c92c8ba7b21363982b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=46a43dc1e987156c4c03a8c92c8ba7b21363982b", "patch": "@@ -243,6 +243,12 @@ pub struct Parser<'a> {\n     desugar_doc_comments: bool,\n     /// Whether we should configure out of line modules as we parse.\n     pub cfg_mods: bool,\n+    /// This field is used to keep track of how many left angle brackets we have seen. This is\n+    /// required in order to detect extra leading left angle brackets (`<` characters) and error\n+    /// appropriately.\n+    ///\n+    /// See the comments in the `parse_path_segment` function for more details.\n+    crate unmatched_angle_bracket_count: u32,\n }\n \n \n@@ -564,6 +570,7 @@ impl<'a> Parser<'a> {\n             },\n             desugar_doc_comments,\n             cfg_mods: true,\n+            unmatched_angle_bracket_count: 0,\n         };\n \n         let tok = parser.next_tok();\n@@ -1028,7 +1035,7 @@ impl<'a> Parser<'a> {\n     /// starting token.\n     fn eat_lt(&mut self) -> bool {\n         self.expected_tokens.push(TokenType::Token(token::Lt));\n-        match self.token {\n+        let ate = match self.token {\n             token::Lt => {\n                 self.bump();\n                 true\n@@ -1039,7 +1046,15 @@ impl<'a> Parser<'a> {\n                 true\n             }\n             _ => false,\n+        };\n+\n+        if ate {\n+            // See doc comment for `unmatched_angle_bracket_count`.\n+            self.unmatched_angle_bracket_count += 1;\n+            debug!(\"eat_lt: (increment) count={:?}\", self.unmatched_angle_bracket_count);\n         }\n+\n+        ate\n     }\n \n     fn expect_lt(&mut self) -> PResult<'a, ()> {\n@@ -1055,24 +1070,35 @@ impl<'a> Parser<'a> {\n     /// signal an error.\n     fn expect_gt(&mut self) -> PResult<'a, ()> {\n         self.expected_tokens.push(TokenType::Token(token::Gt));\n-        match self.token {\n+        let ate = match self.token {\n             token::Gt => {\n                 self.bump();\n-                Ok(())\n+                Some(())\n             }\n             token::BinOp(token::Shr) => {\n                 let span = self.span.with_lo(self.span.lo() + BytePos(1));\n-                Ok(self.bump_with(token::Gt, span))\n+                Some(self.bump_with(token::Gt, span))\n             }\n             token::BinOpEq(token::Shr) => {\n                 let span = self.span.with_lo(self.span.lo() + BytePos(1));\n-                Ok(self.bump_with(token::Ge, span))\n+                Some(self.bump_with(token::Ge, span))\n             }\n             token::Ge => {\n                 let span = self.span.with_lo(self.span.lo() + BytePos(1));\n-                Ok(self.bump_with(token::Eq, span))\n+                Some(self.bump_with(token::Eq, span))\n             }\n-            _ => self.unexpected()\n+            _ => None,\n+        };\n+\n+        match ate {\n+            Some(x) => {\n+                // See doc comment for `unmatched_angle_bracket_count`.\n+                self.unmatched_angle_bracket_count -= 1;\n+                debug!(\"expect_gt: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n+\n+                Ok(x)\n+            },\n+            None => self.unexpected(),\n         }\n     }\n \n@@ -2115,7 +2141,11 @@ impl<'a> Parser<'a> {\n             path_span = self.span.to(self.span);\n         }\n \n+        // See doc comment for `unmatched_angle_bracket_count`.\n         self.expect(&token::Gt)?;\n+        self.unmatched_angle_bracket_count -= 1;\n+        debug!(\"parse_qpath: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n+\n         self.expect(&token::ModSep)?;\n \n         let qself = QSelf { ty, path_span, position: path.segments.len() };\n@@ -2238,9 +2268,15 @@ impl<'a> Parser<'a> {\n             }\n             let lo = self.span;\n \n+            // We use `style == PathStyle::Expr` to check if this is in a recursion or not. If\n+            // it isn't, then we reset the unmatched angle bracket count as we're about to start\n+            // parsing a new path.\n+            if style == PathStyle::Expr { self.unmatched_angle_bracket_count = 0; }\n+\n             let args = if self.eat_lt() {\n                 // `<'a, T, A = U>`\n-                let (args, bindings) = self.parse_generic_args()?;\n+                let (args, bindings) =\n+                    self.parse_generic_args_with_leaning_angle_bracket_recovery(style, lo)?;\n                 self.expect_gt()?;\n                 let span = lo.to(self.prev_span);\n                 AngleBracketedArgs { args, bindings, span }.into()\n@@ -5538,6 +5574,152 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Parse generic args (within a path segment) with recovery for extra leading angle brackets.\n+    /// For the purposes of understanding the parsing logic of generic arguments, this function\n+    /// can be thought of being the same as just calling `self.parse_generic_args()` if the source\n+    /// had the correct amount of leading angle brackets.\n+    ///\n+    /// ```ignore (diagnostics)\n+    /// bar::<<<<T as Foo>::Output>();\n+    ///      ^^ help: remove extra angle brackets\n+    /// ```\n+    fn parse_generic_args_with_leaning_angle_bracket_recovery(\n+        &mut self,\n+        style: PathStyle,\n+        lo: Span,\n+    ) -> PResult<'a, (Vec<GenericArg>, Vec<TypeBinding>)> {\n+        // We need to detect whether there are extra leading left angle brackets and produce an\n+        // appropriate error and suggestion. This cannot be implemented by looking ahead at\n+        // upcoming tokens for a matching `>` character - if there are unmatched `<` tokens\n+        // then there won't be matching `>` tokens to find.\n+        //\n+        // To explain how this detection works, consider the following example:\n+        //\n+        // ```ignore (diagnostics)\n+        // bar::<<<<T as Foo>::Output>();\n+        //      ^^ help: remove extra angle brackets\n+        // ```\n+        //\n+        // Parsing of the left angle brackets starts in this function. We start by parsing the\n+        // `<` token (incrementing the counter of unmatched angle brackets on `Parser` via\n+        // `eat_lt`):\n+        //\n+        // *Upcoming tokens:* `<<<<T as Foo>::Output>;`\n+        // *Unmatched count:* 1\n+        // *`parse_path_segment` calls deep:* 0\n+        //\n+        // This has the effect of recursing as this function is called if a `<` character\n+        // is found within the expected generic arguments:\n+        //\n+        // *Upcoming tokens:* `<<<T as Foo>::Output>;`\n+        // *Unmatched count:* 2\n+        // *`parse_path_segment` calls deep:* 1\n+        //\n+        // Eventually we will have recursed until having consumed all of the `<` tokens and\n+        // this will be reflected in the count:\n+        //\n+        // *Upcoming tokens:* `T as Foo>::Output>;`\n+        // *Unmatched count:* 4\n+        // `parse_path_segment` calls deep:* 3\n+        //\n+        // The parser will continue until reaching the first `>` - this will decrement the\n+        // unmatched angle bracket count and return to the parent invocation of this function\n+        // having succeeded in parsing:\n+        //\n+        // *Upcoming tokens:* `::Output>;`\n+        // *Unmatched count:* 3\n+        // *`parse_path_segment` calls deep:* 2\n+        //\n+        // This will continue until the next `>` character which will also return successfully\n+        // to the parent invocation of this function and decrement the count:\n+        //\n+        // *Upcoming tokens:* `;`\n+        // *Unmatched count:* 2\n+        // *`parse_path_segment` calls deep:* 1\n+        //\n+        // At this point, this function will expect to find another matching `>` character but\n+        // won't be able to and will return an error. This will continue all the way up the\n+        // call stack until the first invocation:\n+        //\n+        // *Upcoming tokens:* `;`\n+        // *Unmatched count:* 2\n+        // *`parse_path_segment` calls deep:* 0\n+        //\n+        // In doing this, we have managed to work out how many unmatched leading left angle\n+        // brackets there are, but we cannot recover as the unmatched angle brackets have\n+        // already been consumed. To remedy this, we keep a snapshot of the parser state\n+        // before we do the above. We can then inspect whether we ended up with a parsing error\n+        // and unmatched left angle brackets and if so, restore the parser state before we\n+        // consumed any `<` characters to emit an error and consume the erroneous tokens to\n+        // recover by attempting to parse again.\n+        //\n+        // In practice, the recursion of this function is indirect and there will be other\n+        // locations that consume some `<` characters - as long as we update the count when\n+        // this happens, it isn't an issue.\n+\n+        let is_first_invocation = style == PathStyle::Expr;\n+        // Take a snapshot before attempting to parse - we can restore this later.\n+        let snapshot = if is_first_invocation {\n+            Some(self.clone())\n+        } else {\n+            None\n+        };\n+\n+        debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n+        match self.parse_generic_args() {\n+            Ok(value) => Ok(value),\n+            Err(ref mut e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n+                // Cancel error from being unable to find `>`. We know the error\n+                // must have been this due to a non-zero unmatched angle bracket\n+                // count.\n+                e.cancel();\n+\n+                // Swap `self` with our backup of the parser state before attempting to parse\n+                // generic arguments.\n+                let snapshot = mem::replace(self, snapshot.unwrap());\n+\n+                debug!(\n+                    \"parse_generic_args_with_leading_angle_bracket_recovery: (snapshot failure) \\\n+                     snapshot.count={:?}\",\n+                    snapshot.unmatched_angle_bracket_count,\n+                );\n+\n+                // Eat the unmatched angle brackets.\n+                for _ in 0..snapshot.unmatched_angle_bracket_count {\n+                    self.eat_lt();\n+                }\n+\n+                // Make a span over ${unmatched angle bracket count} characters.\n+                let span = lo.with_hi(\n+                    lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count)\n+                );\n+                let plural = snapshot.unmatched_angle_bracket_count > 1;\n+                self.diagnostic()\n+                    .struct_span_err(\n+                        span,\n+                        &format!(\n+                            \"unmatched angle bracket{}\",\n+                            if plural { \"s\" } else { \"\" }\n+                        ),\n+                    )\n+                    .span_suggestion_with_applicability(\n+                        span,\n+                        &format!(\n+                            \"remove extra angle bracket{}\",\n+                            if plural { \"s\" } else { \"\" }\n+                        ),\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+\n+                // Try again without unmatched angle bracket characters.\n+                self.parse_generic_args()\n+            },\n+            Err(e) => Err(e),\n+        }\n+    }\n+\n     /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n     /// possibly including trailing comma.\n     fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<TypeBinding>)> {"}, {"sha": "3fab21db2d06e42035df10025f16c6902264bf50", "filename": "src/test/ui/issues/issue-57819.fixed", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/46a43dc1e987156c4c03a8c92c8ba7b21363982b/src%2Ftest%2Fui%2Fissues%2Fissue-57819.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/46a43dc1e987156c4c03a8c92c8ba7b21363982b/src%2Ftest%2Fui%2Fissues%2Fissue-57819.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57819.fixed?ref=46a43dc1e987156c4c03a8c92c8ba7b21363982b", "patch": "@@ -0,0 +1,47 @@\n+// run-rustfix\n+\n+#![allow(warnings)]\n+\n+// This test checks that the following error is emitted and the suggestion works:\n+//\n+// ```\n+// let _ = vec![1, 2, 3].into_iter().collect::<<<Vec<usize>>();\n+//                                            ^^ help: remove extra angle brackets\n+// ```\n+\n+trait Foo {\n+    type Output;\n+}\n+\n+fn foo<T: Foo>() {\n+    // More complex cases with more than one correct leading `<` character:\n+\n+    bar::<<T as Foo>::Output>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    bar::<<T as Foo>::Output>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    bar::<<T as Foo>::Output>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    bar::<<T as Foo>::Output>();\n+}\n+\n+fn bar<T>() {}\n+\n+fn main() {\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+}"}, {"sha": "5cafbf439be2dba4ee1bc4a5a72e6d9ac4b27376", "filename": "src/test/ui/issues/issue-57819.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/46a43dc1e987156c4c03a8c92c8ba7b21363982b/src%2Ftest%2Fui%2Fissues%2Fissue-57819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46a43dc1e987156c4c03a8c92c8ba7b21363982b/src%2Ftest%2Fui%2Fissues%2Fissue-57819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57819.rs?ref=46a43dc1e987156c4c03a8c92c8ba7b21363982b", "patch": "@@ -0,0 +1,47 @@\n+// run-rustfix\n+\n+#![allow(warnings)]\n+\n+// This test checks that the following error is emitted and the suggestion works:\n+//\n+// ```\n+// let _ = vec![1, 2, 3].into_iter().collect::<<<Vec<usize>>();\n+//                                            ^^ help: remove extra angle brackets\n+// ```\n+\n+trait Foo {\n+    type Output;\n+}\n+\n+fn foo<T: Foo>() {\n+    // More complex cases with more than one correct leading `<` character:\n+\n+    bar::<<<<<T as Foo>::Output>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    bar::<<<<T as Foo>::Output>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    bar::<<<T as Foo>::Output>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    bar::<<T as Foo>::Output>();\n+}\n+\n+fn bar<T>() {}\n+\n+fn main() {\n+    let _ = vec![1, 2, 3].into_iter().collect::<<<<<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<<<<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<<<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+}"}, {"sha": "493e9835b1ca9d6b6c22b3b4394d0126e8f96512", "filename": "src/test/ui/issues/issue-57819.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/46a43dc1e987156c4c03a8c92c8ba7b21363982b/src%2Ftest%2Fui%2Fissues%2Fissue-57819.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46a43dc1e987156c4c03a8c92c8ba7b21363982b/src%2Ftest%2Fui%2Fissues%2Fissue-57819.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57819.stderr?ref=46a43dc1e987156c4c03a8c92c8ba7b21363982b", "patch": "@@ -0,0 +1,44 @@\n+error: unmatched angle brackets\n+  --> $DIR/issue-57819.rs:19:10\n+   |\n+LL |     bar::<<<<<T as Foo>::Output>();\n+   |          ^^^ help: remove extra angle brackets\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-57819.rs:22:10\n+   |\n+LL |     bar::<<<<T as Foo>::Output>();\n+   |          ^^ help: remove extra angle brackets\n+\n+error: unmatched angle bracket\n+  --> $DIR/issue-57819.rs:25:10\n+   |\n+LL |     bar::<<<T as Foo>::Output>();\n+   |          ^ help: remove extra angle bracket\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-57819.rs:34:48\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<<<<<Vec<usize>>();\n+   |                                                ^^^^ help: remove extra angle brackets\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-57819.rs:37:48\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<<<<Vec<usize>>();\n+   |                                                ^^^ help: remove extra angle brackets\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-57819.rs:40:48\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<<<Vec<usize>>();\n+   |                                                ^^ help: remove extra angle brackets\n+\n+error: unmatched angle bracket\n+  --> $DIR/issue-57819.rs:43:48\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<<Vec<usize>>();\n+   |                                                ^ help: remove extra angle bracket\n+\n+error: aborting due to 7 previous errors\n+"}]}