{"sha": "d60bbde7e21f3e274263fe82f5c85b2a6c215020", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MGJiZGU3ZTIxZjNlMjc0MjYzZmU4MmY1Yzg1YjJhNmMyMTUwMjA=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-14T17:53:57Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-09-18T12:41:50Z"}, "message": "Do not preallocate UseTree HirIds.", "tree": {"sha": "700ca02e39407c5ea2ad3d8eba034ce7d98c9d51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/700ca02e39407c5ea2ad3d8eba034ce7d98c9d51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d60bbde7e21f3e274263fe82f5c85b2a6c215020", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d60bbde7e21f3e274263fe82f5c85b2a6c215020", "html_url": "https://github.com/rust-lang/rust/commit/d60bbde7e21f3e274263fe82f5c85b2a6c215020", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d60bbde7e21f3e274263fe82f5c85b2a6c215020/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59f43bdd299df167ea179c61b682911c486324b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/59f43bdd299df167ea179c61b682911c486324b1", "html_url": "https://github.com/rust-lang/rust/commit/59f43bdd299df167ea179c61b682911c486324b1"}], "stats": {"total": 67, "additions": 13, "deletions": 54}, "files": [{"sha": "d9133c711b5b6c906ebaa9262d3691523ac38291", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d60bbde7e21f3e274263fe82f5c85b2a6c215020/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60bbde7e21f3e274263fe82f5c85b2a6c215020/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=d60bbde7e21f3e274263fe82f5c85b2a6c215020", "patch": "@@ -475,7 +475,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     }\n                 }\n \n-                let mut resolutions = self.expect_full_res_from_use(id);\n+                let mut resolutions = self.expect_full_res_from_use(id).fuse();\n                 // We want to return *something* from this function, so hold onto the first item\n                 // for later.\n                 let ret_res = self.lower_res(resolutions.next().unwrap_or(Res::Err));\n@@ -485,7 +485,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // won't be dealing with macros in the rest of the compiler.\n                 // Essentially a single `use` which imports two names is desugared into\n                 // two imports.\n-                for (res, &new_node_id) in iter::zip(resolutions, &[id1, id2]) {\n+                for new_node_id in [id1, id2] {\n+                    // Associate an HirId to both ids even if there is no resolution.\n+                    let new_id = self.allocate_hir_id_counter(new_node_id);\n+\n+                    let res = if let Some(res) = resolutions.next() { res } else { continue };\n                     let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n@@ -494,17 +498,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let span = path.span;\n \n                     self.with_hir_id_owner(new_node_id, |this| {\n-                        let new_id = this.lower_node_id(new_node_id);\n                         let res = this.lower_res(res);\n                         let path = this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n                         let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n                         if let Some(attrs) = attrs {\n-                            this.attrs.insert(new_id, attrs);\n+                            this.attrs.insert(hir::HirId::make_owner(new_id), attrs);\n                         }\n \n                         this.insert_item(hir::Item {\n-                            def_id: new_id.expect_owner(),\n+                            def_id: new_id,\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis,\n@@ -553,7 +556,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 // Add all the nested `PathListItem`s to the HIR.\n                 for &(ref use_tree, id) in trees {\n-                    let new_hir_id = self.lower_node_id(id);\n+                    let new_hir_id = self.allocate_hir_id_counter(id);\n \n                     let mut prefix = prefix.clone();\n \n@@ -574,11 +577,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let kind =\n                             this.lower_use_tree(use_tree, &prefix, id, &mut vis, &mut ident, attrs);\n                         if let Some(attrs) = attrs {\n-                            this.attrs.insert(new_hir_id, attrs);\n+                            this.attrs.insert(hir::HirId::make_owner(new_hir_id), attrs);\n                         }\n \n                         this.insert_item(hir::Item {\n-                            def_id: new_hir_id.expect_owner(),\n+                            def_id: new_hir_id,\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis,"}, {"sha": "03b56a73771a5b47d1ae0661b320cdbe37ecaf7b", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d60bbde7e21f3e274263fe82f5c85b2a6c215020/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60bbde7e21f3e274263fe82f5c85b2a6c215020/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=d60bbde7e21f3e274263fe82f5c85b2a6c215020", "patch": "@@ -38,7 +38,7 @@\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream, TokenTree};\n-use rustc_ast::visit::{self, Visitor};\n+use rustc_ast::visit;\n use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::captures::Captures;\n@@ -418,48 +418,9 @@ enum AnonymousLifetimeMode {\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_crate(mut self, c: &Crate) -> &'hir hir::Crate<'hir> {\n-        /// Full-crate AST visitor that inserts into a fresh\n-        /// `LoweringContext` any information that may be\n-        /// needed from arbitrary locations in the crate,\n-        /// e.g., the number of lifetime generic parameters\n-        /// declared for every type and trait definition.\n-        struct MiscCollector<'tcx, 'lowering, 'hir> {\n-            lctx: &'tcx mut LoweringContext<'lowering, 'hir>,\n-        }\n-\n-        impl MiscCollector<'_, '_, '_> {\n-            fn allocate_use_tree_hir_id_counters(&mut self, tree: &UseTree) {\n-                match tree.kind {\n-                    UseTreeKind::Simple(_, id1, id2) => {\n-                        for id in [id1, id2] {\n-                            self.lctx.allocate_hir_id_counter(id);\n-                        }\n-                    }\n-                    UseTreeKind::Glob => (),\n-                    UseTreeKind::Nested(ref trees) => {\n-                        for &(ref use_tree, id) in trees {\n-                            self.lctx.allocate_hir_id_counter(id);\n-                            self.allocate_use_tree_hir_id_counters(use_tree);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        impl<'tcx> Visitor<'tcx> for MiscCollector<'tcx, '_, '_> {\n-            fn visit_item(&mut self, item: &'tcx Item) {\n-                if let ItemKind::Use(ref use_tree) = item.kind {\n-                    self.allocate_use_tree_hir_id_counters(use_tree);\n-                }\n-\n-                visit::walk_item(self, item);\n-            }\n-        }\n-\n         self.lower_node_id(CRATE_NODE_ID);\n         debug_assert!(self.node_id_to_hir_id[CRATE_NODE_ID] == Some(hir::CRATE_HIR_ID));\n \n-        visit::walk_crate(&mut MiscCollector { lctx: &mut self }, c);\n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n         let module = self.arena.alloc(self.lower_mod(&c.items, c.span));"}, {"sha": "495c5e1719765e74f7c0ff1dd8b8ea2f673bd9a0", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d60bbde7e21f3e274263fe82f5c85b2a6c215020/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d60bbde7e21f3e274263fe82f5c85b2a6c215020/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=d60bbde7e21f3e274263fe82f5c85b2a6c215020", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::svh::Svh;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -206,11 +206,6 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn opt_def_kind(&self, local_def_id: LocalDefId) -> Option<DefKind> {\n-        // FIXME(eddyb) support `find` on the crate root.\n-        if local_def_id.to_def_id().index == CRATE_DEF_INDEX {\n-            return Some(DefKind::Mod);\n-        }\n-\n         let hir_id = self.local_def_id_to_hir_id(local_def_id);\n         let def_kind = match self.find(hir_id)? {\n             Node::Item(item) => match item.kind {"}]}