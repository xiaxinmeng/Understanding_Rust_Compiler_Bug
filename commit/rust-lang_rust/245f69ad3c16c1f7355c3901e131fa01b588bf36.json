{"sha": "245f69ad3c16c1f7355c3901e131fa01b588bf36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NWY2OWFkM2MxNmMxZjczNTVjMzkwMWUxMzFmYTAxYjU4OGJmMzY=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-13T20:48:51Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-13T20:48:51Z"}, "message": "Refactor `resolve_link` into a separate function", "tree": {"sha": "ac25625a9a89134bb30c603ad0840a421d9d58bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac25625a9a89134bb30c603ad0840a421d9d58bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/245f69ad3c16c1f7355c3901e131fa01b588bf36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/245f69ad3c16c1f7355c3901e131fa01b588bf36", "html_url": "https://github.com/rust-lang/rust/commit/245f69ad3c16c1f7355c3901e131fa01b588bf36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/245f69ad3c16c1f7355c3901e131fa01b588bf36/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7402a394471a6738a40fea7d4f1891666e5a80c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7402a394471a6738a40fea7d4f1891666e5a80c5", "html_url": "https://github.com/rust-lang/rust/commit/7402a394471a6738a40fea7d4f1891666e5a80c5"}], "stats": {"total": 667, "additions": 342, "deletions": 325}, "files": [{"sha": "fd461925335cf3b097a6b33c2d3d8bb79eeefeef", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 342, "deletions": 325, "changes": 667, "blob_url": "https://github.com/rust-lang/rust/blob/245f69ad3c16c1f7355c3901e131fa01b588bf36/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/245f69ad3c16c1f7355c3901e131fa01b588bf36/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=245f69ad3c16c1f7355c3901e131fa01b588bf36", "patch": "@@ -843,7 +843,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             self.mod_ids.push(item.def_id);\n         }\n \n-        let cx = self.cx;\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n         trace!(\"got documentation '{}'\", dox);\n \n@@ -885,376 +884,394 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         });\n \n         for (ori_link, link_range) in markdown_links(&dox) {\n-            trace!(\"considering link '{}'\", ori_link);\n+            self.resolve_link(\n+                &mut item,\n+                &dox,\n+                &current_item,\n+                parent_node,\n+                &parent_name,\n+                ori_link,\n+                link_range,\n+            );\n+        }\n \n-            // Bail early for real links.\n-            if ori_link.contains('/') {\n-                continue;\n+        if item.is_mod() && !item.attrs.inner_docs {\n+            self.mod_ids.push(item.def_id);\n+        }\n+\n+        if item.is_mod() {\n+            let ret = self.fold_item_recur(item);\n+\n+            self.mod_ids.pop();\n+\n+            ret\n+        } else {\n+            self.fold_item_recur(item)\n+        }\n+    }\n+}\n+\n+impl LinkCollector<'_, '_> {\n+    fn resolve_link(\n+        &self,\n+        item: &mut Item,\n+        dox: &str,\n+        current_item: &Option<String>,\n+        parent_node: Option<DefId>,\n+        parent_name: &Option<String>,\n+        ori_link: String,\n+        link_range: Option<Range<usize>>,\n+    ) {\n+        trace!(\"considering link '{}'\", ori_link);\n+\n+        // Bail early for real links.\n+        if ori_link.contains('/') {\n+            return;\n+        }\n+\n+        // [] is mostly likely not supposed to be a link\n+        if ori_link.is_empty() {\n+            return;\n+        }\n+\n+        let cx = self.cx;\n+        let link = ori_link.replace(\"`\", \"\");\n+        let parts = link.split('#').collect::<Vec<_>>();\n+        let (link, extra_fragment) = if parts.len() > 2 {\n+            anchor_failure(cx, &item, &link, dox, link_range, AnchorFailure::MultipleAnchors);\n+            return;\n+        } else if parts.len() == 2 {\n+            if parts[0].trim().is_empty() {\n+                // This is an anchor to an element of the current page, nothing to do in here!\n+                return;\n+            }\n+            (parts[0], Some(parts[1].to_owned()))\n+        } else {\n+            (parts[0], None)\n+        };\n+        let resolved_self;\n+        let link_text;\n+        let mut path_str;\n+        let disambiguator;\n+        let (mut res, mut fragment) = {\n+            path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n+                disambiguator = Some(d);\n+                path\n+            } else {\n+                disambiguator = None;\n+                &link\n             }\n+            .trim();\n \n-            // [] is mostly likely not supposed to be a link\n-            if ori_link.is_empty() {\n-                continue;\n+            if path_str.contains(|ch: char| !(ch.is_alphanumeric() || ch == ':' || ch == '_')) {\n+                return;\n             }\n \n-            let link = ori_link.replace(\"`\", \"\");\n-            let parts = link.split('#').collect::<Vec<_>>();\n-            let (link, extra_fragment) = if parts.len() > 2 {\n-                anchor_failure(cx, &item, &link, &dox, link_range, AnchorFailure::MultipleAnchors);\n-                continue;\n-            } else if parts.len() == 2 {\n-                if parts[0].trim().is_empty() {\n-                    // This is an anchor to an element of the current page, nothing to do in here!\n-                    continue;\n-                }\n-                (parts[0], Some(parts[1].to_owned()))\n+            // We stripped `()` and `!` when parsing the disambiguator.\n+            // Add them back to be displayed, but not prefix disambiguators.\n+            link_text = disambiguator\n+                .map(|d| d.display_for(path_str))\n+                .unwrap_or_else(|| path_str.to_owned());\n+\n+            // In order to correctly resolve intra-doc-links we need to\n+            // pick a base AST node to work from.  If the documentation for\n+            // this module came from an inner comment (//!) then we anchor\n+            // our name resolution *inside* the module.  If, on the other\n+            // hand it was an outer comment (///) then we anchor the name\n+            // resolution in the parent module on the basis that the names\n+            // used are more likely to be intended to be parent names.  For\n+            // this, we set base_node to None for inner comments since\n+            // we've already pushed this node onto the resolution stack but\n+            // for outer comments we explicitly try and resolve against the\n+            // parent_node first.\n+            let base_node = if item.is_mod() && item.attrs.inner_docs {\n+                self.mod_ids.last().copied()\n             } else {\n-                (parts[0], None)\n+                parent_node\n             };\n-            let resolved_self;\n-            let link_text;\n-            let mut path_str;\n-            let disambiguator;\n-            let (mut res, mut fragment) = {\n-                path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n-                    disambiguator = Some(d);\n-                    path\n-                } else {\n-                    disambiguator = None;\n-                    &link\n-                }\n-                .trim();\n \n-                if path_str.contains(|ch: char| !(ch.is_alphanumeric() || ch == ':' || ch == '_')) {\n-                    continue;\n-                }\n-\n-                // We stripped `()` and `!` when parsing the disambiguator.\n-                // Add them back to be displayed, but not prefix disambiguators.\n-                link_text = disambiguator\n-                    .map(|d| d.display_for(path_str))\n-                    .unwrap_or_else(|| path_str.to_owned());\n-\n-                // In order to correctly resolve intra-doc-links we need to\n-                // pick a base AST node to work from.  If the documentation for\n-                // this module came from an inner comment (//!) then we anchor\n-                // our name resolution *inside* the module.  If, on the other\n-                // hand it was an outer comment (///) then we anchor the name\n-                // resolution in the parent module on the basis that the names\n-                // used are more likely to be intended to be parent names.  For\n-                // this, we set base_node to None for inner comments since\n-                // we've already pushed this node onto the resolution stack but\n-                // for outer comments we explicitly try and resolve against the\n-                // parent_node first.\n-                let base_node = if item.is_mod() && item.attrs.inner_docs {\n-                    self.mod_ids.last().copied()\n-                } else {\n-                    parent_node\n-                };\n-\n-                // replace `Self` with suitable item's parent name\n-                if path_str.starts_with(\"Self::\") {\n-                    if let Some(ref name) = parent_name {\n-                        resolved_self = format!(\"{}::{}\", name, &path_str[6..]);\n-                        path_str = &resolved_self;\n-                    }\n+            // replace `Self` with suitable item's parent name\n+            if path_str.starts_with(\"Self::\") {\n+                if let Some(ref name) = parent_name {\n+                    resolved_self = format!(\"{}::{}\", name, &path_str[6..]);\n+                    path_str = &resolved_self;\n                 }\n+            }\n \n-                match disambiguator.map(Disambiguator::ns) {\n-                    Some(ns @ (ValueNS | TypeNS)) => {\n-                        match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment)\n-                        {\n-                            Ok(res) => res,\n-                            Err(ErrorKind::Resolve(box mut kind)) => {\n-                                // We only looked in one namespace. Try to give a better error if possible.\n-                                if kind.full_res().is_none() {\n-                                    let other_ns = if ns == ValueNS { TypeNS } else { ValueNS };\n-                                    for &new_ns in &[other_ns, MacroNS] {\n-                                        if let Some(res) = self.check_full_res(\n-                                            new_ns,\n-                                            path_str,\n-                                            base_node,\n-                                            &current_item,\n-                                            &extra_fragment,\n-                                        ) {\n-                                            kind = ResolutionFailure::WrongNamespace(res, ns);\n-                                            break;\n-                                        }\n+            match disambiguator.map(Disambiguator::ns) {\n+                Some(ns @ (ValueNS | TypeNS)) => {\n+                    match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment) {\n+                        Ok(res) => res,\n+                        Err(ErrorKind::Resolve(box mut kind)) => {\n+                            // We only looked in one namespace. Try to give a better error if possible.\n+                            if kind.full_res().is_none() {\n+                                let other_ns = if ns == ValueNS { TypeNS } else { ValueNS };\n+                                for &new_ns in &[other_ns, MacroNS] {\n+                                    if let Some(res) = self.check_full_res(\n+                                        new_ns,\n+                                        path_str,\n+                                        base_node,\n+                                        &current_item,\n+                                        &extra_fragment,\n+                                    ) {\n+                                        kind = ResolutionFailure::WrongNamespace(res, ns);\n+                                        break;\n                                     }\n                                 }\n-                                resolution_failure(\n-                                    self,\n-                                    &item,\n-                                    path_str,\n-                                    disambiguator,\n-                                    &dox,\n-                                    link_range,\n-                                    smallvec![kind],\n-                                );\n-                                // This could just be a normal link or a broken link\n-                                // we could potentially check if something is\n-                                // \"intra-doc-link-like\" and warn in that case.\n-                                continue;\n-                            }\n-                            Err(ErrorKind::AnchorFailure(msg)) => {\n-                                anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        // Try everything!\n-                        let mut candidates = PerNS {\n-                            macro_ns: self\n-                                .macro_resolve(path_str, base_node)\n-                                .map(|res| (res, extra_fragment.clone())),\n-                            type_ns: match self.resolve(\n-                                path_str,\n-                                TypeNS,\n-                                &current_item,\n-                                base_node,\n-                                &extra_fragment,\n-                            ) {\n-                                Ok(res) => {\n-                                    debug!(\"got res in TypeNS: {:?}\", res);\n-                                    Ok(res)\n-                                }\n-                                Err(ErrorKind::AnchorFailure(msg)) => {\n-                                    anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n-                                    continue;\n-                                }\n-                                Err(ErrorKind::Resolve(box kind)) => Err(kind),\n-                            },\n-                            value_ns: match self.resolve(\n-                                path_str,\n-                                ValueNS,\n-                                &current_item,\n-                                base_node,\n-                                &extra_fragment,\n-                            ) {\n-                                Ok(res) => Ok(res),\n-                                Err(ErrorKind::AnchorFailure(msg)) => {\n-                                    anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n-                                    continue;\n-                                }\n-                                Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                             }\n-                            .and_then(|(res, fragment)| {\n-                                // Constructors are picked up in the type namespace.\n-                                match res {\n-                                    Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => {\n-                                        Err(ResolutionFailure::WrongNamespace(res, TypeNS))\n-                                    }\n-                                    _ => match (fragment, extra_fragment) {\n-                                        (Some(fragment), Some(_)) => {\n-                                            // Shouldn't happen but who knows?\n-                                            Ok((res, Some(fragment)))\n-                                        }\n-                                        (fragment, None) | (None, fragment) => Ok((res, fragment)),\n-                                    },\n-                                }\n-                            }),\n-                        };\n-\n-                        let len = candidates.iter().filter(|res| res.is_ok()).count();\n-\n-                        if len == 0 {\n                             resolution_failure(\n                                 self,\n                                 &item,\n                                 path_str,\n                                 disambiguator,\n-                                &dox,\n+                                dox,\n                                 link_range,\n-                                candidates.into_iter().filter_map(|res| res.err()).collect(),\n+                                smallvec![kind],\n                             );\n-                            // this could just be a normal link\n-                            continue;\n+                            // This could just be a normal link or a broken link\n+                            // we could potentially check if something is\n+                            // \"intra-doc-link-like\" and warn in that case.\n+                            return;\n                         }\n-\n-                        if len == 1 {\n-                            candidates.into_iter().filter_map(|res| res.ok()).next().unwrap()\n-                        } else if len == 2 && is_derive_trait_collision(&candidates) {\n-                            candidates.type_ns.unwrap()\n-                        } else {\n-                            if is_derive_trait_collision(&candidates) {\n-                                candidates.macro_ns = Err(ResolutionFailure::Dummy);\n-                            }\n-                            // If we're reporting an ambiguity, don't mention the namespaces that failed\n-                            let candidates =\n-                                candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n-                            ambiguity_error(\n-                                cx,\n-                                &item,\n-                                path_str,\n-                                &dox,\n-                                link_range,\n-                                candidates.present_items().collect(),\n-                            );\n-                            continue;\n+                        Err(ErrorKind::AnchorFailure(msg)) => {\n+                            anchor_failure(cx, &item, &ori_link, dox, link_range, msg);\n+                            return;\n                         }\n                     }\n-                    Some(MacroNS) => {\n-                        match self.macro_resolve(path_str, base_node) {\n-                            Ok(res) => (res, extra_fragment),\n-                            Err(mut kind) => {\n-                                // `macro_resolve` only looks in the macro namespace. Try to give a better error if possible.\n-                                for &ns in &[TypeNS, ValueNS] {\n-                                    if let Some(res) = self.check_full_res(\n-                                        ns,\n-                                        path_str,\n-                                        base_node,\n-                                        &current_item,\n-                                        &extra_fragment,\n-                                    ) {\n-                                        kind = ResolutionFailure::WrongNamespace(res, MacroNS);\n-                                        break;\n-                                    }\n+                }\n+                None => {\n+                    // Try everything!\n+                    let mut candidates = PerNS {\n+                        macro_ns: self\n+                            .macro_resolve(path_str, base_node)\n+                            .map(|res| (res, extra_fragment.clone())),\n+                        type_ns: match self.resolve(\n+                            path_str,\n+                            TypeNS,\n+                            &current_item,\n+                            base_node,\n+                            &extra_fragment,\n+                        ) {\n+                            Ok(res) => {\n+                                debug!(\"got res in TypeNS: {:?}\", res);\n+                                Ok(res)\n+                            }\n+                            Err(ErrorKind::AnchorFailure(msg)) => {\n+                                anchor_failure(cx, &item, &ori_link, dox, link_range, msg);\n+                                return;\n+                            }\n+                            Err(ErrorKind::Resolve(box kind)) => Err(kind),\n+                        },\n+                        value_ns: match self.resolve(\n+                            path_str,\n+                            ValueNS,\n+                            &current_item,\n+                            base_node,\n+                            &extra_fragment,\n+                        ) {\n+                            Ok(res) => Ok(res),\n+                            Err(ErrorKind::AnchorFailure(msg)) => {\n+                                anchor_failure(cx, &item, &ori_link, dox, link_range, msg);\n+                                return;\n+                            }\n+                            Err(ErrorKind::Resolve(box kind)) => Err(kind),\n+                        }\n+                        .and_then(|(res, fragment)| {\n+                            // Constructors are picked up in the type namespace.\n+                            match res {\n+                                Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => {\n+                                    Err(ResolutionFailure::WrongNamespace(res, TypeNS))\n                                 }\n-                                resolution_failure(\n-                                    self,\n-                                    &item,\n-                                    path_str,\n-                                    disambiguator,\n-                                    &dox,\n-                                    link_range,\n-                                    smallvec![kind],\n-                                );\n-                                continue;\n+                                _ => match (fragment, extra_fragment) {\n+                                    (Some(fragment), Some(_)) => {\n+                                        // Shouldn't happen but who knows?\n+                                        Ok((res, Some(fragment)))\n+                                    }\n+                                    (fragment, None) | (None, fragment) => Ok((res, fragment)),\n+                                },\n                             }\n+                        }),\n+                    };\n+\n+                    let len = candidates.iter().filter(|res| res.is_ok()).count();\n+\n+                    if len == 0 {\n+                        resolution_failure(\n+                            self,\n+                            &item,\n+                            path_str,\n+                            disambiguator,\n+                            dox,\n+                            link_range,\n+                            candidates.into_iter().filter_map(|res| res.err()).collect(),\n+                        );\n+                        // this could just be a normal link\n+                        return;\n+                    }\n+\n+                    if len == 1 {\n+                        candidates.into_iter().filter_map(|res| res.ok()).next().unwrap()\n+                    } else if len == 2 && is_derive_trait_collision(&candidates) {\n+                        candidates.type_ns.unwrap()\n+                    } else {\n+                        if is_derive_trait_collision(&candidates) {\n+                            candidates.macro_ns = Err(ResolutionFailure::Dummy);\n                         }\n+                        // If we're reporting an ambiguity, don't mention the namespaces that failed\n+                        let candidates =\n+                            candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n+                        ambiguity_error(\n+                            cx,\n+                            &item,\n+                            path_str,\n+                            dox,\n+                            link_range,\n+                            candidates.present_items().collect(),\n+                        );\n+                        return;\n                     }\n                 }\n-            };\n-\n-            // Check for a primitive which might conflict with a module\n-            // Report the ambiguity and require that the user specify which one they meant.\n-            // FIXME: could there ever be a primitive not in the type namespace?\n-            if matches!(\n-                disambiguator,\n-                None | Some(Disambiguator::Namespace(Namespace::TypeNS) | Disambiguator::Primitive)\n-            ) && !matches!(res, Res::PrimTy(_))\n-            {\n-                if let Some((path, prim)) = is_primitive(path_str, TypeNS) {\n-                    // `prim@char`\n-                    if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n-                        if fragment.is_some() {\n-                            anchor_failure(\n-                                cx,\n+                Some(MacroNS) => {\n+                    match self.macro_resolve(path_str, base_node) {\n+                        Ok(res) => (res, extra_fragment),\n+                        Err(mut kind) => {\n+                            // `macro_resolve` only looks in the macro namespace. Try to give a better error if possible.\n+                            for &ns in &[TypeNS, ValueNS] {\n+                                if let Some(res) = self.check_full_res(\n+                                    ns,\n+                                    path_str,\n+                                    base_node,\n+                                    &current_item,\n+                                    &extra_fragment,\n+                                ) {\n+                                    kind = ResolutionFailure::WrongNamespace(res, MacroNS);\n+                                    break;\n+                                }\n+                            }\n+                            resolution_failure(\n+                                self,\n                                 &item,\n                                 path_str,\n-                                &dox,\n+                                disambiguator,\n+                                dox,\n                                 link_range,\n-                                AnchorFailure::RustdocAnchorConflict(prim),\n+                                smallvec![kind],\n                             );\n-                            continue;\n+                            return;\n                         }\n-                        res = prim;\n-                        fragment = Some(path.to_owned());\n-                    } else {\n-                        // `[char]` when a `char` module is in scope\n-                        let candidates = vec![res, prim];\n-                        ambiguity_error(cx, &item, path_str, &dox, link_range, candidates);\n-                        continue;\n                     }\n                 }\n             }\n+        };\n \n-            let report_mismatch = |specified: Disambiguator, resolved: Disambiguator| {\n-                // The resolved item did not match the disambiguator; give a better error than 'not found'\n-                let msg = format!(\"incompatible link kind for `{}`\", path_str);\n-                report_diagnostic(cx, &msg, &item, &dox, &link_range, |diag, sp| {\n-                    let note = format!(\n-                        \"this link resolved to {} {}, which is not {} {}\",\n-                        resolved.article(),\n-                        resolved.descr(),\n-                        specified.article(),\n-                        specified.descr()\n-                    );\n-                    diag.note(&note);\n-                    suggest_disambiguator(resolved, diag, path_str, &dox, sp, &link_range);\n-                });\n-            };\n-            if let Res::PrimTy(_) = res {\n-                match disambiguator {\n-                    Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n-                        item.attrs.links.push(ItemLink {\n-                            link: ori_link,\n-                            link_text: path_str.to_owned(),\n-                            did: None,\n-                            fragment,\n-                        });\n-                    }\n-                    Some(other) => {\n-                        report_mismatch(other, Disambiguator::Primitive);\n-                        continue;\n-                    }\n-                }\n-            } else {\n-                debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n-\n-                // Disallow e.g. linking to enums with `struct@`\n-                if let Res::Def(kind, _) = res {\n-                    debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n-                    match (self.kind_side_channel.take().map(|(kind, _)| kind).unwrap_or(kind), disambiguator) {\n-                        | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n-                        // NOTE: this allows 'method' to mean both normal functions and associated functions\n-                        // This can't cause ambiguity because both are in the same namespace.\n-                        | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n-                        // These are namespaces; allow anything in the namespace to match\n-                        | (_, Some(Disambiguator::Namespace(_)))\n-                        // If no disambiguator given, allow anything\n-                        | (_, None)\n-                        // All of these are valid, so do nothing\n-                        => {}\n-                        (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n-                        (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n-                            report_mismatch(specified, Disambiguator::Kind(kind));\n-                            continue;\n-                        }\n+        // Check for a primitive which might conflict with a module\n+        // Report the ambiguity and require that the user specify which one they meant.\n+        // FIXME: could there ever be a primitive not in the type namespace?\n+        if matches!(\n+            disambiguator,\n+            None | Some(Disambiguator::Namespace(Namespace::TypeNS) | Disambiguator::Primitive)\n+        ) && !matches!(res, Res::PrimTy(_))\n+        {\n+            if let Some((path, prim)) = is_primitive(path_str, TypeNS) {\n+                // `prim@char`\n+                if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n+                    if fragment.is_some() {\n+                        anchor_failure(\n+                            cx,\n+                            &item,\n+                            path_str,\n+                            dox,\n+                            link_range,\n+                            AnchorFailure::RustdocAnchorConflict(prim),\n+                        );\n+                        return;\n                     }\n+                    res = prim;\n+                    fragment = Some(path.to_owned());\n+                } else {\n+                    // `[char]` when a `char` module is in scope\n+                    let candidates = vec![res, prim];\n+                    ambiguity_error(cx, &item, path_str, dox, link_range, candidates);\n+                    return;\n                 }\n+            }\n+        }\n \n-                // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n-                if let Some((src_id, dst_id)) = res\n-                    .opt_def_id()\n-                    .and_then(|def_id| def_id.as_local())\n-                    .and_then(|dst_id| item.def_id.as_local().map(|src_id| (src_id, dst_id)))\n-                {\n-                    use rustc_hir::def_id::LOCAL_CRATE;\n-\n-                    let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n-                    let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n-\n-                    if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n-                        && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n-                    {\n-                        privacy_error(cx, &item, &path_str, &dox, link_range);\n-                        continue;\n+        let report_mismatch = |specified: Disambiguator, resolved: Disambiguator| {\n+            // The resolved item did not match the disambiguator; give a better error than 'not found'\n+            let msg = format!(\"incompatible link kind for `{}`\", path_str);\n+            report_diagnostic(cx, &msg, &item, dox, &link_range, |diag, sp| {\n+                let note = format!(\n+                    \"this link resolved to {} {}, which is not {} {}\",\n+                    resolved.article(),\n+                    resolved.descr(),\n+                    specified.article(),\n+                    specified.descr()\n+                );\n+                diag.note(&note);\n+                suggest_disambiguator(resolved, diag, path_str, dox, sp, &link_range);\n+            });\n+        };\n+        if let Res::PrimTy(_) = res {\n+            match disambiguator {\n+                Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n+                    item.attrs.links.push(ItemLink {\n+                        link: ori_link,\n+                        link_text: path_str.to_owned(),\n+                        did: None,\n+                        fragment,\n+                    });\n+                }\n+                Some(other) => {\n+                    report_mismatch(other, Disambiguator::Primitive);\n+                    return;\n+                }\n+            }\n+        } else {\n+            debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n+\n+            // Disallow e.g. linking to enums with `struct@`\n+            if let Res::Def(kind, _) = res {\n+                debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n+                match (self.kind_side_channel.take().map(|(kind, _)| kind).unwrap_or(kind), disambiguator) {\n+                    | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n+                    // NOTE: this allows 'method' to mean both normal functions and associated functions\n+                    // This can't cause ambiguity because both are in the same namespace.\n+                    | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n+                    // These are namespaces; allow anything in the namespace to match\n+                    | (_, Some(Disambiguator::Namespace(_)))\n+                    // If no disambiguator given, allow anything\n+                    | (_, None)\n+                    // All of these are valid, so do nothing\n+                    => {}\n+                    (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n+                    (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n+                        report_mismatch(specified, Disambiguator::Kind(kind));\n+                        return;\n                     }\n                 }\n-                let id = register_res(cx, res);\n-                item.attrs.links.push(ItemLink {\n-                    link: ori_link,\n-                    link_text,\n-                    did: Some(id),\n-                    fragment,\n-                });\n             }\n-        }\n-\n-        if item.is_mod() && !item.attrs.inner_docs {\n-            self.mod_ids.push(item.def_id);\n-        }\n \n-        if item.is_mod() {\n-            let ret = self.fold_item_recur(item);\n+            // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n+            if let Some((src_id, dst_id)) = res\n+                .opt_def_id()\n+                .and_then(|def_id| def_id.as_local())\n+                .and_then(|dst_id| item.def_id.as_local().map(|src_id| (src_id, dst_id)))\n+            {\n+                use rustc_hir::def_id::LOCAL_CRATE;\n \n-            self.mod_ids.pop();\n+                let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n+                let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n \n-            ret\n-        } else {\n-            self.fold_item_recur(item)\n+                if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n+                    && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n+                {\n+                    privacy_error(cx, &item, &path_str, dox, link_range);\n+                    return;\n+                }\n+            }\n+            let id = register_res(cx, res);\n+            item.attrs.links.push(ItemLink { link: ori_link, link_text, did: Some(id), fragment });\n         }\n     }\n }"}]}