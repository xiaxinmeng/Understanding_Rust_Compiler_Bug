{"sha": "c958eebf5d17f5fd52805ed08e4a7efc6c3caf21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NThlZWJmNWQxN2Y1ZmQ1MjgwNWVkMDhlNGE3ZWZjNmMzY2FmMjE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-10T23:00:16Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-10T23:00:16Z"}, "message": "Change more of trans to rely on tydescs when dealing with generics.", "tree": {"sha": "9e213594e1dce1cda85a335b4eccd39875e1bcdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e213594e1dce1cda85a335b4eccd39875e1bcdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c958eebf5d17f5fd52805ed08e4a7efc6c3caf21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c958eebf5d17f5fd52805ed08e4a7efc6c3caf21", "html_url": "https://github.com/rust-lang/rust/commit/c958eebf5d17f5fd52805ed08e4a7efc6c3caf21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c958eebf5d17f5fd52805ed08e4a7efc6c3caf21/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "140d6fd96468c51746d0d44bd6a9c4fdb6de30a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/140d6fd96468c51746d0d44bd6a9c4fdb6de30a9", "html_url": "https://github.com/rust-lang/rust/commit/140d6fd96468c51746d0d44bd6a9c4fdb6de30a9"}], "stats": {"total": 103, "additions": 66, "deletions": 37}, "files": [{"sha": "6399b900f5ef1442095efb7fc90669c2c903958d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 66, "deletions": 37, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c958eebf5d17f5fd52805ed08e4a7efc6c3caf21/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c958eebf5d17f5fd52805ed08e4a7efc6c3caf21/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c958eebf5d17f5fd52805ed08e4a7efc6c3caf21", "patch": "@@ -2704,7 +2704,10 @@ fn trans_args(@block_ctxt cx,\n \n     // Arg 0: Output pointer.\n     auto retty = ty.ty_fn_ret(fn_ty);\n-    auto llretslot = cx.build.Alloca(type_of(cx.fcx.ccx, retty));\n+    auto llretslot_res = alloc_ty(bcx, retty);\n+    bcx = llretslot_res.bcx;\n+    auto llretslot = llretslot_res.val;\n+\n     alt (gen) {\n         case (some[generic_info](?g)) {\n             lltydescs = g.tydescs;\n@@ -2715,30 +2718,30 @@ fn trans_args(@block_ctxt cx,\n         }\n     }\n     if (ty.type_has_dynamic_size(retty)) {\n-        llargs += cx.build.PointerCast(llretslot, T_typaram_ptr());\n+        llargs += bcx.build.PointerCast(llretslot, T_typaram_ptr());\n     } else if (ty.count_ty_params(retty) != 0u) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n         // type deep in a structure -- which the caller has a concrete view\n         // of. If so, cast the caller's view of the restlot to the callee's\n         // view, for the sake of making a type-compatible call.\n         llargs += cx.build.PointerCast(llretslot,\n-                                       T_ptr(type_of(cx.fcx.ccx, retty)));\n+                                       T_ptr(type_of(bcx.fcx.ccx, retty)));\n     } else {\n         llargs += llretslot;\n     }\n \n \n     // Arg 1: Task pointer.\n-    llargs += cx.fcx.lltaskptr;\n+    llargs += bcx.fcx.lltaskptr;\n \n     // Arg 2: Env (closure-bindings / self-obj)\n     alt (llobj) {\n         case (some[ValueRef](?ob)) {\n             // Every object is always found in memory,\n             // and not-yet-loaded (as part of an lval x.y\n             // doted method-call).\n-            llargs += cx.build.Load(ob);\n+            llargs += bcx.build.Load(ob);\n         }\n         case (_) {\n             llargs += llenv;\n@@ -2848,25 +2851,32 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n         find_scope_cx(cx).cleanups += clean(bind drop_ty(_, retval, ret_ty));\n     }\n \n+    // log \"call-result type: \" + val_str(retval);\n     ret res(bcx, retval);\n }\n \n fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n              &ast.ann ann) -> result {\n-    auto t = node_ann_type(cx.fcx.ccx, ann);\n-    auto llty = type_of(cx.fcx.ccx, t);\n-    auto tup_val = cx.build.Alloca(llty);\n+    auto bcx = cx;\n+    auto t = node_ann_type(bcx.fcx.ccx, ann);\n+    auto llty = type_of(bcx.fcx.ccx, t);\n+    auto tup_res = alloc_ty(bcx, t);\n+    auto tup_val = tup_res.val;\n+    bcx = tup_res.bcx;\n+\n     find_scope_cx(cx).cleanups += clean(bind drop_ty(_, tup_val, t));\n     let int i = 0;\n-    auto r = res(cx, C_nil());\n+\n     for (ast.elt e in elts) {\n-        auto t = ty.expr_ty(e.expr);\n-        auto src_res = trans_expr(r.bcx, e.expr);\n-        auto dst_elt = r.bcx.build.GEP(tup_val, vec(C_int(0), C_int(i)));\n-        r = copy_ty(src_res.bcx, INIT, dst_elt, src_res.val, t);\n+        auto e_ty = ty.expr_ty(e.expr);\n+        auto src_res = trans_expr(bcx, e.expr);\n+        bcx = src_res.bcx;\n+        auto dst_res = GEP_tup_like(bcx, t, tup_val, vec(0, i));\n+        bcx = dst_res.bcx;\n+        bcx = copy_ty(src_res.bcx, INIT, dst_res.val, src_res.val, e_ty).bcx;\n         i += 1;\n     }\n-    ret res(r.bcx, tup_val);\n+    ret res(bcx, tup_val);\n }\n \n fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n@@ -2891,44 +2901,58 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n \n     // FIXME: pass tydesc properly.\n     auto sub = trans_upcall(bcx, \"upcall_new_vec\", vec(data_sz, C_int(0)));\n+    bcx = sub.bcx;\n \n     auto llty = type_of(bcx.fcx.ccx, t);\n-    auto vec_val = sub.bcx.build.IntToPtr(sub.val, llty);\n+    auto vec_val = bcx.build.IntToPtr(sub.val, llty);\n     find_scope_cx(bcx).cleanups += clean(bind drop_ty(_, vec_val, t));\n \n-    auto body = sub.bcx.build.GEP(vec_val, vec(C_int(0),\n-                                               C_int(abi.vec_elt_data)));\n+    auto body = bcx.build.GEP(vec_val, vec(C_int(0),\n+                                           C_int(abi.vec_elt_data)));\n+\n+    auto pseudo_tup_ty =\n+        plain_ty(ty.ty_tup(_vec.init_elt[@ty.t](unit_ty,\n+                                                _vec.len[@ast.expr](args))));\n     let int i = 0;\n+\n     for (@ast.expr e in args) {\n-        auto src_res = trans_expr(sub.bcx, e);\n-        auto dst_elt = sub.bcx.build.GEP(body, vec(C_int(0), C_int(i)));\n-        sub = copy_ty(src_res.bcx, INIT, dst_elt, src_res.val, unit_ty);\n+        auto src_res = trans_expr(bcx, e);\n+        bcx = src_res.bcx;\n+        auto dst_res = GEP_tup_like(bcx, pseudo_tup_ty, body, vec(0, i));\n+        bcx = dst_res.bcx;\n+        bcx = copy_ty(bcx, INIT, dst_res.val, src_res.val, unit_ty).bcx;\n         i += 1;\n     }\n-    auto fill = sub.bcx.build.GEP(vec_val,\n-                                  vec(C_int(0), C_int(abi.vec_elt_fill)));\n-    sub.bcx.build.Store(data_sz, fill);\n+    auto fill = bcx.build.GEP(vec_val,\n+                              vec(C_int(0), C_int(abi.vec_elt_fill)));\n+    bcx.build.Store(data_sz, fill);\n \n-    ret res(sub.bcx, vec_val);\n+    ret res(bcx, vec_val);\n }\n \n fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n              &ast.ann ann) -> result {\n-    auto t = node_ann_type(cx.fcx.ccx, ann);\n-    auto llty = type_of(cx.fcx.ccx, t);\n-    auto rec_val = cx.build.Alloca(llty);\n+\n+    auto bcx = cx;\n+    auto t = node_ann_type(bcx.fcx.ccx, ann);\n+    auto llty = type_of(bcx.fcx.ccx, t);\n+    auto rec_res = alloc_ty(bcx, t);\n+    auto rec_val = rec_res.val;\n+    bcx = rec_res.bcx;\n+\n     find_scope_cx(cx).cleanups += clean(bind drop_ty(_, rec_val, t));\n     let int i = 0;\n-    auto r = res(cx, C_nil());\n+\n     for (ast.field f in fields) {\n-        auto t = ty.expr_ty(f.expr);\n-        auto src_res = trans_expr(r.bcx, f.expr);\n-        auto dst_elt = r.bcx.build.GEP(rec_val, vec(C_int(0), C_int(i)));\n-        // FIXME: calculate copy init-ness in typestate.\n-        r = copy_ty(src_res.bcx, INIT, dst_elt, src_res.val, t);\n+        auto e_ty = ty.expr_ty(f.expr);\n+        auto src_res = trans_expr(bcx, f.expr);\n+        bcx = src_res.bcx;\n+        auto dst_res = GEP_tup_like(bcx, t, rec_val, vec(0, i));\n+        bcx = dst_res.bcx;\n+        bcx = copy_ty(src_res.bcx, INIT, dst_res.val, src_res.val, e_ty).bcx;\n         i += 1;\n     }\n-    ret res(r.bcx, rec_val);\n+    ret res(bcx, rec_val);\n }\n \n \n@@ -3300,8 +3324,7 @@ iter block_locals(&ast.block b) -> @ast.local {\n     }\n }\n \n-fn alloc_local(@block_ctxt cx, @ast.local local) -> result {\n-    auto t = node_ann_type(cx.fcx.ccx, local.ann);\n+fn alloc_ty(@block_ctxt cx, @ty.t t) -> result {\n     auto val = C_int(0);\n     auto bcx = cx;\n     if (ty.type_has_dynamic_size(t)) {\n@@ -3311,10 +3334,16 @@ fn alloc_local(@block_ctxt cx, @ast.local local) -> result {\n     } else {\n         val = bcx.build.Alloca(type_of(cx.fcx.ccx, t));\n     }\n-    bcx.fcx.lllocals.insert(local.id, val);\n     ret res(bcx, val);\n }\n \n+fn alloc_local(@block_ctxt cx, @ast.local local) -> result {\n+    auto t = node_ann_type(cx.fcx.ccx, local.ann);\n+    auto r = alloc_ty(cx, t);\n+    r.bcx.fcx.lllocals.insert(local.id, r.val);\n+    ret r;\n+}\n+\n fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n     auto bcx = cx;\n "}]}