{"sha": "805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwNWE5OWU2Y2IzN2FiOWQ2YTg3M2Y4ZTFmZGY1N2YwOGI1MDhlNzM=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-05T14:14:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-05T14:14:46Z"}, "message": "Rollup merge of #39442 - keeperofdakeys:expand-derives, r=jseyfried\n\nExpand derive macros in the MacroExpander\n\nThis removes the expand_derives function, and sprinkles the functionality throughout the Invocation Collector, Expander and Resolver.\n\nFixes https://github.com/rust-lang/rust/issues/39326\n\nr? @jseyfried", "tree": {"sha": "bc203d6f512f9375e3e8783378b77afee206e8db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc203d6f512f9375e3e8783378b77afee206e8db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "html_url": "https://github.com/rust-lang/rust/commit/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65b24779a95d306ac9abd73bf430380e925e765e", "url": "https://api.github.com/repos/rust-lang/rust/commits/65b24779a95d306ac9abd73bf430380e925e765e", "html_url": "https://github.com/rust-lang/rust/commit/65b24779a95d306ac9abd73bf430380e925e765e"}, {"sha": "a201348775081ae24bbd016b089b93906f44e3b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a201348775081ae24bbd016b089b93906f44e3b7", "html_url": "https://github.com/rust-lang/rust/commit/a201348775081ae24bbd016b089b93906f44e3b7"}], "stats": {"total": 825, "additions": 483, "deletions": 342}, "files": [{"sha": "81a4f7c93b6e91abe2eec44da15ef705b8dbccb9", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -584,7 +584,7 @@ impl<'a> CrateLoader<'a> {\n         use proc_macro::TokenStream;\n         use proc_macro::__internal::Registry;\n         use rustc_back::dynamic_lib::DynamicLibrary;\n-        use syntax_ext::deriving::custom::CustomDerive;\n+        use syntax_ext::deriving::custom::ProcMacroDerive;\n         use syntax_ext::proc_macro_impl::AttrProcMacro;\n \n         let path = match dylib {\n@@ -616,8 +616,8 @@ impl<'a> CrateLoader<'a> {\n                                       expand: fn(TokenStream) -> TokenStream,\n                                       attributes: &[&'static str]) {\n                 let attrs = attributes.iter().cloned().map(Symbol::intern).collect();\n-                let derive = SyntaxExtension::CustomDerive(\n-                    Box::new(CustomDerive::new(expand, attrs))\n+                let derive = SyntaxExtension::ProcMacroDerive(\n+                    Box::new(ProcMacroDerive::new(expand, attrs))\n                 );\n                 self.0.push((Symbol::intern(trait_name), Rc::new(derive)));\n             }"}, {"sha": "4679b6be88b6f0835a06e410c37af1082423455a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -559,7 +559,7 @@ impl<'a> Resolver<'a> {\n                       \"an `extern crate` loading macros must be at the crate root\");\n         } else if !self.use_extern_macros && !used &&\n                   self.session.cstore.dep_kind(module.def_id().unwrap().krate).macros_only() {\n-            let msg = \"custom derive crates and `#[no_link]` crates have no effect without \\\n+            let msg = \"proc macro crates and `#[no_link]` crates have no effect without \\\n                        `#[macro_use]`\";\n             self.session.span_warn(item.span, msg);\n             used = true; // Avoid the normal unused extern crate warning"}, {"sha": "ea3112b2463f8ba27007e6e14405c475ef93e153", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -250,6 +250,32 @@ impl<'a> base::Resolver for Resolver<'a> {\n         }\n         result\n     }\n+\n+    fn resolve_builtin_macro(&mut self, tname: Name) -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        match self.builtin_macros.get(&tname).cloned() {\n+            Some(binding) => Ok(binding.get_macro(self)),\n+            None => Err(Determinacy::Undetermined),\n+        }\n+    }\n+\n+    fn resolve_derive_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n+                            -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        let ast::Path { span, .. } = *path;\n+        match self.resolve_macro(scope, path, false) {\n+            Ok(ext) => match *ext {\n+                SyntaxExtension::BuiltinDerive(..) |\n+                SyntaxExtension::ProcMacroDerive(..) => Ok(ext),\n+                _ => Err(Determinacy::Determined),\n+            },\n+            Err(Determinacy::Undetermined) if force => {\n+                let msg = format!(\"cannot find derive macro `{}` in this scope\", path);\n+                let mut err = self.session.struct_span_err(span, &msg);\n+                err.emit();\n+                Err(Determinacy::Determined)\n+            },\n+            Err(err) => Err(err),\n+        }\n+    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "9a717b86d091ed6682cd67427c89bda2baadf850", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -10,7 +10,7 @@\n \n pub use self::SyntaxExtension::{MultiDecorator, MultiModifier, NormalTT, IdentTT};\n \n-use ast::{self, Attribute, Name, PatKind};\n+use ast::{self, Attribute, Name, PatKind, MetaItem};\n use attr::HasAttrs;\n use codemap::{self, CodeMap, ExpnInfo, Spanned, respan};\n use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n@@ -471,6 +471,9 @@ impl MacResult for DummyResult {\n     }\n }\n \n+pub type BuiltinDeriveFn =\n+    for<'cx> fn(&'cx mut ExtCtxt, Span, &MetaItem, &Annotatable, &mut FnMut(Annotatable));\n+\n /// An enum representing the different kinds of syntax extensions.\n pub enum SyntaxExtension {\n     /// A syntax extension that is attached to an item and creates new items\n@@ -507,7 +510,14 @@ pub enum SyntaxExtension {\n     ///\n     IdentTT(Box<IdentMacroExpander>, Option<Span>, bool),\n \n-    CustomDerive(Box<MultiItemModifier>),\n+    /// An attribute-like procedural macro. TokenStream -> TokenStream.\n+    /// The input is the annotated item.\n+    /// Allows generating code to implement a Trait for a given struct\n+    /// or enum item.\n+    ProcMacroDerive(Box<MultiItemModifier>),\n+\n+    /// An attribute-like procedural macro that derives a builtin trait.\n+    BuiltinDerive(BuiltinDeriveFn),\n }\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n@@ -526,6 +536,9 @@ pub trait Resolver {\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy>;\n+    fn resolve_builtin_macro(&mut self, tname: Name) -> Result<Rc<SyntaxExtension>, Determinacy>;\n+    fn resolve_derive_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n+                            -> Result<Rc<SyntaxExtension>, Determinacy>;\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -552,6 +565,13 @@ impl Resolver for DummyResolver {\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n+    fn resolve_builtin_macro(&mut self, _tname: Name) -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        Err(Determinacy::Determined)\n+    }\n+    fn resolve_derive_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n+                            -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        Err(Determinacy::Determined)\n+    }\n }\n \n #[derive(Clone)]"}, {"sha": "946448eaaee99a2efbfe170e6c59515d7c24794f", "filename": "src/libsyntax/ext/derive.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -0,0 +1,218 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast::Name;\n+use attr;\n+use ast::{self, NestedMetaItem}; use ext::base::{ExtCtxt, SyntaxExtension};\n+use codemap;\n+use ext::build::AstBuilder;\n+use feature_gate;\n+use symbol::Symbol;\n+use syntax_pos::Span;\n+\n+pub fn derive_attr_trait<'a>(cx: &mut ExtCtxt, attr: &'a ast::Attribute)\n+                             -> Option<&'a NestedMetaItem> {\n+    if attr.name() != \"derive\" {\n+        return None;\n+    }\n+    if attr.value_str().is_some() {\n+        cx.span_err(attr.span, \"unexpected value in `derive`\");\n+        return None;\n+    }\n+\n+    let traits = attr.meta_item_list().unwrap_or(&[]);\n+\n+    if traits.is_empty() {\n+        cx.span_warn(attr.span, \"empty trait list in `derive`\");\n+        return None;\n+    }\n+\n+    return traits.get(0);\n+}\n+\n+pub fn verify_derive_attrs(cx: &mut ExtCtxt, attrs: &[ast::Attribute]) {\n+    for attr in attrs {\n+        if attr.name() != \"derive\" {\n+            continue;\n+        }\n+\n+        if attr.value_str().is_some() {\n+            cx.span_err(attr.span, \"unexpected value in `derive`\");\n+        }\n+\n+        let traits = attr.meta_item_list().unwrap_or(&[]).to_owned();\n+\n+        if traits.is_empty() {\n+            cx.span_warn(attr.span, \"empty trait list in `derive`\");\n+            attr::mark_used(&attr);\n+            continue;\n+        }\n+        for titem in traits {\n+            if titem.word().is_none() {\n+                cx.span_err(titem.span, \"malformed `derive` entry\");\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(PartialEq, Debug, Clone, Copy)]\n+pub enum DeriveType {\n+    Legacy,\n+    ProcMacro,\n+    Builtin\n+}\n+\n+impl DeriveType {\n+    // Classify a derive trait name by resolving the macro.\n+    pub fn classify(cx: &mut ExtCtxt, tname: Name) -> DeriveType {\n+        let legacy_derive_name = Symbol::intern(&format!(\"derive_{}\", tname));\n+\n+        if let Ok(_) = cx.resolver.resolve_builtin_macro(legacy_derive_name) {\n+            return DeriveType::Legacy;\n+        }\n+\n+        match cx.resolver.resolve_builtin_macro(tname) {\n+            Ok(ext) => match *ext {\n+                SyntaxExtension::BuiltinDerive(..) => DeriveType::Builtin,\n+                _ => DeriveType::ProcMacro,\n+            },\n+            Err(_) => DeriveType::ProcMacro,\n+        }\n+    }\n+}\n+\n+pub fn get_derive_attr(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>,\n+                       derive_type: DeriveType) -> Option<ast::Attribute> {\n+    for i in 0..attrs.len() {\n+        if attrs[i].name() != \"derive\" {\n+            continue;\n+        }\n+\n+        if attrs[i].value_str().is_some() {\n+            continue;\n+        }\n+\n+        let mut traits = attrs[i].meta_item_list().unwrap_or(&[]).to_owned();\n+\n+        // First, weed out malformed #[derive]\n+        traits.retain(|titem| titem.word().is_some());\n+\n+        let mut titem = None;\n+\n+        // See if we can find a matching trait.\n+        for j in 0..traits.len() {\n+            let tname = match traits[j].name() {\n+                Some(tname) => tname,\n+                _ => continue,\n+            };\n+\n+            if DeriveType::classify(cx, tname) == derive_type {\n+                titem = Some(traits.remove(j));\n+                break;\n+            }\n+        }\n+\n+        // If we find a trait, remove the trait from the attribute.\n+        if let Some(titem) = titem {\n+            if traits.len() == 0 {\n+                attrs.remove(i);\n+            } else {\n+                let derive = Symbol::intern(\"derive\");\n+                let mitem = cx.meta_list(titem.span, derive, traits);\n+                attrs[i] = cx.attribute(titem.span, mitem);\n+            }\n+            let derive = Symbol::intern(\"derive\");\n+            let mitem = cx.meta_list(titem.span, derive, vec![titem]);\n+            return Some(cx.attribute(mitem.span, mitem));\n+        }\n+    }\n+    return None;\n+}\n+\n+fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n+    Span {\n+        expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n+            call_site: span,\n+            callee: codemap::NameAndSpan {\n+                format: codemap::MacroAttribute(Symbol::intern(attr_name)),\n+                span: Some(span),\n+                allow_internal_unstable: true,\n+            },\n+        }),\n+        ..span\n+    }\n+}\n+\n+pub fn add_derived_markers(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) {\n+    if attrs.is_empty() {\n+        return;\n+    }\n+\n+    let titems = attrs.iter().filter(|a| {\n+        a.name() == \"derive\"\n+    }).flat_map(|a| {\n+        a.meta_item_list().unwrap_or(&[]).iter()\n+    }).filter_map(|titem| {\n+        titem.name()\n+    }).collect::<Vec<_>>();\n+\n+    let span = attrs[0].span;\n+\n+    if !attrs.iter().any(|a| a.name() == \"structural_match\") &&\n+       titems.iter().any(|t| *t == \"PartialEq\") && titems.iter().any(|t| *t == \"Eq\") {\n+        let structural_match = Symbol::intern(\"structural_match\");\n+        let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n+        let meta = cx.meta_word(span, structural_match);\n+        attrs.push(cx.attribute(span, meta));\n+    }\n+\n+    if !attrs.iter().any(|a| a.name() == \"rustc_copy_clone_marker\") &&\n+       titems.iter().any(|t| *t == \"Copy\") && titems.iter().any(|t| *t == \"Clone\") {\n+        let structural_match = Symbol::intern(\"rustc_copy_clone_marker\");\n+        let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n+        let meta = cx.meta_word(span, structural_match);\n+        attrs.push(cx.attribute(span, meta));\n+    }\n+}\n+\n+pub fn find_derive_attr(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>)\n+                        -> Option<ast::Attribute> {\n+    verify_derive_attrs(cx, attrs);\n+    get_derive_attr(cx, attrs, DeriveType::Legacy).and_then(|a| {\n+        let titem = derive_attr_trait(cx, &a);\n+        titem.and_then(|titem| {\n+            let tword = titem.word().unwrap();\n+            let tname = tword.name();\n+            if !cx.ecfg.enable_custom_derive() {\n+                feature_gate::emit_feature_err(\n+                    &cx.parse_sess,\n+                    \"custom_derive\",\n+                    titem.span,\n+                    feature_gate::GateIssue::Language,\n+                    feature_gate::EXPLAIN_CUSTOM_DERIVE\n+                );\n+                None\n+            } else {\n+                let name = Symbol::intern(&format!(\"derive_{}\", tname));\n+                if !cx.resolver.is_whitelisted_legacy_custom_derive(name) {\n+                    cx.span_warn(titem.span,\n+                                 feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n+                }\n+                let mitem = cx.meta_word(titem.span, name);\n+                Some(cx.attribute(mitem.span, mitem))\n+            }\n+        })\n+    }).or_else(|| {\n+        get_derive_attr(cx, attrs, DeriveType::ProcMacro)\n+    }).or_else(|| {\n+        add_derived_markers(cx, attrs);\n+        get_derive_attr(cx, attrs, DeriveType::Builtin)\n+    })\n+}"}, {"sha": "8e7f8830eafbc586d2b2c04ad60d44487cc12dc9", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 104, "deletions": 10, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -8,26 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Ident, Mac_, PatKind};\n+use ast::{self, Block, Ident, Mac_, PatKind};\n use ast::{Name, MacStmtStyle, StmtKind, ItemKind};\n-use ast;\n-use ext::hygiene::Mark;\n-use ext::placeholders::{placeholder, PlaceholderExpander};\n use attr::{self, HasAttrs};\n use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n-use syntax_pos::{self, Span, ExpnId};\n use config::{is_test_or_bench, StripUnconfigured};\n use ext::base::*;\n+use ext::derive::{find_derive_attr, derive_attr_trait};\n+use ext::hygiene::Mark;\n+use ext::placeholders::{placeholder, PlaceholderExpander};\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use parse::{ParseSess, DirectoryOwnership, PResult, filemap_to_tts};\n use parse::parser::Parser;\n use parse::token;\n+use parse::{ParseSess, DirectoryOwnership, PResult, filemap_to_tts};\n use print::pprust;\n use ptr::P;\n use std_inject;\n+use symbol::Symbol;\n use symbol::keywords;\n+use syntax_pos::{self, Span, ExpnId};\n use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -166,13 +167,18 @@ pub enum InvocationKind {\n         attr: ast::Attribute,\n         item: Annotatable,\n     },\n+    Derive {\n+        attr: ast::Attribute,\n+        item: Annotatable,\n+    },\n }\n \n impl Invocation {\n     fn span(&self) -> Span {\n         match self.kind {\n             InvocationKind::Bang { span, .. } => span,\n             InvocationKind::Attr { ref attr, .. } => attr.span,\n+            InvocationKind::Derive { ref attr, .. } => attr.span,\n         }\n     }\n }\n@@ -250,6 +256,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let path = ast::Path::from_ident(attr.span, ident);\n                     self.cx.resolver.resolve_macro(scope, &path, force)\n                 }\n+                InvocationKind::Derive { ref attr, .. } => {\n+                    let titem = derive_attr_trait(self.cx, &attr).unwrap();\n+                    let tname = titem.name().expect(\"Expected derive macro name\");\n+                    let ident = Ident::with_empty_ctxt(tname);\n+                    let path = ast::Path::from_ident(attr.span, ident);\n+                    self.cx.resolver.resolve_derive_macro(scope, &path, force)\n+                }\n             };\n             let ext = match resolution {\n                 Ok(ext) => Some(ext),\n@@ -330,6 +343,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n             InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext),\n+            InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext),\n         }\n     }\n \n@@ -370,7 +384,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n                 self.parse_expansion(tok_result, kind, name, attr.span)\n             }\n-            SyntaxExtension::CustomDerive(_) => {\n+            SyntaxExtension::ProcMacroDerive(..) | SyntaxExtension::BuiltinDerive(..) => {\n                 self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", name));\n                 kind.dummy(attr.span)\n             }\n@@ -440,7 +454,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 return kind.dummy(span);\n             }\n \n-            SyntaxExtension::CustomDerive(..) => {\n+            SyntaxExtension::ProcMacroDerive(..) | SyntaxExtension::BuiltinDerive(..) => {\n                 self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", extname));\n                 return kind.dummy(span);\n             }\n@@ -486,6 +500,71 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         })\n     }\n \n+    /// Expand a derive invocation. Returns the result of expansion.\n+    fn expand_derive_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+        let Invocation { expansion_kind: kind, .. } = invoc;\n+        let (attr, item) = match invoc.kind {\n+            InvocationKind::Derive { attr, item } => (attr, item),\n+            _ => unreachable!(),\n+        };\n+\n+        attr::mark_used(&attr);\n+        let titem = derive_attr_trait(self.cx, &attr).unwrap();\n+        let tname = ast::Ident::with_empty_ctxt(titem.name().unwrap());\n+        let name = Symbol::intern(&format!(\"derive({})\", tname));\n+        let mitem = &attr.value;\n+\n+        self.cx.bt_push(ExpnInfo {\n+            call_site: attr.span,\n+            callee: NameAndSpan {\n+                format: MacroAttribute(attr.name()),\n+                span: Some(attr.span),\n+                allow_internal_unstable: false,\n+            }\n+        });\n+\n+        match *ext {\n+            SyntaxExtension::ProcMacroDerive(ref ext) => {\n+                let span = Span {\n+                    expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n+                        call_site: mitem.span,\n+                        callee: NameAndSpan {\n+                            format: MacroAttribute(Symbol::intern(&format!(\"derive({})\", tname))),\n+                            span: None,\n+                            allow_internal_unstable: false,\n+                        },\n+                    }),\n+                    ..mitem.span\n+                };\n+                return kind.expect_from_annotatables(ext.expand(self.cx, span, &mitem, item));\n+            }\n+            SyntaxExtension::BuiltinDerive(func) => {\n+                let span = Span {\n+                    expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n+                        call_site: titem.span,\n+                        callee: NameAndSpan {\n+                            format: MacroAttribute(name),\n+                            span: None,\n+                            allow_internal_unstable: true,\n+                        },\n+                    }),\n+                    ..titem.span\n+                };\n+                let mut items = Vec::new();\n+                func(self.cx, span, &mitem, &item, &mut |a| {\n+                    items.push(a)\n+                });\n+                items.insert(0, item);\n+                return kind.expect_from_annotatables(items);\n+            }\n+            _ => {\n+                let msg = &format!(\"macro `{}` may not be used for derive attributes\", name);\n+                self.cx.span_err(attr.span, &msg);\n+                kind.dummy(attr.span)\n+            }\n+        }\n+    }\n+\n     fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, name: Name, span: Span)\n                        -> Expansion {\n         let mut parser = self.cx.new_parser_from_tts(&toks.trees().cloned().collect::<Vec<_>>());\n@@ -595,16 +674,31 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(&mut self, attr: ast::Attribute, item: Annotatable, kind: ExpansionKind)\n                     -> Expansion {\n-        self.collect(kind, InvocationKind::Attr { attr: attr, item: item })\n+        let invoc_kind = if attr.name() == \"derive\" {\n+            if kind == ExpansionKind::TraitItems || kind == ExpansionKind::ImplItems {\n+                self.cx.span_err(attr.span, \"`derive` can be only be applied to items\");\n+                return kind.expect_from_annotatables(::std::iter::once(item));\n+            }\n+            InvocationKind::Derive { attr: attr, item: item }\n+        } else {\n+            InvocationKind::Attr { attr: attr, item: item }\n+        };\n+\n+        self.collect(kind, invoc_kind)\n     }\n \n     // If `item` is an attr invocation, remove and return the macro attribute.\n     fn classify_item<T: HasAttrs>(&mut self, mut item: T) -> (T, Option<ast::Attribute>) {\n         let mut attr = None;\n+\n         item = item.map_attrs(|mut attrs| {\n-            attr = self.cx.resolver.find_attr_invoc(&mut attrs);\n+            attr = self.cx.resolver.find_attr_invoc(&mut attrs).or_else(|| {\n+                find_derive_attr(self.cx, &mut attrs)\n+            });\n+\n             attrs\n         });\n+\n         (item, attr)\n     }\n "}, {"sha": "87a03adf6b77c018784aa535a3939f0ba1db4a2c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -128,6 +128,7 @@ pub mod print {\n pub mod ext {\n     pub mod base;\n     pub mod build;\n+    pub mod derive;\n     pub mod expand;\n     pub mod placeholders;\n     pub mod hygiene;"}, {"sha": "974e86a57412446d0b2457b48704e8e46a91f927", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -32,18 +32,18 @@ impl<'a> Visitor<'a> for MarkAttrs<'a> {\n     fn visit_mac(&mut self, _mac: &Mac) {}\n }\n \n-pub struct CustomDerive {\n+pub struct ProcMacroDerive {\n     inner: fn(TokenStream) -> TokenStream,\n     attrs: Vec<ast::Name>,\n }\n \n-impl CustomDerive {\n-    pub fn new(inner: fn(TokenStream) -> TokenStream, attrs: Vec<ast::Name>) -> CustomDerive {\n-        CustomDerive { inner: inner, attrs: attrs }\n+impl ProcMacroDerive {\n+    pub fn new(inner: fn(TokenStream) -> TokenStream, attrs: Vec<ast::Name>) -> ProcMacroDerive {\n+        ProcMacroDerive { inner: inner, attrs: attrs }\n     }\n }\n \n-impl MultiItemModifier for CustomDerive {\n+impl MultiItemModifier for ProcMacroDerive {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n@@ -54,7 +54,7 @@ impl MultiItemModifier for CustomDerive {\n             Annotatable::Item(item) => item,\n             Annotatable::ImplItem(_) |\n             Annotatable::TraitItem(_) => {\n-                ecx.span_err(span, \"custom derive attributes may only be \\\n+                ecx.span_err(span, \"proc-macro derives may only be \\\n                                     applied to struct/enum items\");\n                 return Vec::new()\n             }\n@@ -63,7 +63,7 @@ impl MultiItemModifier for CustomDerive {\n             ItemKind::Struct(..) |\n             ItemKind::Enum(..) => {},\n             _ => {\n-                ecx.span_err(span, \"custom derive attributes may only be \\\n+                ecx.span_err(span, \"proc-macro derives may only be \\\n                                     applied to struct/enum items\");\n                 return Vec::new()\n             }\n@@ -81,7 +81,7 @@ impl MultiItemModifier for CustomDerive {\n         let stream = match res {\n             Ok(stream) => stream,\n             Err(e) => {\n-                let msg = \"custom derive attribute panicked\";\n+                let msg = \"proc-macro derive panicked\";\n                 let mut err = ecx.struct_span_fatal(span, msg);\n                 if let Some(s) = e.downcast_ref::<String>() {\n                     err.help(&format!(\"message: {}\", s));\n@@ -100,7 +100,7 @@ impl MultiItemModifier for CustomDerive {\n                 Ok(new_items) => new_items,\n                 Err(_) => {\n                     // FIXME: handle this better\n-                    let msg = \"custom derive produced unparseable tokens\";\n+                    let msg = \"proc-macro derive produced unparseable tokens\";\n                     ecx.struct_span_fatal(span, msg).emit();\n                     panic!(FatalError);\n                 }"}, {"sha": "498f2348b80f109157f55992e684e7e91111b864", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -13,6 +13,7 @@\n use deriving;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n+use deriving::warn_if_deprecated;\n \n use syntax::ast;\n use syntax::ast::{Expr, MetaItem, Mutability};\n@@ -35,6 +36,7 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n                                  push: &mut FnMut(Annotatable)) {\n+    warn_if_deprecated(cx, span, \"Decodable\");\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n "}, {"sha": "9d155c22ad031d86f4f3508d4195c5c051b5a5d8", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -91,6 +91,7 @@\n use deriving;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n+use deriving::warn_if_deprecated;\n \n use syntax::ast::{Expr, ExprKind, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n@@ -112,6 +113,7 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n                                  push: &mut FnMut(Annotatable)) {\n+    warn_if_deprecated(cx, span, \"Encodable\");\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n "}, {"sha": "3bceb02f3d6c5af6a2e2cff0a5cb9c452ce275c5", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 10, "deletions": 247, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -10,12 +10,11 @@\n \n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n-use syntax::ast::{self, MetaItem};\n-use syntax::attr::HasAttrs;\n+use std::rc::Rc;\n+use syntax::ast;\n use syntax::codemap;\n-use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver};\n use syntax::ext::build::AstBuilder;\n-use syntax::feature_gate;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -89,234 +88,6 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n     }\n }\n \n-pub fn expand_derive(cx: &mut ExtCtxt,\n-                     span: Span,\n-                     mitem: &MetaItem,\n-                     annotatable: Annotatable)\n-                     -> Vec<Annotatable> {\n-    debug!(\"expand_derive: span = {:?}\", span);\n-    debug!(\"expand_derive: mitem = {:?}\", mitem);\n-    debug!(\"expand_derive: annotatable input  = {:?}\", annotatable);\n-    let mut item = match annotatable {\n-        Annotatable::Item(item) => item,\n-        other => {\n-            cx.span_err(span, \"`derive` can only be applied to items\");\n-            return vec![other]\n-        }\n-    };\n-\n-    let derive = Symbol::intern(\"derive\");\n-    let mut derive_attrs = Vec::new();\n-    item = item.map_attrs(|attrs| {\n-        let partition = attrs.into_iter().partition(|attr| attr.name() == derive);\n-        derive_attrs = partition.0;\n-        partition.1\n-    });\n-\n-    // Expand `#[derive]`s after other attribute macro invocations.\n-    if cx.resolver.find_attr_invoc(&mut item.attrs.clone()).is_some() {\n-        return vec![Annotatable::Item(item.map_attrs(|mut attrs| {\n-            attrs.push(cx.attribute(span, mitem.clone()));\n-            attrs.extend(derive_attrs);\n-            attrs\n-        }))];\n-    }\n-\n-    let get_traits = |mitem: &MetaItem, cx: &ExtCtxt| {\n-        if mitem.value_str().is_some() {\n-            cx.span_err(mitem.span, \"unexpected value in `derive`\");\n-        }\n-\n-        let traits = mitem.meta_item_list().unwrap_or(&[]).to_owned();\n-        if traits.is_empty() {\n-            cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n-        }\n-        traits\n-    };\n-\n-    let mut traits = get_traits(mitem, cx);\n-    for derive_attr in derive_attrs {\n-        traits.extend(get_traits(&derive_attr.value, cx));\n-    }\n-\n-    // First, weed out malformed #[derive]\n-    traits.retain(|titem| {\n-        if titem.word().is_none() {\n-            cx.span_err(titem.span, \"malformed `derive` entry\");\n-            false\n-        } else {\n-            true\n-        }\n-    });\n-\n-    // Next, check for old-style #[derive(Foo)]\n-    //\n-    // These all get expanded to `#[derive_Foo]` and will get expanded first. If\n-    // we actually add any attributes here then we return to get those expanded\n-    // and then eventually we'll come back to finish off the other derive modes.\n-    let mut new_attributes = Vec::new();\n-    traits.retain(|titem| {\n-        let tword = titem.word().unwrap();\n-        let tname = tword.name();\n-\n-        if is_builtin_trait(tname) || {\n-            let derive_mode = ast::Path::from_ident(titem.span, ast::Ident::with_empty_ctxt(tname));\n-            cx.resolver.resolve_macro(cx.current_expansion.mark, &derive_mode, false).map(|ext| {\n-                if let SyntaxExtension::CustomDerive(_) = *ext { true } else { false }\n-            }).unwrap_or(false)\n-        } {\n-            return true;\n-        }\n-\n-        if !cx.ecfg.enable_custom_derive() {\n-            feature_gate::emit_feature_err(&cx.parse_sess,\n-                                           \"custom_derive\",\n-                                           titem.span,\n-                                           feature_gate::GateIssue::Language,\n-                                           feature_gate::EXPLAIN_CUSTOM_DERIVE);\n-        } else {\n-            let name = Symbol::intern(&format!(\"derive_{}\", tname));\n-            if !cx.resolver.is_whitelisted_legacy_custom_derive(name) {\n-                cx.span_warn(titem.span, feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n-            }\n-            let mitem = cx.meta_word(titem.span, name);\n-            new_attributes.push(cx.attribute(mitem.span, mitem));\n-        }\n-        false\n-    });\n-    if new_attributes.len() > 0 {\n-        item = item.map(|mut i| {\n-            i.attrs.extend(new_attributes);\n-            if traits.len() > 0 {\n-                let list = cx.meta_list(mitem.span, derive, traits);\n-                i.attrs.push(cx.attribute(mitem.span, list));\n-            }\n-            i\n-        });\n-        return vec![Annotatable::Item(item)]\n-    }\n-\n-    // Now check for macros-1.1 style custom #[derive].\n-    //\n-    // Expand each of them in order given, but *before* we expand any built-in\n-    // derive modes. The logic here is to:\n-    //\n-    // 1. Collect the remaining `#[derive]` annotations into a list. If\n-    //    there are any left, attach a `#[derive]` attribute to the item\n-    //    that we're currently expanding with the remaining derive modes.\n-    // 2. Manufacture a `#[derive(Foo)]` attribute to pass to the expander.\n-    // 3. Expand the current item we're expanding, getting back a list of\n-    //    items that replace it.\n-    // 4. Extend the returned list with the current list of items we've\n-    //    collected so far.\n-    // 5. Return everything!\n-    //\n-    // If custom derive extensions end up threading through the `#[derive]`\n-    // attribute, we'll get called again later on to continue expanding\n-    // those modes.\n-    let macros_11_derive = traits.iter()\n-                                 .cloned()\n-                                 .enumerate()\n-                                 .filter(|&(_, ref name)| !is_builtin_trait(name.name().unwrap()))\n-                                 .next();\n-    if let Some((i, titem)) = macros_11_derive {\n-        let tname = ast::Ident::with_empty_ctxt(titem.name().unwrap());\n-        let path = ast::Path::from_ident(titem.span, tname);\n-        let ext = cx.resolver.resolve_macro(cx.current_expansion.mark, &path, false).unwrap();\n-\n-        traits.remove(i);\n-        if traits.len() > 0 {\n-            item = item.map(|mut i| {\n-                let list = cx.meta_list(mitem.span, derive, traits);\n-                i.attrs.push(cx.attribute(mitem.span, list));\n-                i\n-            });\n-        }\n-        let titem = cx.meta_list_item_word(titem.span, titem.name().unwrap());\n-        let mitem = cx.meta_list(titem.span, derive, vec![titem]);\n-        let item = Annotatable::Item(item);\n-\n-        let span = Span {\n-            expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-                call_site: mitem.span,\n-                callee: codemap::NameAndSpan {\n-                    format: codemap::MacroAttribute(Symbol::intern(&format!(\"derive({})\", tname))),\n-                    span: None,\n-                    allow_internal_unstable: false,\n-                },\n-            }),\n-            ..mitem.span\n-        };\n-\n-        if let SyntaxExtension::CustomDerive(ref ext) = *ext {\n-            return ext.expand(cx, span, &mitem, item);\n-        } else {\n-            unreachable!()\n-        }\n-    }\n-\n-    // Ok, at this point we know that there are no old-style `#[derive_Foo]` nor\n-    // any macros-1.1 style `#[derive(Foo)]`. Expand all built-in traits here.\n-\n-    // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n-    // `#[structural_match]` attribute.\n-    let (partial_eq, eq) = (Symbol::intern(\"PartialEq\"), Symbol::intern(\"Eq\"));\n-    if traits.iter().any(|t| t.name() == Some(partial_eq)) &&\n-       traits.iter().any(|t| t.name() == Some(eq)) {\n-        let structural_match = Symbol::intern(\"structural_match\");\n-        let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n-        let meta = cx.meta_word(span, structural_match);\n-        item = item.map(|mut i| {\n-            i.attrs.push(cx.attribute(span, meta));\n-            i\n-        });\n-    }\n-\n-    // RFC #1521. `Clone` can assume that `Copy` types' clone implementation is\n-    // the same as the copy implementation.\n-    //\n-    // Add a marker attribute here picked up during #[derive(Clone)]\n-    let (copy, clone) = (Symbol::intern(\"Copy\"), Symbol::intern(\"Clone\"));\n-    if traits.iter().any(|t| t.name() == Some(clone)) &&\n-       traits.iter().any(|t| t.name() == Some(copy)) {\n-        let marker = Symbol::intern(\"rustc_copy_clone_marker\");\n-        let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n-        let meta = cx.meta_word(span, marker);\n-        item = item.map(|mut i| {\n-            i.attrs.push(cx.attribute(span, meta));\n-            i\n-        });\n-    }\n-\n-    let mut items = Vec::new();\n-    for titem in traits.iter() {\n-        let tname = titem.word().unwrap().name();\n-        let name = Symbol::intern(&format!(\"derive({})\", tname));\n-        let mitem = cx.meta_word(titem.span, name);\n-\n-        let span = Span {\n-            expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-                call_site: titem.span,\n-                callee: codemap::NameAndSpan {\n-                    format: codemap::MacroAttribute(name),\n-                    span: None,\n-                    allow_internal_unstable: true,\n-                },\n-            }),\n-            ..titem.span\n-        };\n-\n-        let my_item = Annotatable::Item(item);\n-        expand_builtin(&tname.as_str(), cx, span, &mitem, &my_item, &mut |a| {\n-            items.push(a);\n-        });\n-        item = my_item.expect_item();\n-    }\n-\n-    items.insert(0, Annotatable::Item(item));\n-    return items\n-}\n-\n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n         pub fn is_builtin_trait(name: ast::Name) -> bool {\n@@ -326,21 +97,13 @@ macro_rules! derive_traits {\n             }\n         }\n \n-        fn expand_builtin(name: &str,\n-                          ecx: &mut ExtCtxt,\n-                          span: Span,\n-                          mitem: &MetaItem,\n-                          item: &Annotatable,\n-                          push: &mut FnMut(Annotatable)) {\n-            match name {\n-                $(\n-                    $name => {\n-                        warn_if_deprecated(ecx, span, $name);\n-                        $func(ecx, span, mitem, item, push);\n-                    }\n-                )*\n-                _ => panic!(\"not a builtin derive mode: {}\", name),\n-            }\n+        pub fn register_builtin_derives(resolver: &mut Resolver) {\n+            $(\n+                resolver.add_ext(\n+                    ast::Ident::with_empty_ctxt(Symbol::intern($name)),\n+                    Rc::new(SyntaxExtension::BuiltinDerive($func))\n+                );\n+            )*\n         }\n     }\n }"}, {"sha": "7533171b08556df082f2fcabfd27dbcb11e3e3d0", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -24,7 +24,6 @@\n #![feature(staged_api)]\n \n extern crate fmt_macros;\n-#[macro_use]\n extern crate log;\n #[macro_use]\n extern crate syntax;\n@@ -51,12 +50,14 @@ pub mod proc_macro_impl;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, MultiModifier, NamedSyntaxExtension};\n+use syntax::ext::base::{MacroExpanderFn, NormalTT, NamedSyntaxExtension};\n use syntax::symbol::Symbol;\n \n pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n                          user_exts: Vec<NamedSyntaxExtension>,\n                          enable_quotes: bool) {\n+    deriving::register_builtin_derives(resolver);\n+\n     let mut register = |name, ext| {\n         resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n@@ -112,8 +113,6 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n     register(Symbol::intern(\"format_args\"),\n              NormalTT(Box::new(format::expand_format_args), None, true));\n \n-    register(Symbol::intern(\"derive\"), MultiModifier(Box::new(deriving::expand_derive)));\n-\n     for (name, ext) in user_exts {\n         register(name, ext);\n     }"}, {"sha": "325f09a83ddab80860afd3524f7937ab23cd2e7c", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -27,7 +27,7 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use deriving;\n \n-struct CustomDerive {\n+struct ProcMacroDerive {\n     trait_name: ast::Name,\n     function_name: Ident,\n     span: Span,\n@@ -40,7 +40,7 @@ struct AttrProcMacro {\n }\n \n struct CollectProcMacros<'a> {\n-    derives: Vec<CustomDerive>,\n+    derives: Vec<ProcMacroDerive>,\n     attr_macros: Vec<AttrProcMacro>,\n     in_root: bool,\n     handler: &'a errors::Handler,\n@@ -176,7 +176,7 @@ impl<'a> CollectProcMacros<'a> {\n         };\n \n         if self.in_root && item.vis == ast::Visibility::Public {\n-            self.derives.push(CustomDerive {\n+            self.derives.push(ProcMacroDerive {\n                 span: item.span,\n                 trait_name: trait_name,\n                 function_name: item.ident,\n@@ -319,7 +319,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n //          }\n //      }\n fn mk_registrar(cx: &mut ExtCtxt,\n-                custom_derives: &[CustomDerive],\n+                custom_derives: &[ProcMacroDerive],\n                 custom_attrs: &[AttrProcMacro]) -> P<ast::Item> {\n     let eid = cx.codemap().record_expansion(ExpnInfo {\n         call_site: DUMMY_SP,"}, {"sha": "42fad803bfa68ae345d5643ff0ae3b0e99fbdadb", "filename": "src/test/compile-fail-fulldeps/proc-macro/derive-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fderive-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fderive-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fderive-bad.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -16,7 +16,7 @@ extern crate derive_bad;\n #[derive(\n     A\n )]\n-//~^^ ERROR: custom derive produced unparseable tokens\n+//~^^ ERROR: proc-macro derive produced unparseable tokens\n struct A;\n \n fn main() {}"}, {"sha": "c483c048b418f11f437a37a8f13a03200cd472a6", "filename": "src/test/compile-fail-fulldeps/proc-macro/load-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fload-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fload-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fload-panic.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -14,7 +14,7 @@\n extern crate derive_panic;\n \n #[derive(A)]\n-//~^ ERROR: custom derive attribute panicked\n+//~^ ERROR: proc-macro derive panicked\n //~| HELP: message: nope!\n struct Foo;\n "}, {"sha": "e47a4aefb5e0b67447dde7a118477e45622574ba", "filename": "src/test/compile-fail-fulldeps/proc-macro/no-macro-use-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fno-macro-use-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fno-macro-use-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fno-macro-use-attr.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -13,7 +13,7 @@\n #![feature(rustc_attrs)]\n \n extern crate derive_a;\n-//~^ WARN custom derive crates and `#[no_link]` crates have no effect without `#[macro_use]`\n+//~^ WARN proc macro crates and `#[no_link]` crates have no effect without `#[macro_use]`\n \n #[rustc_error]\n fn main() {} //~ ERROR compilation successful"}, {"sha": "d388ece084417160ce98517533942f71e0387ca5", "filename": "src/test/compile-fail/deriving-meta-unknown-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail%2Fderiving-meta-unknown-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail%2Fderiving-meta-unknown-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-meta-unknown-trait.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -11,7 +11,7 @@\n // ignore-tidy-linelength\n \n #[derive(Eqr)]\n-//~^ ERROR `#[derive]` for custom traits is not stable enough for use. It is deprecated and will be removed in v1.15 (see issue #29644)\n+//~^ ERROR cannot find derive macro `Eqr` in this scope\n struct Foo;\n \n pub fn main() {}"}, {"sha": "97a39a46c19a81774f5e06f1b45118b65c7253da", "filename": "src/test/compile-fail/deriving-primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(FromPrimitive)] //~ERROR `#[derive]` for custom traits is not stable\n+#[derive(FromPrimitive)] //~ERROR cannot find derive macro `FromPrimitive` in this scope\n enum Foo {}\n \n fn main() {}"}, {"sha": "f467ba3b1e19521a8e161573ea538c494ea5e34a", "filename": "src/test/compile-fail/macro-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-error.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -16,5 +16,5 @@ fn main() {\n     foo!(0); // Check that we report errors at macro definition, not expansion.\n \n     let _: cfg!(foo) = (); //~ ERROR non-type macro in type position\n-    derive!(); //~ ERROR `derive` can only be used in attributes\n+    derive!(); //~ ERROR macro undefined: 'derive!'\n }"}, {"sha": "3f710af8ac9a883f0c31ac5161e2828b3998771f", "filename": "src/test/compile-fail/macros-nonfatal-errors.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -14,9 +14,11 @@\n #![feature(asm)]\n #![feature(trace_macros, concat_idents)]\n \n-#[derive(Default, //~ ERROR\n-           Zero)] //~ ERROR\n-enum CantDeriveThose {}\n+#[derive(Zero)] //~ ERROR\n+struct CantDeriveThis;\n+\n+#[derive(Default)] //~ ERROR\n+enum OrDeriveThis {}\n \n fn main() {\n     doesnt_exist!(); //~ ERROR"}, {"sha": "f74ff55e2c08e406399443b2c7a4ca49a3a3c7c1", "filename": "src/test/compile-fail/no-link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-link.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -12,7 +12,7 @@\n \n #[no_link]\n extern crate empty_struct;\n-//~^ WARN custom derive crates and `#[no_link]` crates have no effect without `#[macro_use]`\n+//~^ WARN proc macro crates and `#[no_link]` crates have no effect without `#[macro_use]`\n \n fn main() {\n     empty_struct::XEmpty1; //~ ERROR cannot find value `XEmpty1` in module `empty_struct`"}, {"sha": "a1c581a18682c5a1fdf5373568a0e2e080027ee1", "filename": "src/test/pretty/attr-derive.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fpretty%2Fattr-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fpretty%2Fattr-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-derive.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-foo.rs\n+// ignore-stage1\n+// pp-exact\n+// Testing that both the inner item and next outer item are\n+// preserved, and that the first outer item parsed in main is not\n+// accidentally carried over to each inner function\n+\n+#[macro_use]\n+extern crate derive_foo;\n+\n+#[derive(Foo)]\n+struct X;\n+\n+#[derive(Foo)]\n+#[Bar]\n+struct Y;\n+\n+#[derive(Foo)]\n+struct WithRef {\n+    x: X,\n+    #[Bar]\n+    y: Y,\n+}\n+\n+#[derive(Foo)]\n+enum Enum {\n+\n+    #[Bar]\n+    Asdf,\n+    Qwerty,\n+}\n+\n+fn main() { }"}, {"sha": "1ffacaa9f5a5d89bbc6add9c3674d0ec2ba77cfb", "filename": "src/test/pretty/attr-variant-data.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/65b24779a95d306ac9abd73bf430380e925e765e/src%2Ftest%2Fpretty%2Fattr-variant-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b24779a95d306ac9abd73bf430380e925e765e/src%2Ftest%2Fpretty%2Fattr-variant-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-variant-data.rs?ref=65b24779a95d306ac9abd73bf430380e925e765e", "patch": "@@ -1,51 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pp-exact\n-// Testing that both the inner item and next outer item are\n-// preserved, and that the first outer item parsed in main is not\n-// accidentally carried over to each inner function\n-\n-#![feature(custom_attribute)]\n-#![feature(custom_derive)]\n-\n-#[derive(Serialize, Deserialize)]\n-struct X;\n-\n-#[derive(Serialize, Deserialize)]\n-struct WithRef<'a, T: 'a> {\n-    #[serde(skip_deserializing)]\n-    t: Option<&'a T>,\n-    #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n-    x: X,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-enum EnumWith<T> {\n-    Unit,\n-    Newtype(\n-            #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n-            X),\n-    Tuple(T,\n-          #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n-          X),\n-    Struct {\n-        t: T,\n-        #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n-        x: X,\n-    },\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-struct Tuple<T>(T,\n-                #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n-                X);\n-\n-fn main() { }"}, {"sha": "bd81d3e5a3b53f26260647f268cbfebe0127726c", "filename": "src/test/pretty/auxiliary/derive-foo.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fpretty%2Fauxiliary%2Fderive-foo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fpretty%2Fauxiliary%2Fderive-foo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fauxiliary%2Fderive-foo.rs?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Foo, attributes(Bar))]\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    \"\".parse().unwrap()\n+}"}, {"sha": "9a5e2de14e3b0788754bee7982778fea7adb0253", "filename": "src/test/ui/custom-derive/issue-36935.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/805a99e6cb37ab9d6a873f8e1fdf57f08b508e73/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr?ref=805a99e6cb37ab9d6a873f8e1fdf57f08b508e73", "patch": "@@ -1,4 +1,4 @@\n-error: custom derive attribute panicked\n+error: proc-macro derive panicked\n   --> $DIR/issue-36935.rs:17:15\n    |\n 17 | #[derive(Foo, Bar)]"}]}