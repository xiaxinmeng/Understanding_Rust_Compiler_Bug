{"sha": "05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3", "node_id": "C_kwDOAAsO6NoAKDA1Zjk1Y2JiMGNjMmMwN2QzZjI3MzgzOGM2MDIzZTdkY2ZkMGMwZDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-15T09:19:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-15T09:19:13Z"}, "message": "Auto merge of #14354 - Veykril:sighelp, r=Veykril\n\nfeat: Add signature help for record and tuple struct patterns", "tree": {"sha": "584b8ac9b6c233e59aac7adc5a15b2ac46d69ced", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/584b8ac9b6c233e59aac7adc5a15b2ac46d69ced"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3", "html_url": "https://github.com/rust-lang/rust/commit/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60548db111e579b12b259734ae8613eedb6aec60", "url": "https://api.github.com/repos/rust-lang/rust/commits/60548db111e579b12b259734ae8613eedb6aec60", "html_url": "https://github.com/rust-lang/rust/commit/60548db111e579b12b259734ae8613eedb6aec60"}, {"sha": "55120b3d83ff3608b392e3af80491f1eab2cd238", "url": "https://api.github.com/repos/rust-lang/rust/commits/55120b3d83ff3608b392e3af80491f1eab2cd238", "html_url": "https://github.com/rust-lang/rust/commit/55120b3d83ff3608b392e3af80491f1eab2cd238"}], "stats": {"total": 300, "additions": 281, "deletions": 19}, "files": [{"sha": "407ba6f65844e7b426450a81c4e001985b9ffa8e", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3", "patch": "@@ -411,7 +411,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_record_field(field)\n     }\n \n-    pub fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<Field> {\n+    pub fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<(Field, Type)> {\n         self.imp.resolve_record_pat_field(field)\n     }\n \n@@ -1201,7 +1201,7 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(field.syntax())?.resolve_record_field(self.db, field)\n     }\n \n-    fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<Field> {\n+    fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<(Field, Type)> {\n         self.analyze(field.syntax())?.resolve_record_pat_field(self.db, field)\n     }\n "}, {"sha": "c24d196e1b6247857764f9898fd17c623069bdc0", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3", "patch": "@@ -441,14 +441,17 @@ impl SourceAnalyzer {\n         &self,\n         db: &dyn HirDatabase,\n         field: &ast::RecordPatField,\n-    ) -> Option<Field> {\n+    ) -> Option<(Field, Type)> {\n         let field_name = field.field_name()?.as_name();\n         let record_pat = ast::RecordPat::cast(field.syntax().parent().and_then(|p| p.parent())?)?;\n         let pat_id = self.pat_id(&record_pat.into())?;\n         let variant = self.infer.as_ref()?.variant_resolution_for_pat(pat_id)?;\n         let variant_data = variant.variant_data(db.upcast());\n         let field = FieldId { parent: variant, local_id: variant_data.field(&field_name)? };\n-        Some(field.into())\n+        let (_, subst) = self.infer.as_ref()?.type_of_pat.get(pat_id)?.as_adt()?;\n+        let field_ty =\n+            db.field_types(variant).get(field.local_id)?.clone().substitute(Interner, subst);\n+        Some((field.into(), Type::new_with_resolver(db, &self.resolver, field_ty)))\n     }\n \n     pub(crate) fn resolve_macro_call("}, {"sha": "4071c490b7fc39546812ad04375c17b292305f54", "filename": "crates/ide-db/src/defs.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/crates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/crates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fdefs.rs?ref=05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3", "patch": "@@ -327,7 +327,7 @@ impl NameClass {\n             let pat_parent = ident_pat.syntax().parent();\n             if let Some(record_pat_field) = pat_parent.and_then(ast::RecordPatField::cast) {\n                 if record_pat_field.name_ref().is_none() {\n-                    if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n+                    if let Some((field, _)) = sema.resolve_record_pat_field(&record_pat_field) {\n                         return Some(NameClass::PatFieldShorthand {\n                             local_def: local,\n                             field_ref: field,\n@@ -483,6 +483,13 @@ impl NameRefClass {\n                 },\n                 ast::RecordPatField(record_pat_field) => {\n                     sema.resolve_record_pat_field(&record_pat_field)\n+                        .map(|(field, ..)|field)\n+                        .map(Definition::Field)\n+                        .map(NameRefClass::Definition)\n+                },\n+                ast::RecordExprField(record_expr_field) => {\n+                    sema.resolve_record_field(&record_expr_field)\n+                        .map(|(field, ..)|field)\n                         .map(Definition::Field)\n                         .map(NameRefClass::Definition)\n                 },"}, {"sha": "6d2d0bd635165b2bba55a7ff4fccd6b74fbe03d4", "filename": "crates/ide/src/goto_type_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs?ref=05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3", "patch": "@@ -55,7 +55,7 @@ pub(crate) fn goto_type_definition(\n                                 ty\n                             } else {\n                                 let record_field = ast::RecordPatField::for_field_name_ref(&it)?;\n-                                sema.resolve_record_pat_field(&record_field)?.ty(db)\n+                                sema.resolve_record_pat_field(&record_field)?.1\n                             }\n                         },\n                         _ => return None,"}, {"sha": "4b2c139f6f455b3f8fa5ad462c6343d5d9faaeed", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 257, "deletions": 6, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3", "patch": "@@ -16,7 +16,7 @@ use stdx::format_to;\n use syntax::{\n     algo,\n     ast::{self, HasArgList},\n-    match_ast, AstNode, Direction, SyntaxToken, TextRange, TextSize,\n+    match_ast, AstNode, Direction, SyntaxElementChildren, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::RootDatabase;\n@@ -102,6 +102,20 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n                     }\n                     return signature_help_for_record_lit(&sema, record, token);\n                 },\n+                ast::RecordPat(record) => {\n+                    let cursor_outside = record.record_pat_field_list().and_then(|list| list.r_curly_token()).as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_record_pat(&sema, record, token);\n+                },\n+                ast::TupleStructPat(tuple_pat) => {\n+                    let cursor_outside = tuple_pat.r_paren_token().as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_tuple_struct_pat(&sema, tuple_pat, token);\n+                },\n                 _ => (),\n             }\n         }\n@@ -346,10 +360,111 @@ fn signature_help_for_record_lit(\n     record: ast::RecordExpr,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let active_parameter = record\n-        .record_expr_field_list()?\n+    signature_help_for_record_(\n+        sema,\n+        record.record_expr_field_list()?.syntax().children_with_tokens(),\n+        &record.path()?,\n+        record\n+            .record_expr_field_list()?\n+            .fields()\n+            .filter_map(|field| sema.resolve_record_field(&field))\n+            .map(|(field, _, ty)| (field, ty)),\n+        token,\n+    )\n+}\n+\n+fn signature_help_for_record_pat(\n+    sema: &Semantics<'_, RootDatabase>,\n+    record: ast::RecordPat,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    signature_help_for_record_(\n+        sema,\n+        record.record_pat_field_list()?.syntax().children_with_tokens(),\n+        &record.path()?,\n+        record\n+            .record_pat_field_list()?\n+            .fields()\n+            .filter_map(|field| sema.resolve_record_pat_field(&field)),\n+        token,\n+    )\n+}\n+\n+fn signature_help_for_tuple_struct_pat(\n+    sema: &Semantics<'_, RootDatabase>,\n+    pat: ast::TupleStructPat,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let rest_pat = pat.fields().find(|it| matches!(it, ast::Pat::RestPat(_)));\n+    let is_left_of_rest_pat =\n+        rest_pat.map_or(true, |it| token.text_range().start() < it.syntax().text_range().end());\n+\n+    let mut res = SignatureHelp {\n+        doc: None,\n+        signature: String::new(),\n+        parameters: vec![],\n+        active_parameter: None,\n+    };\n+\n+    let db = sema.db;\n+    let path_res = sema.resolve_path(&pat.path()?)?;\n+    let fields: Vec<_> = if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {\n+        let en = variant.parent_enum(db);\n+\n+        res.doc = en.docs(db).map(|it| it.into());\n+        format_to!(res.signature, \"enum {}::{} (\", en.name(db), variant.name(db));\n+        variant.fields(db)\n+    } else {\n+        let adt = match path_res {\n+            PathResolution::SelfType(imp) => imp.self_ty(db).as_adt()?,\n+            PathResolution::Def(ModuleDef::Adt(adt)) => adt,\n+            _ => return None,\n+        };\n+\n+        match adt {\n+            hir::Adt::Struct(it) => {\n+                res.doc = it.docs(db).map(|it| it.into());\n+                format_to!(res.signature, \"struct {} (\", it.name(db));\n+                it.fields(db)\n+            }\n+            _ => return None,\n+        }\n+    };\n+    let commas = pat\n         .syntax()\n         .children_with_tokens()\n+        .filter_map(syntax::NodeOrToken::into_token)\n+        .filter(|t| t.kind() == syntax::T![,]);\n+    res.active_parameter = Some(if is_left_of_rest_pat {\n+        commas.take_while(|t| t.text_range().start() <= token.text_range().start()).count()\n+    } else {\n+        let n_commas = commas\n+            .collect::<Vec<_>>()\n+            .into_iter()\n+            .rev()\n+            .take_while(|t| t.text_range().start() > token.text_range().start())\n+            .count();\n+        fields.len().saturating_sub(1).saturating_sub(n_commas)\n+    });\n+\n+    let mut buf = String::new();\n+    for ty in fields.into_iter().map(|it| it.ty(db)) {\n+        format_to!(buf, \"{}\", ty.display_truncated(db, Some(20)));\n+        res.push_call_param(&buf);\n+        buf.clear();\n+    }\n+    res.signature.push_str(\")\");\n+    Some(res)\n+}\n+\n+fn signature_help_for_record_(\n+    sema: &Semantics<'_, RootDatabase>,\n+    field_list_children: SyntaxElementChildren,\n+    path: &ast::Path,\n+    fields2: impl Iterator<Item = (hir::Field, hir::Type)>,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let active_parameter = field_list_children\n         .filter_map(syntax::NodeOrToken::into_token)\n         .filter(|t| t.kind() == syntax::T![,])\n         .take_while(|t| t.text_range().start() <= token.text_range().start())\n@@ -365,7 +480,7 @@ fn signature_help_for_record_lit(\n     let fields;\n \n     let db = sema.db;\n-    let path_res = sema.resolve_path(&record.path()?)?;\n+    let path_res = sema.resolve_path(path)?;\n     if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {\n         fields = variant.fields(db);\n         let en = variant.parent_enum(db);\n@@ -397,8 +512,7 @@ fn signature_help_for_record_lit(\n     let mut fields =\n         fields.into_iter().map(|field| (field.name(db), Some(field))).collect::<FxIndexMap<_, _>>();\n     let mut buf = String::new();\n-    for field in record.record_expr_field_list()?.fields() {\n-        let Some((field, _, ty)) = sema.resolve_record_field(&field) else { continue };\n+    for (field, ty) in fields2 {\n         let name = field.name(db);\n         format_to!(buf, \"{name}: {}\", ty.display_truncated(db, Some(20)));\n         res.push_record_field(&buf);\n@@ -439,6 +553,7 @@ mod tests {\n         (database, FilePosition { file_id, offset })\n     }\n \n+    #[track_caller]\n     fn check(ra_fixture: &str, expect: Expect) {\n         let fixture = format!(\n             r#\"\n@@ -890,6 +1005,119 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn tuple_struct_pat() {\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32);\n+fn main() {\n+    let S(0, $0);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32)\n+                          ---  ^^^\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_struct_pat_rest() {\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S(0, .., $0);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ---  ---  ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16, u8);\n+fn main() {\n+    let S(0, .., $0, 0);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16, u8)\n+                          ---  ---  ---  ^^^  --\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S($0, .., 1);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ^^^  ---  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16, u8);\n+fn main() {\n+    let S(1, .., 1, $0, 2);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16, u8)\n+                          ---  ---  ---  ^^^  --\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S(1, $0.., 1);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ---  ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S(1, ..$0, 1);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ---  ^^^  ---  ---\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn generic_struct() {\n         check(\n@@ -1550,6 +1778,29 @@ impl S {\n         );\n     }\n \n+    #[test]\n+    fn record_pat() {\n+        check(\n+            r#\"\n+struct Strukt<T, U = ()> {\n+    t: T,\n+    u: U,\n+    unit: (),\n+}\n+fn f() {\n+    let Strukt {\n+        u: 0,\n+        $0\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                struct Strukt { u: i32, t: T, unit: () }\n+                                ------  ^^^^  --------\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_enum_in_nested_method_in_lambda() {\n         check("}, {"sha": "5f4977886f6ebe076fde8f190af25ac50af95d0c", "filename": "crates/parser/src/grammar/patterns.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=05f95cbb0cc2c07d3f273838c6023e7dcfd0c0d3", "patch": "@@ -431,14 +431,15 @@ fn slice_pat(p: &mut Parser<'_>) -> CompletedMarker {\n \n fn pat_list(p: &mut Parser<'_>, ket: SyntaxKind) {\n     while !p.at(EOF) && !p.at(ket) {\n-        if !p.at_ts(PAT_TOP_FIRST) {\n-            p.error(\"expected a pattern\");\n-            break;\n-        }\n-\n         pattern_top(p);\n-        if !p.at(ket) {\n-            p.expect(T![,]);\n+        if !p.at(T![,]) {\n+            if p.at_ts(PAT_TOP_FIRST) {\n+                p.error(format!(\"expected {:?}, got {:?}\", T![,], p.current()));\n+            } else {\n+                break;\n+            }\n+        } else {\n+            p.bump(T![,]);\n         }\n     }\n }"}]}