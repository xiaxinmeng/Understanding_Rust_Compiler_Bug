{"sha": "fb5dd398f677213e8f0943638c9205172a634efe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNWRkMzk4ZjY3NzIxM2U4ZjA5NDM2MzhjOTIwNTE3MmE2MzRlZmU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-06-29T23:31:07Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-06-29T23:31:07Z"}, "message": "Remove now-useless code", "tree": {"sha": "2324417be72ebadd942448e32197c78a2fc05324", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2324417be72ebadd942448e32197c78a2fc05324"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb5dd398f677213e8f0943638c9205172a634efe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb5dd398f677213e8f0943638c9205172a634efe", "html_url": "https://github.com/rust-lang/rust/commit/fb5dd398f677213e8f0943638c9205172a634efe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb5dd398f677213e8f0943638c9205172a634efe/comments", "author": null, "committer": null, "parents": [{"sha": "a5e21daa1909f538ddd696f7baffad4603f38a5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5e21daa1909f538ddd696f7baffad4603f38a5d", "html_url": "https://github.com/rust-lang/rust/commit/a5e21daa1909f538ddd696f7baffad4603f38a5d"}], "stats": {"total": 52, "additions": 12, "deletions": 40}, "files": [{"sha": "588e4cea5048b599c7615139b761f3c2711211ba", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 12, "deletions": 40, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fb5dd398f677213e8f0943638c9205172a634efe/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5dd398f677213e8f0943638c9205172a634efe/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=fb5dd398f677213e8f0943638c9205172a634efe", "patch": "@@ -199,7 +199,6 @@ pub struct CachedEarlyExit {\n \n pub trait Cleanup<'tcx> {\n     fn must_unwind(&self) -> bool;\n-    fn clean_on_unwind(&self) -> bool;\n     fn is_lifetime_end(&self) -> bool;\n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n@@ -776,29 +775,19 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         //\n         // At this point, `popped_scopes` is empty, and so the final block\n         // that we return to the user is `Cleanup(AST 24)`.\n-        while !popped_scopes.is_empty() {\n-            let mut scope = popped_scopes.pop().unwrap();\n-\n-            if scope.cleanups.iter().any(|c| cleanup_is_suitable_for(&**c, label))\n-            {\n-                let name = scope.block_name(\"clean\");\n-                debug!(\"generating cleanups for {}\", name);\n-                let bcx_in = self.new_block(label.is_unwind(),\n-                                            &name[..],\n-                                            None);\n-                let mut bcx_out = bcx_in;\n-                for cleanup in scope.cleanups.iter().rev() {\n-                    if cleanup_is_suitable_for(&**cleanup, label) {\n-                        bcx_out = cleanup.trans(bcx_out,\n-                                                scope.debug_loc);\n-                    }\n-                }\n-                build::Br(bcx_out, prev_llbb, DebugLoc::None);\n-                prev_llbb = bcx_in.llbb;\n-            } else {\n-                debug!(\"no suitable cleanups in {}\",\n-                       scope.block_name(\"clean\"));\n+        while let Some(mut scope) = popped_scopes.pop() {\n+            let name = scope.block_name(\"clean\");\n+            debug!(\"generating cleanups for {}\", name);\n+            let bcx_in = self.new_block(label.is_unwind(),\n+                                        &name[..],\n+                                        None);\n+            let mut bcx_out = bcx_in;\n+            for cleanup in scope.cleanups.iter().rev() {\n+                bcx_out = cleanup.trans(bcx_out,\n+                                        scope.debug_loc);\n             }\n+            build::Br(bcx_out, prev_llbb, DebugLoc::None);\n+            prev_llbb = bcx_in.llbb;\n \n             scope.add_cached_early_exit(label, prev_llbb);\n             self.push_scope(scope);\n@@ -1038,10 +1027,6 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n         true\n     }\n \n-    fn clean_on_unwind(&self) -> bool {\n-        true\n-    }\n-\n     fn is_lifetime_end(&self) -> bool {\n         false\n     }\n@@ -1085,10 +1070,6 @@ impl<'tcx> Cleanup<'tcx> for FreeValue<'tcx> {\n         true\n     }\n \n-    fn clean_on_unwind(&self) -> bool {\n-        true\n-    }\n-\n     fn is_lifetime_end(&self) -> bool {\n         false\n     }\n@@ -1118,10 +1099,6 @@ impl<'tcx> Cleanup<'tcx> for LifetimeEnd {\n         false\n     }\n \n-    fn clean_on_unwind(&self) -> bool {\n-        true\n-    }\n-\n     fn is_lifetime_end(&self) -> bool {\n         true\n     }\n@@ -1160,11 +1137,6 @@ pub fn var_scope(tcx: &ty::ctxt,\n     r\n }\n \n-fn cleanup_is_suitable_for(c: &Cleanup,\n-                           label: EarlyExitLabel) -> bool {\n-    !label.is_unwind() || c.clean_on_unwind()\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // These traits just exist to put the methods into this file.\n "}]}