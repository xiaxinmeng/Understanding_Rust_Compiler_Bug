{"sha": "2076959336a1751bccfb24e1b8e0107341bec58a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNzY5NTkzMzZhMTc1MWJjY2ZiMjRlMWI4ZTAxMDczNDFiZWM1OGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-09T22:31:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-09T22:31:26Z"}, "message": "auto merge of #9750 : alexcrichton/rust/safer-strings, r=brson\n\nThis behavior was decided to get out-right forbidden by the compiler\r\n\r\n\r\nCloses #8891", "tree": {"sha": "3c524613c5d2ea8605935f10e6323b02dc23f938", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c524613c5d2ea8605935f10e6323b02dc23f938"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2076959336a1751bccfb24e1b8e0107341bec58a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2076959336a1751bccfb24e1b8e0107341bec58a", "html_url": "https://github.com/rust-lang/rust/commit/2076959336a1751bccfb24e1b8e0107341bec58a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2076959336a1751bccfb24e1b8e0107341bec58a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11d56706479982fd074130a6c9af2bb74968baf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/11d56706479982fd074130a6c9af2bb74968baf2", "html_url": "https://github.com/rust-lang/rust/commit/11d56706479982fd074130a6c9af2bb74968baf2"}, {"sha": "a69e4a55eb3f0b0daa4bb2fde93ee25d98b499f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a69e4a55eb3f0b0daa4bb2fde93ee25d98b499f2", "html_url": "https://github.com/rust-lang/rust/commit/a69e4a55eb3f0b0daa4bb2fde93ee25d98b499f2"}], "stats": {"total": 214, "additions": 118, "deletions": 96}, "files": [{"sha": "8cc4c23bd1c702a81746756c79b1e54d61008348", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 100, "deletions": 96, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/2076959336a1751bccfb24e1b8e0107341bec58a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2076959336a1751bccfb24e1b8e0107341bec58a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=2076959336a1751bccfb24e1b8e0107341bec58a", "patch": "@@ -11,19 +11,14 @@\n //! Enforces the Rust effect system. Currently there is just one effect,\n /// `unsafe`.\n \n-use middle::ty::{ty_bare_fn, ty_closure, ty_ptr};\n use middle::ty;\n use middle::typeck::method_map;\n use util::ppaux;\n \n-use syntax::ast::{UnDeref, ExprCall, ExprInlineAsm, ExprMethodCall};\n-use syntax::ast::{ExprUnary, unsafe_fn, ExprPath};\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::visit::{fk_item_fn, fk_method};\n use syntax::visit;\n-use syntax::visit::{Visitor,fn_kind};\n-use syntax::ast::{fn_decl,Block,NodeId,Expr};\n+use syntax::visit::Visitor;\n \n #[deriving(Eq)]\n enum UnsafeContext {\n@@ -32,29 +27,26 @@ enum UnsafeContext {\n     UnsafeBlock(ast::NodeId),\n }\n \n-struct Context {\n-    /// The method map.\n-    method_map: method_map,\n-    /// Whether we're in an unsafe context.\n-    unsafe_context: UnsafeContext,\n-}\n-\n fn type_is_unsafe_function(ty: ty::t) -> bool {\n     match ty::get(ty).sty {\n-        ty_bare_fn(ref f) => f.purity == unsafe_fn,\n-        ty_closure(ref f) => f.purity == unsafe_fn,\n+        ty::ty_bare_fn(ref f) => f.purity == ast::unsafe_fn,\n+        ty::ty_closure(ref f) => f.purity == ast::unsafe_fn,\n         _ => false,\n     }\n }\n \n struct EffectCheckVisitor {\n     tcx: ty::ctxt,\n-    context: @mut Context,\n+\n+    /// The method map.\n+    method_map: method_map,\n+    /// Whether we're in an unsafe context.\n+    unsafe_context: UnsafeContext,\n }\n \n impl EffectCheckVisitor {\n     fn require_unsafe(&mut self, span: Span, description: &str) {\n-        match self.context.unsafe_context {\n+        match self.unsafe_context {\n             SafeContext => {\n                 // Report an error.\n                 self.tcx.sess.span_err(span,\n@@ -69,112 +61,124 @@ impl EffectCheckVisitor {\n             UnsafeFn => {}\n         }\n     }\n+\n+    fn check_str_index(&mut self, e: @ast::Expr) {\n+        let base_type = match e.node {\n+            ast::ExprIndex(_, base, _) => ty::node_id_to_type(self.tcx, base.id),\n+            _ => return\n+        };\n+        debug2!(\"effect: checking index with base type {}\",\n+                ppaux::ty_to_str(self.tcx, base_type));\n+        match ty::get(base_type).sty {\n+            ty::ty_estr(*) => {\n+                self.tcx.sess.span_err(e.span,\n+                    \"modification of string types is not allowed\");\n+            }\n+            _ => {}\n+        }\n+    }\n }\n \n impl Visitor<()> for EffectCheckVisitor {\n-    fn visit_fn(&mut self, fn_kind:&fn_kind, fn_decl:&fn_decl,\n-                block:&Block, span:Span, node_id:NodeId, _:()) {\n-\n-            let (is_item_fn, is_unsafe_fn) = match *fn_kind {\n-                fk_item_fn(_, _, purity, _) => (true, purity == unsafe_fn),\n-                fk_method(_, _, method) => (true, method.purity == unsafe_fn),\n-                _ => (false, false),\n-            };\n-\n-            let old_unsafe_context = self.context.unsafe_context;\n-            if is_unsafe_fn {\n-                self.context.unsafe_context = UnsafeFn\n-            } else if is_item_fn {\n-                self.context.unsafe_context = SafeContext\n-            }\n+    fn visit_fn(&mut self, fn_kind: &visit::fn_kind, fn_decl: &ast::fn_decl,\n+                block: &ast::Block, span: Span, node_id: ast::NodeId, _:()) {\n+\n+        let (is_item_fn, is_unsafe_fn) = match *fn_kind {\n+            visit::fk_item_fn(_, _, purity, _) =>\n+                (true, purity == ast::unsafe_fn),\n+            visit::fk_method(_, _, method) =>\n+                (true, method.purity == ast::unsafe_fn),\n+            _ => (false, false),\n+        };\n+\n+        let old_unsafe_context = self.unsafe_context;\n+        if is_unsafe_fn {\n+            self.unsafe_context = UnsafeFn\n+        } else if is_item_fn {\n+            self.unsafe_context = SafeContext\n+        }\n \n-            visit::walk_fn(self,\n-                           fn_kind,\n-                            fn_decl,\n-                            block,\n-                            span,\n-                            node_id,\n-                            ());\n+        visit::walk_fn(self, fn_kind, fn_decl, block, span, node_id, ());\n \n-            self.context.unsafe_context = old_unsafe_context\n+        self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_block(&mut self, block:&Block, _:()) {\n-\n-            let old_unsafe_context = self.context.unsafe_context;\n-            let is_unsafe = match block.rules {\n-                ast::UnsafeBlock(*) => true, ast::DefaultBlock => false\n-            };\n-            if is_unsafe && self.context.unsafe_context == SafeContext {\n-                self.context.unsafe_context = UnsafeBlock(block.id)\n-            }\n+    fn visit_block(&mut self, block: &ast::Block, _:()) {\n+        let old_unsafe_context = self.unsafe_context;\n+        let is_unsafe = match block.rules {\n+            ast::UnsafeBlock(*) => true, ast::DefaultBlock => false\n+        };\n+        if is_unsafe && self.unsafe_context == SafeContext {\n+            self.unsafe_context = UnsafeBlock(block.id)\n+        }\n \n-            visit::walk_block(self, block, ());\n+        visit::walk_block(self, block, ());\n \n-            self.context.unsafe_context = old_unsafe_context\n+        self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_expr(&mut self, expr:@Expr, _:()) {\n-\n-            match expr.node {\n-                ExprMethodCall(callee_id, _, _, _, _, _) => {\n-                    let base_type = ty::node_id_to_type(self.tcx, callee_id);\n-                    debug2!(\"effect: method call case, base type is {}\",\n-                           ppaux::ty_to_str(self.tcx, base_type));\n-                    if type_is_unsafe_function(base_type) {\n-                        self.require_unsafe(expr.span,\n-                                       \"invocation of unsafe method\")\n-                    }\n+    fn visit_expr(&mut self, expr: @ast::Expr, _:()) {\n+        match expr.node {\n+            ast::ExprMethodCall(callee_id, _, _, _, _, _) => {\n+                let base_type = ty::node_id_to_type(self.tcx, callee_id);\n+                debug2!(\"effect: method call case, base type is {}\",\n+                       ppaux::ty_to_str(self.tcx, base_type));\n+                if type_is_unsafe_function(base_type) {\n+                    self.require_unsafe(expr.span,\n+                                        \"invocation of unsafe method\")\n                 }\n-                ExprCall(base, _, _) => {\n-                    let base_type = ty::node_id_to_type(self.tcx, base.id);\n-                    debug2!(\"effect: call case, base type is {}\",\n-                           ppaux::ty_to_str(self.tcx, base_type));\n-                    if type_is_unsafe_function(base_type) {\n-                        self.require_unsafe(expr.span, \"call to unsafe function\")\n-                    }\n+            }\n+            ast::ExprCall(base, _, _) => {\n+                let base_type = ty::node_id_to_type(self.tcx, base.id);\n+                debug2!(\"effect: call case, base type is {}\",\n+                       ppaux::ty_to_str(self.tcx, base_type));\n+                if type_is_unsafe_function(base_type) {\n+                    self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n-                ExprUnary(_, UnDeref, base) => {\n-                    let base_type = ty::node_id_to_type(self.tcx, base.id);\n-                    debug2!(\"effect: unary case, base type is {}\",\n-                           ppaux::ty_to_str(self.tcx, base_type));\n-                    match ty::get(base_type).sty {\n-                        ty_ptr(_) => {\n-                            self.require_unsafe(expr.span,\n-                                           \"dereference of unsafe pointer\")\n-                        }\n-                        _ => {}\n+            }\n+            ast::ExprUnary(_, ast::UnDeref, base) => {\n+                let base_type = ty::node_id_to_type(self.tcx, base.id);\n+                debug2!(\"effect: unary case, base type is {}\",\n+                        ppaux::ty_to_str(self.tcx, base_type));\n+                match ty::get(base_type).sty {\n+                    ty::ty_ptr(_) => {\n+                        self.require_unsafe(expr.span,\n+                                            \"dereference of unsafe pointer\")\n                     }\n+                    _ => {}\n                 }\n-                ExprInlineAsm(*) => {\n-                    self.require_unsafe(expr.span, \"use of inline assembly\")\n-                }\n-                ExprPath(*) => {\n-                    match ty::resolve_expr(self.tcx, expr) {\n-                        ast::DefStatic(_, true) => {\n-                            self.require_unsafe(expr.span, \"use of mutable static\")\n-                        }\n-                        _ => {}\n+            }\n+            ast::ExprAssign(base, _) | ast::ExprAssignOp(_, _, base, _) => {\n+                self.check_str_index(base);\n+            }\n+            ast::ExprAddrOf(ast::MutMutable, base) => {\n+                self.check_str_index(base);\n+            }\n+            ast::ExprInlineAsm(*) => {\n+                self.require_unsafe(expr.span, \"use of inline assembly\")\n+            }\n+            ast::ExprPath(*) => {\n+                match ty::resolve_expr(self.tcx, expr) {\n+                    ast::DefStatic(_, true) => {\n+                        self.require_unsafe(expr.span, \"use of mutable static\")\n                     }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n+            _ => {}\n+        }\n \n-            visit::walk_expr(self, expr, ());\n+        visit::walk_expr(self, expr, ());\n     }\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: method_map,\n                    crate: &ast::Crate) {\n-    let context = @mut Context {\n-        method_map: method_map,\n-        unsafe_context: SafeContext,\n-    };\n-\n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n-        context: context,\n+        method_map: method_map,\n+        unsafe_context: SafeContext,\n     };\n \n     visit::walk_crate(&mut visitor, crate, ());"}, {"sha": "2a9f132fa524c5eeca3f6c5d3f2a9a85ac334fa0", "filename": "src/test/compile-fail/unsafe-modifying-str.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2076959336a1751bccfb24e1b8e0107341bec58a/src%2Ftest%2Fcompile-fail%2Funsafe-modifying-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2076959336a1751bccfb24e1b8e0107341bec58a/src%2Ftest%2Fcompile-fail%2Funsafe-modifying-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-modifying-str.rs?ref=2076959336a1751bccfb24e1b8e0107341bec58a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let mut s = ~\"test\";\n+    s[0] = 3; //~ ERROR: not allowed\n+    s[0] += 3; //~ ERROR: not allowed\n+    {\n+        let _a = &mut s[0]; //~ ERROR: not allowed\n+    }\n+}"}]}