{"sha": "ca7418b84658fc1c723672c462aa0a7878d88b64", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNzQxOGI4NDY1OGZjMWM3MjM2NzJjNDYyYWEwYTc4NzhkODhiNjQ=", "commit": {"author": {"name": "Joshua Landau", "email": "joshua@landau.ws", "date": "2015-06-10T16:22:20Z"}, "committer": {"name": "Joshua Landau", "email": "joshua@landau.ws", "date": "2015-06-10T20:14:03Z"}, "message": "Removed many pointless calls to *iter() and iter_mut()", "tree": {"sha": "6fba2849520c8c205c53ca12aaa8445eb8e03ab9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fba2849520c8c205c53ca12aaa8445eb8e03ab9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca7418b84658fc1c723672c462aa0a7878d88b64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca7418b84658fc1c723672c462aa0a7878d88b64", "html_url": "https://github.com/rust-lang/rust/commit/ca7418b84658fc1c723672c462aa0a7878d88b64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca7418b84658fc1c723672c462aa0a7878d88b64/comments", "author": {"login": "Veedrac", "id": 2867413, "node_id": "MDQ6VXNlcjI4Njc0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2867413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veedrac", "html_url": "https://github.com/Veedrac", "followers_url": "https://api.github.com/users/Veedrac/followers", "following_url": "https://api.github.com/users/Veedrac/following{/other_user}", "gists_url": "https://api.github.com/users/Veedrac/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veedrac/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veedrac/subscriptions", "organizations_url": "https://api.github.com/users/Veedrac/orgs", "repos_url": "https://api.github.com/users/Veedrac/repos", "events_url": "https://api.github.com/users/Veedrac/events{/privacy}", "received_events_url": "https://api.github.com/users/Veedrac/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veedrac", "id": 2867413, "node_id": "MDQ6VXNlcjI4Njc0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2867413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veedrac", "html_url": "https://github.com/Veedrac", "followers_url": "https://api.github.com/users/Veedrac/followers", "following_url": "https://api.github.com/users/Veedrac/following{/other_user}", "gists_url": "https://api.github.com/users/Veedrac/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veedrac/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veedrac/subscriptions", "organizations_url": "https://api.github.com/users/Veedrac/orgs", "repos_url": "https://api.github.com/users/Veedrac/repos", "events_url": "https://api.github.com/users/Veedrac/events{/privacy}", "received_events_url": "https://api.github.com/users/Veedrac/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8a9570154dfbc4032cb3a6ba8b51c6256518dcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8a9570154dfbc4032cb3a6ba8b51c6256518dcd", "html_url": "https://github.com/rust-lang/rust/commit/d8a9570154dfbc4032cb3a6ba8b51c6256518dcd"}], "stats": {"total": 586, "additions": 292, "deletions": 294}, "files": [{"sha": "8b06c3bf18c46cac279fd7d377d076f650df3c2a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -285,8 +285,8 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n                             format!(\"--target={}\", config.target),\n                             \"-L\".to_string(),\n                             aux_dir.to_str().unwrap().to_string());\n-        args.extend(split_maybe_args(&config.target_rustcflags).into_iter());\n-        args.extend(split_maybe_args(&props.compile_flags).into_iter());\n+        args.extend(split_maybe_args(&config.target_rustcflags));\n+        args.extend(split_maybe_args(&props.compile_flags));\n         return ProcArgs {\n             prog: config.rustc_path.to_str().unwrap().to_string(),\n             args: args,\n@@ -333,8 +333,8 @@ actual:\\n\\\n                             config.build_base.to_str().unwrap().to_string(),\n                             \"-L\".to_string(),\n                             aux_dir.to_str().unwrap().to_string());\n-        args.extend(split_maybe_args(&config.target_rustcflags).into_iter());\n-        args.extend(split_maybe_args(&props.compile_flags).into_iter());\n+        args.extend(split_maybe_args(&config.target_rustcflags));\n+        args.extend(split_maybe_args(&props.compile_flags));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         return ProcArgs {\n             prog: config.rustc_path.to_str().unwrap().to_string(),\n@@ -380,7 +380,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             script_str.push_str(&format!(\"set solib-search-path \\\n                                          ./{}/stage2/lib/rustlib/{}/lib/\\n\",\n                                          config.host, config.target));\n-            for line in breakpoint_lines.iter() {\n+            for line in &breakpoint_lines {\n                 script_str.push_str(&format!(\"break {:?}:{}\\n\",\n                                              testfile.file_name().unwrap()\n                                                      .to_string_lossy(),\n@@ -1171,7 +1171,7 @@ fn document(config: &Config, props: &TestProps,\n                         out_dir.to_str().unwrap().to_string(),\n                         testfile.to_str().unwrap().to_string()];\n     args.extend(extra_args.iter().cloned());\n-    args.extend(split_maybe_args(&props.compile_flags).into_iter());\n+    args.extend(split_maybe_args(&props.compile_flags));\n     let args = ProcArgs {\n         prog: config.rustdoc_path.to_str().unwrap().to_string(),\n         args: args,\n@@ -1236,7 +1236,7 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n                 vec!(\"--crate-type=dylib\".to_string())\n             }\n         };\n-        crate_type.extend(extra_link_args.clone().into_iter());\n+        crate_type.extend(extra_link_args.clone());\n         let aux_args =\n             make_compile_args(config,\n                               &aux_props,\n@@ -1334,11 +1334,11 @@ fn make_compile_args<F>(config: &Config,\n     };\n     args.push(path.to_str().unwrap().to_string());\n     if props.force_host {\n-        args.extend(split_maybe_args(&config.host_rustcflags).into_iter());\n+        args.extend(split_maybe_args(&config.host_rustcflags));\n     } else {\n-        args.extend(split_maybe_args(&config.target_rustcflags).into_iter());\n+        args.extend(split_maybe_args(&config.target_rustcflags));\n     }\n-    args.extend(split_maybe_args(&props.compile_flags).into_iter());\n+    args.extend(split_maybe_args(&props.compile_flags));\n     return ProcArgs {\n         prog: config.rustc_path.to_str().unwrap().to_string(),\n         args: args,\n@@ -1373,7 +1373,7 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path)\n     args.push(exe_file.to_str().unwrap().to_string());\n \n     // Add the arguments in the run_flags directive\n-    args.extend(split_maybe_args(&props.run_flags).into_iter());\n+    args.extend(split_maybe_args(&props.run_flags));\n \n     let prog = args.remove(0);\n     return ProcArgs {\n@@ -1683,7 +1683,7 @@ fn compile_test_and_save_ir(config: &Config, props: &TestProps,\n                              aux_dir.to_str().unwrap().to_string());\n     let llvm_args = vec!(\"--emit=llvm-ir\".to_string(),\n                          \"--crate-type=lib\".to_string());\n-    link_args.extend(llvm_args.into_iter());\n+    link_args.extend(llvm_args);\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args,"}, {"sha": "33cb7584580de42733a584256c974e34e9ddecad", "filename": "src/error-index-generator/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ferror-index-generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ferror-index-generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror-index-generator%2Fmain.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -73,7 +73,7 @@ r##\"<!DOCTYPE html>\n \n     try!(write!(&mut output_file, \"<h1>Rust Compiler Error Index</h1>\\n\"));\n \n-    for (err_code, info) in err_map.iter() {\n+    for (err_code, info) in err_map {\n         // Enclose each error in a div so they can be shown/hidden en masse.\n         let desc_desc = match info.description {\n             Some(_) => \"error-described\","}, {"sha": "6a9b41c0fe4e3f8752c07b7d924f4afbf74925d5", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -130,7 +130,7 @@\n //!     gadget_owner.gadgets.borrow_mut().push(gadget2.clone().downgrade());\n //!\n //!     // Iterate over our Gadgets, printing their details out\n-//!     for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n+//!     for gadget_opt in &*gadget_owner.gadgets.borrow() {\n //!\n //!         // gadget_opt is a Weak<Gadget>. Since weak pointers can't guarantee\n //!         // that their object is still allocated, we need to call upgrade()"}, {"sha": "451b1fd61cbdfa8235b24ba053da170241441cf9", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -85,7 +85,7 @@\n //!\n //!         // For each node we can reach, see if we can find a way with\n //!         // a lower cost going through this node\n-//!         for edge in adj_list[position].iter() {\n+//!         for edge in &adj_list[position] {\n //!             let next = State { cost: cost + edge.cost, position: edge.node };\n //!\n //!             // If so, add it to the frontier and continue\n@@ -450,7 +450,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let vec = heap.into_vec();\n     ///\n     /// // Will print in some order\n-    /// for x in vec.iter() {\n+    /// for x in vec {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```"}, {"sha": "562bbe262068f82dc631134af95f95c4d3c8ecae", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -266,9 +266,9 @@ impl BitVec {\n     /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = BitVec::from_elem(10, false);\n+    /// let bv = BitVec::from_elem(10, false);\n     /// assert_eq!(bv.len(), 10);\n-    /// for x in bv.iter() {\n+    /// for x in &bv {\n     ///     assert_eq!(x, false);\n     /// }\n     /// ```\n@@ -1245,7 +1245,7 @@ impl<'a> IntoIterator for &'a BitVec {\n /// s.union_with(&other);\n ///\n /// // Print 0, 1, 3 in some order\n-/// for x in s.iter() {\n+/// for x in &s {\n ///     println!(\"{}\", x);\n /// }\n ///\n@@ -1370,7 +1370,7 @@ impl BitSet {\n     /// let s = BitSet::from_bit_vec(bv);\n     ///\n     /// // Print 1, 2 in arbitrary order\n-    /// for x in s.iter() {\n+    /// for x in &s {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```"}, {"sha": "314036ef59d80f5f4027316252d41c80538610d9", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -907,7 +907,7 @@ impl<K: Ord, V> Default for BTreeMap<K, V> {\n impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n     fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n         self.len() == other.len() &&\n-            self.iter().zip(other.iter()).all(|(a, b)| a == b)\n+            self.iter().zip(other).all(|(a, b)| a == b)\n     }\n }\n \n@@ -1544,7 +1544,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// for (_, balance) in map.range_mut(Included(&\"B\"), Excluded(&\"Cheryl\")) {\n     ///     *balance += 100;\n     /// }\n-    /// for (name, balance) in map.iter() {\n+    /// for (name, balance) in &map {\n     ///     println!(\"{} => {}\", name, balance);\n     /// }\n     /// ```"}, {"sha": "8ff49efe9d7d24f5dd2cd2fd99e2fcef8bb51440", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -265,7 +265,7 @@ impl<T> LinkedList<T> {\n     ///\n     /// a.append(&mut b);\n     ///\n-    /// for e in a.iter() {\n+    /// for e in &a {\n     ///     println!(\"{}\", e); // prints 1, then 2, then 3, then 4\n     /// }\n     /// println!(\"{}\", b.len()); // prints 0\n@@ -1189,7 +1189,7 @@ mod tests {\n         check_links(&m);\n \n         let mut i = 0;\n-        for (a, &b) in m.into_iter().zip(v.iter()) {\n+        for (a, &b) in m.into_iter().zip(&v) {\n             i += 1;\n             assert_eq!(a, b);\n         }"}, {"sha": "36cd4ca27f61df8fece06e5f80aac8672ddaf524", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -971,7 +971,7 @@ impl<T> [T] {\n                reason = \"uncertain about this API approach\")]\n     #[inline]\n     pub fn move_from(&mut self, mut src: Vec<T>, start: usize, end: usize) -> usize {\n-        for (a, b) in self.iter_mut().zip(src[start .. end].iter_mut()) {\n+        for (a, b) in self.iter_mut().zip(&mut src[start .. end]) {\n             mem::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)"}, {"sha": "1f8e0aa8ab350970e84fd6c54631578cc93dba0e", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -1890,7 +1890,7 @@ impl str {\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_uppercase(&self) -> String {\n         let mut s = String::with_capacity(self.len());\n-        s.extend(self[..].chars().flat_map(|c| c.to_uppercase()));\n+        s.extend(self.chars().flat_map(|c| c.to_uppercase()));\n         return s;\n     }\n "}, {"sha": "b87d793d1a85ec461733b82f489cc266a5aa297c", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -1331,7 +1331,7 @@ impl<T:Clone> Clone for Vec<T> {\n         }\n \n         // reuse the contained values' allocations/resources.\n-        for (place, thing) in self.iter_mut().zip(other.iter()) {\n+        for (place, thing) in self.iter_mut().zip(other) {\n             place.clone_from(thing)\n         }\n "}, {"sha": "da13684b4f30264e8be083c1c2454f9596abf7a9", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -1443,7 +1443,7 @@ impl<T: Clone> VecDeque<T> {\n     /// buf.push_back(15);\n     /// buf.resize(2, 0);\n     /// buf.resize(6, 20);\n-    /// for (a, b) in [5, 10, 20, 20, 20, 20].iter().zip(buf.iter()) {\n+    /// for (a, b) in [5, 10, 20, 20, 20, 20].iter().zip(&buf) {\n     ///     assert_eq!(a, b);\n     /// }\n     /// ```\n@@ -1681,7 +1681,7 @@ impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n impl<A: PartialEq> PartialEq for VecDeque<A> {\n     fn eq(&self, other: &VecDeque<A>) -> bool {\n         self.len() == other.len() &&\n-            self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n+            self.iter().zip(other).all(|(a, b)| a.eq(b))\n     }\n }\n "}, {"sha": "5c2f5759604b7a3ba277e9e72ae5681504dc18e1", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -54,7 +54,7 @@ use vec::Vec;\n /// assert_eq!(months.get(&3), Some(&\"Venus\"));\n ///\n /// // Print out all months\n-/// for (key, value) in months.iter() {\n+/// for (key, value) in &months {\n ///     println!(\"month {} is {}\", key, value);\n /// }\n ///\n@@ -287,7 +287,7 @@ impl<V> VecMap<V> {\n     ///     *value = \"x\";\n     /// }\n     ///\n-    /// for (key, value) in map.iter() {\n+    /// for (key, value) in &map {\n     ///     assert_eq!(value, &\"x\");\n     /// }\n     /// ```"}, {"sha": "486a651e679fdf4014f120981c828e3b3c2f0da5", "filename": "src/libcollectionstest/bit/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fvec.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -625,7 +625,7 @@ fn test_bit_vec_grow() {\n fn test_bit_vec_extend() {\n     let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n     let ext = BitVec::from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n-    bit_vec.extend(ext.iter());\n+    bit_vec.extend(&ext);\n     assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n                                  0b01001001, 0b10010010, 0b10111101]));\n }"}, {"sha": "56257233aa55820de7dc37b081dc521edac6216f", "filename": "src/libcollectionstest/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fset.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -147,7 +147,7 @@ fn test_zip() {\n \n     let x = x;\n     let y = y;\n-    let mut z = x.iter().zip(y.iter());\n+    let mut z = x.iter().zip(&y);\n \n     // FIXME: #5801: this needs a type hint to compile...\n     let result: Option<(&usize, & &'static str)> = z.next();"}, {"sha": "2df0c7a3a8a2329100a8a143653d36cf98588fc9", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -344,7 +344,7 @@ fn test_from_iterator() {\n     assert_eq!(s, c);\n \n     let mut d = t.to_string();\n-    d.extend(vec![u].into_iter());\n+    d.extend(vec![u]);\n     assert_eq!(s, d);\n }\n "}, {"sha": "3f07c3697ef3ca2b033fba01f9be4b0bdfc8db4a", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -699,7 +699,7 @@ fn do_bench_from_iter(b: &mut Bencher, src_len: usize) {\n     b.bytes = src_len as u64;\n \n     b.iter(|| {\n-        let dst: Vec<_> = FromIterator::from_iter(src.clone().into_iter());\n+        let dst: Vec<_> = FromIterator::from_iter(src.clone());\n         assert_eq!(dst.len(), src_len);\n         assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n     });\n@@ -733,7 +733,7 @@ fn do_bench_extend(b: &mut Bencher, dst_len: usize, src_len: usize) {\n \n     b.iter(|| {\n         let mut dst = dst.clone();\n-        dst.extend(src.clone().into_iter());\n+        dst.extend(src.clone());\n         assert_eq!(dst.len(), dst_len + src_len);\n         assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n     });\n@@ -831,7 +831,7 @@ fn do_bench_push_all_move(b: &mut Bencher, dst_len: usize, src_len: usize) {\n \n     b.iter(|| {\n         let mut dst = dst.clone();\n-        dst.extend(src.clone().into_iter());\n+        dst.extend(src.clone());\n         assert_eq!(dst.len(), dst_len + src_len);\n         assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n     });"}, {"sha": "54153660c2301c9f9dfdd01a39f8e7f948a1d39b", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -177,7 +177,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [0];\n     /// let b = [1];\n-    /// let mut it = a.iter().chain(b.iter());\n+    /// let mut it = a.iter().chain(&b);\n     /// assert_eq!(it.next(), Some(&0));\n     /// assert_eq!(it.next(), Some(&1));\n     /// assert!(it.next().is_none());\n@@ -200,7 +200,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [0];\n     /// let b = [1];\n-    /// let mut it = a.iter().zip(b.iter());\n+    /// let mut it = a.iter().zip(&b);\n     /// assert_eq!(it.next(), Some((&0, &1)));\n     /// assert!(it.next().is_none());\n     /// ```\n@@ -585,9 +585,9 @@ pub trait Iterator {\n \n         for x in self {\n             if f(&x) {\n-                left.extend(Some(x).into_iter())\n+                left.extend(Some(x))\n             } else {\n-                right.extend(Some(x).into_iter())\n+                right.extend(Some(x))\n             }\n         }\n \n@@ -994,8 +994,8 @@ pub trait Iterator {\n         us.extend(SizeHint(lo, hi, marker::PhantomData));\n \n         for (t, u) in self {\n-            ts.extend(Some(t).into_iter());\n-            us.extend(Some(u).into_iter());\n+            ts.extend(Some(t));\n+            us.extend(Some(u));\n         }\n \n         (ts, us)"}, {"sha": "4f373c16f7c0888974a8d79ee646d6115f2e58a7", "filename": "src/libcore/num/flt2dec/bignum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -146,7 +146,7 @@ macro_rules! define_bignum {\n \n                 let mut sz = cmp::max(self.size, other.size);\n                 let mut carry = false;\n-                for (a, b) in self.base[..sz].iter_mut().zip(other.base[..sz].iter()) {\n+                for (a, b) in self.base[..sz].iter_mut().zip(&other.base[..sz]) {\n                     let (c, v) = (*a).full_add(*b, carry);\n                     *a = v;\n                     carry = c;\n@@ -166,7 +166,7 @@ macro_rules! define_bignum {\n \n                 let sz = cmp::max(self.size, other.size);\n                 let mut noborrow = true;\n-                for (a, b) in self.base[..sz].iter_mut().zip(other.base[..sz].iter()) {\n+                for (a, b) in self.base[..sz].iter_mut().zip(&other.base[..sz]) {\n                     let (c, v) = (*a).full_add(!*b, noborrow);\n                     *a = v;\n                     noborrow = c;\n@@ -183,7 +183,7 @@ macro_rules! define_bignum {\n \n                 let mut sz = self.size;\n                 let mut carry = 0;\n-                for a in self.base[..sz].iter_mut() {\n+                for a in &mut self.base[..sz] {\n                     let (c, v) = (*a).full_mul(other, carry);\n                     *a = v;\n                     carry = c;"}, {"sha": "f4b47f3fbb871186260d1520f94083c0c77015ca", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -124,7 +124,7 @@\n //! // but to start with we've just got `None`.\n //! let mut name_of_biggest_animal = None;\n //! let mut size_of_biggest_animal = 0;\n-//! for big_thing in all_the_big_things.iter() {\n+//! for big_thing in &all_the_big_things {\n //!     match *big_thing {\n //!         Kingdom::Animal(size, name) if size > size_of_biggest_animal => {\n //!             // Now we've found the name of some big animal"}, {"sha": "dca899a8e9f7a14ddf323f3f96637b1d1ad113a2", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -82,7 +82,7 @@ fn test_iterator_chain() {\n     let xs = [0, 1, 2, 3, 4, 5];\n     let ys = [30, 40, 50, 60];\n     let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n-    let it = xs.iter().chain(ys.iter());\n+    let it = xs.iter().chain(&ys);\n     let mut i = 0;\n     for &x in it {\n         assert_eq!(x, expected[i]);\n@@ -107,11 +107,11 @@ fn test_iterator_chain_nth() {\n     let zs = [];\n     let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n     for (i, x) in expected.iter().enumerate() {\n-        assert_eq!(Some(x), xs.iter().chain(ys.iter()).nth(i));\n+        assert_eq!(Some(x), xs.iter().chain(&ys).nth(i));\n     }\n-    assert_eq!(zs.iter().chain(xs.iter()).nth(0), Some(&0));\n+    assert_eq!(zs.iter().chain(&xs).nth(0), Some(&0));\n \n-    let mut it = xs.iter().chain(zs.iter());\n+    let mut it = xs.iter().chain(&zs);\n     assert_eq!(it.nth(5), Some(&5));\n     assert_eq!(it.next(), None);\n }\n@@ -121,19 +121,19 @@ fn test_iterator_chain_last() {\n     let xs = [0, 1, 2, 3, 4, 5];\n     let ys = [30, 40, 50, 60];\n     let zs = [];\n-    assert_eq!(xs.iter().chain(ys.iter()).last(), Some(&60));\n-    assert_eq!(zs.iter().chain(ys.iter()).last(), Some(&60));\n-    assert_eq!(ys.iter().chain(zs.iter()).last(), Some(&60));\n-    assert_eq!(zs.iter().chain(zs.iter()).last(), None);\n+    assert_eq!(xs.iter().chain(&ys).last(), Some(&60));\n+    assert_eq!(zs.iter().chain(&ys).last(), Some(&60));\n+    assert_eq!(ys.iter().chain(&zs).last(), Some(&60));\n+    assert_eq!(zs.iter().chain(&zs).last(), None);\n }\n \n #[test]\n fn test_iterator_chain_count() {\n     let xs = [0, 1, 2, 3, 4, 5];\n     let ys = [30, 40, 50, 60];\n     let zs = [];\n-    assert_eq!(xs.iter().chain(ys.iter()).count(), 10);\n-    assert_eq!(zs.iter().chain(ys.iter()).count(), 4);\n+    assert_eq!(xs.iter().chain(&ys).count(), 10);\n+    assert_eq!(zs.iter().chain(&ys).count(), 4);\n }\n \n #[test]\n@@ -571,8 +571,8 @@ fn test_iterator_size_hint() {\n     assert_eq!(vi.clone().take_while(|_| false).size_hint(), (0, Some(10)));\n     assert_eq!(vi.clone().skip_while(|_| false).size_hint(), (0, Some(10)));\n     assert_eq!(vi.clone().enumerate().size_hint(), (10, Some(10)));\n-    assert_eq!(vi.clone().chain(v2.iter()).size_hint(), (13, Some(13)));\n-    assert_eq!(vi.clone().zip(v2.iter()).size_hint(), (3, Some(3)));\n+    assert_eq!(vi.clone().chain(v2).size_hint(), (13, Some(13)));\n+    assert_eq!(vi.clone().zip(v2).size_hint(), (3, Some(3)));\n     assert_eq!(vi.clone().scan(0, |_,_| Some(0)).size_hint(), (0, Some(10)));\n     assert_eq!(vi.clone().filter(|_| false).size_hint(), (0, Some(10)));\n     assert_eq!(vi.clone().map(|&i| i+1).size_hint(), (10, Some(10)));\n@@ -742,7 +742,7 @@ fn test_double_ended_filter_map() {\n fn test_double_ended_chain() {\n     let xs = [1, 2, 3, 4, 5];\n     let ys = [7, 9, 11];\n-    let mut it = xs.iter().chain(ys.iter()).rev();\n+    let mut it = xs.iter().chain(&ys).rev();\n     assert_eq!(it.next().unwrap(), &11);\n     assert_eq!(it.next().unwrap(), &9);\n     assert_eq!(it.next_back().unwrap(), &1);\n@@ -807,7 +807,7 @@ fn check_randacc_iter<A, T>(a: T, len: usize) where\n fn test_double_ended_flat_map() {\n     let u = [0,1];\n     let v = [5,6,7,8];\n-    let mut it = u.iter().flat_map(|x| v[*x..v.len()].iter());\n+    let mut it = u.iter().flat_map(|x| &v[*x..v.len()]);\n     assert_eq!(it.next_back().unwrap(), &8);\n     assert_eq!(it.next().unwrap(),      &5);\n     assert_eq!(it.next_back().unwrap(), &7);\n@@ -824,7 +824,7 @@ fn test_double_ended_flat_map() {\n fn test_random_access_chain() {\n     let xs = [1, 2, 3, 4, 5];\n     let ys = [7, 9, 11];\n-    let mut it = xs.iter().chain(ys.iter());\n+    let mut it = xs.iter().chain(&ys);\n     assert_eq!(it.idx(0).unwrap(), &1);\n     assert_eq!(it.idx(5).unwrap(), &7);\n     assert_eq!(it.idx(7).unwrap(), &11);\n@@ -862,7 +862,7 @@ fn test_random_access_rev() {\n fn test_random_access_zip() {\n     let xs = [1, 2, 3, 4, 5];\n     let ys = [7, 9, 11];\n-    check_randacc_iter(xs.iter().zip(ys.iter()), cmp::min(xs.len(), ys.len()));\n+    check_randacc_iter(xs.iter().zip(&ys), cmp::min(xs.len(), ys.len()));\n }\n \n #[test]"}, {"sha": "4b445c84e8f5836376b8ff15ccaf9ad0e806f2b8", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -72,7 +72,7 @@ fn test_option_dance() {\n     let x = Some(());\n     let mut y = Some(5);\n     let mut y2 = 0;\n-    for _x in x.iter() {\n+    for _x in x {\n         y2 = y.take().unwrap();\n     }\n     assert_eq!(y2, 5);"}, {"sha": "0d15f584d648aed652a39452175e7a10cc0cd95e", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -953,7 +953,7 @@ fn test_split_within() {\n     fn t(s: &str, i: usize, u: &[String]) {\n         let mut v = Vec::new();\n         each_split_within(s, i, |s| { v.push(s.to_string()); true });\n-        assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n+        assert!(v.iter().zip(u).all(|(a,b)| a == b));\n     }\n     t(\"\", 0, &[]);\n     t(\"\", 15, &[]);"}, {"sha": "afd796f7771fcf33fe1da24feca59aaf8175a3c7", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -74,7 +74,7 @@\n //!         // (assumes that |N| \\approxeq |E|)\n //!         let &Edges(ref v) = self;\n //!         let mut nodes = Vec::with_capacity(v.len());\n-//!         for &(s,t) in v.iter() {\n+//!         for &(s,t) in v {\n //!             nodes.push(s); nodes.push(t);\n //!         }\n //!         nodes.sort();"}, {"sha": "da360978369f20f6fc40e7cbcc08b667456e201f", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -174,7 +174,7 @@ impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n         self.init(&[0; KEY_WORDS]);\n         // set key in place\n         let key = &mut self.state[4 .. 4+KEY_WORDS];\n-        for (k, s) in key.iter_mut().zip(seed.iter()) {\n+        for (k, s) in key.iter_mut().zip(seed) {\n             *k = *s;\n         }\n     }"}, {"sha": "ec9aa2d16d24ad0b5ea80b1871bf3ffb0e8bf68c", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -140,7 +140,7 @@ impl IsaacRng {\n         }\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n-        for &(mr_offset, m2_offset) in r.iter() {\n+        for &(mr_offset, m2_offset) in &r {\n \n             macro_rules! rngstepp {\n                 ($j:expr, $shift:expr) => {{\n@@ -379,7 +379,7 @@ impl Isaac64Rng {\n             }\n         }\n \n-        for &(mr_offset, m2_offset) in MP_VEC.iter() {\n+        for &(mr_offset, m2_offset) in &MP_VEC {\n             for base in (0..MIDPOINT / 4).map(|i| i * 4) {\n \n                 macro_rules! rngstepp {"}, {"sha": "810862cdfd663a7820c2c591d7b60eb636acc30b", "filename": "src/librustc/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fast_map%2Fmod.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -404,7 +404,7 @@ impl<'ast> Map<'ast> {\n \n     fn path_to_str_with_ident(&self, id: NodeId, i: Ident) -> String {\n         self.with_path(id, |path| {\n-            path_to_string(path.chain(Some(PathName(i.name)).into_iter()))\n+            path_to_string(path.chain(Some(PathName(i.name))))\n         })\n     }\n "}, {"sha": "dce19d6ff781514d5301325a0efb0f18bbb46252", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -698,7 +698,7 @@ pub fn import_codemap(local_codemap: &codemap::CodeMap,\n             return false;\n         }\n \n-        for (&line1, &line2) in lines1.iter().zip(lines2.iter()) {\n+        for (&line1, &line2) in lines1.iter().zip(&*lines2) {\n             if (line1 - fm1.start_pos) != (line2 - fm2.start_pos) {\n                 return false;\n             }\n@@ -711,7 +711,7 @@ pub fn import_codemap(local_codemap: &codemap::CodeMap,\n             return false;\n         }\n \n-        for (mb1, mb2) in multibytes1.iter().zip(multibytes2.iter()) {\n+        for (mb1, mb2) in multibytes1.iter().zip(&*multibytes2) {\n             if (mb1.bytes != mb2.bytes) ||\n                ((mb1.pos - fm1.start_pos) != (mb2.pos - fm2.start_pos)) {\n                 return false;"}, {"sha": "d6f4c4ca0d06ba76d247c9684cbe554ce94cb17e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -723,14 +723,14 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         abbrevs: &ecx.type_abbrevs\n     };\n \n-    for param in generics.types.iter() {\n+    for param in &generics.types {\n         rbml_w.start_tag(tag_type_param_def);\n         tyencode::enc_type_param_def(rbml_w, ty_str_ctxt, param);\n         rbml_w.end_tag();\n     }\n \n     // Region parameters\n-    for param in generics.regions.iter() {\n+    for param in &generics.regions {\n         rbml_w.start_tag(tag_region_param_def);\n \n         rbml_w.start_tag(tag_region_param_def_ident);\n@@ -838,7 +838,7 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n     encode_stability(rbml_w, stab);\n \n     let elem = ast_map::PathName(associated_const.name);\n-    encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n+    encode_path(rbml_w, impl_path.chain(Some(elem)));\n \n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n@@ -871,7 +871,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_bounds_and_type_for_item(rbml_w, ecx, m.def_id.local_id());\n \n     let elem = ast_map::PathName(m.name);\n-    encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n+    encode_path(rbml_w, impl_path.chain(Some(elem)));\n     if let Some(impl_item) = impl_item_opt {\n         if let ast::MethodImplItem(ref sig, _) = impl_item.node {\n             encode_attributes(rbml_w, &impl_item.attrs);\n@@ -917,7 +917,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_stability(rbml_w, stab);\n \n     let elem = ast_map::PathName(associated_type.name);\n-    encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n+    encode_path(rbml_w, impl_path.chain(Some(elem)));\n \n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n@@ -955,7 +955,7 @@ fn encode_repr_attrs(rbml_w: &mut Encoder,\n     let mut repr_attrs = Vec::new();\n     for attr in attrs {\n         repr_attrs.extend(attr::find_repr_attrs(ecx.tcx.sess.diagnostic(),\n-                                                attr).into_iter());\n+                                                attr));\n     }\n     rbml_w.start_tag(tag_items_data_item_repr);\n     repr_attrs.encode(rbml_w);\n@@ -1409,7 +1409,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                     let elem = ast_map::PathName(associated_const.name);\n                     encode_path(rbml_w,\n-                                path.clone().chain(Some(elem).into_iter()));\n+                                path.clone().chain(Some(elem)));\n \n                     encode_item_sort(rbml_w, 'C');\n                     encode_family(rbml_w, 'C');\n@@ -1426,7 +1426,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                     let elem = ast_map::PathName(method_ty.name);\n                     encode_path(rbml_w,\n-                                path.clone().chain(Some(elem).into_iter()));\n+                                path.clone().chain(Some(elem)));\n \n                     match method_ty.explicit_self {\n                         ty::StaticExplicitSelfCategory => {\n@@ -1449,7 +1449,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                     let elem = ast_map::PathName(associated_type.name);\n                     encode_path(rbml_w,\n-                                path.clone().chain(Some(elem).into_iter()));\n+                                path.clone().chain(Some(elem)));\n \n                     encode_item_sort(rbml_w, 't');\n                     encode_family(rbml_w, 'y');\n@@ -1822,8 +1822,8 @@ fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n fn encode_native_libraries(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_native_libraries);\n \n-    for &(ref lib, kind) in ecx.tcx.sess.cstore.get_used_libraries()\n-                               .borrow().iter() {\n+    for &(ref lib, kind) in &*ecx.tcx.sess.cstore.get_used_libraries()\n+                               .borrow() {\n         match kind {\n             cstore::NativeStatic => {} // these libraries are not propagated\n             cstore::NativeFramework | cstore::NativeUnknown => {"}, {"sha": "2af3c393868d8ef355af0a523ae6f178495e8147", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -438,7 +438,7 @@ impl<'a> Context<'a> {\n                 FileMatches\n             }).unwrap_or(FileDoesntMatch)\n         });\n-        self.rejected_via_kind.extend(staticlibs.into_iter());\n+        self.rejected_via_kind.extend(staticlibs);\n \n         // We have now collected all known libraries into a set of candidates\n         // keyed of the filename hash listed. For each filename, we also have a"}, {"sha": "8606cbc53d54468349acaa6f5094cbe2760fb2cb", "filename": "src/librustc/metadata/macro_import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -164,14 +164,14 @@ impl<'a> MacroLoader<'a> {\n         }\n \n         if let Some(sel) = import.as_ref() {\n-            for (name, span) in sel.iter() {\n+            for (name, span) in sel {\n                 if !seen.contains(name) {\n                     self.sess.span_err(*span, \"imported macro not found\");\n                 }\n             }\n         }\n \n-        for (name, span) in reexport.iter() {\n+        for (name, span) in &reexport {\n             if !seen.contains(name) {\n                 self.sess.span_err(*span, \"reexported macro not found\");\n             }"}, {"sha": "ad228404a9cdd405ef943093b77eaefb62137473", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -1126,7 +1126,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &qualif in tcx.const_qualif_map.borrow().get(&id).iter() {\n+    if let Some(qualif) = tcx.const_qualif_map.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_const_qualif, |rbml_w| {\n             rbml_w.id(id);\n             qualif.encode(rbml_w).unwrap()"}, {"sha": "e782a03176d67d5b1649e6f7480a0a5b057e2f74", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -338,7 +338,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             ast::ExprRange(ref start, ref end) => {\n                 let fields = start.as_ref().map(|e| &**e).into_iter()\n-                    .chain(end.as_ref().map(|e| &**e).into_iter());\n+                    .chain(end.as_ref().map(|e| &**e));\n                 self.straightline(expr, pred, fields)\n             }\n "}, {"sha": "55b25b273f2ea7eb83b67aa7b90f97f5b7f91034", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -409,7 +409,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         // Special-case some expressions to avoid certain flags bubbling up.\n         match ex.node {\n             ast::ExprCall(ref callee, ref args) => {\n-                for arg in args.iter() {\n+                for arg in args {\n                     self.visit_expr(&**arg)\n                 }\n \n@@ -435,7 +435,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 // Compute the most demanding borrow from all the arms'\n                 // patterns and set that on the discriminator.\n                 let mut borrow = None;\n-                for pat in arms.iter().flat_map(|arm| arm.pats.iter()) {\n+                for pat in arms.iter().flat_map(|arm| &arm.pats) {\n                     let pat_borrow = self.rvalue_borrows.remove(&pat.id);\n                     match (borrow, pat_borrow) {\n                         (None, _) | (_, Some(ast::MutMutable)) => {"}, {"sha": "88be86ac37b47fa5d6d8acc1254c8f61146d00b5", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -187,7 +187,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n \n             for pat in inlined_arms\n                 .iter()\n-                .flat_map(|&(ref pats, _)| pats.iter()) {\n+                .flat_map(|&(ref pats, _)| pats) {\n                 // Third, check legality of move bindings.\n                 check_legality_of_bindings_in_at_patterns(cx, &**pat);\n \n@@ -220,7 +220,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n             let matrix: Matrix = inlined_arms\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n-                .flat_map(|arm| arm.0.iter())\n+                .flat_map(|arm| &arm.0)\n                 .map(|pat| vec![&**pat])\n                 .collect();\n             check_exhaustive(cx, ex.span, &matrix, source);\n@@ -583,7 +583,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n                        left_ty: Ty, max_slice_length: usize) -> Option<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n-        .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length).into_iter())\n+        .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length))\n         .collect();\n     all_constructors(cx, left_ty, max_slice_length)\n         .into_iter()\n@@ -705,7 +705,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                         let wild_pats: Vec<_> = repeat(DUMMY_WILD_PAT).take(arity).collect();\n                         let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n                         let mut new_pats = vec![enum_pat];\n-                        new_pats.extend(pats.into_iter());\n+                        new_pats.extend(pats);\n                         UsefulWithWitness(new_pats)\n                     },\n                     result => result"}, {"sha": "b69a086257341dc0994a4abcdef5aed5b91b6cc8", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -634,7 +634,7 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n                                op: &Op) -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n-    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec.iter()) {\n+    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n         let old_val = *out_elt;\n         let new_val = op.join(old_val, *in_elt);\n         *out_elt = new_val;"}, {"sha": "406734ba68711497fafa9ec11dc9544a0a5946b4", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -212,11 +212,11 @@ enum OverloadedCallType {\n impl OverloadedCallType {\n     fn from_trait_id(tcx: &ty::ctxt, trait_id: ast::DefId)\n                      -> OverloadedCallType {\n-        for &(maybe_function_trait, overloaded_call_type) in [\n+        for &(maybe_function_trait, overloaded_call_type) in &[\n             (tcx.lang_items.fn_once_trait(), FnOnceOverloadedCall),\n             (tcx.lang_items.fn_mut_trait(), FnMutOverloadedCall),\n             (tcx.lang_items.fn_trait(), FnOverloadedCall)\n-        ].iter() {\n+        ] {\n             match maybe_function_trait {\n                 Some(function_trait) if function_trait == trait_id => {\n                     return overloaded_call_type"}, {"sha": "572478ba3f9398f8f4eab0566b59e528b8d7faa4", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n \n         let variances = ty::item_variances(self.tcx(), def_id);\n \n-        for (&region, &variance) in substs.regions().iter().zip(variances.regions.iter()) {\n+        for (&region, &variance) in substs.regions().iter().zip(&variances.regions) {\n             match variance {\n                 ty::Contravariant | ty::Invariant => {\n                     // If any data with this lifetime is reachable\n@@ -287,7 +287,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n             }\n         }\n \n-        for (&ty, &variance) in substs.types.iter().zip(variances.types.iter()) {\n+        for (&ty, &variance) in substs.types.iter().zip(&variances.types) {\n             match variance {\n                 ty::Covariant | ty::Invariant => {\n                     // If any data of this type is reachable within,"}, {"sha": "3d946aa2fbc8bbb9ff36dfb7adf007544f86c129", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -443,7 +443,7 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n         let escaping_region_vars: FnvHashSet<_> =\n             escaping_types\n             .iter()\n-            .flat_map(|&t| ty_fold::collect_regions(self.tcx, &t).into_iter())\n+            .flat_map(|&t| ty_fold::collect_regions(self.tcx, &t))\n             .collect();\n \n         region_vars.retain(|&region_vid| {"}, {"sha": "2ee5507f40254d0f9ca2df950aa4411693d8486f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -372,22 +372,22 @@ struct RegionResolutionVisitor<'a> {\n \n impl RegionMaps {\n     pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(&CodeExtent, &CodeExtent) {\n-        for (child, parent) in self.scope_map.borrow().iter() {\n+        for (child, parent) in &*self.scope_map.borrow() {\n             e(child, parent)\n         }\n     }\n     pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, &CodeExtent) {\n-        for (child, parent) in self.var_map.borrow().iter() {\n+        for (child, parent) in &*self.var_map.borrow() {\n             e(child, parent)\n         }\n     }\n     pub fn each_rvalue_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, &CodeExtent) {\n-        for (child, parent) in self.rvalue_scopes.borrow().iter() {\n+        for (child, parent) in &*self.rvalue_scopes.borrow() {\n             e(child, parent)\n         }\n     }\n     pub fn each_terminating_scope<E>(&self, mut e:E) where E: FnMut(&CodeExtent) {\n-        for scope in self.terminating_scopes.borrow().iter() {\n+        for scope in &*self.terminating_scopes.borrow() {\n             e(scope)\n         }\n     }"}, {"sha": "2159e143e6159ea886f4f8829baf53fb7966ae2b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -485,7 +485,7 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n     match pat.node {\n         // Foo(a, b, c)\n         ast::PatEnum(_, Some(ref pat_fields)) => {\n-            for (field, struct_field) in pat_fields.iter().zip(struct_fields.iter()) {\n+            for (field, struct_field) in pat_fields.iter().zip(&struct_fields) {\n                 // a .. pattern is fine, but anything positional is\n                 // not.\n                 if let ast::PatWild(ast::PatWildMulti) = field.node {\n@@ -595,14 +595,14 @@ pub fn check_unused_or_stable_features(sess: &Session,\n \n     let stable_msg = \"this feature is stable. attribute no longer needed\";\n \n-    for &span in sess.features.borrow().declared_stable_lang_features.iter() {\n+    for &span in &sess.features.borrow().declared_stable_lang_features {\n         sess.add_lint(lint::builtin::STABLE_FEATURES,\n                       ast::CRATE_NODE_ID,\n                       span,\n                       stable_msg.to_string());\n     }\n \n-    for (used_lib_feature, level) in lib_features_used.iter() {\n+    for (used_lib_feature, level) in lib_features_used {\n         match remaining_lib_features.remove(used_lib_feature) {\n             Some(span) => {\n                 if *level == attr::Stable {\n@@ -616,7 +616,7 @@ pub fn check_unused_or_stable_features(sess: &Session,\n         }\n     }\n \n-    for (_, &span) in remaining_lib_features.iter() {\n+    for &span in remaining_lib_features.values() {\n         sess.add_lint(lint::builtin::UNUSED_FEATURES,\n                       ast::CRATE_NODE_ID,\n                       span,"}, {"sha": "012e3eae889b1f3dc646cbf8cd3437ae96cefafe", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -279,8 +279,8 @@ impl<T> VecPerParamSpace<T> {\n         let self_limit = type_limit + s.len();\n \n         let mut content = t;\n-        content.extend(s.into_iter());\n-        content.extend(f.into_iter());\n+        content.extend(s);\n+        content.extend(f);\n \n         VecPerParamSpace {\n             type_limit: type_limit,"}, {"sha": "26574e2b80d08a8c88337f1f8f218ef5f459c6bb", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -85,7 +85,7 @@ fn overlap(selcx: &mut SelectionContext,\n     let infcx = selcx.infcx();\n     let opt_failing_obligation =\n         a_obligations.iter()\n-                     .chain(b_obligations.iter())\n+                     .chain(&b_obligations)\n                      .map(|o| infcx.resolve_type_vars_if_possible(o))\n                      .find(|o| !selcx.evaluate_obligation(o));\n \n@@ -159,8 +159,8 @@ fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n \n     let impl_obligations: Vec<_> =\n         impl_obligations.into_iter()\n-        .chain(normalization_obligations1.into_iter())\n-        .chain(normalization_obligations2.into_iter())\n+        .chain(normalization_obligations1)\n+        .chain(normalization_obligations2)\n         .collect();\n \n     (impl_trait_ref, impl_obligations)\n@@ -209,7 +209,7 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n     let input_tys = Some(trait_ref.self_ty());\n-    let input_tys = input_tys.iter().chain(trait_ref.substs.types.get_slice(TypeSpace).iter());\n+    let input_tys = input_tys.iter().chain(trait_ref.substs.types.get_slice(TypeSpace));\n \n     // Find the first input type that either references a type parameter OR\n     // some local type.\n@@ -255,7 +255,7 @@ fn uncovered_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n         vec![]\n     } else if fundamental_ty(tcx, ty) {\n         ty.walk_shallow()\n-          .flat_map(|t| uncovered_tys(tcx, t, infer_is_local).into_iter())\n+          .flat_map(|t| uncovered_tys(tcx, t, infer_is_local))\n           .collect()\n     } else {\n         vec![ty]"}, {"sha": "80acb9bcc139933cecdf07d41e9849ad46740d66", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -399,7 +399,7 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                    result.repr(tcx));\n             match result {\n                 Ok(Some(obligations)) => {\n-                    new_obligations.extend(obligations.into_iter());\n+                    new_obligations.extend(obligations);\n                     true\n                 }\n                 Ok(None) => {"}, {"sha": "6662cf743831bdc7714b31262ebd6e13470d89fb", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -80,7 +80,7 @@ pub fn object_safety_violations<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                       -> Vec<ObjectSafetyViolation<'tcx>>\n {\n     traits::supertrait_def_ids(tcx, trait_def_id)\n-        .flat_map(|def_id| object_safety_violations_for_trait(tcx, def_id).into_iter())\n+        .flat_map(|def_id| object_safety_violations_for_trait(tcx, def_id))\n         .collect()\n }\n "}, {"sha": "48ebfe35479696d9589396c64eac8497fc2208ac", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -280,7 +280,7 @@ impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n                                               data.clone(),\n                                               self.cause.clone(),\n                                               self.depth);\n-                self.obligations.extend(obligations.into_iter());\n+                self.obligations.extend(obligations);\n                 ty\n             }\n \n@@ -376,7 +376,7 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n                        normalized_ty.repr(tcx),\n                        depth);\n \n-                obligations.extend(normalizer.obligations.into_iter());\n+                obligations.extend(normalizer.obligations);\n                 Some(Normalized {\n                     value: normalized_ty,\n                     obligations: obligations,\n@@ -872,7 +872,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n \n     // It is not in the impl - get the default from the trait.\n     let trait_ref = obligation.predicate.trait_ref;\n-    for trait_item in ty::trait_items(selcx.tcx(), trait_ref.def_id).iter() {\n+    for trait_item in &*ty::trait_items(selcx.tcx(), trait_ref.def_id) {\n         if let &ty::TypeTraitItem(ref assoc_ty) = trait_item {\n             if assoc_ty.name == obligation.predicate.item_name {\n                 if let Some(ty) = assoc_ty.ty {"}, {"sha": "7244622a8331dea863280082c05bae3dc4cdce22", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -1750,7 +1750,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let types: Vec<Ty> =\n                     ty::substd_enum_variants(self.tcx(), def_id, substs)\n                     .iter()\n-                    .flat_map(|variant| variant.args.iter())\n+                    .flat_map(|variant| &variant.args)\n                     .cloned()\n                     .collect();\n                 nominal(bound, types)\n@@ -1893,7 +1893,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::ty_enum(def_id, substs) => {\n                 Some(ty::substd_enum_variants(self.tcx(), def_id, substs)\n                      .iter()\n-                     .flat_map(|variant| variant.args.iter())\n+                     .flat_map(|variant| &variant.args)\n                      .map(|&ty| ty)\n                      .collect())\n             }\n@@ -1960,7 +1960,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // Flatten those vectors (couldn't do it above due `collect`)\n         match obligations {\n-            Ok(obligations) => obligations.into_iter().flat_map(|o| o.into_iter()).collect(),\n+            Ok(obligations) => obligations.into_iter().flat_map(|o| o).collect(),\n             Err(ErrorReported) => Vec::new(),\n         }\n     }\n@@ -2689,7 +2689,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // simplified, do not match.\n \n         obligation.predicate.0.input_types().iter()\n-            .zip(impl_trait_ref.input_types().iter())\n+            .zip(impl_trait_ref.input_types())\n             .any(|(&obligation_ty, &impl_ty)| {\n                 let simplified_obligation_ty =\n                     fast_reject::simplify_type(self.tcx(), obligation_ty, true);"}, {"sha": "132a0687b1a613db12ccc15d45e7a2105eb48861", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -135,7 +135,7 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n                 // Sized { }`.\n                 predicates.retain(|r| self.visited.insert(r));\n \n-                self.stack.extend(predicates.into_iter());\n+                self.stack.extend(predicates);\n             }\n             ty::Predicate::Equate(..) => {\n                 // Currently, we do not \"elaborate\" predicates like"}, {"sha": "cd337f67303a153812eff39fc9b8c91e9e265f7e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -2154,7 +2154,7 @@ impl<'tcx> Predicate<'tcx> {\n                 let trait_inputs = data.0.projection_ty.trait_ref.substs.types.as_slice();\n                 trait_inputs.iter()\n                             .cloned()\n-                            .chain(Some(data.0.ty).into_iter())\n+                            .chain(Some(data.0.ty))\n                             .collect()\n             }\n         };\n@@ -2571,7 +2571,7 @@ impl<'tcx> TraitDef<'tcx> {\n     pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &ctxt<'tcx>, mut f: F)  {\n         ty::populate_implementations_for_trait_if_necessary(tcx, self.trait_ref.def_id);\n \n-        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+        for &impl_def_id in &*self.blanket_impls.borrow() {\n             f(impl_def_id);\n         }\n \n@@ -2589,7 +2589,7 @@ impl<'tcx> TraitDef<'tcx> {\n     {\n         ty::populate_implementations_for_trait_if_necessary(tcx, self.trait_ref.def_id);\n \n-        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+        for &impl_def_id in &*self.blanket_impls.borrow() {\n             f(impl_def_id);\n         }\n \n@@ -3068,7 +3068,7 @@ impl FlagComputation {\n         match substs.regions {\n             subst::ErasedRegions => {}\n             subst::NonerasedRegions(ref regions) => {\n-                for &r in regions.iter() {\n+                for &r in regions {\n                     self.add_region(r);\n                 }\n             }\n@@ -4199,7 +4199,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n             ty_enum(did, substs) => {\n                 let vs = enum_variants(cx, did);\n                 let iter = vs.iter()\n-                    .flat_map(|variant| { variant.args.iter() })\n+                    .flat_map(|variant| &variant.args)\n                     .map(|aty| { aty.subst_spanned(cx, substs, Some(sp)) });\n \n                 find_nonrepresentable(cx, sp, seen, iter)\n@@ -4233,7 +4233,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                 let types_a = substs_a.types.get_slice(subst::TypeSpace);\n                 let types_b = substs_b.types.get_slice(subst::TypeSpace);\n \n-                let mut pairs = types_a.iter().zip(types_b.iter());\n+                let mut pairs = types_a.iter().zip(types_b);\n \n                 pairs.all(|(&a, &b)| same_type(a, b))\n             }\n@@ -4509,7 +4509,7 @@ pub fn named_element_ty<'tcx>(cx: &ctxt<'tcx>,\n             let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);\n             variant_info.arg_names.as_ref()\n                 .expect(\"must have struct enum variant if accessing a named fields\")\n-                .iter().zip(variant_info.args.iter())\n+                .iter().zip(&variant_info.args)\n                 .find(|&(&name, _)| name == n)\n                 .map(|(_name, arg_t)| arg_t.subst(cx, substs))\n         }\n@@ -5401,7 +5401,7 @@ pub fn associated_type_parameter_index(cx: &ctxt,\n                                        trait_def: &TraitDef,\n                                        associated_type_id: ast::DefId)\n                                        -> usize {\n-    for type_parameter_def in trait_def.generics.types.iter() {\n+    for type_parameter_def in &trait_def.generics.types {\n         if type_parameter_def.def_id == associated_type_id {\n             return type_parameter_def.index as usize\n         }\n@@ -6607,8 +6607,8 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                     hash!(data.bounds);\n \n                     let principal = anonymize_late_bound_regions(tcx, &data.principal).0;\n-                    for subty in principal.substs.types.iter() {\n-                        helper(tcx, *subty, svh, state);\n+                    for subty in &principal.substs.types {\n+                        helper(tcx, subty, svh, state);\n                     }\n \n                     return false;\n@@ -6933,7 +6933,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n         match substs.regions {\n             subst::ErasedRegions => {}\n             subst::NonerasedRegions(ref regions) => {\n-                for region in regions.iter() {\n+                for region in regions {\n                     accumulator.push(*region)\n                 }\n             }"}, {"sha": "92f9e0b6673eb3683a348fd4b1f1f4014ed30a1b", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -274,8 +274,7 @@ fn relate_arg_vecs<'a,'tcx:'a,R>(relation: &mut R,\n         return Err(ty::terr_arg_count);\n     }\n \n-    a_args.iter()\n-          .zip(b_args.iter())\n+    a_args.iter().zip(b_args)\n           .map(|(a, b)| relation.relate_with_variance(ty::Contravariant, a, b))\n           .collect()\n }\n@@ -355,8 +354,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n         if a.len() != b.len() {\n             Err(ty::terr_projection_bounds_length(expected_found(relation, &a.len(), &b.len())))\n         } else {\n-            a.iter()\n-                .zip(b.iter())\n+            a.iter().zip(b)\n                 .map(|(a, b)| relation.relate(a, b))\n                 .collect()\n         }\n@@ -539,8 +537,7 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n         (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) =>\n         {\n             if as_.len() == bs.len() {\n-                let ts = try!(as_.iter()\n-                                 .zip(bs.iter())\n+                let ts = try!(as_.iter().zip(bs)\n                                  .map(|(a, b)| relation.relate(a, b))\n                                  .collect::<Result<_, _>>());\n                 Ok(ty::mk_tup(tcx, ts))"}, {"sha": "0b55f05072f6e78bd6122decd4dc64765ba0d9c5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -470,15 +470,15 @@ pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n                 strings.push(format!(\"..\"));\n             }\n             subst::NonerasedRegions(ref regions) => {\n-                for region in regions.iter() {\n+                for region in regions {\n                     strings.push(region.repr(cx));\n                 }\n             }\n         }\n-        for ty in substs.types.iter() {\n+        for ty in &substs.types {\n             strings.push(ty.repr(cx));\n         }\n-        for projection in projections.iter() {\n+        for projection in projections {\n             strings.push(format!(\"{}={}\",\n                                  projection.projection_ty.item_name.user_string(cx),\n                                  projection.ty.user_string(cx)));\n@@ -495,7 +495,7 @@ pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n     match substs.regions {\n         subst::ErasedRegions => { }\n         subst::NonerasedRegions(ref regions) => {\n-            for &r in regions.iter() {\n+            for &r in regions {\n                 let s = region_to_string(cx, \"\", false, r);\n                 if s.is_empty() {\n                     // This happens when the value of the region\n@@ -523,7 +523,7 @@ pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n     let ty_params = generics.types.get_slice(subst::TypeSpace);\n     let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n     let num_defaults = if has_defaults {\n-        ty_params.iter().zip(tps.iter()).rev().take_while(|&(def, &actual)| {\n+        ty_params.iter().zip(tps).rev().take_while(|&(def, &actual)| {\n             match def.default {\n                 Some(default) => {\n                     if !has_self && ty::type_has_self(default) {"}, {"sha": "de52d2e7b7847f8210283498d86867231c416779", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -99,7 +99,7 @@ fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n         for ge in &mut *grouped_errors {\n             if move_from_id == ge.move_from.id && error.move_to.is_some() {\n                 debug!(\"appending move_to to list\");\n-                ge.move_to_places.extend(move_to.into_iter());\n+                ge.move_to_places.extend(move_to);\n                 return\n             }\n         }"}, {"sha": "a9c7d22c3708a77cb4260f2008b846c76326c708", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -484,7 +484,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                 let mut new_path = sess.host_filesearch(PathKind::All)\n                                        .get_dylib_search_paths();\n                 new_path.extend(env::split_paths(&_old_path));\n-                env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n+                env::set_var(\"PATH\", &env::join_paths(new_path).unwrap());\n             }\n             let features = sess.features.borrow();\n             let cfg = syntax::ext::expand::ExpansionConfig {\n@@ -765,7 +765,7 @@ pub fn phase_6_link_output(sess: &Session,\n     let old_path = env::var_os(\"PATH\").unwrap_or(OsString::new());\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n     new_path.extend(env::split_paths(&old_path));\n-    env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n+    env::set_var(\"PATH\", &env::join_paths(&new_path).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|\n          link::link_binary(sess,\n@@ -895,7 +895,7 @@ pub fn collect_crate_types(session: &Session,\n     // will be found in crate attributes.\n     let mut base = session.opts.crate_types.clone();\n     if base.is_empty() {\n-        base.extend(attr_types.into_iter());\n+        base.extend(attr_types);\n         if base.is_empty() {\n             base.push(link::default_output_for_target(session));\n         }"}, {"sha": "6ae0ea81c3ddaffb009b15f4eb9cdafc6217ee2b", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -566,7 +566,7 @@ Available lint options:\n     let plugin_groups = sort_lint_groups(plugin_groups);\n     let builtin_groups = sort_lint_groups(builtin_groups);\n \n-    let max_name_len = plugin.iter().chain(builtin.iter())\n+    let max_name_len = plugin.iter().chain(&builtin)\n         .map(|&s| s.name.chars().count())\n         .max().unwrap_or(0);\n     let padded = |x: &str| {\n@@ -593,7 +593,7 @@ Available lint options:\n \n \n \n-    let max_name_len = plugin_groups.iter().chain(builtin_groups.iter())\n+    let max_name_len = plugin_groups.iter().chain(&builtin_groups)\n         .map(|&(s, _)| s.chars().count())\n         .max().unwrap_or(0);\n     let padded = |x: &str| {"}, {"sha": "9c87f8a98db5d034ca8373df72b3984b704b036e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -645,7 +645,7 @@ impl LintPass for UnusedAttributes {\n         }\n \n         let plugin_attributes = cx.sess().plugin_attributes.borrow_mut();\n-        for &(ref name, ty) in plugin_attributes.iter() {\n+        for &(ref name, ty) in &*plugin_attributes {\n             if ty == AttributeType::Whitelisted && attr.check_name(&*name) {\n                 break;\n             }\n@@ -2249,7 +2249,7 @@ impl LintPass for DropWithReprExtern {\n         lint_array!(DROP_WITH_REPR_EXTERN)\n     }\n     fn check_crate(&mut self, ctx: &Context, _: &ast::Crate) {\n-        for dtor_did in ctx.tcx.destructors.borrow().iter() {\n+        for dtor_did in &*ctx.tcx.destructors.borrow() {\n             let (drop_impl_did, dtor_self_type) =\n                 if dtor_did.krate == ast::LOCAL_CRATE {\n                     let impl_did = ctx.tcx.map.get_parent_did(dtor_did.node);"}, {"sha": "455aea9448e381b168228fceab7fe030f9225828", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -215,7 +215,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n         // `visit::walk_variant` without the discriminant expression.\n         match variant.node.kind {\n             ast::TupleVariantKind(ref variant_arguments) => {\n-                for variant_argument in variant_arguments.iter() {\n+                for variant_argument in variant_arguments {\n                     self.visit_ty(&*variant_argument.ty);\n                 }\n             }"}, {"sha": "6d51ae50ea0ce72fa56ac9b0d9b48afc48f91326", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -355,7 +355,7 @@ pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n }\n \n pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n-    mangle(path.chain(Some(gensym_name(flav)).into_iter()), None)\n+    mangle(path.chain(Some(gensym_name(flav))), None)\n }\n \n pub fn get_cc_prog(sess: &Session) -> String {\n@@ -761,7 +761,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n         ab.add_rlib(&p, &name[..], sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n-        all_native_libs.extend(native_libs.into_iter());\n+        all_native_libs.extend(native_libs);\n     }\n \n     ab.update_symbols();\n@@ -918,7 +918,7 @@ fn link_args(cmd: &mut Linker,\n         let empty_vec = Vec::new();\n         let empty_str = String::new();\n         let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n-        let mut args = args.iter().chain(used_link_args.iter());\n+        let mut args = args.iter().chain(&*used_link_args);\n         let relocation_model = sess.opts.cg.relocation_model.as_ref()\n                                    .unwrap_or(&empty_str);\n         if (t.options.relocation_model == \"pic\" || *relocation_model == \"pic\")"}, {"sha": "e0fad66bdd8105f605f476d58b7fbed2a6369667", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -138,7 +138,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let mut result: Vec<(Span, String)> = vec!();\n \n         let mut segs = vec!();\n-        for (i, (seg, span)) in path.segments.iter().zip(spans.iter()).enumerate() {\n+        for (i, (seg, span)) in path.segments.iter().zip(&spans).enumerate() {\n             segs.push(seg.clone());\n             let sub_path = ast::Path{span: *span, // span for the last segment\n                                      global: path.global,\n@@ -476,14 +476,14 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         // the first few to match the number of generics we're looking for.\n         let param_sub_spans = self.span.spans_for_ty_params(full_span,\n                                                            (generics.ty_params.len() as isize));\n-        for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans.iter()) {\n+        for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans) {\n             // Append $id to name to make sure each one is unique\n             let name = format!(\"{}::{}${}\",\n                                prefix,\n-                               escape(self.span.snippet(*param_ss)),\n+                               escape(self.span.snippet(param_ss)),\n                                id);\n             self.fmt.typedef_str(full_span,\n-                                 Some(*param_ss),\n+                                 Some(param_ss),\n                                  param.id,\n                                  &name,\n                                  \"\");"}, {"sha": "2beb4efb3d1aa70b7a15457c533e271c36f24c2a", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -1501,7 +1501,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     };\n \n     let mut matches = Vec::new();\n-    for (arm_data, pats) in arm_datas.iter().zip(arm_pats.iter()) {\n+    for (arm_data, pats) in arm_datas.iter().zip(&arm_pats) {\n         matches.extend(pats.iter().map(|p| Match {\n             pats: vec![&**p],\n             data: arm_data,\n@@ -1833,7 +1833,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 .iter()\n                 .chain(slice.iter())\n                 .chain(after.iter())\n-                .zip(extracted.vals.into_iter())\n+                .zip(extracted.vals)\n                 .fold(bcx, |bcx, (inner, elem)|\n                     bind_irrefutable_pat(bcx, &**inner, elem, cleanup_scope)\n                 );"}, {"sha": "f94d67c8796e82db50d829c2c30eae64c3e3e2ff", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -1199,7 +1199,7 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // offset of current value\n     let mut offset = 0;\n     let mut cfields = Vec::new();\n-    for (&val, &target_offset) in vals.iter().zip(target_offsets.iter()) {\n+    for (&val, target_offset) in vals.iter().zip(target_offsets) {\n         if !st.packed {\n             let val_align = machine::llalign_of_min(ccx, val_ty(val));\n             offset = roundup(offset, val_align);"}, {"sha": "db726fe4b8e3b6fa687c371d3895a31e127c23d3", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -88,7 +88,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n \n     let all_constraints= constraints.iter()\n                                     .map(|s| s.to_string())\n-                                    .chain(ext_constraints.into_iter())\n+                                    .chain(ext_constraints)\n                                     .chain(clobbers)\n                                     .chain(arch_clobbers.iter()\n                                                .map(|s| s.to_string()))"}, {"sha": "947f45dc3918239b2f648a2c278755bf886c7345", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -561,7 +561,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // we care about.\n         if ixs.len() < 16 {\n             let mut small_vec = [ C_i32(self.ccx, 0); 16 ];\n-            for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs.iter()) {\n+            for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs) {\n                 *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n             self.inbounds_gep(base, &small_vec[..ixs.len()])"}, {"sha": "304906a666e63f2ad612a836d819466f5d12fc4e", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -257,7 +257,7 @@ fn walk_pattern(cx: &CrateContext,\n             for &codemap::Spanned {\n                 node: ast::FieldPat { pat: ref sub_pat, .. },\n                 ..\n-            } in field_pats.iter() {\n+            } in field_pats {\n                 walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n             }\n         }"}, {"sha": "72d0159a8cdc8533904de67457ac67024cc65bea", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -1557,7 +1557,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n     let args: Vec<(String, Ty)> = arg_names.iter()\n-        .zip(struct_def.fields.iter())\n+        .zip(&struct_def.fields)\n         .map(|(s, &t)| (s.to_string(), t))\n         .collect();\n "}, {"sha": "4d340fcc77c2fd698006765311269efc2b076448", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -216,7 +216,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         output.push('<');\n \n-        for &type_parameter in substs.types.iter() {\n+        for &type_parameter in &substs.types {\n             push_debuginfo_type_name(cx, type_parameter, true, output);\n             output.push_str(\", \");\n         }"}, {"sha": "23d2d8efc33258261ca1dfc60eedff986f553597", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -526,7 +526,7 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n             assert!(coerce_index < src_fields.len() && src_fields.len() == target_fields.len());\n \n-            let iter = src_fields.iter().zip(target_fields.iter()).enumerate();\n+            let iter = src_fields.iter().zip(target_fields).enumerate();\n             for (i, (src_ty, target_ty)) in iter {\n                 let ll_source = adt::trans_field_ptr(bcx, &repr_source, source.val, 0, i);\n                 let ll_target = adt::trans_field_ptr(bcx, &repr_target, target.val, 0, i);\n@@ -1547,7 +1547,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n \n         // Finally, move scratch field values into actual field locations\n-        for (i, datum) in scratch_vals.into_iter() {\n+        for (i, datum) in scratch_vals {\n             let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n             bcx = datum.store_to(bcx, dest);\n         }"}, {"sha": "e151ce8fad2513fbdcf2d4cd669083c4101c4f77", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -454,7 +454,7 @@ fn gate_simd_ffi(tcx: &ty::ctxt, decl: &ast::FnDecl, ty: &ty::BareFnTy) {\n             }\n         };\n         let sig = &ty.sig.0;\n-        for (input, ty) in decl.inputs.iter().zip(sig.inputs.iter()) {\n+        for (input, ty) in decl.inputs.iter().zip(&sig.inputs) {\n             check(&*input.ty, *ty)\n         }\n         if let ast::Return(ref ty) = decl.output {\n@@ -600,7 +600,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         let ps = ccx.tcx().map.with_path(id, |path| {\n             let abi = Some(ast_map::PathName(special_idents::clownshoe_abi.name));\n-            link::mangle(path.chain(abi.into_iter()), hash)\n+            link::mangle(path.chain(abi), hash)\n         });\n \n         // Compute the type that the function would have if it were just a"}, {"sha": "da98b8a43cbfa4a28a280f89a17850f3f602fdee", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -106,7 +106,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ast::ItemEnum(_, _) => {\n               let vs_here = ty::enum_variants(ccx.tcx(), local_def(item.id));\n               let vs_there = ty::enum_variants(ccx.tcx(), parent_id);\n-              for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n+              for (here, there) in vs_here.iter().zip(&*vs_there) {\n                   if there.id == fn_id { my_id = here.id.node; }\n                   ccx.external().borrow_mut().insert(there.id, Some(here.id.node));\n               }"}, {"sha": "fbcfe9f218f38fa768b2a9e84b7ada2c2b7c6947", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -508,7 +508,7 @@ fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n     let mut lifetimes_for_params: Vec<(String, usize)> = Vec::new();\n     let mut possible_implied_output_region = None;\n \n-    for (input_type, input_pat) in input_tys.iter().zip(input_pats.into_iter()) {\n+    for (input_type, input_pat) in input_tys.iter().zip(input_pats) {\n         let mut accumulator = Vec::new();\n         ty::accumulate_lifetimes_in_type(&mut accumulator, *input_type);\n "}, {"sha": "0e3280c44be36740075c696076d33dbb37a773e6", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -250,7 +250,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let pat_ty = ty::mk_tup(tcx, element_tys.clone());\n             fcx.write_ty(pat.id, pat_ty);\n             demand::eqtype(fcx, pat.span, expected, pat_ty);\n-            for (element_pat, element_ty) in elements.iter().zip(element_tys.into_iter()) {\n+            for (element_pat, element_ty) in elements.iter().zip(element_tys) {\n                 check_pat(pcx, &**element_pat, element_ty);\n             }\n         }\n@@ -697,8 +697,8 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n     if let Some(subpats) = subpats {\n         if subpats.len() == arg_tys.len() {\n-            for (subpat, arg_ty) in subpats.iter().zip(arg_tys.iter()) {\n-                check_pat(pcx, &**subpat, *arg_ty);\n+            for (subpat, arg_ty) in subpats.iter().zip(arg_tys) {\n+                check_pat(pcx, &**subpat, arg_ty);\n             }\n         } else if arg_tys.is_empty() {\n             span_err!(tcx.sess, pat.span, E0024,"}, {"sha": "30ebcb756f7019c2397c91fb076b13ef866ee4db", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -184,11 +184,11 @@ fn try_overloaded_call_traits<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                        -> Option<ty::MethodCallee<'tcx>>\n {\n     // Try the options that are least restrictive on the caller first.\n-    for &(opt_trait_def_id, method_name) in [\n+    for &(opt_trait_def_id, method_name) in &[\n         (fcx.tcx().lang_items.fn_trait(), token::intern(\"call\")),\n         (fcx.tcx().lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n         (fcx.tcx().lang_items.fn_once_trait(), token::intern(\"call_once\")),\n-    ].iter() {\n+    ] {\n         let trait_def_id = match opt_trait_def_id {\n             Some(def_id) => def_id,\n             None => continue,\n@@ -379,7 +379,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                        method_callee.repr(fcx.tcx()));\n \n                 for (&method_arg_ty, &self_arg_ty) in\n-                    method_sig.inputs[1..].iter().zip(self.fn_sig.inputs.iter())\n+                    method_sig.inputs[1..].iter().zip(&self.fn_sig.inputs)\n                 {\n                     demand::eqtype(fcx, self.call_expr.span, self_arg_ty, method_arg_ty);\n                 }"}, {"sha": "d95bdd01e22135011dea1647c403d63d4c358b49", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -475,7 +475,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n                     let fields =\n                         ty::lookup_struct_fields(rcx.tcx(), struct_did);\n-                    for field in fields.iter() {\n+                    for field in &fields {\n                         let field_type =\n                             ty::lookup_field_type(rcx.tcx(),\n                                                   struct_did,\n@@ -507,7 +507,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                         ty::substd_enum_variants(rcx.tcx(),\n                                                  enum_did,\n                                                  substs);\n-                    for variant_info in all_variant_info.iter() {\n+                    for variant_info in &all_variant_info {\n                         for (i, arg_type) in variant_info.args.iter().enumerate() {\n                             try!(iterate_over_potentially_unsafe_regions_in_type(\n                                 rcx,"}, {"sha": "c8bf83a049b0cd4234830fc76ac490bd00c07ac1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -482,7 +482,7 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n \n     ccx.tcx.sess.abort_if_errors();\n \n-    for drop_method_did in ccx.tcx.destructors.borrow().iter() {\n+    for drop_method_did in &*ccx.tcx.destructors.borrow() {\n         if drop_method_did.krate == ast::LOCAL_CRATE {\n             let drop_impl_did = ccx.tcx.map.get_parent_did(drop_method_did.node);\n             match dropck::check_drop_impl(ccx.tcx, drop_impl_did) {\n@@ -679,7 +679,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         let mut visit = GatherLocalsVisitor { fcx: &fcx, };\n \n         // Add formal parameters.\n-        for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n+        for (arg_ty, input) in arg_tys.iter().zip(&decl.inputs) {\n             // Create type variables for each argument.\n             pat_util::pat_bindings(\n                 &tcx.def_map,\n@@ -706,8 +706,8 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         ty::FnDiverging => NoExpectation\n     });\n \n-    for (input, arg) in decl.inputs.iter().zip(arg_tys.iter()) {\n-        fcx.write_ty(input.id, *arg);\n+    for (input, arg) in decl.inputs.iter().zip(arg_tys) {\n+        fcx.write_ty(input.id, arg);\n     }\n \n     fcx\n@@ -1753,7 +1753,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                            substs: &Substs<'tcx>,\n                                            expr: &ast::Expr)\n     {\n-        for &ty in substs.types.iter() {\n+        for &ty in &substs.types {\n             let default_bound = ty::ReScope(CodeExtent::from_node_id(expr.id));\n             let cause = traits::ObligationCause::new(expr.span, self.body_id,\n                                                      traits::MiscObligation);\n@@ -4292,7 +4292,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         // we need not check for that.\n         let variants = ty::enum_variants(ccx.tcx, def_id);\n \n-        for (v, variant) in vs.iter().zip(variants.iter()) {\n+        for (v, variant) in vs.iter().zip(&*variants) {\n             let current_disr_val = variant.disr_val;\n \n             // Check for duplicate discriminant values\n@@ -4563,7 +4563,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // provided (if any) into their appropriate spaces. We'll also report\n     // errors if type parameters are provided in an inappropriate place.\n     let mut substs = Substs::empty();\n-    for (opt_space, segment) in segment_spaces.iter().zip(segments.iter()) {\n+    for (opt_space, segment) in segment_spaces.iter().zip(segments) {\n         match *opt_space {\n             None => {\n                 check_path_args(fcx.tcx(), slice::ref_slice(segment),"}, {"sha": "a29502bf51dc1af5795dba609453a004f8e0064e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -637,7 +637,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             // outlive the operation you are performing.\n             let lhs_ty = rcx.resolve_expr_type_adjusted(&**lhs);\n             let rhs_ty = rcx.resolve_expr_type_adjusted(&**rhs);\n-            for &ty in [lhs_ty, rhs_ty].iter() {\n+            for &ty in &[lhs_ty, rhs_ty] {\n                 type_must_outlive(rcx,\n                                   infer::Operand(expr.span),\n                                   ty,"}, {"sha": "10ec2225555e9614a462048bfe9a5bb91d770281", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -235,7 +235,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         if self.closures_with_inferred_kinds.contains(&id) {\n             let mut deferred_call_resolutions =\n                 self.fcx.remove_deferred_call_resolutions(closure_def_id);\n-            for deferred_call_resolution in deferred_call_resolutions.iter_mut() {\n+            for deferred_call_resolution in &mut deferred_call_resolutions {\n                 deferred_call_resolution.resolve(self.fcx);\n             }\n         }"}, {"sha": "62790a1d0a8788f33d10705a20d5e614fed283e3", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -375,7 +375,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                       span: Span,\n                                       predicates: &ty::GenericPredicates<'tcx>) {\n-    for predicate in predicates.predicates.iter() {\n+    for predicate in &predicates.predicates {\n         match predicate {\n             &ty::Predicate::Trait(ty::Binder(ref tr)) => {\n                 let found_param = tr.input_types().iter()\n@@ -514,7 +514,7 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n                 traits::ItemObligation(trait_ref.def_id)),\n             &bounds);\n \n-        for &ty in trait_ref.substs.types.iter() {\n+        for &ty in &trait_ref.substs.types {\n             self.check_traits_in_ty(ty);\n         }\n     }"}, {"sha": "3810abb7fe016f0d10d28e836b199bc209bc0ddc", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -260,7 +260,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n             }\n         }\n \n-        for request in cycle[1..].iter() {\n+        for request in &cycle[1..] {\n             match *request {\n                 AstConvRequest::GetItemTypeScheme(def_id) |\n                 AstConvRequest::GetTraitDef(def_id) => {\n@@ -443,7 +443,7 @@ impl<'a,'b,'tcx,A,B> GetTypeParameterBounds<'tcx> for (&'a A,&'b B)\n                                  -> Vec<ty::Predicate<'tcx>>\n     {\n         let mut v = self.0.get_type_parameter_bounds(astconv, span, node_id);\n-        v.extend(self.1.get_type_parameter_bounds(astconv, span, node_id).into_iter());\n+        v.extend(self.1.get_type_parameter_bounds(astconv, span, node_id));\n         v\n     }\n }\n@@ -516,8 +516,8 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ast::Generics {\n             self.ty_params\n                 .iter()\n                 .filter(|p| p.id == node_id)\n-                .flat_map(|p| p.bounds.iter())\n-                .flat_map(|b| predicates_from_bound(astconv, ty, b).into_iter());\n+                .flat_map(|p| &*p.bounds)\n+                .flat_map(|b| predicates_from_bound(astconv, ty, b));\n \n         let from_where_clauses =\n             self.where_clause\n@@ -528,8 +528,8 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ast::Generics {\n                     _ => None\n                 })\n                 .filter(|bp| is_param(astconv.tcx(), &bp.bounded_ty, node_id))\n-                .flat_map(|bp| bp.bounds.iter())\n-                .flat_map(|b| predicates_from_bound(astconv, ty, b).into_iter());\n+                .flat_map(|bp| &*bp.bounds)\n+                .flat_map(|b| predicates_from_bound(astconv, ty, b));\n \n         from_ty_params.chain(from_where_clauses).collect()\n     }\n@@ -1188,7 +1188,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         let superbounds2 = generics.get_type_parameter_bounds(&ccx.icx(scope), item.span, item.id);\n \n         // Combine the two lists to form the complete set of superbounds:\n-        let superbounds = superbounds1.into_iter().chain(superbounds2.into_iter()).collect();\n+        let superbounds = superbounds1.into_iter().chain(superbounds2).collect();\n         let superpredicates = ty::GenericPredicates {\n             predicates: VecPerParamSpace::new(superbounds, vec![], vec![])\n         };\n@@ -1928,7 +1928,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let inline_bounds = from_bounds(ccx, param_bounds);\n     let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n     let all_bounds: HashSet<_> = inline_bounds.into_iter()\n-                                              .chain(where_bounds.into_iter())\n+                                              .chain(where_bounds)\n                                               .collect();\n     return if all_bounds.len() > 1 {\n         Some(ty::ObjectLifetimeDefault::Ambiguous)\n@@ -2026,7 +2026,7 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx>,\n             let pred = conv_poly_trait_ref(astconv, param_ty, tr, &mut projections);\n             projections.into_iter()\n                        .map(|p| p.as_predicate())\n-                       .chain(Some(pred.as_predicate()).into_iter())\n+                       .chain(Some(pred.as_predicate()))\n                        .collect()\n         }\n         ast::RegionTyParamBound(ref lifetime) => {\n@@ -2096,7 +2096,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     abi: abi::Abi)\n     -> ty::TypeScheme<'tcx>\n {\n-    for i in decl.inputs.iter() {\n+    for i in &decl.inputs {\n         match (*i).pat.node {\n             ast::PatIdent(_, _, _) => (),\n             ast::PatWild(ast::PatWildSingle) => (),\n@@ -2300,7 +2300,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n                       ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None\n                   })\n-                  .flat_map(|ty| ctp::parameters_for_type(ty).into_iter())\n+                  .flat_map(|ty| ctp::parameters_for_type(ty))\n                   .filter_map(|p| match p {\n                       ctp::Parameter::Type(_) => None,\n                       ctp::Parameter::Region(r) => Some(r),"}, {"sha": "a46c04fee11362a3fb7ceb42985b7697abd42007", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -21,7 +21,7 @@ pub enum Parameter {\n \n pub fn parameters_for_type<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n     ty.walk()\n-      .flat_map(|ty| parameters_for_type_shallow(ty).into_iter())\n+      .flat_map(|ty| parameters_for_type_shallow(ty))\n       .collect()\n }\n \n@@ -31,7 +31,7 @@ pub fn parameters_for_trait_ref<'tcx>(trait_ref: &ty::TraitRef<'tcx>) -> Vec<Par\n \n     let type_parameters =\n         trait_ref.substs.types.iter()\n-                              .flat_map(|ty| parameters_for_type(ty).into_iter());\n+                              .flat_map(|ty| parameters_for_type(ty));\n \n     region_parameters.extend(type_parameters);\n "}, {"sha": "aa364c4c74656defec9b245d1e23ef91916829e9", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -83,17 +83,17 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n         }\n         def::DefStruct(did) => {\n             record_extern_fqn(cx, did, clean::TypeStruct);\n-            ret.extend(build_impls(cx, tcx, did).into_iter());\n+            ret.extend(build_impls(cx, tcx, did));\n             clean::StructItem(build_struct(cx, tcx, did))\n         }\n         def::DefTy(did, false) => {\n             record_extern_fqn(cx, did, clean::TypeTypedef);\n-            ret.extend(build_impls(cx, tcx, did).into_iter());\n+            ret.extend(build_impls(cx, tcx, did));\n             build_type(cx, tcx, did)\n         }\n         def::DefTy(did, true) => {\n             record_extern_fqn(cx, did, clean::TypeEnum);\n-            ret.extend(build_impls(cx, tcx, did).into_iter());\n+            ret.extend(build_impls(cx, tcx, did));\n             build_type(cx, tcx, did)\n         }\n         // Assume that the enum type is reexported next to the variant, and\n@@ -228,7 +228,7 @@ pub fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n     match tcx.inherent_impls.borrow().get(&did) {\n         None => {}\n         Some(i) => {\n-            for &did in i.iter() {\n+            for &did in &**i {\n                 build_impl(cx, tcx, did, &mut impls);\n             }\n         }\n@@ -451,7 +451,7 @@ fn build_module(cx: &DocContext, tcx: &ty::ctxt,\n                 decoder::DlDef(def) if vis == ast::Public => {\n                     if !visited.insert(def) { return }\n                     match try_inline_def(cx, tcx, def) {\n-                        Some(i) => items.extend(i.into_iter()),\n+                        Some(i) => items.extend(i),\n                         None => {}\n                     }\n                 }"}, {"sha": "bbd999b1d73bd4e7a3d3d788853dac7ab4c692aa", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -190,7 +190,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     inner: PrimitiveItem(prim),\n                 });\n             }\n-            m.items.extend(tmp.into_iter());\n+            m.items.extend(tmp);\n         }\n \n         let src = match cx.input {\n@@ -382,17 +382,17 @@ impl Clean<Item> for doctree::Module {\n \n         let mut items: Vec<Item> = vec![];\n         items.extend(self.extern_crates.iter().map(|x| x.clean(cx)));\n-        items.extend(self.imports.iter().flat_map(|x| x.clean(cx).into_iter()));\n+        items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.structs.iter().map(|x| x.clean(cx)));\n         items.extend(self.enums.iter().map(|x| x.clean(cx)));\n         items.extend(self.fns.iter().map(|x| x.clean(cx)));\n-        items.extend(self.foreigns.iter().flat_map(|x| x.clean(cx).into_iter()));\n+        items.extend(self.foreigns.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n         items.extend(self.typedefs.iter().map(|x| x.clean(cx)));\n         items.extend(self.statics.iter().map(|x| x.clean(cx)));\n         items.extend(self.constants.iter().map(|x| x.clean(cx)));\n         items.extend(self.traits.iter().map(|x| x.clean(cx)));\n-        items.extend(self.impls.iter().flat_map(|x| x.clean(cx).into_iter()));\n+        items.extend(self.impls.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n         items.extend(self.def_traits.iter().map(|x| x.clean(cx)));\n \n@@ -1884,7 +1884,7 @@ impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n                 StructVariant(VariantStruct {\n                     struct_type: doctree::Plain,\n                     fields_stripped: false,\n-                    fields: s.iter().zip(self.args.iter()).map(|(name, ty)| {\n+                    fields: s.iter().zip(&self.args).map(|(name, ty)| {\n                         Item {\n                             source: Span::empty(),\n                             name: Some(name.clean(cx)),\n@@ -2375,7 +2375,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n                     for path in list {\n                         match inline::try_inline(cx, path.node.id(), None) {\n                             Some(items) => {\n-                                ret.extend(items.into_iter());\n+                                ret.extend(items);\n                             }\n                             None => {\n                                 remaining.push(path.clean(cx));"}, {"sha": "2bde8d5bfb5fc02733ae62ad39735dd4a0459f77", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -139,7 +139,7 @@ pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n }\n \n pub fn ty_params(mut params: Vec<clean::TyParam>) -> Vec<clean::TyParam> {\n-    for param in params.iter_mut() {\n+    for param in &mut params {\n         param.bounds = ty_bounds(mem::replace(&mut param.bounds, Vec::new()));\n     }\n     return params;\n@@ -165,7 +165,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: ast::DefId,\n             } if *s == \"Self\" => Some(bounds),\n             _ => None,\n         }\n-    }).flat_map(|bounds| bounds.iter()).any(|bound| {\n+    }).flat_map(|bounds| bounds).any(|bound| {\n         let poly_trait = match *bound {\n             clean::TraitBound(ref t, _) => t,\n             _ => return false,"}, {"sha": "9669492cb996d607059faf639ceba9f3e770311a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -2414,7 +2414,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: AssocItemLink,\n     }\n \n     try!(write!(w, \"<div class='impl-items'>\"));\n-    for trait_item in i.impl_.items.iter() {\n+    for trait_item in &i.impl_.items {\n         try!(doctraititem(w, trait_item, link, render_header));\n     }\n "}, {"sha": "1ac95177860680cd7d59d710f3f0b9fa533e0d6c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -75,7 +75,7 @@ pub fn run(input: &str,\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess);\n-    cfg.extend(config::parse_cfgspecs(cfgs).into_iter());\n+    cfg.extend(config::parse_cfgspecs(cfgs));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n     let krate = driver::phase_2_configure_and_expand(&sess, krate,\n                                                      \"rustdoc-test\", None)\n@@ -129,12 +129,13 @@ fn scrape_test_config(krate: &::syntax::ast::Crate) -> TestOptions {\n         attrs: Vec::new(),\n     };\n \n-    let attrs = krate.attrs.iter().filter(|a| a.check_name(\"doc\"))\n+    let attrs = krate.attrs.iter()\n+                     .filter(|a| a.check_name(\"doc\"))\n                      .filter_map(|a| a.meta_item_list())\n-                     .flat_map(|l| l.iter())\n+                     .flat_map(|l| l)\n                      .filter(|a| a.check_name(\"test\"))\n                      .filter_map(|a| a.meta_item_list())\n-                     .flat_map(|l| l.iter());\n+                     .flat_map(|l| l);\n     for attr in attrs {\n         if attr.check_name(\"no_crate_inject\") {\n             opts.no_crate_inject = true;\n@@ -239,7 +240,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n         let path = env::var_os(var).unwrap_or(OsString::new());\n         let mut path = env::split_paths(&path).collect::<Vec<_>>();\n         path.insert(0, libdir.clone());\n-        env::join_paths(path.iter()).unwrap()\n+        env::join_paths(path).unwrap()\n     };\n     cmd.env(var, &newpath);\n "}, {"sha": "b808acb73a12a2691085ed0c92091d8dce973a1c", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -226,7 +226,7 @@ impl AsciiExt for [u8] {\n     #[inline]\n     fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n         self.len() == other.len() &&\n-        self.iter().zip(other.iter()).all(|(a, b)| {\n+        self.iter().zip(other).all(|(a, b)| {\n             a.eq_ignore_ascii_case(b)\n         })\n     }"}, {"sha": "e12814bf77c7c1b4ff822ba41cd32ed27d056f5f", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -906,7 +906,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///     *val *= 2;\n     /// }\n     ///\n-    /// for (key, val) in map.iter() {\n+    /// for (key, val) in &map {\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```"}, {"sha": "c31a46ada32873f01c546b1e30b3cb28a7b2a647", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -647,7 +647,7 @@ impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     ///\n     /// let mut i = 0;\n     /// let expected = [1, 2, 3, 4, 5];\n-    /// for x in set.iter() {\n+    /// for x in &set {\n     ///     assert!(expected.contains(x));\n     ///     i += 1;\n     /// }\n@@ -679,7 +679,7 @@ impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     ///\n     /// let mut i = 0;\n     /// let expected = [2, 3];\n-    /// for x in set.iter() {\n+    /// for x in &set {\n     ///     assert!(expected.contains(x));\n     ///     i += 1;\n     /// }\n@@ -711,7 +711,7 @@ impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     ///\n     /// let mut i = 0;\n     /// let expected = [1, 2, 4, 5];\n-    /// for x in set.iter() {\n+    /// for x in &set {\n     ///     assert!(expected.contains(x));\n     ///     i += 1;\n     /// }\n@@ -743,7 +743,7 @@ impl<'a, 'b, T, S> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     ///\n     /// let mut i = 0;\n     /// let expected = [1, 2];\n-    /// for x in set.iter() {\n+    /// for x in &set {\n     ///     assert!(expected.contains(x));\n     ///     i += 1;\n     /// }\n@@ -838,7 +838,7 @@ impl<T, S> IntoIterator for HashSet<T, S>\n     /// let v: Vec<String> = set.into_iter().collect();\n     ///\n     /// // Will print in an arbitrary order.\n-    /// for x in v.iter() {\n+    /// for x in &v {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```"}, {"sha": "4781f2b47548f14dd59e2d4ac294043fa8d1521b", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -252,6 +252,7 @@\n //! contents by-value. This is great when the collection itself is no longer\n //! needed, and the values are needed elsewhere. Using `extend` with `into_iter`\n //! is the main way that contents of one collection are moved into another.\n+//! `extend` automatically calls `into_iter`, and takes any `T: IntoIterator`.\n //! Calling `collect` on an iterator itself is also a great way to convert one\n //! collection into another. Both of these methods should internally use the\n //! capacity management tools discussed in the previous section to do this as\n@@ -260,7 +261,7 @@\n //! ```\n //! let mut vec1 = vec![1, 2, 3, 4];\n //! let vec2 = vec![10, 20, 30, 40];\n-//! vec1.extend(vec2.into_iter());\n+//! vec1.extend(vec2);\n //! ```\n //!\n //! ```\n@@ -339,7 +340,7 @@\n //! assert_eq!(count.get(&'s'), Some(&8));\n //!\n //! println!(\"Number of occurrences of each character\");\n-//! for (char, count) in count.iter() {\n+//! for (char, count) in &count {\n //!     println!(\"{}: {}\", char, count);\n //! }\n //! ```\n@@ -362,7 +363,7 @@\n //! // Our clients.\n //! let mut blood_alcohol = BTreeMap::new();\n //!\n-//! for id in orders.into_iter() {\n+//! for id in orders {\n //!     // If this is the first time we've seen this customer, initialize them\n //!     // with no blood alcohol. Otherwise, just retrieve them.\n //!     let person = blood_alcohol.entry(id).or_insert(Person{id: id, blood_alcohol: 0.0});"}, {"sha": "1c8e52f1b5361c17aa91caf16dee658aa67899d8", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -294,7 +294,7 @@ mod dl {\n         let result = match filename {\n             Some(filename) => {\n                 let filename_str: Vec<_> =\n-                    filename.encode_wide().chain(Some(0).into_iter()).collect();\n+                    filename.encode_wide().chain(Some(0)).collect();\n                 let result = unsafe {\n                     LoadLibraryW(filename_str.as_ptr() as *const libc::c_void)\n                 };"}, {"sha": "7f83f0763c640363ae7e956d4af1ac97694f83f6", "filename": "src/libstd/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -365,7 +365,7 @@ pub struct JoinPathsError {\n /// if let Some(path) = env::var_os(\"PATH\") {\n ///     let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n ///     paths.push(PathBuf::from(\"/home/xyz/bin\"));\n-///     let new_path = env::join_paths(paths.iter()).unwrap();\n+///     let new_path = env::join_paths(paths).unwrap();\n ///     env::set_var(\"PATH\", &new_path);\n /// }\n /// ```"}, {"sha": "d8c999f8948379eb9c80c325606bf438a32c1654", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -78,7 +78,7 @@ pub fn repeat(byte: u8) -> Repeat { Repeat { byte: byte } }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for Repeat {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        for slot in buf.iter_mut() {\n+        for slot in &mut *buf {\n             *slot = self.byte;\n         }\n         Ok(buf.len())"}, {"sha": "b0fadb56f36ac7db9ff0a9c8dd6a77de80bf3b31", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -63,7 +63,7 @@ impl<'a> Parser<'a> {\n     // Return result of first successful parser\n     fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T> + 'static>])\n                -> Option<T> {\n-        for pf in parsers.iter_mut() {\n+        for pf in parsers {\n             match self.read_atomically(|p: &mut Parser| pf(p)) {\n                 Some(r) => return Some(r),\n                 None => {}"}, {"sha": "437b2cc6491179e2020bdeeeb3244f880d994c3d", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -368,7 +368,7 @@ impl fmt::Debug for File {\n }\n \n pub fn to_utf16(s: &Path) -> Vec<u16> {\n-    s.as_os_str().encode_wide().chain(Some(0).into_iter()).collect()\n+    s.as_os_str().encode_wide().chain(Some(0)).collect()\n }\n \n impl FileAttr {"}, {"sha": "423996ce6d055e005ab512bb6af20ddc30a617ce", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -615,7 +615,7 @@ pub fn path_name_eq(a : &ast::Path, b : &ast::Path) -> bool {\n // are two arrays of segments equal when compared unhygienically?\n pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> bool {\n     a.len() == b.len() &&\n-    a.iter().zip(b.iter()).all(|(s, t)| {\n+    a.iter().zip(b).all(|(s, t)| {\n         s.identifier.name == t.identifier.name &&\n         // FIXME #7743: ident -> name problems in lifetime comparison?\n         // can types contain idents?"}, {"sha": "aa3ec03ee942b73f8c9bf552b5396317ead8511b", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -414,7 +414,7 @@ fn find_stability_generic<'a,\n                 let mut feature = None;\n                 let mut since = None;\n                 let mut reason = None;\n-                for meta in metas.iter() {\n+                for meta in metas {\n                     if meta.name() == \"feature\" {\n                         match meta.value_str() {\n                             Some(v) => feature = Some(v),"}, {"sha": "14dd9978b876af891ab2bb5bf4886365b7933eba", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -595,7 +595,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let display_line_strings = &line_strings[..display_lines];\n \n     // Print the offending lines\n-    for (line_info, line) in display_line_infos.iter().zip(display_line_strings.iter()) {\n+    for (line_info, line) in display_line_infos.iter().zip(display_line_strings) {\n         try!(write!(&mut err.dst, \"{}:{} {}\\n\",\n                     fm.name,\n                     line_info.line_index + 1,"}, {"sha": "3c43273911181ac64896c4bef48f13fc672d4514", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -549,10 +549,10 @@ impl<'a> TraitDef<'a> {\n                 .map(|ty_param| ty_param.ident.name)\n                 .collect();\n \n-            for field_ty in field_tys.into_iter() {\n+            for field_ty in field_tys {\n                 let tys = find_type_parameters(&*field_ty, &ty_param_names);\n \n-                for ty in tys.into_iter() {\n+                for ty in tys {\n                     let mut bounds: Vec<_> = self.additional_bounds.iter().map(|p| {\n                         cx.typarambound(p.to_path(cx, self.span, type_ident, generics))\n                     }).collect();\n@@ -672,7 +672,7 @@ impl<'a> TraitDef<'a> {\n                        generics: &Generics) -> P<ast::Item> {\n         let mut field_tys = Vec::new();\n \n-        for variant in enum_def.variants.iter() {\n+        for variant in &enum_def.variants {\n             match variant.node.kind {\n                 ast::VariantKind::TupleVariantKind(ref args) => {\n                     field_tys.extend(args.iter()\n@@ -967,7 +967,7 @@ impl<'a> MethodDef<'a> {\n         // make a series of nested matches, to destructure the\n         // structs. This is actually right-to-left, but it shouldn't\n         // matter.\n-        for (arg_expr, pat) in self_args.iter().zip(patterns.iter()) {\n+        for (arg_expr, pat) in self_args.iter().zip(patterns) {\n             body = cx.expr_match(trait_.span, arg_expr.clone(),\n                                      vec!( cx.arm(trait_.span, vec!(pat.clone()), body) ))\n         }\n@@ -1226,7 +1226,7 @@ impl<'a> MethodDef<'a> {\n             let target_type_name =\n                 find_repr_type_name(&cx.parse_sess.span_diagnostic, type_attrs);\n \n-            for (&ident, self_arg) in vi_idents.iter().zip(self_args.iter()) {\n+            for (&ident, self_arg) in vi_idents.iter().zip(&self_args) {\n                 let path = vec![cx.ident_of_std(\"core\"),\n                                 cx.ident_of(\"intrinsics\"),\n                                 cx.ident_of(\"discriminant_value\")];\n@@ -1465,7 +1465,7 @@ impl<'a> TraitDef<'a> {\n         // struct_type is definitely not Unknown, since struct_def.fields\n         // must be nonempty to reach here\n         let pattern = if struct_type == Record {\n-            let field_pats = subpats.into_iter().zip(ident_expr.iter())\n+            let field_pats = subpats.into_iter().zip(&ident_expr)\n                                     .map(|(pat, &(_, id, _, _))| {\n                 // id is guaranteed to be Some\n                 codemap::Spanned {"}, {"sha": "4aa313f3e660ff4165a0434439101740332ca546", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -183,7 +183,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n             arms.push(pat_arm);\n-            arms.extend(else_if_arms.into_iter());\n+            arms.extend(else_if_arms);\n             arms.push(else_arm);\n \n             let match_expr = fld.cx.expr(span,\n@@ -779,7 +779,7 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                     };\n                     // add them to the existing pending renames:\n                     fld.cx.syntax_env.info().pending_renames\n-                          .extend(new_pending_renames.into_iter());\n+                          .extend(new_pending_renames);\n                     Local {\n                         id: id,\n                         ty: expanded_ty,"}, {"sha": "82c249d2585adf699a35b63774f440eb5eec3668", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -49,7 +49,7 @@ pub mod rt {\n \n     impl<T: ToTokens> ToTokens for Vec<T> {\n         fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            self.iter().flat_map(|t| t.to_tokens(cx).into_iter()).collect()\n+            self.iter().flat_map(|t| t.to_tokens(cx)).collect()\n         }\n     }\n \n@@ -387,7 +387,7 @@ pub fn expand_quote_matcher(cx: &mut ExtCtxt,\n                             -> Box<base::MacResult+'static> {\n     let (cx_expr, tts) = parse_arguments_to_quote(cx, tts);\n     let mut vector = mk_stmts_let(cx, sp);\n-    vector.extend(statements_mk_tts(cx, &tts[..], true).into_iter());\n+    vector.extend(statements_mk_tts(cx, &tts[..], true));\n     let block = cx.expr_block(\n         cx.block_all(sp,\n                      vector,\n@@ -593,7 +593,7 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n fn statements_mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree, matcher: bool) -> Vec<P<ast::Stmt>> {\n     match *tt {\n         ast::TtToken(sp, SubstNt(ident, _)) => {\n-            // tt.extend($ident.to_tokens(ext_cx).into_iter())\n+            // tt.extend($ident.to_tokens(ext_cx))\n \n             let e_to_toks =\n                 cx.expr_method_call(sp,\n@@ -633,8 +633,8 @@ fn statements_mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree, matcher: bool) -> Vec<P<a\n         ast::TtDelimited(_, ref delimed) => {\n             statements_mk_tt(cx, &delimed.open_tt(), matcher).into_iter()\n                 .chain(delimed.tts.iter()\n-                                  .flat_map(|tt| statements_mk_tt(cx, tt, matcher).into_iter()))\n-                .chain(statements_mk_tt(cx, &delimed.close_tt(), matcher).into_iter())\n+                                  .flat_map(|tt| statements_mk_tt(cx, tt, matcher)))\n+                .chain(statements_mk_tt(cx, &delimed.close_tt(), matcher))\n                 .collect()\n         },\n         ast::TtSequence(sp, ref seq) => {\n@@ -646,7 +646,7 @@ fn statements_mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree, matcher: bool) -> Vec<P<a\n \n             let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n             let mut tts_stmts = vec![stmt_let_tt];\n-            tts_stmts.extend(statements_mk_tts(cx, &seq.tts[..], matcher).into_iter());\n+            tts_stmts.extend(statements_mk_tts(cx, &seq.tts[..], matcher));\n             let e_tts = cx.expr_block(cx.block(sp, tts_stmts,\n                                                    Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n             let e_separator = match seq.separator {\n@@ -748,7 +748,7 @@ fn mk_stmts_let(cx: &ExtCtxt, sp: Span) -> Vec<P<ast::Stmt>> {\n fn statements_mk_tts(cx: &ExtCtxt, tts: &[ast::TokenTree], matcher: bool) -> Vec<P<ast::Stmt>> {\n     let mut ss = Vec::new();\n     for tt in tts {\n-        ss.extend(statements_mk_tt(cx, tt, matcher).into_iter());\n+        ss.extend(statements_mk_tt(cx, tt, matcher));\n     }\n     ss\n }\n@@ -758,7 +758,7 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let (cx_expr, tts) = parse_arguments_to_quote(cx, tts);\n \n     let mut vector = mk_stmts_let(cx, sp);\n-    vector.extend(statements_mk_tts(cx, &tts[..], false).into_iter());\n+    vector.extend(statements_mk_tts(cx, &tts[..], false));\n     let block = cx.expr_block(\n         cx.block_all(sp,\n                      vector,\n@@ -780,7 +780,7 @@ fn expand_wrapper(cx: &ExtCtxt,\n         // make item: `use ...;`\n         let path = path.iter().map(|s| s.to_string()).collect();\n         cx.stmt_item(sp, cx.item_use_glob(sp, ast::Inherited, ids_ext(path)))\n-    }).chain(Some(stmt_let_ext_cx).into_iter()).collect();\n+    }).chain(Some(stmt_let_ext_cx)).collect();\n \n     cx.expr_block(cx.block_all(sp, stmts, Some(expr)))\n }"}, {"sha": "ea135c7a642ed1a0619cb3d224eb52c214d79fe6", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -385,7 +385,7 @@ impl<'a> Context<'a> {\n                 return;\n             }\n         }\n-        for &(ref n, ref ty) in self.plugin_attributes.iter() {\n+        for &(ref n, ref ty) in self.plugin_attributes {\n             if &*n == name {\n                 // Plugins can't gate attributes, so we don't check for it\n                 // unlike the code above; we only use this loop to"}, {"sha": "14742d2e74c9518b7d003563802e2c01237f0815", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -353,7 +353,7 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n }\n \n pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n-    attrs.into_iter().flat_map(|x| fld.fold_attribute(x).into_iter()).collect()\n+    attrs.into_iter().flat_map(|x| fld.fold_attribute(x)).collect()\n }\n \n pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T) -> Arm {"}, {"sha": "afc592ab4bc1444d35d7a1a15ab1754d985cdf1e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -1060,7 +1060,7 @@ impl<'a> Parser<'a> {\n             };\n             let all_bounds =\n                 Some(TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)).into_iter()\n-                .chain(other_bounds.into_vec().into_iter())\n+                .chain(other_bounds.into_vec())\n                 .collect();\n             Ok(ast::TyPolyTraitRef(all_bounds))\n         }\n@@ -2058,7 +2058,7 @@ impl<'a> Parser<'a> {\n                             |p| Ok(try!(p.parse_expr_nopanic()))\n                                 ));\n                         let mut exprs = vec!(first_expr);\n-                        exprs.extend(remaining_exprs.into_iter());\n+                        exprs.extend(remaining_exprs);\n                         ex = ExprVec(exprs);\n                     } else {\n                         // Vector with one element.\n@@ -4423,7 +4423,7 @@ impl<'a> Parser<'a> {\n             (name, ConstImplItem(typ, expr))\n         } else {\n             let (name, inner_attrs, node) = try!(self.parse_impl_method(vis));\n-            attrs.extend(inner_attrs.into_iter());\n+            attrs.extend(inner_attrs);\n             (name, node)\n         };\n \n@@ -5068,7 +5068,7 @@ impl<'a> Parser<'a> {\n \n         let abi = opt_abi.unwrap_or(abi::C);\n \n-        attrs.extend(self.parse_inner_attributes().into_iter());\n+        attrs.extend(self.parse_inner_attributes());\n \n         let mut foreign_items = vec![];\n         while let Some(item) = try!(self.parse_foreign_item()) {\n@@ -5244,7 +5244,7 @@ impl<'a> Parser<'a> {\n                 try!(self.bump());\n                 let mut attrs = attrs;\n                 mem::swap(&mut item.attrs, &mut attrs);\n-                item.attrs.extend(attrs.into_iter());\n+                item.attrs.extend(attrs);\n                 return Ok(Some(P(item)));\n             }\n             None => {}"}, {"sha": "cbc7b38b1ed29e80adb108bf7fbab5eb9f5d9121", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -658,7 +658,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n             diag.handler.bug(\"expected to find top-level re-export name, but found None\");\n         }\n     };\n-    visible_path.extend(path.into_iter());\n+    visible_path.extend(path);\n \n     let fn_expr = ecx.expr_path(ecx.path_global(span, visible_path));\n "}, {"sha": "9af751debc38426228a50e5d02e6c7d5e6e498ce", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -105,7 +105,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n         Number(0), Number(0), Number(0), Number(0), Number(0),\n         Number(0), Number(0), Number(0), Number(0),\n     ];\n-    for (dst, src) in mparams.iter_mut().zip(params.iter()) {\n+    for (dst, src) in mparams.iter_mut().zip(params) {\n         *dst = (*src).clone();\n     }\n \n@@ -510,7 +510,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                 let mut s_ = Vec::with_capacity(flags.precision);\n                 let n = flags.precision - s.len();\n                 s_.extend(repeat(b'0').take(n));\n-                s_.extend(s.into_iter());\n+                s_.extend(s);\n                 s = s_;\n             }\n             assert!(!s.is_empty(), \"string conversion produced empty result\");\n@@ -528,14 +528,14 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                 FormatHex => {\n                     if flags.alternate {\n                         let s_ = replace(&mut s, vec!(b'0', b'x'));\n-                        s.extend(s_.into_iter());\n+                        s.extend(s_);\n                     }\n                 }\n                 FormatHEX => {\n                     s = s.into_ascii_uppercase();\n                     if flags.alternate {\n                         let s_ = replace(&mut s, vec!(b'0', b'X'));\n-                        s.extend(s_.into_iter());\n+                        s.extend(s_);\n                     }\n                 }\n                 FormatString => unreachable!()\n@@ -565,7 +565,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n         } else {\n             let mut s_ = Vec::with_capacity(flags.width);\n             s_.extend(repeat(b' ').take(n));\n-            s_.extend(s.into_iter());\n+            s_.extend(s);\n             s = s_;\n         }\n     }"}, {"sha": "9850e0a6c2fc9e1f4ff2ebb6040f82dd42f1b34d", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -1423,7 +1423,7 @@ mod tests {\n                  \"test::parse_ignored_flag\".to_string(),\n                  \"test::sort_tests\".to_string());\n \n-        for (a, b) in expected.iter().zip(filtered.iter()) {\n+        for (a, b) in expected.iter().zip(filtered) {\n             assert!(*a == b.desc.name.to_string());\n         }\n     }"}, {"sha": "5a8e1f695ae6e846a9addc9b9d9f795a415ef9ac", "filename": "src/rustbook/subcommand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Frustbook%2Fsubcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Frustbook%2Fsubcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fsubcommand.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -36,7 +36,7 @@ pub fn parse_name(name: &str) -> Option<Box<Subcommand>> {\n                                                           build::parse_cmd,\n                                                           serve::parse_cmd,\n                                                           test::parse_cmd];\n-    for parser in cmds.iter() {\n+    for parser in &cmds {\n         let parsed = (*parser)(name);\n         if parsed.is_some() { return parsed }\n     }"}, {"sha": "95d74c6aa7f455a9ee30dbaecdfd03c635549a8f", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -72,7 +72,7 @@ fn vec_plus() {\n     while i < 1500 {\n         let rv = repeat(i).take(r.gen_range(0, i + 1)).collect::<Vec<_>>();\n         if r.gen() {\n-            v.extend(rv.into_iter());\n+            v.extend(rv);\n         } else {\n             let mut rv = rv.clone();\n             rv.push_all(&v);"}, {"sha": "3bc1782bd0c9e0ecf5e7bcb95f8ebb77f8dc37fc", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -103,7 +103,7 @@ impl Perm {\n             let d = idx / self.fact[i] as i32;\n             self.cnt[i] = d;\n             idx %= self.fact[i] as i32;\n-            for (place, val) in pp.iter_mut().zip(self.perm.p[..i+1].iter()) {\n+            for (place, val) in pp.iter_mut().zip(&self.perm.p[..i+1]) {\n                 *place = (*val) as u8\n             }\n "}, {"sha": "f69e155ad388885cfd39930798bc7898a61b0c62", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -124,11 +124,11 @@ impl<'a, W: Write> RepeatFasta<'a, W> {\n         let mut buf = repeat(0).take(alu_len + LINE_LEN).collect::<Vec<_>>();\n         let alu: &[u8] = self.alu.as_bytes();\n \n-        for (slot, val) in buf.iter_mut().zip(alu.iter()) {\n+        for (slot, val) in buf.iter_mut().zip(alu) {\n             *slot = *val;\n         }\n         let buf_len = buf.len();\n-        for (slot, val) in buf[alu_len..buf_len].iter_mut().zip(alu[..LINE_LEN].iter()) {\n+        for (slot, val) in buf[alu_len..buf_len].iter_mut().zip(&alu[..LINE_LEN]) {\n             *slot = *val;\n         }\n "}, {"sha": "b4e5ca201492a0d3600c5ee0f0cd65b3cfae0588", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -158,7 +158,7 @@ fn main() {\n         Some(channel::<String>())\n     }).collect::<Vec<_>>();\n     let mut from_child = Vec::new();\n-    let to_child  = sizes.iter().zip(streams.iter_mut()).map(|(sz, stream_ref)| {\n+    let to_child  = sizes.iter().zip(&mut streams).map(|(sz, stream_ref)| {\n         let sz = *sz;\n         let stream = replace(stream_ref, None);\n         let (to_parent_, from_child_) = stream.unwrap();"}, {"sha": "0cbef937e726d398d43c37e148d46dde2428ea23", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -317,7 +317,7 @@ fn main() {\n     for (i, freq) in nb_freqs {\n         print_frequencies(&freq.join().unwrap(), i);\n     }\n-    for (&occ, freq) in OCCURRENCES.iter().zip(occ_freqs.into_iter()) {\n+    for (&occ, freq) in OCCURRENCES.iter().zip(occ_freqs) {\n         print_occurrences(&mut freq.join().unwrap(), occ);\n     }\n }"}, {"sha": "d6f4d18a8d1d4358f7065f342346d5adcaf1eb77", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -108,8 +108,8 @@ fn mandelbrot<W: Write>(w: usize, mut out: W) -> io::Result<()> {\n \n     for res in precalc_futures {\n         let (rs, is) = res.join().unwrap();\n-        precalc_r.extend(rs.into_iter());\n-        precalc_i.extend(is.into_iter());\n+        precalc_r.extend(rs);\n+        precalc_i.extend(is);\n     }\n \n     assert_eq!(precalc_r.len(), w);"}, {"sha": "cb89f51210ca7dfa14fbe2c86a1aced4f4b0fd8c", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -315,7 +315,7 @@ fn par_search(masks: Vec<Vec<Vec<u64>>>) -> Data {\n \n     // launching the search in parallel on every masks at minimum\n     // coordinate (0,0)\n-    for m in (*masks)[0].iter().flat_map(|masks_pos| masks_pos.iter()) {\n+    for m in (*masks)[0].iter().flat_map(|masks_pos| masks_pos) {\n         let masks = masks.clone();\n         let tx = tx.clone();\n         let m = *m;"}, {"sha": "6ddf23281046141b343acb9635ce572cd57d7e93", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -107,7 +107,7 @@ fn A(i: usize, j: usize) -> f64 {\n }\n \n fn dot(v: &[f64], u: &[f64]) -> f64 {\n-    v.iter().zip(u.iter()).map(|(a, b)| *a * *b).sum()\n+    v.iter().zip(u).map(|(a, b)| *a * *b).sum()\n }\n \n "}, {"sha": "c0ed7165afecac903a1c08258eccec8cf5953bb0", "filename": "src/test/run-pass-fulldeps/issue-15149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15149.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -52,7 +52,7 @@ fn test() {\n     let path = {\n         let mut paths: Vec<_> = env::split_paths(&env::var_os(\"PATH\").unwrap()).collect();\n         paths.push(child_dir.to_path_buf());\n-        env::join_paths(paths.iter()).unwrap()\n+        env::join_paths(paths).unwrap()\n     };\n \n     let child_output = process::Command::new(\"mytest\").env(\"PATH\", &path)"}, {"sha": "dbf975c6f2e882c7e4f6a0cd509110ad8ea9fcbf", "filename": "src/test/run-pass/associated-types-conditional-dispatch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -28,8 +28,7 @@ impl<A, B> MyEq<[B]> for [A]\n {\n     fn eq(&self, other: &[B]) -> bool {\n         self.len() == other.len() &&\n-            self.iter().zip(other.iter())\n-                       .all(|(a, b)| MyEq::eq(a, b))\n+            self.iter().zip(other).all(|(a, b)| MyEq::eq(a, b))\n     }\n }\n "}, {"sha": "be854f820d4d6793cdb0059282999d24c70e21ae", "filename": "src/test/run-pass/associated-types-iterator-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Frun-pass%2Fassociated-types-iterator-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Frun-pass%2Fassociated-types-iterator-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-iterator-binding.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -23,6 +23,6 @@ fn pairwise_sub<T:DoubleEndedIterator<Item=isize>>(mut t: T) -> isize {\n \n fn main() {\n     let v = vec!(1, 2, 3, 4, 5, 6);\n-    let r =pairwise_sub(v.into_iter());\n+    let r = pairwise_sub(v.into_iter());\n     assert_eq!(r, 9);\n }"}, {"sha": "2772fc8787528b20f20a040860706e8ea28ec177", "filename": "src/test/run-pass/issue-20797.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20797.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -85,7 +85,7 @@ impl<S: Strategy> Iterator for Subpaths<S> {\n                 if path.is_dir() {\n                     let result = self.strategy.get_more(&path);\n                     match result {\n-                        Ok(dirs) => { self.stack.extend(dirs.into_iter()); },\n+                        Ok(dirs) => { self.stack.extend(dirs); },\n                         Err(..) => { }\n                     }\n                 }"}, {"sha": "b28e5ec64de345d1d8942d8721b2d1cae8f060db", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7418b84658fc1c723672c462aa0a7878d88b64/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=ca7418b84658fc1c723672c462aa0a7878d88b64", "patch": "@@ -19,7 +19,7 @@ impl<A> vec_monad<A> for Vec<A> {\n     fn bind<B, F>(&self, mut f: F) -> Vec<B> where F: FnMut(&A) -> Vec<B> {\n         let mut r = Vec::new();\n         for elt in self {\n-            r.extend(f(elt).into_iter());\n+            r.extend(f(elt));\n         }\n         r\n     }"}]}