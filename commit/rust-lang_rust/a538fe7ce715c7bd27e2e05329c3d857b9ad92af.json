{"sha": "a538fe7ce715c7bd27e2e05329c3d857b9ad92af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MzhmZTdjZTcxNWM3YmQyN2UyZTA1MzI5YzNkODU3YjlhZDkyYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-24T03:02:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-24T03:02:15Z"}, "message": "Auto merge of #46931 - clarcharr:float_bits_core, r=alexcrichton\n\nExpose float from_bits and to_bits in libcore.\n\nThese methods have no dependencies on libm and thus should be offered in libcore.", "tree": {"sha": "4ad33836bf270d25c4c8184d61f5487121dedefe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ad33836bf270d25c4c8184d61f5487121dedefe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a538fe7ce715c7bd27e2e05329c3d857b9ad92af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a538fe7ce715c7bd27e2e05329c3d857b9ad92af", "html_url": "https://github.com/rust-lang/rust/commit/a538fe7ce715c7bd27e2e05329c3d857b9ad92af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdecb0564b86f6876124903a05e590e929532039", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdecb0564b86f6876124903a05e590e929532039", "html_url": "https://github.com/rust-lang/rust/commit/fdecb0564b86f6876124903a05e590e929532039"}, {"sha": "556fb02e43a16de50764af55db20f64ac17e7f23", "url": "https://api.github.com/repos/rust-lang/rust/commits/556fb02e43a16de50764af55db20f64ac17e7f23", "html_url": "https://github.com/rust-lang/rust/commit/556fb02e43a16de50764af55db20f64ac17e7f23"}], "stats": {"total": 129, "additions": 73, "deletions": 56}, "files": [{"sha": "77180233a2389e50dee760fcda12c66be961813e", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=a538fe7ce715c7bd27e2e05329c3d857b9ad92af", "patch": "@@ -27,11 +27,10 @@\n //! Many functions in this module only handle normal numbers. The dec2flt routines conservatively\n //! take the universally-correct slow path (Algorithm M) for very small and very large numbers.\n //! That algorithm needs only next_float() which does handle subnormals and zeros.\n-use u32;\n use cmp::Ordering::{Less, Equal, Greater};\n-use ops::{Mul, Div, Neg};\n+use convert::{TryFrom, TryInto};\n+use ops::{Add, Mul, Div, Neg};\n use fmt::{Debug, LowerExp};\n-use mem::transmute;\n use num::diy_float::Fp;\n use num::FpCategory::{Infinite, Zero, Subnormal, Normal, Nan};\n use num::Float;\n@@ -56,22 +55,27 @@ impl Unpacked {\n ///\n /// Should **never ever** be implemented for other types or be used outside the dec2flt module.\n /// Inherits from `Float` because there is some overlap, but all the reused methods are trivial.\n-pub trait RawFloat : Float + Copy + Debug + LowerExp\n-                    + Mul<Output=Self> + Div<Output=Self> + Neg<Output=Self>\n+pub trait RawFloat\n+    : Float\n+    + Copy\n+    + Debug\n+    + LowerExp\n+    + Mul<Output=Self>\n+    + Div<Output=Self>\n+    + Neg<Output=Self>\n+where\n+    Self: Float<Bits = <Self as RawFloat>::RawBits>\n {\n     const INFINITY: Self;\n     const NAN: Self;\n     const ZERO: Self;\n \n+    /// Same as `Float::Bits` with extra traits.\n+    type RawBits: Add<Output = Self::RawBits> + From<u8> + TryFrom<u64>;\n+\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Get the raw binary representation of the float.\n-    fn transmute(self) -> u64;\n-\n-    /// Transmute the raw binary representation into a float.\n-    fn from_bits(bits: u64) -> Self;\n-\n     /// Decode the float.\n     fn unpack(self) -> Unpacked;\n \n@@ -149,6 +153,8 @@ macro_rules! other_constants {\n }\n \n impl RawFloat for f32 {\n+    type RawBits = u32;\n+\n     const SIG_BITS: u8 = 24;\n     const EXP_BITS: u8 = 8;\n     const CEIL_LOG5_OF_MAX_SIG: i16 = 11;\n@@ -159,7 +165,7 @@ impl RawFloat for f32 {\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u32 = unsafe { transmute(self) };\n+        let bits = self.to_bits();\n         let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n         let mantissa = if exponent == 0 {\n@@ -172,16 +178,6 @@ impl RawFloat for f32 {\n         (mantissa as u64, exponent, sign)\n     }\n \n-    fn transmute(self) -> u64 {\n-        let bits: u32 = unsafe { transmute(self) };\n-        bits as u64\n-    }\n-\n-    fn from_bits(bits: u64) -> f32 {\n-        assert!(bits < u32::MAX as u64, \"f32::from_bits: too many bits\");\n-        unsafe { transmute(bits as u32) }\n-    }\n-\n     fn unpack(self) -> Unpacked {\n         let (sig, exp, _sig) = self.integer_decode();\n         Unpacked::new(sig, exp)\n@@ -200,6 +196,8 @@ impl RawFloat for f32 {\n \n \n impl RawFloat for f64 {\n+    type RawBits = u64;\n+\n     const SIG_BITS: u8 = 53;\n     const EXP_BITS: u8 = 11;\n     const CEIL_LOG5_OF_MAX_SIG: i16 = 23;\n@@ -210,7 +208,7 @@ impl RawFloat for f64 {\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u64 = unsafe { transmute(self) };\n+        let bits = self.to_bits();\n         let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n         let mantissa = if exponent == 0 {\n@@ -223,15 +221,6 @@ impl RawFloat for f64 {\n         (mantissa, exponent, sign)\n     }\n \n-    fn transmute(self) -> u64 {\n-        let bits: u64 = unsafe { transmute(self) };\n-        bits\n-    }\n-\n-    fn from_bits(bits: u64) -> f64 {\n-        unsafe { transmute(bits) }\n-    }\n-\n     fn unpack(self) -> Unpacked {\n         let (sig, exp, _sig) = self.integer_decode();\n         Unpacked::new(sig, exp)\n@@ -296,14 +285,14 @@ pub fn encode_normal<T: RawFloat>(x: Unpacked) -> T {\n         \"encode_normal: exponent out of range\");\n     // Leave sign bit at 0 (\"+\"), our numbers are all positive\n     let bits = (k_enc as u64) << T::EXPLICIT_SIG_BITS | sig_enc;\n-    T::from_bits(bits)\n+    T::from_bits(bits.try_into().unwrap_or_else(|_| unreachable!()))\n }\n \n /// Construct a subnormal. A mantissa of 0 is allowed and constructs zero.\n pub fn encode_subnormal<T: RawFloat>(significand: u64) -> T {\n     assert!(significand < T::MIN_SIG, \"encode_subnormal: not actually subnormal\");\n     // Encoded exponent is 0, the sign bit is 0, so we just have to reinterpret the bits.\n-    T::from_bits(significand)\n+    T::from_bits(significand.try_into().unwrap_or_else(|_| unreachable!()))\n }\n \n /// Approximate a bignum with an Fp. Rounds within 0.5 ULP with half-to-even.\n@@ -363,8 +352,7 @@ pub fn next_float<T: RawFloat>(x: T) -> T {\n         // too is exactly what we want!\n         // Finally, f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY.\n         Zero | Subnormal | Normal => {\n-            let bits: u64 = x.transmute();\n-            T::from_bits(bits + 1)\n+            T::from_bits(x.to_bits() + T::Bits::from(1u8))\n         }\n     }\n }"}, {"sha": "207df84d080f2856d5407a15181443f288b9a8c6", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a538fe7ce715c7bd27e2e05329c3d857b9ad92af", "patch": "@@ -145,6 +145,8 @@ pub mod consts {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n impl Float for f32 {\n+    type Bits = u32;\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool {\n@@ -176,7 +178,7 @@ impl Float for f32 {\n         const EXP_MASK: u32 = 0x7f800000;\n         const MAN_MASK: u32 = 0x007fffff;\n \n-        let bits: u32 = unsafe { mem::transmute(self) };\n+        let bits = self.to_bits();\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n             (0, 0) => Fp::Zero,\n             (_, 0) => Fp::Subnormal,\n@@ -220,12 +222,7 @@ impl Float for f32 {\n     fn is_sign_negative(self) -> bool {\n         // IEEE754 says: isSignMinus(x) is true if and only if x has negative sign. isSignMinus\n         // applies to zeros and NaNs as well.\n-        #[repr(C)]\n-        union F32Bytes {\n-            f: f32,\n-            b: u32\n-        }\n-        unsafe { F32Bytes { f: self }.b & 0x8000_0000 != 0 }\n+        self.to_bits() & 0x8000_0000 != 0\n     }\n \n     /// Returns the reciprocal (multiplicative inverse) of the number.\n@@ -279,4 +276,17 @@ impl Float for f32 {\n         // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n         (if other.is_nan() || self < other { self } else { other }) * 1.0\n     }\n+\n+    /// Raw transmutation to `u32`.\n+    #[inline]\n+    fn to_bits(self) -> u32 {\n+        unsafe { mem::transmute(self) }\n+    }\n+\n+    /// Raw transmutation from `u32`.\n+    #[inline]\n+    fn from_bits(v: u32) -> Self {\n+        // It turns out the safety issues with sNaN were overblown! Hooray!\n+        unsafe { mem::transmute(v) }\n+    }\n }"}, {"sha": "9206132e8b46ff8be695108e516e5986a16cd6a0", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a538fe7ce715c7bd27e2e05329c3d857b9ad92af", "patch": "@@ -145,6 +145,8 @@ pub mod consts {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n impl Float for f64 {\n+    type Bits = u64;\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool {\n@@ -176,7 +178,7 @@ impl Float for f64 {\n         const EXP_MASK: u64 = 0x7ff0000000000000;\n         const MAN_MASK: u64 = 0x000fffffffffffff;\n \n-        let bits: u64 = unsafe { mem::transmute(self) };\n+        let bits = self.to_bits();\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n             (0, 0) => Fp::Zero,\n             (_, 0) => Fp::Subnormal,\n@@ -218,12 +220,7 @@ impl Float for f64 {\n     /// negative sign bit and negative infinity.\n     #[inline]\n     fn is_sign_negative(self) -> bool {\n-        #[repr(C)]\n-        union F64Bytes {\n-            f: f64,\n-            b: u64\n-        }\n-        unsafe { F64Bytes { f: self }.b & 0x8000_0000_0000_0000 != 0 }\n+        self.to_bits() & 0x8000_0000_0000_0000 != 0\n     }\n \n     /// Returns the reciprocal (multiplicative inverse) of the number.\n@@ -277,4 +274,17 @@ impl Float for f64 {\n         // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n         (if other.is_nan() || self < other { self } else { other }) * 1.0\n     }\n+\n+    /// Raw transmutation to `u64`.\n+    #[inline]\n+    fn to_bits(self) -> u64 {\n+        unsafe { mem::transmute(self) }\n+    }\n+\n+    /// Raw transmutation from `u64`.\n+    #[inline]\n+    fn from_bits(v: u64) -> Self {\n+        // It turns out the safety issues with sNaN were overblown! Hooray!\n+        unsafe { mem::transmute(v) }\n+    }\n }"}, {"sha": "1fae88b9c7775aa341304aaf6ca67ccfb3c35e39", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a538fe7ce715c7bd27e2e05329c3d857b9ad92af", "patch": "@@ -2880,6 +2880,10 @@ pub enum FpCategory {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n pub trait Float: Sized {\n+    /// Type used by `to_bits` and `from_bits`.\n+    #[stable(feature = \"core_float_bits\", since = \"1.24.0\")]\n+    type Bits;\n+\n     /// Returns `true` if this value is NaN and false otherwise.\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_nan(self) -> bool;\n@@ -2941,6 +2945,13 @@ pub trait Float: Sized {\n     /// Returns the minimum of the two numbers.\n     #[stable(feature = \"core_float_min_max\", since=\"1.20.0\")]\n     fn min(self, other: Self) -> Self;\n+\n+    /// Raw transmutation to integer.\n+    #[stable(feature = \"core_float_bits\", since=\"1.24.0\")]\n+    fn to_bits(self) -> Self::Bits;\n+    /// Raw transmutation from integer.\n+    #[stable(feature = \"core_float_bits\", since=\"1.24.0\")]\n+    fn from_bits(v: Self::Bits) -> Self;\n }\n \n macro_rules! from_str_radix_int_impl {"}, {"sha": "9810dede61821e03c80c3405e7f32b2c28744146", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=a538fe7ce715c7bd27e2e05329c3d857b9ad92af", "patch": "@@ -1015,7 +1015,7 @@ impl f32 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn to_bits(self) -> u32 {\n-        unsafe { ::mem::transmute(self) }\n+        num::Float::to_bits(self)\n     }\n \n     /// Raw transmutation from `u32`.\n@@ -1059,8 +1059,7 @@ impl f32 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn from_bits(v: u32) -> Self {\n-        // It turns out the safety issues with sNaN were overblown! Hooray!\n-        unsafe { ::mem::transmute(v) }\n+        num::Float::from_bits(v)\n     }\n }\n "}, {"sha": "29ba7d0dac6350c0c03c899f6a978ab177ed2174", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a538fe7ce715c7bd27e2e05329c3d857b9ad92af/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=a538fe7ce715c7bd27e2e05329c3d857b9ad92af", "patch": "@@ -970,7 +970,7 @@ impl f64 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn to_bits(self) -> u64 {\n-        unsafe { ::mem::transmute(self) }\n+        num::Float::to_bits(self)\n     }\n \n     /// Raw transmutation from `u64`.\n@@ -1014,8 +1014,7 @@ impl f64 {\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n     pub fn from_bits(v: u64) -> Self {\n-        // It turns out the safety issues with sNaN were overblown! Hooray!\n-        unsafe { ::mem::transmute(v) }\n+        num::Float::from_bits(v)\n     }\n }\n "}]}