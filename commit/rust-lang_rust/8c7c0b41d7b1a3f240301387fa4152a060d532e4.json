{"sha": "8c7c0b41d7b1a3f240301387fa4152a060d532e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjN2MwYjQxZDdiMWEzZjI0MDMwMTM4N2ZhNDE1MmEwNjBkNTMyZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-10T03:16:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-10T03:16:02Z"}, "message": "auto merge of #9034 : catamorphism/rust/rustpkg-workcache, r=metajack\n\nr? @metajack or @brson - This pull request makes rustpkg use the workcache library to avoid recompilation.", "tree": {"sha": "da1d90f6d315261b32c84958ab80c14ac8b7c65a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da1d90f6d315261b32c84958ab80c14ac8b7c65a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c7c0b41d7b1a3f240301387fa4152a060d532e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7c0b41d7b1a3f240301387fa4152a060d532e4", "html_url": "https://github.com/rust-lang/rust/commit/8c7c0b41d7b1a3f240301387fa4152a060d532e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c7c0b41d7b1a3f240301387fa4152a060d532e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af259a651d52e7243c74a833b2b39a61890e89fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/af259a651d52e7243c74a833b2b39a61890e89fe", "html_url": "https://github.com/rust-lang/rust/commit/af259a651d52e7243c74a833b2b39a61890e89fe"}, {"sha": "a8194edef8c446d441a8bafba97a7bd961e63f10", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8194edef8c446d441a8bafba97a7bd961e63f10", "html_url": "https://github.com/rust-lang/rust/commit/a8194edef8c446d441a8bafba97a7bd961e63f10"}], "stats": {"total": 1330, "additions": 792, "deletions": 538}, "files": [{"sha": "bbb8dbfcbfe5378bad1ba379157259b7abdea46c", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 146, "deletions": 20, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -12,17 +12,15 @@\n \n use digest::Digest;\n use json;\n+use json::ToJson;\n use sha1::Sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n use arc::{Arc,RWArc};\n use treemap::TreeMap;\n-\n use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n use std::either::{Either, Left, Right};\n-use std::io;\n-use std::run;\n-use std::task;\n+use std::{io, os, task};\n \n /**\n *\n@@ -107,11 +105,27 @@ impl WorkKey {\n     }\n }\n \n+// FIXME #8883: The key should be a WorkKey and not a ~str.\n+// This is working around some JSON weirdness.\n+#[deriving(Clone, Eq, Encodable, Decodable)]\n+struct WorkMap(TreeMap<~str, KindMap>);\n+\n #[deriving(Clone, Eq, Encodable, Decodable)]\n-struct WorkMap(TreeMap<WorkKey, ~str>);\n+struct KindMap(TreeMap<~str, ~str>);\n \n impl WorkMap {\n     fn new() -> WorkMap { WorkMap(TreeMap::new()) }\n+\n+    fn insert_work_key(&mut self, k: WorkKey, val: ~str) {\n+        let WorkKey { kind, name } = k;\n+        match self.find_mut(&name) {\n+            Some(&KindMap(ref mut m)) => { m.insert(kind, val); return; }\n+            None => ()\n+        }\n+        let mut new_map = TreeMap::new();\n+        new_map.insert(kind, val);\n+        self.insert(name, KindMap(new_map));\n+    }\n }\n \n struct Database {\n@@ -123,11 +137,15 @@ struct Database {\n impl Database {\n \n     pub fn new(p: Path) -> Database {\n-        Database {\n+        let mut rslt = Database {\n             db_filename: p,\n             db_cache: TreeMap::new(),\n             db_dirty: false\n+        };\n+        if os::path_exists(&rslt.db_filename) {\n+            rslt.load();\n         }\n+        rslt\n     }\n \n     pub fn prepare(&self,\n@@ -154,6 +172,41 @@ impl Database {\n         self.db_cache.insert(k,v);\n         self.db_dirty = true\n     }\n+\n+    // FIXME #4330: This should have &mut self and should set self.db_dirty to false.\n+    fn save(&self) {\n+        let f = io::file_writer(&self.db_filename, [io::Create, io::Truncate]).unwrap();\n+        self.db_cache.to_json().to_pretty_writer(f);\n+    }\n+\n+    fn load(&mut self) {\n+        assert!(!self.db_dirty);\n+        assert!(os::path_exists(&self.db_filename));\n+        let f = io::file_reader(&self.db_filename);\n+        match f {\n+            Err(e) => fail!(\"Couldn't load workcache database %s: %s\",\n+                            self.db_filename.to_str(), e.to_str()),\n+            Ok(r) =>\n+                match json::from_reader(r) {\n+                    Err(e) => fail!(\"Couldn't parse workcache database (from file %s): %s\",\n+                                    self.db_filename.to_str(), e.to_str()),\n+                    Ok(r) => {\n+                        let mut decoder = json::Decoder(r);\n+                        self.db_cache = Decodable::decode(&mut decoder);\n+                    }\n+            }\n+        }\n+    }\n+}\n+\n+// FIXME #4330: use &mut self here\n+#[unsafe_destructor]\n+impl Drop for Database {\n+    fn drop(&self) {\n+        if self.db_dirty {\n+            self.save();\n+        }\n+    }\n }\n \n struct Logger {\n@@ -172,12 +225,20 @@ impl Logger {\n     }\n }\n \n+type FreshnessMap = TreeMap<~str,extern fn(&str,&str)->bool>;\n+\n #[deriving(Clone)]\n struct Context {\n     db: RWArc<Database>,\n     logger: RWArc<Logger>,\n     cfg: Arc<json::Object>,\n-    freshness: Arc<TreeMap<~str,extern fn(&str,&str)->bool>>\n+    /// Map from kinds (source, exe, url, etc.) to a freshness function.\n+    /// The freshness function takes a name (e.g. file path) and value\n+    /// (e.g. hash of file contents) and determines whether it's up-to-date.\n+    /// For example, in the file case, this would read the file off disk,\n+    /// hash it, and return the result of comparing the given hash and the\n+    /// read hash for equality.\n+    freshness: Arc<FreshnessMap>\n }\n \n struct Prep<'self> {\n@@ -205,6 +266,7 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n \n // FIXME(#5121)\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n+    debug!(\"json decoding: %s\", s);\n     do io::with_str_reader(s) |rdr| {\n         let j = json::from_reader(rdr).unwrap();\n         let mut decoder = json::Decoder(j);\n@@ -230,11 +292,18 @@ impl Context {\n     pub fn new(db: RWArc<Database>,\n                lg: RWArc<Logger>,\n                cfg: Arc<json::Object>) -> Context {\n+        Context::new_with_freshness(db, lg, cfg, Arc::new(TreeMap::new()))\n+    }\n+\n+    pub fn new_with_freshness(db: RWArc<Database>,\n+                              lg: RWArc<Logger>,\n+                              cfg: Arc<json::Object>,\n+                              freshness: Arc<FreshnessMap>) -> Context {\n         Context {\n             db: db,\n             logger: lg,\n             cfg: cfg,\n-            freshness: Arc::new(TreeMap::new())\n+            freshness: freshness\n         }\n     }\n \n@@ -249,6 +318,36 @@ impl Context {\n \n }\n \n+impl Exec {\n+    pub fn discover_input(&mut self,\n+                          dependency_kind: &str,\n+                          dependency_name: &str,\n+                          dependency_val: &str) {\n+        debug!(\"Discovering input %s %s %s\", dependency_kind, dependency_name, dependency_val);\n+        self.discovered_inputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n+                                 dependency_val.to_owned());\n+    }\n+    pub fn discover_output(&mut self,\n+                           dependency_kind: &str,\n+                           dependency_name: &str,\n+                           dependency_val: &str) {\n+        debug!(\"Discovering output %s %s %s\", dependency_kind, dependency_name, dependency_val);\n+        self.discovered_outputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n+                                 dependency_val.to_owned());\n+    }\n+\n+    // returns pairs of (kind, name)\n+    pub fn lookup_discovered_inputs(&self) -> ~[(~str, ~str)] {\n+        let mut rs = ~[];\n+        for (k, v) in self.discovered_inputs.iter() {\n+            for (k1, _) in v.iter() {\n+                rs.push((k1.clone(), k.clone()));\n+            }\n+        }\n+        rs\n+    }\n+}\n+\n impl<'self> Prep<'self> {\n     fn new(ctxt: &'self Context, fn_name: &'self str) -> Prep<'self> {\n         Prep {\n@@ -257,18 +356,30 @@ impl<'self> Prep<'self> {\n             declared_inputs: WorkMap::new()\n         }\n     }\n+\n+    pub fn lookup_declared_inputs(&self) -> ~[~str] {\n+        let mut rs = ~[];\n+        for (_, v) in self.declared_inputs.iter() {\n+            for (inp, _) in v.iter() {\n+                rs.push(inp.clone());\n+            }\n+        }\n+        rs\n+    }\n }\n \n impl<'self> Prep<'self> {\n-    fn declare_input(&mut self, kind:&str, name:&str, val:&str) {\n-        self.declared_inputs.insert(WorkKey::new(kind, name),\n+    pub fn declare_input(&mut self, kind: &str, name: &str, val: &str) {\n+        debug!(\"Declaring input %s %s %s\", kind, name, val);\n+        self.declared_inputs.insert_work_key(WorkKey::new(kind, name),\n                                  val.to_owned());\n     }\n \n     fn is_fresh(&self, cat: &str, kind: &str,\n                 name: &str, val: &str) -> bool {\n         let k = kind.to_owned();\n         let f = self.ctxt.freshness.get().find(&k);\n+        debug!(\"freshness for: %s/%s/%s/%s\", cat, kind, name, val)\n         let fresh = match f {\n             None => fail!(\"missing freshness-function for '%s'\", kind),\n             Some(f) => (*f)(name, val)\n@@ -286,27 +397,31 @@ impl<'self> Prep<'self> {\n     }\n \n     fn all_fresh(&self, cat: &str, map: &WorkMap) -> bool {\n-        for (k, v) in map.iter() {\n-            if ! self.is_fresh(cat, k.kind, k.name, *v) {\n-                return false;\n+        for (k_name, kindmap) in map.iter() {\n+            for (k_kind, v) in kindmap.iter() {\n+               if ! self.is_fresh(cat, *k_kind, *k_name, *v) {\n+                  return false;\n             }\n+          }\n         }\n         return true;\n     }\n \n-    fn exec<T:Send +\n+    pub fn exec<T:Send +\n         Encodable<json::Encoder> +\n         Decodable<json::Decoder>>(\n-            &'self self, blk: ~fn(&Exec) -> T) -> T {\n+            &'self self, blk: ~fn(&mut Exec) -> T) -> T {\n         self.exec_work(blk).unwrap()\n     }\n \n     fn exec_work<T:Send +\n         Encodable<json::Encoder> +\n         Decodable<json::Decoder>>( // FIXME(#5121)\n-            &'self self, blk: ~fn(&Exec) -> T) -> Work<'self, T> {\n+            &'self self, blk: ~fn(&mut Exec) -> T) -> Work<'self, T> {\n         let mut bo = Some(blk);\n \n+        debug!(\"exec_work: looking up %s and %?\", self.fn_name,\n+               self.declared_inputs);\n         let cached = do self.ctxt.db.read |db| {\n             db.prepare(self.fn_name, &self.declared_inputs)\n         };\n@@ -316,21 +431,26 @@ impl<'self> Prep<'self> {\n             if self.all_fresh(\"declared input\",&self.declared_inputs) &&\n                self.all_fresh(\"discovered input\", disc_in) &&\n                self.all_fresh(\"discovered output\", disc_out) => {\n+                debug!(\"Cache hit!\");\n+                debug!(\"Trying to decode: %? / %? / %?\",\n+                       disc_in, disc_out, *res);\n                 Left(json_decode(*res))\n             }\n \n             _ => {\n+                debug!(\"Cache miss!\");\n                 let (port, chan) = oneshot();\n                 let blk = bo.take_unwrap();\n                 let chan = Cell::new(chan);\n \n+// What happens if the task fails?\n                 do task::spawn {\n-                    let exe = Exec {\n+                    let mut exe = Exec {\n                         discovered_inputs: WorkMap::new(),\n                         discovered_outputs: WorkMap::new(),\n                     };\n                     let chan = chan.take();\n-                    let v = blk(&exe);\n+                    let v = blk(&mut exe);\n                     chan.send((exe, v));\n                 }\n                 Right(port)\n@@ -371,17 +491,23 @@ impl<'self, T:Send +\n }\n \n \n-//#[test]\n+#[test]\n fn test() {\n     use std::io::WriterUtil;\n+    use std::{os, run};\n \n     let pth = Path(\"foo.c\");\n     {\n         let r = io::file_writer(&pth, [io::Create]);\n         r.unwrap().write_str(\"int main() { return 0; }\");\n     }\n \n-    let cx = Context::new(RWArc::new(Database::new(Path(\"db.json\"))),\n+    let db_path = os::self_exe_path().expect(\"workcache::test failed\").pop().push(\"db.json\");\n+    if os::path_exists(&db_path) {\n+        os::remove_file(&db_path);\n+    }\n+\n+    let cx = Context::new(RWArc::new(Database::new(db_path)),\n                           RWArc::new(Logger::new()),\n                           Arc::new(TreeMap::new()));\n "}, {"sha": "4de2572be7d5e2ac6c0bac04197552e7c40baacd", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 82, "deletions": 52, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -13,75 +13,105 @@ use crate::*;\n use package_id::*;\n use package_source::*;\n use version::Version;\n+use workcache_support::*;\n \n-use std::os;\n-use std::hashmap::*;\n+use extra::arc::{Arc,RWArc};\n+use extra::workcache;\n+use extra::workcache::{Database, Logger, FreshnessMap};\n+use extra::treemap::TreeMap;\n \n /// Convenience functions intended for calling from pkg.rs\n+/// p is where to put the cache file for dependencies\n+pub fn default_context(p: Path) -> BuildContext {\n+    new_default_context(new_workcache_context(&p), p)\n+}\n \n-fn default_ctxt(p: @Path) -> Ctx {\n-    Ctx {\n-        use_rust_path_hack: false,\n-        sysroot_opt: Some(p),\n-        json: false,\n-        dep_cache: @mut HashMap::new()\n+pub fn new_default_context(c: workcache::Context, p: Path) -> BuildContext {\n+    BuildContext {\n+        context: Context {\n+            use_rust_path_hack: false,\n+            sysroot: p\n+        },\n+        workcache_context: c\n     }\n }\n \n-pub fn build_lib(sysroot: @Path, root: Path, name: ~str, version: Version,\n-                 lib: Path) {\n+fn file_is_fresh(path: &str, in_hash: &str) -> bool {\n+    in_hash == digest_file_with_date(&Path(path))\n+}\n \n-    let pkg_src = PkgSrc {\n-        root: root,\n-        id: PkgId{ version: version, ..PkgId::new(name)},\n-        libs: ~[mk_crate(lib)],\n-        mains: ~[],\n-        tests: ~[],\n-        benchs: ~[]\n-    };\n-    pkg_src.build(&default_ctxt(sysroot), ~[]);\n+fn binary_is_fresh(path: &str, in_hash: &str) -> bool {\n+    in_hash == digest_only_date(&Path(path))\n }\n \n-pub fn build_exe(sysroot: @Path, root: Path, name: ~str, version: Version, main: Path) {\n-    let pkg_src = PkgSrc {\n-        root: root,\n-        id: PkgId{ version: version, ..PkgId::new(name)},\n-        libs: ~[],\n-        mains: ~[mk_crate(main)],\n-        tests: ~[],\n-        benchs: ~[]\n-    };\n-    pkg_src.build(&default_ctxt(sysroot), ~[]);\n \n+pub fn new_workcache_context(p: &Path) -> workcache::Context {\n+    let db_file = p.push(\"rustpkg_db.json\"); // ??? probably wrong\n+    debug!(\"Workcache database file: %s\", db_file.to_str());\n+    let db = RWArc::new(Database::new(db_file));\n+    let lg = RWArc::new(Logger::new());\n+    let cfg = Arc::new(TreeMap::new());\n+    let mut freshness: FreshnessMap = TreeMap::new();\n+    // Set up freshness functions for every type of dependency rustpkg\n+    // knows about\n+    freshness.insert(~\"file\", file_is_fresh);\n+    freshness.insert(~\"binary\", binary_is_fresh);\n+    workcache::Context::new_with_freshness(db, lg, cfg, Arc::new(freshness))\n }\n \n-pub fn install_lib(sysroot: @Path,\n-                   workspace: Path,\n-                   name: ~str,\n-                   lib_path: Path,\n-                   version: Version) {\n-    debug!(\"self_exe: %?\", os::self_exe_path());\n-    debug!(\"sysroot = %s\", sysroot.to_str());\n-    debug!(\"workspace = %s\", workspace.to_str());\n-    // make a PkgSrc\n-    let pkg_id = PkgId{ version: version, ..PkgId::new(name)};\n-    let pkg_src = PkgSrc {\n-        root: workspace.clone(),\n-        id: pkg_id.clone(),\n-        libs: ~[mk_crate(lib_path)],\n-        mains: ~[],\n-        tests: ~[],\n-        benchs: ~[]\n+pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n+                 lib: Path) {\n+    let cx = default_context(sysroot);\n+    let subroot = root.clone();\n+    let subversion = version.clone();\n+    let sublib = lib.clone();\n+    do cx.workcache_context.with_prep(name) |prep| {\n+        let pkg_src = PkgSrc {\n+            workspace: subroot.clone(),\n+            start_dir: subroot.push(\"src\").push(name),\n+            id: PkgId{ version: subversion.clone(), ..PkgId::new(name)},\n+            libs: ~[mk_crate(sublib.clone())],\n+            mains: ~[],\n+            tests: ~[],\n+            benchs: ~[]\n+        };\n+        pkg_src.declare_inputs(prep);\n+        let subcx = cx.clone();\n+        let subsrc = pkg_src.clone();\n+        do prep.exec |exec| {\n+            subsrc.build(exec, &subcx.clone(), ~[]);\n+        }\n     };\n-    let cx = default_ctxt(sysroot);\n-    pkg_src.build(&cx, ~[]);\n-    cx.install_no_build(&workspace, &pkg_id);\n }\n \n-pub fn install_exe(sysroot: @Path, workspace: Path, name: ~str, version: Version) {\n-    default_ctxt(sysroot).install(&workspace, &PkgId{ version: version,\n-                                            ..PkgId::new(name)});\n+pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n+                 main: Path) {\n+    let cx = default_context(sysroot);\n+    let subroot = root.clone();\n+    let submain = main.clone();\n+    do cx.workcache_context.with_prep(name) |prep| {\n+        let pkg_src = PkgSrc {\n+            workspace: subroot.clone(),\n+            start_dir: subroot.push(\"src\").push(name),\n+            id: PkgId{ version: version.clone(), ..PkgId::new(name)},\n+            libs: ~[],\n+            mains: ~[mk_crate(submain.clone())],\n+            tests: ~[],\n+            benchs: ~[]\n+        };\n+        pkg_src.declare_inputs(prep);\n+        let subsrc = pkg_src.clone();\n+        let subcx = cx.clone();\n+        do prep.exec |exec| {\n+            subsrc.clone().build(exec, &subcx.clone(), ~[]);\n+        }\n+    }\n+}\n \n+pub fn install_pkg(sysroot: Path, workspace: Path, name: ~str, version: Version) {\n+    let cx = default_context(sysroot);\n+    let pkgid = PkgId{ version: version, ..PkgId::new(name)};\n+    cx.install(PkgSrc::new(workspace, false, pkgid));\n }\n \n fn mk_crate(p: Path) -> Crate {"}, {"sha": "2e049d252bcd792ceeafa223822bf54cea89ae4f", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -12,11 +12,17 @@\n \n pub use std::path::Path;\n pub use package_id::PkgId;\n+pub use std::libc;\n+pub use std::libc::stat;\n \n condition! {\n     pub bad_path: (Path, ~str) -> Path;\n }\n \n+condition! {\n+    pub bad_stat: (Path, ~str) -> stat;\n+}\n+\n condition! {\n     pub nonexistent_package: (PkgId, ~str) -> Path;\n }"}, {"sha": "2c6454cd2c664f6d812adc19d3dd9cf9ae4b17b9", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -10,56 +10,65 @@\n \n // Context data structure used by rustpkg\n \n-\n-use std::hashmap::HashMap;\n use std::os;\n+use extra::workcache;\n \n-pub struct Ctx {\n+#[deriving(Clone)]\n+pub struct Context {\n     // If use_rust_path_hack is true, rustpkg searches for sources\n     // in *package* directories that are in the RUST_PATH (for example,\n     // FOO/src/bar-0.1 instead of FOO). The flag doesn't affect where\n     // rustpkg stores build artifacts.\n     use_rust_path_hack: bool,\n-    // Sysroot -- if this is None, uses rustc filesearch's\n-    // idea of the default\n-    sysroot_opt: Option<@Path>,\n-    // I'm not sure what this is for\n-    json: bool,\n-    // Cache of hashes of things already installed\n-    // though I'm not sure why the value is a bool\n-    dep_cache: @mut HashMap<~str, bool>,\n+    // The root directory containing the Rust standard libraries\n+    sysroot: Path\n+}\n+\n+#[deriving(Clone)]\n+pub struct BuildContext {\n+    // Context for workcache\n+    workcache_context: workcache::Context,\n+    // Everything else\n+    context: Context\n+}\n+\n+impl BuildContext {\n+    pub fn sysroot(&self) -> Path {\n+        self.context.sysroot.clone()\n+    }\n+\n+    pub fn sysroot_to_use(&self) -> Path {\n+        self.context.sysroot_to_use()\n+    }\n }\n \n-impl Ctx {\n+impl Context {\n+    pub fn sysroot(&self) -> Path {\n+        self.sysroot.clone()\n+    }\n+}\n+\n+impl Context {\n     /// Debugging\n-    pub fn sysroot_opt_str(&self) -> ~str {\n-        match self.sysroot_opt {\n-            None => ~\"[none]\",\n-            Some(p) => p.to_str()\n-        }\n+    pub fn sysroot_str(&self) -> ~str {\n+        self.sysroot.to_str()\n     }\n \n     // Hack so that rustpkg can run either out of a rustc target dir,\n     // or the host dir\n-    pub fn sysroot_to_use(&self) -> Option<@Path> {\n-        if !in_target(self.sysroot_opt) {\n-            self.sysroot_opt\n-        }\n-        else {\n-            self.sysroot_opt.map(|p| { @p.pop().pop().pop() })\n+    pub fn sysroot_to_use(&self) -> Path {\n+        if !in_target(&self.sysroot) {\n+            self.sysroot.clone()\n+        } else {\n+            self.sysroot.pop().pop().pop()\n         }\n     }\n }\n \n /// We assume that if ../../rustc exists, then we're running\n /// rustpkg from a Rust target directory. This is part of a\n /// kludgy hack used to adjust the sysroot.\n-pub fn in_target(sysroot_opt: Option<@Path>) -> bool {\n-    match sysroot_opt {\n-        None => false,\n-        Some(p) => {\n-            debug!(\"Checking whether %s is in target\", p.to_str());\n-            os::path_is_dir(&p.pop().pop().push(\"rustc\"))\n-        }\n-    }\n+pub fn in_target(sysroot: &Path) -> bool {\n+    debug!(\"Checking whether %s is in target\", sysroot.to_str());\n+    os::path_is_dir(&sysroot.pop().pop().push(\"rustc\"))\n }"}, {"sha": "f0f3673f1d030abdc2fe482fdd1befcbc1dc3c00", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -51,12 +51,10 @@ impl PkgId {\n         // Did the user request a specific version?\n         let s = match split_version(s) {\n             Some((path, v)) => {\n-                debug!(\"s = %s, path = %s, v = %s\", s, path, v.to_str());\n                 given_version = Some(v);\n                 path\n             }\n             None => {\n-                debug!(\"%s has no explicit version\", s);\n                 s\n             }\n         };\n@@ -81,7 +79,6 @@ impl PkgId {\n             }\n         };\n \n-        debug!(\"path = %s\", path.to_str());\n         PkgId {\n             path: path.clone(),\n             short_name: short_name.to_owned(),"}, {"sha": "946707288c43deed901a4d5f269baeeda6f4c04b", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 154, "deletions": 97, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -18,80 +18,120 @@ use context::*;\n use crate::Crate;\n use messages::*;\n use source_control::{git_clone, git_clone_general};\n-use path_util::{pkgid_src_in_workspace, find_dir_using_rust_path_hack, default_workspace};\n+use path_util::{find_dir_using_rust_path_hack, default_workspace};\n use util::compile_crate;\n use workspace::is_workspace;\n+use workcache_support;\n+use extra::workcache;\n \n // An enumeration of the unpacked source of a package workspace.\n // This contains a list of files found in the source workspace.\n+#[deriving(Clone)]\n pub struct PkgSrc {\n-    root: Path, // root of where the package source code lives\n+    /// Root of where the package source code lives\n+    workspace: Path,\n+    // Directory to start looking in for packages -- normally\n+    // this is workspace/src/id but it may be just workspace\n+    start_dir: Path,\n     id: PkgId,\n     libs: ~[Crate],\n     mains: ~[Crate],\n     tests: ~[Crate],\n     benchs: ~[Crate],\n }\n \n+impl ToStr for PkgSrc {\n+    fn to_str(&self) -> ~str {\n+        fmt!(\"Package ID %s in start dir %s [workspace = %s]\",\n+             self.id.to_str(),\n+             self.start_dir.to_str(), self.workspace.to_str())\n+    }\n+}\n condition! {\n     // #6009: should this be pub or not, when #8215 is fixed?\n-    build_err: (~str) -> ();\n+    build_err: (~str) -> ~str;\n }\n \n impl PkgSrc {\n \n-    pub fn new(src_dir: &Path, id: &PkgId) -> PkgSrc {\n-        PkgSrc {\n-            root: (*src_dir).clone(),\n-            id: (*id).clone(),\n-            libs: ~[],\n-            mains: ~[],\n-            tests: ~[],\n-            benchs: ~[]\n-        }\n-    }\n-\n-\n-    fn check_dir(&self, cx: &Ctx) -> Path {\n+    pub fn new(workspace: Path, use_rust_path_hack: bool, id: PkgId) -> PkgSrc {\n         use conditions::nonexistent_package::cond;\n \n-        debug!(\"Pushing onto root: %s | %s\", self.id.path.to_str(), self.root.to_str());\n+        debug!(\"Checking package source for package ID %s, \\\n+               workspace = %s\", id.to_str(), workspace.to_str());\n+\n+        let mut to_try = ~[];\n+        if use_rust_path_hack {\n+            to_try.push(workspace.clone());\n+        } else {\n+            let result = workspace.push(\"src\").push_rel(&id.path.pop()).push(fmt!(\"%s-%s\",\n+                                                         id.short_name, id.version.to_str()));\n+            to_try.push(result);\n+            to_try.push(workspace.push(\"src\").push_rel(&id.path));\n+        }\n+\n+        debug!(\"Checking dirs: %?\", to_try.map(|s| s.to_str()).connect(\":\"));\n \n-        let dirs = pkgid_src_in_workspace(&self.id, &self.root);\n-        debug!(\"Checking dirs: %?\", dirs.map(|s| s.to_str()).connect(\":\"));\n-        let path = dirs.iter().find(|&d| os::path_exists(d));\n+        let path = to_try.iter().find(|&d| os::path_exists(d));\n \n-        let dir = match path {\n+        let dir: Path = match path {\n             Some(d) => (*d).clone(),\n             None => {\n-                match self.fetch_git() {\n+                let mut ok_d = None;\n+                for w in to_try.iter() {\n+                    debug!(\"Calling fetch_git on %s\", w.to_str());\n+                    let gf = PkgSrc::fetch_git(w, &id);\n+                    for p in gf.iter() {\n+                        ok_d = Some(p.clone());\n+                        break;\n+                    }\n+                    if ok_d.is_some() { break; }\n+                }\n+                match ok_d {\n                     Some(d) => d,\n                     None => {\n-                        match find_dir_using_rust_path_hack(cx, &self.id) {\n-                            Some(d) => d,\n-                            None => cond.raise((self.id.clone(),\n-                               ~\"supplied path for package dir does not \\\n-                                 exist, and couldn't interpret it as a URL fragment\"))\n+                        if use_rust_path_hack {\n+                            match find_dir_using_rust_path_hack(&id) {\n+                                Some(d) => d,\n+                                None => cond.raise((id.clone(),\n+                                    ~\"supplied path for package dir does not \\\n+                                     exist, and couldn't interpret it as a URL fragment\"))\n+                            }\n+                        }\n+                        else {\n+                            cond.raise((id.clone(),\n+                                        ~\"supplied path for package dir does not \\\n+                                        exist, and couldn't interpret it as a URL fragment\"))\n+\n                         }\n                     }\n                 }\n             }\n         };\n-        debug!(\"For package id %s, returning %s\", self.id.to_str(), dir.to_str());\n+        debug!(\"For package id %s, returning %s\", id.to_str(), dir.to_str());\n+\n         if !os::path_is_dir(&dir) {\n-            cond.raise((self.id.clone(), ~\"supplied path for package dir is a \\\n+            cond.raise((id.clone(), ~\"supplied path for package dir is a \\\n                                         non-directory\"));\n         }\n \n-        dir\n+        PkgSrc {\n+            workspace: workspace,\n+            start_dir: dir,\n+            id: id,\n+            libs: ~[],\n+            mains: ~[],\n+            tests: ~[],\n+            benchs: ~[]\n+        }\n     }\n \n     /// Try interpreting self's package id as a git repository, and try\n     /// fetching it and caching it in a local directory. Return the cached directory\n     /// if this was successful, None otherwise. Similarly, if the package id\n     /// refers to a git repo on the local version, also check it out.\n     /// (right now we only support git)\n-    pub fn fetch_git(&self) -> Option<Path> {\n+    pub fn fetch_git(local: &Path, pkgid: &PkgId) -> Option<Path> {\n         use conditions::failed_to_create_temp_dir::cond;\n \n         // We use a temporary directory because if the git clone fails,\n@@ -103,38 +143,35 @@ impl PkgSrc {\n             None    => cond.raise(~\"Failed to create temporary directory for fetching git sources\")\n         };\n \n-        let mut local = self.root.push(\"src\");\n-        local = local.push(self.id.to_str());\n-\n-        debug!(\"Checking whether %s exists locally. Cwd = %s, does it? %?\",\n-               self.id.path.to_str(),\n+        debug!(\"Checking whether %s (path = %s) exists locally. Cwd = %s, does it? %?\",\n+               pkgid.to_str(), pkgid.path.to_str(),\n                os::getcwd().to_str(),\n-               os::path_exists(&self.id.path));\n+               os::path_exists(&pkgid.path));\n \n-        if os::path_exists(&self.id.path) {\n+        if os::path_exists(&pkgid.path) {\n             debug!(\"%s exists locally! Cloning it into %s\",\n-                   self.id.path.to_str(), local.to_str());\n+                   pkgid.path.to_str(), local.to_str());\n             // Ok to use local here; we know it will succeed\n-            git_clone(&self.id.path, &local, &self.id.version);\n-            return Some(local);\n+            git_clone(&pkgid.path, local, &pkgid.version);\n+            return Some(local.clone());\n         }\n \n-        if self.id.path.components().len() < 2 {\n+        if pkgid.path.components().len() < 2 {\n             // If a non-URL, don't bother trying to fetch\n             return None;\n         }\n \n-        let url = fmt!(\"https://%s\", self.id.path.to_str());\n-        note(fmt!(\"Fetching package: git clone %s %s [version=%s]\",\n-                  url, clone_target.to_str(), self.id.version.to_str()));\n+        let url = fmt!(\"https://%s\", pkgid.path.to_str());\n+        debug!(\"Fetching package: git clone %s %s [version=%s]\",\n+                  url, clone_target.to_str(), pkgid.version.to_str());\n \n-        if git_clone_general(url, &clone_target, &self.id.version) {\n+        if git_clone_general(url, &clone_target, &pkgid.version) {\n             // since the operation succeeded, move clone_target to local\n-            if !os::rename_file(&clone_target, &local) {\n+            if !os::rename_file(&clone_target, local) {\n                  None\n             }\n             else {\n-                 Some(local)\n+                 Some(local.clone())\n             }\n         }\n         else {\n@@ -143,10 +180,11 @@ impl PkgSrc {\n     }\n \n \n-    // If a file named \"pkg.rs\" in the current directory exists,\n+    // If a file named \"pkg.rs\" in the start directory exists,\n     // return the path for it. Otherwise, None\n-    pub fn package_script_option(&self, cwd: &Path) -> Option<Path> {\n-        let maybe_path = cwd.push(\"pkg.rs\");\n+    pub fn package_script_option(&self) -> Option<Path> {\n+        let maybe_path = self.start_dir.push(\"pkg.rs\");\n+        debug!(\"package_script_option: checking whether %s exists\", maybe_path.to_str());\n         if os::path_exists(&maybe_path) {\n             Some(maybe_path)\n         }\n@@ -166,20 +204,18 @@ impl PkgSrc {\n         for c in p.components.slice(prefix, p.components.len()).iter() {\n             sub = sub.push(*c);\n         }\n-        debug!(\"found crate %s\", sub.to_str());\n+        debug!(\"Will compile crate %s\", sub.to_str());\n         cs.push(Crate::new(&sub));\n     }\n \n     /// Infers crates to build. Called only in the case where there\n     /// is no custom build logic\n-    pub fn find_crates(&mut self, cx: &Ctx) {\n+    pub fn find_crates(&mut self) {\n         use conditions::missing_pkg_files::cond;\n \n-        let dir = self.check_dir(cx);\n-        debug!(\"Called check_dir, I'm in %s\", dir.to_str());\n-        let prefix = dir.components.len();\n-        debug!(\"Matching against %?\", self.id.short_name);\n-        do os::walk_dir(&dir) |pth| {\n+        let prefix = self.start_dir.components.len();\n+        debug!(\"Matching against %s\", self.id.short_name);\n+        do os::walk_dir(&self.start_dir) |pth| {\n             let maybe_known_crate_set = match pth.filename() {\n                 Some(filename) => match filename {\n                     \"lib.rs\" => Some(&mut self.libs),\n@@ -207,76 +243,97 @@ impl PkgSrc {\n             cond.raise(self.id.clone());\n         }\n \n-        debug!(\"found %u libs, %u mains, %u tests, %u benchs\",\n+        debug!(\"In %s, found %u libs, %u mains, %u tests, %u benchs\",\n+               self.start_dir.to_str(),\n                self.libs.len(),\n                self.mains.len(),\n                self.tests.len(),\n                self.benchs.len())\n     }\n \n     fn build_crates(&self,\n-                    ctx: &Ctx,\n-                    src_dir: &Path,\n+                    ctx: &BuildContext,\n+                    exec: &mut workcache::Exec,\n                     destination_dir: &Path,\n                     crates: &[Crate],\n                     cfgs: &[~str],\n                     what: OutputType) {\n         for crate in crates.iter() {\n-            let path = &src_dir.push_rel(&crate.file).normalize();\n-            note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n-            note(fmt!(\"build_crates: using as workspace %s\", self.root.to_str()));\n-\n-            let result = compile_crate(ctx,\n-                                       &self.id,\n-                                       path,\n-                                       // compile_crate wants the destination workspace\n-                                       destination_dir,\n-                                       crate.flags,\n-                                       crate.cfgs + cfgs,\n-                                       false,\n-                                       what);\n-            if !result {\n-                build_err::cond.raise(fmt!(\"build failure on %s\",\n-                                           path.to_str()));\n+            let path = self.start_dir.push_rel(&crate.file).normalize();\n+            debug!(\"build_crates: compiling %s\", path.to_str());\n+            let path_str = path.to_str();\n+            let cfgs = crate.cfgs + cfgs;\n+\n+            let result =\n+                // compile_crate should return the path of the output artifact\n+                compile_crate(ctx,\n+                              exec,\n+                              &self.id,\n+                              &path,\n+                              destination_dir,\n+                              crate.flags,\n+                              cfgs,\n+                              false,\n+                              what).to_str();\n+            debug!(\"Result of compiling %s was %s\", path_str, result);\n+        }\n+    }\n+\n+    /// Declare all the crate files in the package source as inputs\n+    pub fn declare_inputs(&self, prep: &mut workcache::Prep) {\n+        let to_do = ~[self.libs.clone(), self.mains.clone(),\n+                      self.tests.clone(), self.benchs.clone()];\n+        for cs in to_do.iter() {\n+            for c in cs.iter() {\n+                let path = self.start_dir.push_rel(&c.file).normalize();\n+                debug!(\"Declaring input: %s\", path.to_str());\n+                prep.declare_input(\"file\",\n+                                   path.to_str(),\n+                                   workcache_support::digest_file_with_date(&path.clone()));\n             }\n-            debug!(\"Result of compiling %s was %?\",\n-                   path.to_str(), result);\n         }\n     }\n \n-    pub fn build(&self, ctx: &Ctx, cfgs: ~[~str]) -> Path {\n+    // It would be better if build returned a Path, but then Path would have to derive\n+    // Encodable.\n+    pub fn build(&self,\n+                 exec: &mut workcache::Exec,\n+                 build_context: &BuildContext,\n+                 cfgs: ~[~str]) -> ~str {\n         use conditions::not_a_workspace::cond;\n \n         // Determine the destination workspace (which depends on whether\n         // we're using the rust_path_hack)\n-        let destination_workspace = if is_workspace(&self.root) {\n-            debug!(\"%s is indeed a workspace\", self.root.to_str());\n-            self.root.clone()\n-        }\n-        else {\n+        let destination_workspace = if is_workspace(&self.workspace) {\n+            debug!(\"%s is indeed a workspace\", self.workspace.to_str());\n+            self.workspace.clone()\n+        } else {\n             // It would be nice to have only one place in the code that checks\n             // for the use_rust_path_hack flag...\n-            if ctx.use_rust_path_hack {\n+            if build_context.context.use_rust_path_hack {\n                 let rs = default_workspace();\n                 debug!(\"Using hack: %s\", rs.to_str());\n                 rs\n-            }\n-            else {\n+            } else {\n                 cond.raise(fmt!(\"Package root %s is not a workspace; pass in --rust_path_hack \\\n-                                if you want to treat it as a package source\", self.root.to_str()))\n+                                        if you want to treat it as a package source\",\n+                                self.workspace.to_str()))\n             }\n         };\n \n-        let dir = self.check_dir(ctx);\n-        debug!(\"Building libs in %s, destination = %s\", dir.to_str(),\n-            destination_workspace.to_str());\n-        self.build_crates(ctx, &dir, &destination_workspace, self.libs, cfgs, Lib);\n+        let libs = self.libs.clone();\n+        let mains = self.mains.clone();\n+        let tests = self.tests.clone();\n+        let benchs = self.benchs.clone();\n+        debug!(\"Building libs in %s, destination = %s\",\n+               destination_workspace.to_str(), destination_workspace.to_str());\n+        self.build_crates(build_context, exec, &destination_workspace, libs, cfgs, Lib);\n         debug!(\"Building mains\");\n-        self.build_crates(ctx, &dir, &destination_workspace, self.mains, cfgs, Main);\n+        self.build_crates(build_context, exec, &destination_workspace, mains, cfgs, Main);\n         debug!(\"Building tests\");\n-        self.build_crates(ctx, &dir, &destination_workspace, self.tests, cfgs, Test);\n+        self.build_crates(build_context, exec, &destination_workspace, tests, cfgs, Test);\n         debug!(\"Building benches\");\n-        self.build_crates(ctx, &dir, &destination_workspace, self.benchs, cfgs, Bench);\n-        destination_workspace\n+        self.build_crates(build_context, exec, &destination_workspace, benchs, cfgs, Bench);\n+        destination_workspace.to_str()\n     }\n }"}, {"sha": "1b732354f11b8c985e5272375b2bb64271480718", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -14,7 +14,6 @@ pub use package_id::PkgId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n pub use version::{Version, NoVersion, split_version_general, try_parsing_version};\n pub use rustc::metadata::filesearch::rust_path;\n-use context::Ctx;\n \n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::os::mkdir_recursive;\n@@ -62,21 +61,14 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n \n     let mut found = None;\n     do os::walk_dir(&src_dir) |p| {\n-        debug!(\"=> p = %s\", p.to_str());\n-\n         if os::path_is_dir(p) {\n-            debug!(\"p = %s, path = %s [%s]\", p.to_str(), pkgid.path.to_str(),\n-                   src_dir.push_rel(&pkgid.path).to_str());\n-\n             if *p == src_dir.push_rel(&pkgid.path) || {\n                 let pf = p.filename();\n                 do pf.iter().any |pf| {\n                     let g = pf.to_str();\n                     match split_version_general(g, '-') {\n                         None => false,\n                         Some((ref might_match, ref vers)) => {\n-                            debug!(\"might_match = %s, vers = %s\", *might_match,\n-                                   vers.to_str());\n                             *might_match == pkgid.short_name\n                                 && (pkgid.version == *vers || pkgid.version == NoVersion)\n                         }\n@@ -90,32 +82,14 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n         true\n     };\n \n-    debug!(if found.is_some() { fmt!(\"Found %s in %s\", pkgid.to_str(), workspace.to_str()) }\n-           else     { fmt!(\"Didn't find %s in %s\", pkgid.to_str(), workspace.to_str()) });\n+    if found.is_some() {\n+        debug!(\"Found %s in %s\", pkgid.to_str(), workspace.to_str());\n+    } else {\n+        debug!(\"Didn't find %s in %s\", pkgid.to_str(), workspace.to_str());\n+    }\n     found\n }\n \n-/// Returns a list of possible directories\n-/// for <pkgid>'s source files in <workspace>.\n-/// Doesn't check that any of them exist.\n-/// (for example, try both with and without the version)\n-pub fn pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> ~[Path] {\n-    let mut results = ~[];\n-    let result = workspace.push(\"src\").push(fmt!(\"%s-%s\",\n-                     pkgid.path.to_str(), pkgid.version.to_str()));\n-    results.push(result);\n-    results.push(workspace.push(\"src\").push_rel(&pkgid.path));\n-    results\n-}\n-\n-/// Returns a src for pkgid that does exist -- None if none of them do\n-pub fn first_pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-    let rs = pkgid_src_in_workspace(pkgid, workspace);\n-    do rs.iter().find |&p| {\n-        os::path_exists(p)\n-    }.map(|p| (**p).clone())\n-}\n-\n /// Figure out what the executable name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n@@ -402,10 +376,7 @@ fn dir_has_file(dir: &Path, file: &str) -> bool {\n     os::path_exists(&dir.push(file))\n }\n \n-pub fn find_dir_using_rust_path_hack(cx: &Ctx, p: &PkgId) -> Option<Path> {\n-    if !cx.use_rust_path_hack {\n-        return None;\n-    }\n+pub fn find_dir_using_rust_path_hack(p: &PkgId) -> Option<Path> {\n     let rp = rust_path();\n     for dir in rp.iter() {\n         debug!(\"In find_dir_using_rust_path_hack: checking dir %s\", dir.to_str());"}, {"sha": "331dfcd692a19d2682ac3e78e8c8d18824ff18fd", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 146, "deletions": 86, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -24,24 +24,26 @@ extern mod syntax;\n \n use std::{io, os, result, run, str};\n pub use std::path::Path;\n-use std::hashmap::HashMap;\n \n+use extra::workcache;\n+use extra::arc::RWArc;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use rustc::metadata::filesearch::rust_path;\n use extra::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n use messages::*;\n-use path_util::{build_pkg_id_in_workspace, first_pkgid_src_in_workspace};\n+use path_util::build_pkg_id_in_workspace;\n use path_util::{U_RWX, in_rust_path};\n use path_util::{built_executable_in_workspace, built_library_in_workspace, default_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n use source_control::is_git_dir;\n use workspace::{each_pkg_parent_workspace, pkg_parent_workspaces, cwd_to_workspace};\n-use context::Ctx;\n+use context::{BuildContext, Context};\n use package_id::PkgId;\n use package_source::PkgSrc;\n+use workcache_support::{discover_outputs, digest_only_date};\n \n pub mod api;\n mod conditions;\n@@ -59,6 +61,7 @@ mod target;\n mod tests;\n mod util;\n mod version;\n+pub mod workcache_support;\n mod workspace;\n \n pub mod usage;\n@@ -69,11 +72,8 @@ pub mod usage;\n struct PkgScript<'self> {\n     /// Uniquely identifies this package\n     id: &'self PkgId,\n-    // Used to have this field:    deps: ~[(~str, Option<~str>)]\n-    // but I think it shouldn't be stored here\n-    /// The contents of the package script: either a file path,\n-    /// or a string containing the text of the input\n-    input: driver::input,\n+    /// File path for the package script\n+    input: Path,\n     /// The session to use *only* for compiling the custom\n     /// build script\n     sess: session::Session,\n@@ -104,7 +104,7 @@ impl<'self> PkgScript<'self> {\n             crate_type: session::bin_crate,\n             .. (*session::basic_options()).clone()\n         };\n-        let input = driver::file_input(script);\n+        let input = driver::file_input(script.clone());\n         let sess = driver::build_session(options, diagnostic::emit);\n         let cfg = driver::build_configuration(sess);\n         let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n@@ -115,7 +115,7 @@ impl<'self> PkgScript<'self> {\n \n         PkgScript {\n             id: id,\n-            input: input,\n+            input: script,\n             sess: sess,\n             cfg: cfg,\n             crate: crate,\n@@ -127,22 +127,24 @@ impl<'self> PkgScript<'self> {\n     /// is the command to pass to it (e.g., \"build\", \"clean\", \"install\")\n     /// Returns a pair of an exit code and list of configs (obtained by\n     /// calling the package script's configs() function if it exists\n-    // FIXME (#4432): Use workcache to only compile the script when changed\n-    fn run_custom(&self, sysroot: @Path) -> (~[~str], ExitCode) {\n+    fn run_custom(&self, exec: &mut workcache::Exec, sysroot: &Path) -> (~[~str], ExitCode) {\n         let sess = self.sess;\n \n         debug!(\"Working directory = %s\", self.build_dir.to_str());\n         // Collect together any user-defined commands in the package script\n         let crate = util::ready_crate(sess, self.crate);\n         debug!(\"Building output filenames with script name %s\",\n-               driver::source_name(&self.input));\n+               driver::source_name(&driver::file_input(self.input.clone())));\n         let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n         util::compile_crate_from_input(&self.input,\n+                                       exec,\n                                        &self.build_dir,\n                                        sess,\n                                        crate);\n         debug!(\"Running program: %s %s %s\", exe.to_str(),\n                sysroot.to_str(), \"install\");\n+        // Discover the output\n+        exec.discover_output(\"binary\", exe.to_str(), digest_only_date(&exe));\n         // FIXME #7401 should support commands besides `install`\n         let status = run::process_status(exe.to_str(), [sysroot.to_str(), ~\"install\"]);\n         if status != 0 {\n@@ -162,47 +164,67 @@ impl<'self> PkgScript<'self> {\n     fn hash(&self) -> ~str {\n         self.id.hash()\n     }\n-\n }\n \n pub trait CtxMethods {\n     fn run(&self, cmd: &str, args: ~[~str]);\n     fn do_cmd(&self, _cmd: &str, _pkgname: &str);\n+    fn build_from_src(&self, pkg_src: PkgSrc);\n     /// Returns the destination workspace\n-    fn build(&self, workspace: &Path, pkgid: &PkgId) -> Path;\n+    fn build(&self, exec: &mut workcache::Exec, pkg_src: PkgSrc) -> Path;\n     fn clean(&self, workspace: &Path, id: &PkgId);\n     fn info(&self);\n-    fn install(&self, workspace: &Path, id: &PkgId);\n-    fn install_no_build(&self, workspace: &Path, id: &PkgId);\n+    /// Returns a pair. First component is a list of installed paths,\n+    /// second is a list of declared and discovered inputs\n+    fn install(&self, src: PkgSrc) -> (~[Path], ~[(~str, ~str)]);\n+    /// Returns a list of installed files\n+    fn install_no_build(&self, workspace: &Path, id: &PkgId) -> ~[Path];\n     fn prefer(&self, _id: &str, _vers: Option<~str>);\n     fn test(&self);\n     fn uninstall(&self, _id: &str, _vers: Option<~str>);\n     fn unprefer(&self, _id: &str, _vers: Option<~str>);\n }\n \n-impl CtxMethods for Ctx {\n+impl CtxMethods for BuildContext {\n+    fn build_from_src(&self, pkg_src: PkgSrc) {\n+        let tag = pkg_src.id.to_str();\n+        debug!(\"package source = %s\", pkg_src.to_str());\n+        do self.workcache_context.with_prep(tag) |prep| {\n+            let subsrc = pkg_src.clone();\n+            let subself = self.clone();\n+            declare_package_script_dependency(prep, &subsrc);\n+            pkg_src.declare_inputs(prep);\n+            do prep.exec |exec| {\n+                subself.build(exec, subsrc.clone());\n+            }\n+        }\n+    }\n \n     fn run(&self, cmd: &str, args: ~[~str]) {\n         match cmd {\n             \"build\" => {\n                 if args.len() < 1 {\n                     match cwd_to_workspace() {\n-                        None if self.use_rust_path_hack => {\n+                        None if self.context.use_rust_path_hack => {\n                             let cwd = os::getcwd();\n-                            self.build(&cwd, &PkgId::new(cwd.components[cwd.components.len() - 1]));\n+                            let pkgid = PkgId::new(cwd.components[cwd.components.len() - 1]);\n+                            self.build_from_src(PkgSrc::new(cwd, true, pkgid));\n                         }\n                         None => { usage::build(); return; }\n-                        Some((ws, pkgid)) => { self.build(&ws, &pkgid); }\n+                        Some((ws, pkgid)) => {\n+                            self.build_from_src(PkgSrc::new(ws, false, pkgid));\n+                        }\n                     }\n                 }\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n                     let pkgid = PkgId::new(args[0].clone());\n-                    do each_pkg_parent_workspace(self, &pkgid) |workspace| {\n+                    do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n                         debug!(\"found pkg %s in workspace %s, trying to build\",\n                                pkgid.to_str(), workspace.to_str());\n-                        self.build(workspace, &pkgid);\n+                        let pkg_src = PkgSrc::new(workspace.clone(), false, pkgid.clone());\n+                        self.build_from_src(pkg_src);\n                         true\n                     };\n                 }\n@@ -236,35 +258,40 @@ impl CtxMethods for Ctx {\n                 self.info();\n             }\n             \"install\" => {\n-                if args.len() < 1 {\n+               if args.len() < 1 {\n                     match cwd_to_workspace() {\n-                        None if self.use_rust_path_hack => {\n+                        None if self.context.use_rust_path_hack => {\n                             let cwd = os::getcwd();\n-                            self.install(&cwd,\n-                                &PkgId::new(cwd.components[cwd.components.len() - 1]));\n+                            let inferred_pkgid =\n+                                PkgId::new(cwd.components[cwd.components.len() - 1]);\n+                            self.install(PkgSrc::new(cwd, true, inferred_pkgid));\n                         }\n                         None  => { usage::install(); return; }\n-                        Some((ws, pkgid))                => self.install(&ws, &pkgid),\n-                     }\n+                        Some((ws, pkgid))                => {\n+                            let pkg_src = PkgSrc::new(ws, false, pkgid);\n+                            self.install(pkg_src);\n+                      }\n+                  }\n                 }\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n                     let pkgid = PkgId::new(args[0]);\n-                    let workspaces = pkg_parent_workspaces(self, &pkgid);\n+                    let workspaces = pkg_parent_workspaces(&self.context, &pkgid);\n                     debug!(\"package ID = %s, found it in %? workspaces\",\n                            pkgid.to_str(), workspaces.len());\n                     if workspaces.is_empty() {\n                         let rp = rust_path();\n                         assert!(!rp.is_empty());\n-                        let src = PkgSrc::new(&rp[0], &pkgid);\n-                        src.fetch_git();\n-                        self.install(&rp[0], &pkgid);\n+                        let src = PkgSrc::new(rp[0].clone(), false, pkgid.clone());\n+                        self.install(src);\n                     }\n                     else {\n-                        do each_pkg_parent_workspace(self, &pkgid) |workspace| {\n-                            self.install(workspace, &pkgid);\n-                            true\n+                        for workspace in workspaces.iter() {\n+                            let src = PkgSrc::new(workspace.clone(),\n+                                                  self.context.use_rust_path_hack,\n+                                                  pkgid.clone());\n+                            self.install(src);\n                         };\n                     }\n                 }\n@@ -299,7 +326,7 @@ impl CtxMethods for Ctx {\n                 else {\n                     let rp = rust_path();\n                     assert!(!rp.is_empty());\n-                    do each_pkg_parent_workspace(self, &pkgid) |workspace| {\n+                    do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n                         path_util::uninstall_package_from(workspace, &pkgid);\n                         note(fmt!(\"Uninstalled package %s (was installed in %s)\",\n                                   pkgid.to_str(), workspace.to_str()));\n@@ -325,44 +352,42 @@ impl CtxMethods for Ctx {\n \n     /// Returns the destination workspace\n     /// In the case of a custom build, we don't know, so we just return the source workspace\n-    fn build(&self, workspace: &Path, pkgid: &PkgId) -> Path {\n+    fn build(&self, exec: &mut workcache::Exec, mut pkg_src: PkgSrc) -> Path {\n+        let workspace = pkg_src.workspace.clone();\n+        let pkgid = pkg_src.id.clone();\n+\n         debug!(\"build: workspace = %s (in Rust path? %? is git dir? %? \\\n-                pkgid = %s\", workspace.to_str(),\n-               in_rust_path(workspace), is_git_dir(&workspace.push_rel(&pkgid.path)),\n-               pkgid.to_str());\n-        let src_dir   = first_pkgid_src_in_workspace(pkgid, workspace);\n+                pkgid = %s pkgsrc start_dir = %s\", workspace.to_str(),\n+               in_rust_path(&workspace), is_git_dir(&workspace.push_rel(&pkgid.path)),\n+               pkgid.to_str(), pkg_src.start_dir.to_str());\n \n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n-        debug!(\"%? %? %s\", in_rust_path(workspace),\n-               is_git_dir(&workspace.push_rel(&pkgid.path)),\n-               workspace.to_str());\n-        if !in_rust_path(workspace) && is_git_dir(&workspace.push_rel(&pkgid.path)) {\n+        if !in_rust_path(&workspace) && is_git_dir(&workspace.push_rel(&pkgid.path)) {\n             let out_dir = default_workspace().push(\"src\").push_rel(&pkgid.path);\n             source_control::git_clone(&workspace.push_rel(&pkgid.path),\n                                       &out_dir, &pkgid.version);\n             let default_ws = default_workspace();\n             debug!(\"Calling build recursively with %? and %?\", default_ws.to_str(),\n                    pkgid.to_str());\n-            return self.build(&default_ws, pkgid);\n+            return self.build(exec, PkgSrc::new(default_ws, false, pkgid.clone()));\n         }\n \n-        // Create the package source\n-        let mut src = PkgSrc::new(workspace, pkgid);\n-        debug!(\"Package src = %?\", src);\n-\n         // Is there custom build logic? If so, use it\n-        let pkg_src_dir = src_dir;\n         let mut custom = false;\n-        debug!(\"Package source directory = %?\", pkg_src_dir);\n-        let cfgs = match pkg_src_dir.chain_ref(|p| src.package_script_option(p)) {\n+        debug!(\"Package source directory = %s\", pkg_src.to_str());\n+        let opt = pkg_src.package_script_option();\n+        debug!(\"Calling pkg_script_option on %?\", opt);\n+        let cfgs = match pkg_src.package_script_option() {\n             Some(package_script_path) => {\n-                let sysroot = self.sysroot_to_use().expect(\"custom build needs a sysroot\");\n-                let pscript = PkgScript::parse(sysroot,\n-                                               package_script_path,\n-                                               workspace,\n-                                               pkgid);\n-                let (cfgs, hook_result) = pscript.run_custom(sysroot);\n+                let sysroot = self.sysroot_to_use();\n+                let (cfgs, hook_result) = {\n+                    let pscript = PkgScript::parse(@sysroot.clone(),\n+                                                   package_script_path.clone(),\n+                                                   &workspace.clone(),\n+                                                   &pkgid);\n+                    pscript.run_custom(exec, &sysroot)\n+                };\n                 debug!(\"Command return code = %?\", hook_result);\n                 if hook_result != 0 {\n                     fail!(\"Error running custom build command\")\n@@ -381,9 +406,10 @@ impl CtxMethods for Ctx {\n         // the build already. Otherwise...\n         if !custom {\n             // Find crates inside the workspace\n-            src.find_crates(self);\n+            pkg_src.find_crates();\n             // Build it!\n-            src.build(self, cfgs)\n+            let rs_path = pkg_src.build(exec, self, cfgs);\n+            Path(rs_path)\n         }\n         else {\n             // Just return the source workspace\n@@ -412,20 +438,44 @@ impl CtxMethods for Ctx {\n         fail!(\"info not yet implemented\");\n     }\n \n-    fn install(&self, workspace: &Path, id: &PkgId)  {\n-        // Also should use workcache to not build if not necessary.\n-        let destination_workspace = self.build(workspace, id);\n-        // See #7402: This still isn't quite right yet; we want to\n-        // install to the first workspace in the RUST_PATH if there's\n-        // a non-default RUST_PATH. This code installs to the same\n-        // workspace the package was built in.\n-        debug!(\"install: destination workspace = %s, id = %s\",\n-               destination_workspace.to_str(), id.to_str());\n-        self.install_no_build(&destination_workspace, id);\n-\n+    fn install(&self, pkg_src: PkgSrc) -> (~[Path], ~[(~str, ~str)]) {\n+\n+        let id = &pkg_src.id;\n+\n+        let installed_files = RWArc::new(~[]);\n+        let inputs = RWArc::new(~[]);\n+        // FIXME #7402: Use RUST_PATH to determine target dir\n+        self.workcache_context.with_prep(id.to_str(), |p| pkg_src.declare_inputs(p));\n+        do self.workcache_context.with_prep(id.to_str()) |prep| {\n+            let sub_inputs = inputs.clone();\n+            let sub_files  = installed_files.clone();\n+            let subsrc = pkg_src.clone();\n+            let subself = self.clone();\n+            let id_str = id.to_str();\n+            let sub_id = id.clone();\n+            sub_inputs.write(|r| *r = prep.lookup_declared_inputs().map(|v|\n+                                          { (~\"file\", (*v).clone()) }));\n+            do prep.exec |exec| {\n+                let destination_workspace = subself.build(exec, subsrc.clone()).to_str();\n+                // See #7402: This still isn't quite right yet; we want to\n+                // install to the first workspace in the RUST_PATH if there's\n+                // a non-default RUST_PATH. This code installs to the same\n+                // workspace the package was built in.\n+                debug!(\"install: destination workspace = %s, id = %s\",\n+                       destination_workspace, id_str);\n+                let result = subself.install_no_build(&Path(destination_workspace), &sub_id);\n+                debug!(\"install: id = %s, about to call discover_outputs, %?\",\n+                       id_str, result.to_str());\n+\n+                discover_outputs(exec, result.clone());\n+                sub_files.write(|r| { *r = result.clone(); });\n+                sub_inputs.write(|r| { *r = *r + exec.lookup_discovered_inputs() });\n+            }\n+        };\n+        (installed_files.unwrap(), inputs.unwrap())\n     }\n \n-    fn install_no_build(&self, workspace: &Path, id: &PkgId) {\n+    fn install_no_build(&self, workspace: &Path, id: &PkgId) -> ~[Path] {\n         use conditions::copy_failed::cond;\n \n         // Now copy stuff into the install dirs\n@@ -439,12 +489,15 @@ impl CtxMethods for Ctx {\n                target_exec.to_str(), target_lib,\n                maybe_executable, maybe_library);\n \n+        let mut outputs = ~[];\n+\n         for exec in maybe_executable.iter() {\n             debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n             if !(os::mkdir_recursive(&target_exec.dir_path(), U_RWX) &&\n                  os::copy_file(exec, &target_exec)) {\n                 cond.raise(((*exec).clone(), target_exec.clone()));\n             }\n+            outputs.push(target_exec.clone());\n         }\n         for lib in maybe_library.iter() {\n             let target_lib = target_lib.clone().expect(fmt!(\"I built %s but apparently \\\n@@ -455,7 +508,9 @@ impl CtxMethods for Ctx {\n                  os::copy_file(lib, &target_lib)) {\n                 cond.raise(((*lib).clone(), target_lib.clone()));\n             }\n+            outputs.push(target_lib.clone());\n         }\n+        outputs\n     }\n \n     fn prefer(&self, _id: &str, _vers: Option<~str>)  {\n@@ -476,7 +531,6 @@ impl CtxMethods for Ctx {\n     }\n }\n \n-\n pub fn main() {\n     io::println(\"WARNING: The Rust package manager is experimental and may be unstable\");\n     let args = os::args();\n@@ -485,7 +539,6 @@ pub fn main() {\n \n pub fn main_args(args: &[~str]) {\n     let opts = ~[getopts::optflag(\"h\"), getopts::optflag(\"help\"),\n-                 getopts::optflag(\"j\"), getopts::optflag(\"json\"),\n                  getopts::optmulti(\"c\"), getopts::optmulti(\"cfg\"),\n                  getopts::optflag(\"v\"), getopts::optflag(\"version\"),\n                  getopts::optflag(\"r\"), getopts::optflag(\"rust-path-hack\")];\n@@ -499,8 +552,6 @@ pub fn main_args(args: &[~str]) {\n     };\n     let help = getopts::opt_present(matches, \"h\") ||\n                getopts::opt_present(matches, \"help\");\n-    let json = getopts::opt_present(matches, \"j\") ||\n-               getopts::opt_present(matches, \"json\");\n \n     if getopts::opt_present(matches, \"v\") ||\n        getopts::opt_present(matches, \"version\") {\n@@ -512,7 +563,6 @@ pub fn main_args(args: &[~str]) {\n                              getopts::opt_present(matches, \"rust-path-hack\");\n \n     let mut args = matches.free.clone();\n-\n     args.shift();\n \n     if (args.len() < 1) {\n@@ -553,13 +603,15 @@ pub fn main_args(args: &[~str]) {\n     // I had to add this type annotation to get the code to typecheck\n     let mut remaining_args: ~[~str] = remaining_args.map(|s| (*s).clone()).collect();\n     remaining_args.shift();\n-    let sroot = Some(@filesearch::get_or_default_sysroot());\n-    debug!(\"Using sysroot: %?\", sroot);\n-    Ctx {\n-        use_rust_path_hack: use_rust_path_hack,\n-        sysroot_opt: sroot, // Currently, only tests override this\n-        json: json,\n-        dep_cache: @mut HashMap::new()\n+    let sroot = filesearch::get_or_default_sysroot();\n+    debug!(\"Using sysroot: %s\", sroot.to_str());\n+    debug!(\"Will store workcache in %s\", default_workspace().to_str());\n+    BuildContext {\n+        context: Context {\n+            use_rust_path_hack: use_rust_path_hack,\n+            sysroot: sroot, // Currently, only tests override this\n+         },\n+        workcache_context: api::default_context(default_workspace()).workcache_context\n     }.run(*cmd, remaining_args)\n }\n \n@@ -581,3 +633,11 @@ pub fn work_dir() -> Path {\n pub fn src_dir() -> Path {\n     os::getcwd()\n }\n+\n+fn declare_package_script_dependency(prep: &mut workcache::Prep, pkg_src: &PkgSrc) {\n+    match pkg_src.package_script_option() {\n+        Some(ref p) => prep.declare_input(\"file\", p.to_str(),\n+                                      workcache_support::digest_file_with_date(p)),\n+        None => ()\n+    }\n+}"}, {"sha": "e5e2a0dbd714f2a5e08727cb95944c648b484271", "filename": "src/librustpkg/search.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsearch.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -11,16 +11,6 @@\n use path_util::{installed_library_in_workspace, rust_path};\n use version::Version;\n \n-/// If a library with path `p` matching pkg_id's name exists under sroot_opt,\n-/// return Some(p). Return None if there's no such path or if sroot_opt is None.\n-pub fn find_library_in_search_path(sroot_opt: Option<@Path>, short_name: &str) -> Option<Path> {\n-    do sroot_opt.chain |sroot| {\n-        debug!(\"Will search for a library with short name %s in \\\n-                %s\", short_name, (sroot.push(\"lib\")).to_str());\n-        installed_library_in_workspace(short_name, sroot)\n-    }\n-}\n-\n /// If some workspace `p` in the RUST_PATH contains a package matching short_name,\n /// return Some(p) (returns the first one of there are multiple matches.) Return\n /// None if there's no such path."}, {"sha": "f4016d26a150e4576e2b329a6668ca653f0e3c03", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -10,10 +10,14 @@\n \n // rustpkg unit tests\n \n-use context::Ctx;\n-use std::hashmap::HashMap;\n-use std::{io, libc, os, run, str};\n+use context::{BuildContext, Context};\n+use std::{io, libc, os, run, str, task};\n+use extra::arc::Arc;\n+use extra::arc::RWArc;\n use extra::tempfile::mkdtemp;\n+use extra::workcache;\n+use extra::workcache::{Database, Logger};\n+use extra::treemap::TreeMap;\n use std::run::ProcessOutput;\n use installed_packages::list_installed_packages;\n use package_id::{PkgId};\n@@ -26,18 +30,24 @@ use path_util::{target_executable_in_workspace, target_test_in_workspace,\n use rustc::metadata::filesearch::rust_path;\n use rustc::driver::driver::host_triple;\n use target::*;\n+use package_source::PkgSrc;\n \n /// Returns the last-modified date as an Option\n fn datestamp(p: &Path) -> Option<libc::time_t> {\n     p.stat().map(|stat| stat.st_mtime)\n }\n \n-fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n-    Ctx {\n-        use_rust_path_hack: false,\n-        sysroot_opt: sysroot_opt,\n-        json: false,\n-        dep_cache: @mut HashMap::new()\n+fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n+    let context = workcache::Context::new(\n+        RWArc::new(Database::new(workspace.push(\"rustpkg_db.json\"))),\n+        RWArc::new(Logger::new()),\n+        Arc::new(TreeMap::new()));\n+    BuildContext {\n+        workcache_context: context,\n+        context: Context {\n+            use_rust_path_hack: false,\n+            sysroot: sysroot\n+        }\n     }\n }\n \n@@ -388,7 +398,7 @@ fn lib_output_file_name(workspace: &Path, parent: &str, short_name: &str) -> Pat\n }\n \n fn output_file_name(workspace: &Path, short_name: &str) -> Path {\n-    workspace.push(fmt!(\"%s%s\", short_name, os::EXE_SUFFIX))\n+    workspace.push(\"build\").push(short_name).push(fmt!(\"%s%s\", short_name, os::EXE_SUFFIX))\n }\n \n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n@@ -401,12 +411,11 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n             if run::process_output(\"touch\", [p.to_str()]).status != 0 {\n                 let _ = cond.raise((pkg_src_dir.clone(), ~\"Bad path\"));\n             }\n-            break;\n         }\n     }\n }\n \n-/// Add a blank line at the end\n+/// Add a comment at the end\n fn frob_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.push(\"src\").push(pkgid.to_str());\n@@ -423,7 +432,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId) {\n             let w = io::file_writer(p, &[io::Append]);\n             match w {\n                 Err(s) => { let _ = cond.raise((p.clone(), fmt!(\"Bad path: %s\", s))); }\n-                Ok(w)  => w.write_line(\"\")\n+                Ok(w)  => w.write_line(\"/* hi */\")\n             }\n         }\n         None => fail!(fmt!(\"frob_source_file failed to find a source file in %s\",\n@@ -450,12 +459,13 @@ fn test_install_valid() {\n \n     let sysroot = test_sysroot();\n     debug!(\"sysroot = %s\", sysroot.to_str());\n-    let ctxt = fake_ctxt(Some(@sysroot));\n     let temp_pkg_id = fake_pkg();\n     let temp_workspace = mk_temp_workspace(&temp_pkg_id.path, &NoVersion).pop().pop();\n+    let ctxt = fake_ctxt(sysroot, &temp_workspace);\n     debug!(\"temp_workspace = %s\", temp_workspace.to_str());\n     // should have test, bench, lib, and main\n-    ctxt.install(&temp_workspace, &temp_pkg_id);\n+    let src = PkgSrc::new(temp_workspace.clone(), false, temp_pkg_id.clone());\n+    ctxt.install(src);\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, &temp_workspace);\n     debug!(\"exec = %s\", exec.to_str());\n@@ -476,32 +486,19 @@ fn test_install_valid() {\n \n #[test]\n fn test_install_invalid() {\n-    use conditions::nonexistent_package::cond;\n-    use cond1 = conditions::missing_pkg_files::cond;\n-    use cond2 = conditions::not_a_workspace::cond;\n-\n-    let ctxt = fake_ctxt(None);\n+    let sysroot = test_sysroot();\n     let pkgid = fake_pkg();\n     let temp_workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n-    let mut error_occurred = false;\n-    let mut error1_occurred = false;\n-    let mut error2_occurred = false;\n-    do cond1.trap(|_| {\n-        error1_occurred = true;\n-    }).inside {\n-        do cond.trap(|_| {\n-            error_occurred = true;\n-            temp_workspace.clone()\n-        }).inside {\n-            do cond2.trap(|_| {\n-               error2_occurred = true;\n-               temp_workspace.clone()\n-            }).inside {\n-                 ctxt.install(&temp_workspace, &pkgid);\n-            }\n-        }\n-    }\n-    assert!(error_occurred && error1_occurred && error2_occurred);\n+    let ctxt = fake_ctxt(sysroot, &temp_workspace);\n+\n+    // Uses task::try because of #9001\n+    let result = do task::try {\n+        let pkg_src = PkgSrc::new(temp_workspace.clone(), false, pkgid.clone());\n+        ctxt.install(pkg_src);\n+    };\n+    // Not the best test -- doesn't test that we failed in the right way.\n+    // Best we can do for now.\n+    assert!(result == Err(()));\n }\n \n // Tests above should (maybe) be converted to shell out to rustpkg, too\n@@ -898,7 +895,6 @@ fn install_check_duplicates() {\n }\n \n #[test]\n-#[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n fn no_rebuilding() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n@@ -912,24 +908,28 @@ fn no_rebuilding() {\n }\n \n #[test]\n-#[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n fn no_rebuilding_dep() {\n     let p_id = PkgId::new(\"foo\");\n     let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n-    let bar_date = datestamp(&lib_output_file_name(&workspace,\n+    let bar_date_1 = datestamp(&lib_output_file_name(&workspace,\n+                                                  \".rust\",\n+                                                  \"bar\"));\n+    let foo_date_1 = datestamp(&output_file_name(&workspace, \"foo\"));\n+\n+    frob_source_file(&workspace, &p_id);\n+    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    let bar_date_2 = datestamp(&lib_output_file_name(&workspace,\n                                                   \".rust\",\n                                                   \"bar\"));\n-    let foo_date = datestamp(&output_file_name(&workspace, \"foo\"));\n-    assert!(bar_date < foo_date);\n+    let foo_date_2 = datestamp(&output_file_name(&workspace, \"foo\"));\n+    assert_eq!(bar_date_1, bar_date_2);\n+    assert!(foo_date_1 < foo_date_2);\n+    assert!(foo_date_1 > bar_date_1);\n }\n \n-// n.b. The following two tests are ignored; they worked \"accidentally\" before,\n-// when the behavior was \"always rebuild libraries\" (now it's \"never rebuild\n-// libraries if they already exist\"). They can be un-ignored once #7075 is done.\n #[test]\n-#[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n fn do_rebuild_dep_dates_change() {\n     let p_id = PkgId::new(\"foo\");\n     let dep_id = PkgId::new(\"bar\");\n@@ -946,7 +946,6 @@ fn do_rebuild_dep_dates_change() {\n }\n \n #[test]\n-#[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n fn do_rebuild_dep_only_contents_change() {\n     let p_id = PkgId::new(\"foo\");\n     let dep_id = PkgId::new(\"bar\");"}, {"sha": "5e9fc6655a8ec4edcb1d3a31df59128821e3fbfc", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 87, "deletions": 64, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::os;\n+use extra::workcache;\n use rustc::driver::{driver, session};\n use extra::getopts::groups::getopts;\n use syntax::ast_util::*;\n@@ -18,12 +19,13 @@ use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::attr::AttrMetaMethods;\n use rustc::back::link::output_type_exe;\n use rustc::driver::session::{lib_crate, bin_crate};\n-use context::{Ctx, in_target};\n+use context::{in_target, BuildContext};\n use package_id::PkgId;\n-use search::{find_library_in_search_path, find_installed_library_in_rust_path};\n-use path_util::{target_library_in_workspace, U_RWX};\n+use package_source::PkgSrc;\n+use path_util::{installed_library_in_workspace, U_RWX};\n+\n pub use target::{OutputType, Main, Lib, Bench, Test};\n-use version::NoVersion;\n+use workcache_support::{digest_file_with_date, digest_only_date};\n \n // It would be nice to have the list of commands in just one place -- for example,\n // you could update the match in rustpkg.rc but forget to update this list. I think\n@@ -151,16 +153,15 @@ pub fn ready_crate(sess: session::Session,\n     @fold.fold_crate(crate)\n }\n \n-// FIXME (#4432): Use workcache to only compile when needed\n-pub fn compile_input(ctxt: &Ctx,\n+pub fn compile_input(ctxt: &BuildContext,\n+                     exec: &mut workcache::Exec,\n                      pkg_id: &PkgId,\n                      in_file: &Path,\n                      workspace: &Path,\n                      flags: &[~str],\n                      cfgs: &[~str],\n                      opt: bool,\n-                     what: OutputType) -> bool {\n-\n+                     what: OutputType) -> Path {\n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input((*in_file).clone());\n     debug!(\"compile_input: %s / %?\", in_file.to_str(), what);\n@@ -173,7 +174,7 @@ pub fn compile_input(ctxt: &Ctx,\n \n     debug!(\"flags: %s\", flags.connect(\" \"));\n     debug!(\"cfgs: %s\", cfgs.connect(\" \"));\n-    debug!(\"out_dir = %s\", out_dir.to_str());\n+    debug!(\"compile_input's sysroot = %s\", ctxt.sysroot().to_str());\n \n     let crate_type = match what {\n         Lib => lib_crate,\n@@ -191,19 +192,19 @@ pub fn compile_input(ctxt: &Ctx,\n                           driver::optgroups()).unwrap();\n     // Hack so that rustpkg can run either out of a rustc target dir,\n     // or the host dir\n-    let sysroot_to_use = if !in_target(ctxt.sysroot_opt) {\n-        ctxt.sysroot_opt\n+    let sysroot_to_use = @if !in_target(&ctxt.sysroot()) {\n+        ctxt.sysroot()\n     }\n     else {\n-        ctxt.sysroot_opt.map(|p| { @p.pop().pop().pop() })\n+        ctxt.sysroot().pop().pop().pop()\n     };\n-    debug!(\"compile_input's sysroot = %?\", ctxt.sysroot_opt_str());\n-    debug!(\"sysroot_to_use = %?\", sysroot_to_use);\n+    debug!(\"compile_input's sysroot = %s\", ctxt.sysroot().to_str());\n+    debug!(\"sysroot_to_use = %s\", sysroot_to_use.to_str());\n     let options = @session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: what == Test || what == Bench,\n-        maybe_sysroot: sysroot_to_use,\n+        maybe_sysroot: Some(sysroot_to_use),\n         addl_lib_search_paths: @mut (~[out_dir.clone()]),\n         // output_type should be conditional\n         output_type: output_type_exe, // Use this to get a library? That's weird\n@@ -228,11 +229,11 @@ pub fn compile_input(ctxt: &Ctx,\n     // `extern mod` directives.\n     let cfg = driver::build_configuration(sess);\n     let mut crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-    crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n+    crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n \n     // Not really right. Should search other workspaces too, and the installed\n     // database (which doesn't exist yet)\n-    find_and_install_dependencies(ctxt, sess, workspace, crate,\n+    find_and_install_dependencies(ctxt, sess, exec, workspace, crate,\n                                   |p| {\n                                       debug!(\"a dependency: %s\", p.to_str());\n                                       // Pass the directory containing a dependency\n@@ -269,26 +270,27 @@ pub fn compile_input(ctxt: &Ctx,\n \n     debug!(\"calling compile_crate_from_input, workspace = %s,\n            building_library = %?\", out_dir.to_str(), sess.building_library);\n-    compile_crate_from_input(&input, &out_dir, sess, crate);\n-    true\n+    compile_crate_from_input(in_file, exec, &out_dir, sess, crate)\n }\n \n // Should use workcache to avoid recompiling when not necessary\n // Should also rename this to something better\n // If crate_opt is present, then finish compilation. If it's None, then\n // call compile_upto and return the crate\n // also, too many arguments\n-pub fn compile_crate_from_input(input: &driver::input,\n+pub fn compile_crate_from_input(input: &Path,\n+                                exec: &mut workcache::Exec,\n  // should be of the form <workspace>/build/<pkg id's path>\n                                 out_dir: &Path,\n                                 sess: session::Session,\n-                                crate: @ast::Crate) {\n+                                crate: @ast::Crate) -> Path {\n     debug!(\"Calling build_output_filenames with %s, building library? %?\",\n            out_dir.to_str(), sess.building_library);\n \n     // bad copy\n     debug!(\"out_dir = %s\", out_dir.to_str());\n-    let outputs = driver::build_output_filenames(input, &Some(out_dir.clone()), &None,\n+    let outputs = driver::build_output_filenames(&driver::file_input(input.clone()),\n+                                                 &Some(out_dir.clone()), &None,\n                                                  crate.attrs, sess);\n \n     debug!(\"Outputs are out_filename: %s and obj_filename: %s and output type = %?\",\n@@ -304,8 +306,13 @@ pub fn compile_crate_from_input(input: &driver::input,\n                                                         &analysis,\n                                                         outputs);\n     driver::phase_5_run_llvm_passes(sess, &translation, outputs);\n-    if driver::stop_after_phase_5(sess) { return; }\n+    if driver::stop_after_phase_5(sess) { return outputs.out_filename; }\n     driver::phase_6_link_output(sess, &translation, outputs);\n+\n+    // Register dependency on the source file\n+    exec.discover_input(\"file\", input.to_str(), digest_file_with_date(input));\n+\n+    outputs.out_filename\n }\n \n #[cfg(windows)]\n@@ -318,76 +325,92 @@ pub fn exe_suffix() -> ~str { ~\".exe\" }\n pub fn exe_suffix() -> ~str { ~\"\" }\n \n // Called by build_crates\n-// FIXME (#4432): Use workcache to only compile when needed\n-pub fn compile_crate(ctxt: &Ctx, pkg_id: &PkgId,\n+pub fn compile_crate(ctxt: &BuildContext,\n+                     exec: &mut workcache::Exec,\n+                     pkg_id: &PkgId,\n                      crate: &Path, workspace: &Path,\n                      flags: &[~str], cfgs: &[~str], opt: bool,\n-                     what: OutputType) -> bool {\n+                     what: OutputType) -> Path {\n     debug!(\"compile_crate: crate=%s, workspace=%s\", crate.to_str(), workspace.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n     for fl in flags.iter() {\n         debug!(\"+++ %s\", *fl);\n     }\n-    compile_input(ctxt, pkg_id, crate, workspace, flags, cfgs, opt, what)\n+    compile_input(ctxt, exec, pkg_id, crate, workspace, flags, cfgs, opt, what)\n }\n \n \n /// Collect all `extern mod` directives in `c`, then\n /// try to install their targets, failing if any target\n /// can't be found.\n-pub fn find_and_install_dependencies(ctxt: &Ctx,\n+pub fn find_and_install_dependencies(ctxt: &BuildContext,\n                                  sess: session::Session,\n+                                 exec: &mut workcache::Exec,\n                                  workspace: &Path,\n                                  c: &ast::Crate,\n                                  save: @fn(Path)\n                                 ) {\n-    // :-(\n-    debug!(\"In find_and_install_dependencies...\");\n-    let my_workspace = (*workspace).clone();\n-    let my_ctxt      = *ctxt;\n-    do c.each_view_item() |vi: &ast::view_item| {\n+    debug!(\"Finding and installing dependencies...\");\n+    do c.each_view_item |vi| {\n         debug!(\"A view item!\");\n         match vi.node {\n             // ignore metadata, I guess\n             ast::view_item_extern_mod(lib_ident, path_opt, _, _) => {\n-                match my_ctxt.sysroot_opt {\n-                    Some(ref x) => debug!(\"*** sysroot: %s\", x.to_str()),\n-                    None => debug!(\"No sysroot given\")\n+                let lib_name = match path_opt {\n+                    Some(p) => p,\n+                    None => sess.str_of(lib_ident)\n                 };\n-                let lib_name = match path_opt { // ???\n-                    Some(p) => p, None => sess.str_of(lib_ident) };\n-                match find_library_in_search_path(my_ctxt.sysroot_opt, lib_name) {\n-                    Some(installed_path) => {\n+                match installed_library_in_workspace(lib_name, &ctxt.sysroot()) {\n+                    Some(ref installed_path) => {\n                         debug!(\"It exists: %s\", installed_path.to_str());\n+                        // Say that [path for c] has a discovered dependency on\n+                        // installed_path\n+                        // For binary files, we only hash the datestamp, not the contents.\n+                        // I'm not sure what the right thing is.\n+                        // Now we know that this crate has a discovered dependency on\n+                        // installed_path\n+                        exec.discover_input(\"binary\", installed_path.to_str(),\n+                                                      digest_only_date(installed_path));\n                     }\n                     None => {\n                         // FIXME #8711: need to parse version out of path_opt\n-                        match find_installed_library_in_rust_path(lib_name, &NoVersion) {\n-                            Some(installed_path) => {\n-                               debug!(\"Found library %s, not rebuilding it\",\n-                                      installed_path.to_str());\n-                               // Once workcache is implemented, we'll actually check\n-                               // whether or not the library at installed_path is fresh\n-                               save(installed_path.pop());\n+                        debug!(\"Trying to install library %s, rebuilding it\",\n+                               lib_name.to_str());\n+                        // Try to install it\n+                        let pkg_id = PkgId::new(lib_name);\n+                        let (outputs_disc, inputs_disc) =\n+                            ctxt.install(PkgSrc::new(workspace.clone(), false, pkg_id));\n+                        debug!(\"Installed %s, returned %? dependencies and \\\n+                               %? transitive dependencies\",\n+                               lib_name, outputs_disc.len(), inputs_disc.len());\n+                        for dep in outputs_disc.iter() {\n+                            debug!(\"Discovering a binary input: %s\", dep.to_str());\n+                            exec.discover_input(\"binary\", dep.to_str(),\n+                                                digest_only_date(dep));\n+                        }\n+                        for &(ref what, ref dep) in inputs_disc.iter() {\n+                            if *what == ~\"file\" {\n+                                exec.discover_input(*what, *dep,\n+                                                    digest_file_with_date(&Path(*dep)));\n+                            }\n+                            else if *what == ~\"binary\" {\n+                                exec.discover_input(*what, *dep,\n+                                                    digest_only_date(&Path(*dep)));\n+                            }\n+                            else {\n+                                fail!(\"Bad kind: %s\", *what);\n                             }\n-                            None => {\n-                               debug!(\"Trying to install library %s, rebuilding it\",\n-                                      lib_name.to_str());\n-                               // Try to install it\n-                               let pkg_id = PkgId::new(lib_name);\n-                               my_ctxt.install(&my_workspace, &pkg_id);\n-                               // Also, add an additional search path\n-                               debug!(\"let installed_path...\")\n-                               let installed_path = target_library_in_workspace(&pkg_id,\n-                                                                         &my_workspace).pop();\n-                               debug!(\"Great, I installed %s, and it's in %s\",\n-                                   lib_name, installed_path.to_str());\n-                               save(installed_path);\n-                           }\n+                        }\n+                        // Also, add an additional search path\n+                        let installed_library =\n+                            installed_library_in_workspace(lib_name, workspace)\n+                                .expect( fmt!(\"rustpkg failed to install dependency %s\",\n+                                              lib_name));\n+                        let install_dir = installed_library.pop();\n+                        debug!(\"Installed %s into %s\", lib_name, install_dir.to_str());\n+                        save(install_dir);\n                     }\n-                }\n-              }\n-            }\n+                }}\n             // Ignore `use`s\n             _ => ()\n         }"}, {"sha": "c2d87ddeb82bdd4a331e545b8ab9794b58b174c0", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -99,12 +99,14 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n     let rustpath = rust_path();\n     for rp in rustpath.iter() {\n         let local_path = rp.push_rel(local_path);\n-        debug!(\"in try_getting_local_version\");\n+        let git_dir = local_path.push(\".git\");\n+        if !os::path_is_dir(&git_dir) {\n+            loop;\n+        }\n         let outp = run::process_output(\"git\",\n-                                   [fmt!(\"--git-dir=%s\", local_path.push(\".git\").to_str()),\n-                                    ~\"tag\", ~\"-l\"]);\n+                                   [fmt!(\"--git-dir=%s\", git_dir.to_str()), ~\"tag\", ~\"-l\"]);\n \n-        debug!(\"git --git-dir=%s tag -l ~~~> %?\", local_path.push(\".git\").to_str(), outp.status);\n+        debug!(\"git --git-dir=%s tag -l ~~~> %?\", git_dir.to_str(), outp.status);\n \n         if outp.status != 0 {\n             loop;\n@@ -129,9 +131,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n /// and the most recent tag in that repo denotes a version, return it;\n /// otherwise, `None`\n pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n-    debug!(\"try_getting_version: %s\", remote_path.to_str());\n     if is_url_like(remote_path) {\n-        debug!(\"Trying to fetch its sources..\");\n         let tmp_dir = mkdtemp(&os::tmpdir(),\n                               \"test\").expect(\"try_getting_version: couldn't create temp dir\");\n         debug!(\"(to get version) executing {git clone https://%s %s}\",\n@@ -218,14 +218,11 @@ pub fn split_version<'a>(s: &'a str) -> Option<(&'a str, Version)> {\n pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Version)> {\n     match s.rfind(sep) {\n         Some(i) => {\n-            debug!(\"in %s, i = %?\", s, i);\n             let path = s.slice(0, i);\n-            debug!(\"path = %s\", path);\n             // n.b. for now, assuming an exact revision is intended, not a SemVer\n             Some((path, ExactRevision(s.slice(i + 1, s.len()).to_owned())))\n         }\n         None => {\n-            debug!(\"%s doesn't look like an explicit-version thing\", s);\n             None\n         }\n     }"}, {"sha": "e2416782d987cd43a42e079eeecb902f06caa57c", "filename": "src/librustpkg/workcache_support.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use extra::sha1::Sha1;\n+use extra::digest::Digest;\n+use extra::workcache;\n+use std::io;\n+\n+/// Hashes the file contents along with the last-modified time\n+pub fn digest_file_with_date(path: &Path) -> ~str {\n+    use conditions::bad_path::cond;\n+    use cond1 = conditions::bad_stat::cond;\n+\n+    let mut sha = ~Sha1::new();\n+    let s = io::read_whole_file_str(path);\n+    match s {\n+        Ok(s) => {\n+            (*sha).input_str(s);\n+            let st = match path.stat() {\n+                Some(st) => st,\n+                None => cond1.raise((path.clone(), fmt!(\"Couldn't get file access time\")))\n+            };\n+            (*sha).input_str(st.st_mtime.to_str());\n+            (*sha).result_str()\n+        }\n+        Err(e) => cond.raise((path.clone(), fmt!(\"Couldn't read file: %s\", e))).to_str()\n+    }\n+}\n+\n+/// Hashes only the last-modified time\n+pub fn digest_only_date(path: &Path) -> ~str {\n+    use cond = conditions::bad_stat::cond;\n+\n+    let mut sha = ~Sha1::new();\n+    let st = match path.stat() {\n+                Some(st) => st,\n+                None => cond.raise((path.clone(), fmt!(\"Couldn't get file access time\")))\n+    };\n+    (*sha).input_str(st.st_mtime.to_str());\n+    (*sha).result_str()\n+}\n+\n+/// Adds multiple discovered outputs\n+pub fn discover_outputs(e: &mut workcache::Exec, outputs: ~[Path]) {\n+    debug!(\"Discovering %? outputs\", outputs.len());\n+    for p in outputs.iter() {\n+        debug!(\"Discovering output! %s\", p.to_str());\n+        // For now, assume that all discovered outputs are binaries\n+        e.discover_output(\"binary\", p.to_str(), digest_only_date(p));\n+    }\n+}"}, {"sha": "d5dd87ee44228614a5f7636e6b948d0d19f9e17a", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -12,14 +12,14 @@\n \n use std::{os,util};\n use std::path::Path;\n-use context::Ctx;\n+use context::Context;\n use path_util::{workspace_contains_package_id, find_dir_using_rust_path_hack};\n use util::option_to_vec;\n use package_id::PkgId;\n \n use path_util::rust_path;\n \n-pub fn each_pkg_parent_workspace(cx: &Ctx, pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n+pub fn each_pkg_parent_workspace(cx: &Context, pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n     let workspaces = pkg_parent_workspaces(cx, pkgid);\n@@ -38,12 +38,12 @@ pub fn each_pkg_parent_workspace(cx: &Ctx, pkgid: &PkgId, action: &fn(&Path) ->\n     return true;\n }\n \n-pub fn pkg_parent_workspaces(cx: &Ctx, pkgid: &PkgId) -> ~[Path] {\n+pub fn pkg_parent_workspaces(cx: &Context, pkgid: &PkgId) -> ~[Path] {\n     let rs: ~[Path] = rust_path().move_iter()\n         .filter(|ws| workspace_contains_package_id(pkgid, ws))\n         .collect();\n     if cx.use_rust_path_hack {\n-        rs + option_to_vec(find_dir_using_rust_path_hack(cx, pkgid))\n+        rs + option_to_vec(find_dir_using_rust_path_hack(pkgid))\n     }\n     else {\n         rs"}, {"sha": "dcf655871dfb27148e6cf182e785eb91c86759c8", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 9, "deletions": 78, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c0b41d7b1a3f240301387fa4152a060d532e4/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8c7c0b41d7b1a3f240301387fa4152a060d532e4", "patch": "@@ -14,7 +14,7 @@ use ast_util;\n use codemap::{Span, dummy_sp};\n use opt_vec;\n use parse::token;\n-use visit::{SimpleVisitor, SimpleVisitorVisitor, Visitor};\n+use visit::{SimpleVisitor, Visitor};\n use visit;\n \n use std::hashmap::HashMap;\n@@ -684,94 +684,25 @@ pub fn walk_pat(pat: @Pat, it: &fn(@Pat) -> bool) -> bool {\n }\n \n pub trait EachViewItem {\n-    fn each_view_item(&self, f: @fn(&ast::view_item) -> bool) -> bool;\n+    fn each_view_item(&self, f: &fn(&ast::view_item) -> bool) -> bool;\n }\n \n-struct EachViewItemData {\n-    callback: @fn(&ast::view_item) -> bool,\n+struct EachViewItemData<'self> {\n+    callback: &'self fn(&ast::view_item) -> bool,\n }\n \n-impl SimpleVisitor for EachViewItemData {\n-    fn visit_mod(&mut self, _: &_mod, _: Span, _: NodeId) {\n-        // XXX: Default method.\n-    }\n-    fn visit_view_item(&mut self, view_item: &view_item) {\n+impl<'self> Visitor<()> for EachViewItemData<'self> {\n+    fn visit_view_item(&mut self, view_item: &ast::view_item, _: ()) {\n         let _ = (self.callback)(view_item);\n     }\n-    fn visit_foreign_item(&mut self, _: @foreign_item) {\n-        // XXX: Default method.\n-    }\n-    fn visit_item(&mut self, _: @item) {\n-        // XXX: Default method.\n-    }\n-    fn visit_local(&mut self, _: @Local) {\n-        // XXX: Default method.\n-    }\n-    fn visit_block(&mut self, _: &Block) {\n-        // XXX: Default method.\n-    }\n-    fn visit_stmt(&mut self, _: @Stmt) {\n-        // XXX: Default method.\n-    }\n-    fn visit_arm(&mut self, _: &Arm) {\n-        // XXX: Default method.\n-    }\n-    fn visit_pat(&mut self, _: @Pat) {\n-        // XXX: Default method.\n-    }\n-    fn visit_decl(&mut self, _: @Decl) {\n-        // XXX: Default method.\n-    }\n-    fn visit_expr(&mut self, _: @Expr) {\n-        // XXX: Default method.\n-    }\n-    fn visit_expr_post(&mut self, _: @Expr) {\n-        // XXX: Default method.\n-    }\n-    fn visit_ty(&mut self, _: &Ty) {\n-        // XXX: Default method.\n-    }\n-    fn visit_generics(&mut self, _: &Generics) {\n-        // XXX: Default method.\n-    }\n-    fn visit_fn(&mut self,\n-                _: &visit::fn_kind,\n-                _: &fn_decl,\n-                _: &Block,\n-                _: Span,\n-                _: NodeId) {\n-        // XXX: Default method.\n-    }\n-    fn visit_ty_method(&mut self, _: &TypeMethod) {\n-        // XXX: Default method.\n-    }\n-    fn visit_trait_method(&mut self, _: &trait_method) {\n-        // XXX: Default method.\n-    }\n-    fn visit_struct_def(&mut self,\n-                        _: @struct_def,\n-                        _: Ident,\n-                        _: &Generics,\n-                        _: NodeId) {\n-        // XXX: Default method.\n-    }\n-    fn visit_struct_field(&mut self, _: @struct_field) {\n-        // XXX: Default method.\n-    }\n-    fn visit_struct_method(&mut self, _: @method) {\n-        // XXX: Default method.\n-    }\n }\n \n impl EachViewItem for ast::Crate {\n-    fn each_view_item(&self, f: @fn(&ast::view_item) -> bool) -> bool {\n-        let data = @mut EachViewItemData {\n+    fn each_view_item(&self, f: &fn(&ast::view_item) -> bool) -> bool {\n+        let mut visit = EachViewItemData {\n             callback: f,\n         };\n-        let visitor = @mut SimpleVisitorVisitor {\n-            simple_visitor: data as @mut SimpleVisitor,\n-        };\n-        visit::walk_crate(visitor, self, ());\n+        visit::walk_crate(&mut visit, self, ());\n         true\n     }\n }"}]}