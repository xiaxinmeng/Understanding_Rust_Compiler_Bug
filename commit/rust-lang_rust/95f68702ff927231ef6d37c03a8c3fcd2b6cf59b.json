{"sha": "95f68702ff927231ef6d37c03a8c3fcd2b6cf59b", "node_id": "C_kwDOAAsO6NoAKDk1ZjY4NzAyZmY5MjcyMzFlZjZkMzdjMDNhOGMzZmNkMmI2Y2Y1OWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-02T04:59:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-02T04:59:16Z"}, "message": "Auto merge of #95509 - nnethercote:simplify-MatcherPos-some-more, r=petrochenkov\n\nSimplify `MatcherPos` some more\n\nA few more improvements.\n\nr? `@petrochenkov`", "tree": {"sha": "522ecbd9a4744a9cdf986704ac3aa0a78b33923a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/522ecbd9a4744a9cdf986704ac3aa0a78b33923a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95f68702ff927231ef6d37c03a8c3fcd2b6cf59b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95f68702ff927231ef6d37c03a8c3fcd2b6cf59b", "html_url": "https://github.com/rust-lang/rust/commit/95f68702ff927231ef6d37c03a8c3fcd2b6cf59b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95f68702ff927231ef6d37c03a8c3fcd2b6cf59b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79f178b76ea9d5c6182f67413f62dd86b0e38508", "url": "https://api.github.com/repos/rust-lang/rust/commits/79f178b76ea9d5c6182f67413f62dd86b0e38508", "html_url": "https://github.com/rust-lang/rust/commit/79f178b76ea9d5c6182f67413f62dd86b0e38508"}, {"sha": "c6fedd4f1006069786a28e2054442c188408e194", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6fedd4f1006069786a28e2054442c188408e194", "html_url": "https://github.com/rust-lang/rust/commit/c6fedd4f1006069786a28e2054442c188408e194"}], "stats": {"total": 215, "additions": 120, "deletions": 95}, "files": [{"sha": "f5a93905b82e4ef72024975a090a4be063257537", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/95f68702ff927231ef6d37c03a8c3fcd2b6cf59b/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f68702ff927231ef6d37c03a8c3fcd2b6cf59b/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=95f68702ff927231ef6d37c03a8c3fcd2b6cf59b", "patch": "@@ -1,5 +1,6 @@\n #![feature(associated_type_bounds)]\n #![feature(associated_type_defaults)]\n+#![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]"}, {"sha": "7d4de72c3fef647b5e979c508f975c2ea5a321f0", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 119, "deletions": 95, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/95f68702ff927231ef6d37c03a8c3fcd2b6cf59b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f68702ff927231ef6d37c03a8c3fcd2b6cf59b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=95f68702ff927231ef6d37c03a8c3fcd2b6cf59b", "patch": "@@ -75,7 +75,7 @@ crate use ParseResult::*;\n \n use crate::mbe::{self, SequenceRepetition, TokenTree};\n \n-use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n+use rustc_ast::token::{self, DocComment, Nonterminal, Token, TokenKind};\n use rustc_parse::parser::{NtOrTt, Parser};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n@@ -87,17 +87,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_span::symbol::Ident;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::mem;\n-\n-/// This is used by `parse_tt_inner` to keep track of delimited submatchers that we have\n-/// descended into.\n-#[derive(Clone)]\n-struct MatcherPosFrame<'tt> {\n-    /// The \"parent\" matcher that we have descended from.\n-    tts: &'tt [TokenTree],\n-    /// The position of the \"dot\" in `tt` at the time we descended.\n-    idx: usize,\n-}\n \n // One element is enough to cover 95-99% of vectors for most benchmarks. Also,\n // vectors longer than one frequently have many elements, not just two or\n@@ -108,6 +97,33 @@ type NamedMatchVec = SmallVec<[NamedMatch; 1]>;\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(NamedMatchVec, 48);\n \n+#[derive(Clone)]\n+enum MatcherKind<'tt> {\n+    TopLevel,\n+    Delimited(Box<DelimitedSubmatcher<'tt>>),\n+    Sequence(Box<SequenceSubmatcher<'tt>>),\n+}\n+\n+#[derive(Clone)]\n+struct DelimitedSubmatcher<'tt> {\n+    parent: Parent<'tt>,\n+}\n+\n+#[derive(Clone)]\n+struct SequenceSubmatcher<'tt> {\n+    parent: Parent<'tt>,\n+    seq: &'tt SequenceRepetition,\n+}\n+\n+/// Data used to ascend from a submatcher back to its parent matcher. A subset of the fields from\n+/// `MathcherPos`.\n+#[derive(Clone)]\n+struct Parent<'tt> {\n+    tts: &'tt [TokenTree],\n+    idx: usize,\n+    kind: MatcherKind<'tt>,\n+}\n+\n /// A single matcher position, which could be within the top-level matcher, a submatcher, a\n /// subsubmatcher, etc. For example:\n /// ```text\n@@ -116,13 +132,14 @@ rustc_data_structures::static_assert_size!(NamedMatchVec, 48);\n ///                            <-------------->   first submatcher; three tts, zero metavars\n ///                  <--------------------------> top-level matcher; two tts, one metavar\n /// ```\n-#[derive(Clone)]\n struct MatcherPos<'tt> {\n     /// The tokens that make up the current matcher. When we are within a `Sequence` or `Delimited`\n     /// submatcher, this is just the contents of that submatcher.\n     tts: &'tt [TokenTree],\n \n-    /// The \"dot\" position within the current submatcher, i.e. the index into `tts`.\n+    /// The \"dot\" position within the current submatcher, i.e. the index into `tts`. Can go one or\n+    /// two positions past the final elements in `tts` when dealing with sequences, see\n+    /// `parse_tt_inner` for details.\n     idx: usize,\n \n     /// This vector ends up with one element per metavar in the *top-level* matcher, even when this\n@@ -134,25 +151,18 @@ struct MatcherPos<'tt> {\n     /// The number of sequences this mp is within.\n     seq_depth: usize,\n \n-    /// The position in `matches` of the first metavar in this (sub)matcher. Zero if there are\n-    /// no metavars.\n-    match_lo: usize,\n-\n     /// The position in `matches` of the next metavar to be matched against the source token\n     /// stream. Should not be used if there are no metavars.\n     match_cur: usize,\n \n-    /// This field is only used if we are matching a sequence.\n-    sequence: Option<MatcherPosSequence<'tt>>,\n-\n-    /// When we are within a `Delimited` submatcher (or subsubmatcher), this tracks the parent\n-    /// matcher(s). The bottom of the stack is the top-level matcher.\n-    stack: SmallVec<[MatcherPosFrame<'tt>; 1]>,\n+    /// What kind of matcher we are in. For submatchers, this contains enough information to\n+    /// reconstitute a `MatcherPos` within the parent once we ascend out of the submatcher.\n+    kind: MatcherKind<'tt>,\n }\n \n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MatcherPos<'_>, 104);\n+rustc_data_structures::static_assert_size!(MatcherPos<'_>, 64);\n \n impl<'tt> MatcherPos<'tt> {\n     fn top_level(matcher: &'tt [TokenTree], empty_matches: Lrc<NamedMatchVec>) -> Self {\n@@ -161,31 +171,50 @@ impl<'tt> MatcherPos<'tt> {\n             idx: 0,\n             matches: empty_matches,\n             seq_depth: 0,\n-            match_lo: 0,\n             match_cur: 0,\n-            stack: smallvec![],\n-            sequence: None,\n+            kind: MatcherKind::TopLevel,\n         }\n     }\n \n+    fn empty_sequence(\n+        parent_mp: &MatcherPos<'tt>,\n+        seq: &'tt SequenceRepetition,\n+        empty_matches: Lrc<NamedMatchVec>,\n+    ) -> Self {\n+        let mut mp = MatcherPos {\n+            tts: parent_mp.tts,\n+            idx: parent_mp.idx + 1,\n+            matches: parent_mp.matches.clone(), // a cheap clone\n+            seq_depth: parent_mp.seq_depth,\n+            match_cur: parent_mp.match_cur + seq.num_captures,\n+            kind: parent_mp.kind.clone(), // an expensive clone\n+        };\n+        for idx in parent_mp.match_cur..parent_mp.match_cur + seq.num_captures {\n+            mp.push_match(idx, MatchedSeq(empty_matches.clone()));\n+        }\n+        mp\n+    }\n+\n     fn sequence(\n-        parent: Box<MatcherPos<'tt>>,\n+        parent_mp: Box<MatcherPos<'tt>>,\n         seq: &'tt SequenceRepetition,\n         empty_matches: Lrc<NamedMatchVec>,\n     ) -> Self {\n+        let seq_kind = box SequenceSubmatcher {\n+            parent: Parent { tts: parent_mp.tts, idx: parent_mp.idx, kind: parent_mp.kind },\n+            seq,\n+        };\n         let mut mp = MatcherPos {\n             tts: &seq.tts,\n             idx: 0,\n-            matches: parent.matches.clone(),\n-            seq_depth: parent.seq_depth,\n-            match_lo: parent.match_cur,\n-            match_cur: parent.match_cur,\n-            sequence: Some(MatcherPosSequence { parent, seq }),\n-            stack: smallvec![],\n+            matches: parent_mp.matches,\n+            seq_depth: parent_mp.seq_depth,\n+            match_cur: parent_mp.match_cur,\n+            kind: MatcherKind::Sequence(seq_kind),\n         };\n         // Start with an empty vec for each metavar within the sequence. Note that `mp.seq_depth`\n         // must have the parent's depth at this point for these `push_match` calls to work.\n-        for idx in mp.match_lo..mp.match_lo + seq.num_captures {\n+        for idx in mp.match_cur..mp.match_cur + seq.num_captures {\n             mp.push_match(idx, MatchedSeq(empty_matches.clone()));\n         }\n         mp.seq_depth += 1;\n@@ -226,16 +255,6 @@ impl<'tt> MatcherPos<'tt> {\n     }\n }\n \n-#[derive(Clone)]\n-struct MatcherPosSequence<'tt> {\n-    /// The parent matcher position. Effectively gives a linked list of matches all the way to the\n-    /// top-level matcher.\n-    parent: Box<MatcherPos<'tt>>,\n-\n-    /// The sequence itself.\n-    seq: &'tt SequenceRepetition,\n-}\n-\n enum EofMatcherPositions<'tt> {\n     None,\n     One(Box<MatcherPos<'tt>>),\n@@ -448,18 +467,6 @@ impl<'tt> TtParser<'tt> {\n         let mut eof_mps = EofMatcherPositions::None;\n \n         while let Some(mut mp) = self.cur_mps.pop() {\n-            // Backtrack out of delimited submatcher when necessary. When backtracking out again,\n-            // we need to advance the \"dot\" past the delimiters in the parent matcher(s).\n-            while mp.idx >= mp.tts.len() {\n-                match mp.stack.pop() {\n-                    Some(MatcherPosFrame { tts, idx }) => {\n-                        mp.tts = tts;\n-                        mp.idx = idx + 1;\n-                    }\n-                    None => break,\n-                }\n-            }\n-\n             // Get the current position of the \"dot\" (`idx`) in `mp` and the number of token\n             // trees in the matcher (`len`).\n             let idx = mp.idx;\n@@ -473,13 +480,11 @@ impl<'tt> TtParser<'tt> {\n                         let op = seq.kleene.op;\n                         if op == mbe::KleeneOp::ZeroOrMore || op == mbe::KleeneOp::ZeroOrOne {\n                             // Allow for the possibility of zero matches of this sequence.\n-                            let mut new_mp = mp.clone();\n-                            new_mp.match_cur += seq.num_captures;\n-                            new_mp.idx += 1;\n-                            for idx in mp.match_cur..mp.match_cur + seq.num_captures {\n-                                new_mp.push_match(idx, MatchedSeq(self.empty_matches.clone()));\n-                            }\n-                            self.cur_mps.push(new_mp);\n+                            self.cur_mps.push(box MatcherPos::empty_sequence(\n+                                &*mp,\n+                                &seq,\n+                                self.empty_matches.clone(),\n+                            ));\n                         }\n \n                         // Allow for the possibility of one or more matches of this sequence.\n@@ -509,16 +514,17 @@ impl<'tt> TtParser<'tt> {\n                     }\n \n                     TokenTree::Delimited(_, delimited) => {\n-                        // To descend into a delimited submatcher, we push the current matcher onto\n-                        // a stack and push a new mp containing the submatcher onto `cur_mps`.\n-                        //\n-                        // At the beginning of the loop, if we reach the end of the delimited\n-                        // submatcher, we pop the stack to backtrack out of the descent. Note that\n-                        // we use `all_tts` to include the open and close delimiter tokens.\n-                        let tts = mem::replace(&mut mp.tts, &delimited.all_tts);\n-                        let idx = mp.idx;\n-                        mp.stack.push(MatcherPosFrame { tts, idx });\n+                        // To descend into a delimited submatcher, we update `mp` appropriately,\n+                        // including enough information to re-ascend afterwards, and push it onto\n+                        // `cur_mps`. Later, when we reach the closing delimiter, we will recover\n+                        // the parent matcher position to ascend. Note that we use `all_tts` to\n+                        // include the open and close delimiter tokens.\n+                        let kind = MatcherKind::Delimited(box DelimitedSubmatcher {\n+                            parent: Parent { tts: mp.tts, idx: mp.idx, kind: mp.kind },\n+                        });\n+                        mp.tts = &delimited.all_tts;\n                         mp.idx = 0;\n+                        mp.kind = kind;\n                         self.cur_mps.push(mp);\n                     }\n \n@@ -536,6 +542,18 @@ impl<'tt> TtParser<'tt> {\n                             mp.idx += 1;\n                             self.cur_mps.push(mp);\n                         } else if token_name_eq(&t, token) {\n+                            if let TokenKind::CloseDelim(_) = token.kind {\n+                                // Ascend out of the delimited submatcher.\n+                                debug_assert_eq!(idx, len - 1);\n+                                match mp.kind {\n+                                    MatcherKind::Delimited(submatcher) => {\n+                                        mp.tts = submatcher.parent.tts;\n+                                        mp.idx = submatcher.parent.idx;\n+                                        mp.kind = submatcher.parent.kind;\n+                                    }\n+                                    _ => unreachable!(),\n+                                }\n+                            }\n                             mp.idx += 1;\n                             self.next_mps.push(mp);\n                         }\n@@ -544,38 +562,44 @@ impl<'tt> TtParser<'tt> {\n                     // These cannot appear in a matcher.\n                     TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n                 }\n-            } else if let Some(sequence) = &mp.sequence {\n+            } else if let MatcherKind::Sequence(box SequenceSubmatcher { parent, seq }) = &mp.kind {\n                 // We are past the end of a sequence.\n-                debug_assert!(idx <= len + 1);\n+                // - If it has no separator, we must be only one past the end.\n+                // - If it has a separator, we may be one past the end, in which case we must\n+                //   look for a separator. Or we may be two past the end, in which case we have\n+                //   already dealt with the separator.\n+                debug_assert!(idx == len || idx == len + 1 && seq.separator.is_some());\n \n                 if idx == len {\n-                    // Add all matches from the sequence to `parent`, and move the \"dot\" past the\n-                    // sequence in `parent`. This allows for the case where the sequence matching\n-                    // is finished.\n-                    let mut new_mp = sequence.parent.clone();\n-                    new_mp.matches = mp.matches.clone();\n-                    new_mp.match_cur = mp.match_lo + sequence.seq.num_captures;\n-                    new_mp.idx += 1;\n+                    // Sequence matching may have finished: move the \"dot\" past the sequence in\n+                    // `parent`. This applies whether a separator is used or not. If sequence\n+                    // matching hasn't finished, this `new_mp` will fail quietly when it is\n+                    // processed next time around the loop.\n+                    let new_mp = box MatcherPos {\n+                        tts: parent.tts,\n+                        idx: parent.idx + 1,\n+                        matches: mp.matches.clone(), // a cheap clone\n+                        seq_depth: mp.seq_depth - 1,\n+                        match_cur: mp.match_cur,\n+                        kind: parent.kind.clone(), // an expensive clone\n+                    };\n                     self.cur_mps.push(new_mp);\n                 }\n \n-                if idx == len && sequence.seq.separator.is_some() {\n-                    if sequence\n-                        .seq\n-                        .separator\n-                        .as_ref()\n-                        .map_or(false, |sep| token_name_eq(token, sep))\n-                    {\n+                if seq.separator.is_some() && idx == len {\n+                    // Look for the separator.\n+                    if seq.separator.as_ref().map_or(false, |sep| token_name_eq(token, sep)) {\n                         // The matcher has a separator, and it matches the current token. We can\n                         // advance past the separator token.\n                         mp.idx += 1;\n                         self.next_mps.push(mp);\n                     }\n-                } else if sequence.seq.kleene.op != mbe::KleeneOp::ZeroOrOne {\n-                    // We don't need a separator. Move the \"dot\" back to the beginning of the\n-                    // matcher and try to match again UNLESS we are only allowed to have _one_\n-                    // repetition.\n-                    mp.match_cur = mp.match_lo;\n+                } else if seq.kleene.op != mbe::KleeneOp::ZeroOrOne {\n+                    // We don't need to look for a separator: either this sequence doesn't have\n+                    // one, or it does and we've already handled it. Also, we are allowed to have\n+                    // more than one repetition. Move the \"dot\" back to the beginning of the\n+                    // matcher and try to match again.\n+                    mp.match_cur -= seq.num_captures;\n                     mp.idx = 0;\n                     self.cur_mps.push(mp);\n                 }"}]}