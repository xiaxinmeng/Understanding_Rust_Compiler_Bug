{"sha": "4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMzhmOGRmZmJlY2E1YzVmODFjM2M3MmQ0MmQ0Mjg3YzBhY2IxZmM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-22T18:28:14Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-22T18:28:48Z"}, "message": "move pointer truncation to a common method in memory.rs", "tree": {"sha": "c2230518eed930b1b3b017cafb1892b5d313bbd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2230518eed930b1b3b017cafb1892b5d313bbd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc", "html_url": "https://github.com/rust-lang/rust/commit/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40950b2cd18a7a62b14c80d92be60ebf2f6b62a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/40950b2cd18a7a62b14c80d92be60ebf2f6b62a3", "html_url": "https://github.com/rust-lang/rust/commit/40950b2cd18a7a62b14c80d92be60ebf2f6b62a3"}], "stats": {"total": 183, "additions": 113, "deletions": 70}, "files": [{"sha": "aff358f815c98ddc2c1b3c2648cb2478730ad753", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc", "patch": "@@ -4,7 +4,7 @@ use syntax::ast::{FloatTy, IntTy, UintTy};\n use error::{EvalResult, EvalError};\n use eval_context::EvalContext;\n use value::PrimVal;\n-use memory::MemoryPointer;\n+use memory::{MemoryPointer, HasDataLayout};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn cast_primval(\n@@ -78,7 +78,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             TyChar => Err(EvalError::InvalidChar(v)),\n \n             // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n-            TyRawPtr(_) => Ok(PrimVal::Bytes(v % (1u128 << self.memory.layout.pointer_size.bits()))),\n+            TyRawPtr(_) => Ok(PrimVal::Bytes(self.memory.truncate_to_ptr(v).0 as u128)),\n \n             _ => Err(EvalError::Unimplemented(format!(\"int to {:?} cast\", ty))),\n         }"}, {"sha": "3c38f318e4ad191a485276efa12d7acc598a46b9", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc", "patch": "@@ -1226,8 +1226,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let field_1_ty = self.get_field_ty(ty, 1)?;\n         let field_0_size = self.type_size(field_0_ty)?.expect(\"pair element type must be sized\");\n         let field_1_size = self.type_size(field_1_ty)?.expect(\"pair element type must be sized\");\n-        self.memory.write_primval(ptr.offset(field_0, self.memory.layout)?.into(), a, field_0_size)?;\n-        self.memory.write_primval(ptr.offset(field_1, self.memory.layout)?.into(), b, field_1_size)?;\n+        let layout = self.memory.layout;\n+        self.memory.write_primval(ptr.offset(field_0, layout)?.into(), a, field_0_size)?;\n+        self.memory.write_primval(ptr.offset(field_1, layout)?.into(), b, field_1_size)?;\n         Ok(())\n     }\n "}, {"sha": "00b29d26e974ef6edcf4f2168f7270dd813c3c7d", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 95, "deletions": 12, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::layout::{self, TargetDataLayout};\n use syntax::ast::Mutability;\n \n use error::{EvalError, EvalResult};\n-use value::{PrimVal, self, Pointer};\n+use value::{PrimVal, Pointer};\n use eval_context::EvalContext;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -73,26 +73,26 @@ impl MemoryPointer {\n         MemoryPointer { alloc_id, offset }\n     }\n \n-    pub fn wrapping_signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> Self {\n-        MemoryPointer::new(self.alloc_id, value::wrapping_signed_offset(self.offset, i, layout))\n+    pub(crate) fn wrapping_signed_offset<'a, L: HasDataLayout<'a>>(self, i: i64, l: L) -> Self {\n+        MemoryPointer::new(self.alloc_id, l.wrapping_signed_offset(self.offset, i))\n     }\n \n-    pub fn overflowing_signed_offset<'tcx>(self, i: i128, layout: &TargetDataLayout) -> (Self, bool) {\n-        let (res, over) = value::overflowing_signed_offset(self.offset, i, layout);\n+    pub(crate) fn overflowing_signed_offset<'a, L: HasDataLayout<'a>>(self, i: i128, l: L) -> (Self, bool) {\n+        let (res, over) = l.overflowing_signed_offset(self.offset, i);\n         (MemoryPointer::new(self.alloc_id, res), over)\n     }\n \n-    pub fn signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        Ok(MemoryPointer::new(self.alloc_id, value::signed_offset(self.offset, i, layout)?))\n+    pub(crate) fn signed_offset<'a, 'tcx, L: HasDataLayout<'a>>(self, i: i64, l: L) -> EvalResult<'tcx, Self> {\n+        Ok(MemoryPointer::new(self.alloc_id, l.signed_offset(self.offset, i)?))\n     }\n \n-    pub fn overflowing_offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> (Self, bool) {\n-        let (res, over) = value::overflowing_offset(self.offset, i, layout);\n+    pub(crate) fn overflowing_offset<'a, L: HasDataLayout<'a>>(self, i: u64, l: L) -> (Self, bool) {\n+        let (res, over) = l.overflowing_offset(self.offset, i);\n         (MemoryPointer::new(self.alloc_id, res), over)\n     }\n \n-    pub fn offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        Ok(MemoryPointer::new(self.alloc_id, value::offset(self.offset, i, layout)?))\n+    pub(crate) fn offset<'a, 'tcx, L: HasDataLayout<'a>>(self, i: u64, l: L) -> EvalResult<'tcx, Self> {\n+        Ok(MemoryPointer::new(self.alloc_id, l.offset(self.offset, i)?))\n     }\n }\n \n@@ -540,7 +540,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n-        self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds(ptr.offset(size, self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n         assert_eq!(size as usize as u64, size);\n@@ -1131,6 +1131,7 @@ fn bit_index(bits: u64) -> (usize, usize) {\n \n pub(crate) trait HasMemory<'a, 'tcx> {\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx>;\n+    fn memory(&self) -> &Memory<'a, 'tcx>;\n \n     // These are not supposed to be overriden.\n     fn read_maybe_aligned<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n@@ -1159,11 +1160,93 @@ impl<'a, 'tcx> HasMemory<'a, 'tcx> for Memory<'a, 'tcx> {\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n         self\n     }\n+\n+    #[inline]\n+    fn memory(&self) -> &Memory<'a, 'tcx> {\n+        self\n+    }\n }\n \n impl<'a, 'tcx> HasMemory<'a, 'tcx> for EvalContext<'a, 'tcx> {\n     #[inline]\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n         &mut self.memory\n     }\n+\n+    #[inline]\n+    fn memory(&self) -> &Memory<'a, 'tcx> {\n+        &self.memory\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Pointer arithmetic\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub(crate) trait HasDataLayout<'a> : Copy {\n+    fn data_layout(self) -> &'a TargetDataLayout;\n+\n+    // These are not supposed to be overriden.\n+\n+    //// Trunace the given value to the pointer size; also return whether there was an overflow\n+    fn truncate_to_ptr(self, val: u128) -> (u64, bool) {\n+        let max_ptr_plus_1 = 1u128 << self.data_layout().pointer_size.bits();\n+        ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n+    }\n+\n+    // Overflow checking only works properly on the range from -u64 to +u64.\n+    fn overflowing_signed_offset(self, val: u64, i: i128) -> (u64, bool) {\n+        // FIXME: is it possible to over/underflow here?\n+        if i < 0 {\n+            // trickery to ensure that i64::min_value() works fine\n+            // this formula only works for true negative values, it panics for zero!\n+            let n = u64::max_value() - (i as u64) + 1;\n+            val.overflowing_sub(n)\n+        } else {\n+            self.overflowing_offset(val, i as u64)\n+        }\n+    }\n+\n+    fn overflowing_offset(self, val: u64, i: u64) -> (u64, bool) {\n+        let (res, over1) = val.overflowing_add(i);\n+        let (res, over2) = self.truncate_to_ptr(res as u128);\n+        (res, over1 || over2)\n+    }\n+\n+    fn signed_offset<'tcx>(self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_signed_offset(val, i as i128);\n+        if over {\n+            Err(EvalError::OverflowingMath)\n+        } else {\n+            Ok(res)\n+        }\n+    }\n+\n+    fn offset<'tcx>(self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_offset(val, i);\n+        if over {\n+            Err(EvalError::OverflowingMath)\n+        } else {\n+            Ok(res)\n+        }\n+    }\n+\n+    fn wrapping_signed_offset(self, val: u64, i: i64) -> u64 {\n+        self.overflowing_signed_offset(val, i as i128).0\n+    }\n+}\n+\n+impl<'a> HasDataLayout<'a> for &'a TargetDataLayout {\n+    #[inline]\n+    fn data_layout(self) -> &'a TargetDataLayout {\n+        self\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx, T> HasDataLayout<'a> for &'b T\n+    where T: HasMemory<'a, 'tcx> {\n+    #[inline]\n+    fn data_layout(self) -> &'a TargetDataLayout {\n+        self.memory().layout\n+    }\n }"}, {"sha": "2db79b03d00e1d92fec494f7a86fe3a91ada89bf", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc", "patch": "@@ -814,8 +814,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n                     let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env)?;\n+                    let layout = self.memory.layout;\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n-                    self.memory.write_bytes(value_copy.offset(value.len() as u64, self.memory.layout)?.into(), &[0])?;\n+                    self.memory.write_bytes(value_copy.offset(value.len() as u64, layout)?.into(), &[0])?;\n                     if let Some(var) = self.env_vars.insert(name.to_owned(), value_copy) {\n                         self.memory.deallocate(var, None, Kind::Env)?;\n                     }"}, {"sha": "98059afb9e97f5be15bf8b92e582bba034edd7ee", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc", "patch": "@@ -57,14 +57,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let drop = self.memory.create_fn_alloc(drop);\n         self.memory.write_ptr(vtable, drop)?;\n \n-        self.memory.write_usize(vtable.offset(ptr_size, self.memory.layout)?, size)?;\n-        self.memory.write_usize(vtable.offset(ptr_size * 2, self.memory.layout)?, align)?;\n+        let layout = self.memory.layout;\n+        self.memory.write_usize(vtable.offset(ptr_size, layout)?, size)?;\n+        self.memory.write_usize(vtable.offset(ptr_size * 2, layout)?, align)?;\n \n         for (i, method) in ::rustc::traits::get_vtable_methods(self.tcx, trait_ref).enumerate() {\n             if let Some((def_id, substs)) = method {\n                 let instance = eval_context::resolve(self.tcx, def_id, substs);\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n-                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64), self.memory.layout)?, fn_ptr)?;\n+                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64), layout)?, fn_ptr)?;\n             }\n         }\n "}, {"sha": "7420ae1256af25d6285d478e5707eb599c6c2257", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 50, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=4d38f8dffbeca5c5f81c3c72d42d4287c0acb1fc", "patch": "@@ -1,10 +1,8 @@\n #![allow(unknown_lints)]\n #![allow(float_cmp)]\n \n-use rustc::ty::layout::TargetDataLayout;\n-\n use error::{EvalError, EvalResult};\n-use memory::{Memory, MemoryPointer, HasMemory};\n+use memory::{Memory, MemoryPointer, HasMemory, HasDataLayout};\n \n pub(super) fn bytes_to_f32(bytes: u128) -> f32 {\n     f32::from_bits(bytes as u32)\n@@ -61,33 +59,33 @@ impl<'tcx> Pointer {\n         self.primval\n     }\n \n-    pub(crate) fn signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+    pub(crate) fn signed_offset<'a, L: HasDataLayout<'a>>(self, i: i64, layout: L) -> EvalResult<'tcx, Self> {\n         match self.primval {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(PrimVal::Bytes(signed_offset(b as u64, i, layout)? as u128)))\n+                Ok(Pointer::from(PrimVal::Bytes(layout.signed_offset(b as u64, i)? as u128)))\n             },\n             PrimVal::Ptr(ptr) => ptr.signed_offset(i, layout).map(Pointer::from),\n             PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n         }\n     }\n \n-    pub(crate) fn offset(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+    pub(crate) fn offset<'a, L: HasDataLayout<'a>>(self, i: u64, layout: L) -> EvalResult<'tcx, Self> {\n         match self.primval {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(PrimVal::Bytes(offset(b as u64, i, layout)? as u128)))\n+                Ok(Pointer::from(PrimVal::Bytes(layout.offset(b as u64, i)? as u128)))\n             },\n             PrimVal::Ptr(ptr) => ptr.offset(i, layout).map(Pointer::from),\n             PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n         }\n     }\n \n-    pub(crate) fn wrapping_signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+    pub(crate) fn wrapping_signed_offset<'a, L: HasDataLayout<'a>>(self, i: i64, layout: L) -> EvalResult<'tcx, Self> {\n         match self.primval {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(PrimVal::Bytes(wrapping_signed_offset(b as u64, i, layout) as u128)))\n+                Ok(Pointer::from(PrimVal::Bytes(layout.wrapping_signed_offset(b as u64, i) as u128)))\n             },\n             PrimVal::Ptr(ptr) => Ok(Pointer::from(ptr.wrapping_signed_offset(i, layout))),\n             PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n@@ -323,47 +321,6 @@ impl<'tcx> PrimVal {\n     }\n }\n \n-// Overflow checking only works properly on the range from -u64 to +u64.\n-pub fn overflowing_signed_offset<'tcx>(val: u64, i: i128, layout: &TargetDataLayout) -> (u64, bool) {\n-    // FIXME: is it possible to over/underflow here?\n-    if i < 0 {\n-        // trickery to ensure that i64::min_value() works fine\n-        // this formula only works for true negative values, it panics for zero!\n-        let n = u64::max_value() - (i as u64) + 1;\n-        val.overflowing_sub(n)\n-    } else {\n-        overflowing_offset(val, i as u64, layout)\n-    }\n-}\n-\n-pub fn overflowing_offset<'tcx>(val: u64, i: u64, layout: &TargetDataLayout) -> (u64, bool) {\n-    let (res, over) = val.overflowing_add(i);\n-    ((res as u128 % (1u128 << layout.pointer_size.bits())) as u64,\n-     over || res as u128 >= (1u128 << layout.pointer_size.bits()))\n-}\n-\n-pub fn signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n-    let (res, over) = overflowing_signed_offset(val, i as i128, layout);\n-    if over {\n-        Err(EvalError::OverflowingMath)\n-    } else {\n-        Ok(res)\n-    }\n-}\n-\n-pub fn offset<'tcx>(val: u64, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n-    let (res, over) = overflowing_offset(val, i, layout);\n-    if over {\n-        Err(EvalError::OverflowingMath)\n-    } else {\n-        Ok(res)\n-    }\n-}\n-\n-pub fn wrapping_signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> u64 {\n-    overflowing_signed_offset(val, i as i128, layout).0\n-}\n-\n impl PrimValKind {\n     pub fn is_int(self) -> bool {\n         use self::PrimValKind::*;"}]}