{"sha": "27fa2b7944d79c1fa16445628fef268bdb34f625", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ZmEyYjc5NDRkNzljMWZhMTY0NDU2MjhmZWYyNjhiZGIzNGY2MjU=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2019-09-27T17:19:26Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2019-10-02T19:18:00Z"}, "message": "New lint: unsound_collection_transmute", "tree": {"sha": "c8a22793735ff3e6ff56cfa0025401b47042421d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8a22793735ff3e6ff56cfa0025401b47042421d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27fa2b7944d79c1fa16445628fef268bdb34f625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27fa2b7944d79c1fa16445628fef268bdb34f625", "html_url": "https://github.com/rust-lang/rust/commit/27fa2b7944d79c1fa16445628fef268bdb34f625", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27fa2b7944d79c1fa16445628fef268bdb34f625/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "737f0a6bb508706b75e21194e3010aa3865e779a", "url": "https://api.github.com/repos/rust-lang/rust/commits/737f0a6bb508706b75e21194e3010aa3865e779a", "html_url": "https://github.com/rust-lang/rust/commit/737f0a6bb508706b75e21194e3010aa3865e779a"}], "stats": {"total": 747, "additions": 490, "deletions": 257}, "files": [{"sha": "4fe97097fda495cb2ccecc86f0dd3b68415e260f", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27fa2b7944d79c1fa16445628fef268bdb34f625/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/27fa2b7944d79c1fa16445628fef268bdb34f625/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=27fa2b7944d79c1fa16445628fef268bdb34f625", "patch": "@@ -1225,6 +1225,7 @@ Released 2018-09-13\n [`unsafe_removed_from_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#unsafe_removed_from_name\n [`unsafe_vector_initialization`]: https://rust-lang.github.io/rust-clippy/master/index.html#unsafe_vector_initialization\n [`unseparated_literal_suffix`]: https://rust-lang.github.io/rust-clippy/master/index.html#unseparated_literal_suffix\n+[`unsound_collection_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#unsound_collection_transmute\n [`unstable_as_mut_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#unstable_as_mut_slice\n [`unstable_as_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#unstable_as_slice\n [`unused_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_collect"}, {"sha": "9a75d2ced0803e129037bc7b71f0b79f23f48fe0", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27fa2b7944d79c1fa16445628fef268bdb34f625/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/27fa2b7944d79c1fa16445628fef268bdb34f625/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=27fa2b7944d79c1fa16445628fef268bdb34f625", "patch": "@@ -6,7 +6,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 318 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are 319 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "1414b4ad87d94e0cb83d1680a0a1bfe0aee23c18", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27fa2b7944d79c1fa16445628fef268bdb34f625/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27fa2b7944d79c1fa16445628fef268bdb34f625/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=27fa2b7944d79c1fa16445628fef268bdb34f625", "patch": "@@ -890,6 +890,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         transmute::TRANSMUTE_INT_TO_FLOAT,\n         transmute::TRANSMUTE_PTR_TO_PTR,\n         transmute::TRANSMUTE_PTR_TO_REF,\n+        transmute::UNSOUND_COLLECTION_TRANSMUTE,\n         transmute::USELESS_TRANSMUTE,\n         transmute::WRONG_TRANSMUTE,\n         transmuting_null::TRANSMUTING_NULL,\n@@ -1145,6 +1146,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL,\n         suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL,\n         swap::ALMOST_SWAPPED,\n+        transmute::UNSOUND_COLLECTION_TRANSMUTE,\n         transmute::WRONG_TRANSMUTE,\n         transmuting_null::TRANSMUTING_NULL,\n         types::ABSURD_EXTREME_COMPARISONS,"}, {"sha": "1339555f9ce8bba75edf71a64baf6b3fbb40cc45", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 300, "deletions": 230, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/27fa2b7944d79c1fa16445628fef268bdb34f625/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27fa2b7944d79c1fa16445628fef268bdb34f625/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=27fa2b7944d79c1fa16445628fef268bdb34f625", "patch": "@@ -216,6 +216,33 @@ declare_clippy_lint! {\n     \"transmutes from a pointer to a pointer / a reference to a reference\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes between collections whose\n+    /// types have different ABI, size or alignment.\n+    ///\n+    /// **Why is this bad?** This is undefined behavior.\n+    ///\n+    /// **Known problems:** Currently, we cannot know whether a type is a\n+    /// collection, so we just lint the ones that come with `std`.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // different size, therefore likely out-of-bounds memory access\n+    /// // You absolutely do not want this in your code!\n+    /// unsafe {\n+    ///     std::mem::transmute::<_, Vec<u32>>(vec![2_u16])\n+    /// };\n+    /// ```\n+    ///\n+    /// You must always iterate, map and collect the values:\n+    ///\n+    /// ```rust\n+    /// vec![2_u16].into_iter().map(u32::from).collect::<Vec<_>>();\n+    /// ```\n+    pub UNSOUND_COLLECTION_TRANSMUTE,\n+    correctness,\n+    \"transmute between collections of layout-incompatible types\"\n+}\n declare_lint_pass!(Transmute => [\n     CROSSPOINTER_TRANSMUTE,\n     TRANSMUTE_PTR_TO_REF,\n@@ -226,262 +253,292 @@ declare_lint_pass!(Transmute => [\n     TRANSMUTE_BYTES_TO_STR,\n     TRANSMUTE_INT_TO_BOOL,\n     TRANSMUTE_INT_TO_FLOAT,\n+    UNSOUND_COLLECTION_TRANSMUTE,\n ]);\n \n+// used to check for UNSOUND_COLLECTION_TRANSMUTE\n+static COLLECTIONS: &[&[&str]] = &[\n+    &paths::VEC,\n+    &paths::VEC_DEQUE,\n+    &paths::BINARY_HEAP,\n+    &paths::BTREESET,\n+    &paths::BTREEMAP,\n+    &paths::HASHSET,\n+    &paths::HASHMAP,\n+];\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprKind::Call(ref path_expr, ref args) = e.kind {\n-            if let ExprKind::Path(ref qpath) = path_expr.kind {\n-                if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    if match_def_path(cx, def_id, &paths::TRANSMUTE) {\n-                        let from_ty = cx.tables.expr_ty(&args[0]);\n-                        let to_ty = cx.tables.expr_ty(e);\n+        if_chain! {\n+            if let ExprKind::Call(ref path_expr, ref args) = e.kind;\n+            if let ExprKind::Path(ref qpath) = path_expr.kind;\n+            if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n+            if match_def_path(cx, def_id, &paths::TRANSMUTE);\n+            then {\n+                let from_ty = cx.tables.expr_ty(&args[0]);\n+                let to_ty = cx.tables.expr_ty(e);\n \n-                        match (&from_ty.kind, &to_ty.kind) {\n-                            _ if from_ty == to_ty => span_lint(\n-                                cx,\n-                                USELESS_TRANSMUTE,\n-                                e.span,\n-                                &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n-                            ),\n-                            (&ty::Ref(_, rty, rty_mutbl), &ty::RawPtr(ptr_ty)) => span_lint_and_then(\n-                                cx,\n-                                USELESS_TRANSMUTE,\n-                                e.span,\n-                                \"transmute from a reference to a pointer\",\n-                                |db| {\n-                                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                        let rty_and_mut = ty::TypeAndMut {\n-                                            ty: rty,\n-                                            mutbl: rty_mutbl,\n-                                        };\n+                match (&from_ty.kind, &to_ty.kind) {\n+                    _ if from_ty == to_ty => span_lint(\n+                        cx,\n+                        USELESS_TRANSMUTE,\n+                        e.span,\n+                        &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n+                    ),\n+                    (&ty::Ref(_, rty, rty_mutbl), &ty::RawPtr(ptr_ty)) => span_lint_and_then(\n+                        cx,\n+                        USELESS_TRANSMUTE,\n+                        e.span,\n+                        \"transmute from a reference to a pointer\",\n+                        |db| {\n+                            if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                let rty_and_mut = ty::TypeAndMut {\n+                                    ty: rty,\n+                                    mutbl: rty_mutbl,\n+                                };\n \n-                                        let sugg = if ptr_ty == rty_and_mut {\n-                                            arg.as_ty(to_ty)\n-                                        } else {\n-                                            arg.as_ty(cx.tcx.mk_ptr(rty_and_mut)).as_ty(to_ty)\n-                                        };\n+                                let sugg = if ptr_ty == rty_and_mut {\n+                                    arg.as_ty(to_ty)\n+                                } else {\n+                                    arg.as_ty(cx.tcx.mk_ptr(rty_and_mut)).as_ty(to_ty)\n+                                };\n \n-                                        db.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n-                                    }\n-                                },\n-                            ),\n-                            (&ty::Int(_), &ty::RawPtr(_)) | (&ty::Uint(_), &ty::RawPtr(_)) => span_lint_and_then(\n-                                cx,\n-                                USELESS_TRANSMUTE,\n-                                e.span,\n-                                \"transmute from an integer to a pointer\",\n-                                |db| {\n-                                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                        db.span_suggestion(\n-                                            e.span,\n-                                            \"try\",\n-                                            arg.as_ty(&to_ty.to_string()).to_string(),\n-                                            Applicability::Unspecified,\n-                                        );\n-                                    }\n-                                },\n-                            ),\n-                            (&ty::Float(_), &ty::Ref(..))\n-                            | (&ty::Float(_), &ty::RawPtr(_))\n-                            | (&ty::Char, &ty::Ref(..))\n-                            | (&ty::Char, &ty::RawPtr(_)) => span_lint(\n-                                cx,\n-                                WRONG_TRANSMUTE,\n-                                e.span,\n-                                &format!(\"transmute from a `{}` to a pointer\", from_ty),\n-                            ),\n-                            (&ty::RawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n-                                cx,\n-                                CROSSPOINTER_TRANSMUTE,\n-                                e.span,\n-                                &format!(\n-                                    \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n-                                    from_ty, to_ty\n-                                ),\n-                            ),\n-                            (_, &ty::RawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n-                                cx,\n-                                CROSSPOINTER_TRANSMUTE,\n-                                e.span,\n-                                &format!(\n-                                    \"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n-                                    from_ty, to_ty\n-                                ),\n-                            ),\n-                            (&ty::RawPtr(from_pty), &ty::Ref(_, to_ref_ty, mutbl)) => span_lint_and_then(\n-                                cx,\n-                                TRANSMUTE_PTR_TO_REF,\n-                                e.span,\n-                                &format!(\n-                                    \"transmute from a pointer type (`{}`) to a reference type \\\n-                                     (`{}`)\",\n-                                    from_ty, to_ty\n-                                ),\n-                                |db| {\n-                                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                    let (deref, cast) = if mutbl == Mutability::MutMutable {\n-                                        (\"&mut *\", \"*mut\")\n-                                    } else {\n-                                        (\"&*\", \"*const\")\n-                                    };\n+                                db.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n+                            }\n+                        },\n+                    ),\n+                    (&ty::Int(_), &ty::RawPtr(_)) | (&ty::Uint(_), &ty::RawPtr(_)) => span_lint_and_then(\n+                        cx,\n+                        USELESS_TRANSMUTE,\n+                        e.span,\n+                        \"transmute from an integer to a pointer\",\n+                        |db| {\n+                            if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                db.span_suggestion(\n+                                    e.span,\n+                                    \"try\",\n+                                    arg.as_ty(&to_ty.to_string()).to_string(),\n+                                    Applicability::Unspecified,\n+                                );\n+                            }\n+                        },\n+                    ),\n+                    (&ty::Float(_), &ty::Ref(..))\n+                    | (&ty::Float(_), &ty::RawPtr(_))\n+                    | (&ty::Char, &ty::Ref(..))\n+                    | (&ty::Char, &ty::RawPtr(_)) => span_lint(\n+                        cx,\n+                        WRONG_TRANSMUTE,\n+                        e.span,\n+                        &format!(\"transmute from a `{}` to a pointer\", from_ty),\n+                    ),\n+                    (&ty::RawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n+                        cx,\n+                        CROSSPOINTER_TRANSMUTE,\n+                        e.span,\n+                        &format!(\n+                            \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n+                            from_ty, to_ty\n+                        ),\n+                    ),\n+                    (_, &ty::RawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n+                        cx,\n+                        CROSSPOINTER_TRANSMUTE,\n+                        e.span,\n+                        &format!(\n+                            \"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n+                            from_ty, to_ty\n+                        ),\n+                    ),\n+                    (&ty::RawPtr(from_pty), &ty::Ref(_, to_ref_ty, mutbl)) => span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_PTR_TO_REF,\n+                        e.span,\n+                        &format!(\n+                            \"transmute from a pointer type (`{}`) to a reference type \\\n+                             (`{}`)\",\n+                            from_ty, to_ty\n+                        ),\n+                        |db| {\n+                            let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                            let (deref, cast) = if mutbl == Mutability::MutMutable {\n+                                (\"&mut *\", \"*mut\")\n+                            } else {\n+                                (\"&*\", \"*const\")\n+                            };\n \n-                                    let arg = if from_pty.ty == to_ref_ty {\n-                                        arg\n-                                    } else {\n-                                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_ref_ty)))\n-                                    };\n+                            let arg = if from_pty.ty == to_ref_ty {\n+                                arg\n+                            } else {\n+                                arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_ref_ty)))\n+                            };\n \n-                                    db.span_suggestion(\n-                                        e.span,\n-                                        \"try\",\n-                                        sugg::make_unop(deref, arg).to_string(),\n-                                        Applicability::Unspecified,\n-                                    );\n-                                },\n-                            ),\n-                            (&ty::Int(ast::IntTy::I32), &ty::Char) | (&ty::Uint(ast::UintTy::U32), &ty::Char) => {\n-                                span_lint_and_then(\n-                                    cx,\n-                                    TRANSMUTE_INT_TO_CHAR,\n+                            db.span_suggestion(\n+                                e.span,\n+                                \"try\",\n+                                sugg::make_unop(deref, arg).to_string(),\n+                                Applicability::Unspecified,\n+                            );\n+                        },\n+                    ),\n+                    (&ty::Int(ast::IntTy::I32), &ty::Char) | (&ty::Uint(ast::UintTy::U32), &ty::Char) => {\n+                        span_lint_and_then(\n+                            cx,\n+                            TRANSMUTE_INT_TO_CHAR,\n+                            e.span,\n+                            &format!(\"transmute from a `{}` to a `char`\", from_ty),\n+                            |db| {\n+                                let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                                let arg = if let ty::Int(_) = from_ty.kind {\n+                                    arg.as_ty(ast::UintTy::U32)\n+                                } else {\n+                                    arg\n+                                };\n+                                db.span_suggestion(\n                                     e.span,\n-                                    &format!(\"transmute from a `{}` to a `char`\", from_ty),\n-                                    |db| {\n-                                        let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                        let arg = if let ty::Int(_) = from_ty.kind {\n-                                            arg.as_ty(ast::UintTy::U32)\n-                                        } else {\n-                                            arg\n-                                        };\n-                                        db.span_suggestion(\n-                                            e.span,\n-                                            \"consider using\",\n-                                            format!(\"std::char::from_u32({}).unwrap()\", arg.to_string()),\n-                                            Applicability::Unspecified,\n-                                        );\n-                                    },\n-                                )\n+                                    \"consider using\",\n+                                    format!(\"std::char::from_u32({}).unwrap()\", arg.to_string()),\n+                                    Applicability::Unspecified,\n+                                );\n                             },\n-                            (&ty::Ref(_, ty_from, from_mutbl), &ty::Ref(_, ty_to, to_mutbl)) => {\n-                                if_chain! {\n-                                    if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind, &ty_to.kind);\n-                                    if let ty::Uint(ast::UintTy::U8) = slice_ty.kind;\n-                                    if from_mutbl == to_mutbl;\n-                                    then {\n-                                        let postfix = if from_mutbl == Mutability::MutMutable {\n-                                            \"_mut\"\n-                                        } else {\n-                                            \"\"\n-                                        };\n+                        )\n+                    },\n+                    (&ty::Ref(_, ty_from, from_mutbl), &ty::Ref(_, ty_to, to_mutbl)) => {\n+                        if_chain! {\n+                            if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind, &ty_to.kind);\n+                            if let ty::Uint(ast::UintTy::U8) = slice_ty.kind;\n+                            if from_mutbl == to_mutbl;\n+                            then {\n+                                let postfix = if from_mutbl == Mutability::MutMutable {\n+                                    \"_mut\"\n+                                } else {\n+                                    \"\"\n+                                };\n \n-                                        span_lint_and_then(\n-                                            cx,\n-                                            TRANSMUTE_BYTES_TO_STR,\n-                                            e.span,\n-                                            &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n-                                            |db| {\n-                                                db.span_suggestion(\n-                                                    e.span,\n-                                                    \"consider using\",\n-                                                    format!(\n-                                                        \"std::str::from_utf8{}({}).unwrap()\",\n-                                                        postfix,\n-                                                        snippet(cx, args[0].span, \"..\"),\n-                                                    ),\n-                                                    Applicability::Unspecified,\n-                                                );\n-                                            }\n-                                        )\n-                                    } else {\n-                                        if cx.tcx.erase_regions(&from_ty) != cx.tcx.erase_regions(&to_ty) {\n-                                            span_lint_and_then(\n-                                                cx,\n-                                                TRANSMUTE_PTR_TO_PTR,\n-                                                e.span,\n-                                                \"transmute from a reference to a reference\",\n-                                                |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                                    let ty_from_and_mut = ty::TypeAndMut {\n-                                                        ty: ty_from,\n-                                                        mutbl: from_mutbl\n-                                                    };\n-                                                    let ty_to_and_mut = ty::TypeAndMut { ty: ty_to, mutbl: to_mutbl };\n-                                                    let sugg_paren = arg\n-                                                        .as_ty(cx.tcx.mk_ptr(ty_from_and_mut))\n-                                                        .as_ty(cx.tcx.mk_ptr(ty_to_and_mut));\n-                                                    let sugg = if to_mutbl == Mutability::MutMutable {\n-                                                        sugg_paren.mut_addr_deref()\n-                                                    } else {\n-                                                        sugg_paren.addr_deref()\n-                                                    };\n-                                                    db.span_suggestion(\n-                                                        e.span,\n-                                                        \"try\",\n-                                                        sugg.to_string(),\n-                                                        Applicability::Unspecified,\n-                                                    );\n-                                                },\n-                                            )\n-                                        }\n-                                    }\n-                                }\n-                            },\n-                            (&ty::RawPtr(_), &ty::RawPtr(to_ty)) => span_lint_and_then(\n-                                cx,\n-                                TRANSMUTE_PTR_TO_PTR,\n-                                e.span,\n-                                \"transmute from a pointer to a pointer\",\n-                                |db| {\n-                                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                        let sugg = arg.as_ty(cx.tcx.mk_ptr(to_ty));\n-                                        db.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n-                                    }\n-                                },\n-                            ),\n-                            (&ty::Int(ast::IntTy::I8), &ty::Bool) | (&ty::Uint(ast::UintTy::U8), &ty::Bool) => {\n                                 span_lint_and_then(\n                                     cx,\n-                                    TRANSMUTE_INT_TO_BOOL,\n+                                    TRANSMUTE_BYTES_TO_STR,\n                                     e.span,\n-                                    &format!(\"transmute from a `{}` to a `bool`\", from_ty),\n+                                    &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n                                     |db| {\n-                                        let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                        let zero = sugg::Sugg::NonParen(Cow::from(\"0\"));\n                                         db.span_suggestion(\n                                             e.span,\n                                             \"consider using\",\n-                                            sugg::make_binop(ast::BinOpKind::Ne, &arg, &zero).to_string(),\n+                                            format!(\n+                                                \"std::str::from_utf8{}({}).unwrap()\",\n+                                                postfix,\n+                                                snippet(cx, args[0].span, \"..\"),\n+                                            ),\n                                             Applicability::Unspecified,\n                                         );\n-                                    },\n+                                    }\n                                 )\n+                            } else {\n+                                if cx.tcx.erase_regions(&from_ty) != cx.tcx.erase_regions(&to_ty) {\n+                                    span_lint_and_then(\n+                                        cx,\n+                                        TRANSMUTE_PTR_TO_PTR,\n+                                        e.span,\n+                                        \"transmute from a reference to a reference\",\n+                                        |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                            let ty_from_and_mut = ty::TypeAndMut {\n+                                                ty: ty_from,\n+                                                mutbl: from_mutbl\n+                                            };\n+                                            let ty_to_and_mut = ty::TypeAndMut { ty: ty_to, mutbl: to_mutbl };\n+                                            let sugg_paren = arg\n+                                                .as_ty(cx.tcx.mk_ptr(ty_from_and_mut))\n+                                                .as_ty(cx.tcx.mk_ptr(ty_to_and_mut));\n+                                            let sugg = if to_mutbl == Mutability::MutMutable {\n+                                                sugg_paren.mut_addr_deref()\n+                                            } else {\n+                                                sugg_paren.addr_deref()\n+                                            };\n+                                            db.span_suggestion(\n+                                                e.span,\n+                                                \"try\",\n+                                                sugg.to_string(),\n+                                                Applicability::Unspecified,\n+                                            );\n+                                        },\n+                                    )\n+                                }\n+                            }\n+                        }\n+                    },\n+                    (&ty::RawPtr(_), &ty::RawPtr(to_ty)) => span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_PTR_TO_PTR,\n+                        e.span,\n+                        \"transmute from a pointer to a pointer\",\n+                        |db| {\n+                            if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                let sugg = arg.as_ty(cx.tcx.mk_ptr(to_ty));\n+                                db.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n+                            }\n+                        },\n+                    ),\n+                    (&ty::Int(ast::IntTy::I8), &ty::Bool) | (&ty::Uint(ast::UintTy::U8), &ty::Bool) => {\n+                        span_lint_and_then(\n+                            cx,\n+                            TRANSMUTE_INT_TO_BOOL,\n+                            e.span,\n+                            &format!(\"transmute from a `{}` to a `bool`\", from_ty),\n+                            |db| {\n+                                let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                                let zero = sugg::Sugg::NonParen(Cow::from(\"0\"));\n+                                db.span_suggestion(\n+                                    e.span,\n+                                    \"consider using\",\n+                                    sugg::make_binop(ast::BinOpKind::Ne, &arg, &zero).to_string(),\n+                                    Applicability::Unspecified,\n+                                );\n                             },\n-                            (&ty::Int(_), &ty::Float(_)) | (&ty::Uint(_), &ty::Float(_)) => span_lint_and_then(\n+                        )\n+                    },\n+                    (&ty::Int(_), &ty::Float(_)) | (&ty::Uint(_), &ty::Float(_)) => span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_INT_TO_FLOAT,\n+                        e.span,\n+                        &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                        |db| {\n+                            let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                            let arg = if let ty::Int(int_ty) = from_ty.kind {\n+                                arg.as_ty(format!(\n+                                    \"u{}\",\n+                                    int_ty.bit_width().map_or_else(|| \"size\".to_string(), |v| v.to_string())\n+                                ))\n+                            } else {\n+                                arg\n+                            };\n+                            db.span_suggestion(\n+                                e.span,\n+                                \"consider using\",\n+                                format!(\"{}::from_bits({})\", to_ty, arg.to_string()),\n+                                Applicability::Unspecified,\n+                            );\n+                        },\n+                    ),\n+                    (&ty::Adt(ref from_adt, ref from_substs), &ty::Adt(ref to_adt, ref to_substs)) => {\n+                        if from_adt.did != to_adt.did ||\n+                                !COLLECTIONS.iter().any(|path| match_def_path(cx, to_adt.did, path)) {\n+                            return;\n+                        }\n+                        if from_substs.types().zip(to_substs.types())\n+                                              .any(|(from_ty, to_ty)| is_layout_incompatible(cx, from_ty, to_ty)) {\n+                            span_lint(\n                                 cx,\n-                                TRANSMUTE_INT_TO_FLOAT,\n+                                UNSOUND_COLLECTION_TRANSMUTE,\n                                 e.span,\n-                                &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n-                                |db| {\n-                                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                    let arg = if let ty::Int(int_ty) = from_ty.kind {\n-                                        arg.as_ty(format!(\n-                                            \"u{}\",\n-                                            int_ty.bit_width().map_or_else(|| \"size\".to_string(), |v| v.to_string())\n-                                        ))\n-                                    } else {\n-                                        arg\n-                                    };\n-                                    db.span_suggestion(\n-                                        e.span,\n-                                        \"consider using\",\n-                                        format!(\"{}::from_bits({})\", to_ty, arg.to_string()),\n-                                        Applicability::Unspecified,\n-                                    );\n-                                },\n-                            ),\n-                            _ => return,\n-                        };\n-                    }\n+                                &format!(\n+                                    \"transmute from `{}` to `{}` with mismatched layout is unsound\",\n+                                    from_ty,\n+                                    to_ty\n+                                )\n+                            );\n+                        }\n+                    },\n+                    _ => return,\n                 }\n             }\n         }\n@@ -510,3 +567,16 @@ fn get_type_snippet(cx: &LateContext<'_, '_>, path: &QPath, to_ref_ty: Ty<'_>) -\n \n     to_ref_ty.to_string()\n }\n+\n+// check if the component types of the transmuted collection and the result have different ABI,\n+// size or alignment\n+fn is_layout_incompatible<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n+    let from_ty_layout = cx.tcx.layout_of(ty::ParamEnv::empty().and(from));\n+    let to_ty_layout = cx.tcx.layout_of(ty::ParamEnv::empty().and(to));\n+    if let (Ok(from_layout), Ok(to_layout)) = (from_ty_layout, to_ty_layout) {\n+        from_layout.size != to_layout.size || from_layout.align != to_layout.align || from_layout.abi != to_layout.abi\n+    } else {\n+        // no idea about layout, so don't lint\n+        false\n+    }\n+}"}, {"sha": "002709ac0d48f76c34268e1669c14fc53b48b61a", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/27fa2b7944d79c1fa16445628fef268bdb34f625/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27fa2b7944d79c1fa16445628fef268bdb34f625/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=27fa2b7944d79c1fa16445628fef268bdb34f625", "patch": "@@ -6,7 +6,7 @@ pub use lint::Lint;\n pub use lint::LINT_LEVELS;\n \n // begin lint list, do not remove this comment, it\u2019s used in `update_lints`\n-pub const ALL_LINTS: [Lint; 318] = [\n+pub const ALL_LINTS: [Lint; 319] = [\n     Lint {\n         name: \"absurd_extreme_comparisons\",\n         group: \"correctness\",\n@@ -2030,6 +2030,13 @@ pub const ALL_LINTS: [Lint; 318] = [\n         deprecation: None,\n         module: \"misc_early\",\n     },\n+    Lint {\n+        name: \"unsound_collection_transmute\",\n+        group: \"correctness\",\n+        desc: \"transmute between collections of layout-incompatible types\",\n+        deprecation: None,\n+        module: \"transmute\",\n+    },\n     Lint {\n         name: \"unused_io_amount\",\n         group: \"correctness\","}, {"sha": "4f0c2f5a895cbf76a685205a4fddea933d990b83", "filename": "tests/ui/transmute.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27fa2b7944d79c1fa16445628fef268bdb34f625/tests%2Fui%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27fa2b7944d79c1fa16445628fef268bdb34f625/tests%2Fui%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute.rs?ref=27fa2b7944d79c1fa16445628fef268bdb34f625", "patch": "@@ -80,12 +80,6 @@ fn useless() {\n \n         let _: Vec<i32> = my_transmute(my_vec());\n \n-        let _: Vec<u32> = core::intrinsics::transmute(my_vec());\n-        let _: Vec<u32> = core::mem::transmute(my_vec());\n-        let _: Vec<u32> = std::intrinsics::transmute(my_vec());\n-        let _: Vec<u32> = std::mem::transmute(my_vec());\n-        let _: Vec<u32> = my_transmute(my_vec());\n-\n         let _: *const usize = std::mem::transmute(5_isize);\n \n         let _ = 5_isize as *const usize;"}, {"sha": "f73d72f20bb3fc750922cc999c1c843d4de811f3", "filename": "tests/ui/transmute.stderr", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/27fa2b7944d79c1fa16445628fef268bdb34f625/tests%2Fui%2Ftransmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27fa2b7944d79c1fa16445628fef268bdb34f625/tests%2Fui%2Ftransmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute.stderr?ref=27fa2b7944d79c1fa16445628fef268bdb34f625", "patch": "@@ -117,127 +117,127 @@ LL |         let _: Vec<i32> = my_transmute(my_vec());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from an integer to a pointer\n-  --> $DIR/transmute.rs:89:31\n+  --> $DIR/transmute.rs:83:31\n    |\n LL |         let _: *const usize = std::mem::transmute(5_isize);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `5_isize as *const usize`\n \n error: transmute from an integer to a pointer\n-  --> $DIR/transmute.rs:93:31\n+  --> $DIR/transmute.rs:87:31\n    |\n LL |         let _: *const usize = std::mem::transmute(1 + 1usize);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(1 + 1usize) as *const usize`\n \n error: transmute from a type (`*const Usize`) to the type that it points to (`Usize`)\n-  --> $DIR/transmute.rs:108:24\n+  --> $DIR/transmute.rs:102:24\n    |\n LL |         let _: Usize = core::intrinsics::transmute(int_const_ptr);\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::crosspointer-transmute` implied by `-D warnings`\n \n error: transmute from a type (`*mut Usize`) to the type that it points to (`Usize`)\n-  --> $DIR/transmute.rs:110:24\n+  --> $DIR/transmute.rs:104:24\n    |\n LL |         let _: Usize = core::intrinsics::transmute(int_mut_ptr);\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`Usize`) to a pointer to that type (`*const Usize`)\n-  --> $DIR/transmute.rs:112:31\n+  --> $DIR/transmute.rs:106:31\n    |\n LL |         let _: *const Usize = core::intrinsics::transmute(my_int());\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a type (`Usize`) to a pointer to that type (`*mut Usize`)\n-  --> $DIR/transmute.rs:114:29\n+  --> $DIR/transmute.rs:108:29\n    |\n LL |         let _: *mut Usize = core::intrinsics::transmute(my_int());\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from a `u32` to a `char`\n-  --> $DIR/transmute.rs:120:28\n+  --> $DIR/transmute.rs:114:28\n    |\n LL |     let _: char = unsafe { std::mem::transmute(0_u32) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::char::from_u32(0_u32).unwrap()`\n    |\n    = note: `-D clippy::transmute-int-to-char` implied by `-D warnings`\n \n error: transmute from a `i32` to a `char`\n-  --> $DIR/transmute.rs:121:28\n+  --> $DIR/transmute.rs:115:28\n    |\n LL |     let _: char = unsafe { std::mem::transmute(0_i32) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::char::from_u32(0_i32 as u32).unwrap()`\n \n error: transmute from a `u8` to a `bool`\n-  --> $DIR/transmute.rs:126:28\n+  --> $DIR/transmute.rs:120:28\n    |\n LL |     let _: bool = unsafe { std::mem::transmute(0_u8) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `0_u8 != 0`\n    |\n    = note: `-D clippy::transmute-int-to-bool` implied by `-D warnings`\n \n error: transmute from a `u32` to a `f32`\n-  --> $DIR/transmute.rs:131:27\n+  --> $DIR/transmute.rs:125:27\n    |\n LL |     let _: f32 = unsafe { std::mem::transmute(0_u32) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f32::from_bits(0_u32)`\n    |\n    = note: `-D clippy::transmute-int-to-float` implied by `-D warnings`\n \n error: transmute from a `i32` to a `f32`\n-  --> $DIR/transmute.rs:132:27\n+  --> $DIR/transmute.rs:126:27\n    |\n LL |     let _: f32 = unsafe { std::mem::transmute(0_i32) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `f32::from_bits(0_i32 as u32)`\n \n error: transmute from a `&[u8]` to a `&str`\n-  --> $DIR/transmute.rs:136:28\n+  --> $DIR/transmute.rs:130:28\n    |\n LL |     let _: &str = unsafe { std::mem::transmute(b) };\n    |                            ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::str::from_utf8(b).unwrap()`\n    |\n    = note: `-D clippy::transmute-bytes-to-str` implied by `-D warnings`\n \n error: transmute from a `&mut [u8]` to a `&mut str`\n-  --> $DIR/transmute.rs:137:32\n+  --> $DIR/transmute.rs:131:32\n    |\n LL |     let _: &mut str = unsafe { std::mem::transmute(mb) };\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::str::from_utf8_mut(mb).unwrap()`\n \n error: transmute from a pointer to a pointer\n-  --> $DIR/transmute.rs:169:29\n+  --> $DIR/transmute.rs:163:29\n    |\n LL |         let _: *const f32 = std::mem::transmute(ptr);\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr as *const f32`\n    |\n    = note: `-D clippy::transmute-ptr-to-ptr` implied by `-D warnings`\n \n error: transmute from a pointer to a pointer\n-  --> $DIR/transmute.rs:170:27\n+  --> $DIR/transmute.rs:164:27\n    |\n LL |         let _: *mut f32 = std::mem::transmute(mut_ptr);\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `mut_ptr as *mut f32`\n \n error: transmute from a reference to a reference\n-  --> $DIR/transmute.rs:172:23\n+  --> $DIR/transmute.rs:166:23\n    |\n LL |         let _: &f32 = std::mem::transmute(&1u32);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(&1u32 as *const u32 as *const f32)`\n \n error: transmute from a reference to a reference\n-  --> $DIR/transmute.rs:173:23\n+  --> $DIR/transmute.rs:167:23\n    |\n LL |         let _: &f64 = std::mem::transmute(&1f32);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(&1f32 as *const f32 as *const f64)`\n \n error: transmute from a reference to a reference\n-  --> $DIR/transmute.rs:176:27\n+  --> $DIR/transmute.rs:170:27\n    |\n LL |         let _: &mut f32 = std::mem::transmute(&mut 1u32);\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&mut *(&mut 1u32 as *mut u32 as *mut f32)`\n \n error: transmute from a reference to a reference\n-  --> $DIR/transmute.rs:177:37\n+  --> $DIR/transmute.rs:171:37\n    |\n LL |         let _: &GenericParam<f32> = std::mem::transmute(&GenericParam { t: 1u32 });\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(&GenericParam { t: 1u32 } as *const GenericParam<u32> as *const GenericParam<f32>)`"}, {"sha": "cd5a7127791a86784fe8332d91c2589e9ba10d49", "filename": "tests/ui/transmute_collection.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/27fa2b7944d79c1fa16445628fef268bdb34f625/tests%2Fui%2Ftransmute_collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27fa2b7944d79c1fa16445628fef268bdb34f625/tests%2Fui%2Ftransmute_collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_collection.rs?ref=27fa2b7944d79c1fa16445628fef268bdb34f625", "patch": "@@ -0,0 +1,47 @@\n+#![warn(clippy::unsound_collection_transmute)]\n+\n+use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n+use std::mem::transmute;\n+\n+fn main() {\n+    unsafe {\n+        // wrong size\n+        let _ = transmute::<_, Vec<u32>>(vec![0u8]);\n+        // wrong layout\n+        let _ = transmute::<_, Vec<[u8; 4]>>(vec![1234u32]);\n+\n+        // wrong size\n+        let _ = transmute::<_, VecDeque<u32>>(VecDeque::<u8>::new());\n+        // wrong layout\n+        let _ = transmute::<_, VecDeque<u32>>(VecDeque::<[u8; 4]>::new());\n+\n+        // wrong size\n+        let _ = transmute::<_, BinaryHeap<u32>>(BinaryHeap::<u8>::new());\n+        // wrong layout\n+        let _ = transmute::<_, BinaryHeap<u32>>(BinaryHeap::<[u8; 4]>::new());\n+\n+        // wrong size\n+        let _ = transmute::<_, BTreeSet<u32>>(BTreeSet::<u8>::new());\n+        // wrong layout\n+        let _ = transmute::<_, BTreeSet<u32>>(BTreeSet::<[u8; 4]>::new());\n+\n+        // wrong size\n+        let _ = transmute::<_, HashSet<u32>>(HashSet::<u8>::new());\n+        // wrong layout\n+        let _ = transmute::<_, HashSet<u32>>(HashSet::<[u8; 4]>::new());\n+\n+        // wrong size\n+        let _ = transmute::<_, BTreeMap<u8, u32>>(BTreeMap::<u8, u8>::new());\n+        let _ = transmute::<_, BTreeMap<u8, u32>>(BTreeMap::<u32, u32>::new());\n+        // wrong layout\n+        let _ = transmute::<_, BTreeMap<u8, u32>>(BTreeMap::<u8, [u8; 4]>::new());\n+        let _ = transmute::<_, BTreeMap<u32, u32>>(BTreeMap::<[u8; 4], u32>::new());\n+\n+        // wrong size\n+        let _ = transmute::<_, HashMap<u8, u32>>(HashMap::<u8, u8>::new());\n+        let _ = transmute::<_, HashMap<u8, u32>>(HashMap::<u32, u32>::new());\n+        // wrong layout\n+        let _ = transmute::<_, HashMap<u8, u32>>(HashMap::<u8, [u8; 4]>::new());\n+        let _ = transmute::<_, HashMap<u32, u32>>(HashMap::<[u8; 4], u32>::new());\n+    }\n+}"}, {"sha": "ebc05c402abf69b9e0856083c46286677db22e20", "filename": "tests/ui/transmute_collection.stderr", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/27fa2b7944d79c1fa16445628fef268bdb34f625/tests%2Fui%2Ftransmute_collection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27fa2b7944d79c1fa16445628fef268bdb34f625/tests%2Fui%2Ftransmute_collection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_collection.stderr?ref=27fa2b7944d79c1fa16445628fef268bdb34f625", "patch": "@@ -0,0 +1,112 @@\n+error: transmute from `std::vec::Vec<u8>` to `std::vec::Vec<u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:9:17\n+   |\n+LL |         let _ = transmute::<_, Vec<u32>>(vec![0u8]);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unsound-collection-transmute` implied by `-D warnings`\n+\n+error: transmute from `std::vec::Vec<u32>` to `std::vec::Vec<[u8; 4]>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:11:17\n+   |\n+LL |         let _ = transmute::<_, Vec<[u8; 4]>>(vec![1234u32]);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::VecDeque<u8>` to `std::collections::VecDeque<u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:14:17\n+   |\n+LL |         let _ = transmute::<_, VecDeque<u32>>(VecDeque::<u8>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::VecDeque<[u8; 4]>` to `std::collections::VecDeque<u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:16:17\n+   |\n+LL |         let _ = transmute::<_, VecDeque<u32>>(VecDeque::<[u8; 4]>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::BinaryHeap<u8>` to `std::collections::BinaryHeap<u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:19:17\n+   |\n+LL |         let _ = transmute::<_, BinaryHeap<u32>>(BinaryHeap::<u8>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::BinaryHeap<[u8; 4]>` to `std::collections::BinaryHeap<u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:21:17\n+   |\n+LL |         let _ = transmute::<_, BinaryHeap<u32>>(BinaryHeap::<[u8; 4]>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::BTreeSet<u8>` to `std::collections::BTreeSet<u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:24:17\n+   |\n+LL |         let _ = transmute::<_, BTreeSet<u32>>(BTreeSet::<u8>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::BTreeSet<[u8; 4]>` to `std::collections::BTreeSet<u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:26:17\n+   |\n+LL |         let _ = transmute::<_, BTreeSet<u32>>(BTreeSet::<[u8; 4]>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::HashSet<u8>` to `std::collections::HashSet<u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:29:17\n+   |\n+LL |         let _ = transmute::<_, HashSet<u32>>(HashSet::<u8>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::HashSet<[u8; 4]>` to `std::collections::HashSet<u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:31:17\n+   |\n+LL |         let _ = transmute::<_, HashSet<u32>>(HashSet::<[u8; 4]>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::BTreeMap<u8, u8>` to `std::collections::BTreeMap<u8, u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:34:17\n+   |\n+LL |         let _ = transmute::<_, BTreeMap<u8, u32>>(BTreeMap::<u8, u8>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::BTreeMap<u32, u32>` to `std::collections::BTreeMap<u8, u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:35:17\n+   |\n+LL |         let _ = transmute::<_, BTreeMap<u8, u32>>(BTreeMap::<u32, u32>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::BTreeMap<u8, [u8; 4]>` to `std::collections::BTreeMap<u8, u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:37:17\n+   |\n+LL |         let _ = transmute::<_, BTreeMap<u8, u32>>(BTreeMap::<u8, [u8; 4]>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::BTreeMap<[u8; 4], u32>` to `std::collections::BTreeMap<u32, u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:38:17\n+   |\n+LL |         let _ = transmute::<_, BTreeMap<u32, u32>>(BTreeMap::<[u8; 4], u32>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::HashMap<u8, u8>` to `std::collections::HashMap<u8, u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:41:17\n+   |\n+LL |         let _ = transmute::<_, HashMap<u8, u32>>(HashMap::<u8, u8>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::HashMap<u32, u32>` to `std::collections::HashMap<u8, u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:42:17\n+   |\n+LL |         let _ = transmute::<_, HashMap<u8, u32>>(HashMap::<u32, u32>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::HashMap<u8, [u8; 4]>` to `std::collections::HashMap<u8, u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:44:17\n+   |\n+LL |         let _ = transmute::<_, HashMap<u8, u32>>(HashMap::<u8, [u8; 4]>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `std::collections::HashMap<[u8; 4], u32>` to `std::collections::HashMap<u32, u32>` with mismatched layout is unsound\n+  --> $DIR/transmute_collection.rs:45:17\n+   |\n+LL |         let _ = transmute::<_, HashMap<u32, u32>>(HashMap::<[u8; 4], u32>::new());\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 18 previous errors\n+"}]}