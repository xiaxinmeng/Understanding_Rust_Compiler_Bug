{"sha": "b7f6d7239b03d1f7b8a9713412e1b74364879432", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZjZkNzIzOWIwM2QxZjdiOGE5NzEzNDEyZTFiNzQzNjQ4Nzk0MzI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-12T07:48:51Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-12T07:48:51Z"}, "message": "Rollup merge of #29776 - nikomatsakis:mir-29740, r=nrc\n\nIn previous PRs, I changed the match desugaring to generate more efficient code for ints/chars and the like. But this doesn't help when you're matching strings, ranges, or other crazy complex things (leading to #29740). This commit restructures match desugaring *yet again* to handle that case better -- basically we now degenerate to an if-else-if chain in such cases.\n\n~~Note that this builds on https://github.com/rust-lang/rust/pull/29763 which will hopefully land soon. So ignore the first few commits.~~ landed now\n\nr? @Aatch since he's been reviewing the other commits in this series", "tree": {"sha": "19a1945751369cdba951ed52a2a915a05b61bd5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19a1945751369cdba951ed52a2a915a05b61bd5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7f6d7239b03d1f7b8a9713412e1b74364879432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7f6d7239b03d1f7b8a9713412e1b74364879432", "html_url": "https://github.com/rust-lang/rust/commit/b7f6d7239b03d1f7b8a9713412e1b74364879432", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7f6d7239b03d1f7b8a9713412e1b74364879432/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35decad78124b251822eb4666638455224d3f0c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/35decad78124b251822eb4666638455224d3f0c8", "html_url": "https://github.com/rust-lang/rust/commit/35decad78124b251822eb4666638455224d3f0c8"}, {"sha": "a5e3625a552b3568343aa2affb81dba45f91054c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5e3625a552b3568343aa2affb81dba45f91054c", "html_url": "https://github.com/rust-lang/rust/commit/a5e3625a552b3568343aa2affb81dba45f91054c"}], "stats": {"total": 583, "additions": 535, "deletions": 48}, "files": [{"sha": "cc8549de26a6c164375138c6d5cbb7174dc605f6", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 184, "deletions": 23, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/b7f6d7239b03d1f7b8a9713412e1b74364879432/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f6d7239b03d1f7b8a9713412e1b74364879432/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=b7f6d7239b03d1f7b8a9713412e1b74364879432", "patch": "@@ -85,7 +85,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         // this will generate code to test discriminant_lvalue and\n         // branch to the appropriate arm block\n-        self.match_candidates(span, &mut arm_blocks, candidates, block);\n+        let otherwise = self.match_candidates(span, &mut arm_blocks, candidates, block);\n+\n+        // because all matches are exhaustive, in principle we expect\n+        // an empty vector to be returned here, but the algorithm is\n+        // not entirely precise\n+        if !otherwise.is_empty() {\n+            let join_block = self.join_otherwise_blocks(otherwise);\n+            self.panic(join_block);\n+        }\n \n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n@@ -279,11 +287,32 @@ struct Test<'tcx> {\n // Main matching algorithm\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n+    /// The main match algorithm. It begins with a set of candidates\n+    /// `candidates` and has the job of generating code to determine\n+    /// which of these candidates, if any, is the correct one. The\n+    /// candidates are sorted in inverse priority -- so the last item\n+    /// in the list has highest priority. When a candidate is found to\n+    /// match the value, we will generate a branch to the appropriate\n+    /// block found in `arm_blocks`.\n+    ///\n+    /// The return value is a list of \"otherwise\" blocks. These are\n+    /// points in execution where we found that *NONE* of the\n+    /// candidates apply.  In principle, this means that the input\n+    /// list was not exhaustive, though at present we sometimes are\n+    /// not smart enough to recognize all exhaustive inputs.\n+    ///\n+    /// It might be surprising that the input can be inexhaustive.\n+    /// Indeed, initially, it is not, because all matches are\n+    /// exhaustive in Rust. But during processing we sometimes divide\n+    /// up the list of candidates and recurse with a non-exhaustive\n+    /// list. This is important to keep the size of the generated code\n+    /// under control. See `test_candidates` for more details.\n     fn match_candidates<'pat>(&mut self,\n                               span: Span,\n                               arm_blocks: &mut ArmBlocks,\n                               mut candidates: Vec<Candidate<'pat, 'tcx>>,\n                               mut block: BasicBlock)\n+                              -> Vec<BasicBlock>\n     {\n         debug!(\"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n                span, block, candidates);\n@@ -311,17 +340,127 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             } else {\n                 // if None is returned, then any remaining candidates\n                 // are unreachable (at least not through this path).\n-                return;\n+                return vec![];\n             }\n         }\n \n         // If there are no candidates that still need testing, we're done.\n         // Since all matches are exhaustive, execution should never reach this point.\n         if candidates.is_empty() {\n-            return self.panic(block);\n+            return vec![block];\n+        }\n+\n+        // Test candidates where possible.\n+        let (otherwise, tested_candidates) =\n+            self.test_candidates(span, arm_blocks, &candidates, block);\n+\n+        // If the target candidates were exhaustive, then we are done.\n+        if otherwise.is_empty() {\n+            return vec![];\n+        }\n+\n+        // If all candidates were sorted into `target_candidates` somewhere, then\n+        // the initial set was inexhaustive.\n+        let untested_candidates = candidates.len() - tested_candidates;\n+        if untested_candidates == 0 {\n+            return otherwise;\n         }\n \n-        // otherwise, extract the next match pair and construct tests\n+        // Otherwise, let's process those remaining candidates.\n+        let join_block = self.join_otherwise_blocks(otherwise);\n+        candidates.truncate(untested_candidates);\n+        self.match_candidates(span, arm_blocks, candidates, join_block)\n+    }\n+\n+    fn join_otherwise_blocks(&mut self,\n+                             otherwise: Vec<BasicBlock>)\n+                             -> BasicBlock\n+    {\n+        if otherwise.len() == 1 {\n+            otherwise[0]\n+        } else {\n+            let join_block = self.cfg.start_new_block();\n+            for block in otherwise {\n+                self.cfg.terminate(block, Terminator::Goto { target: join_block });\n+            }\n+            join_block\n+        }\n+    }\n+\n+    /// This is the most subtle part of the matching algorithm.  At\n+    /// this point, the input candidates have been fully simplified,\n+    /// and so we know that all remaining match-pairs require some\n+    /// sort of test. To decide what test to do, we take the highest\n+    /// priority candidate (last one in the list) and extract the\n+    /// first match-pair from the list. From this we decide what kind\n+    /// of test is needed using `test`, defined in the `test` module.\n+    ///\n+    /// *Note:* taking the first match pair is somewhat arbitrary, and\n+    /// we might do better here by choosing more carefully what to\n+    /// test.\n+    ///\n+    /// For example, consider the following possible match-pairs:\n+    ///\n+    /// 1. `x @ Some(P)` -- we will do a `Switch` to decide what variant `x` has\n+    /// 2. `x @ 22` -- we will do a `SwitchInt`\n+    /// 3. `x @ 3..5` -- we will do a range test\n+    /// 4. etc.\n+    ///\n+    /// Once we know what sort of test we are going to perform, this\n+    /// test may also help us with other candidates. So we walk over\n+    /// the candidates (from high to low priority) and check. This\n+    /// gives us, for each outcome of the test, a transformed list of\n+    /// candidates.  For example, if we are testing the current\n+    /// variant of `x.0`, and we have a candidate `{x.0 @ Some(v), x.1\n+    /// @ 22}`, then we would have a resulting candidate of `{(x.0 as\n+    /// Some).0 @ v, x.1 @ 22}`. Note that the first match-pair is now\n+    /// simpler (and, in fact, irrefutable).\n+    ///\n+    /// But there may also be candidates that the test just doesn't\n+    /// apply to. For example, consider the case of #29740:\n+    ///\n+    /// ```rust\n+    /// match x {\n+    ///     \"foo\" => ...,\n+    ///     \"bar\" => ...,\n+    ///     \"baz\" => ...,\n+    ///     _ => ...,\n+    /// }\n+    /// ```\n+    ///\n+    /// Here the match-pair we are testing will be `x @ \"foo\"`, and we\n+    /// will generate an `Eq` test. Because `\"bar\"` and `\"baz\"` are different\n+    /// constants, we will decide that these later candidates are just not\n+    /// informed by the eq test. So we'll wind up with three candidate sets:\n+    ///\n+    /// - If outcome is that `x == \"foo\"` (one candidate, derived from `x @ \"foo\"`)\n+    /// - If outcome is that `x != \"foo\"` (empty list of candidates)\n+    /// - Otherwise (three candidates, `x @ \"bar\"`, `x @ \"baz\"`, `x @\n+    ///   _`). Here we have the invariant that everything in the\n+    ///   otherwise list is of **lower priority** than the stuff in the\n+    ///   other lists.\n+    ///\n+    /// So we'll compile the test. For each outcome of the test, we\n+    /// recursively call `match_candidates` with the corresponding set\n+    /// of candidates. But note that this set is now inexhaustive: for\n+    /// example, in the case where the test returns false, there are\n+    /// NO candidates, even though there is stll a value to be\n+    /// matched. So we'll collect the return values from\n+    /// `match_candidates`, which are the blocks where control-flow\n+    /// goes if none of the candidates matched. At this point, we can\n+    /// continue with the \"otherwise\" list.\n+    ///\n+    /// If you apply this to the above test, you basically wind up\n+    /// with an if-else-if chain, testing each candidate in turn,\n+    /// which is precisely what we want.\n+    fn test_candidates<'pat>(&mut self,\n+                             span: Span,\n+                             arm_blocks: &mut ArmBlocks,\n+                             candidates: &[Candidate<'pat, 'tcx>],\n+                             block: BasicBlock)\n+                             -> (Vec<BasicBlock>, usize)\n+    {\n+        // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.last().unwrap().match_pairs[0];\n         let mut test = self.test(match_pair);\n \n@@ -331,35 +470,57 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // available\n         match test.kind {\n             TestKind::SwitchInt { switch_ty, ref mut options, ref mut indices } => {\n-                for candidate in &candidates {\n-                    self.add_cases_to_switch(&match_pair.lvalue,\n-                                             candidate,\n-                                             switch_ty,\n-                                             options,\n-                                             indices);\n+                for candidate in candidates.iter().rev() {\n+                    if !self.add_cases_to_switch(&match_pair.lvalue,\n+                                                 candidate,\n+                                                 switch_ty,\n+                                                 options,\n+                                                 indices) {\n+                        break;\n+                    }\n                 }\n             }\n             _ => { }\n         }\n \n+        // perform the test, branching to one of N blocks. For each of\n+        // those N possible outcomes, create a (initially empty)\n+        // vector of candidates. Those are the candidates that still\n+        // apply if the test has that particular outcome.\n         debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n         let target_blocks = self.perform_test(block, &match_pair.lvalue, &test);\n-\n         let mut target_candidates: Vec<_> = (0..target_blocks.len()).map(|_| vec![]).collect();\n \n-        for candidate in &candidates {\n-            self.sort_candidate(&match_pair.lvalue,\n-                                &test,\n-                                candidate,\n-                                &mut target_candidates);\n-        }\n-\n-        for (target_block, target_candidates) in\n+        // Sort the candidates into the appropriate vector in\n+        // `target_candidates`. Note that at some point we may\n+        // encounter a candidate where the test is not relevant; at\n+        // that point, we stop sorting.\n+        let tested_candidates =\n+            candidates.iter()\n+                      .rev()\n+                      .take_while(|c| self.sort_candidate(&match_pair.lvalue,\n+                                                          &test,\n+                                                          c,\n+                                                          &mut target_candidates))\n+                      .count();\n+        assert!(tested_candidates > 0); // at least the last candidate ought to be tested\n+\n+        // For each outcome of test, process the candidates that still\n+        // apply. Collect a list of blocks where control flow will\n+        // branch if one of the `target_candidate` sets is not\n+        // exhaustive.\n+        let otherwise: Vec<_> =\n             target_blocks.into_iter()\n-                         .zip(target_candidates.into_iter())\n-        {\n-            self.match_candidates(span, arm_blocks, target_candidates, target_block);\n-        }\n+                         .zip(target_candidates)\n+                         .flat_map(|(target_block, target_candidates)| {\n+                             self.match_candidates(span,\n+                                                   arm_blocks,\n+                                                   target_candidates,\n+                                                   target_block)\n+                         })\n+                         .collect();\n+\n+        (otherwise, tested_candidates)\n     }\n \n     /// Initializes each of the bindings from the candidate by"}, {"sha": "dffd83f1c415058ea3802f87f032e7074cc070b4", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b7f6d7239b03d1f7b8a9713412e1b74364879432/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f6d7239b03d1f7b8a9713412e1b74364879432/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=b7f6d7239b03d1f7b8a9713412e1b74364879432", "patch": "@@ -105,10 +105,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                      switch_ty: Ty<'tcx>,\n                                      options: &mut Vec<ConstVal>,\n                                      indices: &mut FnvHashMap<ConstVal, usize>)\n+                                     -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {\n             Some(match_pair) => match_pair,\n-            _ => { return; }\n+            _ => { return false; }\n         };\n \n         match *match_pair.pattern.kind {\n@@ -121,11 +122,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                            options.push(value.clone());\n                            options.len() - 1\n                        });\n+                true\n             }\n \n-            PatternKind::Range { .. } => {\n-            }\n-\n+            PatternKind::Range { .. } |\n             PatternKind::Constant { .. } |\n             PatternKind::Variant { .. } |\n             PatternKind::Slice { .. } |\n@@ -134,6 +134,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             PatternKind::Binding { .. } |\n             PatternKind::Leaf { .. } |\n             PatternKind::Deref { .. } => {\n+                // don't know how to add these patterns to a switch\n+                false\n             }\n         }\n     }\n@@ -284,18 +286,29 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// P0` to the `resulting_candidates` entry corresponding to the\n     /// variant `Some`.\n     ///\n-    /// In many cases we will add the `candidate` to more than one\n-    /// outcome. For example, say that the test is `x == 22`, but the\n-    /// candidate is `x @ 13..55`. In that case, if the test is true,\n-    /// then we know that the candidate applies (without this match\n-    /// pair, potentially, though we don't optimize this due to\n-    /// #29623). If the test is false, the candidate may also apply\n-    /// (with the match pair, still).\n+    /// However, in some cases, the test may just not be relevant to\n+    /// candidate. For example, suppose we are testing whether `foo.x == 22`,\n+    /// but in one match arm we have `Foo { x: _, ... }`... in that case,\n+    /// the test for what value `x` has has no particular relevance\n+    /// to this candidate. In such cases, this function just returns false\n+    /// without doing anything. This is used by the overall `match_candidates`\n+    /// algorithm to structure the match as a whole. See `match_candidates` for\n+    /// more details.\n+    ///\n+    /// FIXME(#29623). In some cases, we have some tricky choices to\n+    /// make.  for example, if we are testing that `x == 22`, but the\n+    /// candidate is `x @ 13..55`, what should we do? In the event\n+    /// that the test is true, we know that the candidate applies, but\n+    /// in the event of false, we don't know that it *doesn't*\n+    /// apply. For now, we return false, indicate that the test does\n+    /// not apply to this candidate, but it might be we can get\n+    /// tighter match code if we do something a bit different.\n     pub fn sort_candidate<'pat>(&mut self,\n                                 test_lvalue: &Lvalue<'tcx>,\n                                 test: &Test<'tcx>,\n                                 candidate: &Candidate<'pat, 'tcx>,\n-                                resulting_candidates: &mut [Vec<Candidate<'pat, 'tcx>>]) {\n+                                resulting_candidates: &mut [Vec<Candidate<'pat, 'tcx>>])\n+                                -> bool {\n         // Find the match_pair for this lvalue (if any). At present,\n         // afaik, there can be at most one. (In the future, if we\n         // adopted a more general `@` operator, there might be more\n@@ -311,7 +324,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             None => {\n                 // We are not testing this lvalue. Therefore, this\n                 // candidate applies to ALL outcomes.\n-                return self.add_to_all_candidate_sets(candidate, resulting_candidates);\n+                return false;\n             }\n         };\n \n@@ -329,9 +342,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                                                 subpatterns,\n                                                                 candidate);\n                         resulting_candidates[variant_index].push(new_candidate);\n+                        true\n                     }\n                     _ => {\n-                        self.add_to_all_candidate_sets(candidate, resulting_candidates);\n+                        false\n                     }\n                 }\n             }\n@@ -349,9 +363,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         let new_candidate = self.candidate_without_match_pair(match_pair_index,\n                                                                               candidate);\n                         resulting_candidates[index].push(new_candidate);\n+                        true\n                     }\n                     _ => {\n-                        self.add_to_all_candidate_sets(candidate, resulting_candidates);\n+                        false\n                     }\n                 }\n             }\n@@ -367,8 +382,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     let new_candidate = self.candidate_without_match_pair(match_pair_index,\n                                                                           candidate);\n                     resulting_candidates[0].push(new_candidate);\n+                    true\n                 } else {\n-                    self.add_to_all_candidate_sets(candidate, resulting_candidates);\n+                    false\n                 }\n             }\n         }\n@@ -392,14 +408,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n     }\n \n-    fn add_to_all_candidate_sets<'pat>(&mut self,\n-                                       candidate: &Candidate<'pat, 'tcx>,\n-                                       resulting_candidates: &mut [Vec<Candidate<'pat, 'tcx>>]) {\n-        for resulting_candidate in resulting_candidates {\n-            resulting_candidate.push(candidate.clone());\n-        }\n-    }\n-\n     fn candidate_after_variant_switch<'pat>(&mut self,\n                                             match_pair_index: usize,\n                                             adt_def: ty::AdtDef<'tcx>,\n@@ -447,5 +455,5 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n }\n \n fn is_switch_ty<'tcx>(ty: Ty<'tcx>) -> bool {\n-    ty.is_integral() || ty.is_char()\n+    ty.is_integral() || ty.is_char() || ty.is_bool()\n }"}, {"sha": "b20bacadf34b7c2232a5459d0849706961d49ead", "filename": "src/test/run-pass/issue-29740.rs", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/b7f6d7239b03d1f7b8a9713412e1b74364879432/src%2Ftest%2Frun-pass%2Fissue-29740.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f6d7239b03d1f7b8a9713412e1b74364879432/src%2Ftest%2Frun-pass%2Fissue-29740.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29740.rs?ref=b7f6d7239b03d1f7b8a9713412e1b74364879432", "patch": "@@ -0,0 +1,318 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #29740. Inefficient MIR matching algorithms\n+// generated way too much code for this sort of case, leading to OOM.\n+\n+// ignore-pretty\n+\n+pub mod KeyboardEventConstants {\n+    pub const DOM_KEY_LOCATION_STANDARD: u32 = 0;\n+    pub const DOM_KEY_LOCATION_LEFT: u32 = 1;\n+    pub const DOM_KEY_LOCATION_RIGHT: u32 = 2;\n+    pub const DOM_KEY_LOCATION_NUMPAD: u32 = 3;\n+} // mod KeyboardEventConstants\n+\n+pub enum Key {\n+    Space,\n+    Apostrophe,\n+    Comma,\n+    Minus,\n+    Period,\n+    Slash,\n+    Num0,\n+    Num1,\n+    Num2,\n+    Num3,\n+    Num4,\n+    Num5,\n+    Num6,\n+    Num7,\n+    Num8,\n+    Num9,\n+    Semicolon,\n+    Equal,\n+    A,\n+    B,\n+    C,\n+    D,\n+    E,\n+    F,\n+    G,\n+    H,\n+    I,\n+    J,\n+    K,\n+    L,\n+    M,\n+    N,\n+    O,\n+    P,\n+    Q,\n+    R,\n+    S,\n+    T,\n+    U,\n+    V,\n+    W,\n+    X,\n+    Y,\n+    Z,\n+    LeftBracket,\n+    Backslash,\n+    RightBracket,\n+    GraveAccent,\n+    World1,\n+    World2,\n+\n+    Escape,\n+    Enter,\n+    Tab,\n+    Backspace,\n+    Insert,\n+    Delete,\n+    Right,\n+    Left,\n+    Down,\n+    Up,\n+    PageUp,\n+    PageDown,\n+    Home,\n+    End,\n+    CapsLock,\n+    ScrollLock,\n+    NumLock,\n+    PrintScreen,\n+    Pause,\n+    F1,\n+    F2,\n+    F3,\n+    F4,\n+    F5,\n+    F6,\n+    F7,\n+    F8,\n+    F9,\n+    F10,\n+    F11,\n+    F12,\n+    F13,\n+    F14,\n+    F15,\n+    F16,\n+    F17,\n+    F18,\n+    F19,\n+    F20,\n+    F21,\n+    F22,\n+    F23,\n+    F24,\n+    F25,\n+    Kp0,\n+    Kp1,\n+    Kp2,\n+    Kp3,\n+    Kp4,\n+    Kp5,\n+    Kp6,\n+    Kp7,\n+    Kp8,\n+    Kp9,\n+    KpDecimal,\n+    KpDivide,\n+    KpMultiply,\n+    KpSubtract,\n+    KpAdd,\n+    KpEnter,\n+    KpEqual,\n+    LeftShift,\n+    LeftControl,\n+    LeftAlt,\n+    LeftSuper,\n+    RightShift,\n+    RightControl,\n+    RightAlt,\n+    RightSuper,\n+    Menu,\n+}\n+\n+fn key_from_string(key_string: &str, location: u32) -> Option<Key> {\n+    match key_string {\n+        \" \" => Some(Key::Space),\n+        \"\\\"\" => Some(Key::Apostrophe),\n+        \"'\" => Some(Key::Apostrophe),\n+        \"<\" => Some(Key::Comma),\n+        \",\" => Some(Key::Comma),\n+        \"_\" => Some(Key::Minus),\n+        \"-\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Minus),\n+        \">\" => Some(Key::Period),\n+        \".\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Period),\n+        \"?\" => Some(Key::Slash),\n+        \"/\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Slash),\n+        \"~\" => Some(Key::GraveAccent),\n+        \"`\" => Some(Key::GraveAccent),\n+        \")\" => Some(Key::Num0),\n+        \"0\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Num0),\n+        \"!\" => Some(Key::Num1),\n+        \"1\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Num1),\n+        \"@\" => Some(Key::Num2),\n+        \"2\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Num2),\n+        \"#\" => Some(Key::Num3),\n+        \"3\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Num3),\n+        \"$\" => Some(Key::Num4),\n+        \"4\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Num4),\n+        \"%\" => Some(Key::Num5),\n+        \"5\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Num5),\n+        \"^\" => Some(Key::Num6),\n+        \"6\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Num6),\n+        \"&\" => Some(Key::Num7),\n+        \"7\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Num7),\n+        \"*\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Num8),\n+        \"8\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Num8),\n+        \"(\" => Some(Key::Num9),\n+        \"9\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Num9),\n+        \":\" => Some(Key::Semicolon),\n+        \";\" => Some(Key::Semicolon),\n+        \"+\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Equal),\n+        \"=\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Equal),\n+        \"A\" => Some(Key::A),\n+        \"a\" => Some(Key::A),\n+        \"B\" => Some(Key::B),\n+        \"b\" => Some(Key::B),\n+        \"C\" => Some(Key::C),\n+        \"c\" => Some(Key::C),\n+        \"D\" => Some(Key::D),\n+        \"d\" => Some(Key::D),\n+        \"E\" => Some(Key::E),\n+        \"e\" => Some(Key::E),\n+        \"F\" => Some(Key::F),\n+        \"f\" => Some(Key::F),\n+        \"G\" => Some(Key::G),\n+        \"g\" => Some(Key::G),\n+        \"H\" => Some(Key::H),\n+        \"h\" => Some(Key::H),\n+        \"I\" => Some(Key::I),\n+        \"i\" => Some(Key::I),\n+        \"J\" => Some(Key::J),\n+        \"j\" => Some(Key::J),\n+        \"K\" => Some(Key::K),\n+        \"k\" => Some(Key::K),\n+        \"L\" => Some(Key::L),\n+        \"l\" => Some(Key::L),\n+        \"M\" => Some(Key::M),\n+        \"m\" => Some(Key::M),\n+        \"N\" => Some(Key::N),\n+        \"n\" => Some(Key::N),\n+        \"O\" => Some(Key::O),\n+        \"o\" => Some(Key::O),\n+        \"P\" => Some(Key::P),\n+        \"p\" => Some(Key::P),\n+        \"Q\" => Some(Key::Q),\n+        \"q\" => Some(Key::Q),\n+        \"R\" => Some(Key::R),\n+        \"r\" => Some(Key::R),\n+        \"S\" => Some(Key::S),\n+        \"s\" => Some(Key::S),\n+        \"T\" => Some(Key::T),\n+        \"t\" => Some(Key::T),\n+        \"U\" => Some(Key::U),\n+        \"u\" => Some(Key::U),\n+        \"V\" => Some(Key::V),\n+        \"v\" => Some(Key::V),\n+        \"W\" => Some(Key::W),\n+        \"w\" => Some(Key::W),\n+        \"X\" => Some(Key::X),\n+        \"x\" => Some(Key::X),\n+        \"Y\" => Some(Key::Y),\n+        \"y\" => Some(Key::Y),\n+        \"Z\" => Some(Key::Z),\n+        \"z\" => Some(Key::Z),\n+        \"{\" => Some(Key::LeftBracket),\n+        \"[\" => Some(Key::LeftBracket),\n+        \"|\" => Some(Key::Backslash),\n+        \"\\\\\" => Some(Key::Backslash),\n+        \"}\" => Some(Key::RightBracket),\n+        \"]\" => Some(Key::RightBracket),\n+        \"Escape\" => Some(Key::Escape),\n+        \"Enter\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_STANDARD => Some(Key::Enter),\n+        \"Tab\" => Some(Key::Tab),\n+        \"Backspace\" => Some(Key::Backspace),\n+        \"Insert\" => Some(Key::Insert),\n+        \"Delete\" => Some(Key::Delete),\n+        \"ArrowRight\" => Some(Key::Right),\n+        \"ArrowLeft\" => Some(Key::Left),\n+        \"ArrowDown\" => Some(Key::Down),\n+        \"ArrowUp\" => Some(Key::Up),\n+        \"PageUp\" => Some(Key::PageUp),\n+        \"PageDown\" => Some(Key::PageDown),\n+        \"Home\" => Some(Key::Home),\n+        \"End\" => Some(Key::End),\n+        \"CapsLock\" => Some(Key::CapsLock),\n+        \"ScrollLock\" => Some(Key::ScrollLock),\n+        \"NumLock\" => Some(Key::NumLock),\n+        \"PrintScreen\" => Some(Key::PrintScreen),\n+        \"Pause\" => Some(Key::Pause),\n+        \"F1\" => Some(Key::F1),\n+        \"F2\" => Some(Key::F2),\n+        \"F3\" => Some(Key::F3),\n+        \"F4\" => Some(Key::F4),\n+        \"F5\" => Some(Key::F5),\n+        \"F6\" => Some(Key::F6),\n+        \"F7\" => Some(Key::F7),\n+        \"F8\" => Some(Key::F8),\n+        \"F9\" => Some(Key::F9),\n+        \"F10\" => Some(Key::F10),\n+        \"F11\" => Some(Key::F11),\n+        \"F12\" => Some(Key::F12),\n+        \"F13\" => Some(Key::F13),\n+        \"F14\" => Some(Key::F14),\n+        \"F15\" => Some(Key::F15),\n+        \"F16\" => Some(Key::F16),\n+        \"F17\" => Some(Key::F17),\n+        \"F18\" => Some(Key::F18),\n+        \"F19\" => Some(Key::F19),\n+        \"F20\" => Some(Key::F20),\n+        \"F21\" => Some(Key::F21),\n+        \"F22\" => Some(Key::F22),\n+        \"F23\" => Some(Key::F23),\n+        \"F24\" => Some(Key::F24),\n+        \"F25\" => Some(Key::F25),\n+        \"0\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::Kp0),\n+        \"1\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::Kp1),\n+        \"2\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::Kp2),\n+        \"3\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::Kp3),\n+        \"4\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::Kp4),\n+        \"5\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::Kp5),\n+        \"6\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::Kp6),\n+        \"7\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::Kp7),\n+        \"8\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::Kp8),\n+        \"9\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::Kp9),\n+        \".\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::KpDecimal),\n+        \"/\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::KpDivide),\n+        \"*\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::KpMultiply),\n+        \"-\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::KpSubtract),\n+        \"+\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::KpAdd),\n+        \"Enter\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::KpEnter),\n+        \"=\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_NUMPAD => Some(Key::KpEqual),\n+        \"Shift\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_LEFT => Some(Key::LeftShift),\n+        \"Control\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_LEFT => Some(Key::LeftControl),\n+        \"Alt\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_LEFT => Some(Key::LeftAlt),\n+        \"Super\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_LEFT => Some(Key::LeftSuper),\n+        \"Shift\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_RIGHT => Some(Key::RightShift),\n+        \"Control\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_RIGHT => Some(Key::RightControl),\n+        \"Alt\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_RIGHT => Some(Key::RightAlt),\n+        \"Super\" if location == KeyboardEventConstants::DOM_KEY_LOCATION_RIGHT => Some(Key::RightSuper),\n+        \"ContextMenu\" => Some(Key::Menu),\n+        _ => None\n+    }\n+}\n+\n+fn main() { }"}]}