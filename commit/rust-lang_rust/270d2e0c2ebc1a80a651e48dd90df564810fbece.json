{"sha": "270d2e0c2ebc1a80a651e48dd90df564810fbece", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MGQyZTBjMmViYzFhODBhNjUxZTQ4ZGQ5MGRmNTY0ODEwZmJlY2U=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-10-29T03:08:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-29T03:08:40Z"}, "message": "Rollup merge of #78224 - lcnr:repeat-expr, r=varkor\n\nmin_const_generics: allow ty param in repeat expr\n\nimplements https://rust-lang.zulipchat.com/#narrow/stream/260443-project-const-generics/topic/repeat.20expressions\n\nEven with `min_const_generics` active, now keeps resulting in future compat warnings instead of hard errors.\nConst parameters, for example `[0; N + 1]`, still result in hard errors during resolve.\n```rust\n#![allow(dead_code)]\n\nfn foo<T>() {\n    [0; std::mem::size_of::<*mut T>()];\n}\n\nstruct Foo<T>(T);\n\nimpl<T> Foo<T> {\n    const ASSOC: usize = 4;\n\n    fn test() {\n        [0; Self::ASSOC];\n    }\n}\n```\n\nr? @varkor cc @petrochenkov", "tree": {"sha": "0bbef9d7c0030ff54b0230efa94c7078e355325c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bbef9d7c0030ff54b0230efa94c7078e355325c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/270d2e0c2ebc1a80a651e48dd90df564810fbece", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfmjI5CRBK7hj4Ov3rIwAAdHIIAHQnov1AWp6lU1Xm556je2sp\ncq5SFf3GR5kLm5TfTqUApTgF0+gsIrNDLN9NsNoHTgq7VyzTQ48YFu4ViXWWRGEG\nBpSbazIG7JD46rchaOIqg2hS+m93wIQgZuSjCWuYMoWchQ1NM3CXPIYrMxZmFlZJ\nRmmUIFXqQ+Tl5P7sgUIJ3Zf4WHEMgijsD8/47d+MvBRdvock+oAH+HksKPKJFFgK\n0+DJBMz17W3PBp/S0CCjIfO7stdU+0yzyhPU/O8FZms2VpTI1vew1M7Fs0S2bUfe\nFf4qpZ8Oi4cwCj8UBL+m3/U3KR7IM1fdtACf8NrZZ+ihoNp9hILOmRyoOXFXTr4=\n=gZhQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 0bbef9d7c0030ff54b0230efa94c7078e355325c\nparent 2008d1bb0b185286d376d8e1f1093fa9ec070156\nparent 83ecbb4a294abca245f8c515e298464e9425b9a2\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1603940920 +0900\ncommitter GitHub <noreply@github.com> 1603940920 +0900\n\nRollup merge of #78224 - lcnr:repeat-expr, r=varkor\n\nmin_const_generics: allow ty param in repeat expr\n\nimplements https://rust-lang.zulipchat.com/#narrow/stream/260443-project-const-generics/topic/repeat.20expressions\n\nEven with `min_const_generics` active, now keeps resulting in future compat warnings instead of hard errors.\nConst parameters, for example `[0; N + 1]`, still result in hard errors during resolve.\n```rust\n#![allow(dead_code)]\n\nfn foo<T>() {\n    [0; std::mem::size_of::<*mut T>()];\n}\n\nstruct Foo<T>(T);\n\nimpl<T> Foo<T> {\n    const ASSOC: usize = 4;\n\n    fn test() {\n        [0; Self::ASSOC];\n    }\n}\n```\n\nr? @varkor cc @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/270d2e0c2ebc1a80a651e48dd90df564810fbece", "html_url": "https://github.com/rust-lang/rust/commit/270d2e0c2ebc1a80a651e48dd90df564810fbece", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/270d2e0c2ebc1a80a651e48dd90df564810fbece/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2008d1bb0b185286d376d8e1f1093fa9ec070156", "url": "https://api.github.com/repos/rust-lang/rust/commits/2008d1bb0b185286d376d8e1f1093fa9ec070156", "html_url": "https://github.com/rust-lang/rust/commit/2008d1bb0b185286d376d8e1f1093fa9ec070156"}, {"sha": "83ecbb4a294abca245f8c515e298464e9425b9a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/83ecbb4a294abca245f8c515e298464e9425b9a2", "html_url": "https://github.com/rust-lang/rust/commit/83ecbb4a294abca245f8c515e298464e9425b9a2"}], "stats": {"total": 256, "additions": 217, "deletions": 39}, "files": [{"sha": "193247af584bb579d240582f8de712df42b22aed", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/270d2e0c2ebc1a80a651e48dd90df564810fbece/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270d2e0c2ebc1a80a651e48dd90df564810fbece/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=270d2e0c2ebc1a80a651e48dd90df564810fbece", "patch": "@@ -206,8 +206,10 @@ pub enum Res<Id = hir::HirId> {\n     /// ```rust\n     /// impl Foo { fn test() -> [u8; std::mem::size_of::<Self>()] {} }\n     /// ```\n+    /// We do however allow `Self` in repeat expression even if it is generic to not break code\n+    /// which already works on stable while causing the `const_evaluatable_unchecked` future compat lint.\n     ///\n-    /// FIXME(lazy_normalization_consts): Remove this bodge once this feature is stable.\n+    /// FIXME(lazy_normalization_consts): Remove this bodge once that feature is stable.\n     SelfTy(Option<DefId> /* trait */, Option<(DefId, bool)> /* impl */),\n     ToolMod, // e.g., `rustfmt` in `#[rustfmt::skip]`\n "}, {"sha": "d323aebe59798cc04de848bf7307bed502dbdef3", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 70, "deletions": 18, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/270d2e0c2ebc1a80a651e48dd90df564810fbece/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270d2e0c2ebc1a80a651e48dd90df564810fbece/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=270d2e0c2ebc1a80a651e48dd90df564810fbece", "patch": "@@ -57,6 +57,12 @@ enum PatternSource {\n     FnParam,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum IsRepeatExpr {\n+    No,\n+    Yes,\n+}\n+\n impl PatternSource {\n     fn descr(self) -> &'static str {\n         match self {\n@@ -437,10 +443,8 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         self.resolve_block(block);\n     }\n     fn visit_anon_const(&mut self, constant: &'ast AnonConst) {\n-        debug!(\"visit_anon_const {:?}\", constant);\n-        self.with_constant_rib(constant.value.is_potential_trivial_const_param(), |this| {\n-            visit::walk_anon_const(this, constant);\n-        });\n+        // We deal with repeat expressions explicitly in `resolve_expr`.\n+        self.resolve_anon_const(constant, IsRepeatExpr::No);\n     }\n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         self.resolve_expr(expr, None);\n@@ -647,7 +651,11 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         if !check_ns(TypeNS) && check_ns(ValueNS) {\n                             // This must be equivalent to `visit_anon_const`, but we cannot call it\n                             // directly due to visitor lifetimes so we have to copy-paste some code.\n-                            self.with_constant_rib(true, |this| {\n+                            //\n+                            // Note that we might not be inside of an repeat expression here,\n+                            // but considering that `IsRepeatExpr` is only relevant for\n+                            // non-trivial constants this is doesn't matter.\n+                            self.with_constant_rib(IsRepeatExpr::No, true, |this| {\n                                 this.smart_resolve_path(\n                                     ty.id,\n                                     qself.as_ref(),\n@@ -980,9 +988,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                             //\n                                             // Type parameters can already be used and as associated consts are\n                                             // not used as part of the type system, this is far less surprising.\n-                                            this.with_constant_rib(true, |this| {\n-                                                this.visit_expr(expr)\n-                                            });\n+                                            this.with_constant_rib(\n+                                                IsRepeatExpr::No,\n+                                                true,\n+                                                |this| this.visit_expr(expr),\n+                                            );\n                                         }\n                                     }\n                                     AssocItemKind::Fn(_, _, generics, _) => {\n@@ -1023,7 +1033,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.with_item_rib(HasGenericParams::No, |this| {\n                     this.visit_ty(ty);\n                     if let Some(expr) = expr {\n-                        this.with_constant_rib(expr.is_potential_trivial_const_param(), |this| {\n+                        // We already forbid generic params because of the above item rib,\n+                        // so it doesn't matter whether this is a trivial constant.\n+                        this.with_constant_rib(IsRepeatExpr::No, true, |this| {\n                             this.visit_expr(expr)\n                         });\n                     }\n@@ -1122,12 +1134,29 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         self.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n     }\n \n-    fn with_constant_rib(&mut self, trivial: bool, f: impl FnOnce(&mut Self)) {\n-        debug!(\"with_constant_rib\");\n-        self.with_rib(ValueNS, ConstantItemRibKind(trivial), |this| {\n-            this.with_rib(TypeNS, ConstantItemRibKind(trivial), |this| {\n-                this.with_label_rib(ConstantItemRibKind(trivial), f);\n-            })\n+    // HACK(min_const_generics,const_evaluatable_unchecked): We\n+    // want to keep allowing `[0; std::mem::size_of::<*mut T>()]`\n+    // with a future compat lint for now. We do this by adding an\n+    // additional special case for repeat expressions.\n+    //\n+    // Note that we intentionally still forbid `[0; N + 1]` during\n+    // name resolution so that we don't extend the future\n+    // compat lint to new cases.\n+    fn with_constant_rib(\n+        &mut self,\n+        is_repeat: IsRepeatExpr,\n+        is_trivial: bool,\n+        f: impl FnOnce(&mut Self),\n+    ) {\n+        debug!(\"with_constant_rib: is_repeat={:?} is_trivial={}\", is_repeat, is_trivial);\n+        self.with_rib(ValueNS, ConstantItemRibKind(is_trivial), |this| {\n+            this.with_rib(\n+                TypeNS,\n+                ConstantItemRibKind(is_repeat == IsRepeatExpr::Yes || is_trivial),\n+                |this| {\n+                    this.with_label_rib(ConstantItemRibKind(is_trivial), f);\n+                },\n+            )\n         });\n     }\n \n@@ -1272,9 +1301,17 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                             //\n                                             // Type parameters can already be used and as associated consts are\n                                             // not used as part of the type system, this is far less surprising.\n-                                            this.with_constant_rib(true, |this| {\n-                                                visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n-                                            });\n+                                            this.with_constant_rib(\n+                                                IsRepeatExpr::No,\n+                                                true,\n+                                                |this| {\n+                                                    visit::walk_assoc_item(\n+                                                        this,\n+                                                        item,\n+                                                        AssocCtxt::Impl,\n+                                                    )\n+                                                },\n+                                            );\n                                         }\n                                         AssocItemKind::Fn(_, _, generics, _) => {\n                                             // We also need a new scope for the impl item type parameters.\n@@ -2199,6 +2236,17 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n+    fn resolve_anon_const(&mut self, constant: &'ast AnonConst, is_repeat: IsRepeatExpr) {\n+        debug!(\"resolve_anon_const {:?} is_repeat: {:?}\", constant, is_repeat);\n+        self.with_constant_rib(\n+            is_repeat,\n+            constant.value.is_potential_trivial_const_param(),\n+            |this| {\n+                visit::walk_anon_const(this, constant);\n+            },\n+        );\n+    }\n+\n     fn resolve_expr(&mut self, expr: &'ast Expr, parent: Option<&'ast Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n@@ -2322,6 +2370,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ExprKind::Async(..) | ExprKind::Closure(..) => {\n                 self.with_label_rib(ClosureOrAsyncRibKind, |this| visit::walk_expr(this, expr));\n             }\n+            ExprKind::Repeat(ref elem, ref ct) => {\n+                self.visit_expr(elem);\n+                self.resolve_anon_const(ct, IsRepeatExpr::Yes);\n+            }\n             _ => {\n                 visit::walk_expr(self, expr);\n             }"}, {"sha": "865eaf749326764fd36b94e16d68d45600451d99", "filename": "src/test/ui/const-generics/issues/issue-62504.min.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.min.stderr?ref=270d2e0c2ebc1a80a651e48dd90df564810fbece", "patch": "@@ -1,14 +1,20 @@\n-error: generic `Self` types are currently not permitted in anonymous constants\n+error[E0308]: mismatched types\n+  --> $DIR/issue-62504.rs:19:21\n+   |\n+LL |         ArrayHolder([0; Self::SIZE])\n+   |                     ^^^^^^^^^^^^^^^ expected `X`, found `Self::SIZE`\n+   |\n+   = note: expected array `[u32; X]`\n+              found array `[u32; _]`\n+\n+error: constant expression depends on a generic parameter\n   --> $DIR/issue-62504.rs:19:25\n    |\n LL |         ArrayHolder([0; Self::SIZE])\n    |                         ^^^^^^^^^^\n    |\n-note: not a concrete type\n-  --> $DIR/issue-62504.rs:17:22\n-   |\n-LL | impl<const X: usize> ArrayHolder<X> {\n-   |                      ^^^^^^^^^^^^^^\n+   = note: this may fail depending on what value the parameter takes\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "5630962ff53767ca8ff9b156640b464fbb9c5b90", "filename": "src/test/ui/const-generics/issues/issue-62504.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs?ref=270d2e0c2ebc1a80a651e48dd90df564810fbece", "patch": "@@ -17,8 +17,8 @@ struct ArrayHolder<const X: usize>([u32; X]);\n impl<const X: usize> ArrayHolder<X> {\n     pub const fn new() -> Self {\n         ArrayHolder([0; Self::SIZE])\n-        //[full]~^ ERROR constant expression depends on a generic parameter\n-        //[min]~^^ ERROR generic `Self` types are currently\n+        //~^ ERROR constant expression depends on a generic parameter\n+        //[min]~| ERROR mismatched types\n     }\n }\n "}, {"sha": "27a56b8eb02b2a0692f28bf6042155c77320600f", "filename": "src/test/ui/const-generics/issues/issue-67739.min.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.min.stderr?ref=270d2e0c2ebc1a80a651e48dd90df564810fbece", "patch": "@@ -1,10 +1,10 @@\n-error: generic parameters may not be used in const operations\n-  --> $DIR/issue-67739.rs:12:30\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-67739.rs:12:15\n    |\n LL |         [0u8; mem::size_of::<Self::Associated>()];\n-   |                              ^^^^^^^^^^^^^^^^ cannot perform const operation using `Self`\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: type parameters may not be used in const expressions\n+   = note: this may fail depending on what value the parameter takes\n \n error: aborting due to previous error\n "}, {"sha": "0f5860f22fdd34310f6132bda694682531ac76fe", "filename": "src/test/ui/const-generics/issues/issue-67739.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.rs?ref=270d2e0c2ebc1a80a651e48dd90df564810fbece", "patch": "@@ -10,8 +10,7 @@ pub trait Trait {\n \n     fn associated_size(&self) -> usize {\n         [0u8; mem::size_of::<Self::Associated>()];\n-        //[full]~^ ERROR constant expression depends on a generic parameter\n-        //[min]~^^ ERROR generic parameters may not be used in const operations\n+        //~^ ERROR constant expression depends on a generic parameter\n         0\n     }\n }"}, {"sha": "686ce98fcdff3f88f4a2a50a4ef7ee5e947067e4", "filename": "src/test/ui/const-generics/min_const_generics/complex-expression.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.rs?ref=270d2e0c2ebc1a80a651e48dd90df564810fbece", "patch": "@@ -1,5 +1,7 @@\n #![feature(min_const_generics)]\n \n+use std::mem::size_of;\n+\n fn test<const N: usize>() {}\n \n fn ok<const M: usize>() -> [u8; M] {\n@@ -22,6 +24,24 @@ fn break3<const N: usize>() {\n     //~^ ERROR generic parameters may not be used in const operations\n }\n \n+struct BreakTy0<T>(T, [u8; { size_of::<*mut T>() }]);\n+//~^ ERROR generic parameters may not be used in const operations\n+\n+struct BreakTy1<T>(T, [u8; { { size_of::<*mut T>() } }]);\n+//~^ ERROR generic parameters may not be used in const operations\n+\n+fn break_ty2<T>() {\n+    let _: [u8; size_of::<*mut T>() + 1];\n+    //~^ ERROR generic parameters may not be used in const operations\n+}\n+\n+fn break_ty3<T>() {\n+    let _ = [0; size_of::<*mut T>() + 1];\n+    //~^ WARN cannot use constants which depend on generic parameters in types\n+    //~| WARN this was previously accepted by the compiler but is being phased out\n+}\n+\n+\n trait Foo {\n     const ASSOC: usize;\n }"}, {"sha": "a8de987e1675ed2f2939c0a71a17f29c188be6e6", "filename": "src/test/ui/const-generics/min_const_generics/complex-expression.stderr", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.stderr?ref=270d2e0c2ebc1a80a651e48dd90df564810fbece", "patch": "@@ -1,34 +1,68 @@\n error: generic parameters may not be used in const operations\n-  --> $DIR/complex-expression.rs:9:38\n+  --> $DIR/complex-expression.rs:11:38\n    |\n LL | struct Break0<const N: usize>([u8; { N + 1 }]);\n    |                                      ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n \n error: generic parameters may not be used in const operations\n-  --> $DIR/complex-expression.rs:12:40\n+  --> $DIR/complex-expression.rs:14:40\n    |\n LL | struct Break1<const N: usize>([u8; { { N } }]);\n    |                                        ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n \n error: generic parameters may not be used in const operations\n-  --> $DIR/complex-expression.rs:16:17\n+  --> $DIR/complex-expression.rs:18:17\n    |\n LL |     let _: [u8; N + 1];\n    |                 ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n \n error: generic parameters may not be used in const operations\n-  --> $DIR/complex-expression.rs:21:17\n+  --> $DIR/complex-expression.rs:23:17\n    |\n LL |     let _ = [0; N + 1];\n    |                 ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n \n-error: aborting due to 4 previous errors\n+error: generic parameters may not be used in const operations\n+  --> $DIR/complex-expression.rs:27:45\n+   |\n+LL | struct BreakTy0<T>(T, [u8; { size_of::<*mut T>() }]);\n+   |                                             ^ cannot perform const operation using `T`\n+   |\n+   = note: type parameters may not be used in const expressions\n+\n+error: generic parameters may not be used in const operations\n+  --> $DIR/complex-expression.rs:30:47\n+   |\n+LL | struct BreakTy1<T>(T, [u8; { { size_of::<*mut T>() } }]);\n+   |                                               ^ cannot perform const operation using `T`\n+   |\n+   = note: type parameters may not be used in const expressions\n+\n+error: generic parameters may not be used in const operations\n+  --> $DIR/complex-expression.rs:34:32\n+   |\n+LL |     let _: [u8; size_of::<*mut T>() + 1];\n+   |                                ^ cannot perform const operation using `T`\n+   |\n+   = note: type parameters may not be used in const expressions\n+\n+warning: cannot use constants which depend on generic parameters in types\n+  --> $DIR/complex-expression.rs:39:17\n+   |\n+LL |     let _ = [0; size_of::<*mut T>() + 1];\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(const_evaluatable_unchecked)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #76200 <https://github.com/rust-lang/rust/issues/76200>\n+\n+error: aborting due to 7 previous errors; 1 warning emitted\n "}, {"sha": "dd82be33a8e80b7be29d5c4c1da7641f28bcd49d", "filename": "src/test/ui/const-generics/min_const_generics/const-evaluatable-unchecked.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-evaluatable-unchecked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-evaluatable-unchecked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-evaluatable-unchecked.rs?ref=270d2e0c2ebc1a80a651e48dd90df564810fbece", "patch": "@@ -0,0 +1,35 @@\n+// check-pass\n+#![feature(min_const_generics)]\n+#![allow(dead_code)]\n+\n+fn foo<T>() {\n+    [0; std::mem::size_of::<*mut T>()];\n+    //~^ WARN cannot use constants which depend on generic parameters in types\n+    //~| WARN this was previously accepted by the compiler but is being phased out\n+}\n+\n+struct Foo<T>(T);\n+\n+impl<T> Foo<T> {\n+    const ASSOC: usize = 4;\n+\n+    fn test() {\n+        let _ = [0; Self::ASSOC];\n+        //~^ WARN cannot use constants which depend on generic parameters in types\n+        //~| WARN this was previously accepted by the compiler but is being phased out\n+    }\n+}\n+\n+struct Bar<const N: usize>;\n+\n+impl<const N: usize> Bar<N> {\n+    const ASSOC: usize = 4;\n+\n+    fn test() {\n+        let _ = [0; Self::ASSOC];\n+        //~^ WARN cannot use constants which depend on generic parameters in types\n+        //~| WARN this was previously accepted by the compiler but is being phased out\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4d0cab012f99e1fef4c9ab31b4c6422d4dfa89d0", "filename": "src/test/ui/const-generics/min_const_generics/const-evaluatable-unchecked.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-evaluatable-unchecked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/270d2e0c2ebc1a80a651e48dd90df564810fbece/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-evaluatable-unchecked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-evaluatable-unchecked.stderr?ref=270d2e0c2ebc1a80a651e48dd90df564810fbece", "patch": "@@ -0,0 +1,30 @@\n+warning: cannot use constants which depend on generic parameters in types\n+  --> $DIR/const-evaluatable-unchecked.rs:6:9\n+   |\n+LL |     [0; std::mem::size_of::<*mut T>()];\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(const_evaluatable_unchecked)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #76200 <https://github.com/rust-lang/rust/issues/76200>\n+\n+warning: cannot use constants which depend on generic parameters in types\n+  --> $DIR/const-evaluatable-unchecked.rs:17:21\n+   |\n+LL |         let _ = [0; Self::ASSOC];\n+   |                     ^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #76200 <https://github.com/rust-lang/rust/issues/76200>\n+\n+warning: cannot use constants which depend on generic parameters in types\n+  --> $DIR/const-evaluatable-unchecked.rs:29:21\n+   |\n+LL |         let _ = [0; Self::ASSOC];\n+   |                     ^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #76200 <https://github.com/rust-lang/rust/issues/76200>\n+\n+warning: 3 warnings emitted\n+"}]}