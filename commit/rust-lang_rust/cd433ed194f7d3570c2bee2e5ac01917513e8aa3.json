{"sha": "cd433ed194f7d3570c2bee2e5ac01917513e8aa3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNDMzZWQxOTRmN2QzNTcwYzJiZWUyZTVhYzAxOTE3NTEzZThhYTM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-25T09:58:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-25T09:58:54Z"}, "message": "Merge #1734\n\n1734: Strip indents and empty lines in check_apply_diagnostic_fix_from_position r=matklad a=matklad\n\n\n\nCo-authored-by: Phil Ellison <phil.j.ellison@gmail.com>", "tree": {"sha": "9e5c2c98cd6b2101e31d6ed9b2f6c0f62fb16926", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e5c2c98cd6b2101e31d6ed9b2f6c0f62fb16926"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd433ed194f7d3570c2bee2e5ac01917513e8aa3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdYlveCRBK7hj4Ov3rIwAAdHIIACyjZj1txIkQgssWylwSEJYF\n2QuFvlHtD/kICYpGiHM0UZgSHwDivsA5IKT0I4rNu/BFBYX2t5axJ5Maejvwv+NH\nLMXaoTmSrQdyKNvNbAxlq7cbt4+UUuVWsjQhSxLva2ncnRTWXC8XJH3mWLWgy0fb\npT+VLFoaPsPbkOWa60D9BTR/nC0uJeSV3UiFLjfRHyyZRD8dJjWbAHuRKpQyL7GX\nFRAVlxAioXMjEHR76oOGBMQKI29fCuEYly48UzdxTcEg2m+plpGHRFWG4UWmDm+M\nxepvRwK9nUG54bpUzCe7zI8xHl2ia92h0W1mf82r497l2jTQppsvs2w4qJrLrVM=\n=VXBz\n-----END PGP SIGNATURE-----\n", "payload": "tree 9e5c2c98cd6b2101e31d6ed9b2f6c0f62fb16926\nparent 866b41ddd86cbe9c3e8d9cb2896477bab060a044\nparent 14a23d1bde8493df9e5196973132144060a61709\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1566727134 +0000\ncommitter GitHub <noreply@github.com> 1566727134 +0000\n\nMerge #1734\n\n1734: Strip indents and empty lines in check_apply_diagnostic_fix_from_position r=matklad a=matklad\n\n\n\nCo-authored-by: Phil Ellison <phil.j.ellison@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd433ed194f7d3570c2bee2e5ac01917513e8aa3", "html_url": "https://github.com/rust-lang/rust/commit/cd433ed194f7d3570c2bee2e5ac01917513e8aa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "866b41ddd86cbe9c3e8d9cb2896477bab060a044", "url": "https://api.github.com/repos/rust-lang/rust/commits/866b41ddd86cbe9c3e8d9cb2896477bab060a044", "html_url": "https://github.com/rust-lang/rust/commit/866b41ddd86cbe9c3e8d9cb2896477bab060a044"}, {"sha": "14a23d1bde8493df9e5196973132144060a61709", "url": "https://api.github.com/repos/rust-lang/rust/commits/14a23d1bde8493df9e5196973132144060a61709", "html_url": "https://github.com/rust-lang/rust/commit/14a23d1bde8493df9e5196973132144060a61709"}], "stats": {"total": 324, "additions": 319, "deletions": 5}, "files": [{"sha": "475dd5766e7fe8e6dd673d16583bcd221815e668", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=cd433ed194f7d3570c2bee2e5ac01917513e8aa3", "patch": "@@ -143,3 +143,31 @@ impl AstDiagnostic for MissingFields {\n         ast::RecordFieldList::cast(node).unwrap()\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct MissingOkInTailExpr {\n+    pub file: HirFileId,\n+    pub expr: AstPtr<ast::Expr>,\n+}\n+\n+impl Diagnostic for MissingOkInTailExpr {\n+    fn message(&self) -> String {\n+        \"wrap return expression in Ok\".to_string()\n+    }\n+    fn source(&self) -> Source<SyntaxNodePtr> {\n+        Source { file_id: self.file, ast: self.expr.into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+impl AstDiagnostic for MissingOkInTailExpr {\n+    type AST = ast::Expr;\n+\n+    fn ast(&self, db: &impl HirDatabase) -> Self::AST {\n+        let root = db.parse_or_expand(self.file).unwrap();\n+        let node = self.source().ast.to_node(&root);\n+        ast::Expr::cast(node).unwrap()\n+    }\n+}"}, {"sha": "5d9d59ff89a8c903284ac0637d722e749f7e1b76", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=cd433ed194f7d3570c2bee2e5ac01917513e8aa3", "patch": "@@ -6,11 +6,14 @@ use ra_syntax::ast::{AstNode, RecordLit};\n use super::{Expr, ExprId, RecordLitField};\n use crate::{\n     adt::AdtDef,\n-    diagnostics::{DiagnosticSink, MissingFields},\n+    diagnostics::{DiagnosticSink, MissingFields, MissingOkInTailExpr},\n     expr::AstPtr,\n-    ty::InferenceResult,\n-    Function, HasSource, HirDatabase, Name, Path,\n+    name,\n+    path::{PathKind, PathSegment},\n+    ty::{ApplicationTy, InferenceResult, Ty, TypeCtor},\n+    Function, HasSource, HirDatabase, ModuleDef, Name, Path, PerNs, Resolution,\n };\n+use ra_syntax::ast;\n \n pub(crate) struct ExprValidator<'a, 'b: 'a> {\n     func: Function,\n@@ -29,11 +32,17 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n     pub(crate) fn validate_body(&mut self, db: &impl HirDatabase) {\n         let body = self.func.body(db);\n+\n         for e in body.exprs() {\n             if let (id, Expr::RecordLit { path, fields, spread }) = e {\n                 self.validate_record_literal(id, path, fields, *spread, db);\n             }\n         }\n+\n+        let body_expr = &body[body.body_expr()];\n+        if let Expr::Block { statements: _, tail: Some(t) } = body_expr {\n+            self.validate_results_in_tail_expr(*t, db);\n+        }\n     }\n \n     fn validate_record_literal(\n@@ -87,4 +96,42 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             })\n         }\n     }\n+\n+    fn validate_results_in_tail_expr(&mut self, id: ExprId, db: &impl HirDatabase) {\n+        let mismatch = match self.infer.type_mismatch_for_expr(id) {\n+            Some(m) => m,\n+            None => return,\n+        };\n+\n+        let std_result_path = Path {\n+            kind: PathKind::Abs,\n+            segments: vec![\n+                PathSegment { name: name::STD, args_and_bindings: None },\n+                PathSegment { name: name::RESULT_MOD, args_and_bindings: None },\n+                PathSegment { name: name::RESULT_TYPE, args_and_bindings: None },\n+            ],\n+        };\n+\n+        let resolver = self.func.resolver(db);\n+        let std_result_enum =\n+            match resolver.resolve_path_segments(db, &std_result_path).into_fully_resolved() {\n+                PerNs { types: Some(Resolution::Def(ModuleDef::Enum(e))), .. } => e,\n+                _ => return,\n+            };\n+\n+        let std_result_ctor = TypeCtor::Adt(AdtDef::Enum(std_result_enum));\n+        let params = match &mismatch.expected {\n+            Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &std_result_ctor => parameters,\n+            _ => return,\n+        };\n+\n+        if params.len() == 2 && &params[0] == &mismatch.actual {\n+            let source_map = self.func.body_source_map(db);\n+            let file_id = self.func.source(db).file_id;\n+\n+            if let Some(expr) = source_map.expr_syntax(id).and_then(|n| n.cast::<ast::Expr>()) {\n+                self.sink.push(MissingOkInTailExpr { file: file_id, expr });\n+            }\n+        }\n+    }\n }"}, {"sha": "9c4822d917f44690d560b77cbecb0f673e5f01ce", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=cd433ed194f7d3570c2bee2e5ac01917513e8aa3", "patch": "@@ -120,6 +120,8 @@ pub(crate) const TRY: Name = Name::new(SmolStr::new_inline_from_ascii(3, b\"Try\")\n pub(crate) const OK: Name = Name::new(SmolStr::new_inline_from_ascii(2, b\"Ok\"));\n pub(crate) const FUTURE_MOD: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"future\"));\n pub(crate) const FUTURE_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Future\"));\n+pub(crate) const RESULT_MOD: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"result\"));\n+pub(crate) const RESULT_TYPE: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Result\"));\n pub(crate) const OUTPUT: Name = Name::new(SmolStr::new_inline_from_ascii(6, b\"Output\"));\n \n fn resolve_name(text: &SmolStr) -> SmolStr {"}, {"sha": "d94e8154b0db0d0ce02de5a9238bbe2ee11b57b5", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=cd433ed194f7d3570c2bee2e5ac01917513e8aa3", "patch": "@@ -106,6 +106,13 @@ impl Default for BindingMode {\n     }\n }\n \n+/// A mismatch between an expected and an inferred type.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct TypeMismatch {\n+    pub expected: Ty,\n+    pub actual: Ty,\n+}\n+\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug, Default)]\n pub struct InferenceResult {\n@@ -120,6 +127,7 @@ pub struct InferenceResult {\n     diagnostics: Vec<InferenceDiagnostic>,\n     pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n     pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n+    pub(super) type_mismatches: ArenaMap<ExprId, TypeMismatch>,\n }\n \n impl InferenceResult {\n@@ -141,6 +149,9 @@ impl InferenceResult {\n     pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<ImplItem> {\n         self.assoc_resolutions.get(&id.into()).copied()\n     }\n+    pub fn type_mismatch_for_expr(&self, expr: ExprId) -> Option<&TypeMismatch> {\n+        self.type_mismatches.get(expr)\n+    }\n     pub(crate) fn add_diagnostics(\n         &self,\n         db: &impl HirDatabase,\n@@ -1345,9 +1356,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n-        self.unify(&ty, &expected.ty);\n+        let could_unify = self.unify(&ty, &expected.ty);\n         let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n         self.write_expr_ty(tgt_expr, ty.clone());\n+        if !could_unify {\n+            self.result.type_mismatches.insert(\n+                tgt_expr,\n+                TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n+            );\n+        }\n         ty\n     }\n "}, {"sha": "1a4882824f65a2ecd63f753870f12a41fab0c853", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 214, "deletions": 1, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=cd433ed194f7d3570c2bee2e5ac01917513e8aa3", "patch": "@@ -75,6 +75,19 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n             severity: Severity::Error,\n             fix: Some(fix),\n         })\n+    })\n+    .on::<hir::diagnostics::MissingOkInTailExpr, _>(|d| {\n+        let node = d.ast(db);\n+        let mut builder = TextEditBuilder::default();\n+        let replacement = format!(\"Ok({})\", node.syntax());\n+        builder.replace(node.syntax().text_range(), replacement);\n+        let fix = SourceChange::source_file_edit_from(\"wrap with ok\", file_id, builder.finish());\n+        res.borrow_mut().push(Diagnostic {\n+            range: d.highlight_range(),\n+            message: d.message(),\n+            severity: Severity::Error,\n+            fix: Some(fix),\n+        })\n     });\n     if let Some(m) = source_binder::module_from_file_id(db, file_id) {\n         m.diagnostics(db, &mut sink);\n@@ -171,10 +184,11 @@ fn check_struct_shorthand_initialization(\n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot_matches;\n+    use join_to_string::join;\n     use ra_syntax::SourceFile;\n     use test_utils::assert_eq_text;\n \n-    use crate::mock_analysis::single_file;\n+    use crate::mock_analysis::{analysis_and_position, single_file};\n \n     use super::*;\n \n@@ -203,6 +217,48 @@ mod tests {\n         assert_eq_text!(after, &actual);\n     }\n \n+    /// Takes a multi-file input fixture with annotated cursor positions,\n+    /// and checks that:\n+    ///  * a diagnostic is produced\n+    ///  * this diagnostic touches the input cursor position\n+    ///  * that the contents of the file containing the cursor match `after` after the diagnostic fix is applied\n+    fn check_apply_diagnostic_fix_from_position(fixture: &str, after: &str) {\n+        let (analysis, file_position) = analysis_and_position(fixture);\n+        let diagnostic = analysis.diagnostics(file_position.file_id).unwrap().pop().unwrap();\n+        let mut fix = diagnostic.fix.unwrap();\n+        let edit = fix.source_file_edits.pop().unwrap().edit;\n+        let target_file_contents = analysis.file_text(file_position.file_id).unwrap();\n+        let actual = edit.apply(&target_file_contents);\n+\n+        // Strip indent and empty lines from `after`, to match the behaviour of\n+        // `parse_fixture` called from `analysis_and_position`.\n+        let margin = fixture\n+            .lines()\n+            .filter(|it| it.trim_start().starts_with(\"//-\"))\n+            .map(|it| it.len() - it.trim_start().len())\n+            .next()\n+            .expect(\"empty fixture\");\n+        let after = join(after.lines().filter_map(|line| {\n+            if line.len() > margin {\n+                Some(&line[margin..])\n+            } else {\n+                None\n+            }\n+        }))\n+        .separator(\"\\n\")\n+        .suffix(\"\\n\")\n+        .to_string();\n+\n+        assert_eq_text!(&after, &actual);\n+        assert!(\n+            diagnostic.range.start() <= file_position.offset\n+                && diagnostic.range.end() >= file_position.offset,\n+            \"diagnostic range {} does not touch cursor position {}\",\n+            diagnostic.range,\n+            file_position.offset\n+        );\n+    }\n+\n     fn check_apply_diagnostic_fix(before: &str, after: &str) {\n         let (analysis, file_id) = single_file(before);\n         let diagnostic = analysis.diagnostics(file_id).unwrap().pop().unwrap();\n@@ -212,12 +268,169 @@ mod tests {\n         assert_eq_text!(after, &actual);\n     }\n \n+    /// Takes a multi-file input fixture with annotated cursor position and checks that no diagnostics\n+    /// apply to the file containing the cursor.\n+    fn check_no_diagnostic_for_target_file(fixture: &str) {\n+        let (analysis, file_position) = analysis_and_position(fixture);\n+        let diagnostics = analysis.diagnostics(file_position.file_id).unwrap();\n+        assert_eq!(diagnostics.len(), 0);\n+    }\n+\n     fn check_no_diagnostic(content: &str) {\n         let (analysis, file_id) = single_file(content);\n         let diagnostics = analysis.diagnostics(file_id).unwrap();\n         assert_eq!(diagnostics.len(), 0);\n     }\n \n+    #[test]\n+    fn test_wrap_return_type() {\n+        let before = r#\"\n+            //- /main.rs\n+            use std::{string::String, result::Result::{self, Ok, Err}};\n+\n+            fn div(x: i32, y: i32) -> Result<i32, String> {\n+                if y == 0 {\n+                    return Err(\"div by zero\".into());\n+                }\n+                x / y<|>\n+            }\n+\n+            //- /std/lib.rs\n+            pub mod string {\n+                pub struct String { }\n+            }\n+            pub mod result {\n+                pub enum Result<T, E> { Ok(T), Err(E) }\n+            }\n+        \"#;\n+        let after = r#\"\n+            use std::{string::String, result::Result::{self, Ok, Err}};\n+\n+            fn div(x: i32, y: i32) -> Result<i32, String> {\n+                if y == 0 {\n+                    return Err(\"div by zero\".into());\n+                }\n+                Ok(x / y)\n+            }\n+        \"#;\n+        check_apply_diagnostic_fix_from_position(before, after);\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_handles_generic_functions() {\n+        let before = r#\"\n+            //- /main.rs\n+            use std::result::Result::{self, Ok, Err};\n+\n+            fn div<T>(x: T) -> Result<T, i32> {\n+                if x == 0 {\n+                    return Err(7);\n+                }\n+                <|>x\n+            }\n+\n+            //- /std/lib.rs\n+            pub mod result {\n+                pub enum Result<T, E> { Ok(T), Err(E) }\n+            }\n+        \"#;\n+        let after = r#\"\n+            use std::result::Result::{self, Ok, Err};\n+\n+            fn div<T>(x: T) -> Result<T, i32> {\n+                if x == 0 {\n+                    return Err(7);\n+                }\n+                Ok(x)\n+            }\n+        \"#;\n+        check_apply_diagnostic_fix_from_position(before, after);\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_handles_type_aliases() {\n+        let before = r#\"\n+            //- /main.rs\n+            use std::{string::String, result::Result::{self, Ok, Err}};\n+\n+            type MyResult<T> = Result<T, String>;\n+\n+            fn div(x: i32, y: i32) -> MyResult<i32> {\n+                if y == 0 {\n+                    return Err(\"div by zero\".into());\n+                }\n+                x <|>/ y\n+            }\n+\n+            //- /std/lib.rs\n+            pub mod string {\n+                pub struct String { }\n+            }\n+            pub mod result {\n+                pub enum Result<T, E> { Ok(T), Err(E) }\n+            }\n+        \"#;\n+        let after = r#\"\n+            use std::{string::String, result::Result::{self, Ok, Err}};\n+\n+            type MyResult<T> = Result<T, String>;\n+            fn div(x: i32, y: i32) -> MyResult<i32> {\n+                if y == 0 {\n+                    return Err(\"div by zero\".into());\n+                }\n+                Ok(x / y)\n+            }\n+        \"#;\n+        check_apply_diagnostic_fix_from_position(before, after);\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {\n+        let content = r#\"\n+            //- /main.rs\n+            use std::{string::String, result::Result::{self, Ok, Err}};\n+\n+            fn foo() -> Result<String, i32> {\n+                0<|>\n+            }\n+\n+            //- /std/lib.rs\n+            pub mod string {\n+                pub struct String { }\n+            }\n+            pub mod result {\n+                pub enum Result<T, E> { Ok(T), Err(E) }\n+            }\n+        \"#;\n+        check_no_diagnostic_for_target_file(content);\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_not_applicable_when_return_type_is_not_result() {\n+        let content = r#\"\n+            //- /main.rs\n+            use std::{string::String, result::Result::{self, Ok, Err}};\n+\n+            enum SomeOtherEnum {\n+                Ok(i32),\n+                Err(String),\n+            }\n+\n+            fn foo() -> SomeOtherEnum {\n+                0<|>\n+            }\n+\n+            //- /std/lib.rs\n+            pub mod string {\n+                pub struct String { }\n+            }\n+            pub mod result {\n+                pub enum Result<T, E> { Ok(T), Err(E) }\n+            }\n+        \"#;\n+        check_no_diagnostic_for_target_file(content);\n+    }\n+\n     #[test]\n     fn test_fill_struct_fields_empty() {\n         let before = r\""}, {"sha": "992034ef0ff66318ff4ac6f3e0de8eac36b5ebdc", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd433ed194f7d3570c2bee2e5ac01917513e8aa3/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=cd433ed194f7d3570c2bee2e5ac01917513e8aa3", "patch": "@@ -31,6 +31,13 @@ impl SyntaxNodePtr {\n     pub fn kind(self) -> SyntaxKind {\n         self.kind\n     }\n+\n+    pub fn cast<N: AstNode>(self) -> Option<AstPtr<N>> {\n+        if !N::can_cast(self.kind()) {\n+            return None;\n+        }\n+        Some(AstPtr { raw: self, _ty: PhantomData })\n+    }\n }\n \n /// Like `SyntaxNodePtr`, but remembers the type of node"}]}