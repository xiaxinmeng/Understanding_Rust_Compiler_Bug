{"sha": "c20aed09307d1b486c22e9b62156b02500ae1e6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMGFlZDA5MzA3ZDFiNDg2YzIyZTliNjIxNTZiMDI1MDBhZTFlNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-13T01:52:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-13T01:52:02Z"}, "message": "auto merge of #14819 : michaelwoerister/rust/unique_type_id, r=alexcrichton\n\nWith this change, rustc creates a unique type identifier for types in debuginfo. These type identifiers are used by LLVM to correctly handle link-time-optimization scenarios but also help rustc with dealing with inlining from other crates. For more information, see the documentation block at the top of librustc/middle/trans/debuginfo.rs and also [my blog post about the topic](http://michaelwoerister.github.io/2014/06/05/rust-debuginfo-and-unique-type-identifiers.html). This should fix the LTO issues that have been popping up lately. \r\n\r\nThe changes to the debuginfo module's inner workings are also improved by this. Metadata uniquing of pointer types is not handled explicitly instead of relying on LLVM doing the right thing behind the scenes, and region parameters on types should not lead to metadata duplication anymore.\r\n\r\nThere are two things that I'd like to get some feedback on:\r\n1. IDs for named items consist of two parts: The [Strict Version Hash](https://github.com/mozilla/rust/blob/0.10/src/librustc/back/svh.rs#L11) of their defining crate and the AST node id of their definition within that crate. My question is: Is the SVH a good choice for identifying the crate? Is it even going to stay? The [crate-id RFC](https://github.com/rust-lang/rfcs/pull/109) got me confused.\r\n2. Unique Type Identifiers can be arbitrary strings and right now the format is rather verbose. For debugging this is nice, because one can infer a lot about a type from the type id alone (it's more or less a signature). For deeply nested generics, id strings could get rather long though. One option to limit the id size would be to use some hashcode instead of the full id (anything that avoids collision as much as possible). Another option would be to use a more compact representation, like ty_encode. This reduces size but also readability.\r\nSince these ID's only show up in LLVM IR, I'm inclined to just leave in the verbose format for now, and only act if sizes of rlibs become a problem.", "tree": {"sha": "28d934f7e26d644f804c9a0da18aa33bd02171a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28d934f7e26d644f804c9a0da18aa33bd02171a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c20aed09307d1b486c22e9b62156b02500ae1e6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c20aed09307d1b486c22e9b62156b02500ae1e6e", "html_url": "https://github.com/rust-lang/rust/commit/c20aed09307d1b486c22e9b62156b02500ae1e6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c20aed09307d1b486c22e9b62156b02500ae1e6e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c7f4b0e0baac739c12080dcbf83ed04c11e9a89", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c7f4b0e0baac739c12080dcbf83ed04c11e9a89", "html_url": "https://github.com/rust-lang/rust/commit/7c7f4b0e0baac739c12080dcbf83ed04c11e9a89"}, {"sha": "c7426cf05a166fca8aa76a690bad17111ea0dea4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7426cf05a166fca8aa76a690bad17111ea0dea4", "html_url": "https://github.com/rust-lang/rust/commit/c7426cf05a166fca8aa76a690bad17111ea0dea4"}], "stats": {"total": 875, "additions": 730, "deletions": 145}, "files": [{"sha": "ac9cec84715264e1f483bedce9a22342f2525054", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c20aed09307d1b486c22e9b62156b02500ae1e6e/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20aed09307d1b486c22e9b62156b02500ae1e6e/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=c20aed09307d1b486c22e9b62156b02500ae1e6e", "patch": "@@ -1809,6 +1809,7 @@ pub mod llvm {\n         pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n \n         pub fn LLVMRustSetDLLExportStorageClass(V: ValueRef);\n+        pub fn LLVMVersionMajor() -> c_int;\n         pub fn LLVMVersionMinor() -> c_int;\n \n         pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,"}, {"sha": "0b10db56cc42696eae3b5e68b52f50274e324c32", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 672, "deletions": 143, "changes": 815, "blob_url": "https://github.com/rust-lang/rust/blob/c20aed09307d1b486c22e9b62156b02500ae1e6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20aed09307d1b486c22e9b62156b02500ae1e6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c20aed09307d1b486c22e9b62156b02500ae1e6e", "patch": "@@ -122,9 +122,37 @@ prologue detection. The `create_argument_metadata()` and related functions take\n `llvm.dbg.declare` instructions to the correct source locations even while source location emission\n is still disabled, so there is no need to do anything special with source location handling here.\n \n+## Unique Type Identification\n+In order for link-time optimization to work properly, LLVM needs a unique type identifier that tells\n+it across compilation units which types are the same as others. This type identifier is created by\n+TypeMap::get_unique_type_id_of_type() using the following algorithm:\n+\n+(1) Primitive types have their name as ID\n+(2) Structs, enums and traits have a multipart identifier\n+    (1) The first part is the SVH (strict version hash) of the crate they were originally defined in\n+    (2) The second part is the ast::NodeId of the definition in their original crate\n+    (3) The final part is a concatenation of the type IDs of their concrete type arguments if they\n+        are generic types.\n+(3) Tuple-, pointer and function types are structurally identified, which means that they are\n+    equivalent if their component types are equivalent (i.e. (int, int) is the same regardless in\n+    which crate it is used).\n+\n+This algorithm also provides a stable ID for types that are defined in one crate but instantiated\n+from metadata within another crate. We just have to take care to always map crate and node IDs back\n+to the original crate context.\n+\n+As a side-effect these unique type IDs also help to solve a problem arising from lifetime\n+parameters. Since lifetime parameters are completely omitted in debuginfo, more than one `ty::t`\n+instance may map to the same debuginfo type metadata, that is, some struct `Struct<'a>` may have N\n+instantiations with different concrete substitutions for `'a`, and thus there will be N `ty::t`\n+instances for the type `Struct<'a>` even though it is not generic otherwise. Unfortunately this\n+means that we cannot use `ty::type_id()` as cheap identifier for type metadata---we have done this\n+in the past, but it led to unnecessary metadata duplication in the best case and LLVM assertions in\n+the worst. However, the unique type ID as described above *can* be used as identifier. Since it is\n+comparatively expensive to construct, though, `ty::type_id()` is still used additionally as an\n+optimization for cases where the exact same type has been seen before (which is most of the time).\n */\n \n-\n use driver::config;\n use driver::config::{FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use lib::llvm::llvm;\n@@ -151,7 +179,7 @@ use std::collections::HashSet;\n use std::gc::Gc;\n use std::ptr;\n use std::rc::{Rc, Weak};\n-use std::sync::atomics;\n+use syntax::util::interner::Interner;\n use syntax::codemap::{Span, Pos};\n use syntax::{abi, ast, codemap, ast_util, ast_map};\n use syntax::owned_slice::OwnedSlice;\n@@ -166,23 +194,377 @@ static DW_TAG_arg_variable: c_uint = 0x101;\n static DW_ATE_boolean: c_uint = 0x02;\n static DW_ATE_float: c_uint = 0x04;\n static DW_ATE_signed: c_uint = 0x05;\n-// static DW_ATE_signed_char: c_uint = 0x06;\n static DW_ATE_unsigned: c_uint = 0x07;\n static DW_ATE_unsigned_char: c_uint = 0x08;\n \n //=-------------------------------------------------------------------------------------------------\n //  Public Interface of debuginfo module\n //=-------------------------------------------------------------------------------------------------\n \n+#[deriving(Copy, Show, Hash, Eq, PartialEq, Clone)]\n+struct UniqueTypeId(ast::Name);\n+\n+// The TypeMap is where the CrateDebugContext holds the type metadata nodes created so far. The\n+// metadata nodes are indexed by UniqueTypeId, and, for faster lookup, also by ty::t. The\n+// TypeMap is responsible for creating UniqueTypeIds.\n+struct TypeMap {\n+    // The UniqueTypeIds created so far\n+    unique_id_interner: Interner<Rc<String>>,\n+    // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n+    unique_id_to_metadata: HashMap<UniqueTypeId, DIType>,\n+    // A map from ty::type_id() to debuginfo metadata. This is a N:1 mapping.\n+    type_to_metadata: HashMap<uint, DIType>,\n+    // A map from ty::type_id() to UniqueTypeId. This is a N:1 mapping.\n+    type_to_unique_id: HashMap<uint, UniqueTypeId>\n+}\n+\n+impl TypeMap {\n+\n+    fn new() -> TypeMap {\n+        TypeMap {\n+            unique_id_interner: Interner::new(),\n+            type_to_metadata: HashMap::new(),\n+            unique_id_to_metadata: HashMap::new(),\n+            type_to_unique_id: HashMap::new(),\n+        }\n+    }\n+\n+    // Adds a ty::t to metadata mapping to the TypeMap. The method will fail if the mapping already\n+    // exists.\n+    fn register_type_with_metadata(&mut self,\n+                                   cx: &CrateContext,\n+                                   type_: ty::t,\n+                                   metadata: DIType) {\n+        if !self.type_to_metadata.insert(ty::type_id(type_), metadata) {\n+            cx.sess().bug(format!(\"Type metadata for ty::t '{}' is already in the TypeMap!\",\n+                                  ppaux::ty_to_str(cx.tcx(), type_)).as_slice());\n+        }\n+    }\n+\n+    // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will fail if the mapping\n+    // already exists.\n+    fn register_unique_id_with_metadata(&mut self,\n+                                        cx: &CrateContext,\n+                                        unique_type_id: UniqueTypeId,\n+                                        metadata: DIType) {\n+        if !self.unique_id_to_metadata.insert(unique_type_id, metadata) {\n+            let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n+            cx.sess().bug(format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n+                                  unique_type_id_str.as_slice()).as_slice());\n+        }\n+    }\n+\n+    fn find_metadata_for_type(&self, type_: ty::t) -> Option<DIType> {\n+        self.type_to_metadata.find_copy(&ty::type_id(type_))\n+    }\n+\n+    fn find_metadata_for_unique_id(&self, unique_type_id: UniqueTypeId) -> Option<DIType> {\n+        self.unique_id_to_metadata.find_copy(&unique_type_id)\n+    }\n+\n+    // Get the string representation of a UniqueTypeId. This method will fail if the id is unknown.\n+    fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> Rc<String> {\n+        let UniqueTypeId(interner_key) = unique_type_id;\n+        self.unique_id_interner.get(interner_key)\n+    }\n+\n+    // Get the UniqueTypeId for the given type. If the UniqueTypeId for the given type has been\n+    // requested before, this is just a table lookup. Otherwise an ID will be generated and stored\n+    // for later lookup.\n+    fn get_unique_type_id_of_type(&mut self, cx: &CrateContext, type_: ty::t) -> UniqueTypeId {\n+\n+        // basic type           -> {:name of the type:}\n+        // tuple                -> {tuple_(:param-uid:)*}\n+        // struct               -> {struct_:svh: / :node-id:_<(:param-uid:),*> }\n+        // enum                 -> {enum_:svh: / :node-id:_<(:param-uid:),*> }\n+        // enum variant         -> {variant_:variant-name:_:enum-uid:}\n+        // reference (&)        -> {& :pointee-uid:}\n+        // mut reference (&mut) -> {&mut :pointee-uid:}\n+        // ptr (*)              -> {* :pointee-uid:}\n+        // mut ptr (*mut)       -> {*mut :pointee-uid:}\n+        // unique ptr (~)       -> {~ :pointee-uid:}\n+        // @-ptr (@)            -> {@ :pointee-uid:}\n+        // sized vec ([T, ..x]) -> {[:size:] :element-uid:}\n+        // vec slice (&[T])     -> {&<mut> [] :element-uid:}\n+        // trait (~ | &[mut] T) -> {:sigil: trait_:svh: / :node-id:_<(:param-uid:),*> }\n+        // closure              -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n+        //                             :return-type-uid: : (:bounds:)*}\n+        // function             -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n+        //                             :return-type-uid:}\n+\n+        match self.type_to_unique_id.find_copy(&ty::type_id(type_)) {\n+            Some(unique_type_id) => return unique_type_id,\n+            None => { /* generate one */}\n+        };\n+\n+        let mut unique_type_id = String::with_capacity(256);\n+        unique_type_id.push_char('{');\n+\n+        match ty::get(type_).sty {\n+            ty::ty_nil                |\n+            ty::ty_bot                |\n+            ty::ty_bool               |\n+            ty::ty_char               |\n+            ty::ty_str                |\n+            ty::ty_int(_)             |\n+            ty::ty_uint(_)            |\n+            ty::ty_float(_) => {\n+                unique_type_id.push_str(ppaux::ty_to_str(cx.tcx(), type_).as_slice());\n+            },\n+            ty::ty_enum(def_id, ref substs) => {\n+                unique_type_id.push_str(\"enum \");\n+                from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n+            },\n+            ty::ty_struct(def_id, ref substs) => {\n+                unique_type_id.push_str(\"struct \");\n+                from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n+            },\n+            ty::ty_tup(ref component_types) => {\n+                unique_type_id.push_str(\"tuple \");\n+                for &component_type in component_types.iter() {\n+                    let component_type_id = self.get_unique_type_id_of_type(cx, component_type);\n+                    let component_type_id = self.get_unique_type_id_as_string(component_type_id);\n+                    unique_type_id.push_str(component_type_id.as_slice());\n+                }\n+            },\n+            ty::ty_box(inner_type) => {\n+                unique_type_id.push_char('@');\n+                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n+                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n+                unique_type_id.push_str(inner_type_id.as_slice());\n+            },\n+            ty::ty_uniq(inner_type) => {\n+                unique_type_id.push_char('~');\n+                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n+                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n+                unique_type_id.push_str(inner_type_id.as_slice());\n+            },\n+            ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n+                unique_type_id.push_char('*');\n+                if mutbl == ast::MutMutable {\n+                    unique_type_id.push_str(\"mut\");\n+                }\n+\n+                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n+                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n+                unique_type_id.push_str(inner_type_id.as_slice());\n+            },\n+            ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n+                unique_type_id.push_char('&');\n+                if mutbl == ast::MutMutable {\n+                    unique_type_id.push_str(\"mut\");\n+                }\n+\n+                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n+                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n+                unique_type_id.push_str(inner_type_id.as_slice());\n+            },\n+            ty::ty_vec(ty::mt { ty: inner_type, mutbl }, optional_length) => {\n+                match optional_length {\n+                    Some(len) => {\n+                        unique_type_id.push_str(format!(\"[{}]\", len).as_slice());\n+                    }\n+                    None => {\n+                        unique_type_id.push_char('&');\n+\n+                        if mutbl == ast::MutMutable {\n+                           unique_type_id.push_str(\"mut\");\n+                        }\n+\n+                        unique_type_id.push_str(\"[]\");\n+                    }\n+                };\n+\n+                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n+                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n+                unique_type_id.push_str(inner_type_id.as_slice());\n+            },\n+            ty::ty_trait(ref trait_data) => {\n+                match trait_data.store {\n+                    ty::UniqTraitStore => unique_type_id.push_char('~'),\n+                    ty::RegionTraitStore(_, ast::MutMutable) => unique_type_id.push_str(\"&mut\"),\n+                    ty::RegionTraitStore(_, ast::MutImmutable) => unique_type_id.push_char('&'),\n+                };\n+\n+                unique_type_id.push_str(\"trait \");\n+\n+                from_def_id_and_substs(self,\n+                                       cx,\n+                                       trait_data.def_id,\n+                                       &trait_data.substs,\n+                                       &mut unique_type_id);\n+            },\n+            ty::ty_bare_fn(ty::BareFnTy{ fn_style, abi, ref sig } ) => {\n+                if fn_style == ast::UnsafeFn {\n+                    unique_type_id.push_str(\"unsafe \");\n+                }\n+\n+                unique_type_id.push_str(abi.name());\n+\n+                unique_type_id.push_str(\" fn(\");\n+\n+                for &parameter_type in sig.inputs.iter() {\n+                    let parameter_type_id = self.get_unique_type_id_of_type(cx, parameter_type);\n+                    let parameter_type_id = self.get_unique_type_id_as_string(parameter_type_id);\n+                    unique_type_id.push_str(parameter_type_id.as_slice());\n+                    unique_type_id.push_char(',');\n+                }\n+\n+                if sig.variadic {\n+                    unique_type_id.push_str(\"...\");\n+                }\n+\n+                unique_type_id.push_str(\")->\");\n+                let return_type_id = self.get_unique_type_id_of_type(cx, sig.output);\n+                let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n+                unique_type_id.push_str(return_type_id.as_slice());\n+            },\n+            ty::ty_closure(box ty::ClosureTy { fn_style,\n+                                               onceness,\n+                                               store,\n+                                               ref bounds,\n+                                               ref sig }) => {\n+                if fn_style == ast::UnsafeFn {\n+                    unique_type_id.push_str(\"unsafe \");\n+                }\n+\n+                if onceness == ast::Once {\n+                    unique_type_id.push_str(\"once \");\n+                }\n+\n+                match store {\n+                    ty::UniqTraitStore => unique_type_id.push_str(\"~|\"),\n+                    ty::RegionTraitStore(_, ast::MutMutable) => unique_type_id.push_str(\"&mut|\"),\n+                    ty::RegionTraitStore(_, ast::MutImmutable) => unique_type_id.push_str(\"&|\"),\n+                };\n+\n+                for &parameter_type in sig.inputs.iter() {\n+                    let parameter_type_id = self.get_unique_type_id_of_type(cx, parameter_type);\n+                    let parameter_type_id = self.get_unique_type_id_as_string(parameter_type_id);\n+                    unique_type_id.push_str(parameter_type_id.as_slice());\n+                    unique_type_id.push_char(',');\n+                }\n+\n+                if sig.variadic {\n+                    unique_type_id.push_str(\"...\");\n+                }\n+\n+                unique_type_id.push_str(\"|->\");\n+\n+                let return_type_id = self.get_unique_type_id_of_type(cx, sig.output);\n+                let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n+                unique_type_id.push_str(return_type_id.as_slice());\n+\n+                unique_type_id.push_char(':');\n+\n+                for bound in bounds.iter() {\n+                    match bound {\n+                        ty::BoundStatic => unique_type_id.push_str(\"'static\"),\n+                        ty::BoundSend => unique_type_id.push_str(\"Send\"),\n+                        ty::BoundSized => unique_type_id.push_str(\"Sized\"),\n+                        ty::BoundCopy => unique_type_id.push_str(\"Copy\"),\n+                        ty::BoundShare => unique_type_id.push_str(\"Share\"),\n+                    };\n+                    unique_type_id.push_char('+');\n+                }\n+            },\n+            _ => {\n+                cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n+                                      ppaux::ty_to_str(cx.tcx(), type_).as_slice(),\n+                                      ty::get(type_).sty).as_slice())\n+            }\n+        };\n+\n+        unique_type_id.push_char('}');\n+\n+        // Trim to size before storing permanently\n+        unique_type_id.shrink_to_fit();\n+\n+        let key = self.unique_id_interner.intern(Rc::new(unique_type_id));\n+        self.type_to_unique_id.insert(ty::type_id(type_), UniqueTypeId(key));\n+\n+        return UniqueTypeId(key);\n+\n+        fn from_def_id_and_substs(type_map: &mut TypeMap,\n+                                  cx: &CrateContext,\n+                                  def_id: ast::DefId,\n+                                  substs: &subst::Substs,\n+                                  output: &mut String) {\n+            use std::num::ToStrRadix;\n+\n+            // First, find out the 'real' def_id of the type. Items inlined from other crates have\n+            // to be mapped back to their source.\n+            let source_def_id = if def_id.krate == ast::LOCAL_CRATE {\n+                match cx.external_srcs.borrow().find_copy(&def_id.node) {\n+                    Some(source_def_id) => {\n+                        // The given def_id identifies the inlined copy of a type definition,\n+                        // let's take the source of the copy\n+                        source_def_id\n+                    }\n+                    None => def_id\n+                }\n+            } else {\n+                def_id\n+            };\n+\n+            // Get the crate hash as first part of the identifier\n+            let crate_hash = if source_def_id.krate == ast::LOCAL_CRATE {\n+                cx.link_meta.crate_hash.clone()\n+            } else {\n+                cx.sess().cstore.get_crate_hash(source_def_id.krate)\n+            };\n+\n+            output.push_str(crate_hash.as_str());\n+            output.push_str(\"/\");\n+            output.push_str(def_id.node.to_str_radix(16).as_slice());\n+\n+            // Maybe check that there is no self type here\n+\n+            if substs.tps.len() > 0 {\n+                output.push_char('<');\n+\n+                for &type_parameter in substs.tps.iter() {\n+                    let param_type_id = type_map.get_unique_type_id_of_type(cx, type_parameter);\n+                    let param_type_id = type_map.get_unique_type_id_as_string(param_type_id);\n+                    output.push_str(param_type_id.as_slice());\n+                    output.push_char(',');\n+                }\n+\n+                output.push_char('>');\n+            }\n+        }\n+    }\n+\n+    // Get the UniqueTypeId for an enum variant. Enum variants are not really types of their own,\n+    // so they need special handling. We still need a UniqueTypeId for them, since to debuginfo they\n+    // *are* real types.\n+    fn get_unique_type_id_of_enum_variant(&mut self,\n+                                          cx: &CrateContext,\n+                                          enum_type: ty::t,\n+                                          variant_name: &str)\n+                                       -> UniqueTypeId {\n+        let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n+        let enum_variant_type_id = format!(\"{}::{}\",\n+                                           self.get_unique_type_id_as_string(enum_type_id)\n+                                               .as_slice(),\n+                                           variant_name);\n+        let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n+        UniqueTypeId(interner_key)\n+    }\n+}\n+\n+\n /// A context object for maintaining all state needed by the debuginfo module.\n pub struct CrateDebugContext {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n     current_debug_location: Cell<DebugLocation>,\n     created_files: RefCell<HashMap<String, DIFile>>,\n-    created_types: RefCell<HashMap<uint, DIType>>,\n     created_enum_disr_types: RefCell<HashMap<ast::DefId, DIType>>,\n+\n+    type_map: RefCell<TypeMap>,\n     namespace_map: RefCell<HashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n+\n     // This collection is used to assert that composite types (structs, enums, ...) have their\n     // members only set once:\n     composite_types_completed: RefCell<HashSet<DIType>>,\n@@ -199,8 +581,8 @@ impl CrateDebugContext {\n             builder: builder,\n             current_debug_location: Cell::new(UnknownLocation),\n             created_files: RefCell::new(HashMap::new()),\n-            created_types: RefCell::new(HashMap::new()),\n             created_enum_disr_types: RefCell::new(HashMap::new()),\n+            type_map: RefCell::new(TypeMap::new()),\n             namespace_map: RefCell::new(HashMap::new()),\n             composite_types_completed: RefCell::new(HashSet::new()),\n         };\n@@ -1255,7 +1637,8 @@ impl MemberDescriptionFactory {\n // more information.\n enum RecursiveTypeDescription {\n     UnfinishedMetadata {\n-        cache_id: uint,\n+        unfinished_type: ty::t,\n+        unique_type_id: UniqueTypeId,\n         metadata_stub: DICompositeType,\n         llvm_type: Type,\n         file_metadata: DIFile,\n@@ -1264,22 +1647,59 @@ enum RecursiveTypeDescription {\n     FinalMetadata(DICompositeType)\n }\n \n+fn create_and_register_recursive_type_forward_declaration(\n+    cx: &CrateContext,\n+    unfinished_type: ty::t,\n+    unique_type_id: UniqueTypeId,\n+    metadata_stub: DICompositeType,\n+    llvm_type: Type,\n+    file_metadata: DIFile,\n+    member_description_factory: MemberDescriptionFactory)\n+ -> RecursiveTypeDescription {\n+\n+    // Insert the stub into the TypeMap in order to allow for recursive references\n+    let mut type_map = debug_context(cx).type_map.borrow_mut();\n+    type_map.register_unique_id_with_metadata(cx, unique_type_id, metadata_stub);\n+    type_map.register_type_with_metadata(cx, unfinished_type, metadata_stub);\n+\n+    UnfinishedMetadata {\n+        unfinished_type: unfinished_type,\n+        unique_type_id: unique_type_id,\n+        metadata_stub: metadata_stub,\n+        llvm_type: llvm_type,\n+        file_metadata: file_metadata,\n+        member_description_factory: member_description_factory,\n+    }\n+}\n+\n impl RecursiveTypeDescription {\n     // Finishes up the description of the type in question (mostly by providing descriptions of the\n     // fields of the given type) and returns the final type metadata.\n     fn finalize(&self, cx: &CrateContext) -> DICompositeType {\n         match *self {\n             FinalMetadata(metadata) => metadata,\n             UnfinishedMetadata {\n-                cache_id,\n+                unfinished_type,\n+                unique_type_id,\n                 metadata_stub,\n                 llvm_type,\n                 file_metadata,\n                 ref member_description_factory\n             } => {\n-                // Insert the stub into the cache in order to allow recursive references ...\n-                debug_context(cx).created_types.borrow_mut()\n-                                 .insert(cache_id, metadata_stub);\n+                // Make sure that we have a forward declaration of the type in the TypeMap so that\n+                // recursive references are possible. This will always be the case if the\n+                // RecursiveTypeDescription has been properly created through the\n+                // create_and_register_recursive_type_forward_declaration() function.\n+                {\n+                    let type_map = debug_context(cx).type_map.borrow();\n+                    if type_map.find_metadata_for_unique_id(unique_type_id).is_none() ||\n+                       type_map.find_metadata_for_type(unfinished_type).is_none() {\n+                        cx.sess().bug(format!(\"Forward declaration of potentially recursive type \\\n+                                              '{}' was not found in TypeMap!\",\n+                                              ppaux::ty_to_str(cx.tcx(), unfinished_type))\n+                                      .as_slice());\n+                    }\n+                }\n \n                 // ... then create the member descriptions ...\n                 let member_descriptions = member_description_factory.create_member_descriptions(cx);\n@@ -1349,6 +1769,7 @@ fn prepare_struct_metadata(cx: &CrateContext,\n                            struct_type: ty::t,\n                            def_id: ast::DefId,\n                            substs: &subst::Substs,\n+                           unique_type_id: UniqueTypeId,\n                            span: Span)\n                         -> RecursiveTypeDescription {\n     let struct_name = ppaux::ty_to_str(cx.tcx(), struct_type);\n@@ -1362,23 +1783,26 @@ fn prepare_struct_metadata(cx: &CrateContext,\n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n                                                   struct_name.as_slice(),\n+                                                  unique_type_id,\n                                                   containing_scope,\n                                                   file_metadata,\n                                                   definition_span);\n \n     let fields = ty::struct_fields(cx.tcx(), def_id, substs);\n \n-    UnfinishedMetadata {\n-        cache_id: cache_id_for_type(struct_type),\n-        metadata_stub: struct_metadata_stub,\n-        llvm_type: struct_llvm_type,\n-        file_metadata: file_metadata,\n-        member_description_factory: StructMDF(StructMemberDescriptionFactory {\n+    create_and_register_recursive_type_forward_declaration(\n+        cx,\n+        struct_type,\n+        unique_type_id,\n+        struct_metadata_stub,\n+        struct_llvm_type,\n+        file_metadata,\n+        StructMDF(StructMemberDescriptionFactory {\n             fields: fields,\n             is_simd: ty::type_is_simd(cx.tcx(), struct_type),\n             span: span,\n-        }),\n-    }\n+        })\n+    )\n }\n \n \n@@ -1409,6 +1833,7 @@ impl TupleMemberDescriptionFactory {\n fn prepare_tuple_metadata(cx: &CrateContext,\n                           tuple_type: ty::t,\n                           component_types: &[ty::t],\n+                          unique_type_id: UniqueTypeId,\n                           span: Span)\n                        -> RecursiveTypeDescription {\n     let tuple_name = ppaux::ty_to_str(cx.tcx(), tuple_type);\n@@ -1417,21 +1842,24 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n-    UnfinishedMetadata {\n-        cache_id: cache_id_for_type(tuple_type),\n-        metadata_stub: create_struct_stub(cx,\n-                                          tuple_llvm_type,\n-                                          tuple_name.as_slice(),\n-                                          file_metadata,\n-                                          file_metadata,\n-                                          span),\n-        llvm_type: tuple_llvm_type,\n-        file_metadata: file_metadata,\n-        member_description_factory: TupleMDF(TupleMemberDescriptionFactory {\n+    create_and_register_recursive_type_forward_declaration(\n+        cx,\n+        tuple_type,\n+        unique_type_id,\n+        create_struct_stub(cx,\n+                           tuple_llvm_type,\n+                           tuple_name.as_slice(),\n+                           unique_type_id,\n+                           file_metadata,\n+                           file_metadata,\n+                           span),\n+        tuple_llvm_type,\n+        file_metadata,\n+        TupleMDF(TupleMemberDescriptionFactory {\n             component_types: Vec::from_slice(component_types),\n             span: span,\n         })\n-    }\n+    )\n }\n \n \n@@ -1444,6 +1872,7 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n // variant of the given enum, this factory will produce one MemberDescription (all with no name and\n // a fixed offset of zero bytes).\n struct EnumMemberDescriptionFactory {\n+    enum_type: ty::t,\n     type_rep: Rc<adt::Repr>,\n     variants: Rc<Vec<Rc<ty::VariantInfo>>>,\n     discriminant_type_metadata: Option<DIType>,\n@@ -1465,6 +1894,7 @@ impl EnumMemberDescriptionFactory {\n                     .map(|(i, struct_def)| {\n                         let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n                             describe_enum_variant(cx,\n+                                                  self.enum_type,\n                                                   struct_def,\n                                                   &**self.variants.get(i),\n                                                   discriminant_info,\n@@ -1497,6 +1927,7 @@ impl EnumMemberDescriptionFactory {\n                 } else {\n                     let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n                         describe_enum_variant(cx,\n+                                              self.enum_type,\n                                               struct_def,\n                                               &**self.variants.get(0),\n                                               NoDiscriminant,\n@@ -1551,11 +1982,19 @@ impl EnumMemberDescriptionFactory {\n                     offset: FixedMemberOffset { bytes: 0 },\n                 };\n \n+                let unique_type_id = debug_context(cx).type_map\n+                                                      .borrow_mut()\n+                                                      .get_unique_type_id_of_enum_variant(\n+                                                          cx,\n+                                                          self.enum_type,\n+                                                          non_null_variant_name.get());\n+\n                 // Now we can create the metadata of the artificial struct\n                 let artificial_struct_metadata =\n                     composite_type_metadata(cx,\n                                             artificial_struct_llvm_type,\n                                             non_null_variant_name.get(),\n+                                            unique_type_id,\n                                             &[sole_struct_member_description],\n                                             self.containing_scope,\n                                             self.file_metadata,\n@@ -1581,6 +2020,7 @@ impl EnumMemberDescriptionFactory {\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n                     describe_enum_variant(cx,\n+                                          self.enum_type,\n                                           struct_def,\n                                           &**self.variants.get(nndiscr as uint),\n                                           OptimizedDiscriminant(ptrfield),\n@@ -1654,6 +2094,7 @@ enum EnumDiscriminantInfo {\n // (3) a MemberDescriptionFactory for producing the descriptions of the fields of the variant. This\n // is a rudimentary version of a full RecursiveTypeDescription.\n fn describe_enum_variant(cx: &CrateContext,\n+                         enum_type: ty::t,\n                          struct_def: &adt::Struct,\n                          variant_info: &ty::VariantInfo,\n                          discriminant_info: EnumDiscriminantInfo,\n@@ -1678,9 +2119,19 @@ fn describe_enum_variant(cx: &CrateContext,\n         codemap::DUMMY_SP\n     };\n \n+    let variant_name = token::get_ident(variant_info.name);\n+    let variant_name = variant_name.get();\n+    let unique_type_id = debug_context(cx).type_map\n+                                          .borrow_mut()\n+                                          .get_unique_type_id_of_enum_variant(\n+                                              cx,\n+                                              enum_type,\n+                                              variant_name);\n+\n     let metadata_stub = create_struct_stub(cx,\n                                            variant_llvm_type,\n-                                           token::get_ident(variant_info.name).get(),\n+                                           variant_name,\n+                                           unique_type_id,\n                                            containing_scope,\n                                            file_metadata,\n                                            variant_definition_span);\n@@ -1724,6 +2175,7 @@ fn describe_enum_variant(cx: &CrateContext,\n fn prepare_enum_metadata(cx: &CrateContext,\n                          enum_type: ty::t,\n                          enum_def_id: ast::DefId,\n+                         unique_type_id: UniqueTypeId,\n                          span: Span)\n                       -> RecursiveTypeDescription {\n     let enum_name = ppaux::ty_to_str(cx.tcx(), enum_type);\n@@ -1804,10 +2256,14 @@ fn prepare_enum_metadata(cx: &CrateContext,\n \n     let enum_llvm_type = type_of::type_of(cx, enum_type);\n     let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n-    let unique_id = generate_unique_type_id(\"DI_ENUM_\");\n+\n+    let unique_type_id_str = debug_context(cx)\n+                             .type_map\n+                             .borrow()\n+                             .get_unique_type_id_as_string(unique_type_id);\n \n     let enum_metadata = enum_name.as_slice().with_c_str(|enum_name| {\n-        unique_id.as_slice().with_c_str(|unique_id| {\n+        unique_type_id_str.as_slice().with_c_str(|unique_type_id_str| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateUnionType(\n                 DIB(cx),\n@@ -1820,25 +2276,28 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                 0, // Flags\n                 ptr::null(),\n                 0, // RuntimeLang\n-                unique_id)\n+                unique_type_id_str)\n             }\n         })\n     });\n \n-    return UnfinishedMetadata {\n-        cache_id: cache_id_for_type(enum_type),\n-        metadata_stub: enum_metadata,\n-        llvm_type: enum_llvm_type,\n-        file_metadata: file_metadata,\n-        member_description_factory: EnumMDF(EnumMemberDescriptionFactory {\n+    return create_and_register_recursive_type_forward_declaration(\n+        cx,\n+        enum_type,\n+        unique_type_id,\n+        enum_metadata,\n+        enum_llvm_type,\n+        file_metadata,\n+        EnumMDF(EnumMemberDescriptionFactory {\n+            enum_type: enum_type,\n             type_rep: type_rep.clone(),\n             variants: variants,\n             discriminant_type_metadata: discriminant_type_metadata,\n             containing_scope: containing_scope,\n             file_metadata: file_metadata,\n             span: span,\n         }),\n-    };\n+    );\n \n     fn get_enum_discriminant_name(cx: &CrateContext, def_id: ast::DefId) -> token::InternedString {\n         let name = if def_id.krate == ast::LOCAL_CRATE {\n@@ -1857,6 +2316,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n fn composite_type_metadata(cx: &CrateContext,\n                            composite_llvm_type: Type,\n                            composite_type_name: &str,\n+                           composite_type_unique_id: UniqueTypeId,\n                            member_descriptions: &[MemberDescription],\n                            containing_scope: DIScope,\n                            file_metadata: DIFile,\n@@ -1866,10 +2326,10 @@ fn composite_type_metadata(cx: &CrateContext,\n     let composite_type_metadata = create_struct_stub(cx,\n                                                      composite_llvm_type,\n                                                      composite_type_name,\n+                                                     composite_type_unique_id,\n                                                      containing_scope,\n                                                      file_metadata,\n                                                      definition_span);\n-\n     // ... and immediately create and add the member descriptions.\n     set_members_of_composite_type(cx,\n                                   composite_type_metadata,\n@@ -1895,9 +2355,22 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         let mut composite_types_completed =\n             debug_context(cx).composite_types_completed.borrow_mut();\n         if composite_types_completed.contains(&composite_type_metadata) {\n-            cx.sess().span_bug(definition_span, \"debuginfo::set_members_of_composite_type() - \\\n-                                                 Already completed forward declaration \\\n-                                                 re-encountered.\");\n+            let (llvm_version_major, llvm_version_minor) = unsafe {\n+                (llvm::LLVMVersionMajor(), llvm::LLVMVersionMinor())\n+            };\n+\n+            let actual_llvm_version = llvm_version_major * 1000000 + llvm_version_minor * 1000;\n+            let min_supported_llvm_version = 3 * 1000000 + 4 * 1000;\n+\n+            if actual_llvm_version < min_supported_llvm_version {\n+                cx.sess().warn(format!(\"This version of rustc was built with LLVM {}.{}. \\\n+                    Rustc just ran into a known debuginfo corruption problem that \\\n+                    often occurs with LLVM versions below 3.4. Please use a rustc built with a \\\n+                    newer version of LLVM.\", llvm_version_major, llvm_version_minor).as_slice());\n+            } else {\n+                cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n+                               Already completed forward declaration re-encountered.\");\n+            }\n         } else {\n             composite_types_completed.insert(composite_type_metadata);\n         }\n@@ -1944,20 +2417,20 @@ fn set_members_of_composite_type(cx: &CrateContext,\n fn create_struct_stub(cx: &CrateContext,\n                       struct_llvm_type: Type,\n                       struct_type_name: &str,\n+                      unique_type_id: UniqueTypeId,\n                       containing_scope: DIScope,\n                       file_metadata: DIFile,\n                       definition_span: Span)\n                    -> DICompositeType {\n     let loc = span_start(cx, definition_span);\n     let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n \n-    // We assign unique IDs to the type stubs so LLVM metadata uniquing does not reuse instances\n-    // where we don't want it.\n-    let unique_id = generate_unique_type_id(\"DI_STRUCT_\");\n-\n-    return unsafe {\n+    let unique_type_id_str = debug_context(cx).type_map\n+                                              .borrow()\n+                                              .get_unique_type_id_as_string(unique_type_id);\n+    let metadata_stub = unsafe {\n         struct_type_name.with_c_str(|name| {\n-            unique_id.as_slice().with_c_str(|unique_id| {\n+            unique_type_id_str.as_slice().with_c_str(|unique_type_id| {\n                 // LLVMDIBuilderCreateStructType() wants an empty array. A null pointer will lead to\n                 // hard to trace and debug LLVM assertions later on in llvm/lib/IR/Value.cpp\n                 let empty_array = create_DIArray(DIB(cx), []);\n@@ -1975,23 +2448,23 @@ fn create_struct_stub(cx: &CrateContext,\n                     empty_array,\n                     0,\n                     ptr::null(),\n-                    unique_id)\n+                    unique_type_id)\n             })\n         })\n     };\n+\n+    return metadata_stub;\n }\n \n-fn boxed_type_metadata(cx: &CrateContext,\n-                       content_type_name: Option<&str>,\n-                       content_llvm_type: Type,\n-                       content_type_metadata: DIType,\n-                       span: Span)\n-                    -> DICompositeType {\n-    let box_type_name = match content_type_name {\n-        Some(content_type_name) => format!(\"Boxed<{}>\", content_type_name),\n-        None                    => \"BoxedType\".to_string()\n-    };\n+fn at_box_metadata(cx: &CrateContext,\n+                   content_type: ty::t,\n+                   unique_type_id: UniqueTypeId) -> DIType {\n+    let content_type_name = ppaux::ty_to_str(cx.tcx(), content_type);\n+    let content_type_name = content_type_name.as_slice();\n+    let content_llvm_type = type_of::type_of(cx, content_type);\n+    let content_type_metadata = type_metadata(cx, content_type, codemap::DUMMY_SP);\n \n+    let box_type_name = format!(\"Boxed<{}>\", content_type_name);\n     let box_llvm_type = Type::at_box(cx, content_llvm_type);\n     let member_llvm_types = box_llvm_type.field_types();\n     assert!(box_layout_is_correct(cx,\n@@ -2035,17 +2508,18 @@ fn boxed_type_metadata(cx: &CrateContext,\n         }\n     ];\n \n-    let loc = span_start(cx, span);\n+    let loc = span_start(cx, codemap::DUMMY_SP);\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n     return composite_type_metadata(\n         cx,\n         box_llvm_type,\n         box_type_name.as_slice(),\n+        unique_type_id,\n         member_descriptions,\n         file_metadata,\n         file_metadata,\n-        span);\n+        codemap::DUMMY_SP);\n \n     // Unfortunately, we cannot assert anything but the correct types here---and not whether the\n     // 'next' and 'prev' pointers are in the correct order.\n@@ -2062,6 +2536,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n     }\n }\n \n+\n fn fixed_vec_metadata(cx: &CrateContext,\n                       element_type: ty::t,\n                       len: uint,\n@@ -2089,18 +2564,19 @@ fn fixed_vec_metadata(cx: &CrateContext,\n     };\n }\n \n-fn vec_metadata(cx: &CrateContext,\n-                element_type: ty::t,\n-                span: Span)\n-             -> DICompositeType {\n+fn heap_vec_metadata(cx: &CrateContext,\n+                     vec_type: ty::t,\n+                     element_type: ty::t,\n+                     unique_type_id: UniqueTypeId,\n+                     span: Span)\n+                  -> DICompositeType {\n \n     let element_type_metadata = type_metadata(cx, element_type, span);\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n     let vec_llvm_type = Type::vec(cx, &element_llvm_type);\n-    let vec_type_name = format!(\"[{}]\",\n-                                ppaux::ty_to_str(cx.tcx(), element_type));\n+    let vec_type_name = ppaux::ty_to_str(cx.tcx(), vec_type);\n     let vec_type_name = vec_type_name.as_slice();\n \n     let member_llvm_types = vec_llvm_type.field_types();\n@@ -2145,6 +2621,7 @@ fn vec_metadata(cx: &CrateContext,\n         cx,\n         vec_llvm_type,\n         vec_type_name,\n+        unique_type_id,\n         member_descriptions,\n         file_metadata,\n         file_metadata,\n@@ -2154,6 +2631,7 @@ fn vec_metadata(cx: &CrateContext,\n fn vec_slice_metadata(cx: &CrateContext,\n                       vec_type: ty::t,\n                       element_type: ty::t,\n+                      unique_type_id: UniqueTypeId,\n                       span: Span)\n                    -> DICompositeType {\n \n@@ -2196,6 +2674,7 @@ fn vec_slice_metadata(cx: &CrateContext,\n         cx,\n         slice_llvm_type,\n         slice_type_name.as_slice(),\n+        unique_type_id,\n         member_descriptions,\n         file_metadata,\n         file_metadata,\n@@ -2218,8 +2697,7 @@ fn subroutine_type_metadata(cx: &CrateContext,\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n-    let mut signature_metadata: Vec<DIType> =\n-        Vec::with_capacity(signature.inputs.len() + 1);\n+    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n     signature_metadata.push(match ty::get(signature.output).sty {\n@@ -2245,7 +2723,8 @@ fn trait_metadata(cx: &CrateContext,\n                   trait_type: ty::t,\n                   substs: &subst::Substs,\n                   trait_store: ty::TraitStore,\n-                  _: &ty::BuiltinBounds)\n+                  _: &ty::BuiltinBounds,\n+                  unique_type_id: UniqueTypeId)\n                -> DIType {\n     // The implementation provided here is a stub. It makes sure that the trait type is\n     // assigned the correct name, size, namespace, and source location. But it does not describe\n@@ -2272,126 +2751,190 @@ fn trait_metadata(cx: &CrateContext,\n     composite_type_metadata(cx,\n                             trait_llvm_type,\n                             name.as_slice(),\n+                            unique_type_id,\n                             [],\n                             containing_scope,\n                             file_metadata,\n                             definition_span)\n }\n \n+\n fn type_metadata(cx: &CrateContext,\n                  t: ty::t,\n                  usage_site_span: Span)\n               -> DIType {\n-    let cache_id = cache_id_for_type(t);\n-\n-    match debug_context(cx).created_types.borrow().find(&cache_id) {\n-        Some(type_metadata) => return *type_metadata,\n-        None => ()\n-    }\n-\n-    fn create_pointer_to_box_metadata(cx: &CrateContext,\n-                                      pointer_type: ty::t,\n-                                      type_in_box: ty::t)\n-                                   -> DIType {\n-        let content_type_name = ppaux::ty_to_str(cx.tcx(), type_in_box);\n-        let content_type_name = content_type_name.as_slice();\n-        let content_llvm_type = type_of::type_of(cx, type_in_box);\n-        let content_type_metadata = type_metadata(\n-            cx,\n-            type_in_box,\n-            codemap::DUMMY_SP);\n-\n-        let box_metadata = boxed_type_metadata(\n-            cx,\n-            Some(content_type_name),\n-            content_llvm_type,\n-            content_type_metadata,\n-            codemap::DUMMY_SP);\n-\n-        pointer_type_metadata(cx, pointer_type, box_metadata)\n-    }\n+    // Get the unique type id of this type.\n+    let unique_type_id = {\n+        let mut type_map = debug_context(cx).type_map.borrow_mut();\n+        match type_map.find_metadata_for_type(t) {\n+            Some(metadata) => {\n+                return metadata;\n+            },\n+            None => {\n+                let unique_type_id = type_map.get_unique_type_id_of_type(cx, t);\n+                match type_map.find_metadata_for_unique_id(unique_type_id) {\n+                    Some(metadata) => {\n+                        type_map.register_type_with_metadata(cx, t, metadata);\n+                        return metadata;\n+                    },\n+                    None => {\n+                        // There really is no type metadata for this type, so proceed by creating\n+                        // it\n+                        unique_type_id\n+                    }\n+                }\n+            }\n+        }\n+    };\n \n     debug!(\"type_metadata: {:?}\", ty::get(t));\n \n+    macro_rules! return_if_created_in_meantime(\n+        () => (\n+            match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n+                Some(metadata) => return metadata,\n+                None => { /* proceed normally */ }\n+            };\n+        )\n+    )\n+\n     let sty = &ty::get(t).sty;\n-    let type_metadata = match *sty {\n+    let (type_metadata, should_already_be_stored_in_typemap) = match *sty {\n         ty::ty_nil      |\n         ty::ty_bot      |\n         ty::ty_bool     |\n         ty::ty_char     |\n         ty::ty_int(_)   |\n         ty::ty_uint(_)  |\n         ty::ty_float(_) => {\n-            basic_type_metadata(cx, t)\n+            (basic_type_metadata(cx, t), false)\n         }\n         ty::ty_enum(def_id, _) => {\n-            prepare_enum_metadata(cx, t, def_id, usage_site_span).finalize(cx)\n+            let is_c_style_enum = match *adt::represent_type(cx, t) {\n+                adt::CEnum(..) => true,\n+                _ => false\n+            };\n+\n+            (prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx),\n+             !is_c_style_enum)\n+        }\n+        ty::ty_box(pointee_type) => {\n+            let box_content_metadata = at_box_metadata(cx, pointee_type, unique_type_id);\n+            return_if_created_in_meantime!();\n+            (pointer_type_metadata(cx, t, box_content_metadata), false)\n         }\n-        ty::ty_box(typ) => {\n-            create_pointer_to_box_metadata(cx, t, typ)\n+        ty::ty_vec(ref mt, Some(len)) => {\n+            (fixed_vec_metadata(cx, mt.ty, len, usage_site_span), false)\n         }\n-        ty::ty_vec(ref mt, Some(len)) => fixed_vec_metadata(cx, mt.ty, len, usage_site_span),\n-        ty::ty_uniq(typ) => {\n-            match ty::get(typ).sty {\n+        ty::ty_uniq(pointee_type) => {\n+            (match ty::get(pointee_type).sty {\n                 ty::ty_vec(ref mt, None) => {\n-                    let vec_metadata = vec_metadata(cx, mt.ty, usage_site_span);\n+                    let vec_metadata = heap_vec_metadata(cx,\n+                                                         pointee_type,\n+                                                         mt.ty,\n+                                                         unique_type_id,\n+                                                         usage_site_span);\n+                    return_if_created_in_meantime!();\n                     pointer_type_metadata(cx, t, vec_metadata)\n                 }\n                 ty::ty_str => {\n                     let i8_t = ty::mk_i8();\n-                    let vec_metadata = vec_metadata(cx, i8_t, usage_site_span);\n+                    let vec_metadata = heap_vec_metadata(cx,\n+                                                         pointee_type,\n+                                                         i8_t,\n+                                                         unique_type_id,\n+                                                         usage_site_span);\n                     pointer_type_metadata(cx, t, vec_metadata)\n                 }\n                 _ => {\n-                    let pointee = type_metadata(cx, typ, usage_site_span);\n-                    pointer_type_metadata(cx, t, pointee)\n+                    let pointee_metadata = type_metadata(cx, pointee_type, usage_site_span);\n+                    return_if_created_in_meantime!();\n+                    pointer_type_metadata(cx, t, pointee_metadata)\n                 }\n-            }\n+            }, false)\n         }\n         ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n-            match ty::get(mt.ty).sty {\n-                ty::ty_vec(ref mt, None) => vec_slice_metadata(cx, t, mt.ty, usage_site_span),\n+            (match ty::get(mt.ty).sty {\n+                ty::ty_vec(ref mt, None) => {\n+                    vec_slice_metadata(cx, t, mt.ty, unique_type_id, usage_site_span)\n+                }\n                 ty::ty_str => {\n                     let i8_t = ty::mk_i8();\n-                    vec_slice_metadata(cx, t, i8_t, usage_site_span)\n+                    vec_slice_metadata(cx, t, i8_t, unique_type_id, usage_site_span)\n                 }\n                 _ => {\n                     let pointee = type_metadata(cx, mt.ty, usage_site_span);\n+                    return_if_created_in_meantime!();\n                     pointer_type_metadata(cx, t, pointee)\n                 }\n-            }\n+            }, false)\n         }\n         ty::ty_bare_fn(ref barefnty) => {\n-            subroutine_type_metadata(cx, &barefnty.sig, usage_site_span)\n+            (subroutine_type_metadata(cx, &barefnty.sig, usage_site_span), false)\n         }\n         ty::ty_closure(ref closurety) => {\n-            subroutine_type_metadata(cx, &closurety.sig, usage_site_span)\n+            (subroutine_type_metadata(cx, &closurety.sig, usage_site_span), false)\n         }\n         ty::ty_trait(box ty::TyTrait {\n                 def_id,\n                 ref substs,\n                 store,\n                 ref bounds\n             }) => {\n-            trait_metadata(cx, def_id, t, substs, store, bounds)\n+            (trait_metadata(cx, def_id, t, substs, store, bounds, unique_type_id), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n-            prepare_struct_metadata(cx, t, def_id, substs, usage_site_span).finalize(cx)\n+            let struct_metadata = prepare_struct_metadata(cx,\n+                                                          t,\n+                                                          def_id,\n+                                                          substs,\n+                                                          unique_type_id,\n+                                                          usage_site_span).finalize(cx);\n+            (struct_metadata, true)\n         }\n         ty::ty_tup(ref elements) => {\n-            prepare_tuple_metadata(cx,\n-                                   t,\n-                                   elements.as_slice(),\n-                                   usage_site_span).finalize(cx)\n+            let tuple_metadata = prepare_tuple_metadata(cx,\n+                                                        t,\n+                                                        elements.as_slice(),\n+                                                        unique_type_id,\n+                                                        usage_site_span).finalize(cx);\n+            (tuple_metadata, true)\n         }\n         _ => {\n-            cx.sess().bug(format!(\"debuginfo: unexpected type in \\\n-                                   type_metadata: {:?}\",\n+            cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n                                   sty).as_slice())\n         }\n     };\n \n-    debug_context(cx).created_types.borrow_mut().insert(cache_id, type_metadata);\n+    {\n+        let mut type_map = debug_context(cx).type_map.borrow_mut();\n+\n+        if should_already_be_stored_in_typemap {\n+            // Make sure that we already have a TypeMap entry entry for the ty::t.\n+            if type_map.find_metadata_for_type(t).is_none() {\n+                let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n+                let error_message = format!(\"Expected type metadata for ty::t '{}' to already be in\n+                                            the TypeMap but it was not (unique type id = {})\",\n+                                            ppaux::ty_to_str(cx.tcx(), t),\n+                                            unique_type_id_str.as_slice());\n+                cx.sess().span_bug(usage_site_span, error_message.as_slice());\n+            }\n+\n+            // Also make sure that we already have a TypeMap entry entry for the unique type id.\n+            if type_map.find_metadata_for_unique_id(unique_type_id).is_none() {\n+                let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n+                let error_message = format!(\"Expected type metadata for unique type id '{}' to\n+                                            already be in the TypeMap but it was not. (ty::t = {})\",\n+                                            unique_type_id_str.as_slice(),\n+                                            ppaux::ty_to_str(cx.tcx(), t));\n+                cx.sess().span_bug(usage_site_span, error_message.as_slice());\n+            }\n+        } else {\n+            type_map.register_type_with_metadata(cx, t, type_metadata);\n+            type_map.register_unique_id_with_metadata(cx, unique_type_id, type_metadata);\n+        }\n+    }\n+\n     type_metadata\n }\n \n@@ -2446,20 +2989,6 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n //  Utility Functions\n //=-------------------------------------------------------------------------------------------------\n \n-fn cache_id_for_type(t: ty::t) -> uint {\n-    ty::type_id(t)\n-}\n-\n-// Used to avoid LLVM metadata uniquing problems. See `create_struct_stub()` and\n-// `prepare_enum_metadata()`.\n-fn generate_unique_type_id(prefix: &'static str) -> String {\n-    unsafe {\n-        static mut unique_id_counter: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n-        format!(\"{}{}\", prefix,\n-                unique_id_counter.fetch_add(1, atomics::SeqCst))\n-    }\n-}\n-\n /// Return codemap::Loc corresponding to the beginning of the span\n fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n     cx.sess().codemap().lookup_char_pos(span.lo)"}, {"sha": "f42844b9f19d2612e3b7873ab5a344b62556e6c4", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c20aed09307d1b486c22e9b62156b02500ae1e6e/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c20aed09307d1b486c22e9b62156b02500ae1e6e/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=c20aed09307d1b486c22e9b62156b02500ae1e6e", "patch": "@@ -318,7 +318,7 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateStructType(\n         unwrapDI<DIArray>(Elements),\n         RunTimeLang,\n         unwrapDI<DIType>(VTableHolder)\n-#if LLVM_VERSION_MINOR >= 5\n+#if LLVM_VERSION_MINOR >= 4\n         ,UniqueId\n #endif\n         ));\n@@ -510,7 +510,7 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateUnionType(\n         Flags,\n         unwrapDI<DIArray>(Elements),\n         RunTimeLang\n-#if LLVM_VERSION_MINOR >= 5\n+#if LLVM_VERSION_MINOR >= 4\n         ,UniqueId\n #endif\n         ));\n@@ -734,6 +734,11 @@ LLVMVersionMinor() {\n     return LLVM_VERSION_MINOR;\n }\n \n+extern \"C\" int\n+LLVMVersionMajor() {\n+    return LLVM_VERSION_MAJOR;\n+}\n+\n // Note that the two following functions look quite similar to the\n // LLVMGetSectionName function. Sadly, it appears that this function only\n // returns a char* pointer, which isn't guaranteed to be null-terminated. The"}, {"sha": "f4bc72305a026feabbef14c3cd464cc9e45f57ea", "filename": "src/test/auxiliary/cross_crate_debuginfo_type_uniquing.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c20aed09307d1b486c22e9b62156b02500ae1e6e/src%2Ftest%2Fauxiliary%2Fcross_crate_debuginfo_type_uniquing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20aed09307d1b486c22e9b62156b02500ae1e6e/src%2Ftest%2Fauxiliary%2Fcross_crate_debuginfo_type_uniquing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcross_crate_debuginfo_type_uniquing.rs?ref=c20aed09307d1b486c22e9b62156b02500ae1e6e", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+#![crate_type = \"rlib\"]\n+// compile-flags:-g\n+\n+struct S1;\n+\n+impl S1 {\n+    fn f(&mut self) { }\n+}\n+\n+\n+struct S2;\n+\n+impl S2 {\n+    fn f(&mut self) { }\n+}"}, {"sha": "47de06c48569643acd172b9eeb9b000d4b558685", "filename": "src/test/debuginfo/cross-crate-type-uniquing.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c20aed09307d1b486c22e9b62156b02500ae1e6e/src%2Ftest%2Fdebuginfo%2Fcross-crate-type-uniquing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c20aed09307d1b486c22e9b62156b02500ae1e6e/src%2Ftest%2Fdebuginfo%2Fcross-crate-type-uniquing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fcross-crate-type-uniquing.rs?ref=c20aed09307d1b486c22e9b62156b02500ae1e6e", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-android: FIXME(#10381)\n+\n+// aux-build:cross_crate_debuginfo_type_uniquing.rs\n+extern crate cross_crate_debuginfo_type_uniquing;\n+\n+// no-prefer-dynamic\n+// compile-flags:-g -Zlto\n+\n+pub struct C;\n+pub fn p() -> C {\n+    C\n+}\n+\n+fn main() { }\n\\ No newline at end of file"}]}