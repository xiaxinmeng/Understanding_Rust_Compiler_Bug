{"sha": "8ef8d5702909828df1a1d93b6c437a98a240a01e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZjhkNTcwMjkwOTgyOGRmMWExZDkzYjZjNDM3YTk4YTI0MGEwMWU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-01-23T23:19:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-23T23:19:54Z"}, "message": "Rollup merge of #57793 - estebank:impl-trait-resolve, r=oli-obk\n\nExplain type mismatch cause pointing to return type when it is `impl Trait`\n\nFix #57743.", "tree": {"sha": "9434ed9c4df382ea5929532de0a5fb116b3bacc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9434ed9c4df382ea5929532de0a5fb116b3bacc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ef8d5702909828df1a1d93b6c437a98a240a01e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcSPaaCRBK7hj4Ov3rIwAAdHIIABZXV+DnD/i/q7V4HsJsSf4d\n0clW69/ljP0B8GiAcMMaDqauC7brgKkg+/DEesm4WMZdA313gJmei1aEBnyajRA9\nw+x0VBNAkdyzqdkDdrwK3BIsyvxehvWJA83hMZBN01FU/DHK2xodpCz39AH+piPO\nasiVykSluZErjhhyJTrz4bjsOGEhh8ML/hJRF44iYVdX/MJeDDdub6XOYmF+Om5k\n0LF5B/lrGq4/kYIs/21kzTjD1OCeiI77vA8jKBk+TG58zBc6BofIjhKyJ0KMMBP7\n0wBHRb+CbBA5RYca72XGQsQJUmjmxpfQTLqHGj63mXiJErc65zArNHZJsf5INRg=\n=i5Om\n-----END PGP SIGNATURE-----\n", "payload": "tree 9434ed9c4df382ea5929532de0a5fb116b3bacc3\nparent 2dd63a2e10aa130f6d7b10ddaad8f8120d1b8c58\nparent ab2479b00db475b7b8fe3b9e93d2e92dbe72bff4\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1548285594 +0100\ncommitter GitHub <noreply@github.com> 1548285594 +0100\n\nRollup merge of #57793 - estebank:impl-trait-resolve, r=oli-obk\n\nExplain type mismatch cause pointing to return type when it is `impl Trait`\n\nFix #57743.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ef8d5702909828df1a1d93b6c437a98a240a01e", "html_url": "https://github.com/rust-lang/rust/commit/8ef8d5702909828df1a1d93b6c437a98a240a01e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ef8d5702909828df1a1d93b6c437a98a240a01e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dd63a2e10aa130f6d7b10ddaad8f8120d1b8c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dd63a2e10aa130f6d7b10ddaad8f8120d1b8c58", "html_url": "https://github.com/rust-lang/rust/commit/2dd63a2e10aa130f6d7b10ddaad8f8120d1b8c58"}, {"sha": "ab2479b00db475b7b8fe3b9e93d2e92dbe72bff4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab2479b00db475b7b8fe3b9e93d2e92dbe72bff4", "html_url": "https://github.com/rust-lang/rust/commit/ab2479b00db475b7b8fe3b9e93d2e92dbe72bff4"}], "stats": {"total": 136, "additions": 78, "deletions": 58}, "files": [{"sha": "d1dfe9469fb774753afedee85e4c200ec058c8f5", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 63, "deletions": 54, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8d5702909828df1a1d93b6c437a98a240a01e/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8d5702909828df1a1d93b6c437a98a240a01e/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=8ef8d5702909828df1a1d93b6c437a98a240a01e", "patch": "@@ -1199,7 +1199,6 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                     (self.final_ty.unwrap_or(self.expected_ty), expression_ty)\n                 };\n \n-                let reason_label = \"expected because of this statement\";\n                 let mut db;\n                 match cause.code {\n                     ObligationCauseCode::ReturnNoExpression => {\n@@ -1209,63 +1208,20 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         db.span_label(cause.span, \"return type is not `()`\");\n                     }\n                     ObligationCauseCode::BlockTailExpression(blk_id) => {\n-                        db = fcx.report_mismatched_types(cause, expected, found, err);\n-\n-                        let expr = expression.unwrap_or_else(|| {\n-                            span_bug!(cause.span,\n-                                      \"supposed to be part of a block tail expression, but the \\\n-                                       expression is empty\");\n-                        });\n-                        let pointing_at_return_type = fcx.suggest_mismatched_types_on_tail(\n-                            &mut db,\n-                            expr,\n+                        let parent_id = fcx.tcx.hir().get_parent_node(blk_id);\n+                        db = self.report_return_mismatched_types(\n+                            cause,\n                             expected,\n                             found,\n-                            cause.span,\n-                            blk_id,\n+                            err,\n+                            fcx,\n+                            parent_id,\n+                            expression.map(|expr| (expr, blk_id)),\n                         );\n-                        // FIXME: replace with navigating up the chain until hitting an fn or\n-                        // bailing if no \"pass-through\" Node is found, in order to provide a\n-                        // suggestion when encountering something like:\n-                        // ```\n-                        // fn foo(a: bool) -> impl Debug {\n-                        //     if a {\n-                        //         bar()?;\n-                        //     }\n-                        //     {\n-                        //         let x = unsafe { bar() };\n-                        //         x\n-                        //     }\n-                        // }\n-                        // ```\n-                        //\n-                        // Verify that this is a tail expression of a function, otherwise the\n-                        // label pointing out the cause for the type coercion will be wrong\n-                        // as prior return coercions would not be relevant (#57664).\n-                        let parent_id = fcx.tcx.hir().get_parent_node(blk_id);\n-                        let parent = fcx.tcx.hir().get(fcx.tcx.hir().get_parent_node(parent_id));\n-                        if fcx.get_node_fn_decl(parent).is_some() && !pointing_at_return_type {\n-                            if let Some(sp) = fcx.ret_coercion_span.borrow().as_ref() {\n-                                db.span_label(*sp, reason_label);\n-                            }\n-                        }\n                     }\n-                    ObligationCauseCode::ReturnType(_id) => {\n-                        db = fcx.report_mismatched_types(cause, expected, found, err);\n-                        let _id = fcx.tcx.hir().get_parent_node(_id);\n-                        let mut pointing_at_return_type = false;\n-                        if let Some((fn_decl, can_suggest)) = fcx.get_fn_decl(_id) {\n-                            pointing_at_return_type = fcx.suggest_missing_return_type(\n-                                &mut db, &fn_decl, expected, found, can_suggest);\n-                        }\n-                        if let (Some(sp), false) = (\n-                            fcx.ret_coercion_span.borrow().as_ref(),\n-                            pointing_at_return_type,\n-                        ) {\n-                            if !sp.overlaps(cause.span) {\n-                                db.span_label(*sp, reason_label);\n-                            }\n-                        }\n+                    ObligationCauseCode::ReturnType(id) => {\n+                        db = self.report_return_mismatched_types(\n+                            cause, expected, found, err, fcx, id, None);\n                     }\n                     _ => {\n                         db = fcx.report_mismatched_types(cause, expected, found, err);\n@@ -1283,6 +1239,59 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         }\n     }\n \n+    fn report_return_mismatched_types<'a>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+        err: TypeError<'tcx>,\n+        fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n+        id: syntax::ast::NodeId,\n+        expression: Option<(&'gcx hir::Expr, syntax::ast::NodeId)>,\n+    ) -> DiagnosticBuilder<'a> {\n+        let mut db = fcx.report_mismatched_types(cause, expected, found, err);\n+\n+        let mut pointing_at_return_type = false;\n+        let mut return_sp = None;\n+\n+        // Verify that this is a tail expression of a function, otherwise the\n+        // label pointing out the cause for the type coercion will be wrong\n+        // as prior return coercions would not be relevant (#57664).\n+        let parent_id = fcx.tcx.hir().get_parent_node(id);\n+        let fn_decl = if let Some((expr, blk_id)) = expression {\n+            pointing_at_return_type = fcx.suggest_mismatched_types_on_tail(\n+                &mut db,\n+                expr,\n+                expected,\n+                found,\n+                cause.span,\n+                blk_id,\n+            );\n+            let parent = fcx.tcx.hir().get(parent_id);\n+            fcx.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n+        } else {\n+            fcx.get_fn_decl(parent_id)\n+        };\n+\n+        if let (Some((fn_decl, can_suggest)), _) = (fn_decl, pointing_at_return_type) {\n+            if expression.is_none() {\n+                pointing_at_return_type |= fcx.suggest_missing_return_type(\n+                    &mut db, &fn_decl, expected, found, can_suggest);\n+            }\n+            if !pointing_at_return_type {\n+                return_sp = Some(fn_decl.output.span()); // `impl Trait` return type\n+            }\n+        }\n+        if let (Some(sp), Some(return_sp)) = (fcx.ret_coercion_span.borrow().as_ref(), return_sp) {\n+            db.span_label(return_sp, \"expected because this return type...\");\n+            db.span_label( *sp, format!(\n+                \"...is found to be `{}` here\",\n+                fcx.resolve_type_vars_with_obligations(expected),\n+            ));\n+        }\n+        db\n+    }\n+\n     pub fn complete<'a>(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         if let Some(final_ty) = self.final_ty {\n             final_ty"}, {"sha": "6cd9d07748c27043ddd019388e3b08cd98373007", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8d5702909828df1a1d93b6c437a98a240a01e/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8d5702909828df1a1d93b6c437a98a240a01e/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=8ef8d5702909828df1a1d93b6c437a98a240a01e", "patch": "@@ -1,8 +1,11 @@\n error[E0308]: mismatched types\n   --> $DIR/equality.rs:15:5\n    |\n+LL | fn two(x: bool) -> impl Foo {\n+   |                    -------- expected because this return type...\n+LL |     if x {\n LL |         return 1_i32;\n-   |                ----- expected because of this statement\n+   |                ----- ...is found to be `i32` here\n LL |     }\n LL |     0_u32\n    |     ^^^^^ expected i32, found u32"}, {"sha": "5ebe00e624fc1ddfa2fc564d217078ef3f26257a", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ef8d5702909828df1a1d93b6c437a98a240a01e/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ef8d5702909828df1a1d93b6c437a98a240a01e/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=8ef8d5702909828df1a1d93b6c437a98a240a01e", "patch": "@@ -1,8 +1,11 @@\n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:5:5\n    |\n+LL | fn foo() -> impl std::fmt::Display {\n+   |             ---------------------- expected because this return type...\n+LL |     if false {\n LL |         return 0i32;\n-   |                ---- expected because of this statement\n+   |                ---- ...is found to be `i32` here\n LL |     }\n LL |     1u32\n    |     ^^^^ expected i32, found u32\n@@ -13,8 +16,11 @@ LL |     1u32\n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:13:16\n    |\n+LL | fn bar() -> impl std::fmt::Display {\n+   |             ---------------------- expected because this return type...\n+LL |     if false {\n LL |         return 0i32;\n-   |                ---- expected because of this statement\n+   |                ---- ...is found to be `i32` here\n LL |     } else {\n LL |         return 1u32;\n    |                ^^^^ expected i32, found u32\n@@ -25,10 +31,12 @@ LL |         return 1u32;\n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:19:5\n    |\n+LL |   fn baz() -> impl std::fmt::Display {\n+   |               ---------------------- expected because this return type...\n LL | /     if false {\n LL | |     //~^ ERROR mismatched types\n LL | |         return 0i32;\n-   | |                ---- expected because of this statement\n+   | |                ---- ...is found to be `i32` here\n LL | |     } else {\n LL | |         1u32\n LL | |     }"}]}