{"sha": "c3bf7d07e98109a1143567a3c658cadf387febeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYmY3ZDA3ZTk4MTA5YTExNDM1NjdhM2M2NThjYWRmMzg3ZmViZWI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-14T01:52:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-14T01:57:25Z"}, "message": "rustc: Implement simple interior vector append translation", "tree": {"sha": "f0cd6a5bf497f4119f383c03e1f17ce58bea875f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0cd6a5bf497f4119f383c03e1f17ce58bea875f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3bf7d07e98109a1143567a3c658cadf387febeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3bf7d07e98109a1143567a3c658cadf387febeb", "html_url": "https://github.com/rust-lang/rust/commit/c3bf7d07e98109a1143567a3c658cadf387febeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3bf7d07e98109a1143567a3c658cadf387febeb/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1bb4a4ded1128094066fb1b61f894d2a8dbc124", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1bb4a4ded1128094066fb1b61f894d2a8dbc124", "html_url": "https://github.com/rust-lang/rust/commit/a1bb4a4ded1128094066fb1b61f894d2a8dbc124"}], "stats": {"total": 340, "additions": 305, "deletions": 35}, "files": [{"sha": "272c4d71d3f9994a6b70d580d175f7adae042154", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c3bf7d07e98109a1143567a3c658cadf387febeb/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bf7d07e98109a1143567a3c658cadf387febeb/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=c3bf7d07e98109a1143567a3c658cadf387febeb", "patch": "@@ -10,6 +10,7 @@ import trans::T_i32;\n import trans::T_int;\n import trans::T_nil;\n import trans::T_opaque_chan_ptr;\n+import trans::T_opaque_ivec;\n import trans::T_opaque_port_ptr;\n import trans::T_opaque_vec_ptr;\n import trans::T_ptr;\n@@ -56,7 +57,9 @@ type upcalls = rec(\n     ValueRef new_task,\n     ValueRef start_task,\n     ValueRef new_thread,\n-    ValueRef start_thread\n+    ValueRef start_thread,\n+    ValueRef ivec_resize,\n+    ValueRef ivec_spill\n );\n \n fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n@@ -119,7 +122,11 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n         new_thread=d(\"new_thread\", [T_ptr(T_i8())], T_taskptr(tn)),\n         start_thread=d(\"start_thread\", [T_taskptr(tn), T_int(), T_int(),\n                                            T_int(), T_size_t()],\n-                       T_taskptr(tn))\n+                       T_taskptr(tn)),\n+        ivec_resize=d(\"ivec_resize\", [T_ptr(T_opaque_ivec()), T_int()],\n+                      T_void()),\n+        ivec_spill=d(\"ivec_spill\", [T_ptr(T_opaque_ivec()), T_int()],\n+                     T_void())\n     );\n }\n "}, {"sha": "c1ec7fa338a1a1226c737cc3950d1852d48ea081", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 238, "deletions": 33, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/c3bf7d07e98109a1143567a3c658cadf387febeb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bf7d07e98109a1143567a3c658cadf387febeb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c3bf7d07e98109a1143567a3c658cadf387febeb", "patch": "@@ -584,20 +584,29 @@ fn T_opaque_ivec() -> TypeRef {\n                   T_array(T_i8(), abi::ivec_default_size)]); // Body elements\n }\n \n-// Interior vector on the heap. Cast to this when the allocated length (second\n-// element of T_ivec above) is zero.\n+fn T_ivec_heap_part(TypeRef t) -> TypeRef {\n+    ret T_struct([T_int(),              // Real length\n+                  T_array(t, 0u)]);     // Body elements\n+}\n+\n+// Interior vector on the heap, also known as the \"stub\". Cast to this when\n+// the allocated length (second element of T_ivec above) is zero.\n fn T_ivec_heap(TypeRef t) -> TypeRef {\n-    ret T_struct([T_int(),          // Length (zero)\n-                  T_int(),          // Alloc\n-                  T_ptr(T_struct([T_int(),              // Real length\n-                                  T_array(t, 0u)]))]);  // Body elements\n+    ret T_struct([T_int(),                          // Length (zero)\n+                  T_int(),                          // Alloc\n+                  T_ptr(T_ivec_heap_part(t))]);     // Pointer\n+}\n+\n+fn T_opaque_ivec_heap_part() -> TypeRef {\n+    ret T_struct([T_int(),                  // Real length\n+                  T_array(T_i8(), 0u)]);    // Body elements\n+\n }\n \n fn T_opaque_ivec_heap() -> TypeRef {\n-    ret T_struct([T_int(),          // Length (zero)\n-                  T_int(),          // Alloc\n-                  T_ptr(T_struct([T_int(),                  // Real length\n-                                  T_array(T_i8(), 0u)]))]); // Body elements\n+    ret T_struct([T_int(),                              // Length (zero)\n+                  T_int(),                              // Alloc\n+                  T_ptr(T_opaque_ivec_heap_part())]);   // Pointer\n }\n \n fn T_str() -> TypeRef {\n@@ -2670,9 +2679,8 @@ fn get_ivec_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n \n     auto stack_len = bcx.build.Load(bcx.build.InBoundsGEP(v,\n         [C_int(0), C_uint(abi::ivec_elt_len)]));\n-    auto stack_elem = bcx.build.InBoundsGEP(v, [C_int(0),\n-                                        C_uint(abi::ivec_elt_elems),\n-                                        C_int(0)]);\n+    auto stack_elem = bcx.build.InBoundsGEP(v,\n+        [C_int(0), C_uint(abi::ivec_elt_elems), C_int(0)]);\n \n     auto on_heap = bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n \n@@ -3680,6 +3688,201 @@ fn trans_vec_append(&@block_ctxt cx, &ty::t t,\n                                         dst, src, skip_null]));\n }\n \n+// Returns a tuple consisting of a pointer to the length (to be updated), a\n+// pointer to the newly-reserved space, and a block context.\n+fn reserve_ivec_space(&@block_ctxt cx, TypeRef llunitty, ValueRef v,\n+        ValueRef len_needed) -> tup(ValueRef, ValueRef, @block_ctxt) {\n+    auto stack_len_ptr = cx.build.InBoundsGEP(v, [C_int(0),\n+                                                  C_uint(abi::ivec_elt_len)]);\n+    auto stack_len = cx.build.Load(stack_len_ptr);\n+    auto alen = cx.build.Load(cx.build.InBoundsGEP(v,\n+        [C_int(0), C_uint(abi::ivec_elt_alen)]));\n+\n+    // There are four cases we have to consider:\n+    // (1) On heap, no resize necessary.\n+    // (2) On heap, need to resize.\n+    // (3) On stack, no resize necessary.\n+    // (4) On stack, need to spill to heap.\n+\n+    auto maybe_on_heap = cx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len,\n+                                       C_int(0));\n+    auto maybe_on_heap_cx = new_sub_block_ctxt(cx, \"maybe_on_heap\");\n+    auto on_stack_cx = new_sub_block_ctxt(cx, \"on_stack\");\n+    cx.build.CondBr(maybe_on_heap, maybe_on_heap_cx.llbb, on_stack_cx.llbb);\n+\n+    auto next_cx = new_sub_block_ctxt(cx, \"next\");\n+\n+    // We're possibly on the heap, unless the vector is zero-length.\n+    auto stub_ptr = maybe_on_heap_cx.build.PointerCast(v,\n+        T_ptr(T_ivec_heap(llunitty)));\n+    auto heap_ptr = maybe_on_heap_cx.build.Load(\n+        maybe_on_heap_cx.build.InBoundsGEP(stub_ptr,\n+            [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n+    auto on_heap = maybe_on_heap_cx.build.ICmp(lib::llvm::LLVMIntNE, heap_ptr,\n+        C_null(val_ty(heap_ptr)));\n+    auto on_heap_cx = new_sub_block_ctxt(cx, \"on_heap\");\n+    maybe_on_heap_cx.build.CondBr(on_heap, on_heap_cx.llbb, on_stack_cx.llbb);\n+\n+    // We're definitely on the heap. Check whether we need to resize.\n+    auto heap_len_ptr = on_heap_cx.build.InBoundsGEP(heap_ptr, [C_int(0),\n+                                                                C_int(0)]);\n+    auto heap_len = on_heap_cx.build.Load(heap_len_ptr);\n+    auto new_heap_len = on_heap_cx.build.Add(heap_len, len_needed);\n+    auto heap_no_resize_needed = on_heap_cx.build.ICmp(lib::llvm::LLVMIntULT,\n+                                                       new_heap_len, alen);\n+    auto heap_no_resize_cx = new_sub_block_ctxt(cx, \"heap_no_resize\");\n+    auto heap_resize_cx = new_sub_block_ctxt(cx, \"heap_resize\");\n+    on_heap_cx.build.CondBr(heap_no_resize_needed, heap_no_resize_cx.llbb,\n+                            heap_resize_cx.llbb);\n+\n+    // Case (1): We're on the heap and don't need to resize.\n+    auto heap_len_unscaled = heap_no_resize_cx.build.UDiv(heap_len,\n+        llsize_of(llunitty));\n+    auto heap_data_no_resize = heap_no_resize_cx.build.InBoundsGEP(heap_ptr,\n+        [C_int(0), C_uint(abi::ivec_heap_elt_elems), heap_len_unscaled]);\n+    heap_no_resize_cx.build.Br(next_cx.llbb);\n+\n+    // Case (2): We're on the heap and need to resize. This path is rare, so\n+    // we delegate to cold glue.\n+    heap_resize_cx.build.Call(\n+        cx.fcx.lcx.ccx.upcalls.ivec_resize, [\n+            cx.fcx.lltaskptr,\n+            heap_resize_cx.build.PointerCast(v, T_ptr(T_opaque_ivec())),\n+            new_heap_len\n+        ]);\n+    auto heap_ptr_resize = heap_resize_cx.build.Load(\n+        heap_resize_cx.build.InBoundsGEP(stub_ptr,\n+            [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n+    auto heap_data_resize = heap_resize_cx.build.InBoundsGEP(heap_ptr_resize,\n+        [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)]);\n+    heap_resize_cx.build.Br(next_cx.llbb);\n+\n+    // We're on the stack. Check whether we need to spill to the heap.\n+    auto new_stack_len = on_stack_cx.build.Add(stack_len, len_needed);\n+    auto stack_no_spill_needed = on_stack_cx.build.ICmp(lib::llvm::LLVMIntULT,\n+                                                        new_stack_len, alen);\n+    auto stack_no_spill_cx = new_sub_block_ctxt(cx, \"stack_no_spill\");\n+    auto stack_spill_cx = new_sub_block_ctxt(cx, \"stack_spill\");\n+    on_stack_cx.build.CondBr(stack_no_spill_needed, stack_no_spill_cx.llbb,\n+                             stack_spill_cx.llbb);\n+\n+    // Case (3): We're on the stack and don't need to spill.\n+    auto stack_len_unscaled = stack_no_spill_cx.build.UDiv(stack_len,\n+        llsize_of(llunitty));\n+    auto stack_data_no_spill = stack_no_spill_cx.build.InBoundsGEP(v,\n+        [C_int(0), C_uint(abi::ivec_elt_elems), stack_len_unscaled]);\n+    stack_no_spill_cx.build.Br(next_cx.llbb);\n+\n+    // Case (4): We're on the stack and need to spill. Like case (2), this\n+    // path is rare, so we delegate to cold glue.\n+    stack_spill_cx.build.Call(\n+        cx.fcx.lcx.ccx.upcalls.ivec_spill, [\n+            cx.fcx.lltaskptr,\n+            stack_spill_cx.build.PointerCast(v, T_ptr(T_opaque_ivec())),\n+            new_stack_len\n+        ]);\n+    auto spill_stub = stack_spill_cx.build.PointerCast(v,\n+        T_ptr(T_ivec_heap(llunitty)));\n+    auto heap_ptr_spill = stack_spill_cx.build.Load(\n+        stack_spill_cx.build.InBoundsGEP(spill_stub,\n+            [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n+    auto heap_len_ptr_spill = stack_spill_cx.build.InBoundsGEP(heap_ptr_spill,\n+        [C_int(0), C_uint(abi::ivec_heap_elt_len)]);\n+    auto heap_data_spill = stack_spill_cx.build.InBoundsGEP(heap_ptr_spill,\n+        [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)]);\n+\n+    stack_spill_cx.build.Br(next_cx.llbb);\n+\n+    // Phi together the different data pointers to get the result.\n+    auto len_ptr = next_cx.build.Phi(T_ptr(T_int()),\n+        [heap_len_ptr, heap_len_ptr, stack_len_ptr, heap_len_ptr_spill],\n+        [heap_no_resize_cx.llbb, heap_resize_cx.llbb, stack_no_spill_cx.llbb,\n+         stack_spill_cx.llbb]);\n+    auto data_ptr = next_cx.build.Phi(T_ptr(llunitty),\n+        [heap_data_no_resize, heap_data_resize, stack_data_no_spill,\n+         heap_data_spill],\n+        [heap_no_resize_cx.llbb, heap_resize_cx.llbb, stack_no_spill_cx.llbb,\n+         stack_spill_cx.llbb]);\n+    ret tup(len_ptr, data_ptr, next_cx);\n+}\n+\n+fn trans_ivec_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs)\n+        -> result {\n+    auto unit_ty = ty::sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n+    auto llunitty = type_of_or_i8(cx, unit_ty);\n+\n+    auto skip_null;\n+    alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n+        case (ty::ty_istr) { skip_null = true; }\n+        case (ty::ty_ivec(_)) { skip_null = false; }\n+        case (_) {\n+            cx.fcx.lcx.ccx.tcx.sess.bug(\"non-istr/ivec in trans_ivec_append\");\n+        }\n+    }\n+\n+    // Gather the various type descriptors we'll need.\n+    auto rslt = get_tydesc(cx, t, false, none);\n+    auto vec_tydesc = rslt.val;\n+    auto bcx = rslt.bcx;\n+\n+    rslt = get_tydesc(bcx, unit_ty, false, none);\n+    auto unit_tydesc = rslt.val;\n+    bcx = rslt.bcx;\n+    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, none);\n+    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, none);\n+    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, none);\n+\n+    auto rhs_len_and_data = get_ivec_len_and_data(bcx, rhs, unit_ty);\n+    auto rhs_len = rhs_len_and_data._0;\n+    auto rhs_data = rhs_len_and_data._1;\n+    bcx = rhs_len_and_data._2;\n+\n+    auto lhs_len_ptr_and_data =\n+        reserve_ivec_space(bcx, llunitty, lhs, rhs_len);\n+    auto lhs_len_ptr = lhs_len_ptr_and_data._0;\n+    auto lhs_data = lhs_len_ptr_and_data._1;\n+    bcx = lhs_len_ptr_and_data._2;\n+\n+    // Work out the end pointer.\n+    auto lhs_unscaled_idx = bcx.build.UDiv(rhs_len, llsize_of(llunitty));\n+    auto lhs_end = bcx.build.InBoundsGEP(lhs_data, [lhs_unscaled_idx]);\n+\n+    // Now emit the copy loop.\n+    auto dest_ptr = alloca(bcx, T_ptr(llunitty));\n+    bcx.build.Store(lhs_data, dest_ptr);\n+    auto src_ptr = alloca(bcx, T_ptr(llunitty));\n+    bcx.build.Store(rhs_data, src_ptr);\n+\n+    auto copy_loop_header_cx = new_sub_block_ctxt(bcx, \"copy_loop_header\");\n+    bcx.build.Br(copy_loop_header_cx.llbb);\n+\n+    auto copy_dest_ptr = copy_loop_header_cx.build.Load(dest_ptr);\n+    auto not_yet_at_end = copy_loop_header_cx.build.ICmp(lib::llvm::LLVMIntNE,\n+        copy_dest_ptr, lhs_end);\n+    auto copy_loop_body_cx = new_sub_block_ctxt(bcx, \"copy_loop_body\");\n+    auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n+    copy_loop_header_cx.build.CondBr(not_yet_at_end, copy_loop_body_cx.llbb,\n+                                     next_cx.llbb);\n+\n+    auto copy_src_ptr = copy_loop_body_cx.build.Load(src_ptr);\n+    rslt = copy_val(copy_loop_body_cx, INIT, copy_dest_ptr, copy_src_ptr, t);\n+    auto post_copy_cx = rslt.bcx;\n+\n+    // Increment both pointers.\n+    post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(copy_dest_ptr,\n+        [C_int(1)]), dest_ptr);\n+    post_copy_cx.build.Store(post_copy_cx.build.InBoundsGEP(copy_src_ptr,\n+        [C_int(1)]), src_ptr);\n+    post_copy_cx.build.Br(copy_loop_header_cx.llbb);\n+\n+    // Write in the new length.\n+    auto new_len = next_cx.build.Add(next_cx.build.Load(lhs_len_ptr),\n+                                     rhs_len);\n+    next_cx.build.Store(new_len, lhs_len_ptr);\n+\n+    ret res(next_cx, C_nil());\n+}\n+\n fn trans_vec_add(&@block_ctxt cx, &ty::t t,\n                  ValueRef lhs, ValueRef rhs) -> result {\n     auto r = alloc_ty(cx, t);\n@@ -4741,14 +4944,8 @@ fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base,\n     auto base_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, base);\n     auto base_ty_no_boxes = ty::strip_boxes(cx.fcx.lcx.ccx.tcx, base_ty);\n \n-    auto is_interior;\n-    alt (ty::struct(cx.fcx.lcx.ccx.tcx, base_ty_no_boxes)) {\n-        // TODO: Or-patterns\n-        case (ty::ty_vec(_))    { is_interior = false; }\n-        case (ty::ty_str)       { is_interior = false; }\n-        case (ty::ty_ivec(_))   { is_interior = true; }\n-        case (ty::ty_istr)      { is_interior = true; }\n-    };\n+    auto is_interior = ty::sequence_is_interior(cx.fcx.lcx.ccx.tcx,\n+        base_ty_no_boxes);\n \n     auto lv = trans_expr(cx, base);\n     lv = autoderef(lv.bcx, lv.val, base_ty);\n@@ -5655,40 +5852,43 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann)\n     auto llfirsteltptr;\n     if (vec::len(args) > 0u && vec::len(args) < abi::ivec_default_size) {\n         // Interior case.\n-        bcx.build.Store(lllen, bcx.build.GEP(llvecptr,\n+        bcx.build.Store(lllen, bcx.build.InBoundsGEP(llvecptr,\n             [C_int(0), C_uint(abi::ivec_elt_len)]));\n-        bcx.build.Store(C_uint(abi::ivec_elt_alen), bcx.build.GEP(llvecptr,\n-            [C_int(0), C_uint(abi::ivec_elt_alen)]));\n-        llfirsteltptr = bcx.build.GEP(llvecptr,\n+        bcx.build.Store(C_uint(abi::ivec_default_size),\n+            bcx.build.InBoundsGEP(llvecptr,\n+                [C_int(0), C_uint(abi::ivec_elt_alen)]));\n+        llfirsteltptr = bcx.build.InBoundsGEP(llvecptr,\n             [C_int(0), C_uint(abi::ivec_elt_elems), C_int(0)]);\n     } else {\n         // Heap case.\n         auto llstubty = T_ivec_heap(llunitty);\n         auto llstubptr = bcx.build.PointerCast(llvecptr, T_ptr(llstubty));\n \n-        bcx.build.Store(C_int(0), bcx.build.GEP(llstubptr,\n+        bcx.build.Store(C_int(0), bcx.build.InBoundsGEP(llstubptr,\n             [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)]));\n-        bcx.build.Store(C_uint(abi::ivec_elt_alen), bcx.build.GEP(llstubptr,\n-            [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)]));\n+        bcx.build.Store(lllen,\n+            bcx.build.InBoundsGEP(llstubptr,\n+                [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)]));\n \n         auto llheapty = struct_elt(llstubty, abi::ivec_heap_stub_elt_ptr);\n \n         if (vec::len(args) == 0u) {\n             // Null heap pointer indicates a zero-length vector.\n-            bcx.build.Store(C_null(T_ptr(llheapty)), bcx.build.GEP(llstubptr,\n-                [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n+            bcx.build.Store(C_null(T_ptr(llheapty)),\n+                bcx.build.InBoundsGEP(llstubptr,\n+                    [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n             llfirsteltptr = C_null(T_ptr(llunitty));\n         } else {\n             auto llheapsz = bcx.build.Add(llsize_of(llheapty), lllen);\n             rslt = trans_raw_malloc(bcx, llheapty, llheapsz);\n             bcx = rslt.bcx;\n             auto llheapptr = rslt.val;\n \n-            bcx.build.Store(llheapptr, bcx.build.GEP(llstubptr,\n+            bcx.build.Store(llheapptr, bcx.build.InBoundsGEP(llstubptr,\n                 [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n-            bcx.build.Store(lllen, bcx.build.GEP(llheapptr,\n+            bcx.build.Store(lllen, bcx.build.InBoundsGEP(llheapptr,\n                 [C_int(0), C_uint(abi::ivec_heap_elt_len)]));\n-            llfirsteltptr = bcx.build.GEP(llheapptr,\n+            llfirsteltptr = bcx.build.InBoundsGEP(llheapptr,\n                 [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)]);\n         }\n     }\n@@ -5864,6 +6064,11 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output)\n             if (ty::type_is_sequence(cx.fcx.lcx.ccx.tcx, t)) {\n                 alt (op) {\n                     case (ast::add) {\n+                        if (ty::sequence_is_interior(cx.fcx.lcx.ccx.tcx, t)) {\n+                            ret trans_ivec_append(rhs_res.bcx, t,\n+                                                  lhs_res.res.val,\n+                                                  rhs_res.val);\n+                        }\n                         ret trans_vec_append(rhs_res.bcx, t,\n                                              lhs_res.res.val,\n                                              rhs_res.val);"}, {"sha": "c72f58d1265e5410d39de18c276503ae43738c89", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c3bf7d07e98109a1143567a3c658cadf387febeb/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3bf7d07e98109a1143567a3c658cadf387febeb/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=c3bf7d07e98109a1143567a3c658cadf387febeb", "patch": "@@ -763,6 +763,19 @@ fn type_is_sequence(&ctxt cx, &t ty) -> bool {\n     }\n }\n \n+fn sequence_is_interior(&ctxt cx, &t ty) -> bool {\n+    alt (struct(cx, ty)) {\n+        // TODO: Or-patterns\n+        case (ty::ty_vec(_))    { ret false; }\n+        case (ty::ty_str)       { ret false; }\n+        case (ty::ty_ivec(_))   { ret true; }\n+        case (ty::ty_istr)      { ret true; }\n+        case (_) {\n+            cx.sess.bug(\"sequence_is_interior called on non-sequence type\");\n+        }\n+    }\n+}\n+\n fn sequence_element_type(&ctxt cx, &t ty) -> t {\n     alt (struct(cx, ty)) {\n         case (ty_str)       { ret mk_mach(cx, common::ty_u8); }"}, {"sha": "b39321c92854a2facfe502bdeb53ca4de6b2c8fb", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c3bf7d07e98109a1143567a3c658cadf387febeb/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c3bf7d07e98109a1143567a3c658cadf387febeb/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=c3bf7d07e98109a1143567a3c658cadf387febeb", "patch": "@@ -574,6 +574,25 @@ upcall_start_thread(rust_task *task,\n     return child_task_proxy;\n }\n \n+/**\n+ * Resizes an interior vector that has been spilled to the heap.\n+ */\n+extern \"C\" CDECL void\n+upcall_ivec_resize(rust_task *task,\n+                   rust_ivec *v,\n+                   size_t newsz) {\n+    // TODO\n+    task->fail(4);\n+}\n+\n+extern \"C\" CDECL void\n+upcall_ivec_spill(rust_task *task,\n+                  rust_ivec *v,\n+                  size_t newsz) {\n+    // TODO\n+    task->fail(4);\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "89ad57e33fe317766fe5c8876d0aaf132a87e2bf", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c3bf7d07e98109a1143567a3c658cadf387febeb/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/c3bf7d07e98109a1143567a3c658cadf387febeb/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=c3bf7d07e98109a1143567a3c658cadf387febeb", "patch": "@@ -185,6 +185,30 @@ rust_vec : public rc_base<rust_vec>\n // Rust types vec and str look identical from our perspective.\n typedef rust_vec rust_str;\n \n+// Interior vectors (rust-user-code level).\n+\n+struct\n+rust_ivec_heap\n+{\n+    size_t fill;\n+    uint8_t data[];\n+};\n+\n+union\n+rust_ivec_payload\n+{\n+    uint8_t data[];                 // if on stack\n+    struct rust_ivec_heap *ptr;     // if on heap\n+};\n+\n+struct\n+rust_ivec\n+{\n+    size_t fill;    // in bytes; if zero, heapified\n+    size_t alloc;   // in bytes\n+    rust_ivec_payload payload;\n+};\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "4bbacc53b50b1e8591cb772fcc82b50df8771ac4", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3bf7d07e98109a1143567a3c658cadf387febeb/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/c3bf7d07e98109a1143567a3c658cadf387febeb/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=c3bf7d07e98109a1143567a3c658cadf387febeb", "patch": "@@ -49,6 +49,8 @@ upcall_flush_chan\n upcall_free\n upcall_get_type_desc\n upcall_grow_task\n+upcall_ivec_resize\n+upcall_ivec_spill\n upcall_join\n upcall_kill\n upcall_log_double"}]}