{"sha": "2d3e909e4e68259e15ca2908ff9e854f0a68bbec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkM2U5MDllNGU2ODI1OWUxNWNhMjkwOGZmOWU4NTRmMGE2OGJiZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-22T20:35:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-22T20:35:30Z"}, "message": "Auto merge of #56887 - emilio:enum-field-reordering, r=eddyb\n\nDisable field reordering for repr(int).\n\nThis fixes the problem that the test in #56619 uncovers.\n\nCloses #56619.", "tree": {"sha": "1a4010cc023e81fbbc8dc2f8f9d67fc302d9bb15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a4010cc023e81fbbc8dc2f8f9d67fc302d9bb15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d3e909e4e68259e15ca2908ff9e854f0a68bbec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d3e909e4e68259e15ca2908ff9e854f0a68bbec", "html_url": "https://github.com/rust-lang/rust/commit/2d3e909e4e68259e15ca2908ff9e854f0a68bbec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d3e909e4e68259e15ca2908ff9e854f0a68bbec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9723a495d4aeda267b5657750bf0f7f4436af507", "url": "https://api.github.com/repos/rust-lang/rust/commits/9723a495d4aeda267b5657750bf0f7f4436af507", "html_url": "https://github.com/rust-lang/rust/commit/9723a495d4aeda267b5657750bf0f7f4436af507"}, {"sha": "d84bdba72888a42a67c1771b0a62f8517c8964cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d84bdba72888a42a67c1771b0a62f8517c8964cb", "html_url": "https://github.com/rust-lang/rust/commit/d84bdba72888a42a67c1771b0a62f8517c8964cb"}], "stats": {"total": 59, "additions": 33, "deletions": 26}, "files": [{"sha": "e1bf43c3782e86f0202fca7730feacc586687158", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d3e909e4e68259e15ca2908ff9e854f0a68bbec/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3e909e4e68259e15ca2908ff9e854f0a68bbec/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2d3e909e4e68259e15ca2908ff9e854f0a68bbec", "patch": "@@ -2061,9 +2061,10 @@ impl ReprOptions {\n     }\n \n     /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n-    /// optimizations, such as with repr(C) or repr(packed(1)).\n+    /// optimizations, such as with repr(C), repr(packed(1)), or repr(<int>).\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n-        !(self.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty() || (self.pack == 1)\n+        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.pack == 1 ||\n+            self.int.is_some()\n     }\n \n     /// Returns true if this `#[repr()]` should inhibit union abi optimisations"}, {"sha": "f59f100653fbb31bcc5eba9fe11bf13a8bb6f02a", "filename": "src/test/run-pass/structs-enums/enum-non-c-like-repr-c-and-int.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d3e909e4e68259e15ca2908ff9e854f0a68bbec/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-c-and-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3e909e4e68259e15ca2908ff9e854f0a68bbec/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-c-and-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-c-and-int.rs?ref=2d3e909e4e68259e15ca2908ff9e854f0a68bbec", "patch": "@@ -20,11 +20,12 @@ use std::mem;\n #[repr(C, u8)]\n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n enum MyEnum {\n-    A(u32),                 // Single primitive value\n-    B { x: u8, y: i16 },    // Composite, and the offset of `y` depends on tag being internal\n-    C,                      // Empty\n-    D(Option<u32>),         // Contains an enum\n-    E(Duration),            // Contains a struct\n+    A(u32),                     // Single primitive value\n+    B { x: u8, y: i16, z: u8 }, // Composite, and the offsets of `y` and `z`\n+                                // depend on tag being internal\n+    C,                          // Empty\n+    D(Option<u32>),             // Contains an enum\n+    E(Duration),                // Contains a struct\n }\n \n #[repr(C)]\n@@ -44,14 +45,14 @@ union MyEnumPayload {\n \n #[repr(u8)] #[derive(Copy, Clone)] enum MyEnumTag { A, B, C, D, E }\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantA(u32);\n-#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16 }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16, z: u8 }\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantD(Option<u32>);\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantE(Duration);\n \n fn main() {\n     let result: Vec<Result<MyEnum, ()>> = vec![\n         Ok(MyEnum::A(17)),\n-        Ok(MyEnum::B { x: 206, y: 1145 }),\n+        Ok(MyEnum::B { x: 206, y: 1145, z: 78 }),\n         Ok(MyEnum::C),\n         Err(()),\n         Ok(MyEnum::D(Some(407))),\n@@ -63,7 +64,7 @@ fn main() {\n     // Binary serialized version of the above (little-endian)\n     let input: Vec<u8> = vec![\n         0,  17, 0, 0, 0,\n-        1,  206,  121, 4,\n+        1,  206,  121, 4,  78,\n         2,\n         8,  /* invalid tag value */\n         3,  0,  151, 1, 0, 0,\n@@ -112,6 +113,7 @@ fn parse_my_enum<'a>(dest: &'a mut MyEnum, buf: &mut &[u8]) -> Result<(), ()> {\n             MyEnumTag::B => {\n                 dest.payload.B.x = read_u8(buf)?;\n                 dest.payload.B.y = read_u16_le(buf)? as i16;\n+                dest.payload.B.z = read_u8(buf)?;\n             }\n             MyEnumTag::C => {\n                 /* do nothing */"}, {"sha": "e88b91ab6c3f169837e8977567c951c37198797d", "filename": "src/test/run-pass/structs-enums/enum-non-c-like-repr-c.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d3e909e4e68259e15ca2908ff9e854f0a68bbec/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3e909e4e68259e15ca2908ff9e854f0a68bbec/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-c.rs?ref=2d3e909e4e68259e15ca2908ff9e854f0a68bbec", "patch": "@@ -20,11 +20,12 @@ use std::mem;\n #[repr(C)]\n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n enum MyEnum {\n-    A(u32),                 // Single primitive value\n-    B { x: u8, y: i16 },    // Composite, and the offset of `y` depends on tag being internal\n-    C,                      // Empty\n-    D(Option<u32>),         // Contains an enum\n-    E(Duration),            // Contains a struct\n+    A(u32),                     // Single primitive value\n+    B { x: u8, y: i16, z: u8 }, // Composite, and the offset of `y` and `z`\n+                                // depend on tag being internal\n+    C,                          // Empty\n+    D(Option<u32>),             // Contains an enum\n+    E(Duration),                // Contains a struct\n }\n \n #[repr(C)]\n@@ -44,14 +45,14 @@ union MyEnumPayload {\n \n #[repr(C)] #[derive(Copy, Clone)] enum MyEnumTag { A, B, C, D, E }\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantA(u32);\n-#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16 }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB {x: u8, y: i16, z: u8 }\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantD(Option<u32>);\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantE(Duration);\n \n fn main() {\n     let result: Vec<Result<MyEnum, ()>> = vec![\n         Ok(MyEnum::A(17)),\n-        Ok(MyEnum::B { x: 206, y: 1145 }),\n+        Ok(MyEnum::B { x: 206, y: 1145, z: 78 }),\n         Ok(MyEnum::C),\n         Err(()),\n         Ok(MyEnum::D(Some(407))),\n@@ -63,7 +64,7 @@ fn main() {\n     // Binary serialized version of the above (little-endian)\n     let input: Vec<u8> = vec![\n         0,  17, 0, 0, 0,\n-        1,  206,  121, 4,\n+        1,  206,  121, 4,  78,\n         2,\n         8,  /* invalid tag value */\n         3,  0,  151, 1, 0, 0,\n@@ -112,6 +113,7 @@ fn parse_my_enum<'a>(dest: &'a mut MyEnum, buf: &mut &[u8]) -> Result<(), ()> {\n             MyEnumTag::B => {\n                 dest.payload.B.x = read_u8(buf)?;\n                 dest.payload.B.y = read_u16_le(buf)? as i16;\n+                dest.payload.B.z = read_u8(buf)?;\n             }\n             MyEnumTag::C => {\n                 /* do nothing */"}, {"sha": "d862c0c72c2d8dc995bf824001993a43413b2660", "filename": "src/test/run-pass/structs-enums/enum-non-c-like-repr-int.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d3e909e4e68259e15ca2908ff9e854f0a68bbec/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3e909e4e68259e15ca2908ff9e854f0a68bbec/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-non-c-like-repr-int.rs?ref=2d3e909e4e68259e15ca2908ff9e854f0a68bbec", "patch": "@@ -20,11 +20,12 @@ use std::mem;\n #[repr(u8)]\n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n enum MyEnum {\n-    A(u32),                 // Single primitive value\n-    B { x: u8, y: i16 },    // Composite, and the offset of `y` depends on tag being internal\n-    C,                      // Empty\n-    D(Option<u32>),         // Contains an enum\n-    E(Duration),            // Contains a struct\n+    A(u32),                     // Single primitive value\n+    B { x: u8, y: i16, z: u8 }, // Composite, and the offset of `y` and `z`\n+                                // depend on tag being internal\n+    C,                          // Empty\n+    D(Option<u32>),             // Contains an enum\n+    E(Duration),                // Contains a struct\n }\n \n #[allow(non_snake_case)]\n@@ -39,15 +40,15 @@ union MyEnumRepr {\n \n #[repr(u8)] #[derive(Copy, Clone)] enum MyEnumTag { A, B, C, D, E }\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantA(MyEnumTag, u32);\n-#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB { tag: MyEnumTag, x: u8, y: i16 }\n+#[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantB { tag: MyEnumTag, x: u8, y: i16, z: u8 }\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantC(MyEnumTag);\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantD(MyEnumTag, Option<u32>);\n #[repr(C)] #[derive(Copy, Clone)] struct MyEnumVariantE(MyEnumTag, Duration);\n \n fn main() {\n     let result: Vec<Result<MyEnum, ()>> = vec![\n         Ok(MyEnum::A(17)),\n-        Ok(MyEnum::B { x: 206, y: 1145 }),\n+        Ok(MyEnum::B { x: 206, y: 1145, z: 78 }),\n         Ok(MyEnum::C),\n         Err(()),\n         Ok(MyEnum::D(Some(407))),\n@@ -59,7 +60,7 @@ fn main() {\n     // Binary serialized version of the above (little-endian)\n     let input: Vec<u8> = vec![\n         0,  17, 0, 0, 0,\n-        1,  206,  121, 4,\n+        1,  206,  121, 4,  78,\n         2,\n         8,  /* invalid tag value */\n         3,  0,  151, 1, 0, 0,\n@@ -108,6 +109,7 @@ fn parse_my_enum<'a>(dest: &'a mut MyEnum, buf: &mut &[u8]) -> Result<(), ()> {\n             MyEnumTag::B => {\n                 dest.B.x = read_u8(buf)?;\n                 dest.B.y = read_u16_le(buf)? as i16;\n+                dest.B.z = read_u8(buf)?;\n             }\n             MyEnumTag::C => {\n                 /* do nothing */"}]}