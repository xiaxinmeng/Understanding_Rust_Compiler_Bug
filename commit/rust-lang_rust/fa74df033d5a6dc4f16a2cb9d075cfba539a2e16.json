{"sha": "fa74df033d5a6dc4f16a2cb9d075cfba539a2e16", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNzRkZjAzM2Q1YTZkYzRmMTZhMmNiOWQwNzVjZmJhNTM5YTJlMTY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-09-16T20:04:14Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-09-16T20:07:08Z"}, "message": "Add a constraint on trans::type_of_fn_from_ty\n\nAnd change callers appropriately.", "tree": {"sha": "cd87e567a0c4ebb7258d40f019a2298b28fecb5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd87e567a0c4ebb7258d40f019a2298b28fecb5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa74df033d5a6dc4f16a2cb9d075cfba539a2e16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa74df033d5a6dc4f16a2cb9d075cfba539a2e16", "html_url": "https://github.com/rust-lang/rust/commit/fa74df033d5a6dc4f16a2cb9d075cfba539a2e16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa74df033d5a6dc4f16a2cb9d075cfba539a2e16/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d4b51d10d1f2e386ec4424a8319b8fabd96f97f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d4b51d10d1f2e386ec4424a8319b8fabd96f97f", "html_url": "https://github.com/rust-lang/rust/commit/0d4b51d10d1f2e386ec4424a8319b8fabd96f97f"}], "stats": {"total": 72, "additions": 49, "deletions": 23}, "files": [{"sha": "2a52a2ce9e70d61d5186e8ed81f0fdcab24bbbd4", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 49, "deletions": 23, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fa74df033d5a6dc4f16a2cb9d075cfba539a2e16/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa74df033d5a6dc4f16a2cb9d075cfba539a2e16/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fa74df033d5a6dc4f16a2cb9d075cfba539a2e16", "patch": "@@ -49,7 +49,7 @@ import tvec = trans_vec;\n fn type_of(cx: @crate_ctxt, sp: span, t: ty::t) : type_has_static_size(cx, t)\n    -> TypeRef {\n     // Should follow from type_has_static_size -- argh.\n-    // FIXME\n+    // FIXME (requires Issue #586)\n     check non_ty_var(cx, t);\n     type_of_inner(cx, sp, t)\n }\n@@ -59,6 +59,8 @@ fn type_of_explicit_args(cx: @crate_ctxt, sp: span, inputs: [ty::arg]) ->\n     let atys = [];\n     for arg in inputs {\n         let arg_ty = arg.ty;\n+        // FIXME: would be nice to have a constraint on arg\n+        // that would obviate the need for this check\n         check non_ty_var(cx, arg_ty);\n         atys += [T_ptr(type_of_inner(cx, sp, arg_ty))];\n     }\n@@ -114,9 +116,12 @@ fn type_of_fn(cx: @crate_ctxt, sp: span, proto: ast::proto,\n \n // Given a function type and a count of ty params, construct an llvm type\n fn type_of_fn_from_ty(cx: @crate_ctxt, sp: span, fty: ty::t,\n-                      ty_param_count: uint) -> TypeRef {\n+                      ty_param_count: uint)\n+    : returns_non_ty_var(cx, fty) -> TypeRef {\n     let by_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(cx.tcx, fty));\n-    // FIXME: constraint?\n+    // FIXME: Check should be unnecessary, b/c it's implied\n+    // by returns_non_ty_var(t). Make that a postcondition\n+    // (see Issue #586)\n     let ret_ty = ty::ty_fn_ret(cx.tcx, fty);\n     check non_ty_var(cx, ret_ty);\n     ret type_of_fn(cx, sp, ty::ty_fn_proto(cx.tcx, fty),\n@@ -197,6 +202,8 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         T_struct(tys)\n       }\n       ty::ty_fn(_, _, _, _, _) {\n+        // FIXME: could be a constraint on ty_fn\n+        check returns_non_ty_var(cx, t);\n         T_fn_pair(*cx, type_of_fn_from_ty(cx, sp, t, 0u))\n       }\n       ty::ty_native_fn(abi, args, out) {\n@@ -251,6 +258,7 @@ fn type_of_ty_param_kinds_and_ty(lcx: @local_ctxt, sp: span,\n     let t = tpt.ty;\n     alt ty::struct(cx.tcx, t) {\n       ty::ty_fn(_, _, _, _, _) {\n+        check returns_non_ty_var(cx, t);\n         let llfnty = type_of_fn_from_ty(cx, sp, t, std::vec::len(tpt.kinds));\n         ret T_fn_pair(*cx, llfnty);\n       }\n@@ -2717,27 +2725,30 @@ fn trans_for_each(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n     // Step 1: Generate code to build an environment containing pointers\n     // to all of the upvars\n     let lcx = cx.fcx.lcx;\n+    let ccx = lcx.ccx;\n \n     // FIXME: possibly support alias-mode here?\n-    let decl_ty = node_id_type(lcx.ccx, local.node.id);\n-    let upvars = get_freevars(lcx.ccx.tcx, body.node.id);\n+    let decl_ty = node_id_type(ccx, local.node.id);\n+    let upvars = get_freevars(ccx.tcx, body.node.id);\n \n     let llenv = build_closure(cx, upvars, false);\n \n     // Step 2: Declare foreach body function.\n     let s: str =\n-        mangle_internal_name_by_path_and_seq(lcx.ccx, lcx.path, \"foreach\");\n+        mangle_internal_name_by_path_and_seq(ccx, lcx.path, \"foreach\");\n \n     // The 'env' arg entering the body function is a fake env member (as in\n     // the env-part of the normal rust calling convention) that actually\n     // points to a stack allocated env in this frame. We bundle that env\n     // pointer along with the foreach-body-fn pointer into a 'normal' fn pair\n     // and pass it in as a first class fn-arg to the iterator.\n+    let iter_body_fn = ty::mk_iter_body_fn(ccx.tcx, decl_ty);\n+    // FIXME: should be a postcondition on mk_iter_body_fn\n+    check returns_non_ty_var(ccx, iter_body_fn);\n     let iter_body_llty =\n-        type_of_fn_from_ty(lcx.ccx, cx.sp,\n-                           ty::mk_iter_body_fn(lcx.ccx.tcx, decl_ty), 0u);\n+        type_of_fn_from_ty(ccx, cx.sp, iter_body_fn, 0u);\n     let lliterbody: ValueRef =\n-        decl_internal_fastcall_fn(lcx.ccx.llmod, s, iter_body_llty);\n+        decl_internal_fastcall_fn(ccx.llmod, s, iter_body_llty);\n     let fcx = new_fn_ctxt_w_id(lcx, cx.sp, lliterbody, body.node.id,\n                                ast::return_val);\n     fcx.iterbodyty = cx.fcx.iterbodyty;\n@@ -3258,16 +3269,21 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id) -> result {\n     ret rslt(e_res.bcx, newval);\n }\n \n+// pth is cx.path\n fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n                     outgoing_fty: ty::t, args: [option::t<@ast::expr>],\n                     env_ty: ty::t, ty_param_count: uint,\n-                    target_fn: option::t<ValueRef>) ->\n-   {val: ValueRef, ty: TypeRef} {\n-    // FIXME\n-    // This should be a precondition on trans_bind_thunk, but we would need\n-    // to support record fields as constraint args\n-    let ccx = cx.ccx;\n-    check (type_has_static_size(ccx, incoming_fty));\n+                    target_fn: option::t<ValueRef>)\n+    -> {val: ValueRef, ty: TypeRef} {\n+// If we supported constraints on record fields, we could make the\n+// constraints for this function:\n+/*\n+    : returns_non_ty_var(ccx, outgoing_fty),\n+      type_has_static_size(ccx, incoming_fty) ->\n+*/\n+// but since we don't, we have to do the checks at the beginning.\n+          let ccx = cx.ccx;\n+          check type_has_static_size(ccx, incoming_fty);\n \n     // Here we're not necessarily constructing a thunk in the sense of\n     // \"function with no arguments\".  The result of compiling 'bind f(foo,\n@@ -3424,8 +3440,11 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     // This is necessary because the type of the function that we have\n     // in the closure does not know how many type descriptors the function\n     // needs to take.\n+    let ccx = bcx_ccx(bcx);\n+\n+    check returns_non_ty_var(ccx, outgoing_fty);\n     let lltargetty =\n-        type_of_fn_from_ty(bcx_ccx(bcx), sp, outgoing_fty, ty_param_count);\n+        type_of_fn_from_ty(ccx, sp, outgoing_fty, ty_param_count);\n     lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n     FastCall(bcx, lltargetfn, llargs);\n     build_return(bcx);\n@@ -3972,8 +3991,10 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n       }\n       ast::expr_fn(f) {\n         let ccx = bcx_ccx(cx);\n+        let fty = node_id_type(ccx, e.id);\n+        check returns_non_ty_var(ccx, fty);\n         let llfnty: TypeRef =\n-            type_of_fn_from_ty(ccx, e.span, node_id_type(ccx, e.id), 0u);\n+            type_of_fn_from_ty(ccx, e.span, fty, 0u);\n         let sub_cx = extend_path(cx.fcx.lcx, ccx.names.next(\"anon\"));\n         let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n         let llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfnty);\n@@ -5416,13 +5437,16 @@ fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n \n fn decl_fn_and_pair(ccx: @crate_ctxt, sp: span, path: [str], flav: str,\n                     ty_params: [ast::ty_param], node_id: ast::node_id) {\n-    decl_fn_and_pair_full(ccx, sp, path, flav, ty_params, node_id,\n-                          node_id_type(ccx, node_id));\n+    // FIXME: pull this out\n+    let t = node_id_type(ccx, node_id);\n+    check returns_non_ty_var(ccx, t);\n+    decl_fn_and_pair_full(ccx, sp, path, flav, ty_params, node_id, t);\n }\n \n fn decl_fn_and_pair_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n                          ty_params: [ast::ty_param], node_id: ast::node_id,\n-                         node_type: ty::t) {\n+                         node_type: ty::t)\n+    : returns_non_ty_var(ccx, node_type) {\n     let path = path;\n     let llfty =\n         type_of_fn_from_ty(ccx, sp, node_type, std::vec::len(ty_params));\n@@ -5830,8 +5854,10 @@ fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, pt: [str], v: vt<[str]>) {\n         // the dtor_id. This is a bit counter-intuitive, but simplifies\n         // ty_res, which would have to carry around two def_ids otherwise\n         // -- one to identify the type, and one to find the dtor symbol.\n-        decl_fn_and_pair_full(ccx, i.span, new_pt, \"res_dtor\", tps, i.id,\n-                              node_id_type(ccx, dtor_id));\n+        let t = node_id_type(ccx, dtor_id);\n+        // FIXME: how to get rid of this check?\n+        check returns_non_ty_var(ccx, t);\n+        decl_fn_and_pair_full(ccx, i.span, new_pt, \"res_dtor\", tps, i.id, t);\n       }\n       _ { }\n     }"}]}