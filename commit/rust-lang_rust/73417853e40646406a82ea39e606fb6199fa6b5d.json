{"sha": "73417853e40646406a82ea39e606fb6199fa6b5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNDE3ODUzZTQwNjQ2NDA2YTgyZWEzOWU2MDZmYjYxOTlmYTZiNWQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-12T08:03:13Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-26T18:22:42Z"}, "message": "Refactor out the common functionality of\n`resolve_item_in_lexical_scope` and `resolve_identifier_in_local_ribs` into\na new function `resolve_ident_in_lexical_scope`.", "tree": {"sha": "e0cdb52993fc238971eba39aa06bd2ba61d5ea87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0cdb52993fc238971eba39aa06bd2ba61d5ea87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73417853e40646406a82ea39e606fb6199fa6b5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73417853e40646406a82ea39e606fb6199fa6b5d", "html_url": "https://github.com/rust-lang/rust/commit/73417853e40646406a82ea39e606fb6199fa6b5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73417853e40646406a82ea39e606fb6199fa6b5d/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07fecf80980c8df846bc63a29ca712b18fdbcfa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/07fecf80980c8df846bc63a29ca712b18fdbcfa7", "html_url": "https://github.com/rust-lang/rust/commit/07fecf80980c8df846bc63a29ca712b18fdbcfa7"}], "stats": {"total": 113, "additions": 61, "deletions": 52}, "files": [{"sha": "67279207e5b5fbfb6937ae920e66d93499a69289", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 61, "deletions": 52, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/73417853e40646406a82ea39e606fb6199fa6b5d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73417853e40646406a82ea39e606fb6199fa6b5d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=73417853e40646406a82ea39e606fb6199fa6b5d", "patch": "@@ -784,6 +784,11 @@ impl LocalDef {\n     }\n }\n \n+enum LexicalScopeBinding<'a> {\n+    Item(&'a NameBinding<'a>),\n+    LocalDef(LocalDef),\n+}\n+\n /// The link from a module up to its nearest parent node.\n #[derive(Clone,Debug)]\n enum ParentLink<'a> {\n@@ -1430,40 +1435,66 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                            span)\n     }\n \n-    /// This function resolves `name` in `namespace` in the current lexical scope, returning\n-    /// Success(binding) if `name` resolves to an item, or Failed(None) if `name` does not resolve\n-    /// or resolves to a type parameter or local variable.\n-    /// n.b. `resolve_identifier_in_local_ribs` also resolves names in the current lexical scope.\n+    /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n+    /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n+    /// `ident` in the first scope that defines it (or None if no scopes define it).\n+    ///\n+    /// A block's items are above its local variables in the scope hierarchy, regardless of where\n+    /// the items are defined in the block. For example,\n+    /// ```rust\n+    /// fn f() {\n+    ///    g(); // Since there are no local variables in scope yet, this resolves to the item.\n+    ///    let g = || {};\n+    ///    fn g() {}\n+    ///    g(); // This resolves to the local variable `g` since it shadows the item.\n+    /// }\n+    /// ```\n     ///\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n-    fn resolve_item_in_lexical_scope(&mut self,\n-                                     name: Name,\n-                                     namespace: Namespace,\n-                                     record_used: bool)\n-                                     -> ResolveResult<&'a NameBinding<'a>> {\n+    fn resolve_ident_in_lexical_scope(&mut self,\n+                                      ident: hir::Ident,\n+                                      ns: Namespace,\n+                                      record_used: bool)\n+                                      -> Option<LexicalScopeBinding<'a>> {\n+        let name = match ns { ValueNS => ident.name, TypeNS => ident.unhygienic_name };\n+\n         // Walk backwards up the ribs in scope.\n-        for i in (0 .. self.get_ribs(namespace).len()).rev() {\n-            if let Some(_) = self.get_ribs(namespace)[i].bindings.get(&name).cloned() {\n-                // The name resolves to a type parameter or local variable, so return Failed(None).\n-                return Failed(None);\n-            }\n-\n-            if let ModuleRibKind(module) = self.get_ribs(namespace)[i].kind {\n-                if let Success(binding) = self.resolve_name_in_module(module,\n-                                                                      name,\n-                                                                      namespace,\n-                                                                      true,\n-                                                                      record_used) {\n-                    // The name resolves to an item.\n-                    return Success(binding);\n+        for i in (0 .. self.get_ribs(ns).len()).rev() {\n+            if let Some(def) = self.get_ribs(ns)[i].bindings.get(&name).cloned() {\n+                // The ident resolves to a type parameter or local variable.\n+                return Some(LexicalScopeBinding::LocalDef(LocalDef {\n+                    ribs: Some((ns, i)),\n+                    def: def,\n+                }));\n+            }\n+\n+            if let ModuleRibKind(module) = self.get_ribs(ns)[i].kind {\n+                let name = ident.unhygienic_name;\n+                let item = self.resolve_name_in_module(module, name, ns, true, record_used);\n+                if let Success(binding) = item {\n+                    // The ident resolves to an item.\n+                    return Some(LexicalScopeBinding::Item(binding));\n                 }\n+\n                 // We can only see through anonymous modules\n-                if module.def.is_some() { return Failed(None); }\n+                if module.def.is_some() { return None; }\n             }\n         }\n \n-        Failed(None)\n+        None\n+    }\n+\n+    fn resolve_item_in_lexical_scope(&mut self,\n+                                     name: Name,\n+                                     namespace: Namespace,\n+                                     record_used: bool)\n+                                     -> ResolveResult<&'a NameBinding<'a>> {\n+        let ident = hir::Ident::from_name(name);\n+        match self.resolve_ident_in_lexical_scope(ident, namespace, record_used) {\n+            Some(LexicalScopeBinding::Item(binding)) => Success(binding),\n+            _ => Failed(None),\n+        }\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n@@ -2861,33 +2892,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         namespace: Namespace,\n                                         record_used: bool)\n                                         -> Option<LocalDef> {\n-        // Check the local set of ribs.\n-        let name = match namespace { ValueNS => ident.name, TypeNS => ident.unhygienic_name };\n-\n-        for i in (0 .. self.get_ribs(namespace).len()).rev() {\n-            if let Some(def) = self.get_ribs(namespace)[i].bindings.get(&name).cloned() {\n-                return Some(LocalDef {\n-                    ribs: Some((namespace, i)),\n-                    def: def,\n-                });\n-            }\n-\n-            if let ModuleRibKind(module) = self.get_ribs(namespace)[i].kind {\n-                if let Success(binding) = self.resolve_name_in_module(module,\n-                                                                      ident.unhygienic_name,\n-                                                                      namespace,\n-                                                                      true,\n-                                                                      record_used) {\n-                    if let Some(def) = binding.def() {\n-                        return Some(LocalDef::from_def(def));\n-                    }\n-                }\n-                // We can only see through anonymous modules\n-                if module.def.is_some() { return None; }\n-            }\n-        }\n-\n-        None\n+        Some(match self.resolve_ident_in_lexical_scope(ident, namespace, record_used) {\n+            Some(LexicalScopeBinding::LocalDef(local_def)) => local_def,\n+            Some(LexicalScopeBinding::Item(binding)) => LocalDef::from_def(binding.def().unwrap()),\n+            None => return None,\n+        })\n     }\n \n     fn with_no_errors<T, F>(&mut self, f: F) -> T"}]}