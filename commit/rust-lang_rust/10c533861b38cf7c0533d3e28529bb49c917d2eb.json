{"sha": "10c533861b38cf7c0533d3e28529bb49c917d2eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYzUzMzg2MWIzOGNmN2MwNTMzZDNlMjg1MjliYjQ5YzkxN2QyZWI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-05T19:39:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-05T19:39:16Z"}, "message": "doc: \"import\" -> \"use\"", "tree": {"sha": "7aee7e6071c395c87dc9cb630d999b7615772615", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7aee7e6071c395c87dc9cb630d999b7615772615"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10c533861b38cf7c0533d3e28529bb49c917d2eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10c533861b38cf7c0533d3e28529bb49c917d2eb", "html_url": "https://github.com/rust-lang/rust/commit/10c533861b38cf7c0533d3e28529bb49c917d2eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10c533861b38cf7c0533d3e28529bb49c917d2eb/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f686896f60d901fd7f97add72fbc047691027baa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f686896f60d901fd7f97add72fbc047691027baa", "html_url": "https://github.com/rust-lang/rust/commit/f686896f60d901fd7f97add72fbc047691027baa"}], "stats": {"total": 135, "additions": 68, "deletions": 67}, "files": [{"sha": "20f25c8c2b4a66d621567fc10c53803f8685b009", "filename": "doc/rust.md", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/10c533861b38cf7c0533d3e28529bb49c917d2eb/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/10c533861b38cf7c0533d3e28529bb49c917d2eb/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=10c533861b38cf7c0533d3e28529bb49c917d2eb", "patch": "@@ -203,7 +203,7 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n The keywords in [crate files](#crate-files) are the following strings:\n \n ~~~~~~~~ {.keyword}\n-import export use mod\n+export use mod\n ~~~~~~~~\n \n The keywords in [source files](#source-files) are the following strings:\n@@ -215,7 +215,7 @@ check const copy\n drop\n else enum export extern\n fail false fn for\n-if impl import\n+if impl\n let log loop\n match mod mut\n pure\n@@ -447,7 +447,7 @@ expression context, the final namespace qualifier is omitted.\n Two examples of paths with type arguments:\n \n ~~~~\n-# import std::map;\n+# use std::map;\n # fn f() {\n # fn id<T:copy>(t: T) -> T { t }\n type t = map::hashmap<int,~str>;  // Type arguments used in a type expression\n@@ -619,8 +619,8 @@ or a *configuration* in Mesa.] A crate file describes:\n   and copyright. These are used for linking, versioning and distributing\n   crates.\n * The source-file and directory modules that make up the crate.\n-* Any `use`, `import` or `export` [view items](#view-items) that apply to the\n-  anonymous module at the top-level of the crate's module tree.\n+* Any `use`, `extern mod` or `export` [view items](#view-items) that apply to\n+  the anonymous module at the top-level of the crate's module tree.\n \n An example of a crate file:\n \n@@ -636,7 +636,7 @@ An example of a crate file:\n    author = \"Jane Doe\" ];\n \n // Import a module.\n-use std (ver = \"1.0\");\n+extern mod std (ver = \"1.0\");\n \n // Define some modules.\n #[path = \"foo.rs\"]\n@@ -767,28 +767,28 @@ mod math {\n #### View items\n \n ~~~~~~~~ {.ebnf .gram}\n-view_item : use_decl | import_decl | export_decl ;\n+view_item : extern_mod_decl | use_decl | export_decl ;\n ~~~~~~~~\n \n A view item manages the namespace of a module; it does not define new items\n but simply changes the visibility of other items. There are several kinds of\n view item:\n \n+ * [extern mod declarations](#extern-mod-declarations)\n  * [use declarations](#use-declarations)\n- * [import declarations](#import-declarations)\n  * [export declarations](#export-declarations)\n \n-##### Use declarations\n+##### Extern mod declarations\n \n ~~~~~~~~ {.ebnf .gram}\n-use_decl : \"use\" ident [ '(' link_attrs ')' ] ? ;\n+extern_mod_decl : \"extern\" \"mod\" ident [ '(' link_attrs ')' ] ? ;\n link_attrs : link_attr [ ',' link_attrs ] + ;\n link_attr : ident '=' literal ;\n ~~~~~~~~\n \n-A _use declaration_ specifies a dependency on an external crate. The external\n-crate is then imported into the declaring scope as the `ident` provided in the\n-`use_decl`.\n+An _extern mod declaration_ specifies a dependency on an external crate. The\n+external crate is then imported into the declaring scope as the `ident`\n+provided in the `extern_mod_decl`.\n \n The external crate is resolved to a specific `soname` at compile time, and a\n runtime linkage requirement to that `soname` is passed to the linker for\n@@ -798,51 +798,52 @@ compiler's library path and matching the `link_attrs` provided in the\n crate when it was compiled. If no `link_attrs` are provided, a default `name`\n attribute is assumed, equal to the `ident` given in the `use_decl`.\n \n-Two examples of `use` declarations:\n+Two examples of `extern mod` declarations:\n \n ~~~~~~~~{.xfail-test}\n-use pcre (uuid = \"54aba0f8-a7b1-4beb-92f1-4cf625264841\");\n+extern mod pcre (uuid = \"54aba0f8-a7b1-4beb-92f1-4cf625264841\");\n \n-use std; // equivalent to: use std ( name = \"std\" );\n+extern mod std; // equivalent to: extern mod std ( name = \"std\" );\n \n-use ruststd (name = \"std\"); // linking to 'std' under another name\n+extern mod ruststd (name = \"std\"); // linking to 'std' under another name\n ~~~~~~~~\n \n-##### Import declarations\n+##### Use declarations\n \n ~~~~~~~~ {.ebnf .gram}\n-import_decl : \"import\" ident [ '=' path\n-                             | \"::\" path_glob ] ;\n+use_decl : \"use\" ident [ '=' path\n+                          | \"::\" path_glob ] ;\n \n path_glob : ident [ \"::\" path_glob ] ?\n           | '*'\n           | '{' ident [ ',' ident ] * '}'\n ~~~~~~~~\n \n-An _import declaration_ creates one or more local name bindings synonymous\n-with some other [path](#paths). Usually an import declaration is used to\n+A _use declaration_ creates one or more local name bindings synonymous\n+with some other [path](#paths). Usually an use declaration is used to\n shorten the path required to refer to a module item.\n \n-*Note*: unlike many languages, Rust's `import` declarations do *not* declare\n+*Note*: unlike many languages, Rust's `use` declarations do *not* declare\n linkage-dependency with external crates. Linkage dependencies are\n-independently declared with [`use` declarations](#use-declarations).\n+independently declared with\n+[`extern mod` declarations](#extern-mod-declarations).\n \n Imports support a number of \"convenience\" notations:\n \n   * Importing as a different name than the imported name, using the\n-    syntax `import x = p::q::r;`.\n+    syntax `use x = p::q::r;`.\n   * Importing a list of paths differing only in final element, using\n-    the glob-like brace syntax `import a::b::{c,d,e,f};`\n+    the glob-like brace syntax `use a::b::{c,d,e,f};`\n   * Importing all paths matching a given prefix, using the glob-like\n-    asterisk syntax `import a::b::*;`\n+    asterisk syntax `use a::b::*;`\n \n An example of imports:\n \n ~~~~\n-import foo = core::info;\n-import core::float::sin;\n-import core::str::{slice, to_upper};\n-import core::option::Some;\n+use foo = core::info;\n+use core::float::sin;\n+use core::str::{slice, to_upper};\n+use core::option::Some;\n \n fn main() {\n     // Equivalent to 'log(core::info, core::float::sin(1.0));'\n@@ -1053,7 +1054,7 @@ verify the semantics of the pure functions they write.\n An example of a pure function that uses an unchecked block:\n \n ~~~~\n-# import std::list::*;\n+# use std::list::*;\n \n fn pure_foldl<T, U: copy>(ls: List<T>, u: U, f: fn(&&T, &&U) -> U) -> U {\n     match ls {\n@@ -1347,7 +1348,7 @@ Rust functions, with the exception that they may not have a body and are\n instead terminated by a semi-colon.\n \n ~~~\n-# import libc::{c_char, FILE};\n+# use libc::{c_char, FILE};\n # #[nolink]\n \n extern mod c {"}, {"sha": "c9e0c1a4fc6b7a9db49d7333a3fb24614c91a23a", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10c533861b38cf7c0533d3e28529bb49c917d2eb/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/10c533861b38cf7c0533d3e28529bb49c917d2eb/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=10c533861b38cf7c0533d3e28529bb49c917d2eb", "patch": "@@ -13,8 +13,8 @@ hexadecimal string and prints to standard output. If you have the\n OpenSSL libraries installed, it should 'just work'.\n \n ~~~~ {.xfail-test}\n-use std;\n-import libc::c_uint;\n+extern mod std;\n+use libc::c_uint;\n \n extern mod crypto {\n     fn SHA1(src: *u8, sz: c_uint, out: *u8) -> *u8;\n@@ -208,8 +208,8 @@ This program uses the POSIX function `gettimeofday` to get a\n microsecond-resolution timer.\n \n ~~~~\n-use std;\n-import libc::c_ulonglong;\n+extern mod std;\n+use libc::c_ulonglong;\n \n type timeval = {mut tv_sec: c_ulonglong,\n                 mut tv_usec: c_ulonglong};"}, {"sha": "462a20eb85a2da8bcfcfc436ebac42701218b4b0", "filename": "doc/tutorial.md", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/10c533861b38cf7c0533d3e28529bb49c917d2eb/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/10c533861b38cf7c0533d3e28529bb49c917d2eb/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=10c533861b38cf7c0533d3e28529bb49c917d2eb", "patch": "@@ -1222,7 +1222,7 @@ most vector functionality is provided by methods, so let's have a\n brief look at a few common ones.\n \n ~~~\n-# import io::println;\n+# use io::println;\n # enum crayon {\n #     almond, antique_brass, apricot,\n #     aquamarine, asparagus, atomic_tangerine,\n@@ -1276,7 +1276,7 @@ Rust also supports _closures_, functions that can access variables in\n the enclosing scope.\n \n ~~~~\n-# import println = io::println;\n+# use println = io::println;\n fn call_closure_with_ten(b: fn(int)) { b(10); }\n \n let captured_var = 20;\n@@ -1434,7 +1434,7 @@ takes a final closure argument.\n `do` is often used for task spawning.\n \n ~~~~\n-import task::spawn;\n+use task::spawn;\n \n do spawn() || {\n     debug!(\"I'm a task, whatever\");\n@@ -1446,7 +1446,7 @@ argument lists back to back. Wouldn't it be great if they weren't\n there?\n \n ~~~~\n-# import task::spawn;\n+# use task::spawn;\n do spawn {\n    debug!(\"Kablam!\");\n }\n@@ -1479,8 +1479,8 @@ fn each(v: ~[int], op: fn(int) -> bool) {\n And using this function to iterate over a vector:\n \n ~~~~\n-# import each = vec::each;\n-# import println = io::println;\n+# use each = vec::each;\n+# use println = io::println;\n each(~[2, 4, 8, 5, 16], |n| {\n     if n % 2 != 0 {\n         println(~\"found odd number!\");\n@@ -1496,8 +1496,8 @@ out of the loop, you just write `break`. To skip ahead\n to the next iteration, write `again`.\n \n ~~~~\n-# import each = vec::each;\n-# import println = io::println;\n+# use each = vec::each;\n+# use println = io::println;\n for each(~[2, 4, 8, 5, 16]) |n| {\n     if n % 2 != 0 {\n         println(~\"found odd number!\");\n@@ -1512,7 +1512,7 @@ normally allowed in closures, in a block that appears as the body of a\n function, not just the loop body.\n \n ~~~~\n-# import each = vec::each;\n+# use each = vec::each;\n fn contains(v: ~[int], elt: int) -> bool {\n     for each(v) |x| {\n         if (x == elt) { return true; }\n@@ -1760,22 +1760,22 @@ that path is several modules deep). Rust allows you to import\n identifiers at the top of a file, module, or block.\n \n ~~~~\n-use std;\n-import io::println;\n+extern mod std;\n+use io::println;\n fn main() {\n     println(~\"that was easy\");\n }\n ~~~~\n \n-It is also possible to import just the name of a module (`import\n+It is also possible to import just the name of a module (`use\n std::list;`, then use `list::find`), to import all identifiers exported\n-by a given module (`import io::*`), or to import a specific set\n-of identifiers (`import math::{min, max, pi}`).\n+by a given module (`use io::*`), or to import a specific set\n+of identifiers (`use math::{min, max, pi}`).\n \n You can rename an identifier when importing using the `=` operator:\n \n ~~~~\n-import prnt = io::println;\n+use prnt = io::println;\n ~~~~\n \n ## Exporting\n@@ -1836,14 +1836,14 @@ fn main() {\n }\n ~~~~\n \n-An `import` directive will only import into the namespaces for which\n+An `use` directive will only import into the namespaces for which\n identifiers are actually found. Consider this example:\n \n ~~~~\n type bar = uint;\n mod foo { fn bar() {} }\n mod baz {\n-    import foo::bar;\n+    use foo::bar;\n     const x: bar = 20u;\n }\n ~~~~\n@@ -2089,8 +2089,8 @@ Spawning a task is done using the various spawn functions in the\n module `task`.  Let's begin with the simplest one, `task::spawn()`:\n \n ~~~~\n-import task::spawn;\n-import io::println;\n+use task::spawn;\n+use io::println;\n \n let some_value = 22;\n \n@@ -2116,8 +2116,8 @@ receiving messages. The easiest way to create a pipe is to use\n computations in parallel.  We might write something like:\n \n ~~~~\n-import task::spawn;\n-import pipes::{stream, Port, Chan};\n+use task::spawn;\n+use pipes::{stream, Port, Chan};\n \n let (chan, port) = stream();\n \n@@ -2137,7 +2137,7 @@ Let's walk through this code line-by-line.  The first line creates a\n stream for sending and receiving integers:\n \n ~~~~ {.ignore}\n-# import pipes::stream;\n+# use pipes::stream;\n let (chan, port) = stream();\n ~~~~\n \n@@ -2146,8 +2146,8 @@ once it is complete.  The channel will be used by the child to send a\n message to the port.  The next statement actually spawns the child:\n \n ~~~~\n-# import task::{spawn};\n-# import comm::{Port, Chan};\n+# use task::{spawn};\n+# use comm::{Port, Chan};\n # fn some_expensive_computation() -> int { 42 }\n # let port = Port();\n # let chan = port.chan();\n@@ -2167,7 +2167,7 @@ some other expensive computation and then waiting for the child's result\n to arrive on the port:\n \n ~~~~\n-# import pipes::{stream, Port, Chan};\n+# use pipes::{stream, Port, Chan};\n # fn some_other_expensive_computation() {}\n # let (chan, port) = stream::<int>();\n # chan.send(0);\n@@ -2188,8 +2188,8 @@ the string in response.  The child terminates when `0` is received.\n Here is the function that implements the child task:\n \n ~~~~\n-# import std::comm::DuplexStream;\n-# import pipes::{Port, Chan};\n+# use std::comm::DuplexStream;\n+# use pipes::{Port, Chan};\n fn stringifier(channel: DuplexStream<~str, uint>) {\n     let mut value: uint;\n     loop {\n@@ -2211,9 +2211,9 @@ response itself is simply the strified version of the received value,\n Here is the code for the parent task:\n \n ~~~~\n-# import std::comm::DuplexStream;\n-# import pipes::{Port, Chan};\n-# import task::spawn;\n+# use std::comm::DuplexStream;\n+# use pipes::{Port, Chan};\n+# use task::spawn;\n # fn stringifier(channel: DuplexStream<~str, uint>) {\n #     let mut value: uint;\n #     loop {"}]}