{"sha": "5e9d91831a094dae187ba781f98637a902dae0c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlOWQ5MTgzMWEwOTRkYWUxODdiYTc4MWY5ODYzN2E5MDJkYWUwYzE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-27T20:24:26Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-27T22:56:25Z"}, "message": "Rollup merge of #40832 - pftbest:fix_msp430, r=stjepang\n\nlibcore: fix compilation on 16bit target (MSP430).\n\nSince PR #40601 has been merged, libcore no longer compiles on MSP430.\nThe reason is this code in `break_patterns`:\n```rust\n let mut random = len;\n random ^= random << 13;\n random ^= random >> 17;\n random ^= random << 5;\n random &= modulus - 1;\n```\nIt assumes that `len` is at least a 32 bit integer.\nAs a workaround replace `break_patterns` with an empty function for 16bit targets.\n\ncc @stjepang\ncc @alexcrichton", "tree": {"sha": "e84df1f690c878c015e93bb5109d9facdf823ee9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e84df1f690c878c015e93bb5109d9facdf823ee9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e9d91831a094dae187ba781f98637a902dae0c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9d91831a094dae187ba781f98637a902dae0c1", "html_url": "https://github.com/rust-lang/rust/commit/5e9d91831a094dae187ba781f98637a902dae0c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e9d91831a094dae187ba781f98637a902dae0c1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d93c12581d73cbcedc7fd502f847147b968a78d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d93c12581d73cbcedc7fd502f847147b968a78d", "html_url": "https://github.com/rust-lang/rust/commit/4d93c12581d73cbcedc7fd502f847147b968a78d"}, {"sha": "fda8e1571f7a0c4da77c57bc7a7728c4ed1e6aea", "url": "https://api.github.com/repos/rust-lang/rust/commits/fda8e1571f7a0c4da77c57bc7a7728c4ed1e6aea", "html_url": "https://github.com/rust-lang/rust/commit/fda8e1571f7a0c4da77c57bc7a7728c4ed1e6aea"}], "stats": {"total": 56, "additions": 32, "deletions": 24}, "files": [{"sha": "3612ee65bca0dba78c5ad3fd35e51bbba3b3340e", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5e9d91831a094dae187ba781f98637a902dae0c1/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9d91831a094dae187ba781f98637a902dae0c1/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=5e9d91831a094dae187ba781f98637a902dae0c1", "patch": "@@ -498,32 +498,40 @@ fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n #[cold]\n fn break_patterns<T>(v: &mut [T]) {\n     let len = v.len();\n-\n     if len >= 8 {\n-        // A random number will be taken modulo this one. The modulus is a power of two so that we\n-        // can simply take bitwise \"and\", thus avoiding costly CPU operations.\n-        let modulus = (len / 4).next_power_of_two();\n-        debug_assert!(modulus >= 1 && modulus <= len / 2);\n-\n-        // Pseudorandom number generation from the \"Xorshift RNGs\" paper by George Marsaglia.\n-        let mut random = len;\n-        random ^= random << 13;\n-        random ^= random >> 17;\n-        random ^= random << 5;\n-        random &= modulus - 1;\n-        debug_assert!(random < len / 2);\n-\n-        // The first index.\n-        let a = len / 4 * 2;\n-        debug_assert!(a >= 1 && a < len - 2);\n-\n-        // The second index.\n-        let b = len / 4 + random;\n-        debug_assert!(b >= 1 && b < len - 2);\n-\n-        // Swap neighbourhoods of `a` and `b`.\n+        // Pseudorandom number generator from the \"Xorshift RNGs\" paper by George Marsaglia.\n+        let mut random = len as u32;\n+        let mut gen_u32 = || {\n+            random ^= random << 13;\n+            random ^= random >> 17;\n+            random ^= random << 5;\n+            random\n+        };\n+        let mut gen_usize = || {\n+            if mem::size_of::<usize>() <= 4 {\n+                gen_u32() as usize\n+            } else {\n+                (((gen_u32() as u64) << 32) | (gen_u32() as u64)) as usize\n+            }\n+        };\n+\n+        // Take random numbers modulo this number.\n+        // The number fits into `usize` because `len` is not greater than `isize::MAX`.\n+        let modulus = len.next_power_of_two();\n+\n+        // Some pivot candidates will be in the nearby of this index. Let's randomize them.\n+        let pos = len / 4 * 2;\n+\n         for i in 0..3 {\n-            v.swap(a - 1 + i, b - 1 + i);\n+            // Generate a random number modulo `len`. However, in order to avoid costly operations\n+            // we first take it modulo a power of two, and then decrease by `len` until it fits\n+            // into the range `[0, len - 1]`.\n+            let mut other = gen_usize() & (modulus - 1);\n+            while other >= len {\n+                other -= len;\n+            }\n+\n+            v.swap(pos - 1 + i, other);\n         }\n     }\n }"}]}