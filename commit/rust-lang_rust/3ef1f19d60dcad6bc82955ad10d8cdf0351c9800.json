{"sha": "3ef1f19d60dcad6bc82955ad10d8cdf0351c9800", "node_id": "C_kwDOAAsO6NoAKDNlZjFmMTlkNjBkY2FkNmJjODI5NTVhZDEwZDhjZGYwMzUxYzk4MDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-25T19:20:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-25T19:20:05Z"}, "message": "Auto merge of #7873 - xFrednet:7869-string-index-ice, r=Manishearth\n\nUpdate `str` utils to prevent ICEs and FNs\n\nThis PR reworks some string handling for lints regarding enum naming. I hope the refactoring will prevent future ICEs and help with new bug free implementations.\n\nIt might be better to review this PR by going through the commits, as `clippy_utils::camel_case` was renamed to `clippy_utils::str_utils` and then changed further. GH sadly doesn't really make the changes that obvious :upside_down_face:\n\nNot too much more to say. Have a nice day :sun_with_face:\n\n---\n\nFixes: rust-lang/rust-clippy#7869\n\nchangelog: ICE Fix: [`enum_variant_names`] #7869", "tree": {"sha": "4b92b926e74bf61483b9fbb2637f55dab758cfc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b92b926e74bf61483b9fbb2637f55dab758cfc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800", "html_url": "https://github.com/rust-lang/rust/commit/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f46f4266a322d55dd4deeb502141a23e9218770", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f46f4266a322d55dd4deeb502141a23e9218770", "html_url": "https://github.com/rust-lang/rust/commit/4f46f4266a322d55dd4deeb502141a23e9218770"}, {"sha": "7517ae2fb3bc29e91f0f7c2daaac8cd8c8887bb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7517ae2fb3bc29e91f0f7c2daaac8cd8c8887bb2", "html_url": "https://github.com/rust-lang/rust/commit/7517ae2fb3bc29e91f0f7c2daaac8cd8c8887bb2"}], "stats": {"total": 433, "additions": 275, "deletions": 158}, "files": [{"sha": "404b67c8f29f2817a9e6f58c3fc55d3b588075e4", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=3ef1f19d60dcad6bc82955ad10d8cdf0351c9800", "patch": "@@ -1,8 +1,8 @@\n //! lint on enum variants that are prefixed or suffixed by the same characters\n \n-use clippy_utils::camel_case;\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::source::is_present_in_source;\n+use clippy_utils::str_utils::{self, count_match_end, count_match_start};\n use rustc_hir::{EnumDef, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -117,26 +117,6 @@ impl_lint_pass!(EnumVariantNames => [\n     MODULE_INCEPTION\n ]);\n \n-/// Returns the number of chars that match from the start\n-#[must_use]\n-fn partial_match(pre: &str, name: &str) -> usize {\n-    let mut name_iter = name.chars();\n-    let _ = name_iter.next_back(); // make sure the name is never fully matched\n-    pre.chars().zip(name_iter).take_while(|&(l, r)| l == r).count()\n-}\n-\n-/// Returns the number of chars that match from the end\n-#[must_use]\n-fn partial_rmatch(post: &str, name: &str) -> usize {\n-    let mut name_iter = name.chars();\n-    let _ = name_iter.next(); // make sure the name is never fully matched\n-    post.chars()\n-        .rev()\n-        .zip(name_iter.rev())\n-        .take_while(|&(l, r)| l == r)\n-        .count()\n-}\n-\n fn check_variant(\n     cx: &LateContext<'_>,\n     threshold: u64,\n@@ -150,7 +130,7 @@ fn check_variant(\n     }\n     for var in def.variants {\n         let name = var.ident.name.as_str();\n-        if partial_match(item_name, &name) == item_name_chars\n+        if count_match_start(item_name, &name).char_count == item_name_chars\n             && name.chars().nth(item_name_chars).map_or(false, |c| !c.is_lowercase())\n             && name.chars().nth(item_name_chars + 1).map_or(false, |c| !c.is_numeric())\n         {\n@@ -161,7 +141,7 @@ fn check_variant(\n                 \"variant name starts with the enum's name\",\n             );\n         }\n-        if partial_rmatch(item_name, &name) == item_name_chars {\n+        if count_match_end(item_name, &name).char_count == item_name_chars {\n             span_lint(\n                 cx,\n                 ENUM_VARIANT_NAMES,\n@@ -171,33 +151,33 @@ fn check_variant(\n         }\n     }\n     let first = &def.variants[0].ident.name.as_str();\n-    let mut pre = &first[..camel_case::until(&*first)];\n-    let mut post = &first[camel_case::from(&*first)..];\n+    let mut pre = &first[..str_utils::camel_case_until(&*first).byte_index];\n+    let mut post = &first[str_utils::camel_case_start(&*first).byte_index..];\n     for var in def.variants {\n         let name = var.ident.name.as_str();\n \n-        let pre_match = partial_match(pre, &name);\n+        let pre_match = count_match_start(pre, &name).byte_count;\n         pre = &pre[..pre_match];\n-        let pre_camel = camel_case::until(pre);\n+        let pre_camel = str_utils::camel_case_until(pre).byte_index;\n         pre = &pre[..pre_camel];\n         while let Some((next, last)) = name[pre.len()..].chars().zip(pre.chars().rev()).next() {\n             if next.is_numeric() {\n                 return;\n             }\n             if next.is_lowercase() {\n                 let last = pre.len() - last.len_utf8();\n-                let last_camel = camel_case::until(&pre[..last]);\n-                pre = &pre[..last_camel];\n+                let last_camel = str_utils::camel_case_until(&pre[..last]);\n+                pre = &pre[..last_camel.byte_index];\n             } else {\n                 break;\n             }\n         }\n \n-        let post_match = partial_rmatch(post, &name);\n-        let post_end = post.len() - post_match;\n+        let post_match = count_match_end(post, &name);\n+        let post_end = post.len() - post_match.byte_count;\n         post = &post[post_end..];\n-        let post_camel = camel_case::from(post);\n-        post = &post[post_camel..];\n+        let post_camel = str_utils::camel_case_start(post);\n+        post = &post[post_camel.byte_index..];\n     }\n     let (what, value) = match (pre.is_empty(), post.is_empty()) {\n         (true, true) => return,\n@@ -266,14 +246,16 @@ impl LateLintPass<'_> for EnumVariantNames {\n                             );\n                         }\n                     }\n-                    if item.vis.node.is_pub() {\n-                        let matching = partial_match(mod_camel, &item_camel);\n-                        let rmatching = partial_rmatch(mod_camel, &item_camel);\n+                    // The `module_name_repetitions` lint should only trigger if the item has the module in its\n+                    // name. Having the same name is accepted.\n+                    if item.vis.node.is_pub() && item_camel.len() > mod_camel.len() {\n+                        let matching = count_match_start(mod_camel, &item_camel);\n+                        let rmatching = count_match_end(mod_camel, &item_camel);\n                         let nchars = mod_camel.chars().count();\n \n                         let is_word_beginning = |c: char| c == '_' || c.is_uppercase() || c.is_numeric();\n \n-                        if matching == nchars {\n+                        if matching.char_count == nchars {\n                             match item_camel.chars().nth(nchars) {\n                                 Some(c) if is_word_beginning(c) => span_lint(\n                                     cx,\n@@ -284,7 +266,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n                                 _ => (),\n                             }\n                         }\n-                        if rmatching == nchars {\n+                        if rmatching.char_count == nchars {\n                             span_lint(\n                                 cx,\n                                 MODULE_NAME_REPETITIONS,"}, {"sha": "a6636e391374e13d4c75fe0a6effc0e08495ad6f", "filename": "clippy_utils/src/camel_case.rs", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/4f46f4266a322d55dd4deeb502141a23e9218770/clippy_utils%2Fsrc%2Fcamel_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f46f4266a322d55dd4deeb502141a23e9218770/clippy_utils%2Fsrc%2Fcamel_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fcamel_case.rs?ref=4f46f4266a322d55dd4deeb502141a23e9218770", "patch": "@@ -1,117 +0,0 @@\n-/// Returns the index of the character after the first camel-case component of `s`.\n-#[must_use]\n-pub fn until(s: &str) -> usize {\n-    let mut iter = s.char_indices();\n-    if let Some((_, first)) = iter.next() {\n-        if !first.is_uppercase() {\n-            return 0;\n-        }\n-    } else {\n-        return 0;\n-    }\n-    let mut up = true;\n-    let mut last_i = 0;\n-    for (i, c) in iter {\n-        if up {\n-            if c.is_lowercase() {\n-                up = false;\n-            } else {\n-                return last_i;\n-            }\n-        } else if c.is_uppercase() {\n-            up = true;\n-            last_i = i;\n-        } else if !c.is_lowercase() {\n-            return i;\n-        }\n-    }\n-    if up { last_i } else { s.len() }\n-}\n-\n-/// Returns index of the last camel-case component of `s`.\n-#[must_use]\n-pub fn from(s: &str) -> usize {\n-    let mut iter = s.char_indices().rev();\n-    if let Some((_, first)) = iter.next() {\n-        if !first.is_lowercase() {\n-            return s.len();\n-        }\n-    } else {\n-        return s.len();\n-    }\n-    let mut down = true;\n-    let mut last_i = s.len();\n-    for (i, c) in iter {\n-        if down {\n-            if c.is_uppercase() {\n-                down = false;\n-                last_i = i;\n-            } else if !c.is_lowercase() {\n-                return last_i;\n-            }\n-        } else if c.is_lowercase() {\n-            down = true;\n-        } else if c.is_uppercase() {\n-            last_i = i;\n-        } else {\n-            return last_i;\n-        }\n-    }\n-    last_i\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::{from, until};\n-\n-    #[test]\n-    fn from_full() {\n-        assert_eq!(from(\"AbcDef\"), 0);\n-        assert_eq!(from(\"Abc\"), 0);\n-        assert_eq!(from(\"ABcd\"), 0);\n-        assert_eq!(from(\"ABcdEf\"), 0);\n-        assert_eq!(from(\"AabABcd\"), 0);\n-    }\n-\n-    #[test]\n-    fn from_partial() {\n-        assert_eq!(from(\"abcDef\"), 3);\n-        assert_eq!(from(\"aDbc\"), 1);\n-        assert_eq!(from(\"aabABcd\"), 3);\n-    }\n-\n-    #[test]\n-    fn from_not() {\n-        assert_eq!(from(\"AbcDef_\"), 7);\n-        assert_eq!(from(\"AbcDD\"), 5);\n-    }\n-\n-    #[test]\n-    fn from_caps() {\n-        assert_eq!(from(\"ABCD\"), 4);\n-    }\n-\n-    #[test]\n-    fn until_full() {\n-        assert_eq!(until(\"AbcDef\"), 6);\n-        assert_eq!(until(\"Abc\"), 3);\n-    }\n-\n-    #[test]\n-    fn until_not() {\n-        assert_eq!(until(\"abcDef\"), 0);\n-        assert_eq!(until(\"aDbc\"), 0);\n-    }\n-\n-    #[test]\n-    fn until_partial() {\n-        assert_eq!(until(\"AbcDef_\"), 6);\n-        assert_eq!(until(\"CallTypeC\"), 8);\n-        assert_eq!(until(\"AbcDD\"), 3);\n-    }\n-\n-    #[test]\n-    fn until_caps() {\n-        assert_eq!(until(\"ABCD\"), 0);\n-    }\n-}"}, {"sha": "086fbc9d3ddddcfba357846e45e897f806118814", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=3ef1f19d60dcad6bc82955ad10d8cdf0351c9800", "patch": "@@ -37,7 +37,6 @@ pub mod sym_helper;\n #[allow(clippy::module_name_repetitions)]\n pub mod ast_utils;\n pub mod attrs;\n-pub mod camel_case;\n pub mod comparisons;\n pub mod consts;\n pub mod diagnostics;\n@@ -50,6 +49,7 @@ pub mod paths;\n pub mod ptr;\n pub mod qualify_min_const_fn;\n pub mod source;\n+pub mod str_utils;\n pub mod sugg;\n pub mod ty;\n pub mod usage;"}, {"sha": "cba96e05a2412244e6c36cd78d52b181c985cc8b", "filename": "clippy_utils/src/str_utils.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/clippy_utils%2Fsrc%2Fstr_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/clippy_utils%2Fsrc%2Fstr_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fstr_utils.rs?ref=3ef1f19d60dcad6bc82955ad10d8cdf0351c9800", "patch": "@@ -0,0 +1,230 @@\n+/// Dealing with sting indices can be hard, this struct ensures that both the\n+/// character and byte index are provided for correct indexing.\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct StrIndex {\n+    pub char_index: usize,\n+    pub byte_index: usize,\n+}\n+\n+impl StrIndex {\n+    pub fn new(char_index: usize, byte_index: usize) -> Self {\n+        Self { char_index, byte_index }\n+    }\n+}\n+\n+/// Returns the index of the character after the first camel-case component of `s`.\n+///\n+/// ```\n+/// assert_eq!(camel_case_until(\"AbcDef\"), StrIndex::new(6, 6));\n+/// assert_eq!(camel_case_until(\"ABCD\"), StrIndex::new(0, 0));\n+/// assert_eq!(camel_case_until(\"AbcDD\"), StrIndex::new(3, 3));\n+/// assert_eq!(camel_case_until(\"Abc\\u{f6}\\u{f6}DD\"), StrIndex::new(5, 7));\n+/// ```\n+#[must_use]\n+pub fn camel_case_until(s: &str) -> StrIndex {\n+    let mut iter = s.char_indices().enumerate();\n+    if let Some((_char_index, (_, first))) = iter.next() {\n+        if !first.is_uppercase() {\n+            return StrIndex::new(0, 0);\n+        }\n+    } else {\n+        return StrIndex::new(0, 0);\n+    }\n+    let mut up = true;\n+    let mut last_index = StrIndex::new(0, 0);\n+    for (char_index, (byte_index, c)) in iter {\n+        if up {\n+            if c.is_lowercase() {\n+                up = false;\n+            } else {\n+                return last_index;\n+            }\n+        } else if c.is_uppercase() {\n+            up = true;\n+            last_index.byte_index = byte_index;\n+            last_index.char_index = char_index;\n+        } else if !c.is_lowercase() {\n+            return StrIndex::new(char_index, byte_index);\n+        }\n+    }\n+\n+    if up {\n+        last_index\n+    } else {\n+        StrIndex::new(s.chars().count(), s.len())\n+    }\n+}\n+\n+/// Returns index of the last camel-case component of `s`.\n+///\n+/// ```\n+/// assert_eq!(camel_case_start(\"AbcDef\"), StrIndex::new(0, 0));\n+/// assert_eq!(camel_case_start(\"abcDef\"), StrIndex::new(3, 3));\n+/// assert_eq!(camel_case_start(\"ABCD\"), StrIndex::new(4, 4));\n+/// assert_eq!(camel_case_start(\"abcd\"), StrIndex::new(4, 4));\n+/// assert_eq!(camel_case_start(\"\\u{f6}\\u{f6}cd\"), StrIndex::new(4, 6));\n+/// ```\n+#[must_use]\n+pub fn camel_case_start(s: &str) -> StrIndex {\n+    let char_count = s.chars().count();\n+    let range = 0..char_count;\n+    let mut iter = range.rev().zip(s.char_indices().rev());\n+    if let Some((char_index, (_, first))) = iter.next() {\n+        if !first.is_lowercase() {\n+            return StrIndex::new(char_index, s.len());\n+        }\n+    } else {\n+        return StrIndex::new(char_count, s.len());\n+    }\n+    let mut down = true;\n+    let mut last_index = StrIndex::new(char_count, s.len());\n+    for (char_index, (byte_index, c)) in iter {\n+        if down {\n+            if c.is_uppercase() {\n+                down = false;\n+                last_index.byte_index = byte_index;\n+                last_index.char_index = char_index;\n+            } else if !c.is_lowercase() {\n+                return last_index;\n+            }\n+        } else if c.is_lowercase() {\n+            down = true;\n+        } else if c.is_uppercase() {\n+            last_index.byte_index = byte_index;\n+            last_index.char_index = char_index;\n+        } else {\n+            return last_index;\n+        }\n+    }\n+    last_index\n+}\n+\n+/// Dealing with sting comparison can be complicated, this struct ensures that both the\n+/// character and byte count are provided for correct indexing.\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct StrCount {\n+    pub char_count: usize,\n+    pub byte_count: usize,\n+}\n+\n+impl StrCount {\n+    pub fn new(char_count: usize, byte_count: usize) -> Self {\n+        Self { char_count, byte_count }\n+    }\n+}\n+\n+/// Returns the number of chars that match from the start\n+///\n+/// ```\n+/// assert_eq!(count_match_start(\"hello_mouse\", \"hello_penguin\"), StrCount::new(6, 6));\n+/// assert_eq!(count_match_start(\"hello_clippy\", \"bye_bugs\"), StrCount::new(0, 0));\n+/// assert_eq!(count_match_start(\"hello_world\", \"hello_world\"), StrCount::new(11, 11));\n+/// assert_eq!(count_match_start(\"T\\u{f6}ffT\\u{f6}ff\", \"T\\u{f6}ff\"), StrCount::new(4, 5));\n+/// ```\n+#[must_use]\n+pub fn count_match_start(str1: &str, str2: &str) -> StrCount {\n+    // (char_index, char1)\n+    let char_count = str1.chars().count();\n+    let iter1 = (0..=char_count).zip(str1.chars());\n+    // (byte_index, char2)\n+    let iter2 = str2.char_indices();\n+\n+    iter1\n+        .zip(iter2)\n+        .take_while(|((_, c1), (_, c2))| c1 == c2)\n+        .last()\n+        .map_or_else(StrCount::default, |((char_index, _), (byte_index, character))| {\n+            StrCount::new(char_index + 1, byte_index + character.len_utf8())\n+        })\n+}\n+\n+/// Returns the number of chars and bytes that match from the end\n+///\n+/// ```\n+/// assert_eq!(count_match_end(\"hello_cat\", \"bye_cat\"), StrCount::new(4, 4));\n+/// assert_eq!(count_match_end(\"if_item_thing\", \"enum_value\"), StrCount::new(0, 0));\n+/// assert_eq!(count_match_end(\"Clippy\", \"Clippy\"), StrCount::new(6, 6));\n+/// assert_eq!(count_match_end(\"MyT\\u{f6}ff\", \"YourT\\u{f6}ff\"), StrCount::new(4, 5));\n+/// ```\n+#[must_use]\n+pub fn count_match_end(str1: &str, str2: &str) -> StrCount {\n+    let char_count = str1.chars().count();\n+    if char_count == 0 {\n+        return StrCount::default();\n+    }\n+\n+    // (char_index, char1)\n+    let iter1 = (0..char_count).rev().zip(str1.chars().rev());\n+    // (byte_index, char2)\n+    let byte_count = str2.len();\n+    let iter2 = str2.char_indices().rev();\n+\n+    iter1\n+        .zip(iter2)\n+        .take_while(|((_, c1), (_, c2))| c1 == c2)\n+        .last()\n+        .map_or_else(StrCount::default, |((char_index, _), (byte_index, _))| {\n+            StrCount::new(char_count - char_index, byte_count - byte_index)\n+        })\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn camel_case_start_full() {\n+        assert_eq!(camel_case_start(\"AbcDef\"), StrIndex::new(0, 0));\n+        assert_eq!(camel_case_start(\"Abc\"), StrIndex::new(0, 0));\n+        assert_eq!(camel_case_start(\"ABcd\"), StrIndex::new(0, 0));\n+        assert_eq!(camel_case_start(\"ABcdEf\"), StrIndex::new(0, 0));\n+        assert_eq!(camel_case_start(\"AabABcd\"), StrIndex::new(0, 0));\n+    }\n+\n+    #[test]\n+    fn camel_case_start_partial() {\n+        assert_eq!(camel_case_start(\"abcDef\"), StrIndex::new(3, 3));\n+        assert_eq!(camel_case_start(\"aDbc\"), StrIndex::new(1, 1));\n+        assert_eq!(camel_case_start(\"aabABcd\"), StrIndex::new(3, 3));\n+        assert_eq!(camel_case_start(\"\\u{f6}\\u{f6}AabABcd\"), StrIndex::new(2, 4));\n+    }\n+\n+    #[test]\n+    fn camel_case_start_not() {\n+        assert_eq!(camel_case_start(\"AbcDef_\"), StrIndex::new(7, 7));\n+        assert_eq!(camel_case_start(\"AbcDD\"), StrIndex::new(5, 5));\n+        assert_eq!(camel_case_start(\"all_small\"), StrIndex::new(9, 9));\n+        assert_eq!(camel_case_start(\"\\u{f6}_all_small\"), StrIndex::new(11, 12));\n+    }\n+\n+    #[test]\n+    fn camel_case_start_caps() {\n+        assert_eq!(camel_case_start(\"ABCD\"), StrIndex::new(4, 4));\n+    }\n+\n+    #[test]\n+    fn camel_case_until_full() {\n+        assert_eq!(camel_case_until(\"AbcDef\"), StrIndex::new(6, 6));\n+        assert_eq!(camel_case_until(\"Abc\"), StrIndex::new(3, 3));\n+        assert_eq!(camel_case_until(\"Abc\\u{f6}\\u{f6}\\u{f6}\"), StrIndex::new(6, 9));\n+    }\n+\n+    #[test]\n+    fn camel_case_until_not() {\n+        assert_eq!(camel_case_until(\"abcDef\"), StrIndex::new(0, 0));\n+        assert_eq!(camel_case_until(\"aDbc\"), StrIndex::new(0, 0));\n+    }\n+\n+    #[test]\n+    fn camel_case_until_partial() {\n+        assert_eq!(camel_case_until(\"AbcDef_\"), StrIndex::new(6, 6));\n+        assert_eq!(camel_case_until(\"CallTypeC\"), StrIndex::new(8, 8));\n+        assert_eq!(camel_case_until(\"AbcDD\"), StrIndex::new(3, 3));\n+        assert_eq!(camel_case_until(\"Abc\\u{f6}\\u{f6}DD\"), StrIndex::new(5, 7));\n+    }\n+\n+    #[test]\n+    fn until_caps() {\n+        assert_eq!(camel_case_until(\"ABCD\"), StrIndex::new(0, 0));\n+    }\n+}"}, {"sha": "8f97a063a9a9f1618a41ef2fdafc9e51b1030575", "filename": "tests/ui/crashes/ice-7869.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/tests%2Fui%2Fcrashes%2Fice-7869.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/tests%2Fui%2Fcrashes%2Fice-7869.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-7869.rs?ref=3ef1f19d60dcad6bc82955ad10d8cdf0351c9800", "patch": "@@ -0,0 +1,7 @@\n+enum Tila {\n+    Ty\u00f6Alkoi,\n+    Ty\u00f6Keskeytyi,\n+    Ty\u00f6Valmis,\n+}\n+\n+fn main() {}"}, {"sha": "4fa9fb27e7659ebb0acbef1778b01d8a8696afd8", "filename": "tests/ui/crashes/ice-7869.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/tests%2Fui%2Fcrashes%2Fice-7869.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/tests%2Fui%2Fcrashes%2Fice-7869.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-7869.stderr?ref=3ef1f19d60dcad6bc82955ad10d8cdf0351c9800", "patch": "@@ -0,0 +1,15 @@\n+error: all variants have the same prefix: `Ty\u00f6`\n+  --> $DIR/ice-7869.rs:1:1\n+   |\n+LL | / enum Tila {\n+LL | |     Ty\u00f6Alkoi,\n+LL | |     Ty\u00f6Keskeytyi,\n+LL | |     Ty\u00f6Valmis,\n+LL | | }\n+   | |_^\n+   |\n+   = note: `-D clippy::enum-variant-names` implied by `-D warnings`\n+   = help: remove the prefixes and use full paths to the variants instead of glob imports\n+\n+error: aborting due to previous error\n+"}, {"sha": "add8a91e26b85a2b9745a73053ff73d418a54cdd", "filename": "tests/ui/enum_variants.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/tests%2Fui%2Fenum_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/tests%2Fui%2Fenum_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fenum_variants.stderr?ref=3ef1f19d60dcad6bc82955ad10d8cdf0351c9800", "patch": "@@ -60,7 +60,7 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: all variants have the same prefix: `With`\n+error: all variants have the same prefix: `WithOut`\n   --> $DIR/enum_variants.rs:81:1\n    |\n LL | / enum Seallll {"}, {"sha": "7e3674ab8c9f2c633094cce82c11d3351ebb8cb8", "filename": "tests/ui/match_ref_pats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/tests%2Fui%2Fmatch_ref_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef1f19d60dcad6bc82955ad10d8cdf0351c9800/tests%2Fui%2Fmatch_ref_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_ref_pats.rs?ref=3ef1f19d60dcad6bc82955ad10d8cdf0351c9800", "patch": "@@ -1,5 +1,5 @@\n #![warn(clippy::match_ref_pats)]\n-#![allow(clippy::equatable_if_let)]\n+#![allow(clippy::equatable_if_let, clippy::enum_variant_names)]\n \n fn ref_pats() {\n     {"}]}