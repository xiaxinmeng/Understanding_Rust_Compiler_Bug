{"sha": "1e1804db1836c268a0e41f05e29be30836913383", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMTgwNGRiMTgzNmMyNjhhMGU0MWYwNWUyOWJlMzA4MzY5MTMzODM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-22T22:26:35Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-23T04:27:08Z"}, "message": "Cleanup.", "tree": {"sha": "c2fcef9bd635e5e6613cf0c7723209a939f8eb13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2fcef9bd635e5e6613cf0c7723209a939f8eb13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e1804db1836c268a0e41f05e29be30836913383", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e1804db1836c268a0e41f05e29be30836913383", "html_url": "https://github.com/rust-lang/rust/commit/1e1804db1836c268a0e41f05e29be30836913383", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e1804db1836c268a0e41f05e29be30836913383/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "167f70a52f0edbc82cedebff7dcacc398eaccf1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/167f70a52f0edbc82cedebff7dcacc398eaccf1d", "html_url": "https://github.com/rust-lang/rust/commit/167f70a52f0edbc82cedebff7dcacc398eaccf1d"}], "stats": {"total": 57, "additions": 17, "deletions": 40}, "files": [{"sha": "1be57d2e8293ff3e18819c331b9a9b21637fb15c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 40, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1e1804db1836c268a0e41f05e29be30836913383/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e1804db1836c268a0e41f05e29be30836913383/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1e1804db1836c268a0e41f05e29be30836913383", "patch": "@@ -1207,16 +1207,14 @@ impl<'a> Parser<'a> {\n                 // eat a matched-delimiter token tree:\n                 let delim = self.expect_open_delim()?;\n                 let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                             SeqSep::none(),\n-                                             |pp| pp.parse_token_tree())?;\n-                let m_ = Mac_ { path: pth, tts: tts };\n-                let m: ast::Mac = codemap::Spanned { node: m_,\n-                                                     span: mk_sp(lo,\n-                                                                 self.last_span.hi) };\n+                                                SeqSep::none(),\n+                                                |pp| pp.parse_token_tree())?;\n                 if delim != token::Brace {\n                     self.expect(&token::Semi)?\n                 }\n-                (keywords::Invalid.ident(), ast::TraitItemKind::Macro(m))\n+\n+                let mac = spanned(lo, self.last_span.hi, Mac_ { path: pth, tts: tts });\n+                (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac))\n             } else {\n                 let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n                     Ok(cua) => cua,\n@@ -1422,9 +1420,8 @@ impl<'a> Parser<'a> {\n             TyKind::Path(Some(qself), path)\n         } else if self.token.is_path_start() {\n             let path = self.parse_path(PathStyle::Type)?;\n-            if self.check(&token::Not) {\n+            if self.eat(&token::Not) {\n                 // MACRO INVOCATION\n-                self.bump();\n                 let delim = self.expect_open_delim()?;\n                 let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                                 SeqSep::none(),\n@@ -2302,21 +2299,14 @@ impl<'a> Parser<'a> {\n                     let pth = self.parse_path(PathStyle::Expr)?;\n \n                     // `!`, as an operator, is prefix, so we know this isn't that\n-                    if self.check(&token::Not) {\n+                    if self.eat(&token::Not) {\n                         // MACRO INVOCATION expression\n-                        self.bump();\n-\n                         let delim = self.expect_open_delim()?;\n-                        let tts = self.parse_seq_to_end(\n-                            &token::CloseDelim(delim),\n-                            SeqSep::none(),\n-                            |p| p.parse_token_tree())?;\n+                        let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                                        SeqSep::none(),\n+                                                        |p| p.parse_token_tree())?;\n                         let hi = self.last_span.hi;\n-\n-                        return Ok(self.mk_mac_expr(lo,\n-                                                   hi,\n-                                                   Mac_ { path: pth, tts: tts },\n-                                                   attrs));\n+                        return Ok(self.mk_mac_expr(lo, hi, Mac_ { path: pth, tts: tts }, attrs));\n                     }\n                     if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n@@ -4880,14 +4870,12 @@ impl<'a> Parser<'a> {\n             let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                             SeqSep::none(),\n                                             |p| p.parse_token_tree())?;\n-            let m_ = Mac_ { path: pth, tts: tts };\n-            let m: ast::Mac = codemap::Spanned { node: m_,\n-                                                    span: mk_sp(lo,\n-                                                                self.last_span.hi) };\n             if delim != token::Brace {\n                 self.expect(&token::Semi)?\n             }\n-            Ok((keywords::Invalid.ident(), vec![], ast::ImplItemKind::Macro(m)))\n+\n+            let mac = spanned(lo, self.last_span.hi, Mac_ { path: pth, tts: tts });\n+            Ok((keywords::Invalid.ident(), vec![], ast::ImplItemKind::Macro(mac)))\n         } else {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n@@ -6009,12 +5997,6 @@ impl<'a> Parser<'a> {\n             let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                             SeqSep::none(),\n                                             |p| p.parse_token_tree())?;\n-            // single-variant-enum... :\n-            let m = Mac_ { path: pth, tts: tts };\n-            let m: ast::Mac = codemap::Spanned { node: m,\n-                                                 span: mk_sp(mac_lo,\n-                                                             self.last_span.hi) };\n-\n             if delim != token::Brace {\n                 if !self.eat(&token::Semi) {\n                     let last_span = self.last_span;\n@@ -6025,14 +6007,9 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n-            let item_ = ItemKind::Mac(m);\n-            let last_span = self.last_span;\n-            let item = self.mk_item(lo,\n-                                    last_span.hi,\n-                                    id,\n-                                    item_,\n-                                    visibility,\n-                                    attrs);\n+            let hi = self.last_span.hi;\n+            let mac = spanned(mac_lo, hi, Mac_ { path: pth, tts: tts });\n+            let item = self.mk_item(lo, hi, id, ItemKind::Mac(mac), visibility, attrs);\n             return Ok(Some(item));\n         }\n "}]}