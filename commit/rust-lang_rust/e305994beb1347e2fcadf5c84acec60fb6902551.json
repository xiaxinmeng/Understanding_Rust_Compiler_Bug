{"sha": "e305994beb1347e2fcadf5c84acec60fb6902551", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMDU5OTRiZWIxMzQ3ZTJmY2FkZjVjODRhY2VjNjBmYjY5MDI1NTE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-03-15T23:09:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-30T04:15:19Z"}, "message": "proc_macro: introduce a \"bridge\" between clients (proc macros) and servers (compiler front-ends).", "tree": {"sha": "fa3cc47ac732137a158714c65f2e758667ef7e8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa3cc47ac732137a158714c65f2e758667ef7e8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e305994beb1347e2fcadf5c84acec60fb6902551", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e305994beb1347e2fcadf5c84acec60fb6902551", "html_url": "https://github.com/rust-lang/rust/commit/e305994beb1347e2fcadf5c84acec60fb6902551", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e305994beb1347e2fcadf5c84acec60fb6902551/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e90a12a8a95933604a8b609197fce61bb24a38c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e90a12a8a95933604a8b609197fce61bb24a38c", "html_url": "https://github.com/rust-lang/rust/commit/3e90a12a8a95933604a8b609197fce61bb24a38c"}], "stats": {"total": 3519, "additions": 2893, "deletions": 626}, "files": [{"sha": "f228841c1e80f6aa1c6ba9715ed407a519f5b0d2", "filename": "src/libproc_macro/bridge/buffer.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -0,0 +1,170 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Buffer management for same-process client<->server communication.\n+\n+use std::io::{self, Write};\n+use std::mem;\n+use std::ops::{Deref, DerefMut};\n+use std::slice;\n+\n+#[repr(C)]\n+struct Slice<'a, T: 'a> {\n+    data: &'a [T; 0],\n+    len: usize,\n+}\n+\n+unsafe impl<'a, T: Sync> Sync for Slice<'a, T> {}\n+unsafe impl<'a, T: Sync> Send for Slice<'a, T> {}\n+\n+impl<T> Copy for Slice<'a, T> {}\n+impl<T> Clone for Slice<'a, T> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<T> From<&'a [T]> for Slice<'a, T> {\n+    fn from(xs: &'a [T]) -> Self {\n+        Slice {\n+            data: unsafe { &*(xs.as_ptr() as *const [T; 0]) },\n+            len: xs.len(),\n+        }\n+    }\n+}\n+\n+impl<T> Deref for Slice<'a, T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.data.as_ptr(), self.len) }\n+    }\n+}\n+\n+#[repr(C)]\n+pub struct Buffer<T: Copy> {\n+    data: *mut T,\n+    len: usize,\n+    capacity: usize,\n+    extend_from_slice: extern \"C\" fn(Buffer<T>, Slice<T>) -> Buffer<T>,\n+    drop: extern \"C\" fn(Buffer<T>),\n+}\n+\n+unsafe impl<T: Copy + Sync> Sync for Buffer<T> {}\n+unsafe impl<T: Copy + Send> Send for Buffer<T> {}\n+\n+impl<T: Copy> Default for Buffer<T> {\n+    fn default() -> Self {\n+        Self::from(vec![])\n+    }\n+}\n+\n+impl<T: Copy> Deref for Buffer<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.data as *const T, self.len) }\n+    }\n+}\n+\n+impl<T: Copy> DerefMut for Buffer<T> {\n+    fn deref_mut(&mut self) -> &mut [T] {\n+        unsafe { slice::from_raw_parts_mut(self.data, self.len) }\n+    }\n+}\n+\n+impl<T: Copy> Buffer<T> {\n+    pub(super) fn new() -> Self {\n+        Self::default()\n+    }\n+\n+    pub(super) fn clear(&mut self) {\n+        self.len = 0;\n+    }\n+\n+    pub(super) fn take(&mut self) -> Self {\n+        mem::replace(self, Self::default())\n+    }\n+\n+    pub(super) fn extend_from_slice(&mut self, xs: &[T]) {\n+        // Fast path to avoid going through an FFI call.\n+        if let Some(final_len) = self.len.checked_add(xs.len()) {\n+            if final_len <= self.capacity {\n+                let dst = unsafe { slice::from_raw_parts_mut(self.data, self.capacity) };\n+                dst[self.len..][..xs.len()].copy_from_slice(xs);\n+                self.len = final_len;\n+                return;\n+            }\n+        }\n+        let b = self.take();\n+        *self = (b.extend_from_slice)(b, Slice::from(xs));\n+    }\n+}\n+\n+impl Write for Buffer<u8> {\n+    fn write(&mut self, xs: &[u8]) -> io::Result<usize> {\n+        self.extend_from_slice(xs);\n+        Ok(xs.len())\n+    }\n+\n+    fn write_all(&mut self, xs: &[u8]) -> io::Result<()> {\n+        self.extend_from_slice(xs);\n+        Ok(())\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl<T: Copy> Drop for Buffer<T> {\n+    fn drop(&mut self) {\n+        let b = self.take();\n+        (b.drop)(b);\n+    }\n+}\n+\n+impl<T: Copy> From<Vec<T>> for Buffer<T> {\n+    fn from(mut v: Vec<T>) -> Self {\n+        let (data, len, capacity) = (v.as_mut_ptr(), v.len(), v.capacity());\n+        mem::forget(v);\n+\n+        // This utility function is nested in here because it can *only*\n+        // be safely called on `Buffer`s created by *this* `proc_macro`.\n+        fn to_vec<T: Copy>(b: Buffer<T>) -> Vec<T> {\n+            unsafe {\n+                let Buffer {\n+                    data,\n+                    len,\n+                    capacity,\n+                    ..\n+                } = b;\n+                mem::forget(b);\n+                Vec::from_raw_parts(data, len, capacity)\n+            }\n+        }\n+\n+        extern \"C\" fn extend_from_slice<T: Copy>(b: Buffer<T>, xs: Slice<T>) -> Buffer<T> {\n+            let mut v = to_vec(b);\n+            v.extend_from_slice(&xs);\n+            Buffer::from(v)\n+        }\n+\n+        extern \"C\" fn drop<T: Copy>(b: Buffer<T>) {\n+            mem::drop(to_vec(b));\n+        }\n+\n+        Buffer {\n+            data,\n+            len,\n+            capacity,\n+            extend_from_slice,\n+            drop,\n+        }\n+    }\n+}"}, {"sha": "ed27df4496256aa12f51afc5073a7c8afa3f6025", "filename": "src/libproc_macro/bridge/client.rs", "status": "added", "additions": 504, "deletions": 0, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -0,0 +1,504 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Client-side types.\n+\n+use super::*;\n+\n+macro_rules! define_handles {\n+    (\n+        'owned: $($oty:ident,)*\n+        'interned: $($ity:ident,)*\n+    ) => {\n+        #[repr(C)]\n+        #[allow(non_snake_case)]\n+        pub struct HandleCounters {\n+            $($oty: AtomicUsize,)*\n+            $($ity: AtomicUsize,)*\n+        }\n+\n+        impl HandleCounters {\n+            // FIXME(#53451) public to work around `Cannot create local mono-item` ICE.\n+            pub extern \"C\" fn get() -> &'static Self {\n+                static COUNTERS: HandleCounters = HandleCounters {\n+                    $($oty: AtomicUsize::new(1),)*\n+                    $($ity: AtomicUsize::new(1),)*\n+                };\n+                &COUNTERS\n+            }\n+        }\n+\n+        // FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n+        #[repr(C)]\n+        #[allow(non_snake_case)]\n+        pub(super) struct HandleStore<S: server::Types> {\n+            $($oty: handle::OwnedStore<S::$oty>,)*\n+            $($ity: handle::InternedStore<S::$ity>,)*\n+        }\n+\n+        impl<S: server::Types> HandleStore<S> {\n+            pub(super) fn new(handle_counters: &'static HandleCounters) -> Self {\n+                HandleStore {\n+                    $($oty: handle::OwnedStore::new(&handle_counters.$oty),)*\n+                    $($ity: handle::InternedStore::new(&handle_counters.$ity),)*\n+                }\n+            }\n+        }\n+\n+        $(\n+            #[repr(C)]\n+            pub(crate) struct $oty(handle::Handle);\n+            impl !Send for $oty {}\n+            impl !Sync for $oty {}\n+\n+            // Forward `Drop::drop` to the inherent `drop` method.\n+            impl Drop for $oty {\n+                fn drop(&mut self) {\n+                    $oty(self.0).drop();\n+                }\n+            }\n+\n+            impl<S> Encode<S> for $oty {\n+                fn encode(self, w: &mut Writer, s: &mut S) {\n+                    let handle = self.0;\n+                    mem::forget(self);\n+                    handle.encode(w, s);\n+                }\n+            }\n+\n+            impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n+                for Marked<S::$oty, $oty>\n+            {\n+                fn decode(r: &mut Reader, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                    s.$oty.take(handle::Handle::decode(r, &mut ()))\n+                }\n+            }\n+\n+            impl<S> Encode<S> for &$oty {\n+                fn encode(self, w: &mut Writer, s: &mut S) {\n+                    self.0.encode(w, s);\n+                }\n+            }\n+\n+            impl<S: server::Types> Decode<'_, 's, HandleStore<server::MarkedTypes<S>>>\n+                for &'s Marked<S::$oty, $oty>\n+            {\n+                fn decode(r: &mut Reader, s: &'s HandleStore<server::MarkedTypes<S>>) -> Self {\n+                    &s.$oty[handle::Handle::decode(r, &mut ())]\n+                }\n+            }\n+\n+            impl<S> Encode<S> for &mut $oty {\n+                fn encode(self, w: &mut Writer, s: &mut S) {\n+                    self.0.encode(w, s);\n+                }\n+            }\n+\n+            impl<S: server::Types> DecodeMut<'_, 's, HandleStore<server::MarkedTypes<S>>>\n+                for &'s mut Marked<S::$oty, $oty>\n+            {\n+                fn decode(r: &mut Reader, s: &'s mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                    &mut s.$oty[handle::Handle::decode(r, &mut ())]\n+                }\n+            }\n+\n+            impl<S: server::Types> Encode<HandleStore<server::MarkedTypes<S>>>\n+                for Marked<S::$oty, $oty>\n+            {\n+                fn encode(self, w: &mut Writer, s: &mut HandleStore<server::MarkedTypes<S>>) {\n+                    s.$oty.alloc(self).encode(w, s);\n+                }\n+            }\n+\n+            impl<S> DecodeMut<'_, '_, S> for $oty {\n+                fn decode(r: &mut Reader, s: &mut S) -> Self {\n+                    $oty(handle::Handle::decode(r, s))\n+                }\n+            }\n+        )*\n+\n+        $(\n+            #[repr(C)]\n+            #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+            pub(crate) struct $ity(handle::Handle);\n+            impl !Send for $ity {}\n+            impl !Sync for $ity {}\n+\n+            impl<S> Encode<S> for $ity {\n+                fn encode(self, w: &mut Writer, s: &mut S) {\n+                    self.0.encode(w, s);\n+                }\n+            }\n+\n+            impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n+                for Marked<S::$ity, $ity>\n+            {\n+                fn decode(r: &mut Reader, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                    s.$ity.copy(handle::Handle::decode(r, &mut ()))\n+                }\n+            }\n+\n+            impl<S: server::Types> Encode<HandleStore<server::MarkedTypes<S>>>\n+                for Marked<S::$ity, $ity>\n+            {\n+                fn encode(self, w: &mut Writer, s: &mut HandleStore<server::MarkedTypes<S>>) {\n+                    s.$ity.alloc(self).encode(w, s);\n+                }\n+            }\n+\n+            impl<S> DecodeMut<'_, '_, S> for $ity {\n+                fn decode(r: &mut Reader, s: &mut S) -> Self {\n+                    $ity(handle::Handle::decode(r, s))\n+                }\n+            }\n+        )*\n+    }\n+}\n+define_handles! {\n+    'owned:\n+    TokenStream,\n+    TokenStreamBuilder,\n+    TokenStreamIter,\n+    Group,\n+    Literal,\n+    SourceFile,\n+    MultiSpan,\n+    Diagnostic,\n+\n+    'interned:\n+    Punct,\n+    Ident,\n+    Span,\n+}\n+\n+// FIXME(eddyb) generate these impls by pattern-matching on the\n+// names of methods - also could use the presence of `fn drop`\n+// to distinguish between 'owned and 'interned, above.\n+// Alternatively, special 'modes\" could be listed of types in with_api\n+// instead of pattern matching on methods, here and in server decl.\n+\n+impl Clone for TokenStream {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl Clone for TokenStreamIter {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl Clone for Group {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl Clone for Literal {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+// FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n+impl fmt::Debug for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(&self.debug())\n+    }\n+}\n+\n+impl Clone for SourceFile {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl fmt::Debug for Span {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(&self.debug())\n+    }\n+}\n+\n+macro_rules! define_client_side {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)*) $(-> $ret_ty:ty)*;)*\n+    }),* $(,)*) => {\n+        $(impl $name {\n+            $(pub(crate) fn $method($($arg: $arg_ty),*) $(-> $ret_ty)* {\n+                Bridge::with(|bridge| {\n+                    let mut b = bridge.cached_buffer.take();\n+\n+                    b.clear();\n+                    api_tags::Method::$name(api_tags::$name::$method).encode(&mut b, &mut ());\n+                    reverse_encode!(b; $($arg),*);\n+\n+                    b = bridge.dispatch.call(b);\n+\n+                    let r = Result::<_, PanicMessage>::decode(&mut &b[..], &mut ());\n+\n+                    bridge.cached_buffer = b;\n+\n+                    r.unwrap_or_else(|e| panic::resume_unwind(e.into()))\n+                })\n+            })*\n+        })*\n+    }\n+}\n+with_api!(self, self, define_client_side);\n+\n+enum BridgeState<'a> {\n+    /// No server is currently connected to this client.\n+    NotConnected,\n+\n+    /// A server is connected and available for requests.\n+    Connected(Bridge<'a>),\n+\n+    /// Access to the bridge is being exclusively acquired\n+    /// (e.g. during `BridgeState::with`).\n+    InUse,\n+}\n+\n+enum BridgeStateL {}\n+\n+impl<'a> scoped_cell::ApplyL<'a> for BridgeStateL {\n+    type Out = BridgeState<'a>;\n+}\n+\n+thread_local! {\n+    static BRIDGE_STATE: scoped_cell::ScopedCell<BridgeStateL> =\n+        scoped_cell::ScopedCell::new(BridgeState::NotConnected);\n+}\n+\n+impl BridgeState<'_> {\n+    /// Take exclusive control of the thread-local\n+    /// `BridgeState`, and pass it to `f`, mutably.\n+    /// The state will be restored after `f` exits, even\n+    /// by panic, including modifications made to it by `f`.\n+    ///\n+    /// NB: while `f` is running, the thread-local state\n+    /// is `BridgeState::InUse`.\n+    fn with<R>(f: impl FnOnce(&mut BridgeState) -> R) -> R {\n+        BRIDGE_STATE.with(|state| {\n+            state.replace(BridgeState::InUse, |mut state| {\n+                // FIXME(#52812) pass `f` directly to `replace` when `RefMutL` is gone\n+                f(&mut *state)\n+            })\n+        })\n+    }\n+}\n+\n+impl Bridge<'_> {\n+    fn enter<R>(self, f: impl FnOnce() -> R) -> R {\n+        // Hide the default panic output within `proc_macro` expansions.\n+        // NB. the server can't do this because it may use a different libstd.\n+        static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n+        HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n+            let prev = panic::take_hook();\n+            panic::set_hook(Box::new(move |info| {\n+                let hide = BridgeState::with(|state| match state {\n+                    BridgeState::NotConnected => false,\n+                    BridgeState::Connected(_) | BridgeState::InUse => true,\n+                });\n+                if !hide {\n+                    prev(info)\n+                }\n+            }));\n+        });\n+\n+        BRIDGE_STATE.with(|state| state.set(BridgeState::Connected(self), f))\n+    }\n+\n+    fn with<R>(f: impl FnOnce(&mut Bridge) -> R) -> R {\n+        BridgeState::with(|state| match state {\n+            BridgeState::NotConnected => {\n+                panic!(\"procedural macro API is used outside of a procedural macro\");\n+            }\n+            BridgeState::InUse => {\n+                panic!(\"procedural macro API is used while it's already in use\");\n+            }\n+            BridgeState::Connected(bridge) => f(bridge),\n+        })\n+    }\n+}\n+\n+/// A client-side \"global object\" (usually a function pointer),\n+/// which may be using a different `proc_macro` from the one\n+/// used by the server, but can be interacted with compatibly.\n+///\n+/// NB: `F` must have FFI-friendly memory layout (e.g. a pointer).\n+/// The call ABI of function pointers used for `F` doesn't\n+/// need to match between server and client, since it's only\n+/// passed between them and (eventually) called by the client.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct Client<F> {\n+    pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n+    pub(super) run: extern \"C\" fn(Bridge, F) -> Buffer<u8>,\n+    pub(super) f: F,\n+}\n+\n+// FIXME(#53451) public to work around `Cannot create local mono-item` ICE,\n+// affecting not only the function itself, but also the `BridgeState` `thread_local!`.\n+pub extern \"C\" fn __run_expand1(\n+    mut bridge: Bridge,\n+    f: fn(::TokenStream) -> ::TokenStream,\n+) -> Buffer<u8> {\n+    // The initial `cached_buffer` contains the input.\n+    let mut b = bridge.cached_buffer.take();\n+\n+    panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+        bridge.enter(|| {\n+            let reader = &mut &b[..];\n+            let input = TokenStream::decode(reader, &mut ());\n+\n+            // Put the `cached_buffer` back in the `Bridge`, for requests.\n+            Bridge::with(|bridge| bridge.cached_buffer = b.take());\n+\n+            let output = f(::TokenStream(input)).0;\n+\n+            // Take the `cached_buffer` back out, for the output value.\n+            b = Bridge::with(|bridge| bridge.cached_buffer.take());\n+\n+            // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n+            // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n+            // having handles outside the `bridge.enter(|| ...)` scope, and\n+            // to catch panics that could happen while encoding the success.\n+            //\n+            // Note that panics should be impossible beyond this point, but\n+            // this is defensively trying to avoid any accidental panicking\n+            // reaching the `extern \"C\"` (which should `abort` but may not\n+            // at the moment, so this is also potentially preventing UB).\n+            b.clear();\n+            Ok::<_, ()>(output).encode(&mut b, &mut ());\n+        })\n+    }))\n+    .map_err(PanicMessage::from)\n+    .unwrap_or_else(|e| {\n+        b.clear();\n+        Err::<(), _>(e).encode(&mut b, &mut ());\n+    });\n+    b\n+}\n+\n+impl Client<fn(::TokenStream) -> ::TokenStream> {\n+    pub const fn expand1(f: fn(::TokenStream) -> ::TokenStream) -> Self {\n+        Client {\n+            get_handle_counters: HandleCounters::get,\n+            run: __run_expand1,\n+            f,\n+        }\n+    }\n+}\n+\n+// FIXME(#53451) public to work around `Cannot create local mono-item` ICE,\n+// affecting not only the function itself, but also the `BridgeState` `thread_local!`.\n+pub extern \"C\" fn __run_expand2(\n+    mut bridge: Bridge,\n+    f: fn(::TokenStream, ::TokenStream) -> ::TokenStream,\n+) -> Buffer<u8> {\n+    // The initial `cached_buffer` contains the input.\n+    let mut b = bridge.cached_buffer.take();\n+\n+    panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+        bridge.enter(|| {\n+            let reader = &mut &b[..];\n+            let input = TokenStream::decode(reader, &mut ());\n+            let input2 = TokenStream::decode(reader, &mut ());\n+\n+            // Put the `cached_buffer` back in the `Bridge`, for requests.\n+            Bridge::with(|bridge| bridge.cached_buffer = b.take());\n+\n+            let output = f(::TokenStream(input), ::TokenStream(input2)).0;\n+\n+            // Take the `cached_buffer` back out, for the output value.\n+            b = Bridge::with(|bridge| bridge.cached_buffer.take());\n+\n+            // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n+            // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n+            // having handles outside the `bridge.enter(|| ...)` scope, and\n+            // to catch panics that could happen while encoding the success.\n+            //\n+            // Note that panics should be impossible beyond this point, but\n+            // this is defensively trying to avoid any accidental panicking\n+            // reaching the `extern \"C\"` (which should `abort` but may not\n+            // at the moment, so this is also potentially preventing UB).\n+            b.clear();\n+            Ok::<_, ()>(output).encode(&mut b, &mut ());\n+        })\n+    }))\n+    .map_err(PanicMessage::from)\n+    .unwrap_or_else(|e| {\n+        b.clear();\n+        Err::<(), _>(e).encode(&mut b, &mut ());\n+    });\n+    b\n+}\n+\n+impl Client<fn(::TokenStream, ::TokenStream) -> ::TokenStream> {\n+    pub const fn expand2(f: fn(::TokenStream, ::TokenStream) -> ::TokenStream) -> Self {\n+        Client {\n+            get_handle_counters: HandleCounters::get,\n+            run: __run_expand2,\n+            f,\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum ProcMacro {\n+    CustomDerive {\n+        trait_name: &'static str,\n+        attributes: &'static [&'static str],\n+        client: Client<fn(::TokenStream) -> ::TokenStream>,\n+    },\n+\n+    Attr {\n+        name: &'static str,\n+        client: Client<fn(::TokenStream, ::TokenStream) -> ::TokenStream>,\n+    },\n+\n+    Bang {\n+        name: &'static str,\n+        client: Client<fn(::TokenStream) -> ::TokenStream>,\n+    },\n+}\n+\n+impl ProcMacro {\n+    pub const fn custom_derive(\n+        trait_name: &'static str,\n+        attributes: &'static [&'static str],\n+        expand: fn(::TokenStream) -> ::TokenStream,\n+    ) -> Self {\n+        ProcMacro::CustomDerive {\n+            trait_name,\n+            attributes,\n+            client: Client::expand1(expand),\n+        }\n+    }\n+\n+    pub const fn attr(\n+        name: &'static str,\n+        expand: fn(::TokenStream, ::TokenStream) -> ::TokenStream,\n+    ) -> Self {\n+        ProcMacro::Attr {\n+            name,\n+            client: Client::expand2(expand),\n+        }\n+    }\n+\n+    pub const fn bang(name: &'static str, expand: fn(::TokenStream) -> ::TokenStream) -> Self {\n+        ProcMacro::Bang {\n+            name,\n+            client: Client::expand1(expand),\n+        }\n+    }\n+}"}, {"sha": "92fe7baae097c5c882cdae043d1331f6d50fc783", "filename": "src/libproc_macro/bridge/closure.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclosure.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Closure type (equivalent to `&mut dyn FnMut(A) -> R`) that's `repr(C)`.\n+\n+#[repr(C)]\n+pub struct Closure<'a, A, R> {\n+    call: unsafe extern \"C\" fn(&mut Env, A) -> R,\n+    env: &'a mut Env,\n+}\n+\n+extern \"C\" {\n+    type Env;\n+}\n+\n+impl<'a, A, R> !Sync for Closure<'a, A, R> {}\n+impl<'a, A, R> !Send for Closure<'a, A, R> {}\n+\n+impl<'a, A, R, F: FnMut(A) -> R> From<&'a mut F> for Closure<'a, A, R> {\n+    fn from(f: &'a mut F) -> Self {\n+        unsafe extern \"C\" fn call<A, R, F: FnMut(A) -> R>(env: &mut Env, arg: A) -> R {\n+            (*(env as *mut _ as *mut F))(arg)\n+        }\n+        Closure {\n+            call: call::<A, R, F>,\n+            env: unsafe { &mut *(f as *mut _ as *mut Env) },\n+        }\n+    }\n+}\n+\n+impl<'a, A, R> Closure<'a, A, R> {\n+    pub fn call(&mut self, arg: A) -> R {\n+        unsafe { (self.call)(self.env, arg) }\n+    }\n+}"}, {"sha": "5c91a1408a42f5b77ca0b7e6438887459c9b0e4e", "filename": "src/libproc_macro/bridge/handle.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fhandle.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Server-side handles and storage for per-handle data.\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+use std::num::NonZeroU32;\n+use std::ops::{Index, IndexMut};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+pub(super) type Handle = NonZeroU32;\n+\n+pub(super) struct OwnedStore<T: 'static> {\n+    counter: &'static AtomicUsize,\n+    data: BTreeMap<Handle, T>,\n+}\n+\n+impl<T> OwnedStore<T> {\n+    pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n+        // Ensure the handle counter isn't 0, which would panic later,\n+        // when `NonZeroU32::new` (aka `Handle::new`) is called in `alloc`.\n+        assert_ne!(counter.load(Ordering::SeqCst), 0);\n+\n+        OwnedStore {\n+            counter,\n+            data: BTreeMap::new(),\n+        }\n+    }\n+}\n+\n+impl<T> OwnedStore<T> {\n+    pub(super) fn alloc(&mut self, x: T) -> Handle {\n+        let counter = self.counter.fetch_add(1, Ordering::SeqCst);\n+        let handle = Handle::new(counter as u32).expect(\"`proc_macro` handle counter overflowed\");\n+        assert!(self.data.insert(handle, x).is_none());\n+        handle\n+    }\n+\n+    pub(super) fn take(&mut self, h: Handle) -> T {\n+        self.data\n+            .remove(&h)\n+            .expect(\"use-after-free in `proc_macro` handle\")\n+    }\n+}\n+\n+impl<T> Index<Handle> for OwnedStore<T> {\n+    type Output = T;\n+    fn index(&self, h: Handle) -> &T {\n+        self.data\n+            .get(&h)\n+            .expect(\"use-after-free in `proc_macro` handle\")\n+    }\n+}\n+\n+impl<T> IndexMut<Handle> for OwnedStore<T> {\n+    fn index_mut(&mut self, h: Handle) -> &mut T {\n+        self.data\n+            .get_mut(&h)\n+            .expect(\"use-after-free in `proc_macro` handle\")\n+    }\n+}\n+\n+pub(super) struct InternedStore<T: 'static> {\n+    owned: OwnedStore<T>,\n+    interner: HashMap<T, Handle>,\n+}\n+\n+impl<T: Copy + Eq + Hash> InternedStore<T> {\n+    pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n+        InternedStore {\n+            owned: OwnedStore::new(counter),\n+            interner: HashMap::new(),\n+        }\n+    }\n+\n+    pub(super) fn alloc(&mut self, x: T) -> Handle {\n+        let owned = &mut self.owned;\n+        *self.interner.entry(x).or_insert_with(|| owned.alloc(x))\n+    }\n+\n+    pub(super) fn copy(&mut self, h: Handle) -> T {\n+        self.owned[h]\n+    }\n+}"}, {"sha": "f03c63fc04c8146800f6b2a133a9d64bd67e975a", "filename": "src/libproc_macro/bridge/mod.rs", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fmod.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -0,0 +1,413 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Internal interface for communicating between a `proc_macro` client\n+//! (a proc macro crate) and a `proc_macro` server (a compiler front-end).\n+//!\n+//! Serialization (with C ABI buffers) and unique integer handles are employed\n+//! to allow safely interfacing between two copies of `proc_macro` built\n+//! (from the same source) by different compilers with potentially mismatching\n+//! Rust ABIs (e.g. stage0/bin/rustc vs stage1/bin/rustc during bootstrap).\n+\n+#![deny(unsafe_code)]\n+\n+use std::fmt;\n+use std::hash::Hash;\n+use std::marker;\n+use std::mem;\n+use std::ops::Bound;\n+use std::panic;\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::Once;\n+use std::thread;\n+use {Delimiter, Level, LineColumn, Spacing};\n+\n+/// Higher-order macro describing the server RPC API, allowing automatic\n+/// generation of type-safe Rust APIs, both client-side and server-side.\n+///\n+/// `with_api!(MySelf, my_self, my_macro)` expands to:\n+/// ```rust,ignore (pseudo-code)\n+/// my_macro! {\n+///     // ...\n+///     Literal {\n+///         // ...\n+///         fn character(ch: char) -> MySelf::Literal;\n+///         // ...\n+///         fn span(my_self: &MySelf::Literal) -> MySelf::Span;\n+///         fn set_span(my_self: &mut MySelf::Literal, span: MySelf::Span);\n+///     },\n+///     // ...\n+/// }\n+/// ```\n+///\n+/// The first two arguments serve to customize the arguments names\n+/// and argument/return types, to enable several different usecases:\n+///\n+/// If `my_self` is just `self`, then each `fn` signature can be used\n+/// as-is for a method. If it's anything else (`self_` in practice),\n+/// then the signatures don't have a special `self` argument, and\n+/// can, therefore, have a different one introduced.\n+///\n+/// If `MySelf` is just `Self`, then the types are only valid inside\n+/// a trait or a trait impl, where the trait has associated types\n+/// for each of the API types. If non-associated types are desired,\n+/// a module name (`self` in practice) can be used instead of `Self`.\n+macro_rules! with_api {\n+    ($S:ident, $self:ident, $m:ident) => {\n+        $m! {\n+            TokenStream {\n+                fn drop($self: $S::TokenStream);\n+                fn clone($self: &$S::TokenStream) -> $S::TokenStream;\n+                fn new() -> $S::TokenStream;\n+                fn is_empty($self: &$S::TokenStream) -> bool;\n+                fn from_str(src: &str) -> $S::TokenStream;\n+                fn to_string($self: &$S::TokenStream) -> String;\n+                fn from_token_tree(\n+                    tree: TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>,\n+                ) -> $S::TokenStream;\n+                fn into_iter($self: $S::TokenStream) -> $S::TokenStreamIter;\n+            },\n+            TokenStreamBuilder {\n+                fn drop($self: $S::TokenStreamBuilder);\n+                fn new() -> $S::TokenStreamBuilder;\n+                fn push($self: &mut $S::TokenStreamBuilder, stream: $S::TokenStream);\n+                fn build($self: $S::TokenStreamBuilder) -> $S::TokenStream;\n+            },\n+            TokenStreamIter {\n+                fn drop($self: $S::TokenStreamIter);\n+                fn clone($self: &$S::TokenStreamIter) -> $S::TokenStreamIter;\n+                fn next(\n+                    $self: &mut $S::TokenStreamIter,\n+                ) -> Option<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>;\n+            },\n+            Group {\n+                fn drop($self: $S::Group);\n+                fn clone($self: &$S::Group) -> $S::Group;\n+                fn new(delimiter: Delimiter, stream: $S::TokenStream) -> $S::Group;\n+                fn delimiter($self: &$S::Group) -> Delimiter;\n+                fn stream($self: &$S::Group) -> $S::TokenStream;\n+                fn span($self: &$S::Group) -> $S::Span;\n+                fn span_open($self: &$S::Group) -> $S::Span;\n+                fn span_close($self: &$S::Group) -> $S::Span;\n+                fn set_span($self: &mut $S::Group, span: $S::Span);\n+            },\n+            Punct {\n+                fn new(ch: char, spacing: Spacing) -> $S::Punct;\n+                fn as_char($self: $S::Punct) -> char;\n+                fn spacing($self: $S::Punct) -> Spacing;\n+                fn span($self: $S::Punct) -> $S::Span;\n+                fn with_span($self: $S::Punct, span: $S::Span) -> $S::Punct;\n+            },\n+            Ident {\n+                fn new(string: &str, span: $S::Span, is_raw: bool) -> $S::Ident;\n+                fn span($self: $S::Ident) -> $S::Span;\n+                fn with_span($self: $S::Ident, span: $S::Span) -> $S::Ident;\n+            },\n+            Literal {\n+                fn drop($self: $S::Literal);\n+                fn clone($self: &$S::Literal) -> $S::Literal;\n+                // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n+                fn debug($self: &$S::Literal) -> String;\n+                fn integer(n: &str) -> $S::Literal;\n+                fn typed_integer(n: &str, kind: &str) -> $S::Literal;\n+                fn float(n: &str) -> $S::Literal;\n+                fn f32(n: &str) -> $S::Literal;\n+                fn f64(n: &str) -> $S::Literal;\n+                fn string(string: &str) -> $S::Literal;\n+                fn character(ch: char) -> $S::Literal;\n+                fn byte_string(bytes: &[u8]) -> $S::Literal;\n+                fn span($self: &$S::Literal) -> $S::Span;\n+                fn set_span($self: &mut $S::Literal, span: $S::Span);\n+                fn subspan(\n+                    $self: &$S::Literal,\n+                    start: Bound<usize>,\n+                    end: Bound<usize>,\n+                ) -> Option<$S::Span>;\n+            },\n+            SourceFile {\n+                fn drop($self: $S::SourceFile);\n+                fn clone($self: &$S::SourceFile) -> $S::SourceFile;\n+                fn eq($self: &$S::SourceFile, other: &$S::SourceFile) -> bool;\n+                fn path($self: &$S::SourceFile) -> String;\n+                fn is_real($self: &$S::SourceFile) -> bool;\n+            },\n+            MultiSpan {\n+                fn drop($self: $S::MultiSpan);\n+                fn new() -> $S::MultiSpan;\n+                fn push($self: &mut $S::MultiSpan, span: $S::Span);\n+            },\n+            Diagnostic {\n+                fn drop($self: $S::Diagnostic);\n+                fn new(level: Level, msg: &str, span: $S::MultiSpan) -> $S::Diagnostic;\n+                fn sub(\n+                    $self: &mut $S::Diagnostic,\n+                    level: Level,\n+                    msg: &str,\n+                    span: $S::MultiSpan,\n+                );\n+                fn emit($self: $S::Diagnostic);\n+            },\n+            Span {\n+                fn debug($self: $S::Span) -> String;\n+                fn def_site() -> $S::Span;\n+                fn call_site() -> $S::Span;\n+                fn source_file($self: $S::Span) -> $S::SourceFile;\n+                fn parent($self: $S::Span) -> Option<$S::Span>;\n+                fn source($self: $S::Span) -> $S::Span;\n+                fn start($self: $S::Span) -> LineColumn;\n+                fn end($self: $S::Span) -> LineColumn;\n+                fn join($self: $S::Span, other: $S::Span) -> Option<$S::Span>;\n+                fn resolved_at($self: $S::Span, at: $S::Span) -> $S::Span;\n+            },\n+        }\n+    };\n+}\n+\n+// FIXME(eddyb) this calls `encode` for each argument, but in reverse,\n+// to avoid borrow conflicts from borrows started by `&mut` arguments.\n+macro_rules! reverse_encode {\n+    ($writer:ident;) => {};\n+    ($writer:ident; $first:ident $(, $rest:ident)*) => {\n+        reverse_encode!($writer; $($rest),*);\n+        $first.encode(&mut $writer, &mut ());\n+    }\n+}\n+\n+// FIXME(eddyb) this calls `decode` for each argument, but in reverse,\n+// to avoid borrow conflicts from borrows started by `&mut` arguments.\n+macro_rules! reverse_decode {\n+    ($reader:ident, $s:ident;) => {};\n+    ($reader:ident, $s:ident; $first:ident: $first_ty:ty $(, $rest:ident: $rest_ty:ty)*) => {\n+        reverse_decode!($reader, $s; $($rest: $rest_ty),*);\n+        let $first = <$first_ty>::decode(&mut $reader, $s);\n+    }\n+}\n+\n+#[allow(unsafe_code)]\n+mod buffer;\n+#[forbid(unsafe_code)]\n+pub mod client;\n+#[allow(unsafe_code)]\n+mod closure;\n+#[forbid(unsafe_code)]\n+mod handle;\n+#[macro_use]\n+#[forbid(unsafe_code)]\n+mod rpc;\n+#[allow(unsafe_code)]\n+mod scoped_cell;\n+#[forbid(unsafe_code)]\n+pub mod server;\n+\n+use self::buffer::Buffer;\n+pub use self::rpc::PanicMessage;\n+use self::rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n+\n+/// An active connection between a server and a client.\n+/// The server creates the bridge (`Bridge::run_server` in `server.rs`),\n+/// then passes it to the client through the function pointer in the `run`\n+/// field of `client::Client`. The client holds its copy of the `Bridge`\n+/// in TLS during its execution (`Bridge::{enter, with}` in `client.rs`).\n+#[repr(C)]\n+pub struct Bridge<'a> {\n+    /// Reusable buffer (only `clear`-ed, never shrunk), primarily\n+    /// used for making requests, but also for passing input to client.\n+    cached_buffer: Buffer<u8>,\n+\n+    /// Server-side function that the client uses to make requests.\n+    dispatch: closure::Closure<'a, Buffer<u8>, Buffer<u8>>,\n+}\n+\n+impl<'a> !Sync for Bridge<'a> {}\n+impl<'a> !Send for Bridge<'a> {}\n+\n+#[forbid(unsafe_code)]\n+#[allow(non_camel_case_types)]\n+mod api_tags {\n+    use super::rpc::{DecodeMut, Encode, Reader, Writer};\n+\n+    macro_rules! declare_tags {\n+        ($($name:ident {\n+            $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)*) $(-> $ret_ty:ty)*;)*\n+        }),* $(,)*) => {\n+            $(\n+                pub(super) enum $name {\n+                    $($method),*\n+                }\n+                rpc_encode_decode!(enum $name { $($method),* });\n+            )*\n+\n+\n+            pub(super) enum Method {\n+                $($name($name)),*\n+            }\n+            rpc_encode_decode!(enum Method { $($name(m)),* });\n+        }\n+    }\n+    with_api!(self, self, declare_tags);\n+}\n+\n+/// Helper to wrap associated types to allow trait impl dispatch.\n+/// That is, normally a pair of impls for `T::Foo` and `T::Bar`\n+/// can overlap, but if the impls are, instead, on types like\n+/// `Marked<T::Foo, Foo>` and `Marked<T::Bar, Bar>`, they can't.\n+trait Mark {\n+    type Unmarked;\n+    fn mark(unmarked: Self::Unmarked) -> Self;\n+}\n+\n+/// Unwrap types wrapped by `Mark::mark` (see `Mark` for details).\n+trait Unmark {\n+    type Unmarked;\n+    fn unmark(self) -> Self::Unmarked;\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+struct Marked<T, M> {\n+    value: T,\n+    _marker: marker::PhantomData<M>,\n+}\n+\n+impl<T, M> Mark for Marked<T, M> {\n+    type Unmarked = T;\n+    fn mark(unmarked: Self::Unmarked) -> Self {\n+        Marked {\n+            value: unmarked,\n+            _marker: marker::PhantomData,\n+        }\n+    }\n+}\n+impl<T, M> Unmark for Marked<T, M> {\n+    type Unmarked = T;\n+    fn unmark(self) -> Self::Unmarked {\n+        self.value\n+    }\n+}\n+impl<T, M> Unmark for &'a Marked<T, M> {\n+    type Unmarked = &'a T;\n+    fn unmark(self) -> Self::Unmarked {\n+        &self.value\n+    }\n+}\n+impl<T, M> Unmark for &'a mut Marked<T, M> {\n+    type Unmarked = &'a mut T;\n+    fn unmark(self) -> Self::Unmarked {\n+        &mut self.value\n+    }\n+}\n+\n+impl<T: Mark> Mark for Option<T> {\n+    type Unmarked = Option<T::Unmarked>;\n+    fn mark(unmarked: Self::Unmarked) -> Self {\n+        unmarked.map(T::mark)\n+    }\n+}\n+impl<T: Unmark> Unmark for Option<T> {\n+    type Unmarked = Option<T::Unmarked>;\n+    fn unmark(self) -> Self::Unmarked {\n+        self.map(T::unmark)\n+    }\n+}\n+\n+macro_rules! mark_noop {\n+    ($($ty:ty),* $(,)*) => {\n+        $(\n+            impl Mark for $ty {\n+                type Unmarked = Self;\n+                fn mark(unmarked: Self::Unmarked) -> Self {\n+                    unmarked\n+                }\n+            }\n+            impl Unmark for $ty {\n+                type Unmarked = Self;\n+                fn unmark(self) -> Self::Unmarked {\n+                    self\n+                }\n+            }\n+        )*\n+    }\n+}\n+mark_noop! {\n+    (),\n+    bool,\n+    char,\n+    &'a [u8],\n+    &'a str,\n+    String,\n+    Delimiter,\n+    Level,\n+    LineColumn,\n+    Spacing,\n+    Bound<usize>,\n+}\n+\n+rpc_encode_decode!(\n+    enum Delimiter {\n+        Parenthesis,\n+        Brace,\n+        Bracket,\n+        None,\n+    }\n+);\n+rpc_encode_decode!(\n+    enum Level {\n+        Error,\n+        Warning,\n+        Note,\n+        Help,\n+    }\n+);\n+rpc_encode_decode!(struct LineColumn { line, column });\n+rpc_encode_decode!(\n+    enum Spacing {\n+        Alone,\n+        Joint,\n+    }\n+);\n+\n+#[derive(Clone)]\n+pub enum TokenTree<G, P, I, L> {\n+    Group(G),\n+    Punct(P),\n+    Ident(I),\n+    Literal(L),\n+}\n+\n+impl<G: Mark, P: Mark, I: Mark, L: Mark> Mark for TokenTree<G, P, I, L> {\n+    type Unmarked = TokenTree<G::Unmarked, P::Unmarked, I::Unmarked, L::Unmarked>;\n+    fn mark(unmarked: Self::Unmarked) -> Self {\n+        match unmarked {\n+            TokenTree::Group(tt) => TokenTree::Group(G::mark(tt)),\n+            TokenTree::Punct(tt) => TokenTree::Punct(P::mark(tt)),\n+            TokenTree::Ident(tt) => TokenTree::Ident(I::mark(tt)),\n+            TokenTree::Literal(tt) => TokenTree::Literal(L::mark(tt)),\n+        }\n+    }\n+}\n+impl<G: Unmark, P: Unmark, I: Unmark, L: Unmark> Unmark for TokenTree<G, P, I, L> {\n+    type Unmarked = TokenTree<G::Unmarked, P::Unmarked, I::Unmarked, L::Unmarked>;\n+    fn unmark(self) -> Self::Unmarked {\n+        match self {\n+            TokenTree::Group(tt) => TokenTree::Group(tt.unmark()),\n+            TokenTree::Punct(tt) => TokenTree::Punct(tt.unmark()),\n+            TokenTree::Ident(tt) => TokenTree::Ident(tt.unmark()),\n+            TokenTree::Literal(tt) => TokenTree::Literal(tt.unmark()),\n+        }\n+    }\n+}\n+\n+rpc_encode_decode!(\n+    enum TokenTree<G, P, I, L> {\n+        Group(tt),\n+        Punct(tt),\n+        Ident(tt),\n+        Literal(tt),\n+    }\n+);"}, {"sha": "fafc3d0074065b153aaf9ee2d613bc85211d5ef5", "filename": "src/libproc_macro/bridge/rpc.rs", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Frpc.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -0,0 +1,319 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Serialization for client<->server communication.\n+\n+use std::any::Any;\n+use std::char;\n+use std::io::Write;\n+use std::num::NonZeroU32;\n+use std::ops::Bound;\n+use std::str;\n+\n+pub(super) type Writer = super::buffer::Buffer<u8>;\n+\n+pub(super) trait Encode<S>: Sized {\n+    fn encode(self, w: &mut Writer, s: &mut S);\n+}\n+\n+pub(super) type Reader<'a> = &'a [u8];\n+\n+pub(super) trait Decode<'a, 's, S>: Sized {\n+    fn decode(r: &mut Reader<'a>, s: &'s S) -> Self;\n+}\n+\n+pub(super) trait DecodeMut<'a, 's, S>: Sized {\n+    fn decode(r: &mut Reader<'a>, s: &'s mut S) -> Self;\n+}\n+\n+macro_rules! rpc_encode_decode {\n+    (uleb128 $ty:ty) => {\n+        impl<S> Encode<S> for $ty {\n+            fn encode(mut self, w: &mut Writer, s: &mut S) {\n+                let mut byte = 0x80;\n+                while byte & 0x80 != 0 {\n+                    byte = (self & 0x7f) as u8;\n+                    self >>= 7;\n+                    if self != 0 {\n+                        byte |= 0x80;\n+                    }\n+                    byte.encode(w, s);\n+                }\n+            }\n+        }\n+\n+        impl<S> DecodeMut<'_, '_, S> for $ty {\n+            fn decode(r: &mut Reader, s: &mut S) -> Self {\n+                let mut byte = 0x80;\n+                let mut v = 0;\n+                let mut shift = 0;\n+                while byte & 0x80 != 0 {\n+                    byte = u8::decode(r, s);\n+                    v |= ((byte & 0x7f) as Self) << shift;\n+                    shift += 7;\n+                }\n+                v\n+            }\n+        }\n+    };\n+    (struct $name:ident { $($field:ident),* $(,)* }) => {\n+        impl<S> Encode<S> for $name {\n+            fn encode(self, w: &mut Writer, s: &mut S) {\n+                $(self.$field.encode(w, s);)*\n+            }\n+        }\n+\n+        impl<S> DecodeMut<'_, '_, S> for $name {\n+            fn decode(r: &mut Reader, s: &mut S) -> Self {\n+                $name {\n+                    $($field: DecodeMut::decode(r, s)),*\n+                }\n+            }\n+        }\n+    };\n+    (enum $name:ident $(<$($T:ident),+>)* { $($variant:ident $(($field:ident))*),* $(,)* }) => {\n+        impl<S, $($($T: Encode<S>),+)*> Encode<S> for $name $(<$($T),+>)* {\n+            fn encode(self, w: &mut Writer, s: &mut S) {\n+                // HACK(eddyb) `Tag` enum duplicated between the\n+                // two impls as there's no other place to stash it.\n+                #[repr(u8)] enum Tag { $($variant),* }\n+                #[allow(non_upper_case_globals)]\n+                impl Tag { $(const $variant: u8 = Tag::$variant as u8;)* }\n+\n+                match self {\n+                    $($name::$variant $(($field))* => {\n+                        <Tag>::$variant.encode(w, s);\n+                        $($field.encode(w, s);)*\n+                    })*\n+                }\n+            }\n+        }\n+\n+        impl<S, $($($T: for<'s> DecodeMut<'a, 's, S>),+)*> DecodeMut<'a, '_, S>\n+            for $name $(<$($T),+>)*\n+        {\n+            fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+                // HACK(eddyb) `Tag` enum duplicated between the\n+                // two impls as there's no other place to stash it.\n+                #[repr(u8)] enum Tag { $($variant),* }\n+                #[allow(non_upper_case_globals)]\n+                impl Tag { $(const $variant: u8 = Tag::$variant as u8;)* }\n+\n+                match u8::decode(r, s) {\n+                    $(<Tag>::$variant => {\n+                        $(let $field = DecodeMut::decode(r, s);)*\n+                        $name::$variant $(($field))*\n+                    })*\n+                    _ => unreachable!(),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<S> Encode<S> for () {\n+    fn encode(self, _: &mut Writer, _: &mut S) {}\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for () {\n+    fn decode(_: &mut Reader, _: &mut S) -> Self {}\n+}\n+\n+impl<S> Encode<S> for u8 {\n+    fn encode(self, w: &mut Writer, _: &mut S) {\n+        w.write_all(&[self]).unwrap();\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for u8 {\n+    fn decode(r: &mut Reader, _: &mut S) -> Self {\n+        let x = r[0];\n+        *r = &r[1..];\n+        x\n+    }\n+}\n+\n+rpc_encode_decode!(uleb128 u32);\n+rpc_encode_decode!(uleb128 usize);\n+\n+impl<S> Encode<S> for bool {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        (self as u8).encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for bool {\n+    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+        match u8::decode(r, s) {\n+            0 => false,\n+            1 => true,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl<S> Encode<S> for char {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        (self as u32).encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for char {\n+    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+        char::from_u32(u32::decode(r, s)).unwrap()\n+    }\n+}\n+\n+impl<S> Encode<S> for NonZeroU32 {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.get().encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for NonZeroU32 {\n+    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+        Self::new(u32::decode(r, s)).unwrap()\n+    }\n+}\n+\n+impl<S, A: Encode<S>, B: Encode<S>> Encode<S> for (A, B) {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.0.encode(w, s);\n+        self.1.encode(w, s);\n+    }\n+}\n+\n+impl<S, A: for<'s> DecodeMut<'a, 's, S>, B: for<'s> DecodeMut<'a, 's, S>> DecodeMut<'a, '_, S>\n+    for (A, B)\n+{\n+    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+        (DecodeMut::decode(r, s), DecodeMut::decode(r, s))\n+    }\n+}\n+\n+rpc_encode_decode!(\n+    enum Bound<T> {\n+        Included(x),\n+        Excluded(x),\n+        Unbounded,\n+    }\n+);\n+\n+rpc_encode_decode!(\n+    enum Option<T> {\n+        None,\n+        Some(x),\n+    }\n+);\n+\n+rpc_encode_decode!(\n+    enum Result<T, E> {\n+        Ok(x),\n+        Err(e),\n+    }\n+);\n+\n+impl<S> Encode<S> for &[u8] {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.len().encode(w, s);\n+        w.write_all(self).unwrap();\n+    }\n+}\n+\n+impl<S> DecodeMut<'a, '_, S> for &'a [u8] {\n+    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+        let len = usize::decode(r, s);\n+        let xs = &r[..len];\n+        *r = &r[len..];\n+        xs\n+    }\n+}\n+\n+impl<S> Encode<S> for &str {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.as_bytes().encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'a, '_, S> for &'a str {\n+    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+        str::from_utf8(<&[u8]>::decode(r, s)).unwrap()\n+    }\n+}\n+\n+impl<S> Encode<S> for String {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self[..].encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for String {\n+    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+        <&str>::decode(r, s).to_string()\n+    }\n+}\n+\n+/// Simplied version of panic payloads, ignoring\n+/// types other than `&'static str` and `String`.\n+pub enum PanicMessage {\n+    StaticStr(&'static str),\n+    String(String),\n+    Unknown,\n+}\n+\n+impl From<Box<dyn Any + Send>> for PanicMessage {\n+    fn from(payload: Box<dyn Any + Send + 'static>) -> Self {\n+        if let Some(s) = payload.downcast_ref::<&'static str>() {\n+            return PanicMessage::StaticStr(s);\n+        }\n+        if let Ok(s) = payload.downcast::<String>() {\n+            return PanicMessage::String(*s);\n+        }\n+        PanicMessage::Unknown\n+    }\n+}\n+\n+impl Into<Box<dyn Any + Send>> for PanicMessage {\n+    fn into(self) -> Box<dyn Any + Send> {\n+        match self {\n+            PanicMessage::StaticStr(s) => Box::new(s),\n+            PanicMessage::String(s) => Box::new(s),\n+            PanicMessage::Unknown => {\n+                struct UnknownPanicMessage;\n+                Box::new(UnknownPanicMessage)\n+            }\n+        }\n+    }\n+}\n+\n+impl PanicMessage {\n+    pub fn as_str(&self) -> Option<&str> {\n+        match self {\n+            PanicMessage::StaticStr(s) => Some(s),\n+            PanicMessage::String(s) => Some(s),\n+            PanicMessage::Unknown => None,\n+        }\n+    }\n+}\n+\n+impl<S> Encode<S> for PanicMessage {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.as_str().encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for PanicMessage {\n+    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+        match Option::<String>::decode(r, s) {\n+            Some(s) => PanicMessage::String(s),\n+            None => PanicMessage::Unknown,\n+        }\n+    }\n+}"}, {"sha": "51d1fece79b92a4926e741872c55479091aae486", "filename": "src/libproc_macro/bridge/scoped_cell.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! `Cell` variant for (scoped) existential lifetimes.\n+\n+use std::cell::Cell;\n+use std::mem;\n+use std::ops::{Deref, DerefMut};\n+\n+/// Type lambda application, with a lifetime.\n+pub trait ApplyL<'a> {\n+    type Out;\n+}\n+\n+/// Type lambda taking a lifetime, i.e. `Lifetime -> Type`.\n+pub trait LambdaL: for<'a> ApplyL<'a> {}\n+\n+impl<T: for<'a> ApplyL<'a>> LambdaL for T {}\n+\n+// HACK(eddyb) work around projection limitations with a newtype\n+// FIXME(#52812) replace with `&'a mut <T as ApplyL<'b>>::Out`\n+pub struct RefMutL<'a, 'b, T: LambdaL>(&'a mut <T as ApplyL<'b>>::Out);\n+\n+impl<'a, 'b, T: LambdaL> Deref for RefMutL<'a, 'b, T> {\n+    type Target = <T as ApplyL<'b>>::Out;\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}\n+\n+impl<'a, 'b, T: LambdaL> DerefMut for RefMutL<'a, 'b, T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.0\n+    }\n+}\n+\n+pub struct ScopedCell<T: LambdaL>(Cell<<T as ApplyL<'static>>::Out>);\n+\n+impl<T: LambdaL> ScopedCell<T> {\n+    pub const fn new(value: <T as ApplyL<'static>>::Out) -> Self {\n+        ScopedCell(Cell::new(value))\n+    }\n+\n+    /// Set the value in `self` to `replacement` while\n+    /// running `f`, which gets the old value, mutably.\n+    /// The old value will be restored after `f` exits, even\n+    /// by panic, including modifications made to it by `f`.\n+    pub fn replace<'a, R>(\n+        &self,\n+        replacement: <T as ApplyL<'a>>::Out,\n+        f: impl for<'b, 'c> FnOnce(RefMutL<'b, 'c, T>) -> R,\n+    ) -> R {\n+        /// Wrapper that ensures that the cell always gets filled\n+        /// (with the original state, optionally changed by `f`),\n+        /// even if `f` had panicked.\n+        struct PutBackOnDrop<'a, T: LambdaL> {\n+            cell: &'a ScopedCell<T>,\n+            value: Option<<T as ApplyL<'static>>::Out>,\n+        }\n+\n+        impl<'a, T: LambdaL> Drop for PutBackOnDrop<'a, T> {\n+            fn drop(&mut self) {\n+                self.cell.0.set(self.value.take().unwrap());\n+            }\n+        }\n+\n+        let mut put_back_on_drop = PutBackOnDrop {\n+            cell: self,\n+            value: Some(self.0.replace(unsafe {\n+                let erased = mem::transmute_copy(&replacement);\n+                mem::forget(replacement);\n+                erased\n+            })),\n+        };\n+\n+        f(RefMutL(put_back_on_drop.value.as_mut().unwrap()))\n+    }\n+\n+    /// Set the value in `self` to `value` while running `f`.\n+    pub fn set<'a, R>(&self, value: <T as ApplyL<'a>>::Out, f: impl FnOnce() -> R) -> R {\n+        self.replace(value, |_| f())\n+    }\n+}"}, {"sha": "f500b17d1caf316f01105fff1d59d2d9cb96bf07", "filename": "src/libproc_macro/bridge/server.rs", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fserver.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -0,0 +1,352 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Server-side traits.\n+\n+use super::*;\n+\n+// FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n+use super::client::HandleStore;\n+\n+/// Declare an associated item of one of the traits below, optionally\n+/// adjusting it (i.e. adding bounds to types and default bodies to methods).\n+macro_rules! associated_item {\n+    (type TokenStream) =>\n+        (type TokenStream: 'static + Clone;);\n+    (type TokenStreamBuilder) =>\n+        (type TokenStreamBuilder: 'static;);\n+    (type TokenStreamIter) =>\n+        (type TokenStreamIter: 'static + Clone;);\n+    (type Group) =>\n+        (type Group: 'static + Clone;);\n+    (type Punct) =>\n+        (type Punct: 'static + Copy + Eq + Hash;);\n+    (type Ident) =>\n+        (type Ident: 'static + Copy + Eq + Hash;);\n+    (type Literal) =>\n+        (type Literal: 'static + Clone;);\n+    (type SourceFile) =>\n+        (type SourceFile: 'static + Clone;);\n+    (type MultiSpan) =>\n+        (type MultiSpan: 'static;);\n+    (type Diagnostic) =>\n+        (type Diagnostic: 'static;);\n+    (type Span) =>\n+        (type Span: 'static + Copy + Eq + Hash;);\n+    (fn drop(&mut self, $arg:ident: $arg_ty:ty)) =>\n+        (fn drop(&mut self, $arg: $arg_ty) { mem::drop($arg) });\n+    (fn clone(&mut self, $arg:ident: $arg_ty:ty) -> $ret_ty:ty) =>\n+        (fn clone(&mut self, $arg: $arg_ty) -> $ret_ty { $arg.clone() });\n+    ($($item:tt)*) => ($($item)*;)\n+}\n+\n+macro_rules! declare_server_traits {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)*) $(-> $ret_ty:ty)*;)*\n+    }),* $(,)*) => {\n+        pub trait Types {\n+            $(associated_item!(type $name);)*\n+        }\n+\n+        $(pub trait $name: Types {\n+            $(associated_item!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)*);)*\n+        })*\n+\n+        pub trait Server: Types $(+ $name)* {}\n+        impl<S: Types $(+ $name)*> Server for S {}\n+    }\n+}\n+with_api!(Self, self_, declare_server_traits);\n+\n+pub(super) struct MarkedTypes<S: Types>(S);\n+\n+macro_rules! define_mark_types_impls {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)*) $(-> $ret_ty:ty)*;)*\n+    }),* $(,)*) => {\n+        impl<S: Types> Types for MarkedTypes<S> {\n+            $(type $name = Marked<S::$name, client::$name>;)*\n+        }\n+\n+        $(impl<S: $name> $name for MarkedTypes<S> {\n+            $(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)* {\n+                <_>::mark($name::$method(&mut self.0, $($arg.unmark()),*))\n+            })*\n+        })*\n+    }\n+}\n+with_api!(Self, self_, define_mark_types_impls);\n+\n+struct Dispatcher<S: Types> {\n+    handle_store: HandleStore<S>,\n+    server: S,\n+}\n+\n+macro_rules! define_dispatcher_impl {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)*) $(-> $ret_ty:ty)*;)*\n+    }),* $(,)*) => {\n+        // FIXME(eddyb) `pub` only for `ExecutionStrategy` below.\n+        pub trait DispatcherTrait {\n+            // HACK(eddyb) these are here to allow `Self::$name` to work below.\n+            $(type $name;)*\n+            fn dispatch(&mut self, b: Buffer<u8>) -> Buffer<u8>;\n+        }\n+\n+        impl<S: Server> DispatcherTrait for Dispatcher<MarkedTypes<S>> {\n+            $(type $name = <MarkedTypes<S> as Types>::$name;)*\n+            fn dispatch(&mut self, mut b: Buffer<u8>) -> Buffer<u8> {\n+                let Dispatcher { handle_store, server } = self;\n+\n+                let mut reader = &b[..];\n+                match api_tags::Method::decode(&mut reader, &mut ()) {\n+                    $(api_tags::Method::$name(m) => match m {\n+                        $(api_tags::$name::$method => {\n+                            let mut call_method = || {\n+                                reverse_decode!(reader, handle_store; $($arg: $arg_ty),*);\n+                                $name::$method(server, $($arg),*)\n+                            };\n+                            // HACK(eddyb) don't use `panic::catch_unwind` in a panic.\n+                            // If client and server happen to use the same `libstd`,\n+                            // `catch_unwind` asserts that the panic counter was 0,\n+                            // even when the closure passed to it didn't panic.\n+                            let r = if thread::panicking() {\n+                                Ok(call_method())\n+                            } else {\n+                                panic::catch_unwind(panic::AssertUnwindSafe(call_method))\n+                                    .map_err(PanicMessage::from)\n+                            };\n+\n+                            b.clear();\n+                            r.encode(&mut b, handle_store);\n+                        })*\n+                    }),*\n+                }\n+                b\n+            }\n+        }\n+    }\n+}\n+with_api!(Self, self_, define_dispatcher_impl);\n+\n+pub trait ExecutionStrategy {\n+    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+        client_data: D,\n+    ) -> Buffer<u8>;\n+}\n+\n+pub struct SameThread;\n+\n+impl ExecutionStrategy for SameThread {\n+    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+        client_data: D,\n+    ) -> Buffer<u8> {\n+        let mut dispatch = |b| dispatcher.dispatch(b);\n+\n+        run_client(\n+            Bridge {\n+                cached_buffer: input,\n+                dispatch: (&mut dispatch).into(),\n+            },\n+            client_data,\n+        )\n+    }\n+}\n+\n+// NOTE(eddyb) Two implementations are provided, the second one is a bit\n+// faster but neither is anywhere near as fast as same-thread execution.\n+\n+pub struct CrossThread1;\n+\n+impl ExecutionStrategy for CrossThread1 {\n+    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+        client_data: D,\n+    ) -> Buffer<u8> {\n+        use std::sync::mpsc::channel;\n+\n+        let (req_tx, req_rx) = channel();\n+        let (res_tx, res_rx) = channel();\n+\n+        let join_handle = thread::spawn(move || {\n+            let mut dispatch = |b| {\n+                req_tx.send(b).unwrap();\n+                res_rx.recv().unwrap()\n+            };\n+\n+            run_client(\n+                Bridge {\n+                    cached_buffer: input,\n+                    dispatch: (&mut dispatch).into(),\n+                },\n+                client_data,\n+            )\n+        });\n+\n+        for b in req_rx {\n+            res_tx.send(dispatcher.dispatch(b)).unwrap();\n+        }\n+\n+        join_handle.join().unwrap()\n+    }\n+}\n+\n+pub struct CrossThread2;\n+\n+impl ExecutionStrategy for CrossThread2 {\n+    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+        client_data: D,\n+    ) -> Buffer<u8> {\n+        use std::sync::{Arc, Mutex};\n+\n+        enum State<T> {\n+            Req(T),\n+            Res(T),\n+        }\n+\n+        let mut state = Arc::new(Mutex::new(State::Res(Buffer::new())));\n+\n+        let server_thread = thread::current();\n+        let state2 = state.clone();\n+        let join_handle = thread::spawn(move || {\n+            let mut dispatch = |b| {\n+                *state2.lock().unwrap() = State::Req(b);\n+                server_thread.unpark();\n+                loop {\n+                    thread::park();\n+                    if let State::Res(b) = &mut *state2.lock().unwrap() {\n+                        break b.take();\n+                    }\n+                }\n+            };\n+\n+            let r = run_client(\n+                Bridge {\n+                    cached_buffer: input,\n+                    dispatch: (&mut dispatch).into(),\n+                },\n+                client_data,\n+            );\n+\n+            // Wake up the server so it can exit the dispatch loop.\n+            drop(state2);\n+            server_thread.unpark();\n+\n+            r\n+        });\n+\n+        // Check whether `state2` was dropped, to know when to stop.\n+        while Arc::get_mut(&mut state).is_none() {\n+            thread::park();\n+            let mut b = match &mut *state.lock().unwrap() {\n+                State::Req(b) => b.take(),\n+                _ => continue,\n+            };\n+            b = dispatcher.dispatch(b.take());\n+            *state.lock().unwrap() = State::Res(b);\n+            join_handle.thread().unpark();\n+        }\n+\n+        join_handle.join().unwrap()\n+    }\n+}\n+\n+fn run_server<\n+    S: Server,\n+    I: Encode<HandleStore<MarkedTypes<S>>>,\n+    O: for<'a, 's> DecodeMut<'a, 's, HandleStore<MarkedTypes<S>>>,\n+    D: Copy + Send + 'static,\n+>(\n+    strategy: &impl ExecutionStrategy,\n+    handle_counters: &'static client::HandleCounters,\n+    server: S,\n+    input: I,\n+    run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+    client_data: D,\n+) -> Result<O, PanicMessage> {\n+    let mut dispatcher = Dispatcher {\n+        handle_store: HandleStore::new(handle_counters),\n+        server: MarkedTypes(server),\n+    };\n+\n+    let mut b = Buffer::new();\n+    input.encode(&mut b, &mut dispatcher.handle_store);\n+\n+    b = strategy.run_bridge_and_client(&mut dispatcher, b, run_client, client_data);\n+\n+    Result::decode(&mut &b[..], &mut dispatcher.handle_store)\n+}\n+\n+impl client::Client<fn(::TokenStream) -> ::TokenStream> {\n+    pub fn run<S: Server>(\n+        &self,\n+        strategy: &impl ExecutionStrategy,\n+        server: S,\n+        input: S::TokenStream,\n+    ) -> Result<S::TokenStream, PanicMessage> {\n+        let client::Client {\n+            get_handle_counters,\n+            run,\n+            f,\n+        } = *self;\n+        run_server(\n+            strategy,\n+            get_handle_counters(),\n+            server,\n+            <MarkedTypes<S> as Types>::TokenStream::mark(input),\n+            run,\n+            f,\n+        )\n+        .map(<MarkedTypes<S> as Types>::TokenStream::unmark)\n+    }\n+}\n+\n+impl client::Client<fn(::TokenStream, ::TokenStream) -> ::TokenStream> {\n+    pub fn run<S: Server>(\n+        &self,\n+        strategy: &impl ExecutionStrategy,\n+        server: S,\n+        input: S::TokenStream,\n+        input2: S::TokenStream,\n+    ) -> Result<S::TokenStream, PanicMessage> {\n+        let client::Client {\n+            get_handle_counters,\n+            run,\n+            f,\n+        } = *self;\n+        run_server(\n+            strategy,\n+            get_handle_counters(),\n+            server,\n+            (\n+                <MarkedTypes<S> as Types>::TokenStream::mark(input),\n+                <MarkedTypes<S> as Types>::TokenStream::mark(input2),\n+            ),\n+            run,\n+            f,\n+        )\n+        .map(<MarkedTypes<S> as Types>::TokenStream::unmark)\n+    }\n+}"}, {"sha": "4234f0bcd21c1708b031e1483c1375cb4ebbd445", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -10,8 +10,6 @@\n \n use Span;\n \n-use rustc_errors as errors;\n-\n /// An enum representing a diagnostic level.\n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n #[derive(Copy, Clone, Debug)]\n@@ -180,22 +178,22 @@ impl Diagnostic {\n     /// Emit the diagnostic.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n     pub fn emit(self) {\n-        fn to_internal(spans: Vec<Span>) -> ::syntax_pos::MultiSpan {\n-            let spans: Vec<_> = spans.into_iter().map(|s| s.0).collect();\n-            ::syntax_pos::MultiSpan::from_spans(spans)\n+        fn to_internal(spans: Vec<Span>) -> ::bridge::client::MultiSpan {\n+            let mut multi_span = ::bridge::client::MultiSpan::new();\n+            for span in spans {\n+                multi_span.push(span.0);\n+            }\n+            multi_span\n         }\n \n-        let level = self.level.to_internal();\n-        let mut diag = errors::Diagnostic::new(level, &*self.message);\n-        diag.set_span(to_internal(self.spans));\n-\n-        for child in self.children {\n-            let level = child.level.to_internal();\n-            diag.sub(level, &*child.message, to_internal(child.spans), None);\n+        let mut diag = ::bridge::client::Diagnostic::new(\n+            self.level,\n+            &self.message[..],\n+            to_internal(self.spans),\n+        );\n+        for c in self.children {\n+            diag.sub(c.level, &c.message[..], to_internal(c.spans));\n         }\n-\n-        ::__internal::with_sess(move |sess, _| {\n-            errors::DiagnosticBuilder::new_diagnostic(&sess.span_diagnostic, diag).emit();\n-        });\n+        diag.emit();\n     }\n }"}, {"sha": "49ec6b41ce75619d0c6550a646b1d747438a698d", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 170, "deletions": 293, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -30,9 +30,12 @@\n #![feature(nll)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(lang_items)]\n+#![feature(const_fn)]\n+#![feature(extern_types)]\n+#![feature(in_band_lifetimes)]\n #![feature(optin_builtin_traits)]\n #![feature(non_exhaustive)]\n+#![feature(specialization)]\n \n #![recursion_limit=\"256\"]\n \n@@ -41,6 +44,10 @@ extern crate syntax_pos;\n extern crate rustc_errors;\n extern crate rustc_data_structures;\n \n+#[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n+#[doc(hidden)]\n+pub mod bridge;\n+\n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n #[doc(hidden)]\n pub mod rustc;\n@@ -50,18 +57,11 @@ mod diagnostic;\n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n pub use diagnostic::{Diagnostic, Level, MultiSpan};\n \n+use std::{fmt, iter, mem};\n use std::ops::{Bound, RangeBounds};\n-use std::{ascii, fmt, iter};\n use std::path::PathBuf;\n-use rustc_data_structures::sync::Lrc;\n use std::str::FromStr;\n \n-use syntax::errors::DiagnosticBuilder;\n-use syntax::parse::{self, token};\n-use syntax::symbol::Symbol;\n-use syntax::tokenstream::{self, DelimSpan};\n-use syntax_pos::{Pos, FileName, BytePos};\n-\n /// The main type provided by this crate, representing an abstract stream of\n /// tokens, or, more specifically, a sequence of token trees.\n /// The type provide interfaces for iterating over those token trees and, conversely,\n@@ -71,7 +71,7 @@ use syntax_pos::{Pos, FileName, BytePos};\n /// and `#[proc_macro_derive]` definitions.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n #[derive(Clone)]\n-pub struct TokenStream(tokenstream::TokenStream);\n+pub struct TokenStream(bridge::client::TokenStream);\n \n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl !Send for TokenStream {}\n@@ -94,7 +94,7 @@ impl TokenStream {\n     /// Returns an empty `TokenStream` containing no token trees.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new() -> TokenStream {\n-        TokenStream(tokenstream::TokenStream::empty())\n+        TokenStream(bridge::client::TokenStream::new())\n     }\n \n     /// Checks if this `TokenStream` is empty.\n@@ -116,11 +116,16 @@ impl FromStr for TokenStream {\n     type Err = LexError;\n \n     fn from_str(src: &str) -> Result<TokenStream, LexError> {\n-        __internal::with_sess(|sess, data| {\n-            Ok(__internal::token_stream_wrap(parse::parse_stream_from_source_str(\n-                FileName::ProcMacroSourceCode, src.to_string(), sess, Some(data.call_site.0)\n-            )))\n-        })\n+        Ok(TokenStream(bridge::client::TokenStream::from_str(src)))\n+    }\n+}\n+\n+// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// based on it (the reverse of the usual relationship between the two).\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n+impl ToString for TokenStream {\n+    fn to_string(&self) -> String {\n+        self.0.to_string()\n     }\n }\n \n@@ -130,7 +135,7 @@ impl FromStr for TokenStream {\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Display for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.0.fmt(f)\n+        f.write_str(&self.to_string())\n     }\n }\n \n@@ -150,7 +155,12 @@ pub use quote::{quote, quote_span};\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream(tree.to_internal())\n+        TokenStream(bridge::client::TokenStream::from_token_tree(match tree {\n+            TokenTree::Group(tt) => bridge::TokenTree::Group(tt.0),\n+            TokenTree::Punct(tt) => bridge::TokenTree::Punct(tt.0),\n+            TokenTree::Ident(tt) => bridge::TokenTree::Ident(tt.0),\n+            TokenTree::Literal(tt) => bridge::TokenTree::Literal(tt.0)\n+        }))\n     }\n }\n \n@@ -167,7 +177,7 @@ impl iter::FromIterator<TokenTree> for TokenStream {\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl iter::FromIterator<TokenStream> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n-        let mut builder = tokenstream::TokenStreamBuilder::new();\n+        let mut builder = bridge::client::TokenStreamBuilder::new();\n         for stream in streams {\n             builder.push(stream.0);\n         }\n@@ -185,52 +195,34 @@ impl Extend<TokenTree> for TokenStream {\n #[stable(feature = \"token_stream_extend\", since = \"1.30.0\")]\n impl Extend<TokenStream> for TokenStream {\n     fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n-        self.0.extend(streams.into_iter().map(|stream| stream.0));\n+        // FIXME(eddyb) Use an optimized implementation if/when possible.\n+        *self = iter::once(mem::replace(self, Self::new())).chain(streams).collect();\n     }\n }\n \n /// Public implementation details for the `TokenStream` type, such as iterators.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub mod token_stream {\n-    use syntax::tokenstream;\n-    use {TokenTree, TokenStream, Delimiter};\n+    use {bridge, Group, Ident, Literal, Punct, TokenTree, TokenStream};\n \n     /// An iterator over `TokenStream`'s `TokenTree`s.\n     /// The iteration is \"shallow\", e.g. the iterator doesn't recurse into delimited groups,\n     /// and returns whole groups as token trees.\n     #[derive(Clone)]\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-    pub struct IntoIter {\n-        cursor: tokenstream::Cursor,\n-        stack: Vec<TokenTree>,\n-    }\n+    pub struct IntoIter(bridge::client::TokenStreamIter);\n \n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     impl Iterator for IntoIter {\n         type Item = TokenTree;\n \n         fn next(&mut self) -> Option<TokenTree> {\n-            loop {\n-                let tree = self.stack.pop().or_else(|| {\n-                    let next = self.cursor.next_as_stream()?;\n-                    Some(TokenTree::from_internal(next, &mut self.stack))\n-                })?;\n-                // HACK: The condition \"dummy span + group with empty delimiter\" represents an AST\n-                // fragment approximately converted into a token stream. This may happen, for\n-                // example, with inputs to proc macro attributes, including derives. Such \"groups\"\n-                // need to flattened during iteration over stream's token trees.\n-                // Eventually this needs to be removed in favor of keeping original token trees\n-                // and not doing the roundtrip through AST.\n-                if tree.span().0.is_dummy() {\n-                    if let TokenTree::Group(ref group) = tree {\n-                        if group.delimiter() == Delimiter::None {\n-                            self.cursor.insert(group.stream.clone().0);\n-                            continue\n-                        }\n-                    }\n-                }\n-                return Some(tree);\n-            }\n+            self.0.next().map(|tree| match tree {\n+                bridge::TokenTree::Group(tt) => TokenTree::Group(Group(tt)),\n+                bridge::TokenTree::Punct(tt) => TokenTree::Punct(Punct(tt)),\n+                bridge::TokenTree::Ident(tt) => TokenTree::Ident(Ident(tt)),\n+                bridge::TokenTree::Literal(tt) => TokenTree::Literal(Literal(tt)),\n+            })\n         }\n     }\n \n@@ -240,7 +232,7 @@ pub mod token_stream {\n         type IntoIter = IntoIter;\n \n         fn into_iter(self) -> IntoIter {\n-            IntoIter { cursor: self.0.trees(), stack: Vec::new() }\n+            IntoIter(self.0.into_iter())\n         }\n     }\n }\n@@ -264,7 +256,7 @@ mod quote;\n /// A region of source code, along with macro expansion information.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n #[derive(Copy, Clone)]\n-pub struct Span(syntax_pos::Span);\n+pub struct Span(bridge::client::Span);\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Send for Span {}\n@@ -286,7 +278,7 @@ impl Span {\n     /// A span that resolves at the macro definition site.\n     #[unstable(feature = \"proc_macro_def_site\", issue = \"54724\")]\n     pub fn def_site() -> Span {\n-        ::__internal::with_sess(|_, data| data.def_site)\n+        Span(bridge::client::Span::def_site())\n     }\n \n     /// The span of the invocation of the current procedural macro.\n@@ -295,15 +287,13 @@ impl Span {\n     /// at the macro call site will be able to refer to them as well.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn call_site() -> Span {\n-        ::__internal::with_sess(|_, data| data.call_site)\n+        Span(bridge::client::Span::call_site())\n     }\n \n     /// The original source file into which this span points.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn source_file(&self) -> SourceFile {\n-        SourceFile {\n-            source_file: __internal::lookup_char_pos(self.0.lo()).file,\n-        }\n+        SourceFile(self.0.source_file())\n     }\n \n     /// The `Span` for the tokens in the previous macro expansion from which\n@@ -318,47 +308,34 @@ impl Span {\n     /// value is the same as `*self`.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn source(&self) -> Span {\n-        Span(self.0.source_callsite())\n+        Span(self.0.source())\n     }\n \n     /// Get the starting line/column in the source file for this span.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn start(&self) -> LineColumn {\n-        let loc = __internal::lookup_char_pos(self.0.lo());\n-        LineColumn {\n-            line: loc.line,\n-            column: loc.col.to_usize()\n-        }\n+        self.0.start()\n     }\n \n     /// Get the ending line/column in the source file for this span.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn end(&self) -> LineColumn {\n-        let loc = __internal::lookup_char_pos(self.0.hi());\n-        LineColumn {\n-            line: loc.line,\n-            column: loc.col.to_usize()\n-        }\n+        self.0.end()\n     }\n \n     /// Create a new span encompassing `self` and `other`.\n     ///\n     /// Returns `None` if `self` and `other` are from different files.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn join(&self, other: Span) -> Option<Span> {\n-        let self_loc = __internal::lookup_char_pos(self.0.lo());\n-        let other_loc = __internal::lookup_char_pos(other.0.lo());\n-\n-        if self_loc.file.name != other_loc.file.name { return None }\n-\n-        Some(Span(self.0.to(other.0)))\n+        self.0.join(other.0).map(Span)\n     }\n \n     /// Creates a new span with the same line/column information as `self` but\n     /// that resolves symbols as though it were at `other`.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn resolved_at(&self, other: Span) -> Span {\n-        Span(self.0.with_ctxt(other.0.ctxt()))\n+        Span(self.0.resolved_at(other.0))\n     }\n \n     /// Creates a new span with the same name resolution behavior as `self` but\n@@ -384,10 +361,7 @@ impl Span {\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Span {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:?} bytes({}..{})\",\n-               self.0.ctxt(),\n-               self.0.lo().0,\n-               self.0.hi().0)\n+        self.0.fmt(f)\n     }\n }\n \n@@ -412,14 +386,7 @@ impl !Sync for LineColumn {}\n /// The source file of a given `Span`.\n #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n #[derive(Clone)]\n-pub struct SourceFile {\n-    source_file: Lrc<syntax_pos::SourceFile>,\n-}\n-\n-#[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n-impl !Send for SourceFile {}\n-#[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n-impl !Sync for SourceFile {}\n+pub struct SourceFile(bridge::client::SourceFile);\n \n impl SourceFile {\n     /// Get the path to this source file.\n@@ -434,10 +401,7 @@ impl SourceFile {\n     /// [`is_real`]: #method.is_real\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn path(&self) -> PathBuf {\n-        match self.source_file.name {\n-            FileName::Real(ref path) => path.clone(),\n-            _ => PathBuf::from(self.source_file.name.to_string())\n-        }\n+        PathBuf::from(self.0.path())\n     }\n \n     /// Returns `true` if this source file is a real source file, and not generated by an external\n@@ -447,7 +411,7 @@ impl SourceFile {\n         // This is a hack until intercrate spans are implemented and we can have real source files\n         // for spans generated in external macros.\n         // https://github.com/rust-lang/rust/pull/43604#issuecomment-333334368\n-        self.source_file.is_real_file()\n+        self.0.is_real()\n     }\n }\n \n@@ -465,7 +429,7 @@ impl fmt::Debug for SourceFile {\n #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n impl PartialEq for SourceFile {\n     fn eq(&self, other: &Self) -> bool {\n-        Lrc::ptr_eq(&self.source_file, &other.source_file)\n+        self.0.eq(&other.0)\n     }\n }\n \n@@ -579,18 +543,27 @@ impl From<Literal> for TokenTree {\n     }\n }\n \n+// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// based on it (the reverse of the usual relationship between the two).\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n+impl ToString for TokenTree {\n+    fn to_string(&self) -> String {\n+        match *self {\n+            TokenTree::Group(ref t) => t.to_string(),\n+            TokenTree::Ident(ref t) => t.to_string(),\n+            TokenTree::Punct(ref t) => t.to_string(),\n+            TokenTree::Literal(ref t) => t.to_string(),\n+        }\n+    }\n+}\n+\n /// Prints the token tree as a string that is supposed to be losslessly convertible back\n /// into the same token tree (modulo spans), except for possibly `TokenTree::Group`s\n /// with `Delimiter::None` delimiters and negative numeric literals.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for TokenTree {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            TokenTree::Group(ref t) => t.fmt(f),\n-            TokenTree::Ident(ref t) => t.fmt(f),\n-            TokenTree::Punct(ref t) => t.fmt(f),\n-            TokenTree::Literal(ref t) => t.fmt(f),\n-        }\n+        f.write_str(&self.to_string())\n     }\n }\n \n@@ -599,11 +572,7 @@ impl fmt::Display for TokenTree {\n /// A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.\n #[derive(Clone)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-pub struct Group {\n-    delimiter: Delimiter,\n-    stream: TokenStream,\n-    span: DelimSpan,\n-}\n+pub struct Group(bridge::client::Group);\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Send for Group {}\n@@ -640,17 +609,13 @@ impl Group {\n     /// method below.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n-        Group {\n-            delimiter: delimiter,\n-            stream: stream,\n-            span: DelimSpan::from_single(Span::call_site().0),\n-        }\n+        Group(bridge::client::Group::new(delimiter, stream.0))\n     }\n \n     /// Returns the delimiter of this `Group`\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn delimiter(&self) -> Delimiter {\n-        self.delimiter\n+        self.0.delimiter()\n     }\n \n     /// Returns the `TokenStream` of tokens that are delimited in this `Group`.\n@@ -659,7 +624,7 @@ impl Group {\n     /// returned above.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn stream(&self) -> TokenStream {\n-        self.stream.clone()\n+        TokenStream(self.0.stream())\n     }\n \n     /// Returns the span for the delimiters of this token stream, spanning the\n@@ -671,7 +636,7 @@ impl Group {\n     /// ```\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n-        Span(self.span.entire())\n+        Span(self.0.span())\n     }\n \n     /// Returns the span pointing to the opening delimiter of this group.\n@@ -682,7 +647,7 @@ impl Group {\n     /// ```\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn span_open(&self) -> Span {\n-        Span(self.span.open)\n+        Span(self.0.span_open())\n     }\n \n     /// Returns the span pointing to the closing delimiter of this group.\n@@ -693,7 +658,7 @@ impl Group {\n     /// ```\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn span_close(&self) -> Span {\n-        Span(self.span.close)\n+        Span(self.0.span_close())\n     }\n \n     /// Configures the span for this `Group`'s delimiters, but not its internal\n@@ -704,7 +669,16 @@ impl Group {\n     /// tokens at the level of the `Group`.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n-        self.span = DelimSpan::from_single(span.0);\n+        self.0.set_span(span.0);\n+    }\n+}\n+\n+// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// based on it (the reverse of the usual relationship between the two).\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n+impl ToString for Group {\n+    fn to_string(&self) -> String {\n+        TokenStream::from(TokenTree::from(self.clone())).to_string()\n     }\n }\n \n@@ -714,7 +688,7 @@ impl Group {\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Group {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n+        f.write_str(&self.to_string())\n     }\n }\n \n@@ -735,11 +709,7 @@ impl fmt::Debug for Group {\n /// forms of `Spacing` returned.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n #[derive(Clone)]\n-pub struct Punct {\n-    ch: char,\n-    spacing: Spacing,\n-    span: Span,\n-}\n+pub struct Punct(bridge::client::Punct);\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl !Send for Punct {}\n@@ -774,17 +744,13 @@ impl Punct {\n         if !LEGAL_CHARS.contains(&ch) {\n             panic!(\"unsupported character `{:?}`\", ch)\n         }\n-        Punct {\n-            ch: ch,\n-            spacing: spacing,\n-            span: Span::call_site(),\n-        }\n+        Punct(bridge::client::Punct::new(ch, spacing))\n     }\n \n     /// Returns the value of this punctuation character as `char`.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn as_char(&self) -> char {\n-        self.ch\n+        self.0.as_char()\n     }\n \n     /// Returns the spacing of this punctuation character, indicating whether it's immediately\n@@ -793,19 +759,28 @@ impl Punct {\n     /// (`Alone`) so the operator has certainly ended.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn spacing(&self) -> Spacing {\n-        self.spacing\n+        self.0.spacing()\n     }\n \n     /// Returns the span for this punctuation character.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n-        self.span\n+        Span(self.0.span())\n     }\n \n     /// Configure the span for this punctuation character.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n-        self.span = span;\n+        self.0 = self.0.with_span(span.0);\n+    }\n+}\n+\n+// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// based on it (the reverse of the usual relationship between the two).\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n+impl ToString for Punct {\n+    fn to_string(&self) -> String {\n+        TokenStream::from(TokenTree::from(self.clone())).to_string()\n     }\n }\n \n@@ -814,7 +789,7 @@ impl Punct {\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Punct {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n+        f.write_str(&self.to_string())\n     }\n }\n \n@@ -832,16 +807,7 @@ impl fmt::Debug for Punct {\n /// An identifier (`ident`).\n #[derive(Clone)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-pub struct Ident {\n-    sym: Symbol,\n-    span: Span,\n-    is_raw: bool,\n-}\n-\n-#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-impl !Send for Ident {}\n-#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-impl !Sync for Ident {}\n+pub struct Ident(bridge::client::Ident);\n \n impl Ident {\n     fn is_valid(string: &str) -> bool {\n@@ -878,7 +844,7 @@ impl Ident {\n         if !Ident::is_valid(string) {\n             panic!(\"`{:?}` is not a valid identifier\", string)\n         }\n-        Ident::new_maybe_raw(string, span, false)\n+        Ident(bridge::client::Ident::new(string, span.0, false))\n     }\n \n     /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n@@ -887,20 +853,29 @@ impl Ident {\n         if !Ident::is_valid(string) {\n             panic!(\"`{:?}` is not a valid identifier\", string)\n         }\n-        Ident::new_maybe_raw(string, span, true)\n+        Ident(bridge::client::Ident::new(string, span.0, true))\n     }\n \n     /// Returns the span of this `Ident`, encompassing the entire string returned\n     /// by `as_str`.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n-        self.span\n+        Span(self.0.span())\n     }\n \n     /// Configures the span of this `Ident`, possibly changing its hygiene context.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n-        self.span = span;\n+        self.0 = self.0.with_span(span.0);\n+    }\n+}\n+\n+// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// based on it (the reverse of the usual relationship between the two).\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n+impl ToString for Ident {\n+    fn to_string(&self) -> String {\n+        TokenStream::from(TokenTree::from(self.clone())).to_string()\n     }\n }\n \n@@ -909,7 +884,7 @@ impl Ident {\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n+        f.write_str(&self.to_string())\n     }\n }\n \n@@ -927,19 +902,9 @@ impl fmt::Debug for Ident {\n /// character (`'a'`), byte character (`b'a'`), an integer or floating point number\n /// with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n /// Boolean literals like `true` and `false` do not belong here, they are `Ident`s.\n-// FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n-#[derive(Clone, Debug)]\n-#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-pub struct Literal {\n-    lit: token::Lit,\n-    suffix: Option<Symbol>,\n-    span: Span,\n-}\n-\n-#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-impl !Send for Literal {}\n+#[derive(Clone)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-impl !Sync for Literal {}\n+pub struct Literal(bridge::client::Literal);\n \n macro_rules! suffixed_int_literals {\n     ($($name:ident => $kind:ident,)*) => ($(\n@@ -956,11 +921,7 @@ macro_rules! suffixed_int_literals {\n         /// below.\n         #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n         pub fn $name(n: $kind) -> Literal {\n-            Literal {\n-                lit: token::Lit::Integer(Symbol::intern(&n.to_string())),\n-                suffix: Some(Symbol::intern(stringify!($kind))),\n-                span: Span::call_site(),\n-            }\n+            Literal(bridge::client::Literal::typed_integer(&n.to_string(), stringify!($kind)))\n         }\n     )*)\n }\n@@ -982,11 +943,7 @@ macro_rules! unsuffixed_int_literals {\n         /// below.\n         #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n         pub fn $name(n: $kind) -> Literal {\n-            Literal {\n-                lit: token::Lit::Integer(Symbol::intern(&n.to_string())),\n-                suffix: None,\n-                span: Span::call_site(),\n-            }\n+            Literal(bridge::client::Literal::integer(&n.to_string()))\n         }\n     )*)\n }\n@@ -1039,11 +996,7 @@ impl Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n         }\n-        Literal {\n-            lit: token::Lit::Float(Symbol::intern(&n.to_string())),\n-            suffix: None,\n-            span: Span::call_site(),\n-        }\n+        Literal(bridge::client::Literal::float(&n.to_string()))\n     }\n \n     /// Creates a new suffixed floating-point literal.\n@@ -1064,11 +1017,7 @@ impl Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n         }\n-        Literal {\n-            lit: token::Lit::Float(Symbol::intern(&n.to_string())),\n-            suffix: Some(Symbol::intern(\"f32\")),\n-            span: Span::call_site(),\n-        }\n+        Literal(bridge::client::Literal::f32(&n.to_string()))\n     }\n \n     /// Creates a new unsuffixed floating-point literal.\n@@ -1088,11 +1037,7 @@ impl Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n         }\n-        Literal {\n-            lit: token::Lit::Float(Symbol::intern(&n.to_string())),\n-            suffix: None,\n-            span: Span::call_site(),\n-        }\n+        Literal(bridge::client::Literal::float(&n.to_string()))\n     }\n \n     /// Creates a new suffixed floating-point literal.\n@@ -1113,61 +1058,37 @@ impl Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n         }\n-        Literal {\n-            lit: token::Lit::Float(Symbol::intern(&n.to_string())),\n-            suffix: Some(Symbol::intern(\"f64\")),\n-            span: Span::call_site(),\n-        }\n+        Literal(bridge::client::Literal::f64(&n.to_string()))\n     }\n \n     /// String literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn string(string: &str) -> Literal {\n-        let mut escaped = String::new();\n-        for ch in string.chars() {\n-            escaped.extend(ch.escape_debug());\n-        }\n-        Literal {\n-            lit: token::Lit::Str_(Symbol::intern(&escaped)),\n-            suffix: None,\n-            span: Span::call_site(),\n-        }\n+        Literal(bridge::client::Literal::string(string))\n     }\n \n     /// Character literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn character(ch: char) -> Literal {\n-        let mut escaped = String::new();\n-        escaped.extend(ch.escape_unicode());\n-        Literal {\n-            lit: token::Lit::Char(Symbol::intern(&escaped)),\n-            suffix: None,\n-            span: Span::call_site(),\n-        }\n+        Literal(bridge::client::Literal::character(ch))\n     }\n \n     /// Byte string literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn byte_string(bytes: &[u8]) -> Literal {\n-        let string = bytes.iter().cloned().flat_map(ascii::escape_default)\n-            .map(Into::<char>::into).collect::<String>();\n-        Literal {\n-            lit: token::Lit::ByteStr(Symbol::intern(&string)),\n-            suffix: None,\n-            span: Span::call_site(),\n-        }\n+        Literal(bridge::client::Literal::byte_string(bytes))\n     }\n \n     /// Returns the span encompassing this literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n-        self.span\n+        Span(self.0.span())\n     }\n \n     /// Configures the span associated for this literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n-        self.span = span;\n+        self.0.set_span(span.0);\n     }\n \n     /// Returns a `Span` that is a subset of `self.span()` containing only the\n@@ -1183,35 +1104,28 @@ impl Literal {\n     // was 'c' or whether it was '\\u{63}'.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span> {\n-        let inner = self.span().0;\n-        let length = inner.hi().to_usize() - inner.lo().to_usize();\n-\n-        let start = match range.start_bound() {\n-            Bound::Included(&lo) => lo,\n-            Bound::Excluded(&lo) => lo + 1,\n-            Bound::Unbounded => 0,\n-        };\n-\n-        let end = match range.end_bound() {\n-            Bound::Included(&hi) => hi + 1,\n-            Bound::Excluded(&hi) => hi,\n-            Bound::Unbounded => length,\n-        };\n-\n-        // Bounds check the values, preventing addition overflow and OOB spans.\n-        if start > u32::max_value() as usize\n-            || end > u32::max_value() as usize\n-            || (u32::max_value() - start as u32) < inner.lo().to_u32()\n-            || (u32::max_value() - end as u32) < inner.lo().to_u32()\n-            || start >= end\n-            || end > length\n-        {\n-            return None;\n+        // HACK(eddyb) something akin to `Option::cloned`, but for `Bound<&T>`.\n+        fn cloned_bound<T: Clone>(bound: Bound<&T>) -> Bound<T> {\n+            match bound {\n+                Bound::Included(x) => Bound::Included(x.clone()),\n+                Bound::Excluded(x) => Bound::Excluded(x.clone()),\n+                Bound::Unbounded => Bound::Unbounded,\n+            }\n         }\n \n-        let new_lo = inner.lo() + BytePos::from_usize(start);\n-        let new_hi = inner.lo() + BytePos::from_usize(end);\n-        Some(Span(inner.with_lo(new_lo).with_hi(new_hi)))\n+        self.0.subspan(\n+            cloned_bound(range.start_bound()),\n+            cloned_bound(range.end_bound()),\n+        ).map(Span)\n+    }\n+}\n+\n+// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// based on it (the reverse of the usual relationship between the two).\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n+impl ToString for Literal {\n+    fn to_string(&self) -> String {\n+        TokenStream::from(TokenTree::from(self.clone())).to_string()\n     }\n }\n \n@@ -1220,7 +1134,15 @@ impl Literal {\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Literal {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n+impl fmt::Debug for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n+        self.0.fmt(f)\n     }\n }\n \n@@ -1239,60 +1161,21 @@ pub mod __internal {\n     use std::cell::Cell;\n     use std::ptr;\n \n-    use syntax::ast;\n+    use syntax::errors::DiagnosticBuilder;\n     use syntax::ext::base::ExtCtxt;\n-    use syntax::ptr::P;\n-    use syntax::parse::{self, ParseSess};\n-    use syntax::parse::token::{self, Token};\n-    use syntax::tokenstream;\n-    use syntax_pos::{BytePos, Loc, DUMMY_SP};\n+    use syntax::parse::ParseSess;\n+    use syntax_pos::{BytePos, Loc, DUMMY_SP, Span};\n     use syntax_pos::hygiene::{SyntaxContext, Transparency};\n \n-    use super::{TokenStream, LexError, Span};\n+    use super::LexError;\n \n     pub fn lookup_char_pos(pos: BytePos) -> Loc {\n         with_sess(|sess, _| sess.source_map().lookup_char_pos(pos))\n     }\n \n-    pub fn new_token_stream(item: P<ast::Item>) -> TokenStream {\n-        let token = Token::interpolated(token::NtItem(item));\n-        TokenStream(tokenstream::TokenTree::Token(DUMMY_SP, token).into())\n-    }\n-\n-    pub fn token_stream_wrap(inner: tokenstream::TokenStream) -> TokenStream {\n-        TokenStream(inner)\n-    }\n-\n-    pub fn token_stream_parse_items(stream: TokenStream) -> Result<Vec<P<ast::Item>>, LexError> {\n-        with_sess(move |sess, _| {\n-            let mut parser = parse::stream_to_parser(sess, stream.0);\n-            let mut items = Vec::new();\n-\n-            while let Some(item) = try!(parser.parse_item().map_err(super::parse_to_lex_err)) {\n-                items.push(item)\n-            }\n-\n-            Ok(items)\n-        })\n-    }\n-\n-    pub fn token_stream_inner(stream: TokenStream) -> tokenstream::TokenStream {\n-        stream.0\n-    }\n-\n-    pub trait Registry {\n-        fn register_custom_derive(&mut self,\n-                                  trait_name: &str,\n-                                  expand: fn(TokenStream) -> TokenStream,\n-                                  attributes: &[&'static str]);\n-\n-        fn register_attr_proc_macro(&mut self,\n-                                    name: &str,\n-                                    expand: fn(TokenStream, TokenStream) -> TokenStream);\n-\n-        fn register_bang_proc_macro(&mut self,\n-                                    name: &str,\n-                                    expand: fn(TokenStream) -> TokenStream);\n+    pub fn parse_to_lex_err(mut err: DiagnosticBuilder) -> LexError {\n+        err.cancel();\n+        LexError { _inner: () }\n     }\n \n     #[derive(Clone, Copy)]\n@@ -1311,7 +1194,7 @@ pub mod __internal {\n     thread_local! {\n         static CURRENT_SESS: Cell<ProcMacroSess> = Cell::new(ProcMacroSess {\n             parse_sess: ptr::null(),\n-            data: ProcMacroData { def_site: Span(DUMMY_SP), call_site: Span(DUMMY_SP) },\n+            data: ProcMacroData { def_site: DUMMY_SP, call_site: DUMMY_SP },\n         });\n     }\n \n@@ -1331,10 +1214,9 @@ pub mod __internal {\n \n             // No way to determine def location for a proc macro right now, so use call location.\n             let location = cx.current_expansion.mark.expn_info().unwrap().call_site;\n-            let to_span = |transparency| Span(location.with_ctxt(\n+            let to_span = |transparency| location.with_ctxt(\n                 SyntaxContext::empty().apply_mark_with_transparency(cx.current_expansion.mark,\n-                                                                    transparency))\n-            );\n+                                                                    transparency));\n             p.set(ProcMacroSess {\n                 parse_sess: cx.parse_sess,\n                 data: ProcMacroData {\n@@ -1361,8 +1243,3 @@ pub mod __internal {\n         f(unsafe { &*sess.parse_sess }, &sess.data)\n     }\n }\n-\n-fn parse_to_lex_err(mut err: DiagnosticBuilder) -> LexError {\n-    err.cancel();\n-    LexError { _inner: () }\n-}"}, {"sha": "a58de36e0ad73cba963efecc92957e41be24e0e9", "filename": "src/libproc_macro/rustc.rs", "status": "modified", "additions": 531, "deletions": 100, "changes": 631, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibproc_macro%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Frustc.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -8,31 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {Delimiter, Level, Spacing, Span, __internal};\n-use {Group, Ident, Literal, Punct, TokenTree};\n+use bridge::{server, TokenTree};\n+use {Delimiter, Level, LineColumn, Spacing, __internal};\n \n-use rustc_errors as errors;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_errors::{self as errors, Diagnostic, DiagnosticBuilder};\n+use std::ascii;\n+use std::ops::Bound;\n use syntax::ast;\n use syntax::parse::lexer::comments;\n-use syntax::parse::token;\n-use syntax::tokenstream;\n+use syntax::parse::{self, token};\n+use syntax::tokenstream::{self, DelimSpan, TokenStream};\n use syntax_pos::symbol::{keywords, Symbol};\n-\n-impl Ident {\n-    pub(crate) fn new_maybe_raw(string: &str, span: Span, is_raw: bool) -> Ident {\n-        let sym = Symbol::intern(string);\n-        if is_raw\n-            && (sym == keywords::Underscore.name()\n-                || ast::Ident::with_empty_ctxt(sym).is_path_segment_keyword())\n-        {\n-            panic!(\"`{:?}` is not a valid raw identifier\", string)\n-        }\n-        Ident { sym, span, is_raw }\n-    }\n-}\n+use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n \n impl Delimiter {\n-    pub(crate) fn from_internal(delim: token::DelimToken) -> Delimiter {\n+    fn from_internal(delim: token::DelimToken) -> Delimiter {\n         match delim {\n             token::Paren => Delimiter::Parenthesis,\n             token::Brace => Delimiter::Brace,\n@@ -41,7 +32,7 @@ impl Delimiter {\n         }\n     }\n \n-    pub(crate) fn to_internal(self) -> token::DelimToken {\n+    fn to_internal(self) -> token::DelimToken {\n         match self {\n             Delimiter::Parenthesis => token::Paren,\n             Delimiter::Brace => token::Brace,\n@@ -51,48 +42,52 @@ impl Delimiter {\n     }\n }\n \n-impl TokenTree {\n-    pub(crate) fn from_internal(\n-        stream: tokenstream::TokenStream,\n-        stack: &mut Vec<TokenTree>,\n-    ) -> TokenTree {\n+impl TokenTree<Group, Punct, Ident, Literal> {\n+    fn from_internal(stream: TokenStream, stack: &mut Vec<Self>) -> Self {\n         use syntax::parse::token::*;\n \n-        let (tree, is_joint) = stream.as_tree();\n+        let (tree, joint) = stream.as_tree();\n         let (span, token) = match tree {\n-            tokenstream::TokenTree::Token(span, token) => (span, token),\n             tokenstream::TokenTree::Delimited(span, delimed) => {\n                 let delimiter = Delimiter::from_internal(delimed.delim);\n-                let mut g = Group::new(delimiter, ::TokenStream(delimed.tts.into()));\n-                g.span = span;\n-                return g.into();\n+                return TokenTree::Group(Group {\n+                    delimiter,\n+                    stream: delimed.tts.into(),\n+                    span,\n+                });\n             }\n+            tokenstream::TokenTree::Token(span, token) => (span, token),\n         };\n \n-        let op_kind = if is_joint {\n-            Spacing::Joint\n-        } else {\n-            Spacing::Alone\n-        };\n         macro_rules! tt {\n-            ($e:expr) => {{\n-                let mut x = TokenTree::from($e);\n-                x.set_span(Span(span));\n-                x\n-            }};\n+            ($ty:ident { $($field:ident $(: $value:expr)*),+ $(,)* }) => (\n+                TokenTree::$ty(self::$ty {\n+                    $($field $(: $value)*,)*\n+                    span,\n+                })\n+            )\n         }\n         macro_rules! op {\n             ($a:expr) => {\n-                tt!(Punct::new($a, op_kind))\n+                tt!(Punct { ch: $a, joint })\n             };\n             ($a:expr, $b:expr) => {{\n-                stack.push(tt!(Punct::new($b, op_kind)));\n-                tt!(Punct::new($a, Spacing::Joint))\n+                stack.push(tt!(Punct { ch: $b, joint }));\n+                tt!(Punct {\n+                    ch: $a,\n+                    joint: true\n+                })\n             }};\n             ($a:expr, $b:expr, $c:expr) => {{\n-                stack.push(tt!(Punct::new($c, op_kind)));\n-                stack.push(tt!(Punct::new($b, Spacing::Joint)));\n-                tt!(Punct::new($a, Spacing::Joint))\n+                stack.push(tt!(Punct { ch: $c, joint }));\n+                stack.push(tt!(Punct {\n+                    ch: $b,\n+                    joint: true\n+                }));\n+                tt!(Punct {\n+                    ch: $a,\n+                    joint: true\n+                })\n             }};\n         }\n \n@@ -145,37 +140,61 @@ impl TokenTree {\n             Question => op!('?'),\n             SingleQuote => op!('\\''),\n \n-            Ident(ident, false) => tt!(self::Ident::new(&ident.as_str(), Span(span))),\n-            Ident(ident, true) => tt!(self::Ident::new_raw(&ident.as_str(), Span(span))),\n+            Ident(ident, is_raw) => tt!(Ident {\n+                sym: ident.name,\n+                is_raw\n+            }),\n             Lifetime(ident) => {\n                 let ident = ident.without_first_quote();\n-                stack.push(tt!(self::Ident::new(&ident.as_str(), Span(span))));\n-                tt!(Punct::new('\\'', Spacing::Joint))\n+                stack.push(tt!(Ident {\n+                    sym: ident.name,\n+                    is_raw: false\n+                }));\n+                tt!(Punct {\n+                    ch: '\\'',\n+                    joint: true\n+                })\n             }\n-            Literal(lit, suffix) => tt!(self::Literal {\n-                lit,\n-                suffix,\n-                span: Span(span)\n-            }),\n+            Literal(lit, suffix) => tt!(Literal { lit, suffix }),\n             DocComment(c) => {\n                 let style = comments::doc_comment_style(&c.as_str());\n                 let stripped = comments::strip_doc_comment_decoration(&c.as_str());\n+                let mut escaped = String::new();\n+                for ch in stripped.chars() {\n+                    escaped.extend(ch.escape_debug());\n+                }\n                 let stream = vec![\n-                    tt!(self::Ident::new(\"doc\", Span(span))),\n-                    tt!(Punct::new('=', Spacing::Alone)),\n-                    tt!(self::Literal::string(&stripped)),\n-                ].into_iter()\n-                    .collect();\n-                stack.push(tt!(Group::new(Delimiter::Bracket, stream)));\n+                    Ident(ast::Ident::new(Symbol::intern(\"doc\"), span), false),\n+                    Eq,\n+                    Literal(Lit::Str_(Symbol::intern(&escaped)), None),\n+                ]\n+                .into_iter()\n+                .map(|token| tokenstream::TokenTree::Token(span, token))\n+                .collect();\n+                stack.push(TokenTree::Group(Group {\n+                    delimiter: Delimiter::Bracket,\n+                    stream,\n+                    span: DelimSpan::from_single(span),\n+                }));\n                 if style == ast::AttrStyle::Inner {\n-                    stack.push(tt!(Punct::new('!', Spacing::Alone)));\n+                    stack.push(tt!(Punct {\n+                        ch: '!',\n+                        joint: false\n+                    }));\n                 }\n-                tt!(Punct::new('#', Spacing::Alone))\n+                tt!(Punct {\n+                    ch: '#',\n+                    joint: false\n+                })\n             }\n \n             Interpolated(_) => __internal::with_sess(|sess, _| {\n-                let tts = token.interpolated_to_tokenstream(sess, span);\n-                tt!(Group::new(Delimiter::None, ::TokenStream(tts)))\n+                let stream = token.interpolated_to_tokenstream(sess, span);\n+                TokenTree::Group(Group {\n+                    delimiter: Delimiter::None,\n+                    stream,\n+                    span: DelimSpan::from_single(span),\n+                })\n             }),\n \n             DotEq => op!('.', '='),\n@@ -184,56 +203,55 @@ impl TokenTree {\n         }\n     }\n \n-    pub(crate) fn to_internal(self) -> tokenstream::TokenStream {\n+    fn to_internal(self) -> TokenStream {\n         use syntax::parse::token::*;\n-        use syntax::tokenstream::{Delimited, TokenTree};\n-\n-        let (ch, kind, span) = match self {\n-            self::TokenTree::Punct(tt) => (tt.as_char(), tt.spacing(), tt.span()),\n-            self::TokenTree::Group(tt) => {\n-                return TokenTree::Delimited(\n-                    tt.span,\n-                    Delimited {\n-                        delim: tt.delimiter.to_internal(),\n-                        tts: tt.stream.0.into(),\n+\n+        let (ch, joint, span) = match self {\n+            TokenTree::Punct(Punct { ch, joint, span }) => (ch, joint, span),\n+            TokenTree::Group(Group {\n+                delimiter,\n+                stream,\n+                span,\n+            }) => {\n+                return tokenstream::TokenTree::Delimited(\n+                    span,\n+                    tokenstream::Delimited {\n+                        delim: delimiter.to_internal(),\n+                        tts: stream.into(),\n                     },\n-                ).into();\n+                )\n+                .into();\n             }\n-            self::TokenTree::Ident(tt) => {\n-                let token = Ident(ast::Ident::new(tt.sym, tt.span.0), tt.is_raw);\n-                return TokenTree::Token(tt.span.0, token).into();\n+            TokenTree::Ident(self::Ident { sym, span, is_raw }) => {\n+                let token = Ident(ast::Ident::new(sym, span), is_raw);\n+                return tokenstream::TokenTree::Token(span, token).into();\n             }\n-            self::TokenTree::Literal(self::Literal {\n+            TokenTree::Literal(self::Literal {\n                 lit: Lit::Integer(ref a),\n                 suffix,\n                 span,\n-            })\n-                if a.as_str().starts_with(\"-\") =>\n-            {\n+            }) if a.as_str().starts_with(\"-\") => {\n                 let minus = BinOp(BinOpToken::Minus);\n                 let integer = Symbol::intern(&a.as_str()[1..]);\n                 let integer = Literal(Lit::Integer(integer), suffix);\n-                let a = TokenTree::Token(span.0, minus);\n-                let b = TokenTree::Token(span.0, integer);\n+                let a = tokenstream::TokenTree::Token(span, minus);\n+                let b = tokenstream::TokenTree::Token(span, integer);\n                 return vec![a, b].into_iter().collect();\n             }\n-            self::TokenTree::Literal(self::Literal {\n+            TokenTree::Literal(self::Literal {\n                 lit: Lit::Float(ref a),\n                 suffix,\n                 span,\n-            })\n-                if a.as_str().starts_with(\"-\") =>\n-            {\n+            }) if a.as_str().starts_with(\"-\") => {\n                 let minus = BinOp(BinOpToken::Minus);\n                 let float = Symbol::intern(&a.as_str()[1..]);\n                 let float = Literal(Lit::Float(float), suffix);\n-                let a = TokenTree::Token(span.0, minus);\n-                let b = TokenTree::Token(span.0, float);\n+                let a = tokenstream::TokenTree::Token(span, minus);\n+                let b = tokenstream::TokenTree::Token(span, float);\n                 return vec![a, b].into_iter().collect();\n             }\n-            self::TokenTree::Literal(tt) => {\n-                let token = Literal(tt.lit, tt.suffix);\n-                return TokenTree::Token(tt.span.0, token).into();\n+            TokenTree::Literal(self::Literal { lit, suffix, span }) => {\n+                return tokenstream::TokenTree::Token(span, Literal(lit, suffix)).into()\n             }\n         };\n \n@@ -263,16 +281,17 @@ impl TokenTree {\n             _ => unreachable!(),\n         };\n \n-        let tree = TokenTree::Token(span.0, token);\n-        match kind {\n-            Spacing::Alone => tree.into(),\n-            Spacing::Joint => tree.joint(),\n+        let tree = tokenstream::TokenTree::Token(span, token);\n+        if joint {\n+            tree.joint()\n+        } else {\n+            tree.into()\n         }\n     }\n }\n \n impl Level {\n-    pub(crate) fn to_internal(self) -> errors::Level {\n+    fn to_internal(self) -> errors::Level {\n         match self {\n             Level::Error => errors::Level::Error,\n             Level::Warning => errors::Level::Warning,\n@@ -281,3 +300,415 @@ impl Level {\n         }\n     }\n }\n+\n+#[derive(Clone)]\n+pub struct TokenStreamIter {\n+    cursor: tokenstream::Cursor,\n+    stack: Vec<TokenTree<Group, Punct, Ident, Literal>>,\n+}\n+\n+#[derive(Clone)]\n+pub struct Group {\n+    delimiter: Delimiter,\n+    stream: TokenStream,\n+    span: DelimSpan,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Punct {\n+    ch: char,\n+    // NB. not using `Spacing` here because it doesn't implement `Hash`.\n+    joint: bool,\n+    span: Span,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Ident {\n+    sym: Symbol,\n+    span: Span,\n+    is_raw: bool,\n+}\n+\n+// FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n+#[derive(Clone, Debug)]\n+pub struct Literal {\n+    lit: token::Lit,\n+    suffix: Option<Symbol>,\n+    span: Span,\n+}\n+\n+pub struct Rustc;\n+\n+impl server::Types for Rustc {\n+    type TokenStream = TokenStream;\n+    type TokenStreamBuilder = tokenstream::TokenStreamBuilder;\n+    type TokenStreamIter = TokenStreamIter;\n+    type Group = Group;\n+    type Punct = Punct;\n+    type Ident = Ident;\n+    type Literal = Literal;\n+    type SourceFile = Lrc<SourceFile>;\n+    type MultiSpan = Vec<Span>;\n+    type Diagnostic = Diagnostic;\n+    type Span = Span;\n+}\n+\n+impl server::TokenStream for Rustc {\n+    fn new(&mut self) -> Self::TokenStream {\n+        TokenStream::empty()\n+    }\n+    fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n+        stream.is_empty()\n+    }\n+    fn from_str(&mut self, src: &str) -> Self::TokenStream {\n+        ::__internal::with_sess(|sess, data| {\n+            parse::parse_stream_from_source_str(\n+                FileName::ProcMacroSourceCode,\n+                src.to_string(),\n+                sess,\n+                Some(data.call_site),\n+            )\n+        })\n+    }\n+    fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n+        stream.to_string()\n+    }\n+    fn from_token_tree(\n+        &mut self,\n+        tree: TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>,\n+    ) -> Self::TokenStream {\n+        tree.to_internal()\n+    }\n+    fn into_iter(&mut self, stream: Self::TokenStream) -> Self::TokenStreamIter {\n+        TokenStreamIter {\n+            cursor: stream.trees(),\n+            stack: vec![],\n+        }\n+    }\n+}\n+\n+impl server::TokenStreamBuilder for Rustc {\n+    fn new(&mut self) -> Self::TokenStreamBuilder {\n+        tokenstream::TokenStreamBuilder::new()\n+    }\n+    fn push(&mut self, builder: &mut Self::TokenStreamBuilder, stream: Self::TokenStream) {\n+        builder.push(stream);\n+    }\n+    fn build(&mut self, builder: Self::TokenStreamBuilder) -> Self::TokenStream {\n+        builder.build()\n+    }\n+}\n+\n+impl server::TokenStreamIter for Rustc {\n+    fn next(\n+        &mut self,\n+        iter: &mut Self::TokenStreamIter,\n+    ) -> Option<TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n+        loop {\n+            let tree = iter.stack.pop().or_else(|| {\n+                let next = iter.cursor.next_as_stream()?;\n+                Some(TokenTree::from_internal(next, &mut iter.stack))\n+            })?;\n+            // HACK: The condition \"dummy span + group with empty delimiter\" represents an AST\n+            // fragment approximately converted into a token stream. This may happen, for\n+            // example, with inputs to proc macro attributes, including derives. Such \"groups\"\n+            // need to flattened during iteration over stream's token trees.\n+            // Eventually this needs to be removed in favor of keeping original token trees\n+            // and not doing the roundtrip through AST.\n+            if let TokenTree::Group(ref group) = tree {\n+                if group.delimiter == Delimiter::None && group.span.entire().is_dummy() {\n+                    iter.cursor.insert(group.stream.clone());\n+                    continue;\n+                }\n+            }\n+            return Some(tree);\n+        }\n+    }\n+}\n+\n+impl server::Group for Rustc {\n+    fn new(&mut self, delimiter: Delimiter, stream: Self::TokenStream) -> Self::Group {\n+        Group {\n+            delimiter,\n+            stream,\n+            span: DelimSpan::from_single(server::Span::call_site(self)),\n+        }\n+    }\n+    fn delimiter(&mut self, group: &Self::Group) -> Delimiter {\n+        group.delimiter\n+    }\n+    fn stream(&mut self, group: &Self::Group) -> Self::TokenStream {\n+        group.stream.clone()\n+    }\n+    fn span(&mut self, group: &Self::Group) -> Self::Span {\n+        group.span.entire()\n+    }\n+    fn span_open(&mut self, group: &Self::Group) -> Self::Span {\n+        group.span.open\n+    }\n+    fn span_close(&mut self, group: &Self::Group) -> Self::Span {\n+        group.span.close\n+    }\n+    fn set_span(&mut self, group: &mut Self::Group, span: Self::Span) {\n+        group.span = DelimSpan::from_single(span);\n+    }\n+}\n+\n+impl server::Punct for Rustc {\n+    fn new(&mut self, ch: char, spacing: Spacing) -> Self::Punct {\n+        Punct {\n+            ch,\n+            joint: spacing == Spacing::Joint,\n+            span: server::Span::call_site(self),\n+        }\n+    }\n+    fn as_char(&mut self, punct: Self::Punct) -> char {\n+        punct.ch\n+    }\n+    fn spacing(&mut self, punct: Self::Punct) -> Spacing {\n+        if punct.joint {\n+            Spacing::Joint\n+        } else {\n+            Spacing::Alone\n+        }\n+    }\n+    fn span(&mut self, punct: Self::Punct) -> Self::Span {\n+        punct.span\n+    }\n+    fn with_span(&mut self, punct: Self::Punct, span: Self::Span) -> Self::Punct {\n+        Punct { span, ..punct }\n+    }\n+}\n+\n+impl server::Ident for Rustc {\n+    fn new(&mut self, string: &str, span: Self::Span, is_raw: bool) -> Self::Ident {\n+        let sym = Symbol::intern(string);\n+        if is_raw\n+            && (sym == keywords::Underscore.name()\n+                || ast::Ident::with_empty_ctxt(sym).is_path_segment_keyword())\n+        {\n+            panic!(\"`{:?}` is not a valid raw identifier\", string)\n+        }\n+        Ident { sym, span, is_raw }\n+    }\n+    fn span(&mut self, ident: Self::Ident) -> Self::Span {\n+        ident.span\n+    }\n+    fn with_span(&mut self, ident: Self::Ident, span: Self::Span) -> Self::Ident {\n+        Ident { span, ..ident }\n+    }\n+}\n+\n+impl server::Literal for Rustc {\n+    // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n+    fn debug(&mut self, literal: &Self::Literal) -> String {\n+        format!(\"{:?}\", literal)\n+    }\n+    fn integer(&mut self, n: &str) -> Self::Literal {\n+        Literal {\n+            lit: token::Lit::Integer(Symbol::intern(n)),\n+            suffix: None,\n+            span: server::Span::call_site(self),\n+        }\n+    }\n+    fn typed_integer(&mut self, n: &str, kind: &str) -> Self::Literal {\n+        Literal {\n+            lit: token::Lit::Integer(Symbol::intern(n)),\n+            suffix: Some(Symbol::intern(kind)),\n+            span: server::Span::call_site(self),\n+        }\n+    }\n+    fn float(&mut self, n: &str) -> Self::Literal {\n+        Literal {\n+            lit: token::Lit::Float(Symbol::intern(n)),\n+            suffix: None,\n+            span: server::Span::call_site(self),\n+        }\n+    }\n+    fn f32(&mut self, n: &str) -> Self::Literal {\n+        Literal {\n+            lit: token::Lit::Float(Symbol::intern(n)),\n+            suffix: Some(Symbol::intern(\"f32\")),\n+            span: server::Span::call_site(self),\n+        }\n+    }\n+    fn f64(&mut self, n: &str) -> Self::Literal {\n+        Literal {\n+            lit: token::Lit::Float(Symbol::intern(n)),\n+            suffix: Some(Symbol::intern(\"f64\")),\n+            span: server::Span::call_site(self),\n+        }\n+    }\n+    fn string(&mut self, string: &str) -> Self::Literal {\n+        let mut escaped = String::new();\n+        for ch in string.chars() {\n+            escaped.extend(ch.escape_debug());\n+        }\n+        Literal {\n+            lit: token::Lit::Str_(Symbol::intern(&escaped)),\n+            suffix: None,\n+            span: server::Span::call_site(self),\n+        }\n+    }\n+    fn character(&mut self, ch: char) -> Self::Literal {\n+        let mut escaped = String::new();\n+        escaped.extend(ch.escape_unicode());\n+        Literal {\n+            lit: token::Lit::Char(Symbol::intern(&escaped)),\n+            suffix: None,\n+            span: server::Span::call_site(self),\n+        }\n+    }\n+    fn byte_string(&mut self, bytes: &[u8]) -> Self::Literal {\n+        let string = bytes\n+            .iter()\n+            .cloned()\n+            .flat_map(ascii::escape_default)\n+            .map(Into::<char>::into)\n+            .collect::<String>();\n+        Literal {\n+            lit: token::Lit::ByteStr(Symbol::intern(&string)),\n+            suffix: None,\n+            span: server::Span::call_site(self),\n+        }\n+    }\n+    fn span(&mut self, literal: &Self::Literal) -> Self::Span {\n+        literal.span\n+    }\n+    fn set_span(&mut self, literal: &mut Self::Literal, span: Self::Span) {\n+        literal.span = span;\n+    }\n+    fn subspan(\n+        &mut self,\n+        literal: &Self::Literal,\n+        start: Bound<usize>,\n+        end: Bound<usize>,\n+    ) -> Option<Self::Span> {\n+        let span = literal.span;\n+        let length = span.hi().to_usize() - span.lo().to_usize();\n+\n+        let start = match start {\n+            Bound::Included(lo) => lo,\n+            Bound::Excluded(lo) => lo + 1,\n+            Bound::Unbounded => 0,\n+        };\n+\n+        let end = match end {\n+            Bound::Included(hi) => hi + 1,\n+            Bound::Excluded(hi) => hi,\n+            Bound::Unbounded => length,\n+        };\n+\n+        // Bounds check the values, preventing addition overflow and OOB spans.\n+        if start > u32::max_value() as usize\n+            || end > u32::max_value() as usize\n+            || (u32::max_value() - start as u32) < span.lo().to_u32()\n+            || (u32::max_value() - end as u32) < span.lo().to_u32()\n+            || start >= end\n+            || end > length\n+        {\n+            return None;\n+        }\n+\n+        let new_lo = span.lo() + BytePos::from_usize(start);\n+        let new_hi = span.lo() + BytePos::from_usize(end);\n+        Some(span.with_lo(new_lo).with_hi(new_hi))\n+    }\n+}\n+\n+impl server::SourceFile for Rustc {\n+    fn eq(&mut self, file1: &Self::SourceFile, file2: &Self::SourceFile) -> bool {\n+        Lrc::ptr_eq(file1, file2)\n+    }\n+    fn path(&mut self, file: &Self::SourceFile) -> String {\n+        match file.name {\n+            FileName::Real(ref path) => path\n+                .to_str()\n+                .expect(\"non-UTF8 file path in `proc_macro::SourceFile::path`\")\n+                .to_string(),\n+            _ => file.name.to_string(),\n+        }\n+    }\n+    fn is_real(&mut self, file: &Self::SourceFile) -> bool {\n+        file.is_real_file()\n+    }\n+}\n+\n+impl server::MultiSpan for Rustc {\n+    fn new(&mut self) -> Self::MultiSpan {\n+        vec![]\n+    }\n+    fn push(&mut self, spans: &mut Self::MultiSpan, span: Self::Span) {\n+        spans.push(span)\n+    }\n+}\n+\n+impl server::Diagnostic for Rustc {\n+    fn new(&mut self, level: Level, msg: &str, spans: Self::MultiSpan) -> Self::Diagnostic {\n+        let mut diag = Diagnostic::new(level.to_internal(), msg);\n+        diag.set_span(MultiSpan::from_spans(spans));\n+        diag\n+    }\n+    fn sub(\n+        &mut self,\n+        diag: &mut Self::Diagnostic,\n+        level: Level,\n+        msg: &str,\n+        spans: Self::MultiSpan,\n+    ) {\n+        diag.sub(level.to_internal(), msg, MultiSpan::from_spans(spans), None);\n+    }\n+    fn emit(&mut self, diag: Self::Diagnostic) {\n+        ::__internal::with_sess(move |sess, _| {\n+            DiagnosticBuilder::new_diagnostic(&sess.span_diagnostic, diag).emit()\n+        });\n+    }\n+}\n+\n+impl server::Span for Rustc {\n+    fn debug(&mut self, span: Self::Span) -> String {\n+        format!(\"{:?} bytes({}..{})\", span.ctxt(), span.lo().0, span.hi().0)\n+    }\n+    fn def_site(&mut self) -> Self::Span {\n+        ::__internal::with_sess(|_, data| data.def_site)\n+    }\n+    fn call_site(&mut self) -> Self::Span {\n+        ::__internal::with_sess(|_, data| data.call_site)\n+    }\n+    fn source_file(&mut self, span: Self::Span) -> Self::SourceFile {\n+        ::__internal::lookup_char_pos(span.lo()).file\n+    }\n+    fn parent(&mut self, span: Self::Span) -> Option<Self::Span> {\n+        span.ctxt().outer().expn_info().map(|i| i.call_site)\n+    }\n+    fn source(&mut self, span: Self::Span) -> Self::Span {\n+        span.source_callsite()\n+    }\n+    fn start(&mut self, span: Self::Span) -> LineColumn {\n+        let loc = ::__internal::lookup_char_pos(span.lo());\n+        LineColumn {\n+            line: loc.line,\n+            column: loc.col.to_usize(),\n+        }\n+    }\n+    fn end(&mut self, span: Self::Span) -> LineColumn {\n+        let loc = ::__internal::lookup_char_pos(span.hi());\n+        LineColumn {\n+            line: loc.line,\n+            column: loc.col.to_usize(),\n+        }\n+    }\n+    fn join(&mut self, first: Self::Span, second: Self::Span) -> Option<Self::Span> {\n+        let self_loc = ::__internal::lookup_char_pos(first.lo());\n+        let other_loc = ::__internal::lookup_char_pos(second.lo());\n+\n+        if self_loc.file.name != other_loc.file.name {\n+            return None;\n+        }\n+\n+        Some(first.to(second))\n+    }\n+    fn resolved_at(&mut self, span: Self::Span, at: Self::Span) -> Self::Span {\n+        span.with_ctxt(at.ctxt())\n+    }\n+}"}, {"sha": "388bbc52c3b1a1bbb4649f020bc0601446879abd", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -596,7 +596,7 @@ define_dep_nodes!( <'tcx>\n     [] ReachableNonGenerics(CrateNum),\n     [] NativeLibraries(CrateNum),\n     [] PluginRegistrarFn(CrateNum),\n-    [] DeriveRegistrarFn(CrateNum),\n+    [] ProcMacroDeclsStatic(CrateNum),\n     [input] CrateDisambiguator(CrateNum),\n     [input] CrateHash(CrateNum),\n     [input] OriginalCrateName(CrateNum),"}, {"sha": "d1c3acc57b723b5260ceff0c672846e8dbafe0c5", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -68,7 +68,7 @@ pub struct Session {\n     /// For a library crate, this is always none\n     pub entry_fn: Once<Option<(NodeId, Span, config::EntryFnType)>>,\n     pub plugin_registrar_fn: Once<Option<ast::NodeId>>,\n-    pub derive_registrar_fn: Once<Option<ast::NodeId>>,\n+    pub proc_macro_decls_static: Once<Option<ast::NodeId>>,\n     pub default_sysroot: Option<PathBuf>,\n     /// The name of the root source file of the crate, in the local file system.\n     /// `None` means that there is no source file.\n@@ -687,9 +687,9 @@ impl Session {\n         )\n     }\n \n-    pub fn generate_derive_registrar_symbol(&self, disambiguator: CrateDisambiguator) -> String {\n+    pub fn generate_proc_macro_decls_symbol(&self, disambiguator: CrateDisambiguator) -> String {\n         format!(\n-            \"__rustc_derive_registrar_{}__\",\n+            \"__rustc_proc_macro_decls_{}__\",\n             disambiguator.to_fingerprint().to_hex()\n         )\n     }\n@@ -1146,7 +1146,7 @@ pub fn build_session_(\n         // For a library crate, this is always none\n         entry_fn: Once::new(),\n         plugin_registrar_fn: Once::new(),\n-        derive_registrar_fn: Once::new(),\n+        proc_macro_decls_static: Once::new(),\n         default_sysroot,\n         local_crate_source_file,\n         working_dir,"}, {"sha": "5d12aaeed5f7920641a3bb6efcdb7098d010503f", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -591,7 +591,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::plugin_registrar_fn<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::derive_registrar_fn<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::proc_macro_decls_static<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n         \"looking up the derive registrar for a crate\".into()\n     }"}, {"sha": "699c2d111c6397aa8acbd77bc6359f35131a0bc7", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -470,7 +470,7 @@ define_queries! { <'tcx>\n         [] fn foreign_modules: ForeignModules(CrateNum) -> Lrc<Vec<ForeignModule>>,\n \n         [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n-        [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n+        [] fn proc_macro_decls_static: ProcMacroDeclsStatic(CrateNum) -> Option<DefId>,\n         [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> CrateDisambiguator,\n         [] fn crate_hash: CrateHash(CrateNum) -> Svh,\n         [] fn original_crate_name: OriginalCrateName(CrateNum) -> Symbol,"}, {"sha": "5f33d466c4a19f2d5a36ee5ce1feac849963d83c", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -1200,7 +1200,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::ReachableNonGenerics => { force!(reachable_non_generics, krate!()); }\n         DepKind::NativeLibraries => { force!(native_libraries, krate!()); }\n         DepKind::PluginRegistrarFn => { force!(plugin_registrar_fn, krate!()); }\n-        DepKind::DeriveRegistrarFn => { force!(derive_registrar_fn, krate!()); }\n+        DepKind::ProcMacroDeclsStatic => { force!(proc_macro_decls_static, krate!()); }\n         DepKind::CrateDisambiguator => { force!(crate_disambiguator, krate!()); }\n         DepKind::CrateHash => { force!(crate_hash, krate!()); }\n         DepKind::OriginalCrateName => { force!(original_crate_name, krate!()); }"}, {"sha": "7a246af82e5fe7b14641324fcf9e17568e8629ae", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -24,7 +24,6 @@ use std::sync::mpsc::{Sender};\n use syntax_pos::{SpanData};\n use ty::TyCtxt;\n use dep_graph::{DepNode};\n-use proc_macro;\n use lazy_static;\n use session::Session;\n \n@@ -47,14 +46,13 @@ lazy_static! {\n }\n \n fn panic_hook(info: &panic::PanicInfo<'_>) {\n-    if !proc_macro::__internal::in_sess() {\n-        (*DEFAULT_HOOK)(info);\n+    (*DEFAULT_HOOK)(info);\n \n-        let backtrace = env::var_os(\"RUST_BACKTRACE\").map(|x| &x != \"0\").unwrap_or(false);\n+    let backtrace = env::var_os(\"RUST_BACKTRACE\").map(|x| &x != \"0\").unwrap_or(false);\n \n-        if backtrace {\n-            TyCtxt::try_print_query_stack();\n-        }\n+    if backtrace {\n+        TyCtxt::try_print_query_stack();\n+    }\n \n         #[cfg(windows)]\n         unsafe {\n@@ -66,7 +64,6 @@ fn panic_hook(info: &panic::PanicInfo<'_>) {\n                 DebugBreak();\n             }\n         }\n-    }\n }\n \n pub fn install_panic_hook() {"}, {"sha": "0fb2641a4f82e70242c0ebb43d7554075cf00ddf", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -157,7 +157,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         })\n         .collect();\n \n-    if let Some(id) = *tcx.sess.derive_registrar_fn.get() {\n+    if let Some(id) = *tcx.sess.proc_macro_decls_static.get() {\n         let def_id = tcx.hir.local_def_id(id);\n         reachable_non_generics.insert(def_id, SymbolExportLevel::C);\n     }"}, {"sha": "344a2525784720416e5f34ff396099184cb1b43a", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -257,9 +257,9 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n             return tcx.sess.generate_plugin_registrar_symbol(disambiguator);\n         }\n-        if *tcx.sess.derive_registrar_fn.get() == Some(id) {\n+        if *tcx.sess.proc_macro_decls_static.get() == Some(id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return tcx.sess.generate_derive_registrar_symbol(disambiguator);\n+            return tcx.sess.generate_proc_macro_decls_symbol(disambiguator);\n         }\n     }\n "}, {"sha": "c1705ad2d58ff08f8dbcf1004a78769815b862da", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -62,7 +62,7 @@ use syntax::symbol::Symbol;\n use syntax_pos::{FileName, hygiene};\n use syntax_ext;\n \n-use derive_registrar;\n+use proc_macro_decls;\n use pretty::ReplaceBodyWithLoop;\n \n use profile;\n@@ -1066,7 +1066,7 @@ where\n             let num_crate_types = crate_types.len();\n             let is_proc_macro_crate = crate_types.contains(&config::CrateType::ProcMacro);\n             let is_test_crate = sess.opts.test;\n-            syntax_ext::proc_macro_registrar::modify(\n+            syntax_ext::proc_macro_decls::modify(\n                 &sess.parse_sess,\n                 &mut resolver,\n                 krate,\n@@ -1243,8 +1243,8 @@ where\n         .set(time(sess, \"looking for plugin registrar\", || {\n             plugin::build::find_plugin_registrar(sess.diagnostic(), &hir_map)\n         }));\n-    sess.derive_registrar_fn\n-        .set(derive_registrar::find(&hir_map));\n+    sess.proc_macro_decls_static\n+        .set(proc_macro_decls::find(&hir_map));\n \n     time(sess, \"loop checking\", || loops::check_crate(sess, &hir_map));\n "}, {"sha": "b063176d3cafae9f0048f6167fa4dca8fe72a3ad", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -127,7 +127,7 @@ mod test;\n pub mod profile;\n pub mod driver;\n pub mod pretty;\n-mod derive_registrar;\n+mod proc_macro_decls;\n \n pub mod target_features {\n     use syntax::ast;"}, {"sha": "136a27b1ced471812c491c045643d6db1c0bb02a", "filename": "src/librustc_driver/proc_macro_decls.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_driver%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_driver%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fproc_macro_decls.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -17,19 +17,19 @@ use syntax::attr;\n pub fn find(hir_map: &Map) -> Option<ast::NodeId> {\n     let krate = hir_map.krate();\n \n-    let mut finder = Finder { registrar: None };\n+    let mut finder = Finder { decls: None };\n     krate.visit_all_item_likes(&mut finder);\n-    finder.registrar\n+    finder.decls\n }\n \n struct Finder {\n-    registrar: Option<ast::NodeId>,\n+    decls: Option<ast::NodeId>,\n }\n \n impl<'v> ItemLikeVisitor<'v> for Finder {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if attr::contains_name(&item.attrs, \"rustc_derive_registrar\") {\n-            self.registrar = Some(item.id);\n+        if attr::contains_name(&item.attrs, \"rustc_proc_macro_decls\") {\n+            self.decls = Some(item.id);\n         }\n     }\n ", "previous_filename": "src/librustc_driver/derive_registrar.rs"}, {"sha": "4ff29f5c04d41fa3385c0e17d29dae27c3db48ec", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 36, "deletions": 50, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -36,7 +36,6 @@ use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::edition::Edition;\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n use syntax::visit;\n@@ -231,7 +230,7 @@ impl<'a> CrateLoader<'a> {\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n-        let proc_macros = crate_root.macro_derive_registrar.map(|_| {\n+        let proc_macros = crate_root.proc_macro_decls_static.map(|_| {\n             self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n         });\n \n@@ -339,7 +338,7 @@ impl<'a> CrateLoader<'a> {\n         match result {\n             LoadResult::Previous(cnum) => {\n                 let data = self.cstore.get_crate_data(cnum);\n-                if data.root.macro_derive_registrar.is_some() {\n+                if data.root.proc_macro_decls_static.is_some() {\n                     dep_kind = DepKind::UnexportedMacrosOnly;\n                 }\n                 data.dep_kind.with_lock(|data_dep_kind| {\n@@ -431,7 +430,7 @@ impl<'a> CrateLoader<'a> {\n                           dep_kind: DepKind)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n-        if crate_root.macro_derive_registrar.is_some() {\n+        if crate_root.proc_macro_decls_static.is_some() {\n             return cstore::CrateNumMap::new();\n         }\n \n@@ -533,9 +532,8 @@ impl<'a> CrateLoader<'a> {\n     fn load_derive_macros(&mut self, root: &CrateRoot, dylib: Option<PathBuf>, span: Span)\n                           -> Vec<(ast::Name, Lrc<SyntaxExtension>)> {\n         use std::{env, mem};\n-        use proc_macro::TokenStream;\n-        use proc_macro::__internal::Registry;\n         use dynamic_lib::DynamicLibrary;\n+        use proc_macro::bridge::client::ProcMacro;\n         use syntax_ext::deriving::custom::ProcMacroDerive;\n         use syntax_ext::proc_macro_impl::{AttrProcMacro, BangProcMacro};\n \n@@ -550,61 +548,49 @@ impl<'a> CrateLoader<'a> {\n             Err(err) => self.sess.span_fatal(span, &err),\n         };\n \n-        let sym = self.sess.generate_derive_registrar_symbol(root.disambiguator);\n-        let registrar = unsafe {\n+        let sym = self.sess.generate_proc_macro_decls_symbol(root.disambiguator);\n+        let decls = unsafe {\n             let sym = match lib.symbol(&sym) {\n                 Ok(f) => f,\n                 Err(err) => self.sess.span_fatal(span, &err),\n             };\n-            mem::transmute::<*mut u8, fn(&mut dyn Registry)>(sym)\n+            *(sym as *const &[ProcMacro])\n         };\n \n-        struct MyRegistrar {\n-            extensions: Vec<(ast::Name, Lrc<SyntaxExtension>)>,\n-            edition: Edition,\n-        }\n-\n-        impl Registry for MyRegistrar {\n-            fn register_custom_derive(&mut self,\n-                                      trait_name: &str,\n-                                      expand: fn(TokenStream) -> TokenStream,\n-                                      attributes: &[&'static str]) {\n-                let attrs = attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n-                let derive = ProcMacroDerive::new(expand, attrs.clone());\n-                let derive = SyntaxExtension::ProcMacroDerive(\n-                    Box::new(derive), attrs, self.edition\n-                );\n-                self.extensions.push((Symbol::intern(trait_name), Lrc::new(derive)));\n-            }\n-\n-            fn register_attr_proc_macro(&mut self,\n-                                        name: &str,\n-                                        expand: fn(TokenStream, TokenStream) -> TokenStream) {\n-                let expand = SyntaxExtension::AttrProcMacro(\n-                    Box::new(AttrProcMacro { inner: expand }), self.edition\n-                );\n-                self.extensions.push((Symbol::intern(name), Lrc::new(expand)));\n-            }\n-\n-            fn register_bang_proc_macro(&mut self,\n-                                        name: &str,\n-                                        expand: fn(TokenStream) -> TokenStream) {\n-                let expand = SyntaxExtension::ProcMacro {\n-                    expander: Box::new(BangProcMacro { inner: expand }),\n-                    allow_internal_unstable: false,\n-                    edition: self.edition,\n-                };\n-                self.extensions.push((Symbol::intern(name), Lrc::new(expand)));\n+        let extensions = decls.iter().map(|&decl| {\n+            match decl {\n+                ProcMacro::CustomDerive { trait_name, attributes, client } => {\n+                    let attrs = attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n+                    (trait_name, SyntaxExtension::ProcMacroDerive(\n+                        Box::new(ProcMacroDerive {\n+                            client,\n+                            attrs: attrs.clone(),\n+                        }),\n+                        attrs,\n+                        root.edition,\n+                    ))\n+                }\n+                ProcMacro::Attr { name, client } => {\n+                    (name, SyntaxExtension::AttrProcMacro(\n+                        Box::new(AttrProcMacro { client }),\n+                        root.edition,\n+                    ))\n+                }\n+                ProcMacro::Bang { name, client } => {\n+                    (name, SyntaxExtension::ProcMacro {\n+                        expander: Box::new(BangProcMacro { client }),\n+                        allow_internal_unstable: false,\n+                        edition: root.edition,\n+                    })\n+                }\n             }\n-        }\n-\n-        let mut my_registrar = MyRegistrar { extensions: Vec::new(), edition: root.edition };\n-        registrar(&mut my_registrar);\n+        }).map(|(name, ext)| (Symbol::intern(name), Lrc::new(ext))).collect();\n \n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long.\n         mem::forget(lib);\n-        my_registrar.extensions\n+\n+        extensions\n     }\n \n     /// Look for a plugin registrar. Returns library path, crate"}, {"sha": "d0fa63a6163dbeb667d70afc69d8938b0c27cbec", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -203,8 +203,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n             DefId { krate: def_id.krate, index }\n         })\n     }\n-    derive_registrar_fn => {\n-        cdata.root.macro_derive_registrar.map(|index| {\n+    proc_macro_decls_static => {\n+        cdata.root.proc_macro_decls_static.map(|index| {\n             DefId { krate: def_id.krate, index }\n         })\n     }\n@@ -431,8 +431,9 @@ impl cstore::CStore {\n             use syntax::ext::base::SyntaxExtension;\n             use syntax_ext::proc_macro_impl::BangProcMacro;\n \n+            let client = ::proc_macro::bridge::client::Client::expand1(::proc_macro::quote);\n             let ext = SyntaxExtension::ProcMacro {\n-                expander: Box::new(BangProcMacro { inner: ::proc_macro::quote }),\n+                expander: Box::new(BangProcMacro { client }),\n                 allow_internal_unstable: true,\n                 edition: data.root.edition,\n             };"}, {"sha": "2736c60ffb6fa9412df5825925be77517bb89892", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -496,8 +496,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 .plugin_registrar_fn\n                 .get()\n                 .map(|id| tcx.hir.local_def_id(id).index),\n-            macro_derive_registrar: if is_proc_macro {\n-                let id = tcx.sess.derive_registrar_fn.get().unwrap();\n+            proc_macro_decls_static: if is_proc_macro {\n+                let id = tcx.sess.proc_macro_decls_static.get().unwrap();\n                 Some(tcx.hir.local_def_id(id).index)\n             } else {\n                 None"}, {"sha": "d4e51693d7edf818ecaa14291e3d2d810eeaf1fd", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -713,7 +713,7 @@ impl<'a> Context<'a> {\n \n         let root = metadata.get_root();\n         if let Some(is_proc_macro) = self.is_proc_macro {\n-            if root.macro_derive_registrar.is_some() != is_proc_macro {\n+            if root.proc_macro_decls_static.is_some() != is_proc_macro {\n                 return None;\n             }\n         }"}, {"sha": "e91d15b78c0759364d280d877dc2586c58f9b435", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -196,7 +196,7 @@ pub struct CrateRoot {\n     pub has_panic_handler: bool,\n     pub has_default_lib_allocator: bool,\n     pub plugin_registrar_fn: Option<DefIndex>,\n-    pub macro_derive_registrar: Option<DefIndex>,\n+    pub proc_macro_decls_static: Option<DefIndex>,\n \n     pub crate_deps: LazySeq<CrateDep>,\n     pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,"}, {"sha": "c93abc39ff3b9f1237085c2c992bfc4ed562090b", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -1122,8 +1122,8 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n     (\"proc_macro_attribute\", Normal, Ungated),\n     (\"proc_macro\", Normal, Ungated),\n \n-    (\"rustc_derive_registrar\", Normal, Gated(Stability::Unstable,\n-                                             \"rustc_derive_registrar\",\n+    (\"rustc_proc_macro_decls\", Normal, Gated(Stability::Unstable,\n+                                             \"rustc_proc_macro_decls\",\n                                              \"used internally by rustc\",\n                                              cfg_fn!(rustc_attrs))),\n "}, {"sha": "76826dd93e788d241e3929984bcb97273a336d27", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -8,15 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::panic;\n-\n use errors::FatalError;\n-use proc_macro::{TokenStream, __internal};\n use syntax::ast::{self, ItemKind, Attribute, Mac};\n use syntax::attr::{mark_used, mark_known};\n use syntax::source_map::Span;\n use syntax::ext::base::*;\n+use syntax::parse;\n+use syntax::parse::token::{self, Token};\n+use syntax::tokenstream;\n use syntax::visit::Visitor;\n+use syntax_pos::DUMMY_SP;\n+\n+use proc_macro_impl::EXEC_STRATEGY;\n \n struct MarkAttrs<'a>(&'a [ast::Name]);\n \n@@ -32,14 +35,10 @@ impl<'a> Visitor<'a> for MarkAttrs<'a> {\n }\n \n pub struct ProcMacroDerive {\n-    inner: fn(TokenStream) -> TokenStream,\n-    attrs: Vec<ast::Name>,\n-}\n-\n-impl ProcMacroDerive {\n-    pub fn new(inner: fn(TokenStream) -> TokenStream, attrs: Vec<ast::Name>) -> ProcMacroDerive {\n-        ProcMacroDerive { inner: inner, attrs: attrs }\n-    }\n+    pub client: ::proc_macro::bridge::client::Client<\n+        fn(::proc_macro::TokenStream) -> ::proc_macro::TokenStream,\n+    >,\n+    pub attrs: Vec<ast::Name>,\n }\n \n impl MultiItemModifier for ProcMacroDerive {\n@@ -75,21 +74,20 @@ impl MultiItemModifier for ProcMacroDerive {\n         // Mark attributes as known, and used.\n         MarkAttrs(&self.attrs).visit_item(&item);\n \n-        let input = __internal::new_token_stream(ecx.resolver.eliminate_crate_var(item));\n-        let res = __internal::set_sess(ecx, || {\n-            let inner = self.inner;\n-            panic::catch_unwind(panic::AssertUnwindSafe(|| inner(input)))\n+        let item = ecx.resolver.eliminate_crate_var(item);\n+        let token = Token::interpolated(token::NtItem(item));\n+        let input = tokenstream::TokenTree::Token(DUMMY_SP, token).into();\n+        let server = ::proc_macro::rustc::Rustc;\n+        let res = ::proc_macro::__internal::set_sess(ecx, || {\n+            self.client.run(&EXEC_STRATEGY, server, input)\n         });\n \n         let stream = match res {\n             Ok(stream) => stream,\n             Err(e) => {\n                 let msg = \"proc-macro derive panicked\";\n                 let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.downcast_ref::<String>() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-                if let Some(s) = e.downcast_ref::<&'static str>() {\n+                if let Some(s) = e.as_str() {\n                     err.help(&format!(\"message: {}\", s));\n                 }\n \n@@ -99,21 +97,32 @@ impl MultiItemModifier for ProcMacroDerive {\n         };\n \n         let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n-        __internal::set_sess(ecx, || {\n-            let msg = \"proc-macro derive produced unparseable tokens\";\n-            match __internal::token_stream_parse_items(stream) {\n-                // fail if there have been errors emitted\n-                Ok(_) if ecx.parse_sess.span_diagnostic.err_count() > error_count_before => {\n-                    ecx.struct_span_fatal(span, msg).emit();\n-                    FatalError.raise();\n+        let msg = \"proc-macro derive produced unparseable tokens\";\n+\n+        let mut parser = parse::stream_to_parser(ecx.parse_sess, stream);\n+        let mut items = vec![];\n+\n+        loop {\n+            match parser.parse_item().map_err(::proc_macro::__internal::parse_to_lex_err) {\n+                Ok(None) => break,\n+                Ok(Some(item)) => {\n+                    items.push(Annotatable::Item(item))\n                 }\n-                Ok(new_items) => new_items.into_iter().map(Annotatable::Item).collect(),\n                 Err(_) => {\n                     // FIXME: handle this better\n                     ecx.struct_span_fatal(span, msg).emit();\n                     FatalError.raise();\n                 }\n             }\n-        })\n+        }\n+\n+\n+        // fail if there have been errors emitted\n+        if ecx.parse_sess.span_diagnostic.err_count() > error_count_before {\n+            ecx.struct_span_fatal(span, msg).emit();\n+            FatalError.raise();\n+        }\n+\n+        items\n     }\n }"}, {"sha": "c5bceff4733965741cd674bb8529195dc3b64bfe", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -55,9 +55,7 @@ mod trace_macros;\n mod test;\n mod test_case;\n \n-pub mod proc_macro_registrar;\n-\n-\n+pub mod proc_macro_decls;\n pub mod proc_macro_impl;\n \n use rustc_data_structures::sync::Lrc;"}, {"sha": "c859275ed020cb727394890071ceab5c76474a99", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "renamed", "additions": 68, "deletions": 74, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -91,7 +91,7 @@ pub fn modify(sess: &ParseSess,\n         return krate;\n     }\n \n-    krate.module.items.push(mk_registrar(&mut cx, &derives, &attr_macros, &bang_macros));\n+    krate.module.items.push(mk_decls(&mut cx, &derives, &attr_macros, &bang_macros));\n \n     krate\n }\n@@ -339,19 +339,21 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n //      mod $gensym {\n //          extern crate proc_macro;\n //\n-//          use proc_macro::__internal::Registry;\n+//          use proc_macro::bridge::client::ProcMacro;\n //\n-//          #[plugin_registrar]\n-//          fn registrar(registrar: &mut Registry) {\n-//              registrar.register_custom_derive($name_trait1, ::$name1, &[]);\n-//              registrar.register_custom_derive($name_trait2, ::$name2, &[\"attribute_name\"]);\n+//          #[rustc_proc_macro_decls]\n+//          static DECLS: &[ProcMacro] = &[\n+//              ProcMacro::custom_derive($name_trait1, &[], ::$name1);\n+//              ProcMacro::custom_derive($name_trait2, &[\"attribute_name\"], ::$name2);\n //              // ...\n-//          }\n+//          ];\n //      }\n-fn mk_registrar(cx: &mut ExtCtxt,\n-                custom_derives: &[ProcMacroDerive],\n-                custom_attrs: &[ProcMacroDef],\n-                custom_macros: &[ProcMacroDef]) -> P<ast::Item> {\n+fn mk_decls(\n+    cx: &mut ExtCtxt,\n+    custom_derives: &[ProcMacroDerive],\n+    custom_attrs: &[ProcMacroDef],\n+    custom_macros: &[ProcMacroDef],\n+) -> P<ast::Item> {\n     let mark = Mark::fresh(Mark::root());\n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n@@ -370,75 +372,67 @@ fn mk_registrar(cx: &mut ExtCtxt,\n                         Vec::new(),\n                         ast::ItemKind::ExternCrate(None));\n \n-    let __internal = Ident::from_str(\"__internal\");\n-    let registry = Ident::from_str(\"Registry\");\n-    let registrar = Ident::from_str(\"_registrar\");\n-    let register_custom_derive = Ident::from_str(\"register_custom_derive\");\n-    let register_attr_proc_macro = Ident::from_str(\"register_attr_proc_macro\");\n-    let register_bang_proc_macro = Ident::from_str(\"register_bang_proc_macro\");\n+    let bridge = Ident::from_str(\"bridge\");\n+    let client = Ident::from_str(\"client\");\n+    let proc_macro_ty = Ident::from_str(\"ProcMacro\");\n+    let custom_derive = Ident::from_str(\"custom_derive\");\n+    let attr = Ident::from_str(\"attr\");\n+    let bang = Ident::from_str(\"bang\");\n     let crate_kw = Ident::with_empty_ctxt(keywords::Crate.name());\n-    let local_path = |cx: &mut ExtCtxt, sp: Span, name: Ident| {\n-        cx.path(sp.with_ctxt(span.ctxt()), vec![crate_kw, name])\n+\n+    let decls = {\n+        let local_path = |sp: Span, name| {\n+            cx.expr_path(cx.path(sp.with_ctxt(span.ctxt()), vec![crate_kw, name]))\n+        };\n+        let proc_macro_ty_method_path = |method| cx.expr_path(cx.path(span, vec![\n+            proc_macro, bridge, client, proc_macro_ty, method,\n+        ]));\n+        custom_derives.iter().map(|cd| {\n+            cx.expr_call(span, proc_macro_ty_method_path(custom_derive), vec![\n+                cx.expr_str(cd.span, cd.trait_name),\n+                cx.expr_vec_slice(\n+                    span,\n+                    cd.attrs.iter().map(|&s| cx.expr_str(cd.span, s)).collect::<Vec<_>>()\n+                ),\n+                local_path(cd.span, cd.function_name),\n+            ])\n+        }).chain(custom_attrs.iter().map(|ca| {\n+            cx.expr_call(span, proc_macro_ty_method_path(attr), vec![\n+                cx.expr_str(ca.span, ca.function_name.name),\n+                local_path(ca.span, ca.function_name),\n+            ])\n+        })).chain(custom_macros.iter().map(|cm| {\n+            cx.expr_call(span, proc_macro_ty_method_path(bang), vec![\n+                cx.expr_str(cm.span, cm.function_name.name),\n+                local_path(cm.span, cm.function_name),\n+            ])\n+        })).collect()\n     };\n \n-    let mut stmts = custom_derives.iter().map(|cd| {\n-        let path = local_path(cx, cd.span, cd.function_name);\n-        let trait_name = cx.expr_str(cd.span, cd.trait_name);\n-        let attrs = cx.expr_vec_slice(\n-            span,\n-            cd.attrs.iter().map(|&s| cx.expr_str(cd.span, s)).collect::<Vec<_>>()\n-        );\n-        let registrar = cx.expr_ident(span, registrar);\n-        let ufcs_path = cx.path(span, vec![proc_macro, __internal, registry,\n-                                           register_custom_derive]);\n-\n-        cx.stmt_expr(cx.expr_call(span, cx.expr_path(ufcs_path),\n-                                  vec![registrar, trait_name, cx.expr_path(path), attrs]))\n-\n-    }).collect::<Vec<_>>();\n-\n-    stmts.extend(custom_attrs.iter().map(|ca| {\n-        let name = cx.expr_str(ca.span, ca.function_name.name);\n-        let path = local_path(cx, ca.span, ca.function_name);\n-        let registrar = cx.expr_ident(ca.span, registrar);\n-\n-        let ufcs_path = cx.path(span,\n-                                vec![proc_macro, __internal, registry, register_attr_proc_macro]);\n-\n-        cx.stmt_expr(cx.expr_call(span, cx.expr_path(ufcs_path),\n-                                  vec![registrar, name, cx.expr_path(path)]))\n-    }));\n-\n-    stmts.extend(custom_macros.iter().map(|cm| {\n-        let name = cx.expr_str(cm.span, cm.function_name.name);\n-        let path = local_path(cx, cm.span, cm.function_name);\n-        let registrar = cx.expr_ident(cm.span, registrar);\n-\n-        let ufcs_path = cx.path(span,\n-                                vec![proc_macro, __internal, registry, register_bang_proc_macro]);\n-\n-        cx.stmt_expr(cx.expr_call(span, cx.expr_path(ufcs_path),\n-                                  vec![registrar, name, cx.expr_path(path)]))\n-    }));\n-\n-    let path = cx.path(span, vec![proc_macro, __internal, registry]);\n-    let registrar_path = cx.ty_path(path);\n-    let arg_ty = cx.ty_rptr(span, registrar_path, None, ast::Mutability::Mutable);\n-    let func = cx.item_fn(span,\n-                          registrar,\n-                          vec![cx.arg(span, registrar, arg_ty)],\n-                          cx.ty(span, ast::TyKind::Tup(Vec::new())),\n-                          cx.block(span, stmts));\n-\n-    let derive_registrar = cx.meta_word(span, Symbol::intern(\"rustc_derive_registrar\"));\n-    let derive_registrar = cx.attribute(span, derive_registrar);\n-    let func = func.map(|mut i| {\n-        i.attrs.push(derive_registrar);\n+    let decls_static = cx.item_static(\n+        span,\n+        Ident::from_str(\"_DECLS\"),\n+        cx.ty_rptr(span,\n+            cx.ty(span, ast::TyKind::Slice(\n+                cx.ty_path(cx.path(span,\n+                    vec![proc_macro, bridge, client, proc_macro_ty])))),\n+            None, ast::Mutability::Immutable),\n+        ast::Mutability::Immutable,\n+        cx.expr_vec_slice(span, decls),\n+    ).map(|mut i| {\n+        let attr = cx.meta_word(span, Symbol::intern(\"rustc_proc_macro_decls\"));\n+        i.attrs.push(cx.attribute(span, attr));\n         i.vis = respan(span, ast::VisibilityKind::Public);\n         i\n     });\n-    let ident = ast::Ident::with_empty_ctxt(Symbol::gensym(\"registrar\"));\n-    let module = cx.item_mod(span, span, ident, Vec::new(), vec![krate, func]).map(|mut i| {\n+\n+    let module = cx.item_mod(\n+        span,\n+        span,\n+        ast::Ident::with_empty_ctxt(Symbol::gensym(\"decls\")),\n+        vec![],\n+        vec![krate, decls_static],\n+    ).map(|mut i| {\n         i.vis = respan(span, ast::VisibilityKind::Public);\n         i\n     });", "previous_filename": "src/libsyntax_ext/proc_macro_registrar.rs"}, {"sha": "1f111dfcaf9ca25adc2fef39076d9d573ca672a3", "filename": "src/libsyntax_ext/proc_macro_impl.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e305994beb1347e2fcadf5c84acec60fb6902551/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=e305994beb1347e2fcadf5c84acec60fb6902551", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::panic;\n \n use errors::FatalError;\n \n@@ -17,11 +16,13 @@ use syntax::ext::base::*;\n use syntax::tokenstream::TokenStream;\n use syntax::ext::base;\n \n-use proc_macro::TokenStream as TsShim;\n-use proc_macro::__internal;\n+pub const EXEC_STRATEGY: ::proc_macro::bridge::server::SameThread =\n+    ::proc_macro::bridge::server::SameThread;\n \n pub struct AttrProcMacro {\n-    pub inner: fn(TsShim, TsShim) -> TsShim,\n+    pub client: ::proc_macro::bridge::client::Client<\n+        fn(::proc_macro::TokenStream, ::proc_macro::TokenStream) -> ::proc_macro::TokenStream,\n+    >,\n }\n \n impl base::AttrProcMacro for AttrProcMacro {\n@@ -31,22 +32,17 @@ impl base::AttrProcMacro for AttrProcMacro {\n                    annotation: TokenStream,\n                    annotated: TokenStream)\n                    -> TokenStream {\n-        let annotation = __internal::token_stream_wrap(annotation);\n-        let annotated = __internal::token_stream_wrap(annotated);\n-\n-        let res = __internal::set_sess(ecx, || {\n-            panic::catch_unwind(panic::AssertUnwindSafe(|| (self.inner)(annotation, annotated)))\n+        let server = ::proc_macro::rustc::Rustc;\n+        let res = ::proc_macro::__internal::set_sess(ecx, || {\n+            self.client.run(&EXEC_STRATEGY, server, annotation, annotated)\n         });\n \n         match res {\n-            Ok(stream) => __internal::token_stream_inner(stream),\n+            Ok(stream) => stream,\n             Err(e) => {\n                 let msg = \"custom attribute panicked\";\n                 let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.downcast_ref::<String>() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-                if let Some(s) = e.downcast_ref::<&'static str>() {\n+                if let Some(s) = e.as_str() {\n                     err.help(&format!(\"message: {}\", s));\n                 }\n \n@@ -58,7 +54,9 @@ impl base::AttrProcMacro for AttrProcMacro {\n }\n \n pub struct BangProcMacro {\n-    pub inner: fn(TsShim) -> TsShim,\n+    pub client: ::proc_macro::bridge::client::Client<\n+        fn(::proc_macro::TokenStream) -> ::proc_macro::TokenStream,\n+    >,\n }\n \n impl base::ProcMacro for BangProcMacro {\n@@ -67,21 +65,17 @@ impl base::ProcMacro for BangProcMacro {\n                    span: Span,\n                    input: TokenStream)\n                    -> TokenStream {\n-        let input = __internal::token_stream_wrap(input);\n-\n-        let res = __internal::set_sess(ecx, || {\n-            panic::catch_unwind(panic::AssertUnwindSafe(|| (self.inner)(input)))\n+        let server = ::proc_macro::rustc::Rustc;\n+        let res = ::proc_macro::__internal::set_sess(ecx, || {\n+            self.client.run(&EXEC_STRATEGY, server, input)\n         });\n \n         match res {\n-            Ok(stream) => __internal::token_stream_inner(stream),\n+            Ok(stream) => stream,\n             Err(e) => {\n                 let msg = \"proc macro panicked\";\n                 let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.downcast_ref::<String>() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-                if let Some(s) = e.downcast_ref::<&'static str>() {\n+                if let Some(s) = e.as_str() {\n                     err.help(&format!(\"message: {}\", s));\n                 }\n "}]}