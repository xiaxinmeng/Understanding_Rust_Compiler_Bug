{"sha": "ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZDNkOTVhN2ViMDJiYTQ5MWU2YjFhYzdjYTljNjBlZTE4ZTNjNzA=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-01-18T11:43:31Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-01-22T19:09:55Z"}, "message": "Make atomic instructions atomic using a global lock", "tree": {"sha": "b1346ff9fd22074d344cd6296d5ebb8596a99623", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1346ff9fd22074d344cd6296d5ebb8596a99623"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70", "html_url": "https://github.com/rust-lang/rust/commit/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3f378754b63d222f1679b901f7d90d6d4c32aaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f378754b63d222f1679b901f7d90d6d4c32aaa", "html_url": "https://github.com/rust-lang/rust/commit/a3f378754b63d222f1679b901f7d90d6d4c32aaa"}], "stats": {"total": 149, "additions": 147, "deletions": 2}, "files": [{"sha": "6a3cc715119cf55c5968468655b23d71c95b8b33", "filename": "config.sh", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/config.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/config.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.sh?ref=ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70", "patch": "@@ -13,6 +13,12 @@ fi\n TARGET_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n \n export RUSTFLAGS='-Cpanic=abort -Cdebuginfo=2 -Zpanic-abort-tests -Zcodegen-backend='$(pwd)'/target/'$CHANNEL'/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$(pwd)'/build_sysroot/sysroot'\n+\n+# FIXME remove once the atomic shim is gone\n+if [[ `uname` == 'Darwin' ]]; then\n+   export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n+fi\n+\n RUSTC=\"rustc $RUSTFLAGS -L crate=target/out --out-dir target/out\"\n export RUSTC_LOG=warn # display metadata load errors\n "}, {"sha": "300177e7645632920536bb72b45b1a14a761d391", "filename": "src/atomic_shim.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/src%2Fatomic_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/src%2Fatomic_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fatomic_shim.rs?ref=ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70", "patch": "@@ -0,0 +1,94 @@\n+//! Atomic intrinsics are implemented using a global lock for now, as Cranelift doesn't support\n+//! atomic operations yet.\n+\n+// FIXME implement atomic instructions in Cranelift.\n+\n+use crate::prelude::*;\n+\n+#[no_mangle]\n+pub static mut __cg_clif_global_atomic_mutex: libc::pthread_mutex_t = libc::PTHREAD_MUTEX_INITIALIZER;\n+\n+pub fn init_global_lock(module: &mut Module<impl Backend>, bcx: &mut FunctionBuilder<'_>) {\n+    if std::env::var(\"SHOULD_RUN\").is_ok () {\n+        // When using JIT, dylibs won't find the __cg_clif_global_atomic_mutex data object defined here,\n+        // so instead define it in the cg_clif dylib.\n+\n+        return;\n+    }\n+\n+    let mut data_ctx = DataContext::new();\n+    data_ctx.define_zeroinit(1024); // 1024 bytes should be big enough on all platforms.\n+    let atomic_mutex = module.declare_data(\n+        \"__cg_clif_global_atomic_mutex\",\n+        Linkage::Export,\n+        true,\n+        Some(16),\n+    ).unwrap();\n+    module.define_data(atomic_mutex, &data_ctx).unwrap();\n+\n+    let pthread_mutex_init = module.declare_function(\"pthread_mutex_init\", Linkage::Import, &cranelift_codegen::ir::Signature {\n+        call_conv: module.target_config().default_call_conv,\n+        params: vec![\n+            AbiParam::new(module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n+            AbiParam::new(module.target_config().pointer_type() /* *const pthread_mutex_attr_t */),\n+        ],\n+        returns: vec![AbiParam::new(types::I32 /* c_int */)],\n+    }).unwrap();\n+\n+    let pthread_mutex_init = module.declare_func_in_func(pthread_mutex_init, bcx.func);\n+\n+    let atomic_mutex = module.declare_data_in_func(atomic_mutex, bcx.func);\n+    let atomic_mutex = bcx.ins().global_value(module.target_config().pointer_type(), atomic_mutex);\n+\n+    let nullptr = bcx.ins().iconst(module.target_config().pointer_type(), 0);\n+\n+    bcx.ins().call(pthread_mutex_init, &[atomic_mutex, nullptr]);\n+}\n+\n+pub fn lock_global_lock(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n+    let atomic_mutex = fx.module.declare_data(\n+        \"__cg_clif_global_atomic_mutex\",\n+        Linkage::Import,\n+        true,\n+        None,\n+    ).unwrap();\n+\n+    let pthread_mutex_lock = fx.module.declare_function(\"pthread_mutex_lock\", Linkage::Import, &cranelift_codegen::ir::Signature {\n+        call_conv: fx.module.target_config().default_call_conv,\n+        params: vec![\n+            AbiParam::new(fx.module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n+        ],\n+        returns: vec![AbiParam::new(types::I32 /* c_int */)],\n+    }).unwrap();\n+\n+    let pthread_mutex_lock = fx.module.declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n+\n+    let atomic_mutex = fx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n+    let atomic_mutex = fx.bcx.ins().global_value(fx.module.target_config().pointer_type(), atomic_mutex);\n+\n+    fx.bcx.ins().call(pthread_mutex_lock, &[atomic_mutex]);\n+}\n+\n+pub fn unlock_global_lock(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n+    let atomic_mutex = fx.module.declare_data(\n+        \"__cg_clif_global_atomic_mutex\",\n+        Linkage::Import,\n+        true,\n+        None,\n+    ).unwrap();\n+\n+    let pthread_mutex_unlock = fx.module.declare_function(\"pthread_mutex_unlock\", Linkage::Import, &cranelift_codegen::ir::Signature {\n+        call_conv: fx.module.target_config().default_call_conv,\n+        params: vec![\n+            AbiParam::new(fx.module.target_config().pointer_type() /* *mut pthread_mutex_t */),\n+        ],\n+        returns: vec![AbiParam::new(types::I32 /* c_int */)],\n+    }).unwrap();\n+\n+    let pthread_mutex_unlock = fx.module.declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n+\n+    let atomic_mutex = fx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n+    let atomic_mutex = fx.bcx.ins().global_value(fx.module.target_config().pointer_type(), atomic_mutex);\n+\n+    fx.bcx.ins().call(pthread_mutex_unlock, &[atomic_mutex]);\n+}"}, {"sha": "9eb9df0eb54fa3c8ee792d0eaa464357d844f8bf", "filename": "src/driver.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70", "patch": "@@ -36,6 +36,13 @@ pub fn codegen_crate(\n fn run_jit(tcx: TyCtxt<'_>) -> ! {\n     use cranelift_simplejit::{SimpleJITBackend, SimpleJITBuilder};\n \n+    // Rustc opens us without the RTLD_GLOBAL flag, so __cg_clif_global_atomic_mutex will not be\n+    // exported. We fix this by opening ourself again as global.\n+    // FIXME remove once atomic_shim is gone\n+    let cg_dylib = std::ffi::OsString::from(&tcx.sess.opts.debugging_opts.codegen_backend.as_ref().unwrap());\n+    std::mem::forget(libloading::os::unix::Library::open(Some(cg_dylib), libc::RTLD_NOW | libc::RTLD_GLOBAL).unwrap());\n+\n+\n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n     let mut jit_builder = SimpleJITBuilder::with_isa("}, {"sha": "cdb7164f88c9dec03c6200e9e366538e0006048c", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70", "patch": "@@ -104,14 +104,20 @@ macro call_intrinsic_match {\n }\n \n macro atomic_binop_return_old($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident)  {\n+    crate::atomic_shim::lock_global_lock($fx);\n+\n     let clif_ty = $fx.clif_type($T).unwrap();\n     let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n     let new = $fx.bcx.ins().$op(old, $src);\n     $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n     $ret.write_cvalue($fx, CValue::by_val(old, $fx.layout_of($T)));\n+\n+    crate::atomic_shim::unlock_global_lock($fx);\n }\n \n macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $ret:ident) {\n+    crate::atomic_shim::lock_global_lock($fx);\n+\n     // Read old\n     let clif_ty = $fx.clif_type($T).unwrap();\n     let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n@@ -125,6 +131,8 @@ macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $\n \n     let ret_val = CValue::by_val(old, $ret.layout());\n     $ret.write_cvalue($fx, ret_val);\n+\n+    crate::atomic_shim::unlock_global_lock($fx);\n }\n \n fn lane_type_and_count<'tcx>(\n@@ -845,19 +853,35 @@ pub fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, caller_location);\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_fence\"), () {};\n-        _ if intrinsic.starts_with(\"atomic_singlethreadfence\"), () {};\n+        _ if intrinsic.starts_with(\"atomic_fence\"), () {\n+            crate::atomic_shim::lock_global_lock(fx);\n+            crate::atomic_shim::unlock_global_lock(fx);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_singlethreadfence\"), () {\n+            crate::atomic_shim::lock_global_lock(fx);\n+            crate::atomic_shim::unlock_global_lock(fx);\n+        };\n         _ if intrinsic.starts_with(\"atomic_load\"), (c ptr) {\n+            crate::atomic_shim::lock_global_lock(fx);\n+\n             let inner_layout =\n                 fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n             let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), inner_layout);\n             ret.write_cvalue(fx, val);\n+\n+            crate::atomic_shim::unlock_global_lock(fx);\n         };\n         _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n+            crate::atomic_shim::lock_global_lock(fx);\n+\n             let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n             dest.write_cvalue(fx, val);\n+\n+            crate::atomic_shim::unlock_global_lock(fx);\n         };\n         _ if intrinsic.starts_with(\"atomic_xchg\"), <T> (v ptr, c src) {\n+            crate::atomic_shim::lock_global_lock(fx);\n+\n             // Read old\n             let clif_ty = fx.clif_type(T).unwrap();\n             let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n@@ -866,8 +890,12 @@ pub fn codegen_intrinsic_call<'tcx>(\n             // Write new\n             let dest = CPlace::for_ptr(Pointer::new(ptr), src.layout());\n             dest.write_cvalue(fx, src);\n+\n+            crate::atomic_shim::unlock_global_lock(fx);\n         };\n         _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, v test_old, v new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+            crate::atomic_shim::lock_global_lock(fx);\n+\n             // Read old\n             let clif_ty = fx.clif_type(T).unwrap();\n             let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n@@ -881,6 +909,8 @@ pub fn codegen_intrinsic_call<'tcx>(\n \n             let ret_val = CValue::by_val_pair(old, fx.bcx.ins().bint(types::I8, is_eq), ret.layout());\n             ret.write_cvalue(fx, ret_val);\n+\n+            crate::atomic_shim::unlock_global_lock(fx);\n         };\n \n         _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, v amount) {\n@@ -893,12 +923,16 @@ pub fn codegen_intrinsic_call<'tcx>(\n             atomic_binop_return_old! (fx, band<T>(ptr, src) -> ret);\n         };\n         _ if intrinsic.starts_with(\"atomic_nand\"), <T> (v ptr, v src) {\n+            crate::atomic_shim::lock_global_lock(fx);\n+\n             let clif_ty = fx.clif_type(T).unwrap();\n             let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n             let and = fx.bcx.ins().band(old, src);\n             let new = fx.bcx.ins().bnot(and);\n             fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n             ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+\n+            crate::atomic_shim::unlock_global_lock(fx);\n         };\n         _ if intrinsic.starts_with(\"atomic_or\"), <T> (v ptr, v src) {\n             atomic_binop_return_old! (fx, bor<T>(ptr, src) -> ret);"}, {"sha": "94c47d0d395784c8f4f2a7a717eb01d8e8e7a830", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70", "patch": "@@ -2,6 +2,7 @@\n #![allow(intra_doc_link_resolution_failure)]\n \n extern crate flate2;\n+extern crate libc;\n extern crate tempfile;\n extern crate rustc;\n extern crate rustc_codegen_ssa;\n@@ -36,6 +37,7 @@ mod abi;\n mod allocator;\n mod analyze;\n mod archive;\n+mod atomic_shim;\n mod base;\n mod backend;\n mod cast;"}, {"sha": "b7c1425a1af5e69b13df72618a77cc36bb8bdaee", "filename": "src/main_shim.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=ddd3d95a7eb02ba491e6b1ac7ca9c60ee18e3c70", "patch": "@@ -67,6 +67,8 @@ pub fn maybe_create_entry_wrapper(tcx: TyCtxt<'_>, module: &mut Module<impl Back\n             let arg_argc = bcx.append_ebb_param(ebb, m.target_config().pointer_type());\n             let arg_argv = bcx.append_ebb_param(ebb, m.target_config().pointer_type());\n \n+            crate::atomic_shim::init_global_lock(m, &mut bcx);\n+\n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n             let call_inst = if use_start_lang_item {"}]}