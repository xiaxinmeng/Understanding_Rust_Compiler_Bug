{"sha": "81af6fb67ce9efe989031d629ed414ed85ee3767", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxYWY2ZmI2N2NlOWVmZTk4OTAzMWQ2MjllZDQxNGVkODVlZTM3Njc=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2017-04-20T15:38:35Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-22T18:02:02Z"}, "message": "allocate less strings in `symbol_names`\n\nthis improves trans performance by *another* 10%.", "tree": {"sha": "c6fcb26a3e2b690033cb1225f7c9c9aed9baf163", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6fcb26a3e2b690033cb1225f7c9c9aed9baf163"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81af6fb67ce9efe989031d629ed414ed85ee3767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81af6fb67ce9efe989031d629ed414ed85ee3767", "html_url": "https://github.com/rust-lang/rust/commit/81af6fb67ce9efe989031d629ed414ed85ee3767", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81af6fb67ce9efe989031d629ed414ed85ee3767/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "266d36f3b1d6231e53d1f13659e980b48d3b506f", "url": "https://api.github.com/repos/rust-lang/rust/commits/266d36f3b1d6231e53d1f13659e980b48d3b506f", "html_url": "https://github.com/rust-lang/rust/commit/266d36f3b1d6231e53d1f13659e980b48d3b506f"}], "stats": {"total": 104, "additions": 52, "deletions": 52}, "files": [{"sha": "f21864764ddf1f828b428414ab2449d0e028e7c3", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/81af6fb67ce9efe989031d629ed414ed85ee3767/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81af6fb67ce9efe989031d629ed414ed85ee3767/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=81af6fb67ce9efe989031d629ed414ed85ee3767", "patch": "@@ -110,7 +110,8 @@ use rustc::hir::map::definitions::DefPathData;\n use rustc::util::common::record_time;\n \n use syntax::attr;\n-use syntax::symbol::{Symbol, InternedString};\n+\n+use std::fmt::Write;\n \n fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n@@ -252,19 +253,47 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n \n     let hash = get_symbol_hash(tcx, Some(def_id), instance_ty, Some(substs));\n \n-    let mut buffer = SymbolPathBuffer {\n-        names: Vec::new()\n-    };\n-\n+    let mut buffer = SymbolPathBuffer::new();\n     item_path::with_forced_absolute_paths(|| {\n         tcx.push_item_path(&mut buffer, def_id);\n     });\n-\n-    mangle(buffer.names.into_iter(), &hash)\n+    buffer.finish(&hash)\n }\n \n+// Follow C++ namespace-mangling style, see\n+// http://en.wikipedia.org/wiki/Name_mangling for more info.\n+//\n+// It turns out that on macOS you can actually have arbitrary symbols in\n+// function names (at least when given to LLVM), but this is not possible\n+// when using unix's linker. Perhaps one day when we just use a linker from LLVM\n+// we won't need to do this name mangling. The problem with name mangling is\n+// that it seriously limits the available characters. For example we can't\n+// have things like &T in symbol names when one would theoretically\n+// want them for things like impls of traits on that type.\n+//\n+// To be able to work on all platforms and get *some* reasonable output, we\n+// use C++ name-mangling.\n struct SymbolPathBuffer {\n-    names: Vec<InternedString>,\n+    result: String,\n+    temp_buf: String\n+}\n+\n+impl SymbolPathBuffer {\n+    fn new() -> Self {\n+        let mut result = SymbolPathBuffer {\n+            result: String::with_capacity(64),\n+            temp_buf: String::with_capacity(16)\n+        };\n+        result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n+        result\n+    }\n+\n+    fn finish(mut self, hash: &str) -> String {\n+        // end name-sequence\n+        self.push(hash);\n+        self.result.push('E');\n+        self.result\n+    }\n }\n \n impl ItemPathBuffer for SymbolPathBuffer {\n@@ -274,7 +303,13 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     }\n \n     fn push(&mut self, text: &str) {\n-        self.names.push(Symbol::intern(text).as_str());\n+        self.temp_buf.clear();\n+        let need_underscore = sanitize(&mut self.temp_buf, text);\n+        let _ = write!(self.result, \"{}\", self.temp_buf.len() + (need_underscore as usize));\n+        if need_underscore {\n+            self.result.push('_');\n+        }\n+        self.result.push_str(&self.temp_buf);\n     }\n }\n \n@@ -283,15 +318,17 @@ pub fn exported_name_from_type_and_prefix<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     prefix: &str)\n                                                     -> String {\n     let hash = get_symbol_hash(tcx, None, t, None);\n-    let path = [Symbol::intern(prefix).as_str()];\n-    mangle(path.iter().cloned(), &hash)\n+    let mut buffer = SymbolPathBuffer::new();\n+    buffer.push(prefix);\n+    buffer.finish(&hash)\n }\n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-pub fn sanitize(s: &str) -> String {\n-    let mut result = String::new();\n+//\n+// returns true if an underscore must be added at the start\n+pub fn sanitize(result: &mut String, s: &str) -> bool {\n     for c in s.chars() {\n         match c {\n             // Escape these with $ sequences\n@@ -328,44 +365,7 @@ pub fn sanitize(s: &str) -> String {\n     }\n \n     // Underscore-qualify anything that didn't start as an ident.\n-    if !result.is_empty() &&\n+    !result.is_empty() &&\n         result.as_bytes()[0] != '_' as u8 &&\n-        ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", result);\n-    }\n-\n-    return result;\n-}\n-\n-fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: &str) -> String {\n-    // Follow C++ namespace-mangling style, see\n-    // http://en.wikipedia.org/wiki/Name_mangling for more info.\n-    //\n-    // It turns out that on macOS you can actually have arbitrary symbols in\n-    // function names (at least when given to LLVM), but this is not possible\n-    // when using unix's linker. Perhaps one day when we just use a linker from LLVM\n-    // we won't need to do this name mangling. The problem with name mangling is\n-    // that it seriously limits the available characters. For example we can't\n-    // have things like &T in symbol names when one would theoretically\n-    // want them for things like impls of traits on that type.\n-    //\n-    // To be able to work on all platforms and get *some* reasonable output, we\n-    // use C++ name-mangling.\n-\n-    let mut n = String::from(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n-\n-    fn push(n: &mut String, s: &str) {\n-        let sani = sanitize(s);\n-        n.push_str(&format!(\"{}{}\", sani.len(), sani));\n-    }\n-\n-    // First, connect each component with <len, name> pairs.\n-    for data in path {\n-        push(&mut n, &data);\n-    }\n-\n-    push(&mut n, hash);\n-\n-    n.push('E'); // End name-sequence.\n-    n\n+        ! (result.as_bytes()[0] as char).is_xid_start()\n }"}]}