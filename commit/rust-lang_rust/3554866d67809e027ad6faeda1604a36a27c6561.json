{"sha": "3554866d67809e027ad6faeda1604a36a27c6561", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NTQ4NjZkNjc4MDllMDI3YWQ2ZmFlZGExNjA0YTM2YTI3YzY1NjE=", "commit": {"author": {"name": "veetaha", "email": "veetaha2@gmail.com", "date": "2020-04-22T01:16:28Z"}, "committer": {"name": "veetaha", "email": "veetaha2@gmail.com", "date": "2020-05-10T16:06:28Z"}, "message": "Run codegen of ast types with documentation", "tree": {"sha": "8975c95bb6a425d113fad793f565761b6a1ad62e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8975c95bb6a425d113fad793f565761b6a1ad62e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3554866d67809e027ad6faeda1604a36a27c6561", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3554866d67809e027ad6faeda1604a36a27c6561", "html_url": "https://github.com/rust-lang/rust/commit/3554866d67809e027ad6faeda1604a36a27c6561", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3554866d67809e027ad6faeda1604a36a27c6561/comments", "author": {"login": "Veetaha", "id": 36276403, "node_id": "MDQ6VXNlcjM2Mjc2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/36276403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veetaha", "html_url": "https://github.com/Veetaha", "followers_url": "https://api.github.com/users/Veetaha/followers", "following_url": "https://api.github.com/users/Veetaha/following{/other_user}", "gists_url": "https://api.github.com/users/Veetaha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veetaha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veetaha/subscriptions", "organizations_url": "https://api.github.com/users/Veetaha/orgs", "repos_url": "https://api.github.com/users/Veetaha/repos", "events_url": "https://api.github.com/users/Veetaha/events{/privacy}", "received_events_url": "https://api.github.com/users/Veetaha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veetaha", "id": 36276403, "node_id": "MDQ6VXNlcjM2Mjc2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/36276403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veetaha", "html_url": "https://github.com/Veetaha", "followers_url": "https://api.github.com/users/Veetaha/followers", "following_url": "https://api.github.com/users/Veetaha/following{/other_user}", "gists_url": "https://api.github.com/users/Veetaha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veetaha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veetaha/subscriptions", "organizations_url": "https://api.github.com/users/Veetaha/orgs", "repos_url": "https://api.github.com/users/Veetaha/repos", "events_url": "https://api.github.com/users/Veetaha/events{/privacy}", "received_events_url": "https://api.github.com/users/Veetaha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0e384a34ab06b18c76f8020df149bef392c04c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0e384a34ab06b18c76f8020df149bef392c04c7", "html_url": "https://github.com/rust-lang/rust/commit/e0e384a34ab06b18c76f8020df149bef392c04c7"}], "stats": {"total": 1483, "additions": 1345, "deletions": 138}, "files": [{"sha": "dbb009b68831bf31f7627cd348f4bd8c7d933a9b", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1345, "deletions": 138, "changes": 1483, "blob_url": "https://github.com/rust-lang/rust/blob/3554866d67809e027ad6faeda1604a36a27c6561/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3554866d67809e027ad6faeda1604a36a27c6561/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=3554866d67809e027ad6faeda1604a36a27c6561", "patch": "@@ -5,7 +5,9 @@ use crate::{\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, T,\n };\n-\n+/// The entire Rust source file. Includes all top-level inner attributes and module items.\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/crates-and-source-files.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SourceFile {\n     pub(crate) syntax: SyntaxNode,\n@@ -16,7 +18,28 @@ impl ast::DocCommentsOwner for SourceFile {}\n impl SourceFile {\n     pub fn modules(&self) -> AstChildren<Module> { support::children(&self.syntax) }\n }\n-\n+/// Function definition either with body or not.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub extern \"C\" fn foo<T>(#[attr] Patern {p}: Pattern) -> u32\n+///     where\n+///         T: Debug\n+///     {\n+///         42\n+///     }\n+/// \u2771\n+///\n+/// extern \"C\" {\n+///     \u2770 fn fn_decl(also_variadic_ffi: u32, ...) -> u32; \u2771\n+/// }\n+/// ```\n+///\n+/// - [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n+/// - [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html#variadic-functions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FnDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -38,7 +61,13 @@ impl FnDef {\n     pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Return type annotation.\n+///\n+/// ```\n+/// fn foo(a: u32) \u2770 -> Option<u32> \u2771 { Some(a) }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RetType {\n     pub(crate) syntax: SyntaxNode,\n@@ -47,7 +76,26 @@ impl RetType {\n     pub fn thin_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![->]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Struct definition.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     struct Foo<T> where T: Debug {\n+///         /// Docs\n+///         #[attr]\n+///         pub a: u32,\n+///         b: T,\n+///     }\n+/// \u2771\n+///\n+/// \u2770 struct Foo; \u2771\n+/// \u2770 struct Foo<T>(#[attr] T) where T: Debug; \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StructDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -62,7 +110,23 @@ impl StructDef {\n     pub fn field_def_list(&self) -> Option<FieldDefList> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Union definition.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub union Foo<T> where T: Debug {\n+///         /// Docs\n+///         #[attr]\n+///         a: T,\n+///         b: u32,\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/unions.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UnionDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -78,7 +142,19 @@ impl UnionDef {\n         support::child(&self.syntax)\n     }\n }\n-\n+/// Record field definition list including enclosing curly braces.\n+///\n+/// ```\n+/// struct Foo // same for union\n+/// \u2770\n+///     {\n+///         a: u32,\n+///         b: bool,\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldDefList {\n     pub(crate) syntax: SyntaxNode,\n@@ -88,7 +164,22 @@ impl RecordFieldDefList {\n     pub fn fields(&self) -> AstChildren<RecordFieldDef> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Record field definition including its attributes and doc comments.\n+///\n+/// ` ``\n+/// same for union\n+/// struct Foo {\n+///      \u2770\n+///          /// Docs\n+///          #[attr]\n+///          pub a: u32\n+///      \u2771\n+///\n+///      \u2770 b: bool \u2771\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -99,7 +190,13 @@ impl ast::AttrsOwner for RecordFieldDef {}\n impl ast::DocCommentsOwner for RecordFieldDef {}\n impl ast::TypeAscriptionOwner for RecordFieldDef {}\n impl RecordFieldDef {}\n-\n+/// Tuple field definition list including enclosing parens.\n+///\n+/// ```\n+/// struct Foo \u2770 (u32, String, Vec<u32>) \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleFieldDefList {\n     pub(crate) syntax: SyntaxNode,\n@@ -109,7 +206,13 @@ impl TupleFieldDefList {\n     pub fn fields(&self) -> AstChildren<TupleFieldDef> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Tuple field definition including its attributes.\n+///\n+/// ```\n+/// struct Foo(\u2770 #[attr] u32 \u2771);\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleFieldDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -119,7 +222,29 @@ impl ast::AttrsOwner for TupleFieldDef {}\n impl TupleFieldDef {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Enum definition.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub enum Foo<T> where T: Debug {\n+///         /// Docs\n+///         #[attr]\n+///         Bar,\n+///         Baz(#[attr] u32),\n+///         Bruh {\n+///             a: u32,\n+///             /// Docs\n+///             #[attr]\n+///             b: T,\n+///         }\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -133,7 +258,22 @@ impl EnumDef {\n     pub fn enum_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![enum]) }\n     pub fn variant_list(&self) -> Option<EnumVariantList> { support::child(&self.syntax) }\n }\n-\n+/// Enum variant definition list including enclosing curly braces.\n+///\n+/// ```\n+/// enum Foo\n+/// \u2770\n+///     {\n+///         Bar,\n+///         Baz(u32),\n+///         Bruh {\n+///             a: u32\n+///         }\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumVariantList {\n     pub(crate) syntax: SyntaxNode,\n@@ -143,7 +283,21 @@ impl EnumVariantList {\n     pub fn variants(&self) -> AstChildren<EnumVariant> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Enum variant definition including its attributes and discriminant value definition.\n+///\n+/// ```\n+/// enum Foo {\n+///     \u2770\n+///         /// Docs\n+///         #[attr]\n+///         Bar\n+///     \u2771\n+///\n+///     // same for tuple and record variants\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EnumVariant {\n     pub(crate) syntax: SyntaxNode,\n@@ -157,7 +311,20 @@ impl EnumVariant {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Trait definition.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub unsafe trait Foo<T>: Debug where T: Debug {\n+///         // ...\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/traits.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TraitDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -174,7 +341,27 @@ impl TraitDef {\n     pub fn trait_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![trait]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n-\n+/// Module definition either with body or not.\n+/// Includes all of its inner and outer attributes, module items, doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub mod foo;\n+/// \u2771\n+///\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub mod bar {\n+///        //! Inner docs\n+///        #![inner_attr]\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/modules.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Module {\n     pub(crate) syntax: SyntaxNode,\n@@ -188,7 +375,28 @@ impl Module {\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Item defintion list.\n+/// This is used for both top-level items and impl block items.\n+///\n+/// ```\n+/// \u2770\n+///     fn foo {}\n+///     struct Bar;\n+///     enum Baz;\n+///     trait Bruh;\n+///     const BRUUH: u32 = 42;\n+/// \u2771\n+///\n+/// impl Foo\n+/// \u2770\n+///     {\n+///         fn bar() {}\n+///         const BAZ: u32 = 42;\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ItemList {\n     pub(crate) syntax: SyntaxNode,\n@@ -199,7 +407,18 @@ impl ItemList {\n     pub fn assoc_items(&self) -> AstChildren<AssocItem> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Constant variable definition.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub const FOO: u32 = 42;\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/constant-items.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -217,7 +436,18 @@ impl ConstDef {\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Static variable definition.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub static mut FOO: u32 = 42;\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/static-items.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StaticDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -235,7 +465,24 @@ impl StaticDef {\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Type alias definition.\n+/// Includes associated type clauses with type bounds.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     pub type Foo<T> where T: Debug = T;\n+/// \u2771\n+///\n+/// trait Bar {\n+///     \u2770 type Baz: Debug; \u2771\n+///     \u2770 type Bruh = String; \u2771\n+///     \u2770 type Bruuh: Debug = u32; \u2771\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/type-aliases.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeAliasDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -253,7 +500,20 @@ impl TypeAliasDef {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Inherent and trait impl definition.\n+/// Includes all of its inner and outer attributes.\n+///\n+/// ```\n+/// \u2770\n+///     #[attr]\n+///     unsafe impl<T> !Foo for Bar where T: Debug {\n+///         #![inner_attr]\n+///         // ...\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/implementations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ImplDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -270,7 +530,16 @@ impl ImplDef {\n     pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n-\n+/// Parenthesized type reference.\n+/// Note: parens are only used for grouping, this is not a tuple type.\n+///\n+/// ```\n+/// // This is effectively just `u32`.\n+/// // Single-item tuple must be defined with a trailing comma: `(u32,)`\n+/// type Foo = \u2770 (u32) \u2771;\n+///\n+/// let bar: &'static \u2770 (dyn Debug) \u2771 = \"bruh\";\n+/// ```\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenType {\n     pub(crate) syntax: SyntaxNode,\n@@ -280,7 +549,13 @@ impl ParenType {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Unnamed tuple type.\n+///\n+/// ```\n+/// let foo: \u2770 (u32, bool) \u2771 = (42, true);\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/tuple.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleType {\n     pub(crate) syntax: SyntaxNode,\n@@ -290,23 +565,50 @@ impl TupleType {\n     pub fn fields(&self) -> AstChildren<TypeRef> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// The never type (i.e. the exclamation point).\n+///\n+/// ```\n+/// type T = \u2770 ! \u2771;\n+///\n+/// fn no_return() -> \u2770 ! \u2771 {\n+///     loop {}\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/never.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NeverType {\n     pub(crate) syntax: SyntaxNode,\n }\n impl NeverType {\n     pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n }\n-\n+/// Path to a type.\n+/// Includes single identifier type names and elaborate paths with\n+/// generic parameters.\n+///\n+/// ```\n+/// type Foo = \u2770 String \u2771;\n+/// type Bar = \u2770 std::vec::Vec<T> \u2771;\n+/// type Baz = \u2770 ::bruh::<Bruuh as Iterator>::Item \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/paths.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathType {\n     pub(crate) syntax: SyntaxNode,\n }\n impl PathType {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n-\n+/// Raw pointer type.\n+///\n+/// ```\n+/// type Foo = \u2770 *const u32 \u2771;\n+/// type Bar = \u2770 *mut u32 \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/pointer.html#raw-pointers-const-and-mut)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PointerType {\n     pub(crate) syntax: SyntaxNode,\n@@ -317,7 +619,13 @@ impl PointerType {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Array type.\n+///\n+/// ```\n+/// type Foo = \u2770 [u32; 24 - 3] \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/array.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayType {\n     pub(crate) syntax: SyntaxNode,\n@@ -329,7 +637,13 @@ impl ArrayType {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n-\n+/// Slice type.\n+///\n+/// ```\n+/// type Foo = \u2770 [u8] \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/slice.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SliceType {\n     pub(crate) syntax: SyntaxNode,\n@@ -339,7 +653,13 @@ impl SliceType {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n-\n+/// Reference type.\n+///\n+/// ```\n+/// type Foo = \u2770 &'static str \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/pointer.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ReferenceType {\n     pub(crate) syntax: SyntaxNode,\n@@ -352,15 +672,29 @@ impl ReferenceType {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Placeholder type (i.e. the underscore).\n+///\n+/// ```\n+/// let foo: \u2770 _ \u2771 = 42_u32;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/inferred.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PlaceholderType {\n     pub(crate) syntax: SyntaxNode,\n }\n impl PlaceholderType {\n     pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n }\n-\n+/// Function pointer type (not to be confused with `Fn*` family of traits).\n+///\n+/// ```\n+/// type Foo = \u2770 async fn(#[attr] u32, named: bool) -> u32 \u2771;\n+///\n+/// type Bar = \u2770 extern \"C\" fn(variadic: u32, #[attr] ...) \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/function-pointer.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FnPointerType {\n     pub(crate) syntax: SyntaxNode,\n@@ -372,7 +706,13 @@ impl FnPointerType {\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n }\n-\n+/// Higher order type.\n+///\n+/// ```\n+/// type Foo = \u2770 for<'a> fn(&'a str) \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/nomicon/hrtb.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ForType {\n     pub(crate) syntax: SyntaxNode,\n@@ -382,7 +722,13 @@ impl ForType {\n     pub fn type_param_list(&self) -> Option<TypeParamList> { support::child(&self.syntax) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Opaque `impl Trait` type.\n+///\n+/// ```\n+/// fn foo(bar: \u2770 impl Debug + Eq \u2771) {}\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/impl-trait.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ImplTraitType {\n     pub(crate) syntax: SyntaxNode,\n@@ -391,7 +737,13 @@ impl ast::TypeBoundsOwner for ImplTraitType {}\n impl ImplTraitType {\n     pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n }\n-\n+/// Trait object type.\n+///\n+/// ```\n+/// type Foo = \u2770 dyn Debug \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/types/trait-object.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DynTraitType {\n     pub(crate) syntax: SyntaxNode,\n@@ -400,7 +752,13 @@ impl ast::TypeBoundsOwner for DynTraitType {}\n impl DynTraitType {\n     pub fn dyn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![dyn]) }\n }\n-\n+/// Tuple literal.\n+///\n+/// ```\n+/// \u2770 (42, true) \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/tuple-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -411,7 +769,15 @@ impl TupleExpr {\n     pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Array literal.\n+///\n+/// ```\n+/// \u2770 [#![inner_attr] true, false, true] \u2771;\n+///\n+/// \u2770 [\"baz\"; 24] \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/array-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -423,7 +789,14 @@ impl ArrayExpr {\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n-\n+/// Parenthesized expression.\n+/// Note: parens are only used for grouping, this is not a tuple literal.\n+///\n+/// ```\n+/// \u2770 (#![inner_attr] 2 + 2) \u2771 * 2;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/grouped-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -434,29 +807,68 @@ impl ParenExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Path to a symbol in expression context.\n+/// Includes single identifier variable names and elaborate paths with\n+/// generic parameters.\n+///\n+/// ```\n+/// \u2770 Some::<i32> \u2771;\n+/// \u2770 foo \u2771 + 42;\n+/// \u2770 Vec::<i32>::push \u2771;\n+/// \u2770 <[i32]>::reverse \u2771;\n+/// \u2770 <String as std::borrow::Borrow<str>>::borrow \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/path-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n impl PathExpr {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n-\n+/// Anonymous callable object literal a.k.a. closure, lambda or functor.\n+///\n+/// ```\n+/// \u2770 || 42 \u2771;\n+/// \u2770 |a: u32| val + 1 \u2771;\n+/// \u2770 async |#[attr] Pattern(_): Pattern| { bar } \u2771;\n+/// \u2770 move || baz \u2771;\n+/// \u2770 || -> u32 { closure_with_ret_type_annotation_requires_block_expr } \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/closure-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LambdaExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::AttrsOwner for LambdaExpr {}\n impl LambdaExpr {\n-    pub fn static_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![static]) }\n     pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n     pub fn move_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![move]) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// If expression. Includes both regular `if` and `if let` forms.\n+/// Beware that `else if` is a special case syntax sugar, because in general\n+/// there has to be block expression after `else`.\n+///\n+/// ```\n+/// \u2770 if bool_cond { 42 } \u2771\n+/// \u2770 if bool_cond { 42 } else { 24 } \u2771\n+/// \u2770 if bool_cond { 42 } else if bool_cond2 { 42 } \u2771\n+///\n+/// \u2770\n+///     if let Pattern(foo) = bar {\n+///         foo\n+///     } else {\n+///         panic!();\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/if-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct IfExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -466,7 +878,17 @@ impl IfExpr {\n     pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n-\n+/// Unconditional loop expression.\n+///\n+/// ```\n+/// \u2770\n+///     loop {\n+///         // yeah, it's that simple...\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LoopExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -476,7 +898,20 @@ impl ast::LoopBodyOwner for LoopExpr {}\n impl LoopExpr {\n     pub fn loop_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![loop]) }\n }\n-\n+/// Block expression with an optional prefix (label, try ketword,\n+/// unsafe keyword, async keyword...).\n+///\n+/// ```\n+/// \u2770\n+///     'label: try {\n+///         None?\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// - [try block](https://doc.rust-lang.org/unstable-book/language-features/try-blocks.html)\n+/// - [unsafe block](https://doc.rust-lang.org/reference/expressions/block-expr.html#unsafe-blocks)\n+/// - [async block](https://doc.rust-lang.org/reference/expressions/block-expr.html#async-blocks)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct EffectExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -489,7 +924,19 @@ impl EffectExpr {\n     pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n     pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n-\n+/// For loop expression.\n+/// Note: record struct literals are not valid as iterable expression\n+/// due to ambiguity.\n+///\n+/// ```\n+/// \u2770\n+/// for i in (0..4) {\n+///     dbg!(i);\n+/// }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#iterator-loops)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ForExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -502,7 +949,22 @@ impl ForExpr {\n     pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }\n     pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// While loop expression. Includes both regular `while` and `while let` forms.\n+///\n+/// ```\n+/// \u2770\n+///     while bool_cond {\n+///         42;\n+///     }\n+/// \u2771\n+/// \u2770\n+///     while let Pattern(foo) = bar {\n+///         bar += 1;\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhileExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -513,7 +975,22 @@ impl WhileExpr {\n     pub fn while_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![while]) }\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n-\n+/// Continue expression.\n+///\n+/// ```\n+/// while bool_cond {\n+///     \u2770 continue \u2771;\n+/// }\n+///\n+/// 'outer: loop {\n+///     loop {\n+///         \u2770 continue 'outer \u2771;\n+///     }\n+/// }\n+///\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ContinueExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -527,7 +1004,25 @@ impl ContinueExpr {\n         support::token(&self.syntax, T![lifetime])\n     }\n }\n-\n+/// Break expression.\n+///\n+/// ```\n+/// while bool_cond {\n+///     \u2770 break \u2771;\n+/// }\n+/// 'outer: loop {\n+///     for foo in bar {\n+///         \u2770 break 'outer \u2771;\n+///     }\n+/// }\n+/// 'outer: loop {\n+///     loop {\n+///         \u2770 break 'outer 42 \u2771;\n+///     }\n+/// }\n+/// ```\n+///\n+/// [Refernce](https://doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BreakExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -540,7 +1035,20 @@ impl BreakExpr {\n     }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Label.\n+///\n+/// ```\n+/// \u2770 'outer: \u2771 loop {}\n+///\n+/// let foo = \u2770 'bar: \u2771 loop {}\n+///\n+/// \u2770 'baz: \u2771 {\n+///     break 'baz;\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html?highlight=label#loop-labels)\n+/// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Label {\n     pub(crate) syntax: SyntaxNode,\n@@ -550,7 +1058,21 @@ impl Label {\n         support::token(&self.syntax, T![lifetime])\n     }\n }\n-\n+/// Block expression. Includes unsafe blocks and block labels.\n+///\n+/// ```\n+///     let foo = \u2770\n+///         {\n+///             #![inner_attr]\n+///             \u2770 { } \u2771\n+///\n+///             \u2770 'label: { break 'label } \u2771\n+///         }\n+///     \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/block-expr.html)\n+/// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BlockExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -563,7 +1085,17 @@ impl BlockExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Return expression.\n+///\n+/// ```\n+/// || \u2770 return 42 \u2771;\n+///\n+/// fn bar() {\n+///     \u2770 return \u2771;\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/return-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ReturnExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -572,7 +1104,16 @@ impl ast::AttrsOwner for ReturnExpr {}\n impl ReturnExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Call expression (not to be confused with method call expression, it is\n+/// a separate ast node).\n+///\n+/// ```\n+/// \u2770 foo() \u2771;\n+/// \u2770 &str::len(\"bar\") \u2771;\n+/// \u2770 <&str as PartialEq<&str>>::eq(&\"\", &\"\") \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/call-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CallExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -581,7 +1122,16 @@ impl ast::ArgListOwner for CallExpr {}\n impl CallExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Method call expression.\n+///\n+/// ```\n+/// \u2770 receiver_expr.method() \u2771;\n+/// \u2770 receiver_expr.method::<T>(42, true) \u2771;\n+///\n+/// \u2770 \u2770 \u2770 foo.bar() \u2771 .baz() \u2771 .bruh() \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/method-call-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MethodCallExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -594,7 +1144,13 @@ impl MethodCallExpr {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n }\n-\n+/// Index expression a.k.a. subscript operator call.\n+///\n+/// ```\n+/// \u2770 foo[42] \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/array-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct IndexExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -604,7 +1160,15 @@ impl IndexExpr {\n     pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n-\n+/// Field access expression.\n+///\n+/// ```\n+/// \u2770 expr.bar \u2771;\n+///\n+/// \u2770 \u2770 \u2770 foo.bar \u2771 .baz \u2771 .bruh \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/field-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FieldExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -615,7 +1179,13 @@ impl FieldExpr {\n     pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n }\n-\n+/// Await operator call expression.\n+///\n+/// ```\n+/// \u2770 expr.await \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/await-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AwaitExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -626,7 +1196,13 @@ impl AwaitExpr {\n     pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n     pub fn await_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![await]) }\n }\n-\n+/// The question mark operator call.\n+///\n+/// ```\n+/// \u2770 expr? \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TryExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -636,7 +1212,13 @@ impl TryExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }\n }\n-\n+/// Type cast expression.\n+///\n+/// ```\n+/// \u2770 expr as T \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CastExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -647,7 +1229,14 @@ impl CastExpr {\n     pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Borrow operator call.\n+///\n+/// ```\n+/// \u2770 &foo \u2771;\n+/// \u2770 &mut bar \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#borrow-operators)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -659,7 +1248,15 @@ impl RefExpr {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Prefix operator call. This is either `!` or `*` or `-`.\n+///\n+/// ```\n+/// \u2770 !foo \u2771;\n+/// \u2770 *bar \u2771;\n+/// \u2770 -42 \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PrefixExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -668,7 +1265,13 @@ impl ast::AttrsOwner for PrefixExpr {}\n impl PrefixExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Box operator call.\n+///\n+/// ```\n+/// \u2770 box 42 \u2771;\n+/// ```\n+///\n+/// [RFC](https://github.com/rust-lang/rfcs/blob/0806be4f282144cfcd55b1d20284b43f87cbe1c6/text/0809-box-and-in-for-stdlib.md)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BoxExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -678,27 +1281,69 @@ impl BoxExpr {\n     pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Range operator call.\n+///\n+/// ```\n+/// \u2770 0..42 \u2771;\n+/// \u2770 ..42 \u2771;\n+/// \u2770 0.. \u2771;\n+/// \u2770 .. \u2771;\n+/// \u2770 0..=42 \u2771;\n+/// \u2770 ..=42 \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/range-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RangeExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::AttrsOwner for RangeExpr {}\n impl RangeExpr {}\n-\n+/// Binary operator call.\n+/// Includes all arithmetic, logic, bitwise and assignment operators.\n+///\n+/// ```\n+/// \u2770 2 + \u2770 2 * 2 \u2771 \u2771;\n+/// \u2770 \u2770 true && false \u2771 || true \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BinExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::AttrsOwner for BinExpr {}\n impl BinExpr {}\n-\n+/// [Raw] string, [raw] byte string, char, byte, integer, float or bool literal.\n+///\n+/// ```\n+/// \u2770 \"str\" \u2771;\n+/// \u2770 br##\"raw byte str\"## \u2771;\n+/// \u2770 'c' \u2771;\n+/// \u2770 b'c' \u2771;\n+/// \u2770 42 \u2771;\n+/// \u2770 1e9 \u2771;\n+/// \u2770 true \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/literal-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Literal {\n     pub(crate) syntax: SyntaxNode,\n }\n impl Literal {}\n-\n+/// Match expression.\n+///\n+/// ```\n+/// \u2770\n+///     match expr {\n+///         Pat1 => {}\n+///         Pat2(_) => 42,\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -709,7 +1354,20 @@ impl MatchExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }\n }\n-\n+/// Match arm list part of match expression. Includes its inner attributes.\n+///\n+/// ```\n+/// match expr\n+/// \u2770\n+///     {\n+///         #![inner_attr]\n+///         Pat1 => {}\n+///         Pat2(_) => 42,\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchArmList {\n     pub(crate) syntax: SyntaxNode,\n@@ -720,7 +1378,16 @@ impl MatchArmList {\n     pub fn arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Match arm.\n+/// Note: record struct literals are not valid as target match expression\n+/// due to ambiguity.\n+/// ```\n+/// match expr {\n+///     \u2770 #[attr] Pattern(it) if bool_cond => it \u2771,\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchArm {\n     pub(crate) syntax: SyntaxNode,\n@@ -732,7 +1399,15 @@ impl MatchArm {\n     pub fn fat_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=>]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Match guard.\n+///\n+/// ```\n+/// match expr {\n+///     Pattern(it) \u2770 if bool_cond \u2771 => it,\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html#match-guards)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchGuard {\n     pub(crate) syntax: SyntaxNode,\n@@ -741,7 +1416,21 @@ impl MatchGuard {\n     pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Record literal expression. The same syntax is used for structs,\n+/// unions and record enum variants.\n+///\n+/// ```\n+/// \u2770\n+///     foo::Bar {\n+///         #![inner_attr]\n+///         baz: 42,\n+///         bruh: true,\n+///         ..spread\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordLit {\n     pub(crate) syntax: SyntaxNode,\n@@ -750,7 +1439,16 @@ impl RecordLit {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n     pub fn record_field_list(&self) -> Option<RecordFieldList> { support::child(&self.syntax) }\n }\n-\n+/// Record field list including enclosing curly braces.\n+///\n+/// foo::Bar \u2770\n+///     {\n+///         baz: 42,\n+///         ..spread\n+///     }\n+/// \u2771\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldList {\n     pub(crate) syntax: SyntaxNode,\n@@ -762,7 +1460,15 @@ impl RecordFieldList {\n     pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Record field.\n+///\n+/// ```\n+/// foo::Bar {\n+///     \u2770 #[attr] baz: 42 \u2771\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordField {\n     pub(crate) syntax: SyntaxNode,\n@@ -773,15 +1479,28 @@ impl RecordField {\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Disjunction of patterns.\n+///\n+/// ```\n+/// let \u2770 Foo(it) | Bar(it) | Baz(it) \u2771 = bruh;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct OrPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl OrPat {\n     pub fn pats(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n }\n-\n+/// Parenthesized pattern.\n+/// Note: parens are only used for grouping, this is not a tuple pattern.\n+///\n+/// ```\n+/// if let \u2770 &(0..=42) \u2771 = foo {}\n+/// ```\n+///\n+/// https://doc.rust-lang.org/reference/patterns.html#grouped-patterns\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -791,7 +1510,16 @@ impl ParenPat {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Reference pattern.\n+/// Note: this has nothing to do with `ref` keyword, the latter is used in bind patterns.\n+///\n+/// ```\n+/// let \u2770 &mut foo \u2771 = bar;\n+/// ```\n+/// // TODO: clarify on the special case of double reference pattern\n+/// // described in the link bellow\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#reference-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -801,7 +1529,13 @@ impl RefPat {\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n-\n+/// Box pattern.\n+///\n+/// ```\n+/// let \u2770 box foo \u2771 = box 42;\n+/// ```\n+///\n+/// [Unstable book](https://doc.rust-lang.org/unstable-book/language-features/box-patterns.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BoxPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -810,7 +1544,16 @@ impl BoxPat {\n     pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n-\n+/// Bind pattern.\n+///\n+/// ```\n+/// match foo {\n+///     Some(\u2770 ref mut bar \u2771) => {}\n+///     \u2770 baz @ None \u2771 => {}\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#identifier-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BindPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -823,31 +1566,60 @@ impl BindPat {\n     pub fn at_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![@]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n-\n+/// Placeholder pattern a.k.a. the wildcard pattern or the underscore.\n+///\n+/// ```\n+/// let \u2770 _ \u2771 = foo;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#wildcard-pattern)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PlaceholderPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl PlaceholderPat {\n     pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n }\n-\n+/// Rest-of-the record/tuple pattern.\n+/// Note: this is not the unbonded range pattern (even more: it doesn't exist).\n+///\n+/// ```\n+/// let Foo { bar, \u2770 .. \u2771 } = baz;\n+/// let (\u2770 .. \u2771, bruh) = (42, 24, 42);\n+/// let Bruuh(\u2770 .. \u2771) = bruuuh;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DotDotPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl DotDotPat {\n     pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n }\n-\n+/// Path pattern.\n+/// Doesn't include the underscore pattern (it is a special case, namely `PlaceholderPat`).\n+///\n+/// ```\n+/// let \u2770 foo::bar::Baz \u2771 { .. } = bruh;\n+/// if let \u2770 CONST \u2771 = 42 {}\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#path-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl PathPat {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n-\n+/// Slice pattern.\n+///\n+/// ```\n+/// let \u2770 [foo, bar, baz] \u2771 = [1, 2, 3];\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#slice-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SlicePat {\n     pub(crate) syntax: SyntaxNode,\n@@ -857,29 +1629,61 @@ impl SlicePat {\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n-\n+/// Range pattern.\n+///\n+/// ```\n+/// match foo {\n+///     \u2770 0..42 \u2771 => {}\n+///     \u2770 0..=42 \u2771 => {}\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#range-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RangePat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl RangePat {}\n-\n+/// Literal pattern.\n+/// Includes only bool, number, char, and string literals.\n+///\n+/// ```\n+/// match foo {\n+///     Number(\u2770 42 \u2771) => {}\n+///     String(\u2770 \"42\" \u2771) => {}\n+///     Bool(\u2770 true \u2771) => {}\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#literal-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LiteralPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl LiteralPat {\n     pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n }\n-\n+/// Macro invocation in pattern position.\n+///\n+/// ```\n+/// let \u2770 foo!(my custom syntax) \u2771 = baz;\n+///\n+/// ```\n+/// [Reference](https://doc.rust-lang.org/reference/macros.html#macro-invocation)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroPat {\n     pub(crate) syntax: SyntaxNode,\n }\n impl MacroPat {\n     pub fn macro_call(&self) -> Option<MacroCall> { support::child(&self.syntax) }\n }\n-\n+/// Record literal pattern.\n+///\n+/// ```\n+/// let \u2770 foo::Bar { baz, .. } \u2771 = bruh;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -890,7 +1694,13 @@ impl RecordPat {\n     }\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n-\n+/// Record literal's field patterns list including enclosing curly braces.\n+///\n+/// ```\n+/// let foo::Bar \u2770 { baz, bind @ bruh, .. } \u2771 = bruuh;\n+/// ``\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldPatList {\n     pub(crate) syntax: SyntaxNode,\n@@ -905,7 +1715,15 @@ impl RecordFieldPatList {\n     pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Record literal's field pattern.\n+/// Note: record literal can also match tuple structs.\n+///\n+/// ```\n+/// let Foo { \u2770 bar: _ \u2771 } = baz;\n+/// let TupleStruct { \u2770 0: _ \u2771 } = bruh;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -916,7 +1734,13 @@ impl RecordFieldPat {\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n-\n+/// Tuple struct literal pattern.\n+///\n+/// ```\n+/// let \u2770 foo::Bar(baz, bruh) \u2771 = bruuh;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#tuple-struct-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleStructPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -927,7 +1751,14 @@ impl TupleStructPat {\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Tuple pattern.\n+/// Note: this doesn't include tuple structs (see `TupleStructPat`)\n+///\n+/// ```\n+/// let \u2770 (foo, bar, .., baz) \u2771 = bruh;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/patterns.html#tuple-patterns)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TuplePat {\n     pub(crate) syntax: SyntaxNode,\n@@ -937,7 +1768,17 @@ impl TuplePat {\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Visibility.\n+///\n+/// ```\n+/// \u2770 pub mod \u2771 foo;\n+/// \u2770 pub(crate) \u2771 struct Bar;\n+/// \u2770 pub(self) \u2771 enum Baz {}\n+/// \u2770 pub(super) \u2771 fn bruh() {}\n+/// \u2770 pub(in bruuh::bruuuh) \u2771 type T = u64;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Visibility {\n     pub(crate) syntax: SyntaxNode,\n@@ -948,21 +1789,51 @@ impl Visibility {\n     pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n     pub fn crate_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![crate]) }\n }\n-\n+/// Single identifier.\n+/// // TODO: clarify the difference between Name and NameRef\n+///\n+/// ```\n+/// let \u2770 foo \u2771 = bar;\n+/// struct \u2770 Baz \u2771;\n+/// fn \u2770 bruh \u2771() {}\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/identifiers.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Name {\n     pub(crate) syntax: SyntaxNode,\n }\n impl Name {\n     pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }\n }\n-\n+/// Reference to a name.\n+///\n+/// ```\n+/// let foo = \u2770 bar \u2771(\u2770 Baz(\u2770 bruh \u2771) \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/identifiers.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NameRef {\n     pub(crate) syntax: SyntaxNode,\n }\n impl NameRef {}\n-\n+/// Macro call.\n+/// Includes all of its attributes and doc comments.\n+///\n+/// ```\n+/// \u2770\n+///     /// Docs\n+///     #[attr]\n+///     macro_rules! foo {   // macro rules is also a macro call\n+///         ($bar: tt) => {}\n+///     }\n+/// \u2771\n+///\n+/// \u2770 foo!() \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/macros.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCall {\n     pub(crate) syntax: SyntaxNode,\n@@ -976,7 +1847,18 @@ impl MacroCall {\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Attribute.\n+///\n+/// ```\n+/// \u2770 #![inner_attr] \u2771\n+///\n+/// \u2770 #[attr] \u2771\n+/// \u2770 #[foo = \"bar\"] \u2771\n+/// \u2770 #[baz(bruh::bruuh = \"42\")] \u2771\n+/// struct Foo;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/attributes.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Attr {\n     pub(crate) syntax: SyntaxNode,\n@@ -990,13 +1872,31 @@ impl Attr {\n     pub fn input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n-\n+/// // TODO: clarify on this AST type @edwin0cheng\n+///\n+/// ```\n+/// macro_call! \u2770 { my syntax here } \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/macros.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TokenTree {\n     pub(crate) syntax: SyntaxNode,\n }\n impl TokenTree {}\n-\n+/// Generic lifetime, type and constants parameters list **declaration**.\n+///\n+/// ```\n+/// fn foo\u2770 <'a, 'b, T, U, const BAR: u64> \u2771() {}\n+///\n+/// struct Baz\u2770 <T> \u2771(T);\n+///\n+/// impl\u2770 <T> \u2771 Bruh<T> {}\n+///\n+/// type Bruuh = for\u2770 <'a> \u2771 fn(&'a str) -> &'a str;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeParamList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1009,7 +1909,13 @@ impl TypeParamList {\n     pub fn const_params(&self) -> AstChildren<ConstParam> { support::children(&self.syntax) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n-\n+/// Single type parameter **declaration**.\n+///\n+/// ```\n+/// fn foo<\u2770 K \u2771, \u2770 I \u2771, \u2770 E: Debug \u2771, \u2770 V = DefaultType \u2771>() {}\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -1021,7 +1927,12 @@ impl TypeParam {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn default_type(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Const generic parameter **declaration**.\n+/// ```\n+/// fn foo<T, U, \u2770 const BAR: usize \u2771, \u2770 const BAZ: bool \u2771>() {}\n+/// ```\n+///\n+/// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md#declaring-a-const-parameter)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -1033,7 +1944,13 @@ impl ConstParam {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn default_val(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Lifetime parameter **declaration**.\n+///\n+/// ```\n+/// fn foo<\u2770 'a \u2771, \u2770 'b \u2771, V, G, D>(bar: &'a str, baz: &'b mut str) {}\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LifetimeParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -1044,7 +1961,20 @@ impl LifetimeParam {\n         support::token(&self.syntax, T![lifetime])\n     }\n }\n-\n+/// Type bound declaration clause.\n+///\n+/// ```\n+/// fn foo<T: \u2770 ?Sized \u2771 + \u2770 Debug \u2771>() {}\n+///\n+/// trait Bar<T>\n+/// where\n+///     T: \u2770 Send \u2771 + \u2770 Sync \u2771\n+/// {\n+///     type Baz: \u2770 !Sync \u2771 + \u2770 Debug \u2771;\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/trait-bounds.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBound {\n     pub(crate) syntax: SyntaxNode,\n@@ -1056,15 +1986,40 @@ impl TypeBound {\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Type bounds list.\n+///\n+/// ```\n+///\n+/// fn foo<T: \u2770 ?Sized + Debug \u2771>() {}\n+///\n+/// trait Bar<T>\n+/// where\n+///     T: \u2770 Send + Sync \u2771\n+/// {\n+///     type Baz: \u2770 !Sync + Debug \u2771;\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/trait-bounds.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBoundList {\n     pub(crate) syntax: SyntaxNode,\n }\n impl TypeBoundList {\n     pub fn bounds(&self) -> AstChildren<TypeBound> { support::children(&self.syntax) }\n }\n-\n+/// Single where predicate.\n+///\n+/// ```\n+/// trait Foo<'a, 'b, T>\n+/// where\n+///     \u2770 'a: 'b \u2771,\n+///     \u2770 T: IntoIterator \u2771,\n+///     \u2770 for<'c> <T as IntoIterator>::Item: Bar<'c> \u2771\n+/// {}\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/generics.html#where-clauses)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WherePred {\n     pub(crate) syntax: SyntaxNode,\n@@ -1076,7 +2031,14 @@ impl WherePred {\n     }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Where clause.\n+///\n+/// ```\n+/// trait Foo<'a, T> \u2770 where 'a: 'static, T: Debug \u2771 {}\n+///\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/generics.html#where-clauses)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhereClause {\n     pub(crate) syntax: SyntaxNode,\n@@ -1085,13 +2047,42 @@ impl WhereClause {\n     pub fn where_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![where]) }\n     pub fn predicates(&self) -> AstChildren<WherePred> { support::children(&self.syntax) }\n }\n-\n+/// Abi declaration.\n+/// Note: the abi string is optional.\n+///\n+/// ```\n+/// \u2770 extern \"C\" \u2771 {\n+///     fn foo() {}\n+/// }\n+///\n+/// type Bar = \u2770 extern \u2771 fn() -> u32;\n+///\n+/// type Baz = \u2770 extern r#\"stdcall\"# \u2771 fn() -> bool;\n+/// ```\n+///\n+/// - [Extern blocks reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n+/// - [FFI function pointers reference](https://doc.rust-lang.org/reference/items/functions.html#functions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Abi {\n     pub(crate) syntax: SyntaxNode,\n }\n impl Abi {}\n-\n+/// Expression statement.\n+/// Note: may be empty (i.e. only semicolon).\n+///\n+/// ```\n+/// \u2770 42; \u2771\n+/// \u2770 foo(); \u2771\n+/// \u2770 (); \u2771\n+/// \u2770 {}; \u2771\n+/// \u2770 /* empty */; \u2771\n+///\n+/// // constructions with trailing curly brace can omit the semicolon // TODO: clarify\n+/// \u2770 if bool_cond { } \u2771\n+/// \u2770 loop {} \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/statements.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExprStmt {\n     pub(crate) syntax: SyntaxNode,\n@@ -1101,7 +2092,16 @@ impl ExprStmt {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Let statement.\n+///\n+/// ```\n+/// \u2770 #[attr] let foo; \u2771\n+/// \u2770 let bar: u64; \u2771\n+/// \u2770 let baz = 42; \u2771\n+/// \u2770 let bruh: bool = true; \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/statements.html#let-statements)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LetStmt {\n     pub(crate) syntax: SyntaxNode,\n@@ -1115,7 +2115,18 @@ impl LetStmt {\n     pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n-\n+/// Condition of `if` or `while` expression.\n+///\n+/// ```\n+/// if \u2770 true \u2771 {}\n+/// if \u2770 let Pat(foo) = bar \u2771 {}\n+///\n+/// while \u2770 true \u2771 {}\n+/// while \u2770 let Pat(baz) = bruh \u2771 {}\n+/// ```\n+///\n+/// [If expression reference](https://doc.rust-lang.org/reference/expressions/if-expr.html)\n+/// [While expression reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Condition {\n     pub(crate) syntax: SyntaxNode,\n@@ -1126,7 +2137,18 @@ impl Condition {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// Parameter list **declaration**.\n+///\n+/// ```\n+/// fn foo\u2770 (a: u32, b: bool) \u2771 -> u32 {}\n+/// let bar = \u2770 |a, b| \u2771 {};\n+///\n+/// impl Baz {\n+///     fn bruh\u2770 (&self, a: u32) \u2771 {}\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/functions.html)ocs to codegen script\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParamList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1137,7 +2159,19 @@ impl ParamList {\n     pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Self parameter **declaration**.\n+///\n+/// ```\n+/// impl Bruh {\n+///     fn foo(\u2770 self \u2771) {}\n+///     fn bar(\u2770 &self \u2771) {}\n+///     fn baz(\u2770 &mut self \u2771) {}\n+///     fn blah<'a>(\u2770 &'a self \u2771) {}\n+///     fn blin(\u2770 self: Box<Self> \u2771) {}\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SelfParam {\n     pub(crate) syntax: SyntaxNode,\n@@ -1152,7 +2186,17 @@ impl SelfParam {\n     }\n     pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n }\n-\n+/// Parameter **declaration**.\n+///\n+/// ```\n+/// fn foo(\u2770 #[attr] Pat(bar): Pat(u32) \u2771, \u2770 #[attr] _: bool \u2771) {}\n+///\n+/// extern \"C\" {\n+///     fn bar(\u2770 baz: u32 \u2771, \u2770 ... \u2771) -> u32;\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Param {\n     pub(crate) syntax: SyntaxNode,\n@@ -1163,7 +2207,16 @@ impl Param {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![...]) }\n }\n-\n+/// Use declaration.\n+///\n+/// ```\n+/// \u2770 #[attr] pub use foo; \u2771\n+/// \u2770 use bar as baz; \u2771\n+/// \u2770 use bruh::{self, bruuh}; \u2771\n+/// \u2770 use { blin::blen, blah::* };\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseItem {\n     pub(crate) syntax: SyntaxNode,\n@@ -1174,7 +2227,16 @@ impl UseItem {\n     pub fn use_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![use]) }\n     pub fn use_tree(&self) -> Option<UseTree> { support::child(&self.syntax) }\n }\n-\n+/// Use tree.\n+///\n+/// ```\n+/// pub use \u2770 foo::\u2770 * \u2771 \u2771;\n+/// use \u2770 bar as baz \u2771;\n+/// use \u2770 bruh::bruuh::{ \u2770 self \u2771, \u2770 blin \u2771 } \u2771;\n+/// use \u2770 { \u2770 blin::blen \u2771 } \u2771 // TODO: clarify if top-level curlies are `UseTree`\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTree {\n     pub(crate) syntax: SyntaxNode,\n@@ -1185,7 +2247,16 @@ impl UseTree {\n     pub fn use_tree_list(&self) -> Option<UseTreeList> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n-\n+/// Item alias.\n+/// Note: this is not the type alias.\n+///\n+/// ```\n+/// use foo \u2770 as bar \u2771;\n+/// use baz::{bruh \u2770 as _ \u2771};\n+/// extern crate bruuh \u2770 as blin \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Alias {\n     pub(crate) syntax: SyntaxNode,\n@@ -1194,7 +2265,14 @@ impl ast::NameOwner for Alias {}\n impl Alias {\n     pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n }\n-\n+/// Sublist of use trees.\n+///\n+/// ```\n+/// use bruh::bruuh::\u2770 { \u2770 self \u2771, \u2770 blin \u2771 } \u2771;\n+/// use \u2770 { blin::blen::\u2770 {} \u2771 } \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTreeList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1204,7 +2282,14 @@ impl UseTreeList {\n     pub fn use_trees(&self) -> AstChildren<UseTree> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Extern crate item.\n+///\n+/// ```\n+/// \u2770 #[attr] pub extern crate foo; \u2771\n+/// \u2770 extern crate self as bar; \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/extern-crates.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternCrateItem {\n     pub(crate) syntax: SyntaxNode,\n@@ -1217,7 +2302,13 @@ impl ExternCrateItem {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n-\n+/// Call site arguments list.\n+///\n+/// ```\n+/// foo::<T, U>\u2770 (42, true) \u2771;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/expressions/call-expr.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArgList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1227,7 +2318,17 @@ impl ArgList {\n     pub fn args(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n-\n+/// Path to a symbol. Includes single identifier names and elaborate paths with\n+/// generic parameters.\n+///\n+/// ```\n+/// (0..10).\u2770 collect \u2770 ::<Vec<_>> \u2771 \u2771();\n+/// \u2770 Vec \u2770 ::<u8> \u2770 ::with_capacity \u2771 \u2771 \u2771(1024);\n+/// \u2770 <Foo as Bar> \u2770 ::baz \u2771 \u2771();\n+/// \u2770 <bruh> \u2770 ::bruuh \u2771 \u2771();\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/paths.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     pub(crate) syntax: SyntaxNode,\n@@ -1236,7 +2337,16 @@ impl Path {\n     pub fn segment(&self) -> Option<PathSegment> { support::child(&self.syntax) }\n     pub fn qualifier(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n-\n+/// Segment of the path to a symbol.\n+///\n+/// ```\n+/// (0..10).\u2770 collect \u2771 \u2770 ::<Vec<_>> \u2771();\n+/// \u2770 Vec >| \u2770 ::<u8> \u2771 \u2770 ::with_capacity \u2771(1024);\n+/// \u2770 <Foo as Bar> \u2771 \u2770 ::baz \u2771();\n+/// \u2770 <bruh> \u2771 \u2770 ::bruuh \u2771();\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/paths.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathSegment {\n     pub(crate) syntax: SyntaxNode,\n@@ -1254,7 +2364,15 @@ impl PathSegment {\n     pub fn path_type(&self) -> Option<PathType> { support::child(&self.syntax) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n-\n+/// List of type arguments that are passed at generic instantiation site.\n+///\n+/// ```\n+/// use foo \u2770 ::<'a, u64, Item = Bar, 42, true> \u2771::bar;\n+///\n+/// Vec\u2770 ::<bool> \u2771::();\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArgList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1269,15 +2387,27 @@ impl TypeArgList {\n     pub fn const_args(&self) -> AstChildren<ConstArg> { support::children(&self.syntax) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n-\n+/// Type argument that is passed at generic instantiation site.\n+///\n+/// ```\n+/// use foo::<'a, \u2770 u64 \u2771, \u2770 bool \u2771, Item = Bar, 42>::baz;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArg {\n     pub(crate) syntax: SyntaxNode,\n }\n impl TypeArg {\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Associated type argument that is passed at generic instantiation site.\n+/// ```\n+/// use foo::<'a, u64, bool, \u2770 Item = Bar \u2771, 42>::baz;\n+///\n+/// trait Bruh<T>: Iterator<\u2770 Item: Debug \u2771> {}\n+/// ```\n+///\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AssocTypeArg {\n     pub(crate) syntax: SyntaxNode,\n@@ -1288,7 +2418,15 @@ impl AssocTypeArg {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n-\n+/// Lifetime argument that is passed at generic instantiation site.\n+///\n+/// ```\n+/// fn foo<'a>(s: &'a str) {\n+///     bar::<\u2770 'a \u2771>(s);\n+/// }\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LifetimeArg {\n     pub(crate) syntax: SyntaxNode,\n@@ -1298,7 +2436,15 @@ impl LifetimeArg {\n         support::token(&self.syntax, T![lifetime])\n     }\n }\n-\n+/// Constant value argument that is passed at generic instantiation site.\n+///\n+/// ```\n+/// foo::<\u2770 u32 \u2771, \u2770 true \u2771 >();\n+///\n+/// bar::<\u2770 { 2 + 2} \u2771>();\n+/// ```\n+///\n+/// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md#declaring-a-const-parameter)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstArg {\n     pub(crate) syntax: SyntaxNode,\n@@ -1308,14 +2454,28 @@ impl ConstArg {\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n-\n+/// Macro items is a node that holds all the items created by expanding a macro.\n+///\n+/// ```\n+/// foo!(); // expands into some items -v\n+///         // \u2770 struct Foo; impl Bar for Foo; \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/macros.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroItems {\n     pub(crate) syntax: SyntaxNode,\n }\n impl ast::ModuleItemOwner for MacroItems {}\n impl MacroItems {}\n-\n+/// Macro statements is a node that holds an statements created by expanding a macro.\n+///\n+/// ```\n+/// foo!(); // expands into some statements -v\n+///         // \u2770 foo_crate::bar(); \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/macros.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroStmts {\n     pub(crate) syntax: SyntaxNode,\n@@ -1324,7 +2484,18 @@ impl MacroStmts {\n     pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n-\n+/// List of items in an extern block.\n+///\n+/// ```\n+/// extern \"C\" \u2770\n+///     {\n+///         fn foo();\n+///         static var: u32;\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternItemList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1335,7 +2506,18 @@ impl ExternItemList {\n     pub fn extern_items(&self) -> AstChildren<ExternItem> { support::children(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n-\n+/// Extern block.\n+///\n+/// ```\n+/// \u2770\n+///     extern \"C\" {\n+///         fn foo();\n+///     }\n+/// \u2771\n+///\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExternBlock {\n     pub(crate) syntax: SyntaxNode,\n@@ -1344,7 +2526,15 @@ impl ExternBlock {\n     pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n     pub fn extern_item_list(&self) -> Option<ExternItemList> { support::child(&self.syntax) }\n }\n-\n+/// Meta item in an attribute.\n+///\n+/// ```\n+/// #[\u2770 bar::baz = \"42\" \u2771]\n+/// #[\u2770 bruh(bruuh(\"true\")) \u2771]\n+/// struct Foo;\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/attributes.html?highlight=meta,item#meta-item-attribute-syntax)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MetaItem {\n     pub(crate) syntax: SyntaxNode,\n@@ -1355,7 +2545,17 @@ impl MetaItem {\n     pub fn attr_input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n     pub fn nested_meta_items(&self) -> AstChildren<MetaItem> { support::children(&self.syntax) }\n }\n-\n+/// Macro definition.\n+///\n+/// ```\n+/// \u2770\n+///     macro_rules! foo {\n+///         ($bar:tt) => {$bar}\n+///     }\n+/// \u2771\n+/// ```\n+///\n+/// [Reference](https://doc.rust-lang.org/reference/macros-by-example.html)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroDef {\n     pub(crate) syntax: SyntaxNode,\n@@ -1364,7 +2564,7 @@ impl MacroDef {\n     pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n }\n-\n+/// Any kind of nominal type definition.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum NominalDef {\n     StructDef(StructDef),\n@@ -1374,22 +2574,22 @@ pub enum NominalDef {\n impl ast::NameOwner for NominalDef {}\n impl ast::TypeParamsOwner for NominalDef {}\n impl ast::AttrsOwner for NominalDef {}\n-\n+/// Any kind of **declared** generic parameter\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum GenericParam {\n     LifetimeParam(LifetimeParam),\n     TypeParam(TypeParam),\n     ConstParam(ConstParam),\n }\n-\n+/// Any kind of generic argument passed at instantiation site\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum GenericArg {\n     LifetimeArg(LifetimeArg),\n     TypeArg(TypeArg),\n     ConstArg(ConstArg),\n     AssocTypeArg(AssocTypeArg),\n }\n-\n+/// Any kind of construct valid in type context\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum TypeRef {\n     ParenType(ParenType),\n@@ -1406,7 +2606,7 @@ pub enum TypeRef {\n     ImplTraitType(ImplTraitType),\n     DynTraitType(DynTraitType),\n }\n-\n+/// Any kind of top-level item that may appear in a module\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ModuleItem {\n     StructDef(StructDef),\n@@ -1427,7 +2627,10 @@ pub enum ModuleItem {\n impl ast::NameOwner for ModuleItem {}\n impl ast::AttrsOwner for ModuleItem {}\n impl ast::VisibilityOwner for ModuleItem {}\n-\n+/// Any kind of item that may appear in an impl block\n+///\n+/// // TODO: is the following a fixme?\n+/// impl blocks can also contain MacroCall\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AssocItem {\n     FnDef(FnDef),\n@@ -1436,7 +2639,10 @@ pub enum AssocItem {\n }\n impl ast::NameOwner for AssocItem {}\n impl ast::AttrsOwner for AssocItem {}\n-\n+/// Any kind of item that may appear in an extern block\n+///\n+/// // TODO: is the following a fixme?\n+/// extern blocks can also contain MacroCall\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ExternItem {\n     FnDef(FnDef),\n@@ -1445,7 +2651,7 @@ pub enum ExternItem {\n impl ast::NameOwner for ExternItem {}\n impl ast::AttrsOwner for ExternItem {}\n impl ast::VisibilityOwner for ExternItem {}\n-\n+/// Any kind of expression\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Expr {\n     TupleExpr(TupleExpr),\n@@ -1481,7 +2687,7 @@ pub enum Expr {\n     BoxExpr(BoxExpr),\n }\n impl ast::AttrsOwner for Expr {}\n-\n+/// Any kind of pattern\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Pat {\n     OrPat(OrPat),\n@@ -1500,25 +2706,26 @@ pub enum Pat {\n     LiteralPat(LiteralPat),\n     MacroPat(MacroPat),\n }\n-\n+/// Any kind of pattern that appears directly inside of the curly\n+/// braces of a record pattern\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum RecordInnerPat {\n     RecordFieldPat(RecordFieldPat),\n     BindPat(BindPat),\n }\n-\n+/// Any kind of input to an attribute\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AttrInput {\n     Literal(Literal),\n     TokenTree(TokenTree),\n }\n-\n+/// Any kind of statement\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Stmt {\n     LetStmt(LetStmt),\n     ExprStmt(ExprStmt),\n }\n-\n+/// Any kind of fields list (record or tuple field lists)\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum FieldDefList {\n     RecordFieldDefList(RecordFieldDefList),"}]}