{"sha": "560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MGI2Y2E2YzAwYjFkNTFhZWQ4Y2E1YjBjZjY5ODBiNDQ1MGUxOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-23T23:20:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-23T23:20:32Z"}, "message": "Auto merge of #42565 - murarth:rc-from-slice, r=aturon\n\nImplement From<&[T]> and others for Arc/Rc (RFC 1845)\n\n* Implements `From<`{`&[T]`, `&str`, `String`, `Box<T> where T: ?Sized`, `Vec<T>`}`>` for `Arc`/`Rc`\n* Removes `rustc_private`-marked methods `Rc::__from_array` and `Rc::__from_str`, replacing their use with `Rc::from`\n\nTracking issue: #40475", "tree": {"sha": "81fbd22adba47e9c4dbf7718af840e5b75b3a2ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81fbd22adba47e9c4dbf7718af840e5b75b3a2ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f", "html_url": "https://github.com/rust-lang/rust/commit/560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bb8fca18215298487a8684a132da828fdb5a751", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bb8fca18215298487a8684a132da828fdb5a751", "html_url": "https://github.com/rust-lang/rust/commit/2bb8fca18215298487a8684a132da828fdb5a751"}, {"sha": "8e0d01b432b0683d13429dcce907a2b38f30b9f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e0d01b432b0683d13429dcce907a2b38f30b9f6", "html_url": "https://github.com/rust-lang/rust/commit/8e0d01b432b0683d13429dcce907a2b38f30b9f6"}], "stats": {"total": 653, "additions": 587, "deletions": 66}, "files": [{"sha": "d734ae6a2cf61b2184bba55d315bff8024a7ea3a", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 295, "deletions": 5, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f", "patch": "@@ -16,16 +16,13 @@\n //!\n //! [arc]: struct.Arc.html\n \n-use boxed::Box;\n-\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n use core::cmp::Ordering;\n use core::intrinsics::abort;\n-use core::mem;\n-use core::mem::uninitialized;\n+use core::mem::{self, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n@@ -34,7 +31,10 @@ use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n use core::convert::From;\n \n-use heap::{Heap, Alloc, Layout};\n+use heap::{Heap, Alloc, Layout, box_free};\n+use boxed::Box;\n+use string::String;\n+use vec::Vec;\n \n /// A soft limit on the amount of references that may be made to an `Arc`.\n ///\n@@ -532,6 +532,141 @@ impl<T: ?Sized> Arc<T> {\n     }\n }\n \n+impl<T: ?Sized> Arc<T> {\n+    // Allocates an `ArcInner<T>` with sufficient space for an unsized value\n+    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n+        // Create a fake ArcInner to find allocation size and alignment\n+        let fake_ptr = ptr as *mut ArcInner<T>;\n+\n+        let layout = Layout::for_value(&*fake_ptr);\n+\n+        let mem = Heap.alloc(layout)\n+            .unwrap_or_else(|e| Heap.oom(e));\n+\n+        // Initialize the real ArcInner\n+        let inner = set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>;\n+\n+        ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n+        ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n+\n+        inner\n+    }\n+\n+    fn from_box(v: Box<T>) -> Arc<T> {\n+        unsafe {\n+            let bptr = Box::into_raw(v);\n+\n+            let value_size = size_of_val(&*bptr);\n+            let ptr = Self::allocate_for_ptr(bptr);\n+\n+            // Copy value as bytes\n+            ptr::copy_nonoverlapping(\n+                bptr as *const T as *const u8,\n+                &mut (*ptr).data as *mut _ as *mut u8,\n+                value_size);\n+\n+            // Free the allocation without dropping its contents\n+            box_free(bptr);\n+\n+            Arc { ptr: Shared::new_unchecked(ptr) }\n+        }\n+    }\n+}\n+\n+// Sets the data pointer of a `?Sized` raw pointer.\n+//\n+// For a slice/trait object, this sets the `data` field and leaves the rest\n+// unchanged. For a sized raw pointer, this simply sets the pointer.\n+unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n+    ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    ptr\n+}\n+\n+impl<T> Arc<[T]> {\n+    // Copy elements from slice into newly allocated Arc<[T]>\n+    //\n+    // Unsafe because the caller must either take ownership or bind `T: Copy`\n+    unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {\n+        let v_ptr = v as *const [T];\n+        let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+        ptr::copy_nonoverlapping(\n+            v.as_ptr(),\n+            &mut (*ptr).data as *mut [T] as *mut T,\n+            v.len());\n+\n+        Arc { ptr: Shared::new_unchecked(ptr) }\n+    }\n+}\n+\n+// Specialization trait used for From<&[T]>\n+trait ArcFromSlice<T> {\n+    fn from_slice(slice: &[T]) -> Self;\n+}\n+\n+impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n+    #[inline]\n+    default fn from_slice(v: &[T]) -> Self {\n+        // Panic guard while cloning T elements.\n+        // In the event of a panic, elements that have been written\n+        // into the new ArcInner will be dropped, then the memory freed.\n+        struct Guard<T> {\n+            mem: *mut u8,\n+            elems: *mut T,\n+            layout: Layout,\n+            n_elems: usize,\n+        }\n+\n+        impl<T> Drop for Guard<T> {\n+            fn drop(&mut self) {\n+                use core::slice::from_raw_parts_mut;\n+\n+                unsafe {\n+                    let slice = from_raw_parts_mut(self.elems, self.n_elems);\n+                    ptr::drop_in_place(slice);\n+\n+                    Heap.dealloc(self.mem, self.layout.clone());\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            let v_ptr = v as *const [T];\n+            let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+            let mem = ptr as *mut _ as *mut u8;\n+            let layout = Layout::for_value(&*ptr);\n+\n+            // Pointer to first element\n+            let elems = &mut (*ptr).data as *mut [T] as *mut T;\n+\n+            let mut guard = Guard{\n+                mem: mem,\n+                elems: elems,\n+                layout: layout,\n+                n_elems: 0,\n+            };\n+\n+            for (i, item) in v.iter().enumerate() {\n+                ptr::write(elems.offset(i as isize), item.clone());\n+                guard.n_elems += 1;\n+            }\n+\n+            // All clear. Forget the guard so it doesn't free the new ArcInner.\n+            mem::forget(guard);\n+\n+            Arc { ptr: Shared::new_unchecked(ptr) }\n+        }\n+    }\n+}\n+\n+impl<T: Copy> ArcFromSlice<T> for Arc<[T]> {\n+    #[inline]\n+    fn from_slice(v: &[T]) -> Self {\n+        unsafe { Arc::copy_from_slice(v) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Arc<T> {\n     /// Makes a clone of the `Arc` pointer.\n@@ -1216,8 +1351,56 @@ impl<T> From<T> for Arc<T> {\n     }\n }\n \n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a, T: Clone> From<&'a [T]> for Arc<[T]> {\n+    #[inline]\n+    fn from(v: &[T]) -> Arc<[T]> {\n+        <Self as ArcFromSlice<T>>::from_slice(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a> From<&'a str> for Arc<str> {\n+    #[inline]\n+    fn from(v: &str) -> Arc<str> {\n+        unsafe { mem::transmute(<Arc<[u8]>>::from(v.as_bytes())) }\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl From<String> for Arc<str> {\n+    #[inline]\n+    fn from(v: String) -> Arc<str> {\n+        Arc::from(&v[..])\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T: ?Sized> From<Box<T>> for Arc<T> {\n+    #[inline]\n+    fn from(v: Box<T>) -> Arc<T> {\n+        Arc::from_box(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T> From<Vec<T>> for Arc<[T]> {\n+    #[inline]\n+    fn from(mut v: Vec<T>) -> Arc<[T]> {\n+        unsafe {\n+            let arc = Arc::copy_from_slice(&v);\n+\n+            // Allow the Vec to free its memory, but not destroy its contents\n+            v.set_len(0);\n+\n+            arc\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n+    use std::boxed::Box;\n     use std::clone::Clone;\n     use std::sync::mpsc::channel;\n     use std::mem::drop;\n@@ -1520,6 +1703,113 @@ mod tests {\n         }\n         t.join().unwrap();\n     }\n+\n+    #[test]\n+    fn test_from_str() {\n+        let r: Arc<str> = Arc::from(\"foo\");\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_copy_from_slice() {\n+        let s: &[u32] = &[1, 2, 3];\n+        let r: Arc<[u32]> = Arc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_clone_from_slice() {\n+        #[derive(Clone, Debug, Eq, PartialEq)]\n+        struct X(u32);\n+\n+        let s: &[X] = &[X(1), X(2), X(3)];\n+        let r: Arc<[X]> = Arc::from(s);\n+\n+        assert_eq!(&r[..], s);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_clone_from_slice_panic() {\n+        use std::string::{String, ToString};\n+\n+        struct Fail(u32, String);\n+\n+        impl Clone for Fail {\n+            fn clone(&self) -> Fail {\n+                if self.0 == 2 {\n+                    panic!();\n+                }\n+                Fail(self.0, self.1.clone())\n+            }\n+        }\n+\n+        let s: &[Fail] = &[\n+            Fail(0, \"foo\".to_string()),\n+            Fail(1, \"bar\".to_string()),\n+            Fail(2, \"baz\".to_string()),\n+        ];\n+\n+        // Should panic, but not cause memory corruption\n+        let _r: Arc<[Fail]> = Arc::from(s);\n+    }\n+\n+    #[test]\n+    fn test_from_box() {\n+        let b: Box<u32> = box 123;\n+        let r: Arc<u32> = Arc::from(b);\n+\n+        assert_eq!(*r, 123);\n+    }\n+\n+    #[test]\n+    fn test_from_box_str() {\n+        use std::string::String;\n+\n+        let s = String::from(\"foo\").into_boxed_str();\n+        let r: Arc<str> = Arc::from(s);\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_slice() {\n+        let s = vec![1, 2, 3].into_boxed_slice();\n+        let r: Arc<[u32]> = Arc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait() {\n+        use std::fmt::Display;\n+        use std::string::ToString;\n+\n+        let b: Box<Display> = box 123;\n+        let r: Arc<Display> = Arc::from(b);\n+\n+        assert_eq!(r.to_string(), \"123\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait_zero_sized() {\n+        use std::fmt::Debug;\n+\n+        let b: Box<Debug> = box ();\n+        let r: Arc<Debug> = Arc::from(b);\n+\n+        assert_eq!(format!(\"{:?}\", r), \"()\");\n+    }\n+\n+    #[test]\n+    fn test_from_vec() {\n+        let v = vec![1, 2, 3];\n+        let r: Arc<[u32]> = Arc::from(v);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "47f537caf31c45bddb197416b706b5c177cdd8dc", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 291, "deletions": 60, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f", "patch": "@@ -252,14 +252,15 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::Unsize;\n-use core::mem::{self, forget, size_of, size_of_val, uninitialized};\n+use core::mem::{self, forget, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n use core::convert::From;\n \n use heap::{Heap, Alloc, Layout, box_free};\n-use raw_vec::RawVec;\n+use string::String;\n+use vec::Vec;\n \n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n@@ -421,64 +422,6 @@ impl<T> Rc<T> {\n     }\n }\n \n-impl Rc<str> {\n-    /// Constructs a new `Rc<str>` from a string slice.\n-    #[doc(hidden)]\n-    #[unstable(feature = \"rustc_private\",\n-               reason = \"for internal use in rustc\",\n-               issue = \"27812\")]\n-    pub fn __from_str(value: &str) -> Rc<str> {\n-        unsafe {\n-            // Allocate enough space for `RcBox<str>`.\n-            let aligned_len = 2 + (value.len() + size_of::<usize>() - 1) / size_of::<usize>();\n-            let vec = RawVec::<usize>::with_capacity(aligned_len);\n-            let ptr = vec.ptr();\n-            forget(vec);\n-            // Initialize fields of `RcBox<str>`.\n-            *ptr.offset(0) = 1; // strong: Cell::new(1)\n-            *ptr.offset(1) = 1; // weak: Cell::new(1)\n-            ptr::copy_nonoverlapping(value.as_ptr(), ptr.offset(2) as *mut u8, value.len());\n-            // Combine the allocation address and the string length into a fat pointer to `RcBox`.\n-            let rcbox_ptr: *mut RcBox<str> = mem::transmute([ptr as usize, value.len()]);\n-            assert!(aligned_len * size_of::<usize>() == size_of_val(&*rcbox_ptr));\n-            Rc { ptr: Shared::new_unchecked(rcbox_ptr) }\n-        }\n-    }\n-}\n-\n-impl<T> Rc<[T]> {\n-    /// Constructs a new `Rc<[T]>` from a `Box<[T]>`.\n-    #[doc(hidden)]\n-    #[unstable(feature = \"rustc_private\",\n-               reason = \"for internal use in rustc\",\n-               issue = \"27812\")]\n-    pub fn __from_array(value: Box<[T]>) -> Rc<[T]> {\n-        unsafe {\n-            let ptr: *mut RcBox<[T]> =\n-                mem::transmute([mem::align_of::<RcBox<[T; 1]>>(), value.len()]);\n-            // FIXME(custom-DST): creating this invalid &[T] is dubiously defined,\n-            // we should have a better way of getting the size/align\n-            // of a DST from its unsized part.\n-            let ptr = Heap.alloc(Layout::for_value(&*ptr))\n-                .unwrap_or_else(|e| Heap.oom(e));\n-            let ptr: *mut RcBox<[T]> = mem::transmute([ptr as usize, value.len()]);\n-\n-            // Initialize the new RcBox.\n-            ptr::write(&mut (*ptr).strong, Cell::new(1));\n-            ptr::write(&mut (*ptr).weak, Cell::new(1));\n-            ptr::copy_nonoverlapping(\n-                value.as_ptr(),\n-                &mut (*ptr).value as *mut [T] as *mut T,\n-                value.len());\n-\n-            // Free the original allocation without freeing its (moved) contents.\n-            box_free(Box::into_raw(value));\n-\n-            Rc { ptr: Shared::new_unchecked(ptr as *mut _) }\n-        }\n-    }\n-}\n-\n impl<T: ?Sized> Rc<T> {\n     /// Creates a new [`Weak`][weak] pointer to this value.\n     ///\n@@ -665,6 +608,140 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n+impl<T: ?Sized> Rc<T> {\n+    // Allocates an `RcBox<T>` with sufficient space for an unsized value\n+    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n+        // Create a fake RcBox to find allocation size and alignment\n+        let fake_ptr = ptr as *mut RcBox<T>;\n+\n+        let layout = Layout::for_value(&*fake_ptr);\n+\n+        let mem = Heap.alloc(layout)\n+            .unwrap_or_else(|e| Heap.oom(e));\n+\n+        // Initialize the real RcBox\n+        let inner = set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>;\n+\n+        ptr::write(&mut (*inner).strong, Cell::new(1));\n+        ptr::write(&mut (*inner).weak, Cell::new(1));\n+\n+        inner\n+    }\n+\n+    fn from_box(v: Box<T>) -> Rc<T> {\n+        unsafe {\n+            let bptr = Box::into_raw(v);\n+\n+            let value_size = size_of_val(&*bptr);\n+            let ptr = Self::allocate_for_ptr(bptr);\n+\n+            // Copy value as bytes\n+            ptr::copy_nonoverlapping(\n+                bptr as *const T as *const u8,\n+                &mut (*ptr).value as *mut _ as *mut u8,\n+                value_size);\n+\n+            // Free the allocation without dropping its contents\n+            box_free(bptr);\n+\n+            Rc { ptr: Shared::new_unchecked(ptr) }\n+        }\n+    }\n+}\n+\n+// Sets the data pointer of a `?Sized` raw pointer.\n+//\n+// For a slice/trait object, this sets the `data` field and leaves the rest\n+// unchanged. For a sized raw pointer, this simply sets the pointer.\n+unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n+    ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    ptr\n+}\n+\n+impl<T> Rc<[T]> {\n+    // Copy elements from slice into newly allocated Rc<[T]>\n+    //\n+    // Unsafe because the caller must either take ownership or bind `T: Copy`\n+    unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {\n+        let v_ptr = v as *const [T];\n+        let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+        ptr::copy_nonoverlapping(\n+            v.as_ptr(),\n+            &mut (*ptr).value as *mut [T] as *mut T,\n+            v.len());\n+\n+        Rc { ptr: Shared::new_unchecked(ptr) }\n+    }\n+}\n+\n+trait RcFromSlice<T> {\n+    fn from_slice(slice: &[T]) -> Self;\n+}\n+\n+impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n+    #[inline]\n+    default fn from_slice(v: &[T]) -> Self {\n+        // Panic guard while cloning T elements.\n+        // In the event of a panic, elements that have been written\n+        // into the new RcBox will be dropped, then the memory freed.\n+        struct Guard<T> {\n+            mem: *mut u8,\n+            elems: *mut T,\n+            layout: Layout,\n+            n_elems: usize,\n+        }\n+\n+        impl<T> Drop for Guard<T> {\n+            fn drop(&mut self) {\n+                use core::slice::from_raw_parts_mut;\n+\n+                unsafe {\n+                    let slice = from_raw_parts_mut(self.elems, self.n_elems);\n+                    ptr::drop_in_place(slice);\n+\n+                    Heap.dealloc(self.mem, self.layout.clone());\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            let v_ptr = v as *const [T];\n+            let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+            let mem = ptr as *mut _ as *mut u8;\n+            let layout = Layout::for_value(&*ptr);\n+\n+            // Pointer to first element\n+            let elems = &mut (*ptr).value as *mut [T] as *mut T;\n+\n+            let mut guard = Guard{\n+                mem: mem,\n+                elems: elems,\n+                layout: layout,\n+                n_elems: 0,\n+            };\n+\n+            for (i, item) in v.iter().enumerate() {\n+                ptr::write(elems.offset(i as isize), item.clone());\n+                guard.n_elems += 1;\n+            }\n+\n+            // All clear. Forget the guard so it doesn't free the new RcBox.\n+            forget(guard);\n+\n+            Rc { ptr: Shared::new_unchecked(ptr) }\n+        }\n+    }\n+}\n+\n+impl<T: Copy> RcFromSlice<T> for Rc<[T]> {\n+    #[inline]\n+    fn from_slice(v: &[T]) -> Self {\n+        unsafe { Rc::copy_from_slice(v) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for Rc<T> {\n     type Target = T;\n@@ -959,6 +1036,53 @@ impl<T> From<T> for Rc<T> {\n     }\n }\n \n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a, T: Clone> From<&'a [T]> for Rc<[T]> {\n+    #[inline]\n+    fn from(v: &[T]) -> Rc<[T]> {\n+        <Self as RcFromSlice<T>>::from_slice(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a> From<&'a str> for Rc<str> {\n+    #[inline]\n+    fn from(v: &str) -> Rc<str> {\n+        unsafe { mem::transmute(<Rc<[u8]>>::from(v.as_bytes())) }\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl From<String> for Rc<str> {\n+    #[inline]\n+    fn from(v: String) -> Rc<str> {\n+        Rc::from(&v[..])\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T: ?Sized> From<Box<T>> for Rc<T> {\n+    #[inline]\n+    fn from(v: Box<T>) -> Rc<T> {\n+        Rc::from_box(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T> From<Vec<T>> for Rc<[T]> {\n+    #[inline]\n+    fn from(mut v: Vec<T>) -> Rc<[T]> {\n+        unsafe {\n+            let rc = Rc::copy_from_slice(&v);\n+\n+            // Allow the Vec to free its memory, but not destroy its contents\n+            v.set_len(0);\n+\n+            rc\n+        }\n+    }\n+}\n+\n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n /// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n@@ -1465,6 +1589,113 @@ mod tests {\n         assert!(Rc::ptr_eq(&five, &same_five));\n         assert!(!Rc::ptr_eq(&five, &other_five));\n     }\n+\n+    #[test]\n+    fn test_from_str() {\n+        let r: Rc<str> = Rc::from(\"foo\");\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_copy_from_slice() {\n+        let s: &[u32] = &[1, 2, 3];\n+        let r: Rc<[u32]> = Rc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_clone_from_slice() {\n+        #[derive(Clone, Debug, Eq, PartialEq)]\n+        struct X(u32);\n+\n+        let s: &[X] = &[X(1), X(2), X(3)];\n+        let r: Rc<[X]> = Rc::from(s);\n+\n+        assert_eq!(&r[..], s);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_clone_from_slice_panic() {\n+        use std::string::{String, ToString};\n+\n+        struct Fail(u32, String);\n+\n+        impl Clone for Fail {\n+            fn clone(&self) -> Fail {\n+                if self.0 == 2 {\n+                    panic!();\n+                }\n+                Fail(self.0, self.1.clone())\n+            }\n+        }\n+\n+        let s: &[Fail] = &[\n+            Fail(0, \"foo\".to_string()),\n+            Fail(1, \"bar\".to_string()),\n+            Fail(2, \"baz\".to_string()),\n+        ];\n+\n+        // Should panic, but not cause memory corruption\n+        let _r: Rc<[Fail]> = Rc::from(s);\n+    }\n+\n+    #[test]\n+    fn test_from_box() {\n+        let b: Box<u32> = box 123;\n+        let r: Rc<u32> = Rc::from(b);\n+\n+        assert_eq!(*r, 123);\n+    }\n+\n+    #[test]\n+    fn test_from_box_str() {\n+        use std::string::String;\n+\n+        let s = String::from(\"foo\").into_boxed_str();\n+        let r: Rc<str> = Rc::from(s);\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_slice() {\n+        let s = vec![1, 2, 3].into_boxed_slice();\n+        let r: Rc<[u32]> = Rc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait() {\n+        use std::fmt::Display;\n+        use std::string::ToString;\n+\n+        let b: Box<Display> = box 123;\n+        let r: Rc<Display> = Rc::from(b);\n+\n+        assert_eq!(r.to_string(), \"123\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait_zero_sized() {\n+        use std::fmt::Debug;\n+\n+        let b: Box<Debug> = box ();\n+        let r: Rc<Debug> = Rc::from(b);\n+\n+        assert_eq!(format!(\"{:?}\", r), \"()\");\n+    }\n+\n+    #[test]\n+    fn test_from_vec() {\n+        let v = vec![1, 2, 3];\n+        let r: Rc<[u32]> = Rc::from(v);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "73b2e972b93ca81a803b18e9a695705f16f9ff32", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=560b6ca6c00b1d51aed8ca5b0cf6980b4450e19f", "patch": "@@ -892,7 +892,7 @@ impl<'a, 'tcx> CrateMetadata {\n         if def_key.disambiguated_data.data == DefPathData::StructCtor {\n             item = self.entry(def_key.parent.unwrap());\n         }\n-        let result = Rc::__from_array(self.get_attributes(&item).into_boxed_slice());\n+        let result: Rc<[ast::Attribute]> = Rc::from(self.get_attributes(&item));\n         let vec_ = &mut self.attribute_cache.borrow_mut()[node_as];\n         if vec_.len() < node_index + 1 {\n             vec_.resize(node_index + 1, None);"}]}