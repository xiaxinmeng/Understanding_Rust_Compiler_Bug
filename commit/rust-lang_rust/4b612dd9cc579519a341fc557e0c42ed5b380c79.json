{"sha": "4b612dd9cc579519a341fc557e0c42ed5b380c79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNjEyZGQ5Y2M1Nzk1MTlhMzQxZmM1NTdlMGM0MmVkNWIzODBjNzk=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-10-12T14:52:20Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2021-01-03T16:44:59Z"}, "message": "Only report reference-style link errors once\n\nCo-authored-by: Joshua Nelson <joshua@yottadb.com>", "tree": {"sha": "92990539d66544edb477d3dc0d01d2f34c4f0e49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92990539d66544edb477d3dc0d01d2f34c4f0e49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b612dd9cc579519a341fc557e0c42ed5b380c79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b612dd9cc579519a341fc557e0c42ed5b380c79", "html_url": "https://github.com/rust-lang/rust/commit/4b612dd9cc579519a341fc557e0c42ed5b380c79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b612dd9cc579519a341fc557e0c42ed5b380c79/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e821a6ef78b915305c4d659c813f27d4180baec0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e821a6ef78b915305c4d659c813f27d4180baec0", "html_url": "https://github.com/rust-lang/rust/commit/e821a6ef78b915305c4d659c813f27d4180baec0"}], "stats": {"total": 242, "additions": 175, "deletions": 67}, "files": [{"sha": "cc6ce3115b640abd64539191fda9520cd4e66f0f", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b612dd9cc579519a341fc557e0c42ed5b380c79/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b612dd9cc579519a341fc557e0c42ed5b380c79/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=4b612dd9cc579519a341fc557e0c42ed5b380c79", "patch": "@@ -37,7 +37,9 @@ use crate::doctest;\n use crate::html::highlight;\n use crate::html::toc::TocBuilder;\n \n-use pulldown_cmark::{html, BrokenLink, CodeBlockKind, CowStr, Event, Options, Parser, Tag};\n+use pulldown_cmark::{\n+    html, BrokenLink, CodeBlockKind, CowStr, Event, LinkType, Options, Parser, Tag,\n+};\n \n #[cfg(test)]\n mod tests;\n@@ -327,8 +329,6 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n     type Item = Event<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        use pulldown_cmark::LinkType;\n-\n         let mut event = self.inner.next();\n \n         // Replace intra-doc links and remove disambiguators from shortcut links (`[fn@f]`).\n@@ -1123,7 +1123,13 @@ crate fn plain_text_summary(md: &str) -> String {\n     s\n }\n \n-crate fn markdown_links(md: &str) -> Vec<(String, Range<usize>)> {\n+crate struct MarkdownLink {\n+    pub kind: LinkType,\n+    pub link: String,\n+    pub range: Range<usize>,\n+}\n+\n+crate fn markdown_links(md: &str) -> Vec<MarkdownLink> {\n     if md.is_empty() {\n         return vec![];\n     }\n@@ -1163,7 +1169,11 @@ crate fn markdown_links(md: &str) -> Vec<(String, Range<usize>)> {\n \n     let mut push = |link: BrokenLink<'_>| {\n         let span = span_for_link(&CowStr::Borrowed(link.reference), link.span);\n-        links.borrow_mut().push((link.reference.to_owned(), span));\n+        links.borrow_mut().push(MarkdownLink {\n+            kind: LinkType::ShortcutUnknown,\n+            link: link.reference.to_owned(),\n+            range: span,\n+        });\n         None\n     };\n     let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push)).into_offset_iter();\n@@ -1174,10 +1184,10 @@ crate fn markdown_links(md: &str) -> Vec<(String, Range<usize>)> {\n     let iter = Footnotes::new(HeadingLinks::new(p, None, &mut ids));\n \n     for ev in iter {\n-        if let Event::Start(Tag::Link(_, dest, _)) = ev.0 {\n+        if let Event::Start(Tag::Link(kind, dest, _)) = ev.0 {\n             debug!(\"found link: {}\", dest);\n             let span = span_for_link(&dest, ev.1);\n-            links.borrow_mut().push((dest.into_string(), span));\n+            links.borrow_mut().push(MarkdownLink { kind, link: dest.into_string(), range: span });\n         }\n     }\n "}, {"sha": "0cefbb34791b2a9b80516933bfabe556a8378bff", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 74, "deletions": 52, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/4b612dd9cc579519a341fc557e0c42ed5b380c79/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b612dd9cc579519a341fc557e0c42ed5b380c79/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=4b612dd9cc579519a341fc557e0c42ed5b380c79", "patch": "@@ -25,6 +25,8 @@ use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n use smallvec::{smallvec, SmallVec};\n \n+use pulldown_cmark::LinkType;\n+\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::convert::{TryFrom, TryInto};\n@@ -34,7 +36,7 @@ use std::ops::Range;\n use crate::clean::{self, utils::find_nearest_parent_module, Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n-use crate::html::markdown::markdown_links;\n+use crate::html::markdown::{markdown_links, MarkdownLink};\n use crate::passes::Pass;\n \n use super::span_of_attrs;\n@@ -265,8 +267,9 @@ struct LinkCollector<'a, 'tcx> {\n     /// because `clean` and the disambiguator code expect them to be different.\n     /// See the code for associated items on inherent impls for details.\n     kind_side_channel: Cell<Option<(DefKind, DefId)>>,\n-    /// Cache the resolved links so we can avoid resolving (and emitting errors for) the same link\n-    visited_links: FxHashMap<ResolutionInfo, CachedLink>,\n+    /// Cache the resolved links so we can avoid resolving (and emitting errors for) the same link.\n+    /// The link will be `None` if it could not be resolved (i.e. the error was cached).\n+    visited_links: FxHashMap<ResolutionInfo, Option<CachedLink>>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n@@ -901,16 +904,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             };\n             // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n             // This is a degenerate case and it's not supported by rustdoc.\n-            for (ori_link, link_range) in markdown_links(&doc) {\n-                let link = self.resolve_link(\n-                    &item,\n-                    &doc,\n-                    &self_name,\n-                    parent_node,\n-                    krate,\n-                    ori_link,\n-                    link_range,\n-                );\n+            for md_link in markdown_links(&doc) {\n+                let link = self.resolve_link(&item, &doc, &self_name, parent_node, krate, md_link);\n                 if let Some(link) = link {\n                     item.attrs.links.push(link);\n                 }\n@@ -942,27 +937,26 @@ impl LinkCollector<'_, '_> {\n         self_name: &Option<String>,\n         parent_node: Option<DefId>,\n         krate: CrateNum,\n-        ori_link: String,\n-        link_range: Range<usize>,\n+        ori_link: MarkdownLink,\n     ) -> Option<ItemLink> {\n-        trace!(\"considering link '{}'\", ori_link);\n+        trace!(\"considering link '{}'\", ori_link.link);\n \n         // Bail early for real links.\n-        if ori_link.contains('/') {\n+        if ori_link.link.contains('/') {\n             return None;\n         }\n \n         // [] is mostly likely not supposed to be a link\n-        if ori_link.is_empty() {\n+        if ori_link.link.is_empty() {\n             return None;\n         }\n \n         let cx = self.cx;\n-        let link = ori_link.replace(\"`\", \"\");\n+        let link = ori_link.link.replace(\"`\", \"\");\n         let parts = link.split('#').collect::<Vec<_>>();\n         let (link, extra_fragment) = if parts.len() > 2 {\n             // A valid link can't have multiple #'s\n-            anchor_failure(cx, &item, &link, dox, link_range, AnchorFailure::MultipleAnchors);\n+            anchor_failure(cx, &item, &link, dox, ori_link.range, AnchorFailure::MultipleAnchors);\n             return None;\n         } else if parts.len() == 2 {\n             if parts[0].trim().is_empty() {\n@@ -1018,7 +1012,7 @@ impl LinkCollector<'_, '_> {\n                 path_str,\n                 disambiguator,\n                 dox,\n-                link_range,\n+                ori_link.range,\n                 smallvec![ResolutionFailure::NoParentItem],\n             );\n             return None;\n@@ -1058,7 +1052,7 @@ impl LinkCollector<'_, '_> {\n                         path_str,\n                         disambiguator,\n                         dox,\n-                        link_range,\n+                        ori_link.range,\n                         smallvec![err_kind],\n                     );\n                     return None;\n@@ -1074,15 +1068,22 @@ impl LinkCollector<'_, '_> {\n             return None;\n         }\n \n-        let key = ResolutionInfo {\n-            module_id,\n-            dis: disambiguator,\n-            path_str: path_str.to_owned(),\n-            extra_fragment,\n+        let diag_info = DiagnosticInfo {\n+            item,\n+            dox,\n+            ori_link: &ori_link.link,\n+            link_range: ori_link.range.clone(),\n         };\n-        let diag =\n-            DiagnosticInfo { item, dox, ori_link: &ori_link, link_range: link_range.clone() };\n-        let (mut res, mut fragment) = self.resolve_with_disambiguator_cached(key, diag)?;\n+        let (mut res, mut fragment) = self.resolve_with_disambiguator_cached(\n+            ResolutionInfo {\n+                module_id,\n+                dis: disambiguator,\n+                path_str: path_str.to_owned(),\n+                extra_fragment,\n+            },\n+            diag_info,\n+            matches!(ori_link.kind, LinkType::Reference | LinkType::Shortcut),\n+        )?;\n \n         // Check for a primitive which might conflict with a module\n         // Report the ambiguity and require that the user specify which one they meant.\n@@ -1101,7 +1102,7 @@ impl LinkCollector<'_, '_> {\n                             &item,\n                             path_str,\n                             dox,\n-                            link_range,\n+                            ori_link.range,\n                             AnchorFailure::RustdocAnchorConflict(prim),\n                         );\n                         return None;\n@@ -1111,7 +1112,7 @@ impl LinkCollector<'_, '_> {\n                 } else {\n                     // `[char]` when a `char` module is in scope\n                     let candidates = vec![res, prim];\n-                    ambiguity_error(cx, &item, path_str, dox, link_range, candidates);\n+                    ambiguity_error(cx, &item, path_str, dox, ori_link.range, candidates);\n                     return None;\n                 }\n             }\n@@ -1129,14 +1130,22 @@ impl LinkCollector<'_, '_> {\n                     specified.descr()\n                 );\n                 diag.note(&note);\n-                suggest_disambiguator(resolved, diag, path_str, dox, sp, &link_range);\n+                suggest_disambiguator(resolved, diag, path_str, dox, sp, &ori_link.range);\n             };\n-            report_diagnostic(cx, BROKEN_INTRA_DOC_LINKS, &msg, &item, dox, &link_range, callback);\n+            report_diagnostic(\n+                cx,\n+                BROKEN_INTRA_DOC_LINKS,\n+                &msg,\n+                &item,\n+                dox,\n+                &ori_link.range,\n+                callback,\n+            );\n         };\n         match res {\n             Res::Primitive(_) => match disambiguator {\n                 Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n-                    Some(ItemLink { link: ori_link, link_text, did: None, fragment })\n+                    Some(ItemLink { link: ori_link.link, link_text, did: None, fragment })\n                 }\n                 Some(other) => {\n                     report_mismatch(other, Disambiguator::Primitive);\n@@ -1179,11 +1188,11 @@ impl LinkCollector<'_, '_> {\n                     if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n                         && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n                     {\n-                        privacy_error(cx, &item, &path_str, dox, link_range);\n+                        privacy_error(cx, &item, &path_str, dox, &ori_link);\n                     }\n                 }\n                 let id = clean::register_res(cx, rustc_hir::def::Res::Def(kind, id));\n-                Some(ItemLink { link: ori_link, link_text, did: Some(id), fragment })\n+                Some(ItemLink { link: ori_link.link, link_text, did: Some(id), fragment })\n             }\n         }\n     }\n@@ -1192,28 +1201,47 @@ impl LinkCollector<'_, '_> {\n         &mut self,\n         key: ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n+        cache_resolution_failure: bool,\n     ) -> Option<(Res, Option<String>)> {\n         // Try to look up both the result and the corresponding side channel value\n         if let Some(ref cached) = self.visited_links.get(&key) {\n-            self.kind_side_channel.set(cached.side_channel);\n-            return Some(cached.res.clone());\n+            match cached {\n+                Some(cached) => {\n+                    self.kind_side_channel.set(cached.side_channel.clone());\n+                    return Some(cached.res.clone());\n+                }\n+                None if cache_resolution_failure => return None,\n+                None => {\n+                    // Although we hit the cache and found a resolution error, this link isn't\n+                    // supposed to cache those. Run link resolution again to emit the expected\n+                    // resolution error.\n+                }\n+            }\n         }\n \n         let res = self.resolve_with_disambiguator(&key, diag);\n \n         // Cache only if resolved successfully - don't silence duplicate errors\n-        if let Some(res) = &res {\n+        if let Some(res) = res {\n             // Store result for the actual namespace\n             self.visited_links.insert(\n                 key,\n-                CachedLink {\n+                Some(CachedLink {\n                     res: res.clone(),\n                     side_channel: self.kind_side_channel.clone().into_inner(),\n-                },\n+                }),\n             );\n-        }\n \n-        res\n+            Some(res)\n+        } else {\n+            if cache_resolution_failure {\n+                // For reference-style links we only want to report one resolution error\n+                // so let's cache them as well.\n+                self.visited_links.insert(key, None);\n+            }\n+\n+            None\n+        }\n     }\n \n     /// After parsing the disambiguator, resolve the main part of the link.\n@@ -1964,13 +1992,7 @@ fn suggest_disambiguator(\n }\n \n /// Report a link from a public item to a private one.\n-fn privacy_error(\n-    cx: &DocContext<'_>,\n-    item: &Item,\n-    path_str: &str,\n-    dox: &str,\n-    link_range: Range<usize>,\n-) {\n+fn privacy_error(cx: &DocContext<'_>, item: &Item, path_str: &str, dox: &str, link: &MarkdownLink) {\n     let sym;\n     let item_name = match item.name {\n         Some(name) => {\n@@ -1982,7 +2004,7 @@ fn privacy_error(\n     let msg =\n         format!(\"public documentation for `{}` links to private item `{}`\", item_name, path_str);\n \n-    report_diagnostic(cx, PRIVATE_INTRA_DOC_LINKS, &msg, item, dox, &link_range, |diag, sp| {\n+    report_diagnostic(cx, PRIVATE_INTRA_DOC_LINKS, &msg, item, dox, &link.range, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"this item is private\");\n         }"}, {"sha": "7957ee373c49e53cb4d0bc3bacf01b90576ccbb9", "filename": "src/test/rustdoc-ui/reference-link-reports-error-once.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b612dd9cc579519a341fc557e0c42ed5b380c79/src%2Ftest%2Frustdoc-ui%2Freference-link-reports-error-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b612dd9cc579519a341fc557e0c42ed5b380c79/src%2Ftest%2Frustdoc-ui%2Freference-link-reports-error-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Freference-link-reports-error-once.rs?ref=4b612dd9cc579519a341fc557e0c42ed5b380c79", "patch": "@@ -0,0 +1,20 @@\n+#![deny(broken_intra_doc_links)]\n+\n+/// Links to [a] [link][a]\n+/// And also a [third link][a]\n+/// And also a [reference link][b]\n+///\n+/// Other links to the same target should still emit error: [ref] //~ERROR unresolved link to `ref`\n+/// Duplicate [ref] //~ERROR unresolved link to `ref`\n+///\n+/// Other links to other targets should still emit error: [ref2] //~ERROR unresolved link to `ref2`\n+/// Duplicate [ref2] //~ERROR unresolved link to `ref2`\n+///\n+/// [a]: ref\n+//~^ ERROR unresolved link to `ref`\n+/// [b]: ref2\n+//~^ ERROR unresolved link to\n+\n+/// [ref][]\n+//~^ ERROR unresolved link\n+pub fn f() {}"}, {"sha": "218eb334a6fc381ab494c7e55ef679dd5803d248", "filename": "src/test/rustdoc-ui/reference-link-reports-error-once.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4b612dd9cc579519a341fc557e0c42ed5b380c79/src%2Ftest%2Frustdoc-ui%2Freference-link-reports-error-once.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b612dd9cc579519a341fc557e0c42ed5b380c79/src%2Ftest%2Frustdoc-ui%2Freference-link-reports-error-once.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Freference-link-reports-error-once.stderr?ref=4b612dd9cc579519a341fc557e0c42ed5b380c79", "patch": "@@ -0,0 +1,63 @@\n+error: unresolved link to `ref`\n+  --> $DIR/reference-link-reports-error-once.rs:13:10\n+   |\n+LL | /// [a]: ref\n+   |          ^^^ no item named `ref` in scope\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reference-link-reports-error-once.rs:1:9\n+   |\n+LL | #![deny(broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `ref2`\n+  --> $DIR/reference-link-reports-error-once.rs:15:10\n+   |\n+LL | /// [b]: ref2\n+   |          ^^^^ no item named `ref2` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `ref`\n+  --> $DIR/reference-link-reports-error-once.rs:7:62\n+   |\n+LL | /// Other links to the same target should still emit error: [ref]\n+   |                                                              ^^^ no item named `ref` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `ref`\n+  --> $DIR/reference-link-reports-error-once.rs:8:16\n+   |\n+LL | /// Duplicate [ref]\n+   |                ^^^ no item named `ref` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `ref2`\n+  --> $DIR/reference-link-reports-error-once.rs:10:60\n+   |\n+LL | /// Other links to other targets should still emit error: [ref2]\n+   |                                                            ^^^^ no item named `ref2` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `ref2`\n+  --> $DIR/reference-link-reports-error-once.rs:11:16\n+   |\n+LL | /// Duplicate [ref2]\n+   |                ^^^^ no item named `ref2` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `ref`\n+  --> $DIR/reference-link-reports-error-once.rs:18:6\n+   |\n+LL | /// [ref][]\n+   |      ^^^ no item named `ref` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "6e00b9f0fa1a9e466ba9a651c25492ce07e7e9d0", "filename": "src/test/rustdoc-ui/reference-links.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b612dd9cc579519a341fc557e0c42ed5b380c79/src%2Ftest%2Frustdoc-ui%2Freference-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b612dd9cc579519a341fc557e0c42ed5b380c79/src%2Ftest%2Frustdoc-ui%2Freference-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Freference-links.rs?ref=4b612dd9cc579519a341fc557e0c42ed5b380c79", "patch": "@@ -4,4 +4,3 @@\n //!\n //! [a]: std::process::Comman\n //~^ ERROR unresolved\n-//~| ERROR unresolved"}, {"sha": "3df89df21b4c635f1d8f2183e3303811add03342", "filename": "src/test/rustdoc-ui/reference-links.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b612dd9cc579519a341fc557e0c42ed5b380c79/src%2Ftest%2Frustdoc-ui%2Freference-links.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b612dd9cc579519a341fc557e0c42ed5b380c79/src%2Ftest%2Frustdoc-ui%2Freference-links.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Freference-links.stderr?ref=4b612dd9cc579519a341fc557e0c42ed5b380c79", "patch": "@@ -10,11 +10,5 @@ note: the lint level is defined here\n LL | #![deny(broken_intra_doc_links)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: unresolved link to `std::process::Comman`\n-  --> $DIR/reference-links.rs:5:10\n-   |\n-LL | //! [a]: std::process::Comman\n-   |          ^^^^^^^^^^^^^^^^^^^^ no item named `Comman` in module `process`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}]}