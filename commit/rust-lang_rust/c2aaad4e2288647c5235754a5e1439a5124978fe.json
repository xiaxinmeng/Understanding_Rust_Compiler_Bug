{"sha": "c2aaad4e2288647c5235754a5e1439a5124978fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYWFhZDRlMjI4ODY0N2M1MjM1NzU0YTVlMTQzOWE1MTI0OTc4ZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-19T15:02:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-19T15:02:59Z"}, "message": "Auto merge of #33060 - jseyfried:cleanup_resolve, r=nrc\n\nresolve: miscellaneous clean-ups\n\nThis PR consists of some small, miscellaneous clean-ups in `resolve`.\nr? @eddyb", "tree": {"sha": "6a453678285d123896cb9866d6ef44921b7ac7be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a453678285d123896cb9866d6ef44921b7ac7be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2aaad4e2288647c5235754a5e1439a5124978fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2aaad4e2288647c5235754a5e1439a5124978fe", "html_url": "https://github.com/rust-lang/rust/commit/c2aaad4e2288647c5235754a5e1439a5124978fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2aaad4e2288647c5235754a5e1439a5124978fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "478a33dabc4e6f2f501f476c79b56178d9df4f37", "url": "https://api.github.com/repos/rust-lang/rust/commits/478a33dabc4e6f2f501f476c79b56178d9df4f37", "html_url": "https://github.com/rust-lang/rust/commit/478a33dabc4e6f2f501f476c79b56178d9df4f37"}, {"sha": "1e134a47d35bb82ccf41338f1c485a479f7807a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e134a47d35bb82ccf41338f1c485a479f7807a5", "html_url": "https://github.com/rust-lang/rust/commit/1e134a47d35bb82ccf41338f1c485a479f7807a5"}], "stats": {"total": 142, "additions": 62, "deletions": 80}, "files": [{"sha": "effc751c507593f6974d1cd1b6f3c656f8fac5fe", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c2aaad4e2288647c5235754a5e1439a5124978fe/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2aaad4e2288647c5235754a5e1439a5124978fe/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=c2aaad4e2288647c5235754a5e1439a5124978fe", "patch": "@@ -177,13 +177,9 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                         }\n \n                         let subclass = ImportDirectiveSubclass::single(binding, source_name);\n+                        let span = view_path.span;\n+                        parent.add_import_directive(module_path, subclass, span, item.id, vis);\n                         self.unresolved_imports += 1;\n-                        parent.add_import_directive(module_path,\n-                                                    subclass,\n-                                                    view_path.span,\n-                                                    item.id,\n-                                                    vis,\n-                                                    is_prelude);\n                     }\n                     ViewPathList(_, ref source_items) => {\n                         // Make sure there's at most one `mod` import in the list.\n@@ -228,23 +224,16 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                 }\n                             };\n                             let subclass = ImportDirectiveSubclass::single(rename, name);\n+                            let (span, id) = (source_item.span, source_item.node.id());\n+                            parent.add_import_directive(module_path, subclass, span, id, vis);\n                             self.unresolved_imports += 1;\n-                            parent.add_import_directive(module_path,\n-                                                        subclass,\n-                                                        source_item.span,\n-                                                        source_item.node.id(),\n-                                                        vis,\n-                                                        is_prelude);\n                         }\n                     }\n                     ViewPathGlob(_) => {\n+                        let subclass = GlobImport { is_prelude: is_prelude };\n+                        let span = view_path.span;\n+                        parent.add_import_directive(module_path, subclass, span, item.id, vis);\n                         self.unresolved_imports += 1;\n-                        parent.add_import_directive(module_path,\n-                                                    GlobImport,\n-                                                    view_path.span,\n-                                                    item.id,\n-                                                    vis,\n-                                                    is_prelude);\n                     }\n                 }\n             }\n@@ -271,7 +260,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 let def = Def::Mod(self.ast_map.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false, vis);\n                 self.define(parent, name, TypeNS, (module, sp));\n-                parent.module_children.borrow_mut().insert(item.id, module);\n+                self.module_map.insert(item.id, module);\n                 *parent_ref = module;\n             }\n \n@@ -409,7 +398,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n             let parent_link = BlockParentLink(parent, block_id);\n             let new_module = self.new_module(parent_link, None, false, parent.vis);\n-            parent.module_children.borrow_mut().insert(block_id, new_module);\n+            self.module_map.insert(block_id, new_module);\n             *parent = new_module;\n         }\n     }"}, {"sha": "8326b8b95e9967bf06b589da3bafa67da1a858ed", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c2aaad4e2288647c5235754a5e1439a5124978fe/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2aaad4e2288647c5235754a5e1439a5124978fe/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c2aaad4e2288647c5235754a5e1439a5124978fe", "patch": "@@ -827,22 +827,6 @@ pub struct ModuleS<'a> {\n     resolutions: RefCell<HashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n     unresolved_imports: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n-    // The module children of this node, including normal modules and anonymous modules.\n-    // Anonymous children are pseudo-modules that are implicitly created around items\n-    // contained within blocks.\n-    //\n-    // For example, if we have this:\n-    //\n-    //  fn f() {\n-    //      fn g() {\n-    //          ...\n-    //      }\n-    //  }\n-    //\n-    // There will be an anonymous module created around `g` with the ID of the\n-    // entry block for `f`.\n-    module_children: RefCell<NodeMap<Module<'a>>>,\n-\n     prelude: RefCell<Option<Module<'a>>>,\n \n     glob_importers: RefCell<Vec<(Module<'a>, &'a ImportDirective<'a>)>>,\n@@ -874,7 +858,6 @@ impl<'a> ModuleS<'a> {\n             extern_crate_id: None,\n             resolutions: RefCell::new(HashMap::new()),\n             unresolved_imports: RefCell::new(Vec::new()),\n-            module_children: RefCell::new(NodeMap()),\n             prelude: RefCell::new(None),\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n@@ -1082,6 +1065,22 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     export_map: ExportMap,\n     trait_map: TraitMap,\n \n+    // A map from nodes to modules, both normal (`mod`) modules and anonymous modules.\n+    // Anonymous modules are pseudo-modules that are implicitly created around items\n+    // contained within blocks.\n+    //\n+    // For example, if we have this:\n+    //\n+    //  fn f() {\n+    //      fn g() {\n+    //          ...\n+    //      }\n+    //  }\n+    //\n+    // There will be an anonymous module created around `g` with the ID of the\n+    // entry block for `f`.\n+    module_map: NodeMap<Module<'a>>,\n+\n     // Whether or not to print error messages. Can be set to true\n     // when getting additional info for error message suggestions,\n     // so as to avoid printing duplicate errors\n@@ -1107,14 +1106,22 @@ pub struct Resolver<'a, 'tcx: 'a> {\n \n struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleS<'a>>,\n+    local_modules: RefCell<Vec<Module<'a>>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n }\n \n impl<'a> ResolverArenas<'a> {\n     fn alloc_module(&'a self, module: ModuleS<'a>) -> Module<'a> {\n-        self.modules.alloc(module)\n+        let module = self.modules.alloc(module);\n+        if module.def_id().map(|def_id| def_id.is_local()).unwrap_or(true) {\n+            self.local_modules.borrow_mut().push(module);\n+        }\n+        module\n+    }\n+    fn local_modules(&'a self) -> ::std::cell::Ref<'a, Vec<Module<'a>>> {\n+        self.local_modules.borrow()\n     }\n     fn alloc_name_binding(&'a self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n         self.name_bindings.alloc(name_binding)\n@@ -1175,6 +1182,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             freevars_seen: NodeMap(),\n             export_map: NodeMap(),\n             trait_map: NodeMap(),\n+            module_map: NodeMap(),\n             used_imports: HashSet::new(),\n             used_crates: HashSet::new(),\n \n@@ -1193,6 +1201,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn arenas() -> ResolverArenas<'a> {\n         ResolverArenas {\n             modules: arena::TypedArena::new(),\n+            local_modules: RefCell::new(Vec::new()),\n             name_bindings: arena::TypedArena::new(),\n             import_directives: arena::TypedArena::new(),\n             name_resolutions: arena::TypedArena::new(),\n@@ -1573,7 +1582,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn with_scope<F>(&mut self, id: NodeId, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n-        if let Some(module) = self.current_module.module_children.borrow().get(&id) {\n+        let module = self.module_map.get(&id).cloned(); // clones a reference\n+        if let Some(module) = module {\n             // Move down in the graph.\n             let orig_module = ::std::mem::replace(&mut self.current_module, module);\n             self.value_ribs.push(Rib::new(ModuleRibKind(module)));\n@@ -2124,8 +2134,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         debug!(\"(resolving block) entering block\");\n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n-        let anonymous_module =\n-            orig_module.module_children.borrow().get(&block.id).map(|module| *module);\n+        let anonymous_module = self.module_map.get(&block.id).cloned(); // clones a reference\n \n         if let Some(anonymous_module) = anonymous_module {\n             debug!(\"(resolving block) found anonymous module, moving down\");"}, {"sha": "f335f145a1072dc4ad9a45ce23ff9d8c05c7e117", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 23, "deletions": 39, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c2aaad4e2288647c5235754a5e1439a5124978fe/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2aaad4e2288647c5235754a5e1439a5124978fe/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=c2aaad4e2288647c5235754a5e1439a5124978fe", "patch": "@@ -29,7 +29,6 @@ use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n-use std::mem::replace;\n use std::cell::{Cell, RefCell};\n \n /// Contains data for specific types of import directives.\n@@ -41,7 +40,7 @@ pub enum ImportDirectiveSubclass {\n         type_determined: Cell<bool>,\n         value_determined: Cell<bool>,\n     },\n-    GlobImport,\n+    GlobImport { is_prelude: bool },\n }\n \n impl ImportDirectiveSubclass {\n@@ -64,7 +63,6 @@ pub struct ImportDirective<'a> {\n     subclass: ImportDirectiveSubclass,\n     span: Span,\n     vis: ty::Visibility, // see note in ImportResolutionPerNamespace about how to use this\n-    is_prelude: bool,\n }\n \n impl<'a> ImportDirective<'a> {\n@@ -84,7 +82,7 @@ impl<'a> ImportDirective<'a> {\n     }\n \n     pub fn is_glob(&self) -> bool {\n-        match self.subclass { ImportDirectiveSubclass::GlobImport => true, _ => false }\n+        match self.subclass { ImportDirectiveSubclass::GlobImport { .. } => true, _ => false }\n     }\n }\n \n@@ -191,7 +189,7 @@ impl<'a> NameResolution<'a> {\n                 };\n                 let name = match directive.subclass {\n                     SingleImport { source, .. } => source,\n-                    GlobImport => unreachable!(),\n+                    GlobImport { .. } => unreachable!(),\n                 };\n                 match target_module.resolve_name(name, ns, false) {\n                     Failed(_) => {}\n@@ -282,16 +280,14 @@ impl<'a> ::ModuleS<'a> {\n                                 subclass: ImportDirectiveSubclass,\n                                 span: Span,\n                                 id: NodeId,\n-                                vis: ty::Visibility,\n-                                is_prelude: bool) {\n+                                vis: ty::Visibility) {\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n             module_path: module_path,\n             target_module: Cell::new(None),\n             subclass: subclass,\n             span: span,\n             id: id,\n             vis: vis,\n-            is_prelude: is_prelude,\n         });\n \n         self.unresolved_imports.borrow_mut().push(directive);\n@@ -304,8 +300,8 @@ impl<'a> ::ModuleS<'a> {\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n-            GlobImport if directive.is_prelude => {}\n-            GlobImport => self.globs.borrow_mut().push(directive),\n+            GlobImport { is_prelude: true } => {}\n+            GlobImport { .. } => self.globs.borrow_mut().push(directive),\n         }\n     }\n \n@@ -374,11 +370,17 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                    i,\n                    self.resolver.unresolved_imports);\n \n-            self.resolve_imports_for_module_subtree(self.resolver.graph_root, &mut errors);\n+            // Attempt to resolve imports in all local modules.\n+            for module in self.resolver.arenas.local_modules().iter() {\n+                self.resolver.current_module = module;\n+                self.resolve_imports_in_current_module(&mut errors);\n+            }\n \n             if self.resolver.unresolved_imports == 0 {\n                 debug!(\"(resolving imports) success\");\n-                self.finalize_resolutions(self.resolver.graph_root, false);\n+                for module in self.resolver.arenas.local_modules().iter() {\n+                    self.finalize_resolutions_in(module, false);\n+                }\n                 break;\n             }\n \n@@ -388,7 +390,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 // to avoid generating multiple errors on the same import.\n                 // Imports that are still indeterminate at this point are actually blocked\n                 // by errored imports, so there is no point reporting them.\n-                self.finalize_resolutions(self.resolver.graph_root, errors.len() == 0);\n+                for module in self.resolver.arenas.local_modules().iter() {\n+                    self.finalize_resolutions_in(module, errors.len() == 0);\n+                }\n                 for e in errors {\n                     self.import_resolving_error(e)\n                 }\n@@ -425,22 +429,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                       ResolutionError::UnresolvedImport(Some((&path, &e.help))));\n     }\n \n-    /// Attempts to resolve imports for the given module and all of its\n-    /// submodules.\n-    fn resolve_imports_for_module_subtree(&mut self,\n-                                          module_: Module<'b>,\n-                                          errors: &mut Vec<ImportResolvingError<'b>>) {\n-        debug!(\"(resolving imports for module subtree) resolving {}\",\n-               module_to_string(&module_));\n-        let orig_module = replace(&mut self.resolver.current_module, module_);\n-        self.resolve_imports_in_current_module(errors);\n-        self.resolver.current_module = orig_module;\n-\n-        for (_, child_module) in module_.module_children.borrow().iter() {\n-            self.resolve_imports_for_module_subtree(child_module, errors);\n-        }\n-    }\n-\n     /// Attempts to resolve imports for the given module only.\n     fn resolve_imports_in_current_module(&mut self, errors: &mut Vec<ImportResolvingError<'b>>) {\n         let mut imports = Vec::new();\n@@ -496,7 +484,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         let (source, target, value_determined, type_determined) = match directive.subclass {\n             SingleImport { source, target, ref value_determined, ref type_determined } =>\n                 (source, target, value_determined, type_determined),\n-            GlobImport => return self.resolve_glob_import(target_module, directive),\n+            GlobImport { .. } => return self.resolve_glob_import(target_module, directive),\n         };\n \n         // We need to resolve both namespaces for this to succeed.\n@@ -644,7 +632,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n         self.resolver.populate_module_if_necessary(target_module);\n \n-        if directive.is_prelude {\n+        if let GlobImport { is_prelude: true } = directive.subclass {\n             *module_.prelude.borrow_mut() = Some(target_module);\n             return Success(());\n         }\n@@ -676,9 +664,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         return Success(());\n     }\n \n-    // Miscellaneous post-processing, including recording reexports, recording shadowed traits,\n-    // reporting conflicts, reporting the PRIVATE_IN_PUBLIC lint, and reporting unresolved imports.\n-    fn finalize_resolutions(&mut self, module: Module<'b>, report_unresolved_imports: bool) {\n+    // Miscellaneous post-processing, including recording reexports, reporting conflicts,\n+    // reporting the PRIVATE_IN_PUBLIC lint, and reporting unresolved imports.\n+    fn finalize_resolutions_in(&mut self, module: Module<'b>, report_unresolved_imports: bool) {\n         // Since import resolution is finished, globs will not define any more names.\n         *module.globs.borrow_mut() = Vec::new();\n \n@@ -726,10 +714,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 break;\n             }\n         }\n-\n-        for (_, child) in module.module_children.borrow().iter() {\n-            self.finalize_resolutions(child, report_unresolved_imports);\n-        }\n     }\n }\n \n@@ -747,7 +731,7 @@ fn import_path_to_string(names: &[Name], subclass: &ImportDirectiveSubclass) ->\n fn import_directive_subclass_to_string(subclass: &ImportDirectiveSubclass) -> String {\n     match *subclass {\n         SingleImport { source, .. } => source.to_string(),\n-        GlobImport => \"*\".to_string(),\n+        GlobImport { .. } => \"*\".to_string(),\n     }\n }\n "}]}