{"sha": "7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNzA5YmZkMGRhYzFkNWJiZTVjOTc0OTQ5ODA3MzFiNGQ0NzdlOGY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-28T03:18:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-01T06:21:18Z"}, "message": "extra: Remove usage of fmt!", "tree": {"sha": "e0d7b54aed7492e51c5944badf590385a19232ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0d7b54aed7492e51c5944badf590385a19232ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "html_url": "https://github.com/rust-lang/rust/commit/7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8ba31dbf3e7d80a069bc486a35eff8357282b68", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8ba31dbf3e7d80a069bc486a35eff8357282b68", "html_url": "https://github.com/rust-lang/rust/commit/a8ba31dbf3e7d80a069bc486a35eff8357282b68"}], "stats": {"total": 845, "additions": 424, "deletions": 421}, "files": [{"sha": "40ddea538955b63fe8ecf27bb82544c6fdf1fbb7", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -255,7 +255,7 @@ impl<T:Send> MutexArc<T> {\n         let inner = x.unwrap();\n         let MutexArcInner { failed: failed, data: data, _ } = inner;\n         if failed {\n-            fail!(~\"Can't unwrap poisoned MutexArc - another task failed inside!\");\n+            fail2!(\"Can't unwrap poisoned MutexArc - another task failed inside!\");\n         }\n         data\n     }\n@@ -300,9 +300,9 @@ impl<T:Freeze + Send> MutexArc<T> {\n fn check_poison(is_mutex: bool, failed: bool) {\n     if failed {\n         if is_mutex {\n-            fail!(\"Poisoned MutexArc - another task failed inside!\");\n+            fail2!(\"Poisoned MutexArc - another task failed inside!\");\n         } else {\n-            fail!(\"Poisoned rw_arc - another task failed inside!\");\n+            fail2!(\"Poisoned rw_arc - another task failed inside!\");\n         }\n     }\n }\n@@ -505,7 +505,7 @@ impl<T:Freeze + Send> RWArc<T> {\n         let inner = x.unwrap();\n         let RWArcInner { failed: failed, data: data, _ } = inner;\n         if failed {\n-            fail!(~\"Can't unwrap poisoned RWArc - another task failed inside!\")\n+            fail2!(~\"Can't unwrap poisoned RWArc - another task failed inside!\")\n         }\n         data\n     }\n@@ -619,7 +619,7 @@ mod tests {\n         assert_eq!(arc_v.get()[2], 3);\n         assert_eq!(arc_v.get()[4], 5);\n \n-        info!(arc_v);\n+        info2!(\"{:?}\", arc_v);\n     }\n \n     #[test]"}, {"sha": "520faad1afa0797775a7128c92fb0b07b2fdbb93", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -127,7 +127,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n \n         let start = round_up_to(after_tydesc, align);\n \n-        //debug!(\"freeing object: idx = %u, size = %u, align = %u, done = %b\",\n+        //debug2!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n         //       start, size, align, is_done);\n         if is_done {\n             ((*tydesc).drop_glue)(ptr::offset(buf, start as int) as *i8);\n@@ -176,7 +176,7 @@ impl Arena {\n             }\n             this.pod_head.fill = end;\n \n-            //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n+            //debug2!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n             ptr::offset(vec::raw::to_ptr(this.pod_head.data), start as int)\n@@ -232,7 +232,7 @@ impl Arena {\n             let head = transmute_mut_region(&mut self.head);\n             head.fill = round_up_to(end, sys::pref_align_of::<*TyDesc>());\n \n-            //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n+            //debug2!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n             let buf = vec::raw::to_ptr(self.head.data);\n@@ -305,6 +305,6 @@ fn test_arena_destructors_fail() {\n     // Now, fail while allocating\n     do arena.alloc::<@int> {\n         // Now fail.\n-        fail!();\n+        fail2!();\n     };\n }"}, {"sha": "ed366047c848ba1b06da90a4f828ce3c213d9666", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -141,7 +141,7 @@ impl<'self> ToBase64 for &'self [u8] {\n                     v.push('=' as u8);\n                 }\n             }\n-            _ => fail!(\"Algebra is broken, please alert the math police\")\n+            _ => fail2!(\"Algebra is broken, please alert the math police\")\n         }\n \n         unsafe {\n@@ -202,7 +202,7 @@ impl<'self> FromBase64 for &'self str {\n                 '/'|'_' => buf |= 0x3F,\n                 '\\r'|'\\n' => loop,\n                 '=' => break,\n-                _ => return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                _ => return Err(format!(\"Invalid character '{}' at position {}\",\n                                      self.char_at(idx), idx))\n             }\n \n@@ -218,7 +218,7 @@ impl<'self> FromBase64 for &'self str {\n \n         for (idx, byte) in it {\n             if (byte as char) != '=' {\n-                return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                return Err(format!(\"Invalid character '{}' at position {}\",\n                                 self.char_at(idx), idx));\n             }\n         }"}, {"sha": "49a38a00b1003143c61dfed8fab52fd97dbf7d09", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -232,7 +232,7 @@ pub struct Bitv {\n }\n \n fn die() -> ! {\n-    fail!(\"Tried to do operation on bit vectors with different sizes\");\n+    fail2!(\"Tried to do operation on bit vectors with different sizes\");\n }\n \n impl Bitv {\n@@ -1357,7 +1357,7 @@ mod tests {\n         let mut b = Bitv::new(14, true);\n         b.clear();\n         do b.ones |i| {\n-            fail!(\"found 1 at %?\", i)\n+            fail2!(\"found 1 at {:?}\", i)\n         };\n     }\n \n@@ -1366,7 +1366,7 @@ mod tests {\n         let mut b = Bitv::new(140, true);\n         b.clear();\n         do b.ones |i| {\n-            fail!(\"found 1 at %?\", i)\n+            fail2!(\"found 1 at {:?}\", i)\n         };\n     }\n "}, {"sha": "476755919a4c460cb0dfb8ee5d64284536142373", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -179,7 +179,7 @@ mod test {\n         let (port, chan) = rendezvous();\n         do spawn_unlinked {\n             chan.duplex_stream.send(()); // Can't access this field outside this module\n-            fail!()\n+            fail2!()\n         }\n         port.recv()\n     }\n@@ -189,7 +189,7 @@ mod test {\n         let (port, chan) = rendezvous();\n         do spawn_unlinked {\n             port.duplex_stream.recv();\n-            fail!()\n+            fail2!()\n         }\n         chan.try_send(());\n     }\n@@ -200,7 +200,7 @@ mod test {\n         let (port, chan) = rendezvous();\n         do spawn_unlinked {\n             port.duplex_stream.recv();\n-            fail!()\n+            fail2!()\n         }\n         chan.send(());\n     }"}, {"sha": "8c97f7db2bd8a65459362f580b1c3c7d8cf1ae65", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -109,23 +109,23 @@ impl ToBits for u64 {\n     }\n }\n \n-/// Adds the specified number of bytes to the bit count. fail!() if this would cause numeric\n+/// Adds the specified number of bytes to the bit count. fail2!() if this would cause numeric\n /// overflow.\n pub fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n     let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n     if new_high_bits > Zero::zero() {\n-        fail!(\"Numeric overflow occured.\")\n+        fail2!(\"Numeric overflow occured.\")\n     }\n \n     match bits.checked_add(&new_low_bits) {\n         Some(x) => return x,\n-        None => fail!(\"Numeric overflow occured.\")\n+        None => fail2!(\"Numeric overflow occured.\")\n     }\n }\n \n /// Adds the specified number of bytes to the bit count, which is a tuple where the first element is\n-/// the high order value. fail!() if this would cause numeric overflow.\n+/// the high order value. fail2!() if this would cause numeric overflow.\n pub fn add_bytes_to_bits_tuple\n         <T: Int + Unsigned + CheckedAdd + ToBits>\n         (bits: (T, T), bytes: T) -> (T, T) {\n@@ -144,15 +144,15 @@ pub fn add_bytes_to_bits_tuple\n             } else {\n                 match hi.checked_add(&new_high_bits) {\n                     Some(y) => return (y, x),\n-                    None => fail!(\"Numeric overflow occured.\")\n+                    None => fail2!(\"Numeric overflow occured.\")\n                 }\n             }\n         },\n         None => {\n             let one: T = One::one();\n             let z = match new_high_bits.checked_add(&one) {\n                 Some(w) => w,\n-                None => fail!(\"Numeric overflow occured.\")\n+                None => fail2!(\"Numeric overflow occured.\")\n             };\n             match hi.checked_add(&z) {\n                 // This re-executes the addition that was already performed earlier when overflow\n@@ -163,7 +163,7 @@ pub fn add_bytes_to_bits_tuple\n                 // be Unsigned - overflow is not defined for Signed types. This function could be\n                 // implemented for signed types as well if that were needed.\n                 Some(y) => return (y, low + new_low_bits),\n-                None => fail!(\"Numeric overflow occured.\")\n+                None => fail2!(\"Numeric overflow occured.\")\n             }\n         }\n     }"}, {"sha": "bf91c5c5d7e6fe6526cf1947330390a0df7eb956", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -632,11 +632,11 @@ pub fn check_links<T>(list: &DList<T>) {\n     loop {\n         match (last_ptr, node_ptr.prev.resolve_immut()) {\n             (None   , None      ) => {}\n-            (None   , _         ) => fail!(\"prev link for list_head\"),\n+            (None   , _         ) => fail2!(\"prev link for list_head\"),\n             (Some(p), Some(pptr)) => {\n                 assert_eq!(p as *Node<T>, pptr as *Node<T>);\n             }\n-            _ => fail!(\"prev link is none, not good\"),\n+            _ => fail2!(\"prev link is none, not good\"),\n         }\n         match node_ptr.next {\n             Some(ref next) => {"}, {"sha": "8cba1a417d049651fa11c58a164cd75fcd62eb41", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -138,7 +138,7 @@ pub mod reader {\n                         (data[start + 3u] as uint),\n                     next: start + 4u};\n         }\n-        fail!(\"vint too big\");\n+        fail2!(\"vint too big\");\n     }\n \n     #[cfg(target_arch = \"x86\")]\n@@ -216,8 +216,8 @@ pub mod reader {\n         match maybe_get_doc(d, tg) {\n             Some(d) => d,\n             None => {\n-                error!(\"failed to find block with tag %u\", tg);\n-                fail!();\n+                error2!(\"failed to find block with tag {}\", tg);\n+                fail2!();\n             }\n         }\n     }\n@@ -305,31 +305,32 @@ pub mod reader {\n                     self.pos = r_doc.end;\n                     let str = r_doc.as_str_slice();\n                     if lbl != str {\n-                        fail!(\"Expected label %s but found %s\", lbl, str);\n+                        fail2!(\"Expected label {} but found {}\", lbl, str);\n                     }\n                 }\n             }\n         }\n \n         fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> Doc {\n-            debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n+            debug2!(\". next_doc(exp_tag={:?})\", exp_tag);\n             if self.pos >= self.parent.end {\n-                fail!(\"no more documents in current node!\");\n+                fail2!(\"no more documents in current node!\");\n             }\n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 doc_at(self.parent.data, self.pos);\n-            debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n+            debug2!(\"self.parent={}-{} self.pos={} r_tag={} r_doc={}-{}\",\n                    self.parent.start,\n                    self.parent.end,\n                    self.pos,\n                    r_tag,\n                    r_doc.start,\n                    r_doc.end);\n             if r_tag != (exp_tag as uint) {\n-                fail!(\"expected EBML doc with tag %? but found tag %?\", exp_tag, r_tag);\n+                fail2!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n+                       exp_tag, r_tag);\n             }\n             if r_doc.end > self.parent.end {\n-                fail!(\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n+                fail2!(\"invalid EBML, child extends to {:#x}, parent to {:#x}\",\n                       r_doc.end, self.parent.end);\n             }\n             self.pos = r_doc.end;\n@@ -351,7 +352,7 @@ pub mod reader {\n \n         fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> uint {\n             let r = doc_as_u32(self.next_doc(exp_tag));\n-            debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n+            debug2!(\"_next_uint exp_tag={:?} result={}\", exp_tag, r);\n             r as uint\n         }\n     }\n@@ -383,7 +384,7 @@ pub mod reader {\n         fn read_uint(&mut self) -> uint {\n             let v = doc_as_u64(self.next_doc(EsUint));\n             if v > (::std::uint::max_value as u64) {\n-                fail!(\"uint %? too large for this architecture\", v);\n+                fail2!(\"uint {} too large for this architecture\", v);\n             }\n             v as uint\n         }\n@@ -403,8 +404,8 @@ pub mod reader {\n         fn read_int(&mut self) -> int {\n             let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n             if v > (int::max_value as i64) || v < (int::min_value as i64) {\n-                debug!(\"FIXME #6122: Removing this makes this function miscompile\");\n-                fail!(\"int %? out of range for this architecture\", v);\n+                debug2!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n+                fail2!(\"int {} out of range for this architecture\", v);\n             }\n             v as int\n         }\n@@ -437,7 +438,7 @@ pub mod reader {\n                         name: &str,\n                         f: &fn(&mut Decoder) -> T)\n                         -> T {\n-            debug!(\"read_enum(%s)\", name);\n+            debug2!(\"read_enum({})\", name);\n             self._check_label(name);\n \n             let doc = self.next_doc(EsEnum);\n@@ -457,9 +458,9 @@ pub mod reader {\n                                 _: &[&str],\n                                 f: &fn(&mut Decoder, uint) -> T)\n                                 -> T {\n-            debug!(\"read_enum_variant()\");\n+            debug2!(\"read_enum_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n-            debug!(\"  idx=%u\", idx);\n+            debug2!(\"  idx={}\", idx);\n \n             let doc = self.next_doc(EsEnumBody);\n \n@@ -477,17 +478,17 @@ pub mod reader {\n         fn read_enum_variant_arg<T>(&mut self,\n                                     idx: uint,\n                                     f: &fn(&mut Decoder) -> T) -> T {\n-            debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n+            debug2!(\"read_enum_variant_arg(idx={})\", idx);\n             f(self)\n         }\n \n         fn read_enum_struct_variant<T>(&mut self,\n                                        _: &[&str],\n                                        f: &fn(&mut Decoder, uint) -> T)\n                                        -> T {\n-            debug!(\"read_enum_struct_variant()\");\n+            debug2!(\"read_enum_struct_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n-            debug!(\"  idx=%u\", idx);\n+            debug2!(\"  idx={}\", idx);\n \n             let doc = self.next_doc(EsEnumBody);\n \n@@ -507,7 +508,7 @@ pub mod reader {\n                                              idx: uint,\n                                              f: &fn(&mut Decoder) -> T)\n                                              -> T {\n-            debug!(\"read_enum_struct_variant_arg(name=%?, idx=%u)\", name, idx);\n+            debug2!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n             f(self)\n         }\n \n@@ -516,7 +517,7 @@ pub mod reader {\n                           _: uint,\n                           f: &fn(&mut Decoder) -> T)\n                           -> T {\n-            debug!(\"read_struct(name=%s)\", name);\n+            debug2!(\"read_struct(name={})\", name);\n             f(self)\n         }\n \n@@ -525,71 +526,71 @@ pub mod reader {\n                                 idx: uint,\n                                 f: &fn(&mut Decoder) -> T)\n                                 -> T {\n-            debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n+            debug2!(\"read_struct_field(name={}, idx={})\", name, idx);\n             self._check_label(name);\n             f(self)\n         }\n \n         fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-            debug!(\"read_tuple()\");\n+            debug2!(\"read_tuple()\");\n             self.read_seq(f)\n         }\n \n         fn read_tuple_arg<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n                              -> T {\n-            debug!(\"read_tuple_arg(idx=%u)\", idx);\n+            debug2!(\"read_tuple_arg(idx={})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n         fn read_tuple_struct<T>(&mut self,\n                                 name: &str,\n                                 f: &fn(&mut Decoder, uint) -> T)\n                                 -> T {\n-            debug!(\"read_tuple_struct(name=%?)\", name);\n+            debug2!(\"read_tuple_struct(name={})\", name);\n             self.read_tuple(f)\n         }\n \n         fn read_tuple_struct_arg<T>(&mut self,\n                                     idx: uint,\n                                     f: &fn(&mut Decoder) -> T)\n                                     -> T {\n-            debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n+            debug2!(\"read_tuple_struct_arg(idx={})\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n \n         fn read_option<T>(&mut self, f: &fn(&mut Decoder, bool) -> T) -> T {\n-            debug!(\"read_option()\");\n+            debug2!(\"read_option()\");\n             do self.read_enum(\"Option\") |this| {\n                 do this.read_enum_variant([\"None\", \"Some\"]) |this, idx| {\n                     match idx {\n                         0 => f(this, false),\n                         1 => f(this, true),\n-                        _ => fail!(),\n+                        _ => fail2!(),\n                     }\n                 }\n             }\n         }\n \n         fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-            debug!(\"read_seq()\");\n+            debug2!(\"read_seq()\");\n             do self.push_doc(EsVec) |d| {\n                 let len = d._next_uint(EsVecLen);\n-                debug!(\"  len=%u\", len);\n+                debug2!(\"  len={}\", len);\n                 f(d, len)\n             }\n         }\n \n         fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n                            -> T {\n-            debug!(\"read_seq_elt(idx=%u)\", idx);\n+            debug2!(\"read_seq_elt(idx={})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n         fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-            debug!(\"read_map()\");\n+            debug2!(\"read_map()\");\n             do self.push_doc(EsMap) |d| {\n                 let len = d._next_uint(EsMapLen);\n-                debug!(\"  len=%u\", len);\n+                debug2!(\"  len={}\", len);\n                 f(d, len)\n             }\n         }\n@@ -598,15 +599,15 @@ pub mod reader {\n                                idx: uint,\n                                f: &fn(&mut Decoder) -> T)\n                                -> T {\n-            debug!(\"read_map_elt_key(idx=%u)\", idx);\n+            debug2!(\"read_map_elt_key(idx={})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n         fn read_map_elt_val<T>(&mut self,\n                                idx: uint,\n                                f: &fn(&mut Decoder) -> T)\n                                -> T {\n-            debug!(\"read_map_elt_val(idx=%u)\", idx);\n+            debug2!(\"read_map_elt_val(idx={})\", idx);\n             self.push_doc(EsMapVal, f)\n         }\n     }\n@@ -642,7 +643,7 @@ pub mod writer {\n                             n as u8]),\n             4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n                             (n >> 8_u) as u8, n as u8]),\n-            _ => fail!(\"vint to write too big: %?\", n)\n+            _ => fail2!(\"vint to write too big: {}\", n)\n         };\n     }\n \n@@ -651,7 +652,7 @@ pub mod writer {\n         if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n         if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n         if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n-        fail!(\"vint to write too big: %?\", n);\n+        fail2!(\"vint to write too big: {}\", n);\n     }\n \n     pub fn Encoder(w: @io::Writer) -> Encoder {\n@@ -665,7 +666,7 @@ pub mod writer {\n     // FIXME (#2741): Provide a function to write the standard ebml header.\n     impl Encoder {\n         pub fn start_tag(&mut self, tag_id: uint) {\n-            debug!(\"Start tag %u\", tag_id);\n+            debug2!(\"Start tag {}\", tag_id);\n \n             // Write the enum ID:\n             write_vuint(self.writer, tag_id);\n@@ -684,7 +685,7 @@ pub mod writer {\n             write_sized_vuint(self.writer, size, 4u);\n             self.writer.seek(cur_pos as int, io::SeekSet);\n \n-            debug!(\"End tag (size = %u)\", size);\n+            debug2!(\"End tag (size = {})\", size);\n         }\n \n         pub fn wr_tag(&mut self, tag_id: uint, blk: &fn()) {\n@@ -748,12 +749,12 @@ pub mod writer {\n         }\n \n         pub fn wr_bytes(&mut self, b: &[u8]) {\n-            debug!(\"Write %u bytes\", b.len());\n+            debug2!(\"Write {} bytes\", b.len());\n             self.writer.write(b);\n         }\n \n         pub fn wr_str(&mut self, s: &str) {\n-            debug!(\"Write str: %?\", s);\n+            debug2!(\"Write str: {}\", s);\n             self.writer.write(s.as_bytes());\n         }\n     }\n@@ -977,15 +978,15 @@ mod tests {\n     #[test]\n     fn test_option_int() {\n         fn test_v(v: Option<int>) {\n-            debug!(\"v == %?\", v);\n+            debug2!(\"v == {:?}\", v);\n             let bytes = do io::with_bytes_writer |wr| {\n                 let mut ebml_w = writer::Encoder(wr);\n                 v.encode(&mut ebml_w)\n             };\n             let ebml_doc = reader::Doc(@bytes);\n             let mut deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&mut deser);\n-            debug!(\"v1 == %?\", v1);\n+            debug2!(\"v1 == {:?}\", v1);\n             assert_eq!(v, v1);\n         }\n "}, {"sha": "37bcb447f082eaec62858d8dfc24cf88a9167796", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -43,7 +43,7 @@ to handle any `FileInput` structs. E.g. a simple `cat` program\n or a program that numbers lines after concatenating two files\n \n     for input_vec_state(make_path_option_vec([~\"a.txt\", ~\"b.txt\"])) |line, state| {\n-        io::println(fmt!(\"%u: %s\", state.line_num,\n+        io::println(format!(\"{}: %s\", state.line_num,\n                                    line));\n     }\n \n@@ -88,7 +88,7 @@ total line count).\n         input.next_file(); // skip!\n \n         for input.each_line_state |line, state| {\n-           io::println(fmt!(\"%u: %s\", state.line_num_file,\n+           io::println(format!(\"{}: %s\", state.line_num_file,\n                                       line))\n         }\n     }\n@@ -449,11 +449,11 @@ mod test {\n     fn test_fileinput_read_byte() {\n         let filenames = make_path_option_vec(vec::from_fn(\n             3,\n-            |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-byte-%u.tmp\", i)), true);\n+            |i| format!(\"tmp/lib-fileinput-test-fileinput-read-byte-{}.tmp\", i)), true);\n \n         // 3 files containing 0\\n, 1\\n, and 2\\n respectively\n         for (i, filename) in filenames.iter().enumerate() {\n-            make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n+            make_file(filename.get_ref(), [format!(\"{}\", i)]);\n         }\n \n         let fi = FileInput::from_vec(filenames.clone());\n@@ -479,11 +479,11 @@ mod test {\n     fn test_fileinput_read() {\n         let filenames = make_path_option_vec(vec::from_fn(\n             3,\n-            |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-%u.tmp\", i)), true);\n+            |i| format!(\"tmp/lib-fileinput-test-fileinput-read-{}.tmp\", i)), true);\n \n         // 3 files containing 1\\n, 2\\n, and 3\\n respectively\n         for (i, filename) in filenames.iter().enumerate() {\n-            make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n+            make_file(filename.get_ref(), [format!(\"{}\", i)]);\n         }\n \n         let fi = FileInput::from_vec(filenames);\n@@ -500,13 +500,13 @@ mod test {\n         let mut all_lines = ~[];\n         let filenames = make_path_option_vec(vec::from_fn(\n             3,\n-            |i| fmt!(\"tmp/lib-fileinput-test-input-vec-%u.tmp\", i)), true);\n+            |i| format!(\"tmp/lib-fileinput-test-input-vec-{}.tmp\", i)), true);\n \n         for (i, filename) in filenames.iter().enumerate() {\n             let contents =\n-                vec::from_fn(3, |j| fmt!(\"%u %u\", i, j));\n+                vec::from_fn(3, |j| format!(\"{} {}\", i, j));\n             make_file(filename.get_ref(), contents);\n-            debug!(\"contents=%?\", contents);\n+            debug2!(\"contents={:?}\", contents);\n             all_lines.push_all(contents);\n         }\n \n@@ -522,11 +522,11 @@ mod test {\n     fn test_input_vec_state() {\n         let filenames = make_path_option_vec(vec::from_fn(\n             3,\n-            |i| fmt!(\"tmp/lib-fileinput-test-input-vec-state-%u.tmp\", i)),true);\n+            |i| format!(\"tmp/lib-fileinput-test-input-vec-state-{}.tmp\", i)),true);\n \n         for (i, filename) in filenames.iter().enumerate() {\n             let contents =\n-                vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n+                vec::from_fn(3, |j| format!(\"{} {}\", i, j + 1));\n             make_file(filename.get_ref(), contents);\n         }\n \n@@ -544,7 +544,7 @@ mod test {\n     fn test_empty_files() {\n         let filenames = make_path_option_vec(vec::from_fn(\n             3,\n-            |i| fmt!(\"tmp/lib-fileinput-test-empty-files-%u.tmp\", i)),true);\n+            |i| format!(\"tmp/lib-fileinput-test-empty-files-{}.tmp\", i)),true);\n \n         make_file(filenames[0].get_ref(), [~\"1\", ~\"2\"]);\n         make_file(filenames[1].get_ref(), []);\n@@ -555,7 +555,7 @@ mod test {\n             let expected_path = match line {\n                 \"1\" | \"2\" => filenames[0].clone(),\n                 \"3\" | \"4\" => filenames[2].clone(),\n-                _ => fail!(\"unexpected line\")\n+                _ => fail2!(\"unexpected line\")\n             };\n             assert_eq!(state.current_path.clone(), expected_path);\n             count += 1;\n@@ -593,11 +593,11 @@ mod test {\n     fn test_next_file() {\n         let filenames = make_path_option_vec(vec::from_fn(\n             3,\n-            |i| fmt!(\"tmp/lib-fileinput-test-next-file-%u.tmp\", i)),true);\n+            |i| format!(\"tmp/lib-fileinput-test-next-file-{}.tmp\", i)),true);\n \n         for (i, filename) in filenames.iter().enumerate() {\n             let contents =\n-                vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n+                vec::from_fn(3, |j| format!(\"{} {}\", i, j + 1));\n             make_file(filename.get_ref(), contents);\n         }\n \n@@ -609,7 +609,7 @@ mod test {\n \n         // read all lines from 1 (but don't read any from 2),\n         for i in range(1u, 4) {\n-            assert_eq!(input.read_line(), fmt!(\"1 %u\", i));\n+            assert_eq!(input.read_line(), format!(\"1 {}\", i));\n         }\n         // 1 is finished, but 2 hasn't been started yet, so this will\n         // just \"skip\" to the beginning of 2 (Python's fileinput does"}, {"sha": "616c7522a488bfc357a60f47cdf7f714c3fca057", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -121,11 +121,11 @@ mod tests {\n             do 2000.times {\n                 input.push_all(r.choose(words));\n             }\n-            debug!(\"de/inflate of %u bytes of random word-sequences\",\n+            debug2!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());\n             let cmp = deflate_bytes(input);\n             let out = inflate_bytes(cmp);\n-            debug!(\"%u bytes deflated to %u (%.1f%% size)\",\n+            debug2!(\"{} bytes deflated to {} ({:.1f}% size)\",\n                    input.len(), cmp.len(),\n                    100.0 * ((cmp.len() as float) / (input.len() as float)));\n             assert_eq!(input, out);"}, {"sha": "1fd81626188c526c3279485b032e68d970cd2a71", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -261,14 +261,14 @@ impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n     fn recv(&self) -> T {\n         match self.try_recv() {\n             Some(val) => val,\n-            None => fail!(\"port is closed\")\n+            None => fail2!(\"port is closed\")\n         }\n     }\n     fn try_recv(&self) -> Option<T> {\n         let command = match self.byte_port.try_recv(CONTINUE.len()) {\n             Some(c) => c,\n             None => {\n-                warn!(\"flatpipe: broken pipe\");\n+                warn2!(\"flatpipe: broken pipe\");\n                 return None;\n             }\n         };\n@@ -279,7 +279,7 @@ impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n                     io::u64_from_be_bytes(bytes, 0, size_of::<u64>())\n                 },\n                 None => {\n-                    warn!(\"flatpipe: broken pipe\");\n+                    warn2!(\"flatpipe: broken pipe\");\n                     return None;\n                 }\n             };\n@@ -291,13 +291,13 @@ impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n                     Some(self.unflattener.unflatten(bytes))\n                 }\n                 None => {\n-                    warn!(\"flatpipe: broken pipe\");\n+                    warn2!(\"flatpipe: broken pipe\");\n                     return None;\n                 }\n             }\n         }\n         else {\n-            fail!(\"flatpipe: unrecognized command\");\n+            fail2!(\"flatpipe: unrecognized command\");\n         }\n     }\n }\n@@ -477,7 +477,7 @@ pub mod flatteners {\n                 Ok(json) => {\n                     json::Decoder(json)\n                 }\n-                Err(e) => fail!(\"flatpipe: can't parse json: %?\", e)\n+                Err(e) => fail2!(\"flatpipe: can't parse json: {:?}\", e)\n             }\n         }\n     }\n@@ -536,7 +536,7 @@ pub mod bytepipes {\n             if left == 0 {\n                 return Some(bytes);\n             } else {\n-                warn!(\"flatpipe: dropped %? broken bytes\", left);\n+                warn2!(\"flatpipe: dropped {} broken bytes\", left);\n                 return None;\n             }\n         }\n@@ -797,7 +797,7 @@ mod test {\n             let listen_res = do tcp::listen(\n                 addr.clone(), port, 128, iotask, |_kill_ch| {\n                     // Tell the sender to initiate the connection\n-                    debug!(\"listening\");\n+                    debug2!(\"listening\");\n                     begin_connect_chan.send(())\n                 }) |new_conn, kill_ch| {\n \n@@ -820,7 +820,7 @@ mod test {\n             // Wait for the server to start listening\n             begin_connect_port.recv();\n \n-            debug!(\"connecting\");\n+            debug2!(\"connecting\");\n             let iotask = &uv::global_loop::get();\n             let connect_result = tcp::connect(addr.clone(), port, iotask);\n             assert!(connect_result.is_ok());\n@@ -831,7 +831,7 @@ mod test {\n             let chan = writer_chan(socket_buf);\n \n             for i in range(0, 10) {\n-                debug!(\"sending %?\", i);\n+                debug2!(\"sending {}\", i);\n                 chan.send(i)\n             }\n         }\n@@ -841,9 +841,9 @@ mod test {\n             // Wait for a connection\n             let (conn, res_chan) = accept_port.recv();\n \n-            debug!(\"accepting connection\");\n+            debug2!(\"accepting connection\");\n             let accept_result = tcp::accept(conn);\n-            debug!(\"accepted\");\n+            debug2!(\"accepted\");\n             assert!(accept_result.is_ok());\n             let sock = result::unwrap(accept_result);\n             res_chan.send(());\n@@ -855,7 +855,7 @@ mod test {\n \n             for i in range(0, 10) {\n                 let j = port.recv();\n-                debug!(\"received %?\", j);\n+                debug2!(\"received {:?}\", j);\n                 assert_eq!(i, j);\n             }\n "}, {"sha": "516a34f531283c14ca1df5f6019ec2d125a5fd13", "filename": "src/libextra/future.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -57,7 +57,7 @@ impl<A> Future<A> {\n         let state = replace(&mut this.state, Evaluating);\n         match state {\n             Forced(v) => v,\n-            _ => fail!( \"Logic error.\" ),\n+            _ => fail2!( \"Logic error.\" ),\n         }\n     }\n \n@@ -69,10 +69,10 @@ impl<A> Future<A> {\n         */\n         match self.state {\n             Forced(ref v) => return v,\n-            Evaluating => fail!(\"Recursive forcing of future!\"),\n+            Evaluating => fail2!(\"Recursive forcing of future!\"),\n             Pending(_) => {\n                 match replace(&mut self.state, Evaluating) {\n-                    Forced(_) | Evaluating => fail!(\"Logic error.\"),\n+                    Forced(_) | Evaluating => fail2!(\"Logic error.\"),\n                     Pending(f) => {\n                         self.state = Forced(f());\n                         self.get_ref()\n@@ -217,7 +217,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_futurefail() {\n-        let mut f = Future::spawn(|| fail!());\n+        let mut f = Future::spawn(|| fail2!());\n         let _x: ~str = f.get();\n     }\n "}, {"sha": "e9ccbbf605a371ec7a32e90092871cebf7eff763", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -60,7 +60,7 @@\n //!     ];\n //!     let matches = match getopts(args.tail(), opts) {\n //!         Ok(m) => { m }\n-//!         Err(f) => { fail!(f.to_err_msg()) }\n+//!         Err(f) => { fail2!(f.to_err_msg()) }\n //!     };\n //!     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n //!         print_usage(program, opts);\n@@ -185,7 +185,7 @@ impl Matches {\n     pub fn opt_vals(&self, nm: &str) -> ~[Optval] {\n         match find_opt(self.opts, Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n-            None => fail!(\"No option '%s' defined\", nm)\n+            None => fail2!(\"No option '{}' defined\", nm)\n         }\n     }\n \n@@ -365,19 +365,19 @@ impl Fail_ {\n     pub fn to_err_msg(self) -> ~str {\n         match self {\n             ArgumentMissing(ref nm) => {\n-                fmt!(\"Argument to option '%s' missing.\", *nm)\n+                format!(\"Argument to option '{}' missing.\", *nm)\n             }\n             UnrecognizedOption(ref nm) => {\n-                fmt!(\"Unrecognized option: '%s'.\", *nm)\n+                format!(\"Unrecognized option: '{}'.\", *nm)\n             }\n             OptionMissing(ref nm) => {\n-                fmt!(\"Required option '%s' missing.\", *nm)\n+                format!(\"Required option '{}' missing.\", *nm)\n             }\n             OptionDuplicated(ref nm) => {\n-                fmt!(\"Option '%s' given more than once.\", *nm)\n+                format!(\"Option '{}' given more than once.\", *nm)\n             }\n             UnexpectedArgument(ref nm) => {\n-                fmt!(\"Option '%s' does not take an argument.\", *nm)\n+                format!(\"Option '{}' does not take an argument.\", *nm)\n             }\n         }\n     }\n@@ -551,7 +551,7 @@ pub mod groups {\n             } = (*self).clone();\n \n             match (short_name.len(), long_name.len()) {\n-                (0,0) => fail!(\"this long-format option was given no name\"),\n+                (0,0) => fail2!(\"this long-format option was given no name\"),\n                 (0,_) => Opt {\n                     name: Long((long_name)),\n                     hasarg: hasarg,\n@@ -577,7 +577,7 @@ pub mod groups {\n                         }\n                     ]\n                 },\n-                (_,_) => fail!(\"something is wrong with the long-form opt\")\n+                (_,_) => fail2!(\"something is wrong with the long-form opt\")\n             }\n         }\n     }\n@@ -696,7 +696,7 @@ pub mod groups {\n                     row.push_str(short_name);\n                     row.push_char(' ');\n                 }\n-                _ => fail!(\"the short name should only be 1 ascii char long\"),\n+                _ => fail2!(\"the short name should only be 1 ascii char long\"),\n             }\n \n             // long option\n@@ -752,7 +752,7 @@ pub mod groups {\n             row\n         });\n \n-        fmt!(\"%s\\n\\nOptions:\\n%s\\n\", brief, rows.collect::<~[~str]>().connect(\"\\n\"))\n+        format!(\"{}\\n\\nOptions:\\n{}\\n\", brief, rows.collect::<~[~str]>().connect(\"\\n\"))\n     }\n \n     /// Splits a string into substrings with possibly internal whitespace,\n@@ -810,7 +810,7 @@ pub mod groups {\n \n                 (B, Cr, UnderLim) => { B }\n                 (B, Cr, OverLim)  if (i - last_start + 1) > lim\n-                                => fail!(\"word starting with %? longer than limit!\",\n+                                => fail2!(\"word starting with {} longer than limit!\",\n                                         ss.slice(last_start, i + 1)),\n                 (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n                 (B, Ws, UnderLim) => { last_end = i; C }\n@@ -883,7 +883,7 @@ mod tests {\n             assert!(m.opt_present(\"test\"));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n           }\n-          _ => { fail!(\"test_reqopt_long failed\"); }\n+          _ => { fail2!(\"test_reqopt_long failed\"); }\n         }\n     }\n \n@@ -894,7 +894,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -905,7 +905,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -916,7 +916,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -930,7 +930,7 @@ mod tests {\n             assert!(m.opt_present(\"t\"));\n             assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -941,7 +941,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -952,7 +952,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -963,7 +963,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -979,7 +979,7 @@ mod tests {\n             assert!(m.opt_present(\"test\"));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -990,7 +990,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"test\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1001,7 +1001,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1012,7 +1012,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1026,7 +1026,7 @@ mod tests {\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1037,7 +1037,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"t\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1048,7 +1048,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1059,7 +1059,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1072,7 +1072,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(m.opt_present(\"test\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1083,7 +1083,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"test\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1094,10 +1094,10 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => {\n-            error!(f.clone().to_err_msg());\n+            error2!(\"{:?}\", f.clone().to_err_msg());\n             check_fail_type(f, UnexpectedArgument_);\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1108,7 +1108,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1119,7 +1119,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(m.opt_present(\"t\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1130,7 +1130,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"t\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1145,7 +1145,7 @@ mod tests {\n \n             assert!(m.free[0] == ~\"20\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1156,7 +1156,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1170,7 +1170,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 1);\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1183,7 +1183,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 2);\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1196,7 +1196,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 2);\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1209,7 +1209,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 1);\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1222,7 +1222,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 2);\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1237,7 +1237,7 @@ mod tests {\n             assert!((m.opt_present(\"test\")));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1248,7 +1248,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"test\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1259,7 +1259,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1276,7 +1276,7 @@ mod tests {\n               assert!(pair[0] == ~\"20\");\n               assert!(pair[1] == ~\"30\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1290,7 +1290,7 @@ mod tests {\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1301,7 +1301,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"t\")),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1312,7 +1312,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1329,7 +1329,7 @@ mod tests {\n             assert!(pair[0] == ~\"20\");\n             assert!(pair[1] == ~\"30\");\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1340,7 +1340,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1351,7 +1351,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1383,7 +1383,7 @@ mod tests {\n             assert!(pair[1] == ~\"-60 70\");\n             assert!((!m.opt_present(\"notpresent\")));\n           }\n-          _ => fail!()\n+          _ => fail2!()\n         }\n     }\n \n@@ -1394,7 +1394,7 @@ mod tests {\n         let args_single = ~[~\"-e\", ~\"foo\"];\n         let matches_single = &match getopts(args_single, opts) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail!()\n+          result::Err(_) => fail2!()\n         };\n         assert!(matches_single.opts_present([~\"e\"]));\n         assert!(matches_single.opts_present([~\"encrypt\", ~\"e\"]));\n@@ -1410,7 +1410,7 @@ mod tests {\n         let args_both = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let matches_both = &match getopts(args_both, opts) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail!()\n+          result::Err(_) => fail2!()\n         };\n         assert!(matches_both.opts_present([~\"e\"]));\n         assert!(matches_both.opts_present([~\"encrypt\"]));\n@@ -1432,7 +1432,7 @@ mod tests {\n         let opts = ~[optmulti(\"L\"), optmulti(\"M\")];\n         let matches = &match getopts(args, opts) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail!()\n+          result::Err(_) => fail2!()\n         };\n         assert!(matches.opts_present([~\"L\"]));\n         assert_eq!(matches.opts_str([~\"L\"]).unwrap(), ~\"foo\");\n@@ -1575,8 +1575,8 @@ Options:\n \n         let generated_usage = groups::usage(\"Usage: fruits\", optgroups);\n \n-        debug!(\"expected: <<%s>>\", expected);\n-        debug!(\"generated: <<%s>>\", generated_usage);\n+        debug2!(\"expected: <<{}>>\", expected);\n+        debug2!(\"generated: <<{}>>\", generated_usage);\n         assert_eq!(generated_usage, expected);\n     }\n \n@@ -1603,8 +1603,8 @@ Options:\n \n         let usage = groups::usage(\"Usage: fruits\", optgroups);\n \n-        debug!(\"expected: <<%s>>\", expected);\n-        debug!(\"generated: <<%s>>\", usage);\n+        debug2!(\"expected: <<{}>>\", expected);\n+        debug2!(\"generated: <<{}>>\", usage);\n         assert!(usage == expected)\n     }\n \n@@ -1630,8 +1630,8 @@ Options:\n \n         let usage = groups::usage(\"Usage: fruits\", optgroups);\n \n-        debug!(\"expected: <<%s>>\", expected);\n-        debug!(\"generated: <<%s>>\", usage);\n+        debug2!(\"expected: <<{}>>\", expected);\n+        debug2!(\"generated: <<{}>>\", usage);\n         assert!(usage == expected)\n     }\n }"}, {"sha": "9af2f1acc693138d431a3a52ab81f4c57fe003a5", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -552,13 +552,13 @@ mod test {\n \n         let pat = Pattern::new(\"a[0-9]b\");\n         for i in range(0, 10) {\n-            assert!(pat.matches(fmt!(\"a%db\", i)));\n+            assert!(pat.matches(format!(\"a{}b\", i)));\n         }\n         assert!(!pat.matches(\"a_b\"));\n \n         let pat = Pattern::new(\"a[!0-9]b\");\n         for i in range(0, 10) {\n-            assert!(!pat.matches(fmt!(\"a%db\", i)));\n+            assert!(!pat.matches(format!(\"a{}b\", i)));\n         }\n         assert!(pat.matches(\"a_b\"));\n "}, {"sha": "709b4a95981f2c6f72dde1ddd64676665090933b", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -102,8 +102,8 @@ impl<'self> FromHex for &'self str {\n                     buf >>= 4;\n                     loop\n                 }\n-                _ => return Err(fmt!(\"Invalid character '%c' at position %u\",\n-                                     self.char_at(idx), idx))\n+                _ => return Err(format!(\"Invalid character '{}' at position {}\",\n+                                        self.char_at(idx), idx))\n             }\n \n             modulus += 1;\n@@ -158,15 +158,15 @@ mod tests {\n     #[test]\n     pub fn test_to_hex_all_bytes() {\n         for i in range(0, 256) {\n-            assert_eq!([i as u8].to_hex(), fmt!(\"%02x\", i as uint));\n+            assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as uint));\n         }\n     }\n \n     #[test]\n     pub fn test_from_hex_all_bytes() {\n         for i in range(0, 256) {\n-            assert_eq!(fmt!(\"%02x\", i as uint).from_hex().unwrap(), ~[i as u8]);\n-            assert_eq!(fmt!(\"%02X\", i as uint).from_hex().unwrap(), ~[i as u8]);\n+            assert_eq!(format!(\"{:02x}\", i as uint).from_hex().unwrap(), ~[i as u8]);\n+            assert_eq!(format!(\"{:02X}\", i as uint).from_hex().unwrap(), ~[i as u8]);\n         }\n     }\n "}, {"sha": "fe1bbfc9ae4c862d57a682afee5fa2cc308868d0", "filename": "src/libextra/json.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -885,10 +885,10 @@ pub fn Decoder(json: Json) -> Decoder {\n \n impl serialize::Decoder for Decoder {\n     fn read_nil(&mut self) -> () {\n-        debug!(\"read_nil\");\n+        debug2!(\"read_nil\");\n         match self.stack.pop() {\n             Null => (),\n-            value => fail!(\"not a null: %?\", value)\n+            value => fail2!(\"not a null: {:?}\", value)\n         }\n     }\n \n@@ -905,71 +905,71 @@ impl serialize::Decoder for Decoder {\n     fn read_int(&mut self) -> int { self.read_float() as int }\n \n     fn read_bool(&mut self) -> bool {\n-        debug!(\"read_bool\");\n+        debug2!(\"read_bool\");\n         match self.stack.pop() {\n             Boolean(b) => b,\n-            value => fail!(\"not a boolean: %?\", value)\n+            value => fail2!(\"not a boolean: {:?}\", value)\n         }\n     }\n \n     fn read_f64(&mut self) -> f64 { self.read_float() as f64 }\n     fn read_f32(&mut self) -> f32 { self.read_float() as f32 }\n     fn read_float(&mut self) -> float {\n-        debug!(\"read_float\");\n+        debug2!(\"read_float\");\n         match self.stack.pop() {\n             Number(f) => f,\n-            value => fail!(\"not a number: %?\", value)\n+            value => fail2!(\"not a number: {:?}\", value)\n         }\n     }\n \n     fn read_char(&mut self) -> char {\n         let mut v = ~[];\n         let s = self.read_str();\n         for c in s.iter() { v.push(c) }\n-        if v.len() != 1 { fail!(\"string must have one character\") }\n+        if v.len() != 1 { fail2!(\"string must have one character\") }\n         v[0]\n     }\n \n     fn read_str(&mut self) -> ~str {\n-        debug!(\"read_str\");\n+        debug2!(\"read_str\");\n         match self.stack.pop() {\n             String(s) => s,\n-            json => fail!(\"not a string: %?\", json)\n+            json => fail2!(\"not a string: {:?}\", json)\n         }\n     }\n \n     fn read_enum<T>(&mut self, name: &str, f: &fn(&mut Decoder) -> T) -> T {\n-        debug!(\"read_enum(%s)\", name);\n+        debug2!(\"read_enum({})\", name);\n         f(self)\n     }\n \n     fn read_enum_variant<T>(&mut self,\n                             names: &[&str],\n                             f: &fn(&mut Decoder, uint) -> T)\n                             -> T {\n-        debug!(\"read_enum_variant(names=%?)\", names);\n+        debug2!(\"read_enum_variant(names={:?})\", names);\n         let name = match self.stack.pop() {\n             String(s) => s,\n             Object(o) => {\n                 let n = match o.find(&~\"variant\").expect(\"invalidly encoded json\") {\n                     &String(ref s) => s.clone(),\n-                    _ => fail!(\"invalidly encoded json\"),\n+                    _ => fail2!(\"invalidly encoded json\"),\n                 };\n                 match o.find(&~\"fields\").expect(\"invalidly encoded json\") {\n                     &List(ref l) => {\n                         for field in l.rev_iter() {\n                             self.stack.push(field.clone());\n                         }\n                     },\n-                    _ => fail!(\"invalidly encoded json\")\n+                    _ => fail2!(\"invalidly encoded json\")\n                 }\n                 n\n             }\n-            ref json => fail!(\"invalid variant: %?\", *json),\n+            ref json => fail2!(\"invalid variant: {:?}\", *json),\n         };\n         let idx = match names.iter().position(|n| str::eq_slice(*n, name)) {\n             Some(idx) => idx,\n-            None => fail!(\"Unknown variant name: %?\", name),\n+            None => fail2!(\"Unknown variant name: {}\", name),\n         };\n         f(self, idx)\n     }\n@@ -978,15 +978,15 @@ impl serialize::Decoder for Decoder {\n                                 idx: uint,\n                                 f: &fn(&mut Decoder) -> T)\n                                 -> T {\n-        debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n+        debug2!(\"read_enum_variant_arg(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_enum_struct_variant<T>(&mut self,\n                                    names: &[&str],\n                                    f: &fn(&mut Decoder, uint) -> T)\n                                    -> T {\n-        debug!(\"read_enum_struct_variant(names=%?)\", names);\n+        debug2!(\"read_enum_struct_variant(names={:?})\", names);\n         self.read_enum_variant(names, f)\n     }\n \n@@ -996,7 +996,7 @@ impl serialize::Decoder for Decoder {\n                                          idx: uint,\n                                          f: &fn(&mut Decoder) -> T)\n                                          -> T {\n-        debug!(\"read_enum_struct_variant_field(name=%?, idx=%u)\", name, idx);\n+        debug2!(\"read_enum_struct_variant_field(name={}, idx={})\", name, idx);\n         self.read_enum_variant_arg(idx, f)\n     }\n \n@@ -1005,7 +1005,7 @@ impl serialize::Decoder for Decoder {\n                       len: uint,\n                       f: &fn(&mut Decoder) -> T)\n                       -> T {\n-        debug!(\"read_struct(name=%s, len=%u)\", name, len);\n+        debug2!(\"read_struct(name={}, len={})\", name, len);\n         let value = f(self);\n         self.stack.pop();\n         value\n@@ -1016,12 +1016,12 @@ impl serialize::Decoder for Decoder {\n                             idx: uint,\n                             f: &fn(&mut Decoder) -> T)\n                             -> T {\n-        debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n+        debug2!(\"read_struct_field(name={}, idx={})\", name, idx);\n         match self.stack.pop() {\n             Object(obj) => {\n                 let mut obj = obj;\n                 let value = match obj.pop(&name.to_owned()) {\n-                    None => fail!(\"no such field: %s\", name),\n+                    None => fail2!(\"no such field: {}\", name),\n                     Some(json) => {\n                         self.stack.push(json);\n                         f(self)\n@@ -1030,36 +1030,36 @@ impl serialize::Decoder for Decoder {\n                 self.stack.push(Object(obj));\n                 value\n             }\n-            value => fail!(\"not an object: %?\", value)\n+            value => fail2!(\"not an object: {:?}\", value)\n         }\n     }\n \n     fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-        debug!(\"read_tuple()\");\n+        debug2!(\"read_tuple()\");\n         self.read_seq(f)\n     }\n \n     fn read_tuple_arg<T>(&mut self,\n                          idx: uint,\n                          f: &fn(&mut Decoder) -> T)\n                          -> T {\n-        debug!(\"read_tuple_arg(idx=%u)\", idx);\n+        debug2!(\"read_tuple_arg(idx={})\", idx);\n         self.read_seq_elt(idx, f)\n     }\n \n     fn read_tuple_struct<T>(&mut self,\n                             name: &str,\n                             f: &fn(&mut Decoder, uint) -> T)\n                             -> T {\n-        debug!(\"read_tuple_struct(name=%?)\", name);\n+        debug2!(\"read_tuple_struct(name={})\", name);\n         self.read_tuple(f)\n     }\n \n     fn read_tuple_struct_arg<T>(&mut self,\n                                 idx: uint,\n                                 f: &fn(&mut Decoder) -> T)\n                                 -> T {\n-        debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n+        debug2!(\"read_tuple_struct_arg(idx={})\", idx);\n         self.read_tuple_arg(idx, f)\n     }\n \n@@ -1071,7 +1071,7 @@ impl serialize::Decoder for Decoder {\n     }\n \n     fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-        debug!(\"read_seq()\");\n+        debug2!(\"read_seq()\");\n         let len = match self.stack.pop() {\n             List(list) => {\n                 let len = list.len();\n@@ -1080,18 +1080,18 @@ impl serialize::Decoder for Decoder {\n                 }\n                 len\n             }\n-            _ => fail!(\"not a list\"),\n+            _ => fail2!(\"not a list\"),\n         };\n         f(self, len)\n     }\n \n     fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T) -> T {\n-        debug!(\"read_seq_elt(idx=%u)\", idx);\n+        debug2!(\"read_seq_elt(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-        debug!(\"read_map()\");\n+        debug2!(\"read_map()\");\n         let len = match self.stack.pop() {\n             Object(obj) => {\n                 let len = obj.len();\n@@ -1101,7 +1101,7 @@ impl serialize::Decoder for Decoder {\n                 }\n                 len\n             }\n-            json => fail!(\"not an object: %?\", json),\n+            json => fail2!(\"not an object: {:?}\", json),\n         };\n         f(self, len)\n     }\n@@ -1110,13 +1110,13 @@ impl serialize::Decoder for Decoder {\n                            idx: uint,\n                            f: &fn(&mut Decoder) -> T)\n                            -> T {\n-        debug!(\"read_map_elt_key(idx=%u)\", idx);\n+        debug2!(\"read_map_elt_key(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_map_elt_val<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n                            -> T {\n-        debug!(\"read_map_elt_val(idx=%u)\", idx);\n+        debug2!(\"read_map_elt_val(idx={})\", idx);\n         f(self)\n     }\n }\n@@ -1321,7 +1321,7 @@ impl to_str::ToStr for Json {\n \n impl to_str::ToStr for Error {\n     fn to_str(&self) -> ~str {\n-        fmt!(\"%u:%u: %s\", self.line, self.col, *self.msg)\n+        format!(\"{}:{}: {}\", self.line, self.col, *self.msg)\n     }\n }\n "}, {"sha": "5283edbf475e08a3a47f68971c5a9fee406f66de", "filename": "src/libextra/list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -96,7 +96,7 @@ pub fn len<T>(ls: @List<T>) -> uint {\n pub fn tail<T>(ls: @List<T>) -> @List<T> {\n     match *ls {\n         Cons(_, tl) => return tl,\n-        Nil => fail!(\"list empty\")\n+        Nil => fail2!(\"list empty\")\n     }\n }\n \n@@ -105,7 +105,7 @@ pub fn head<T:Clone>(ls: @List<T>) -> T {\n     match *ls {\n       Cons(ref hd, _) => (*hd).clone(),\n       // makes me sad\n-      _ => fail!(\"head invoked on empty list\")\n+      _ => fail2!(\"head invoked on empty list\")\n     }\n }\n "}, {"sha": "2ec9c7471799f76a3abe59812e679e37b8cb133a", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -352,7 +352,7 @@ impl Rem<BigUint, BigUint> for BigUint {\n \n impl Neg<BigUint> for BigUint {\n     #[inline]\n-    fn neg(&self) -> BigUint { fail!() }\n+    fn neg(&self) -> BigUint { fail2!() }\n }\n \n impl Integer for BigUint {\n@@ -374,7 +374,7 @@ impl Integer for BigUint {\n     }\n \n     fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        if other.is_zero() { fail!() }\n+        if other.is_zero() { fail2!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n         if *other == One::one() { return ((*self).clone(), Zero::zero()); }\n \n@@ -726,7 +726,7 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n         14 => (1475789056, 8),\n         15 => (2562890625, 8),\n         16 => (4294967296, 8),\n-        _  => fail!()\n+        _  => fail2!()\n     }\n }\n \n@@ -750,7 +750,7 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n         14 => (38416, 4),\n         15 => (50625, 4),\n         16 => (65536, 4),\n-        _  => fail!()\n+        _  => fail2!()\n     }\n }\n \n@@ -1004,7 +1004,7 @@ impl Integer for BigInt {\n         let d = BigInt::from_biguint(Plus, d_ui);\n         let r = BigInt::from_biguint(Plus, r_ui);\n         match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n+            (_,    Zero)   => fail2!(),\n             (Plus, Plus)  | (Zero, Plus)  => ( d,  r),\n             (Plus, Minus) | (Zero, Minus) => (-d,  r),\n             (Minus, Plus)                 => (-d, -r),\n@@ -1030,7 +1030,7 @@ impl Integer for BigInt {\n         let d = BigInt::from_biguint(Plus, d_ui);\n         let m = BigInt::from_biguint(Plus, m_ui);\n         match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n+            (_,    Zero)   => fail2!(),\n             (Plus, Plus)  | (Zero, Plus)  => (d, m),\n             (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n                 (-d, Zero::zero())\n@@ -1742,7 +1742,7 @@ mod biguint_tests {\n              ~\"2\" +\n              str::from_chars(vec::from_elem(bits / 2 - 1, '0')) + \"1\"),\n             (10, match bits {\n-                32 => ~\"8589934593\", 16 => ~\"131073\", _ => fail!()\n+                32 => ~\"8589934593\", 16 => ~\"131073\", _ => fail2!()\n             }),\n             (16,\n              ~\"2\" +\n@@ -1759,7 +1759,7 @@ mod biguint_tests {\n             (10, match bits {\n                 32 => ~\"55340232229718589441\",\n                 16 => ~\"12885032961\",\n-                _ => fail!()\n+                _ => fail2!()\n             }),\n             (16, ~\"3\" +\n              str::from_chars(vec::from_elem(bits / 4 - 1, '0')) + \"2\" +\n@@ -1814,7 +1814,7 @@ mod biguint_tests {\n         fn check(n: uint, s: &str) {\n             let n = factor(n);\n             let ans = match FromStrRadix::from_str_radix(s, 10) {\n-                Some(x) => x, None => fail!()\n+                Some(x) => x, None => fail2!()\n             };\n             assert_eq!(n, ans);\n         }"}, {"sha": "8943e2ac012df6b10232b5653af1ee288b815170", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -172,19 +172,19 @@ impl<T: Clone + Num> One for Cmplx<T> {\n impl<T: ToStr + Num + Ord> ToStr for Cmplx<T> {\n     fn to_str(&self) -> ~str {\n         if self.im < Zero::zero() {\n-            fmt!(\"%s-%si\", self.re.to_str(), (-self.im).to_str())\n+            format!(\"{}-{}i\", self.re.to_str(), (-self.im).to_str())\n         } else {\n-            fmt!(\"%s+%si\", self.re.to_str(), self.im.to_str())\n+            format!(\"{}+{}i\", self.re.to_str(), self.im.to_str())\n         }\n     }\n }\n \n impl<T: ToStrRadix + Num + Ord> ToStrRadix for Cmplx<T> {\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         if self.im < Zero::zero() {\n-            fmt!(\"%s-%si\", self.re.to_str_radix(radix), (-self.im).to_str_radix(radix))\n+            format!(\"{}-{}i\", self.re.to_str_radix(radix), (-self.im).to_str_radix(radix))\n         } else {\n-            fmt!(\"%s+%si\", self.re.to_str_radix(radix), self.im.to_str_radix(radix))\n+            format!(\"{}+{}i\", self.re.to_str_radix(radix), self.im.to_str_radix(radix))\n         }\n     }\n }"}, {"sha": "e7142f6f9ff243c15d4d0e52730083326ad959e4", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -50,7 +50,7 @@ impl<T: Clone + Integer + Ord>\n     #[inline]\n     pub fn new(numer: T, denom: T) -> Ratio<T> {\n         if denom == Zero::zero() {\n-            fail!(\"denominator == 0\");\n+            fail2!(\"denominator == 0\");\n         }\n         let mut ret = Ratio::new_raw(numer, denom);\n         ret.reduce();\n@@ -254,13 +254,13 @@ impl<T: Clone + Integer + Ord> Fractional for Ratio<T> {\n impl<T: ToStr> ToStr for Ratio<T> {\n     /// Renders as `numer/denom`.\n     fn to_str(&self) -> ~str {\n-        fmt!(\"%s/%s\", self.numer.to_str(), self.denom.to_str())\n+        format!(\"{}/{}\", self.numer.to_str(), self.denom.to_str())\n     }\n }\n impl<T: ToStrRadix> ToStrRadix for Ratio<T> {\n     /// Renders as `numer/denom` where the numbers are in base `radix`.\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        fmt!(\"%s/%s\", self.numer.to_str_radix(radix), self.denom.to_str_radix(radix))\n+        format!(\"{}/{}\", self.numer.to_str_radix(radix), self.denom.to_str_radix(radix))\n     }\n }\n "}, {"sha": "5738faeca956b8d61beb99ba64b503cf0fc336d3", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -127,7 +127,7 @@ impl<T> RingBuf<T> {\n     pub fn get<'a>(&'a self, i: uint) -> &'a T {\n         let idx = self.raw_index(i);\n         match self.elts[idx] {\n-            None => fail!(),\n+            None => fail2!(),\n             Some(ref v) => v\n         }\n     }\n@@ -138,7 +138,7 @@ impl<T> RingBuf<T> {\n     pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T {\n         let idx = self.raw_index(i);\n         match self.elts[idx] {\n-            None => fail!(),\n+            None => fail2!(),\n             Some(ref mut v) => v\n         }\n     }\n@@ -373,21 +373,21 @@ mod tests {\n         assert_eq!(d.len(), 3u);\n         d.push_back(137);\n         assert_eq!(d.len(), 4u);\n-        debug!(d.front());\n+        debug2!(\"{:?}\", d.front());\n         assert_eq!(*d.front().unwrap(), 42);\n-        debug!(d.back());\n+        debug2!(\"{:?}\", d.back());\n         assert_eq!(*d.back().unwrap(), 137);\n         let mut i = d.pop_front();\n-        debug!(i);\n+        debug2!(\"{:?}\", i);\n         assert_eq!(i, Some(42));\n         i = d.pop_back();\n-        debug!(i);\n+        debug2!(\"{:?}\", i);\n         assert_eq!(i, Some(137));\n         i = d.pop_back();\n-        debug!(i);\n+        debug2!(\"{:?}\", i);\n         assert_eq!(i, Some(137));\n         i = d.pop_back();\n-        debug!(i);\n+        debug2!(\"{:?}\", i);\n         assert_eq!(i, Some(17));\n         assert_eq!(d.len(), 0u);\n         d.push_back(3);\n@@ -398,10 +398,10 @@ mod tests {\n         assert_eq!(d.len(), 3u);\n         d.push_front(1);\n         assert_eq!(d.len(), 4u);\n-        debug!(d.get(0));\n-        debug!(d.get(1));\n-        debug!(d.get(2));\n-        debug!(d.get(3));\n+        debug2!(\"{:?}\", d.get(0));\n+        debug2!(\"{:?}\", d.get(1));\n+        debug2!(\"{:?}\", d.get(2));\n+        debug2!(\"{:?}\", d.get(3));\n         assert_eq!(*d.get(0), 1);\n         assert_eq!(*d.get(1), 2);\n         assert_eq!(*d.get(2), 3);"}, {"sha": "fff10533af18535d3099e46d48d5fd61c03acfe4", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -86,16 +86,16 @@ pub struct Version {\n impl ToStr for Version {\n     #[inline]\n     fn to_str(&self) -> ~str {\n-        let s = fmt!(\"%u.%u.%u\", self.major, self.minor, self.patch);\n+        let s = format!(\"{}.{}.{}\", self.major, self.minor, self.patch);\n         let s = if self.pre.is_empty() {\n             s\n         } else {\n-            fmt!(\"%s-%s\", s, self.pre.map(|i| i.to_str()).connect(\".\"))\n+            format!(\"{}-{}\", s, self.pre.map(|i| i.to_str()).connect(\".\"))\n         };\n         if self.build.is_empty() {\n             s\n         } else {\n-            fmt!(\"%s+%s\", s, self.build.map(|i| i.to_str()).connect(\".\"))\n+            format!(\"{}+{}\", s, self.build.map(|i| i.to_str()).connect(\".\"))\n         }\n     }\n }\n@@ -158,7 +158,7 @@ fn take_nonempty_prefix(rdr: @io::Reader,\n     if buf.is_empty() {\n         bad_parse::cond.raise(())\n     }\n-    debug!(\"extracted nonempty prefix: %s\", buf);\n+    debug2!(\"extracted nonempty prefix: {}\", buf);\n     (buf, ch)\n }\n \n@@ -234,7 +234,7 @@ pub fn parse(s: &str) -> Option<Version> {\n     }\n     let s = s.trim();\n     let mut bad = false;\n-    do bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).inside {\n+    do bad_parse::cond.trap(|_| { debug2!(\"bad\"); bad = true }).inside {\n         do io::with_str_reader(s) |rdr| {\n             let v = parse_reader(rdr);\n             if bad || v.to_str() != s.to_owned() {"}, {"sha": "2108415f468ffaf5c37c62f8ae41f692f42996dd", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -265,7 +265,7 @@ mod test_map {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-            None => fail!(), Some(x) => *x = new\n+            None => fail2!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }"}, {"sha": "5293a2c3fd7ce3396b9ac00c225dba9996cc532b", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -564,7 +564,7 @@ impl<T:Clone + Ord> MergeState<T> {\n             shift_vec(array, dest, c2, len2);\n             swap(&mut array[dest+len2], &mut tmp[c1]);\n         } else if len1 == 0 {\n-            fail!(\"Comparison violates its contract!\");\n+            fail2!(\"Comparison violates its contract!\");\n         } else {\n             assert_eq!(len2, 0);\n             assert!(len1 > 1);\n@@ -683,7 +683,7 @@ impl<T:Clone + Ord> MergeState<T> {\n             shift_vec(array, dest+1, c1+1, len1);\n             swap(&mut array[dest], &mut tmp[c2]);\n         } else if len2 == 0 {\n-            fail!(\"Comparison violates its contract!\");\n+            fail2!(\"Comparison violates its contract!\");\n         } else {\n             assert_eq!(len1, 0);\n             assert!(len2 != 0);\n@@ -790,7 +790,7 @@ mod test_qsort {\n         quick_sort::<int>(v1, leual);\n         let mut i = 0u;\n         while i < len {\n-            // debug!(v2[i]);\n+            // debug2!(v2[i]);\n             assert_eq!(v2[i], v1[i]);\n             i += 1;\n         }\n@@ -833,7 +833,7 @@ mod test_qsort {\n         let immut_names = names;\n \n         for (&a, &b) in expected.iter().zip(immut_names.iter()) {\n-            debug!(\"%d %d\", a, b);\n+            debug2!(\"{} {}\", a, b);\n             assert_eq!(a, b);\n         }\n     }\n@@ -851,7 +851,7 @@ mod tests {\n         let v3 = merge_sort::<int>(v1, f);\n         let mut i = 0u;\n         while i < len {\n-            debug!(v3[i]);\n+            debug2!(\"{:?}\", v3[i]);\n             assert_eq!(v3[i], v2[i]);\n             i += 1;\n         }\n@@ -922,7 +922,7 @@ mod test_tim_sort {\n         fn lt(&self, other: &CVal) -> bool {\n             let mut rng = rand::rng();\n             if rng.gen::<float>() > 0.995 {\n-                fail!(\"It's happening!!!\");\n+                fail2!(\"It's happening!!!\");\n             }\n             (*self).val < other.val\n         }\n@@ -936,7 +936,7 @@ mod test_tim_sort {\n         tim_sort::<int>(v1);\n         let mut i = 0u;\n         while i < len {\n-            // debug!(v2[i]);\n+            // debug2!(v2[i]);\n             assert_eq!(v2[i], v1[i]);\n             i += 1u;\n         }\n@@ -977,7 +977,7 @@ mod test_tim_sort {\n         };\n \n         tim_sort(arr);\n-        fail!(\"Guarantee the fail\");\n+        fail2!(\"Guarantee the fail\");\n     }\n \n     #[deriving(Clone)]\n@@ -1045,7 +1045,7 @@ mod big_tests {\n         fn isSorted<T:Ord>(arr: &[T]) {\n             for i in range(0u, arr.len() - 1) {\n                 if arr[i] > arr[i+1] {\n-                    fail!(\"Array not sorted\");\n+                    fail2!(\"Array not sorted\");\n                 }\n             }\n         }\n@@ -1116,7 +1116,7 @@ mod big_tests {\n         fn isSorted<T:Ord>(arr: &[@T]) {\n             for i in range(0u, arr.len() - 1) {\n                 if arr[i] > arr[i+1] {\n-                    fail!(\"Array not sorted\");\n+                    fail2!(\"Array not sorted\");\n                 }\n             }\n         }"}, {"sha": "64c4a4a03fd56ecf5d69ac61f00f4033fdfc9e74", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -267,12 +267,12 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n /// Render writes the min, max and quartiles of the provided `Summary` to the provided `Writer`.\n pub fn write_5_number_summary(w: @io::Writer, s: &Summary) {\n     let (q1,q2,q3) = s.quartiles;\n-    w.write_str(fmt!(\"(min=%f, q1=%f, med=%f, q3=%f, max=%f)\",\n-                     s.min as float,\n-                     q1 as float,\n-                     q2 as float,\n-                     q3 as float,\n-                     s.max as float));\n+    w.write_str(format!(\"(min={}, q1={}, med={}, q3={}, max={})\",\n+                     s.min,\n+                     q1,\n+                     q2,\n+                     q3,\n+                     s.max));\n }\n \n /// Render a boxplot to the provided writer. The boxplot shows the min, max and quartiles of the"}, {"sha": "75060166f8c0a302b9108b8a27e2aa25d3ee2220", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -307,9 +307,9 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n                         blk: &fn() -> U) -> U {\n     match out_of_bounds {\n         Some(0) =>\n-            fail!(\"%s with illegal ID %u - this lock has no condvars!\", act, id),\n+            fail2!(\"{} with illegal ID {} - this lock has no condvars!\", act, id),\n         Some(length) =>\n-            fail!(\"%s with illegal ID %u - ID must be less than %u\", act, id, length),\n+            fail2!(\"{} with illegal ID {} - ID must be less than {}\", act, id, length),\n         None => blk()\n     }\n }\n@@ -634,7 +634,7 @@ impl RWLock {\n     pub fn downgrade<'a>(&self, token: RWLockWriteMode<'a>)\n                          -> RWLockReadMode<'a> {\n         if !borrow::ref_eq(self, token.lock) {\n-            fail!(\"Can't downgrade() with a different rwlock's write_mode!\");\n+            fail2!(\"Can't downgrade() with a different rwlock's write_mode!\");\n         }\n         unsafe {\n             do task::unkillable {\n@@ -918,7 +918,7 @@ mod tests {\n \n         let result: result::Result<(),()> = do task::try {\n             do m2.lock {\n-                fail!();\n+                fail2!();\n             }\n         };\n         assert!(result.is_err());\n@@ -938,7 +938,7 @@ mod tests {\n             do task::spawn || { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::deschedule();\n-                fail!();\n+                fail2!();\n             }\n             do m2.lock_cond |cond| {\n                 c.send(()); // tell sibling go ahead\n@@ -976,9 +976,9 @@ mod tests {\n                         do (|| {\n                             cond.wait(); // block forever\n                         }).finally {\n-                            error!(\"task unwinding and sending\");\n+                            error2!(\"task unwinding and sending\");\n                             c.send(());\n-                            error!(\"task unwinding and done sending\");\n+                            error2!(\"task unwinding and done sending\");\n                         }\n                     }\n                 }\n@@ -988,7 +988,7 @@ mod tests {\n             }\n             do m2.lock { }\n             c.send(sibling_convos); // let parent wait on all children\n-            fail!();\n+            fail2!();\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n@@ -1028,7 +1028,7 @@ mod tests {\n             let _ = p.recv();\n             do m.lock_cond |cond| {\n                 if !cond.signal_on(0) {\n-                    fail!(); // success; punt sibling awake.\n+                    fail2!(); // success; punt sibling awake.\n                 }\n             }\n         };\n@@ -1272,7 +1272,7 @@ mod tests {\n \n         let result: result::Result<(),()> = do task::try || {\n             do lock_rwlock_in_mode(&x2, mode1) {\n-                fail!();\n+                fail2!();\n             }\n         };\n         assert!(result.is_err());\n@@ -1319,7 +1319,7 @@ mod tests {\n             let mut xopt = Some(xwrite);\n             do y.write_downgrade |_ywrite| {\n                 y.downgrade(xopt.take_unwrap());\n-                error!(\"oops, y.downgrade(x) should have failed!\");\n+                error2!(\"oops, y.downgrade(x) should have failed!\");\n             }\n         }\n     }"}, {"sha": "c7f2650790243ef4393642f1f7c5fa7293eb4c68", "filename": "src/libextra/term.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -147,7 +147,7 @@ impl Terminal {\n                 self.out.write(s.unwrap());\n                 return true\n             } else {\n-                warn!(\"%s\", s.unwrap_err());\n+                warn2!(\"{}\", s.unwrap_err());\n             }\n         }\n         false\n@@ -167,7 +167,7 @@ impl Terminal {\n                 self.out.write(s.unwrap());\n                 return true\n             } else {\n-                warn!(\"%s\", s.unwrap_err());\n+                warn2!(\"{}\", s.unwrap_err());\n             }\n         }\n         false\n@@ -188,7 +188,7 @@ impl Terminal {\n                         self.out.write(s.unwrap());\n                         return true\n                     } else {\n-                        warn!(\"%s\", s.unwrap_err());\n+                        warn2!(\"{}\", s.unwrap_err());\n                     }\n                 }\n                 false\n@@ -226,11 +226,11 @@ impl Terminal {\n         if s.is_ok() {\n             self.out.write(s.unwrap());\n         } else if self.num_colors > 0 {\n-            warn!(\"%s\", s.unwrap_err());\n+            warn2!(\"{}\", s.unwrap_err());\n         } else {\n-            // if we support attributes but not color, it would be nice to still warn!()\n+            // if we support attributes but not color, it would be nice to still warn2!()\n             // but it's not worth testing all known attributes just for this.\n-            debug!(\"%s\", s.unwrap_err());\n+            debug2!(\"{}\", s.unwrap_err());\n         }\n     }\n "}, {"sha": "81c4b35d8d0d99a2b4e6fd83e93cded10b4a8e84", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -278,7 +278,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     'e' => state = SeekIfEnd(0),\n                     ';' => (),\n \n-                    _ => return Err(fmt!(\"unrecognized format option %c\", cur))\n+                    _ => return Err(format!(\"unrecognized format option {}\", cur))\n                 }\n             },\n             PushParam => {\n@@ -461,7 +461,7 @@ impl FormatOp {\n             'x' => FormatHex,\n             'X' => FormatHEX,\n             's' => FormatString,\n-            _ => fail!(\"bad FormatOp char\")\n+            _ => fail2!(\"bad FormatOp char\")\n         }\n     }\n     fn to_char(self) -> char {\n@@ -551,7 +551,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n                     s\n                 }\n                 _ => {\n-                    return Err(fmt!(\"non-string on stack with %%%c\", op.to_char()))\n+                    return Err(format!(\"non-string on stack with %{}\", op.to_char()))\n                 }\n             }\n         }\n@@ -606,23 +606,23 @@ mod test {\n         for cap in caps.iter() {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n-                    \"Op %s succeeded incorrectly with 0 stack entries\", *cap);\n+                    \"Op {} succeeded incorrectly with 0 stack entries\", *cap);\n             let p = if *cap == \"%s\" || *cap == \"%l\" { String(~\"foo\") } else { Number(97) };\n             let res = expand((bytes!(\"%p1\")).to_owned() + cap.as_bytes(), [p], vars);\n             assert!(res.is_ok(),\n-                    \"Op %s failed with 1 stack entry: %s\", *cap, res.unwrap_err());\n+                    \"Op {} failed with 1 stack entry: {}\", *cap, res.unwrap_err());\n         }\n         let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n         for cap in caps.iter() {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n-                    \"Binop %s succeeded incorrectly with 0 stack entries\", *cap);\n+                    \"Binop {} succeeded incorrectly with 0 stack entries\", *cap);\n             let res = expand((bytes!(\"%{1}\")).to_owned() + cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n-                    \"Binop %s succeeded incorrectly with 1 stack entry\", *cap);\n+                    \"Binop {} succeeded incorrectly with 1 stack entry\", *cap);\n             let res = expand((bytes!(\"%{1}%{2}\")).to_owned() + cap.as_bytes(), [], vars);\n             assert!(res.is_ok(),\n-                    \"Binop %s failed with 2 stack entries: %s\", *cap, res.unwrap_err());\n+                    \"Binop {} failed with 2 stack entries: {}\", *cap, res.unwrap_err());\n         }\n     }\n \n@@ -635,15 +635,15 @@ mod test {\n     fn test_comparison_ops() {\n         let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n         for &(op, bs) in v.iter() {\n-            let s = fmt!(\"%%{1}%%{2}%%%c%%d\", op);\n+            let s = format!(\"%\\\\{1\\\\}%\\\\{2\\\\}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), ~['0' as u8 + bs[0]]);\n-            let s = fmt!(\"%%{1}%%{1}%%%c%%d\", op);\n+            let s = format!(\"%\\\\{1\\\\}%\\\\{1\\\\}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), ~['0' as u8 + bs[1]]);\n-            let s = fmt!(\"%%{2}%%{1}%%%c%%d\", op);\n+            let s = format!(\"%\\\\{2\\\\}%\\\\{1\\\\}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), ~['0' as u8 + bs[2]]);"}, {"sha": "caef3e70ce80ab1528dee96eba5fce2537d64332", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -178,7 +178,8 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n     // Check magic number\n     let magic = file.read_le_u16();\n     if (magic != 0x011A) {\n-        return Err(fmt!(\"invalid magic number: expected %x but found %x\", 0x011A, magic as uint));\n+        return Err(format!(\"invalid magic number: expected {:x} but found {:x}\",\n+                           0x011A, magic as uint));\n     }\n \n     let names_bytes          = file.read_le_i16() as int;\n@@ -189,26 +190,26 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n     assert!(names_bytes          > 0);\n \n-    debug!(\"names_bytes = %?\", names_bytes);\n-    debug!(\"bools_bytes = %?\", bools_bytes);\n-    debug!(\"numbers_count = %?\", numbers_count);\n-    debug!(\"string_offsets_count = %?\", string_offsets_count);\n-    debug!(\"string_table_bytes = %?\", string_table_bytes);\n+    debug2!(\"names_bytes = {}\", names_bytes);\n+    debug2!(\"bools_bytes = {}\", bools_bytes);\n+    debug2!(\"numbers_count = {}\", numbers_count);\n+    debug2!(\"string_offsets_count = {}\", string_offsets_count);\n+    debug2!(\"string_table_bytes = {}\", string_table_bytes);\n \n     if (bools_bytes as uint) > boolnames.len() {\n-        error!(\"expected bools_bytes to be less than %? but found %?\", boolnames.len(),\n+        error2!(\"expected bools_bytes to be less than {} but found {}\", boolnames.len(),\n                bools_bytes);\n         return Err(~\"incompatible file: more booleans than expected\");\n     }\n \n     if (numbers_count as uint) > numnames.len() {\n-        error!(\"expected numbers_count to be less than %? but found %?\", numnames.len(),\n+        error2!(\"expected numbers_count to be less than {} but found {}\", numnames.len(),\n                numbers_count);\n         return Err(~\"incompatible file: more numbers than expected\");\n     }\n \n     if (string_offsets_count as uint) > stringnames.len() {\n-        error!(\"expected string_offsets_count to be less than %? but found %?\", stringnames.len(),\n+        error2!(\"expected string_offsets_count to be less than {} but found {}\", stringnames.len(),\n                string_offsets_count);\n         return Err(~\"incompatible file: more string offsets than expected\");\n     }\n@@ -218,26 +219,26 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n     file.read_byte(); // consume NUL\n \n-    debug!(\"term names: %?\", term_names);\n+    debug2!(\"term names: {:?}\", term_names);\n \n     let mut bools_map = HashMap::new();\n     if bools_bytes != 0 {\n         for i in range(0, bools_bytes) {\n             let b = file.read_byte();\n             if b < 0 {\n-                error!(\"EOF reading bools after %? entries\", i);\n+                error2!(\"EOF reading bools after {} entries\", i);\n                 return Err(~\"error: expected more bools but hit EOF\");\n             } else if b == 1 {\n-                debug!(\"%s set\", bnames[i]);\n+                debug2!(\"{} set\", bnames[i]);\n                 bools_map.insert(bnames[i].to_owned(), true);\n             }\n         }\n     }\n \n-    debug!(\"bools: %?\", bools_map);\n+    debug2!(\"bools: {:?}\", bools_map);\n \n     if (bools_bytes + names_bytes) % 2 == 1 {\n-        debug!(\"adjusting for padding between bools and numbers\");\n+        debug2!(\"adjusting for padding between bools and numbers\");\n         file.read_byte(); // compensate for padding\n     }\n \n@@ -246,13 +247,13 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n         for i in range(0, numbers_count) {\n             let n = file.read_le_u16();\n             if n != 0xFFFF {\n-                debug!(\"%s#%?\", nnames[i], n);\n+                debug2!(\"{}\\\\#{}\", nnames[i], n);\n                 numbers_map.insert(nnames[i].to_owned(), n);\n             }\n         }\n     }\n \n-    debug!(\"numbers: %?\", numbers_map);\n+    debug2!(\"numbers: {:?}\", numbers_map);\n \n     let mut string_map = HashMap::new();\n \n@@ -262,12 +263,12 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n             string_offsets.push(file.read_le_u16());\n         }\n \n-        debug!(\"offsets: %?\", string_offsets);\n+        debug2!(\"offsets: {:?}\", string_offsets);\n \n         let string_table = file.read_bytes(string_table_bytes as uint);\n \n         if string_table.len() != string_table_bytes as uint {\n-            error!(\"EOF reading string table after %? bytes, wanted %?\", string_table.len(),\n+            error2!(\"EOF reading string table after {} bytes, wanted {}\", string_table.len(),\n                    string_table_bytes);\n             return Err(~\"error: hit EOF before end of string table\");\n         }"}, {"sha": "5c7efdb298f271fdadd9ac31fd13e9bab7812965", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -60,7 +60,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n             return Some(newp);\n         }\n         // on some installations the dir is named after the hex of the char (e.g. OS X)\n-        let newp = ~p.push_many(&[fmt!(\"%x\", first_char as uint), term.to_owned()]);\n+        let newp = ~p.push_many(&[format!(\"{:x}\", first_char as uint), term.to_owned()]);\n         if os::path_exists(p) && os::path_exists(newp) {\n             return Some(newp);\n         }\n@@ -72,7 +72,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n pub fn open(term: &str) -> Result<@Reader, ~str> {\n     match get_dbpath_for_term(term) {\n         Some(x) => file_reader(x),\n-        None => Err(fmt!(\"could not find terminfo entry for %s\", term))\n+        None => Err(format!(\"could not find terminfo entry for {}\", term))\n     }\n }\n "}, {"sha": "1370a0690ca179f7fec951e09010534df17d2789", "filename": "src/libextra/test.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -125,10 +125,10 @@ pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n     let opts =\n         match parse_opts(args) {\n             Some(Ok(o)) => o,\n-            Some(Err(msg)) => fail!(msg),\n+            Some(Err(msg)) => fail2!(msg),\n             None => return\n         };\n-    if !run_tests_console(&opts, tests) { fail!(\"Some tests failed\"); }\n+    if !run_tests_console(&opts, tests) { fail2!(\"Some tests failed\"); }\n }\n \n // A variant optimized for invocation with a static test vector.\n@@ -148,7 +148,7 @@ pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n             TestDescAndFn { testfn: StaticBenchFn(f), desc: t.desc.clone() },\n \n             _ => {\n-                fail!(\"non-static tests passed to test::test_main_static\");\n+                fail2!(\"non-static tests passed to test::test_main_static\");\n             }\n         }\n     };\n@@ -192,7 +192,7 @@ fn optgroups() -> ~[getopts::groups::OptGroup] {\n fn usage(binary: &str, helpstr: &str) {\n     #[fixed_stack_segment]; #[inline(never)];\n \n-    let message = fmt!(\"Usage: %s [OPTIONS] [FILTER]\", binary);\n+    let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n     println(groups::usage(message, optgroups()));\n     println(\"\");\n     if helpstr == \"help\" {\n@@ -210,7 +210,7 @@ Test Attributes:\n     #[bench]       - Indicates a function is a benchmark to be run. This\n                      function takes one argument (extra::test::BenchHarness).\n     #[should_fail] - This function (also labeled with #[test]) will only pass if\n-                     the code causes a failure (an assertion failure or fail!)\n+                     the code causes a failure (an assertion failure or fail2!)\n     #[ignore]      - When applied to a function which is already attributed as a\n                      test, then the test runner will ignore these tests during\n                      normal test runs. Running with --ignored will run these\n@@ -327,7 +327,7 @@ impl ConsoleTestState {\n                                                      io::Truncate]) {\n                 result::Ok(w) => Some(w),\n                 result::Err(ref s) => {\n-                    fail!(\"can't open output file: %s\", *s)\n+                    fail2!(\"can't open output file: {}\", *s)\n                 }\n             },\n             None => None\n@@ -408,11 +408,11 @@ impl ConsoleTestState {\n     pub fn write_run_start(&mut self, len: uint) {\n         self.total = len;\n         let noun = if len != 1 { &\"tests\" } else { &\"test\" };\n-        self.out.write_line(fmt!(\"\\nrunning %u %s\", len, noun));\n+        self.out.write_line(format!(\"\\nrunning {} {}\", len, noun));\n     }\n \n     pub fn write_test_start(&self, test: &TestDesc) {\n-        self.out.write_str(fmt!(\"test %s ... \", test.name.to_str()));\n+        self.out.write_str(format!(\"test {} ... \", test.name.to_str()));\n     }\n \n     pub fn write_result(&self, result: &TestResult) {\n@@ -436,7 +436,7 @@ impl ConsoleTestState {\n         match self.log_out {\n             None => (),\n             Some(out) => {\n-                out.write_line(fmt!(\"%s %s\",\n+                out.write_line(format!(\"{} {}\",\n                                     match *result {\n                                         TrOk => ~\"ok\",\n                                         TrFailed => ~\"failed\",\n@@ -456,7 +456,7 @@ impl ConsoleTestState {\n         }\n         sort::tim_sort(failures);\n         for name in failures.iter() {\n-            self.out.write_line(fmt!(\"    %s\", name.to_str()));\n+            self.out.write_line(format!(\"    {}\", name.to_str()));\n         }\n     }\n \n@@ -473,31 +473,31 @@ impl ConsoleTestState {\n                 MetricAdded => {\n                     added += 1;\n                     self.write_added();\n-                    self.out.write_line(fmt!(\": %s\", *k));\n+                    self.out.write_line(format!(\": {}\", *k));\n                 }\n                 MetricRemoved => {\n                     removed += 1;\n                     self.write_removed();\n-                    self.out.write_line(fmt!(\": %s\", *k));\n+                    self.out.write_line(format!(\": {}\", *k));\n                 }\n                 Improvement(pct) => {\n                     improved += 1;\n                     self.out.write_str(*k);\n                     self.out.write_str(\": \");\n                     self.write_improved();\n-                    self.out.write_line(fmt!(\" by %.2f%%\", pct as float))\n+                    self.out.write_line(format!(\" by {:.2f}%\", pct as float))\n                 }\n                 Regression(pct) => {\n                     regressed += 1;\n                     self.out.write_str(*k);\n                     self.out.write_str(\": \");\n                     self.write_regressed();\n-                    self.out.write_line(fmt!(\" by %.2f%%\", pct as float))\n+                    self.out.write_line(format!(\" by {:.2f}%\", pct as float))\n                 }\n             }\n         }\n-        self.out.write_line(fmt!(\"result of ratchet: %u matrics added, %u removed, \\\n-                                  %u improved, %u regressed, %u noise\",\n+        self.out.write_line(format!(\"result of ratchet: {} matrics added, {} removed, \\\n+                                  {} improved, {} regressed, {} noise\",\n                                  added, removed, improved, regressed, noise));\n         if regressed == 0 {\n             self.out.write_line(\"updated ratchet file\")\n@@ -514,11 +514,11 @@ impl ConsoleTestState {\n         let ratchet_success = match *ratchet_metrics {\n             None => true,\n             Some(ref pth) => {\n-                self.out.write_str(fmt!(\"\\nusing metrics ratchet: %s\\n\", pth.to_str()));\n+                self.out.write_str(format!(\"\\nusing metrics ratchet: {}\\n\", pth.to_str()));\n                 match ratchet_pct {\n                     None => (),\n                     Some(pct) =>\n-                    self.out.write_str(fmt!(\"with noise-tolerance forced to: %f%%\\n\",\n+                    self.out.write_str(format!(\"with noise-tolerance forced to: {}%%\\n\",\n                                             pct as float))\n                 }\n                 let (diff, ok) = self.metrics.ratchet(pth, ratchet_pct);\n@@ -541,15 +541,15 @@ impl ConsoleTestState {\n         } else {\n             self.write_failed();\n         }\n-        self.out.write_str(fmt!(\". %u passed; %u failed; %u ignored; %u measured\\n\\n\",\n+        self.out.write_str(format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n                                 self.passed, self.failed, self.ignored, self.measured));\n         return success;\n     }\n }\n \n pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n     let v : ~[~str] = mm.iter()\n-        .map(|(k,v)| fmt!(\"%s: %f (+/- %f)\",\n+        .map(|(k,v)| format!(\"{}: {} (+/- {})\",\n                           *k,\n                           v.value as float,\n                           v.noise as float))\n@@ -559,12 +559,12 @@ pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n \n pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n     if bs.mb_s != 0 {\n-        fmt!(\"%u ns/iter (+/- %u) = %u MB/s\",\n+        format!(\"{} ns/iter (+/- {}) = {} MB/s\",\n              bs.ns_iter_summ.median as uint,\n              (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint,\n              bs.mb_s)\n     } else {\n-        fmt!(\"%u ns/iter (+/- %u)\",\n+        format!(\"{} ns/iter (+/- {})\",\n              bs.ns_iter_summ.median as uint,\n              (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint)\n     }\n@@ -574,7 +574,7 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n pub fn run_tests_console(opts: &TestOpts,\n                          tests: ~[TestDescAndFn]) -> bool {\n     fn callback(event: &TestEvent, st: &mut ConsoleTestState) {\n-        debug!(\"callback(event=%?)\", event);\n+        debug2!(\"callback(event={:?})\", event);\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test) => st.write_test_start(test),\n@@ -612,7 +612,7 @@ pub fn run_tests_console(opts: &TestOpts,\n         None => (),\n         Some(ref pth) => {\n             st.metrics.save(pth);\n-            st.out.write_str(fmt!(\"\\nmetrics saved to: %s\", pth.to_str()));\n+            st.out.write_str(format!(\"\\nmetrics saved to: {}\", pth.to_str()));\n         }\n     }\n     return st.write_run_finish(&opts.ratchet_metrics, opts.ratchet_noise_percent);\n@@ -688,7 +688,7 @@ fn run_tests(opts: &TestOpts,\n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n     let concurrency = get_concurrency();\n-    debug!(\"using %u test tasks\", concurrency);\n+    debug2!(\"using {} test tasks\", concurrency);\n \n     let mut remaining = filtered_tests;\n     remaining.reverse();\n@@ -735,7 +735,7 @@ fn get_concurrency() -> uint {\n             let opt_n: Option<uint> = FromStr::from_str(s);\n             match opt_n {\n                 Some(n) if n > 0 => n,\n-                _ => fail!(\"RUST_TEST_TASKS is `%s`, should be a positive integer.\", s)\n+                _ => fail2!(\"RUST_TEST_TASKS is `{}`, should be a positive integer.\", s)\n             }\n         }\n         None => {\n@@ -1001,7 +1001,7 @@ impl MetricMap {\n         };\n \n         if ok {\n-            debug!(\"rewriting file '%s' with updated metrics\");\n+            debug2!(\"rewriting file '{:?}' with updated metrics\", p);\n             self.save(p);\n         }\n         return (diff, ok)\n@@ -1040,7 +1040,7 @@ impl BenchHarness {\n \n     pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n         self.iterations = n;\n-        debug!(\"running benchmark for %u iterations\",\n+        debug2!(\"running benchmark for {} iterations\",\n                n as uint);\n         f(self);\n     }\n@@ -1081,7 +1081,7 @@ impl BenchHarness {\n             stats::winsorize(samples, 5.0);\n             let summ5 = stats::Summary::new(samples);\n \n-            debug!(\"%u samples, median %f, MAD=%f, MADP=%f\",\n+            debug2!(\"{} samples, median {}, MAD={}, MADP={}\",\n                    samples.len(),\n                    summ.median as float,\n                    summ.median_abs_dev as float,\n@@ -1153,7 +1153,7 @@ mod tests {\n \n     #[test]\n     pub fn do_not_run_ignored_tests() {\n-        fn f() { fail!(); }\n+        fn f() { fail2!(); }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n@@ -1189,7 +1189,7 @@ mod tests {\n \n     #[test]\n     fn test_should_fail() {\n-        fn f() { fail!(); }\n+        fn f() { fail2!(); }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n@@ -1228,7 +1228,7 @@ mod tests {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = match parse_opts(args) {\n             Some(Ok(o)) => o,\n-            _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n+            _ => fail2!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n         assert!(\"filter\" == opts.filter.clone().unwrap());\n     }\n@@ -1238,7 +1238,7 @@ mod tests {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = match parse_opts(args) {\n             Some(Ok(o)) => o,\n-            _ => fail!(\"Malformed arg in parse_ignored_flag\")\n+            _ => fail2!(\"Malformed arg in parse_ignored_flag\")\n         };\n         assert!((opts.run_ignored));\n     }"}, {"sha": "7f08fcd908aea958bcd16d8f40631117d6502970", "filename": "src/libextra/time.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -259,7 +259,7 @@ impl Tm {\n             let mut m = num::abs(self.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n-            s + fmt!(\"%c%02d:%02d\", sign, h as int, m as int)\n+            s + format!(\"{}{:02d}:{:02d}\", sign, h as int, m as int)\n         }\n     }\n }\n@@ -364,7 +364,7 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         if c == range.ch {\n             Ok(range.next)\n         } else {\n-            Err(fmt!(\"Expected %?, found %?\",\n+            Err(format!(\"Expected {}, found {}\",\n                 str::from_char(c),\n                 str::from_char(range.ch)))\n         }\n@@ -671,7 +671,7 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           }\n           '%' => parse_char(s, pos, '%'),\n           ch => {\n-            Err(fmt!(\"unknown formatting type: %?\", str::from_char(ch)))\n+            Err(format!(\"unknown formatting type: {}\", str::from_char(ch)))\n           }\n         }\n     }\n@@ -736,7 +736,7 @@ fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n fn do_strftime(format: &str, tm: &Tm) -> ~str {\n     fn parse_type(ch: char, tm: &Tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n-      let die = || fmt!(\"strftime: can't understand this format %c \", ch);\n+      let die = || format!(\"strftime: can't understand this format {} \", ch);\n         match ch {\n           'A' => match tm.tm_wday as int {\n             0 => ~\"Sunday\",\n@@ -788,68 +788,68 @@ fn do_strftime(format: &str, tm: &Tm) -> ~str {\n             11 => ~\"Dec\",\n             _  => die()\n           },\n-          'C' => fmt!(\"%02d\", (tm.tm_year as int + 1900) / 100),\n+          'C' => format!(\"{:02d}\", (tm.tm_year as int + 1900) / 100),\n           'c' => {\n-            fmt!(\"%s %s %s %s %s\",\n+            format!(\"{} {} {} {} {}\",\n                 parse_type('a', tm),\n                 parse_type('b', tm),\n                 parse_type('e', tm),\n                 parse_type('T', tm),\n                 parse_type('Y', tm))\n           }\n           'D' | 'x' => {\n-            fmt!(\"%s/%s/%s\",\n+            format!(\"{}/{}/{}\",\n                 parse_type('m', tm),\n                 parse_type('d', tm),\n                 parse_type('y', tm))\n           }\n-          'd' => fmt!(\"%02d\", tm.tm_mday as int),\n-          'e' => fmt!(\"%2d\", tm.tm_mday as int),\n-          'f' => fmt!(\"%09d\", tm.tm_nsec as int),\n+          'd' => format!(\"{:02d}\", tm.tm_mday),\n+          'e' => format!(\"{:2d}\", tm.tm_mday),\n+          'f' => format!(\"{:09d}\", tm.tm_nsec),\n           'F' => {\n-            fmt!(\"%s-%s-%s\",\n+            format!(\"{}-{}-{}\",\n                 parse_type('Y', tm),\n                 parse_type('m', tm),\n                 parse_type('d', tm))\n           }\n           //'G' {}\n           //'g' {}\n-          'H' => fmt!(\"%02d\", tm.tm_hour as int),\n+          'H' => format!(\"{:02d}\", tm.tm_hour),\n           'I' => {\n-            let mut h = tm.tm_hour as int;\n+            let mut h = tm.tm_hour;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n-            fmt!(\"%02d\", h)\n+            format!(\"{:02d}\", h)\n           }\n-          'j' => fmt!(\"%03d\", tm.tm_yday as int + 1),\n-          'k' => fmt!(\"%2d\", tm.tm_hour as int),\n+          'j' => format!(\"{:03d}\", tm.tm_yday + 1),\n+          'k' => format!(\"{:2d}\", tm.tm_hour),\n           'l' => {\n-            let mut h = tm.tm_hour as int;\n+            let mut h = tm.tm_hour;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n-            fmt!(\"%2d\", h)\n+            format!(\"{:2d}\", h)\n           }\n-          'M' => fmt!(\"%02d\", tm.tm_min as int),\n-          'm' => fmt!(\"%02d\", tm.tm_mon as int + 1),\n+          'M' => format!(\"{:02d}\", tm.tm_min),\n+          'm' => format!(\"{:02d}\", tm.tm_mon + 1),\n           'n' => ~\"\\n\",\n           'P' => if (tm.tm_hour as int) < 12 { ~\"am\" } else { ~\"pm\" },\n           'p' => if (tm.tm_hour as int) < 12 { ~\"AM\" } else { ~\"PM\" },\n           'R' => {\n-            fmt!(\"%s:%s\",\n+            format!(\"{}:{}\",\n                 parse_type('H', tm),\n                 parse_type('M', tm))\n           }\n           'r' => {\n-            fmt!(\"%s:%s:%s %s\",\n+            format!(\"{}:{}:{} {}\",\n                 parse_type('I', tm),\n                 parse_type('M', tm),\n                 parse_type('S', tm),\n                 parse_type('p', tm))\n           }\n-          'S' => fmt!(\"%02d\", tm.tm_sec as int),\n-          's' => fmt!(\"%d\", tm.to_timespec().sec as int),\n+          'S' => format!(\"{:02d}\", tm.tm_sec),\n+          's' => format!(\"{}\", tm.to_timespec().sec),\n           'T' | 'X' => {\n-            fmt!(\"%s:%s:%s\",\n+            format!(\"{}:{}:{}\",\n                 parse_type('H', tm),\n                 parse_type('M', tm),\n                 parse_type('S', tm))\n@@ -862,7 +862,7 @@ fn do_strftime(format: &str, tm: &Tm) -> ~str {\n           }\n           //'V' {}\n           'v' => {\n-            fmt!(\"%s-%s-%s\",\n+            format!(\"{}-{}-{}\",\n                 parse_type('e', tm),\n                 parse_type('b', tm),\n                 parse_type('Y', tm))\n@@ -872,14 +872,14 @@ fn do_strftime(format: &str, tm: &Tm) -> ~str {\n           //'X' {}\n           //'x' {}\n           'Y' => (tm.tm_year as int + 1900).to_str(),\n-          'y' => fmt!(\"%02d\", (tm.tm_year as int + 1900) % 100),\n+          'y' => format!(\"{:02d}\", (tm.tm_year as int + 1900) % 100),\n           'Z' => tm.tm_zone.clone(),\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = num::abs(tm.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n-            fmt!(\"%c%02d%02d\", sign, h as int, m as int)\n+            format!(\"{}{:02d}{:02d}\", sign, h, m)\n           }\n           //'+' {}\n           '%' => ~\"%\",\n@@ -914,13 +914,13 @@ mod tests {\n         static SOME_FUTURE_DATE: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n \n         let tv1 = get_time();\n-        debug!(\"tv1=%? sec + %? nsec\", tv1.sec as uint, tv1.nsec as uint);\n+        debug2!(\"tv1={:?} sec + {:?} nsec\", tv1.sec as uint, tv1.nsec as uint);\n \n         assert!(tv1.sec > SOME_RECENT_DATE);\n         assert!(tv1.nsec < 1000000000i32);\n \n         let tv2 = get_time();\n-        debug!(\"tv2=%? sec + %? nsec\", tv2.sec as uint, tv2.nsec as uint);\n+        debug2!(\"tv2={:?} sec + {:?} nsec\", tv2.sec as uint, tv2.nsec as uint);\n \n         assert!(tv2.sec >= tv1.sec);\n         assert!(tv2.sec < SOME_FUTURE_DATE);\n@@ -934,16 +934,16 @@ mod tests {\n         let s0 = precise_time_s();\n         let ns1 = precise_time_ns();\n \n-        debug!(\"s0=%s sec\", float::to_str_digits(s0, 9u));\n+        debug2!(\"s0={} sec\", float::to_str_digits(s0, 9u));\n         assert!(s0 > 0.);\n         let ns0 = (s0 * 1000000000.) as u64;\n-        debug!(\"ns0=%? ns\", ns0);\n+        debug2!(\"ns0={:?} ns\", ns0);\n \n-        debug!(\"ns1=%? ns\", ns0);\n+        debug2!(\"ns1={:?} ns\", ns0);\n         assert!(ns1 >= ns0);\n \n         let ns2 = precise_time_ns();\n-        debug!(\"ns2=%? ns\", ns0);\n+        debug2!(\"ns2={:?} ns\", ns0);\n         assert!(ns2 >= ns1);\n     }\n \n@@ -975,7 +975,7 @@ mod tests {\n         let time = Timespec::new(1234567890, 54321);\n         let local = at(time);\n \n-        error!(\"time_at: %?\", local);\n+        error2!(\"time_at: {:?}\", local);\n \n         assert!(local.tm_sec == 30_i32);\n         assert!(local.tm_min == 31_i32);\n@@ -1050,7 +1050,7 @@ mod tests {\n             == Err(~\"Invalid time\"));\n \n         match strptime(\"Fri Feb 13 15:31:30.01234 2009\", format) {\n-          Err(e) => fail!(e),\n+          Err(e) => fail2!(e),\n           Ok(ref tm) => {\n             assert!(tm.tm_sec == 30_i32);\n             assert!(tm.tm_min == 31_i32);\n@@ -1070,7 +1070,7 @@ mod tests {\n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n               Ok(ref tm) => tm.strftime(format) == s.to_owned(),\n-              Err(e) => fail!(e)\n+              Err(e) => fail2!(e)\n             }\n         }\n \n@@ -1196,7 +1196,7 @@ mod tests {\n         let utc   = at_utc(time);\n         let local = at(time);\n \n-        error!(\"test_ctime: %? %?\", utc.ctime(), local.ctime());\n+        error2!(\"test_ctime: {:?} {:?}\", utc.ctime(), local.ctime());\n \n         assert_eq!(utc.ctime(), ~\"Fri Feb 13 23:31:30 2009\");\n         assert_eq!(local.ctime(), ~\"Fri Feb 13 15:31:30 2009\");"}, {"sha": "ee7ba4a888b86a977b6462c4983a178c2cffdafc", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -831,7 +831,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n       }\n     }\n     return match node.take() {\n-        Some(~TreeNode{value, _}) => Some(value), None => fail!()\n+        Some(~TreeNode{value, _}) => Some(value), None => fail2!()\n     };\n }\n \n@@ -900,7 +900,7 @@ mod test_treemap {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-          None => fail!(), Some(x) => *x = new\n+          None => fail2!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }"}, {"sha": "7a10c0439daf4975dec8402d7413a6b256b1485d", "filename": "src/libextra/url.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -93,10 +93,10 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n                         out.push_char(ch);\n                       }\n \n-                      _ => out.push_str(fmt!(\"%%%X\", ch as uint))\n+                      _ => out.push_str(format!(\"%{:X}\", ch as uint))\n                     }\n                 } else {\n-                    out.push_str(fmt!(\"%%%X\", ch as uint));\n+                    out.push_str(format!(\"%{:X}\", ch as uint));\n                 }\n               }\n             }\n@@ -192,7 +192,7 @@ fn encode_plus(s: &str) -> ~str {\n                 out.push_char(ch);\n               }\n               ' ' => out.push_char('+'),\n-              _ => out.push_str(fmt!(\"%%%X\", ch as uint))\n+              _ => out.push_str(format!(\"%{:X}\", ch as uint))\n             }\n         }\n \n@@ -218,7 +218,7 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n                 first = false;\n             }\n \n-            out.push_str(fmt!(\"%s=%s\", key, encode_plus(*value)));\n+            out.push_str(format!(\"{}={}\", key, encode_plus(*value)));\n         }\n     }\n \n@@ -324,8 +324,8 @@ fn userinfo_from_str(uinfo: &str) -> UserInfo {\n \n fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n     match userinfo.pass {\n-        Some(ref pass) => fmt!(\"%s:%s@\", userinfo.user, *pass),\n-        None => fmt!(\"%s@\", userinfo.user),\n+        Some(ref pass) => format!(\"{}:{}@\", userinfo.user, *pass),\n+        None => format!(\"{}@\", userinfo.user),\n     }\n }\n \n@@ -345,7 +345,7 @@ pub fn query_to_str(query: &Query) -> ~str {\n     for kv in query.iter() {\n         match kv {\n             &(ref k, ref v) => {\n-                strvec.push(fmt!(\"%s=%s\",\n+                strvec.push(format!(\"{}={}\",\n                     encode_component(*k),\n                     encode_component(*v))\n                 );\n@@ -673,21 +673,21 @@ pub fn to_str(url: &Url) -> ~str {\n     let authority = if url.host.is_empty() {\n         ~\"\"\n     } else {\n-        fmt!(\"//%s%s\", user, url.host)\n+        format!(\"//{}{}\", user, url.host)\n     };\n \n     let query = if url.query.is_empty() {\n         ~\"\"\n     } else {\n-        fmt!(\"?%s\", query_to_str(&url.query))\n+        format!(\"?{}\", query_to_str(&url.query))\n     };\n \n     let fragment = match url.fragment {\n-        Some(ref fragment) => fmt!(\"#%s\", encode_component(*fragment)),\n+        Some(ref fragment) => format!(\"\\\\#{}\", encode_component(*fragment)),\n         None => ~\"\",\n     };\n \n-    fmt!(\"%s:%s%s%s%s\", url.scheme, authority, url.path, query, fragment)\n+    format!(\"{}:{}{}{}{}\", url.scheme, authority, url.path, query, fragment)\n }\n \n impl ToStr for Url {"}, {"sha": "6da97d8628a8779805627861b096cd06e0831074", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -129,17 +129,17 @@ impl ToStr for ParseError {\n     fn to_str(&self) -> ~str {\n         match *self {\n             ErrorInvalidLength(found) =>\n-                fmt!(\"Invalid length; expecting 32, 36 or 45 chars, found %u\",\n-                    found),\n+                format!(\"Invalid length; expecting 32, 36 or 45 chars, found {}\",\n+                        found),\n             ErrorInvalidCharacter(found, pos) =>\n-                fmt!(\"Invalid character; found `%c` (0x%02x) at offset %u\",\n-                    found, found as uint, pos),\n+                format!(\"Invalid character; found `{}` (0x{:02x}) at offset {}\",\n+                        found, found as uint, pos),\n             ErrorInvalidGroups(found) =>\n-                fmt!(\"Malformed; wrong number of groups: expected 1 or 5, found %u\",\n-                    found),\n+                format!(\"Malformed; wrong number of groups: expected 1 or 5, found {}\",\n+                        found),\n             ErrorInvalidGroupLength(group, found, expecting) =>\n-                fmt!(\"Malformed; length of group %u was %u, expecting %u\",\n-                    group, found, expecting),\n+                format!(\"Malformed; length of group {} was {}, expecting {}\",\n+                        group, found, expecting),\n         }\n     }\n }\n@@ -303,7 +303,7 @@ impl Uuid {\n     pub fn to_simple_str(&self) -> ~str {\n         let mut s: ~[u8] = vec::from_elem(32, 0u8);\n         for i in range(0u, 16u) {\n-            let digit = fmt!(\"%02x\", self.bytes[i] as uint);\n+            let digit = format!(\"{:02x}\", self.bytes[i] as uint);\n             s[i*2+0] = digit[0];\n             s[i*2+1] = digit[1];\n         }\n@@ -324,12 +324,13 @@ impl Uuid {\n         uf.data1 = to_be32(uf.data1 as i32) as u32;\n         uf.data2 = to_be16(uf.data2 as i16) as u16;\n         uf.data3 = to_be16(uf.data3 as i16) as u16;\n-        let s = fmt!(\"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n-            uf.data1 as uint,\n-            uf.data2 as uint, uf.data3 as uint,\n-            uf.data4[0] as uint, uf.data4[1] as uint,\n-            uf.data4[2] as uint, uf.data4[3] as uint, uf.data4[4] as uint,\n-            uf.data4[5] as uint, uf.data4[6] as uint, uf.data4[7] as uint);\n+        let s = format!(\"{:08x}-{:04x}-{:04x}-{:02x}{:02x}-\\\n+                         {:02x}{:02x}{:02x}{:02x}{:02x}{:02x}\",\n+            uf.data1,\n+            uf.data2, uf.data3,\n+            uf.data4[0], uf.data4[1],\n+            uf.data4[2], uf.data4[3], uf.data4[4],\n+            uf.data4[5], uf.data4[6], uf.data4[7]);\n         s\n     }\n "}, {"sha": "32a2d83d814e1869115ddb08ef4f21ea1fdc9444", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e709bfd0dac1d5bbe5c97494980731b4d477e8f/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=7e709bfd0dac1d5bbe5c97494980731b4d477e8f", "patch": "@@ -183,11 +183,11 @@ impl Database {\n         assert!(os::path_exists(&self.db_filename));\n         let f = io::file_reader(&self.db_filename);\n         match f {\n-            Err(e) => fail!(\"Couldn't load workcache database %s: %s\",\n+            Err(e) => fail2!(\"Couldn't load workcache database {}: {}\",\n                             self.db_filename.to_str(), e.to_str()),\n             Ok(r) =>\n                 match json::from_reader(r) {\n-                    Err(e) => fail!(\"Couldn't parse workcache database (from file %s): %s\",\n+                    Err(e) => fail2!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.to_str(), e.to_str()),\n                     Ok(r) => {\n                         let mut decoder = json::Decoder(r);\n@@ -264,7 +264,7 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n \n // FIXME(#5121)\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n-    debug!(\"json decoding: %s\", s);\n+    debug2!(\"json decoding: {}\", s);\n     do io::with_str_reader(s) |rdr| {\n         let j = json::from_reader(rdr).unwrap();\n         let mut decoder = json::Decoder(j);\n@@ -321,15 +321,15 @@ impl Exec {\n                           dependency_kind: &str,\n                           dependency_name: &str,\n                           dependency_val: &str) {\n-        debug!(\"Discovering input %s %s %s\", dependency_kind, dependency_name, dependency_val);\n+        debug2!(\"Discovering input {} {} {}\", dependency_kind, dependency_name, dependency_val);\n         self.discovered_inputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n                                  dependency_val.to_owned());\n     }\n     pub fn discover_output(&mut self,\n                            dependency_kind: &str,\n                            dependency_name: &str,\n                            dependency_val: &str) {\n-        debug!(\"Discovering output %s %s %s\", dependency_kind, dependency_name, dependency_val);\n+        debug2!(\"Discovering output {} {} {}\", dependency_kind, dependency_name, dependency_val);\n         self.discovered_outputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n                                  dependency_val.to_owned());\n     }\n@@ -368,7 +368,7 @@ impl<'self> Prep<'self> {\n \n impl<'self> Prep<'self> {\n     pub fn declare_input(&mut self, kind: &str, name: &str, val: &str) {\n-        debug!(\"Declaring input %s %s %s\", kind, name, val);\n+        debug2!(\"Declaring input {} {} {}\", kind, name, val);\n         self.declared_inputs.insert_work_key(WorkKey::new(kind, name),\n                                  val.to_owned());\n     }\n@@ -377,17 +377,17 @@ impl<'self> Prep<'self> {\n                 name: &str, val: &str) -> bool {\n         let k = kind.to_owned();\n         let f = self.ctxt.freshness.get().find(&k);\n-        debug!(\"freshness for: %s/%s/%s/%s\", cat, kind, name, val)\n+        debug2!(\"freshness for: {}/{}/{}/{}\", cat, kind, name, val)\n         let fresh = match f {\n-            None => fail!(\"missing freshness-function for '%s'\", kind),\n+            None => fail2!(\"missing freshness-function for '{}'\", kind),\n             Some(f) => (*f)(name, val)\n         };\n         do self.ctxt.logger.write |lg| {\n             if fresh {\n-                lg.info(fmt!(\"%s %s:%s is fresh\",\n+                lg.info(format!(\"{} {}:{} is fresh\",\n                              cat, kind, name));\n             } else {\n-                lg.info(fmt!(\"%s %s:%s is not fresh\",\n+                lg.info(format!(\"{} {}:{} is not fresh\",\n                              cat, kind, name))\n             }\n         };\n@@ -418,7 +418,7 @@ impl<'self> Prep<'self> {\n             &'self self, blk: ~fn(&mut Exec) -> T) -> Work<'self, T> {\n         let mut bo = Some(blk);\n \n-        debug!(\"exec_work: looking up %s and %?\", self.fn_name,\n+        debug2!(\"exec_work: looking up {} and {:?}\", self.fn_name,\n                self.declared_inputs);\n         let cached = do self.ctxt.db.read |db| {\n             db.prepare(self.fn_name, &self.declared_inputs)\n@@ -429,14 +429,14 @@ impl<'self> Prep<'self> {\n             if self.all_fresh(\"declared input\",&self.declared_inputs) &&\n                self.all_fresh(\"discovered input\", disc_in) &&\n                self.all_fresh(\"discovered output\", disc_out) => {\n-                debug!(\"Cache hit!\");\n-                debug!(\"Trying to decode: %? / %? / %?\",\n+                debug2!(\"Cache hit!\");\n+                debug2!(\"Trying to decode: {:?} / {:?} / {}\",\n                        disc_in, disc_out, *res);\n                 Work::from_value(json_decode(*res))\n             }\n \n             _ => {\n-                debug!(\"Cache miss!\");\n+                debug2!(\"Cache miss!\");\n                 let (port, chan) = oneshot();\n                 let blk = bo.take_unwrap();\n                 let chan = Cell::new(chan);"}]}