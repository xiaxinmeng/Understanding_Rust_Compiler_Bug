{"sha": "e86cdaf23ded0d25582a33fea761963cf0eb4f41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NmNkYWYyM2RlZDBkMjU1ODJhMzNmZWE3NjE5NjNjZjBlYjRmNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-19T12:26:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-19T12:26:34Z"}, "message": "auto merge of #11061 : huonw/rust/opt-unsafe-vec, r=alexcrichton\n\nBefore:\r\n\r\n```\r\ntest vec::bench::random_inserts                     ... bench:     15025 ns/iter (+/- 409)\r\ntest vec::bench::random_removes                     ... bench:     16063 ns/iter (+/- 276)\r\n```\r\n\r\nAfter:\r\n\r\n```\r\ntest vec::bench::random_inserts                     ... bench:      5257 ns/iter (+/- 321)\r\ntest vec::bench::random_removes                     ... bench:      4980 ns/iter (+/- 94)\r\n```", "tree": {"sha": "188c070d93105e8f5d1858f17300c356d89e6413", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/188c070d93105e8f5d1858f17300c356d89e6413"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e86cdaf23ded0d25582a33fea761963cf0eb4f41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e86cdaf23ded0d25582a33fea761963cf0eb4f41", "html_url": "https://github.com/rust-lang/rust/commit/e86cdaf23ded0d25582a33fea761963cf0eb4f41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e86cdaf23ded0d25582a33fea761963cf0eb4f41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3cee6203457b98c030a8597f97b037a8d447f40", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3cee6203457b98c030a8597f97b037a8d447f40", "html_url": "https://github.com/rust-lang/rust/commit/b3cee6203457b98c030a8597f97b037a8d447f40"}, {"sha": "acd2be46f144e932d207680a7ab1c51b529c20e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/acd2be46f144e932d207680a7ab1c51b529c20e3", "html_url": "https://github.com/rust-lang/rust/commit/acd2be46f144e932d207680a7ab1c51b529c20e3"}], "stats": {"total": 153, "additions": 105, "deletions": 48}, "files": [{"sha": "86297cd468f737cac762e6c01bc3f22c35437350", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 105, "deletions": 48, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e86cdaf23ded0d25582a33fea761963cf0eb4f41/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e86cdaf23ded0d25582a33fea761963cf0eb4f41/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=e86cdaf23ded0d25582a33fea761963cf0eb4f41", "patch": "@@ -1400,6 +1400,22 @@ pub trait OwnedVector<T> {\n     /// elements after position i one position to the right.\n     fn insert(&mut self, i: uint, x:T);\n \n+    /// Remove and return the element at position `i` within `v`,\n+    /// shifting all elements after position `i` one position to the\n+    /// left. Returns `None` if `i` is out of bounds.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// let mut v = ~[1, 2, 3];\n+    /// assert_eq!(v.remove_opt(1), Some(2));\n+    /// assert_eq!(v, ~[1, 3]);\n+    ///\n+    /// assert_eq!(v.remove_opt(4), None);\n+    /// // v is unchanged:\n+    /// assert_eq!(v, ~[1, 3]);\n+    /// ```\n+    fn remove_opt(&mut self, i: uint) -> Option<T>;\n+\n     /// Remove and return the element at position i within v, shifting\n     /// all elements after position i one position to the left.\n     fn remove(&mut self, i: uint) -> T;\n@@ -1609,66 +1625,59 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     fn shift_opt(&mut self) -> Option<T> {\n-        match self.len() {\n-            0 => None,\n-            1 => self.pop_opt(),\n-            2 => {\n-                let last = self.pop();\n-                let first = self.pop_opt();\n-                self.push(last);\n-                first\n-            }\n-            len => {\n-                unsafe {\n-                    let next_len = len - 1;\n-\n-                    let ptr = self.as_ptr();\n-\n-                    // copy out the head element, for the moment it exists\n-                    // unsafely on the stack and as the first element of the\n-                    // vector.\n-                    let head = ptr::read_ptr(ptr);\n-\n-                    // Memcpy everything to the left one element (leaving the\n-                    // last element unsafely in two consecutive memory\n-                    // locations)\n-                    ptr::copy_memory(self.as_mut_ptr(), ptr.offset(1), next_len);\n-\n-                    // set the new length, which means the second instance of\n-                    // the last element is forgotten.\n-                    self.set_len(next_len);\n-\n-                    Some(head)\n-                }\n-            }\n-        }\n+        self.remove_opt(0)\n     }\n \n     fn unshift(&mut self, x: T) {\n-        let v = util::replace(self, ~[x]);\n-        self.push_all_move(v);\n+        self.insert(0, x)\n     }\n-    fn insert(&mut self, i: uint, x:T) {\n+\n+    fn insert(&mut self, i: uint, x: T) {\n         let len = self.len();\n         assert!(i <= len);\n-\n-        self.push(x);\n-        let mut j = len;\n-        while j > i {\n-            self.swap(j, j - 1);\n-            j -= 1;\n+        // space for the new element\n+        self.reserve_additional(1);\n+\n+        unsafe { // infallible\n+            // The spot to put the new value\n+            let p = self.as_mut_ptr().offset(i as int);\n+            // Shift everything over to make space. (Duplicating the\n+            // `i`th element into two consecutive places.)\n+            ptr::copy_memory(p.offset(1), p, len - i);\n+            // Write it in, overwriting the first copy of the `i`th\n+            // element.\n+            intrinsics::move_val_init(&mut *p, x);\n+            self.set_len(len + 1);\n         }\n     }\n+\n+    #[inline]\n     fn remove(&mut self, i: uint) -> T {\n+        match self.remove_opt(i) {\n+            Some(t) => t,\n+            None => fail!(\"remove: the len is {} but the index is {}\", self.len(), i)\n+        }\n+    }\n+\n+    fn remove_opt(&mut self, i: uint) -> Option<T> {\n         let len = self.len();\n-        assert!(i < len);\n+        if i < len {\n+            unsafe { // infallible\n+                // the place we are taking from.\n+                let ptr = self.as_mut_ptr().offset(i as int);\n+                // copy it out, unsafely having a copy of the value on\n+                // the stack and in the vector at the same time.\n+                let ret = Some(ptr::read_ptr(ptr as *T));\n+\n+                // Shift everything down to fill in that spot.\n+                ptr::copy_memory(ptr, ptr.offset(1), len - i - 1);\n+                self.set_len(len - 1);\n \n-        let mut j = i;\n-        while j < len - 1 {\n-            self.swap(j, j + 1);\n-            j += 1;\n+                ret\n+            }\n+        } else {\n+            None\n         }\n-        self.pop()\n     }\n     fn swap_remove(&mut self, index: uint) -> T {\n         let ln = self.len();\n@@ -3380,6 +3389,29 @@ mod tests {\n         a.insert(4, 5);\n     }\n \n+    #[test]\n+    fn test_remove_opt() {\n+        let mut a = ~[1,2,3,4];\n+\n+        assert_eq!(a.remove_opt(2), Some(3));\n+        assert_eq!(a, ~[1,2,4]);\n+\n+        assert_eq!(a.remove_opt(2), Some(4));\n+        assert_eq!(a, ~[1,2]);\n+\n+        assert_eq!(a.remove_opt(2), None);\n+        assert_eq!(a, ~[1,2]);\n+\n+        assert_eq!(a.remove_opt(0), Some(1));\n+        assert_eq!(a, ~[2]);\n+\n+        assert_eq!(a.remove_opt(0), Some(2));\n+        assert_eq!(a, ~[]);\n+\n+        assert_eq!(a.remove_opt(0), None);\n+        assert_eq!(a.remove_opt(10), None);\n+    }\n+\n     #[test]\n     fn test_remove() {\n         let mut a = ~[1, 2, 3, 4];\n@@ -4092,6 +4124,7 @@ mod bench {\n     use vec::VectorVector;\n     use option::*;\n     use ptr;\n+    use rand::{weak_rng, Rng};\n \n     #[bench]\n     fn iterator(bh: &mut BenchHarness) {\n@@ -4268,4 +4301,28 @@ mod bench {\n             }\n         });\n     }\n+\n+    #[bench]\n+    fn random_inserts(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+                let mut v = vec::from_elem(30, (0u, 0u));\n+                for _ in range(0, 100) {\n+                    let l = v.len();\n+                    v.insert(rng.gen::<uint>() % (l + 1),\n+                             (1, 1));\n+                }\n+            })\n+    }\n+    #[bench]\n+    fn random_removes(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+                let mut v = vec::from_elem(130, (0u, 0u));\n+                for _ in range(0, 100) {\n+                    let l = v.len();\n+                    v.remove(rng.gen::<uint>() % l);\n+                }\n+            })\n+    }\n }"}]}