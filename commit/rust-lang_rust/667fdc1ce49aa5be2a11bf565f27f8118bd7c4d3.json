{"sha": "667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2N2ZkYzFjZTQ5YWE1YmUyYTExYmY1NjVmMjdmODExOGJkN2M0ZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-04T21:20:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-04T21:20:26Z"}, "message": "Auto merge of #52827 - GuillaumeGomez:generic-impls, r=QuietMisdreavus\n\nrustdoc: clean up generic impls\n\nr? @QuietMisdreavus", "tree": {"sha": "f2a55c16f49a75de4df6be3d5e733b2cbd18adf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2a55c16f49a75de4df6be3d5e733b2cbd18adf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "html_url": "https://github.com/rust-lang/rust/commit/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94c3c340cce53396d23a20b236fa94f1d34b6df7", "url": "https://api.github.com/repos/rust-lang/rust/commits/94c3c340cce53396d23a20b236fa94f1d34b6df7", "html_url": "https://github.com/rust-lang/rust/commit/94c3c340cce53396d23a20b236fa94f1d34b6df7"}, {"sha": "d57f3a61c4721506d7fb33cc949cd640d13c939a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d57f3a61c4721506d7fb33cc949cd640d13c939a", "html_url": "https://github.com/rust-lang/rust/commit/d57f3a61c4721506d7fb33cc949cd640d13c939a"}], "stats": {"total": 810, "additions": 481, "deletions": 329}, "files": [{"sha": "507aff0c3c727c5cab548ad824d9ca9c5a7ee6b7", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 23, "deletions": 299, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "patch": "@@ -9,15 +9,11 @@\n // except according to those terms.\n \n use rustc::hir;\n-use rustc::traits::{self, auto_trait as auto};\n-use rustc::ty::{self, ToPredicate, TypeFoldable};\n-use rustc::ty::subst::Subst;\n-use rustc::infer::InferOk;\n-use rustc::middle::cstore::CrateStore;\n+use rustc::traits::auto_trait as auto;\n+use rustc::ty::{self, TypeFoldable};\n use std::fmt::Debug;\n-use syntax_pos::DUMMY_SP;\n \n-use core::DocAccessLevels;\n+use self::def_ctor::{get_def_from_def_id, get_def_from_node_id};\n \n use super::*;\n \n@@ -34,186 +30,16 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n     }\n \n     pub fn get_with_def_id(&self, def_id: DefId) -> Vec<Item> {\n-        let ty = self.cx.tcx.type_of(def_id);\n-\n-        let def_ctor: fn(DefId) -> Def = match ty.sty {\n-            ty::TyAdt(adt, _) => match adt.adt_kind() {\n-                AdtKind::Struct => Def::Struct,\n-                AdtKind::Enum => Def::Enum,\n-                AdtKind::Union => Def::Union,\n-            }\n-            ty::TyInt(_) |\n-            ty::TyUint(_) |\n-            ty::TyFloat(_) |\n-            ty::TyStr |\n-            ty::TyBool |\n-            ty::TyChar => return self.get_auto_trait_impls(def_id, &move |_: DefId| {\n-                match ty.sty {\n-                    ty::TyInt(x) => Def::PrimTy(hir::TyInt(x)),\n-                    ty::TyUint(x) => Def::PrimTy(hir::TyUint(x)),\n-                    ty::TyFloat(x) => Def::PrimTy(hir::TyFloat(x)),\n-                    ty::TyStr => Def::PrimTy(hir::TyStr),\n-                    ty::TyBool => Def::PrimTy(hir::TyBool),\n-                    ty::TyChar => Def::PrimTy(hir::TyChar),\n-                    _ => unreachable!(),\n-                }\n-            }, None),\n-            _ => {\n-                debug!(\"Unexpected type {:?}\", def_id);\n-                return Vec::new()\n-            }\n-        };\n-\n-        self.get_auto_trait_impls(def_id, &def_ctor, None)\n+        get_def_from_def_id(&self.cx, def_id, &|def_ctor| {\n+            self.get_auto_trait_impls(def_id, &def_ctor, None)\n+        })\n     }\n \n     pub fn get_with_node_id(&self, id: ast::NodeId, name: String) -> Vec<Item> {\n-        let item = &self.cx.tcx.hir.expect_item(id).node;\n-        let did = self.cx.tcx.hir.local_def_id(id);\n-\n-        let def_ctor = match *item {\n-            hir::ItemKind::Struct(_, _) => Def::Struct,\n-            hir::ItemKind::Union(_, _) => Def::Union,\n-            hir::ItemKind::Enum(_, _) => Def::Enum,\n-            _ => panic!(\"Unexpected type {:?} {:?}\", item, id),\n-        };\n-\n-        self.get_auto_trait_impls(did, &def_ctor, Some(name))\n-    }\n-\n-    fn get_real_ty<F>(&self,\n-                      def_id: DefId,\n-                      def_ctor: &F,\n-                      real_name: &Option<Ident>,\n-                      generics: &ty::Generics,\n-    ) -> hir::Ty\n-    where F: Fn(DefId) -> Def {\n-        let path = get_path_for_type(self.cx.tcx, def_id, def_ctor);\n-        let mut segments = path.segments.into_vec();\n-        let last = segments.pop().unwrap();\n-\n-        segments.push(hir::PathSegment::new(\n-            real_name.unwrap_or(last.ident),\n-            self.generics_to_path_params(generics.clone()),\n-            false,\n-        ));\n-\n-        let new_path = hir::Path {\n-            span: path.span,\n-            def: path.def,\n-            segments: HirVec::from_vec(segments),\n-        };\n-\n-        hir::Ty {\n-            id: ast::DUMMY_NODE_ID,\n-            node: hir::TyKind::Path(hir::QPath::Resolved(None, P(new_path))),\n-            span: DUMMY_SP,\n-            hir_id: hir::DUMMY_HIR_ID,\n-        }\n-    }\n-\n-    pub fn get_blanket_impls<F>(\n-        &self,\n-        def_id: DefId,\n-        def_ctor: &F,\n-        name: Option<String>,\n-        generics: &ty::Generics,\n-    ) -> Vec<Item>\n-    where F: Fn(DefId) -> Def {\n-        let ty = self.cx.tcx.type_of(def_id);\n-        let mut traits = Vec::new();\n-        if self.cx.access_levels.borrow().is_doc_reachable(def_id) {\n-            let real_name = name.clone().map(|name| Ident::from_str(&name));\n-            let param_env = self.cx.tcx.param_env(def_id);\n-            for &trait_def_id in self.cx.all_traits.iter() {\n-                if !self.cx.access_levels.borrow().is_doc_reachable(trait_def_id) ||\n-                   self.cx.generated_synthetics\n-                          .borrow_mut()\n-                          .get(&(def_id, trait_def_id))\n-                          .is_some() {\n-                    continue\n-                }\n-                self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n-                    self.cx.tcx.infer_ctxt().enter(|infcx| {\n-                        let t_generics = infcx.tcx.generics_of(impl_def_id);\n-                        let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id).unwrap();\n-\n-                        match infcx.tcx.type_of(impl_def_id).sty {\n-                            ::rustc::ty::TypeVariants::TyParam(_) => {},\n-                            _ => return,\n-                        }\n-\n-                        let substs = infcx.fresh_substs_for_item(DUMMY_SP, def_id);\n-                        let ty = ty.subst(infcx.tcx, substs);\n-                        let param_env = param_env.subst(infcx.tcx, substs);\n-\n-                        let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-                        let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n-\n-                        // Require the type the impl is implemented on to match\n-                        // our type, and ignore the impl if there was a mismatch.\n-                        let cause = traits::ObligationCause::dummy();\n-                        let eq_result = infcx.at(&cause, param_env)\n-                                             .eq(trait_ref.self_ty(), ty);\n-                        if let Ok(InferOk { value: (), obligations }) = eq_result {\n-                            // FIXME(eddyb) ignoring `obligations` might cause false positives.\n-                            drop(obligations);\n-\n-                            let may_apply = infcx.predicate_may_hold(&traits::Obligation::new(\n-                                cause.clone(),\n-                                param_env,\n-                                trait_ref.to_predicate(),\n-                            ));\n-                            if !may_apply {\n-                                return\n-                            }\n-                            self.cx.generated_synthetics.borrow_mut()\n-                                                        .insert((def_id, trait_def_id));\n-                            let trait_ = hir::TraitRef {\n-                                path: get_path_for_type(infcx.tcx,\n-                                                        trait_def_id,\n-                                                        hir::def::Def::Trait),\n-                                ref_id: ast::DUMMY_NODE_ID,\n-                            };\n-                            let provided_trait_methods =\n-                                infcx.tcx.provided_trait_methods(trait_def_id)\n-                                         .into_iter()\n-                                         .map(|meth| meth.ident.to_string())\n-                                         .collect();\n-\n-                            let ty = self.get_real_ty(def_id, def_ctor, &real_name, generics);\n-                            let predicates = infcx.tcx.predicates_of(impl_def_id);\n-\n-                            traits.push(Item {\n-                                source: infcx.tcx.def_span(impl_def_id).clean(self.cx),\n-                                name: None,\n-                                attrs: Default::default(),\n-                                visibility: None,\n-                                def_id: self.next_def_id(impl_def_id.krate),\n-                                stability: None,\n-                                deprecation: None,\n-                                inner: ImplItem(Impl {\n-                                    unsafety: hir::Unsafety::Normal,\n-                                    generics: (t_generics, &predicates).clean(self.cx),\n-                                    provided_trait_methods,\n-                                    trait_: Some(trait_.clean(self.cx)),\n-                                    for_: ty.clean(self.cx),\n-                                    items: infcx.tcx.associated_items(impl_def_id)\n-                                                    .collect::<Vec<_>>()\n-                                                    .clean(self.cx),\n-                                    polarity: None,\n-                                    synthetic: false,\n-                                    blanket_impl: Some(infcx.tcx.type_of(impl_def_id)\n-                                                                .clean(self.cx)),\n-                                }),\n-                            });\n-                            debug!(\"{:?} => {}\", trait_ref, may_apply);\n-                        }\n-                    });\n-                });\n-            }\n-        }\n-        traits\n+        get_def_from_node_id(&self.cx, id, name, &|def_ctor, name| {\n+            let did = self.cx.tcx.hir.local_def_id(id);\n+            self.get_auto_trait_impls(did, &def_ctor, Some(name))\n+        })\n     }\n \n     pub fn get_auto_trait_impls<F>(\n@@ -263,7 +89,6 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                 def_ctor,\n                 tcx.require_lang_item(lang_items::SyncTraitLangItem),\n             ).into_iter())\n-            .chain(self.get_blanket_impls(def_id, def_ctor, name, &generics).into_iter())\n             .collect();\n \n         debug!(\n@@ -339,14 +164,14 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                 _ => unreachable!(),\n             };\n             let real_name = name.map(|name| Ident::from_str(&name));\n-            let ty = self.get_real_ty(def_id, def_ctor, &real_name, &generics);\n+            let ty = self.cx.get_real_ty(def_id, def_ctor, &real_name, &generics);\n \n             return Some(Item {\n                 source: Span::empty(),\n                 name: None,\n                 attrs: Default::default(),\n                 visibility: None,\n-                def_id: self.next_def_id(def_id.krate),\n+                def_id: self.cx.next_def_id(def_id.krate),\n                 stability: None,\n                 deprecation: None,\n                 inner: ImplItem(Impl {\n@@ -365,56 +190,6 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n         None\n     }\n \n-    fn generics_to_path_params(&self, generics: ty::Generics) -> hir::GenericArgs {\n-        let mut args = vec![];\n-\n-        for param in generics.params.iter() {\n-            match param.kind {\n-                ty::GenericParamDefKind::Lifetime => {\n-                    let name = if param.name == \"\" {\n-                        hir::ParamName::Plain(keywords::StaticLifetime.ident())\n-                    } else {\n-                        hir::ParamName::Plain(ast::Ident::from_interned_str(param.name))\n-                    };\n-\n-                    args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: DUMMY_SP,\n-                        name: hir::LifetimeName::Param(name),\n-                    }));\n-                }\n-                ty::GenericParamDefKind::Type {..} => {\n-                    args.push(hir::GenericArg::Type(self.ty_param_to_ty(param.clone())));\n-                }\n-            }\n-        }\n-\n-        hir::GenericArgs {\n-            args: HirVec::from_vec(args),\n-            bindings: HirVec::new(),\n-            parenthesized: false,\n-        }\n-    }\n-\n-    fn ty_param_to_ty(&self, param: ty::GenericParamDef) -> hir::Ty {\n-        debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n-        hir::Ty {\n-            id: ast::DUMMY_NODE_ID,\n-            node: hir::TyKind::Path(hir::QPath::Resolved(\n-                None,\n-                P(hir::Path {\n-                    span: DUMMY_SP,\n-                    def: Def::TyParam(param.def_id),\n-                    segments: HirVec::from_vec(vec![\n-                        hir::PathSegment::from_ident(Ident::from_interned_str(param.name))\n-                    ]),\n-                }),\n-            )),\n-            span: DUMMY_SP,\n-            hir_id: hir::DUMMY_HIR_ID,\n-        }\n-    }\n-\n     fn find_auto_trait_generics(\n         &self,\n         did: DefId,\n@@ -531,7 +306,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                     // Desired order is 'larger, smaller', so flip then\n                     if self.region_name(r1) != self.region_name(r2) {\n                         finished\n-                            .entry(self.region_name(r2).unwrap())\n+                            .entry(self.region_name(r2).expect(\"no region_name found\"))\n                             .or_insert_with(|| Vec::new())\n                             .push(r1);\n                     }\n@@ -566,7 +341,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                         (&RegionTarget::Region(r1), &RegionTarget::Region(r2)) => {\n                             if self.region_name(r1) != self.region_name(r2) {\n                                 finished\n-                                    .entry(self.region_name(r2).unwrap())\n+                                    .entry(self.region_name(r2).expect(\"no region name found\"))\n                                     .or_insert_with(|| Vec::new())\n                                     .push(r1) // Larger, smaller\n                             }\n@@ -663,7 +438,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n             .flat_map(|(ty, mut bounds)| {\n                 if let Some(data) = ty_to_fn.get(&ty) {\n                     let (poly_trait, output) =\n-                        (data.0.as_ref().unwrap().clone(), data.1.as_ref().cloned());\n+                        (data.0.as_ref().expect(\"as_ref failed\").clone(), data.1.as_ref().cloned());\n                     let new_ty = match &poly_trait.trait_ {\n                         &Type::ResolvedPath {\n                             ref path,\n@@ -672,7 +447,8 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                             ref is_generic,\n                         } => {\n                             let mut new_path = path.clone();\n-                            let last_segment = new_path.segments.pop().unwrap();\n+                            let last_segment = new_path.segments.pop()\n+                                                                .expect(\"segments were empty\");\n \n                             let (old_input, old_output) = match last_segment.args {\n                                 GenericArgs::AngleBracketed { types, .. } => (types, None),\n@@ -830,7 +606,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                     let mut for_generics = self.extract_for_generics(tcx, orig_p.clone());\n \n                     assert!(bounds.len() == 1);\n-                    let mut b = bounds.pop().unwrap();\n+                    let mut b = bounds.pop().expect(\"bounds were empty\");\n \n                     if b.is_sized_bound(self.cx) {\n                         has_sized.insert(ty.clone());\n@@ -860,7 +636,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                             _ => false,\n                         };\n \n-                        let poly_trait = b.get_poly_trait().unwrap();\n+                        let poly_trait = b.get_poly_trait().expect(\"Cannot get poly trait\");\n \n                         if is_fn {\n                             ty_to_fn\n@@ -913,7 +689,10 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                                     // FIXME: Remove this scope when NLL lands\n                                     {\n                                         let args =\n-                                            &mut new_trait_path.segments.last_mut().unwrap().args;\n+                                            &mut new_trait_path.segments\n+                                                .last_mut()\n+                                                .expect(\"segments were empty\")\n+                                                .args;\n \n                                         match args {\n                                             // Convert somethiung like '<T as Iterator::Item> = u8'\n@@ -1077,61 +856,6 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n             _ => false,\n         }\n     }\n-\n-    // This is an ugly hack, but it's the simplest way to handle synthetic impls without greatly\n-    // refactoring either librustdoc or librustc. In particular, allowing new DefIds to be\n-    // registered after the AST is constructed would require storing the defid mapping in a\n-    // RefCell, decreasing the performance for normal compilation for very little gain.\n-    //\n-    // Instead, we construct 'fake' def ids, which start immediately after the last DefId in\n-    // DefIndexAddressSpace::Low. In the Debug impl for clean::Item, we explicitly check for fake\n-    // def ids, as we'll end up with a panic if we use the DefId Debug impl for fake DefIds\n-    fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n-        let start_def_id = {\n-            let next_id = if crate_num == LOCAL_CRATE {\n-                self.cx\n-                    .tcx\n-                    .hir\n-                    .definitions()\n-                    .def_path_table()\n-                    .next_id(DefIndexAddressSpace::Low)\n-            } else {\n-                self.cx\n-                    .cstore\n-                    .def_path_table(crate_num)\n-                    .next_id(DefIndexAddressSpace::Low)\n-            };\n-\n-            DefId {\n-                krate: crate_num,\n-                index: next_id,\n-            }\n-        };\n-\n-        let mut fake_ids = self.cx.fake_def_ids.borrow_mut();\n-\n-        let def_id = fake_ids.entry(crate_num).or_insert(start_def_id).clone();\n-        fake_ids.insert(\n-            crate_num,\n-            DefId {\n-                krate: crate_num,\n-                index: DefIndex::from_array_index(\n-                    def_id.index.as_array_index() + 1,\n-                    def_id.index.address_space(),\n-                ),\n-            },\n-        );\n-\n-        MAX_DEF_ID.with(|m| {\n-            m.borrow_mut()\n-                .entry(def_id.krate.clone())\n-                .or_insert(start_def_id);\n-        });\n-\n-        self.cx.all_fake_def_ids.borrow_mut().insert(def_id);\n-\n-        def_id.clone()\n-    }\n }\n \n // Replaces all ReVars in a type with ty::Region's, using the provided map"}, {"sha": "5b352ffb725d0cc03eb3ae1dc731bc2f8cc82861", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "patch": "@@ -0,0 +1,162 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::traits;\n+use rustc::ty::ToPredicate;\n+use rustc::ty::subst::Subst;\n+use rustc::infer::InferOk;\n+use syntax_pos::DUMMY_SP;\n+\n+use core::DocAccessLevels;\n+\n+use super::*;\n+\n+use self::def_ctor::{get_def_from_def_id, get_def_from_node_id};\n+\n+pub struct BlanketImplFinder<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n+    pub cx: &'a core::DocContext<'a, 'tcx, 'rcx, 'cstore>,\n+}\n+\n+impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n+    pub fn new(cx: &'a core::DocContext<'a, 'tcx, 'rcx, 'cstore>) -> Self {\n+        BlanketImplFinder { cx }\n+    }\n+\n+    pub fn get_with_def_id(&self, def_id: DefId) -> Vec<Item> {\n+        get_def_from_def_id(&self.cx, def_id, &|def_ctor| {\n+            self.get_blanket_impls(def_id, &def_ctor, None)\n+        })\n+    }\n+\n+    pub fn get_with_node_id(&self, id: ast::NodeId, name: String) -> Vec<Item> {\n+        get_def_from_node_id(&self.cx, id, name, &|def_ctor, name| {\n+            let did = self.cx.tcx.hir.local_def_id(id);\n+            self.get_blanket_impls(did, &def_ctor, Some(name))\n+        })\n+    }\n+\n+    pub fn get_blanket_impls<F>(\n+        &self,\n+        def_id: DefId,\n+        def_ctor: &F,\n+        name: Option<String>,\n+    ) -> Vec<Item>\n+    where F: Fn(DefId) -> Def {\n+        let mut impls = Vec::new();\n+        if self.cx\n+            .tcx\n+            .get_attrs(def_id)\n+            .lists(\"doc\")\n+            .has_word(\"hidden\")\n+        {\n+            debug!(\n+                \"get_blanket_impls(def_id={:?}, def_ctor=...): item has doc('hidden'), \\\n+                 aborting\",\n+                def_id\n+            );\n+            return impls;\n+        }\n+        let ty = self.cx.tcx.type_of(def_id);\n+        if self.cx.access_levels.borrow().is_doc_reachable(def_id) || ty.is_primitive() {\n+            let generics = self.cx.tcx.generics_of(def_id);\n+            let real_name = name.clone().map(|name| Ident::from_str(&name));\n+            let param_env = self.cx.tcx.param_env(def_id);\n+            for &trait_def_id in self.cx.all_traits.iter() {\n+                if !self.cx.access_levels.borrow().is_doc_reachable(trait_def_id) ||\n+                   self.cx.generated_synthetics\n+                          .borrow_mut()\n+                          .get(&(def_id, trait_def_id))\n+                          .is_some() {\n+                    continue\n+                }\n+                self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n+                    self.cx.tcx.infer_ctxt().enter(|infcx| {\n+                        let t_generics = infcx.tcx.generics_of(impl_def_id);\n+                        let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id)\n+                                                 .expect(\"Cannot get impl trait\");\n+\n+                        match trait_ref.self_ty().sty {\n+                            ty::TypeVariants::TyParam(_) => {},\n+                            _ => return,\n+                        }\n+\n+                        let substs = infcx.fresh_substs_for_item(DUMMY_SP, def_id);\n+                        let ty = ty.subst(infcx.tcx, substs);\n+                        let param_env = param_env.subst(infcx.tcx, substs);\n+\n+                        let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+                        let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n+\n+                        // Require the type the impl is implemented on to match\n+                        // our type, and ignore the impl if there was a mismatch.\n+                        let cause = traits::ObligationCause::dummy();\n+                        let eq_result = infcx.at(&cause, param_env)\n+                                             .eq(trait_ref.self_ty(), ty);\n+                        if let Ok(InferOk { value: (), obligations }) = eq_result {\n+                            // FIXME(eddyb) ignoring `obligations` might cause false positives.\n+                            drop(obligations);\n+\n+                            let may_apply = infcx.predicate_may_hold(&traits::Obligation::new(\n+                                cause.clone(),\n+                                param_env,\n+                                trait_ref.to_predicate(),\n+                            ));\n+                            if !may_apply {\n+                                return\n+                            }\n+                            self.cx.generated_synthetics.borrow_mut()\n+                                                        .insert((def_id, trait_def_id));\n+                            let trait_ = hir::TraitRef {\n+                                path: get_path_for_type(infcx.tcx,\n+                                                        trait_def_id,\n+                                                        hir::def::Def::Trait),\n+                                ref_id: ast::DUMMY_NODE_ID,\n+                            };\n+                            let provided_trait_methods =\n+                                infcx.tcx.provided_trait_methods(trait_def_id)\n+                                         .into_iter()\n+                                         .map(|meth| meth.ident.to_string())\n+                                         .collect();\n+\n+                            let ty = self.cx.get_real_ty(def_id, def_ctor, &real_name, generics);\n+                            let predicates = infcx.tcx.predicates_of(impl_def_id);\n+\n+                            impls.push(Item {\n+                                source: infcx.tcx.def_span(impl_def_id).clean(self.cx),\n+                                name: None,\n+                                attrs: Default::default(),\n+                                visibility: None,\n+                                def_id: self.cx.next_def_id(impl_def_id.krate),\n+                                stability: None,\n+                                deprecation: None,\n+                                inner: ImplItem(Impl {\n+                                    unsafety: hir::Unsafety::Normal,\n+                                    generics: (t_generics, &predicates).clean(self.cx),\n+                                    provided_trait_methods,\n+                                    trait_: Some(trait_.clean(self.cx)),\n+                                    for_: ty.clean(self.cx),\n+                                    items: infcx.tcx.associated_items(impl_def_id)\n+                                                    .collect::<Vec<_>>()\n+                                                    .clean(self.cx),\n+                                    polarity: None,\n+                                    synthetic: false,\n+                                    blanket_impl: Some(infcx.tcx.type_of(impl_def_id)\n+                                                                .clean(self.cx)),\n+                                }),\n+                            });\n+                        }\n+                    });\n+                });\n+            }\n+        }\n+        impls\n+    }\n+}"}, {"sha": "4db211b7f1e70f6bba0aa6299c8fa76ea7a372d5", "filename": "src/librustdoc/clean/def_ctor.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs?ref=667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::DocContext;\n+\n+use super::*;\n+\n+pub fn get_def_from_def_id<F>(cx: &DocContext,\n+                              def_id: DefId,\n+                              callback: &F,\n+) -> Vec<Item>\n+where F: Fn(& dyn Fn(DefId) -> Def) -> Vec<Item> {\n+    let ty = cx.tcx.type_of(def_id);\n+\n+    match ty.sty {\n+        ty::TyAdt(adt, _) => callback(&match adt.adt_kind() {\n+            AdtKind::Struct => Def::Struct,\n+            AdtKind::Enum => Def::Enum,\n+            AdtKind::Union => Def::Union,\n+        }),\n+        ty::TyInt(_) |\n+        ty::TyUint(_) |\n+        ty::TyFloat(_) |\n+        ty::TyStr |\n+        ty::TyBool |\n+        ty::TyChar => callback(&move |_: DefId| {\n+            match ty.sty {\n+                ty::TyInt(x) => Def::PrimTy(hir::TyInt(x)),\n+                ty::TyUint(x) => Def::PrimTy(hir::TyUint(x)),\n+                ty::TyFloat(x) => Def::PrimTy(hir::TyFloat(x)),\n+                ty::TyStr => Def::PrimTy(hir::TyStr),\n+                ty::TyBool => Def::PrimTy(hir::TyBool),\n+                ty::TyChar => Def::PrimTy(hir::TyChar),\n+                _ => unreachable!(),\n+            }\n+        }),\n+        _ => {\n+            debug!(\"Unexpected type {:?}\", def_id);\n+            Vec::new()\n+        }\n+    }\n+}\n+\n+pub fn get_def_from_node_id<F>(cx: &DocContext,\n+                               id: ast::NodeId,\n+                               name: String,\n+                               callback: &F,\n+) -> Vec<Item>\n+where F: Fn(& dyn Fn(DefId) -> Def, String) -> Vec<Item> {\n+    let item = &cx.tcx.hir.expect_item(id).node;\n+\n+    callback(&match *item {\n+        hir::ItemKind::Struct(_, _) => Def::Struct,\n+        hir::ItemKind::Union(_, _) => Def::Union,\n+        hir::ItemKind::Enum(_, _) => Def::Enum,\n+        _ => panic!(\"Unexpected type {:?} {:?}\", item, id),\n+    }, name)\n+}"}, {"sha": "1c66c39b660b246cc5f32fab320488718139d8e5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "patch": "@@ -25,7 +25,13 @@ use rustc::util::nodemap::FxHashSet;\n \n use core::{DocContext, DocAccessLevels};\n use doctree;\n-use clean::{self, GetDefId, ToSource, get_auto_traits_with_def_id};\n+use clean::{\n+    self,\n+    GetDefId,\n+    ToSource,\n+    get_auto_traits_with_def_id,\n+    get_blanket_impls_with_def_id,\n+};\n \n use super::Clean;\n \n@@ -168,7 +174,7 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n         }\n     });\n     let fqn = if let clean::TypeKind::Macro = kind {\n-        vec![crate_name, relative.last().unwrap()]\n+        vec![crate_name, relative.last().expect(\"relative was empty\")]\n     } else {\n         once(crate_name).chain(relative).collect()\n     };\n@@ -274,11 +280,14 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n \n     if auto_traits {\n         let auto_impls = get_auto_traits_with_def_id(cx, did);\n-        let mut renderinfo = cx.renderinfo.borrow_mut();\n-        let new_impls: Vec<clean::Item> = auto_impls.into_iter()\n-            .filter(|i| renderinfo.inlined.insert(i.def_id)).collect();\n+        {\n+            let mut renderinfo = cx.renderinfo.borrow_mut();\n+            let new_impls: Vec<clean::Item> = auto_impls.into_iter()\n+                .filter(|i| renderinfo.inlined.insert(i.def_id)).collect();\n \n-        impls.extend(new_impls);\n+            impls.extend(new_impls);\n+        }\n+        impls.extend(get_blanket_impls_with_def_id(cx, did));\n     }\n \n     // If this is the first time we've inlined something from another crate, then\n@@ -336,10 +345,13 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n             build_impl(cx, def_id, &mut impls);\n \n             let auto_impls = get_auto_traits_with_def_id(cx, def_id);\n+            let blanket_impls = get_blanket_impls_with_def_id(cx, def_id);\n             let mut renderinfo = cx.renderinfo.borrow_mut();\n \n             let new_impls: Vec<clean::Item> = auto_impls.into_iter()\n-                .filter(|i| renderinfo.inlined.insert(i.def_id)).collect();\n+                .chain(blanket_impls.into_iter())\n+                .filter(|i| renderinfo.inlined.insert(i.def_id))\n+                .collect();\n \n             impls.extend(new_impls);\n         }"}, {"sha": "9dbd7d7b2607d45f010cbb1758bf07027a58d9c1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "patch": "@@ -37,8 +37,7 @@ use rustc::middle::lang_items;\n use rustc::mir::interpret::GlobalId;\n use rustc::hir::{self, GenericArg, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n-use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::def_id::DefIndexAddressSpace;\n+use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::map::Node;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n@@ -73,11 +72,15 @@ pub mod inline;\n pub mod cfg;\n mod simplify;\n mod auto_trait;\n+mod blanket_impl;\n+pub mod def_ctor;\n \n use self::cfg::Cfg;\n use self::auto_trait::AutoTraitFinder;\n+use self::blanket_impl::BlanketImplFinder;\n \n-thread_local!(static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = RefCell::new(FxHashMap()));\n+thread_local!(pub static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> =\n+    RefCell::new(FxHashMap()));\n \n const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n@@ -569,7 +572,7 @@ pub struct Module {\n impl Clean<Item> for doctree::Module {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let name = if self.name.is_some() {\n-            self.name.unwrap().clean(cx)\n+            self.name.expect(\"No name provided\").clean(cx)\n         } else {\n             \"\".to_string()\n         };\n@@ -1064,7 +1067,7 @@ fn span_of_attrs(attrs: &Attributes) -> syntax_pos::Span {\n         return DUMMY_SP;\n     }\n     let start = attrs.doc_strings[0].span();\n-    let end = attrs.doc_strings.last().unwrap().span();\n+    let end = attrs.doc_strings.last().expect(\"No doc strings provided\").span();\n     start.to(end)\n }\n \n@@ -1728,7 +1731,7 @@ impl Clean<Lifetime> for hir::GenericParam {\n                         hir::GenericBound::Outlives(lt) => lt,\n                         _ => panic!(),\n                     });\n-                    let name = bounds.next().unwrap().name.ident();\n+                    let name = bounds.next().expect(\"no more bounds\").name.ident();\n                     let mut s = format!(\"{}: {}\", self.name.ident(), name);\n                     for bound in bounds {\n                         s.push_str(&format!(\" + {}\", bound.name.ident()));\n@@ -1841,8 +1844,8 @@ impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Region<'tcx>, ty:\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         WherePredicate::RegionPredicate {\n-            lifetime: a.clean(cx).unwrap(),\n-            bounds: vec![GenericBound::Outlives(b.clean(cx).unwrap())]\n+            lifetime: a.clean(cx).expect(\"failed to clean lifetime\"),\n+            bounds: vec![GenericBound::Outlives(b.clean(cx).expect(\"failed to clean bounds\"))]\n         }\n     }\n }\n@@ -1853,7 +1856,7 @@ impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<\n \n         WherePredicate::BoundPredicate {\n             ty: ty.clean(cx),\n-            bounds: vec![GenericBound::Outlives(lt.clean(cx).unwrap())]\n+            bounds: vec![GenericBound::Outlives(lt.clean(cx).expect(\"failed to clean lifetimes\"))]\n         }\n     }\n }\n@@ -1947,7 +1950,7 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n                         hir::GenericBound::Outlives(lt) => lt,\n                         _ => panic!(),\n                     });\n-                    let name = bounds.next().unwrap().name.ident();\n+                    let name = bounds.next().expect(\"no more bounds\").name.ident();\n                     let mut s = format!(\"{}: {}\", self.name.ident(), name);\n                     for bound in bounds {\n                         s.push_str(&format!(\" + {}\", bound.name.ident()));\n@@ -2933,7 +2936,7 @@ impl Clean<Type> for hir::Ty {\n                 };\n \n                 if let Some(&hir::ItemKind::Ty(ref ty, ref generics)) = alias {\n-                    let provided_params = &path.segments.last().unwrap();\n+                    let provided_params = &path.segments.last().expect(\"segments were empty\");\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n                     provided_params.with_generic_args(|generic_args| {\n@@ -3006,7 +3009,7 @@ impl Clean<Type> for hir::Ty {\n                     segments: segments.into(),\n                 };\n                 Type::QPath {\n-                    name: p.segments.last().unwrap().ident.name.clean(cx),\n+                    name: p.segments.last().expect(\"segments were empty\").ident.name.clean(cx),\n                     self_type: box qself.clean(cx),\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n@@ -3062,7 +3065,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::TyStr => Primitive(PrimitiveType::Str),\n             ty::TySlice(ty) => Slice(box ty.clean(cx)),\n             ty::TyArray(ty, n) => {\n-                let mut n = cx.tcx.lift(&n).unwrap();\n+                let mut n = cx.tcx.lift(&n).expect(\"array lift failed\");\n                 if let ConstValue::Unevaluated(def_id, substs) = n.val {\n                     let param_env = cx.tcx.param_env(def_id);\n                     let cid = GlobalId {\n@@ -3084,7 +3087,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             },\n             ty::TyFnDef(..) |\n             ty::TyFnPtr(_) => {\n-                let ty = cx.tcx.lift(self).unwrap();\n+                let ty = cx.tcx.lift(self).expect(\"TyFnPtr lift failed\");\n                 let sig = ty.fn_sig(cx.tcx);\n                 BareFunction(box BareFunctionDecl {\n                     unsafety: sig.unsafety(),\n@@ -3175,7 +3178,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n                 let predicates_of = cx.tcx.predicates_of(def_id);\n-                let substs = cx.tcx.lift(&substs).unwrap();\n+                let substs = cx.tcx.lift(&substs).expect(\"TyAnon lift failed\");\n                 let bounds = predicates_of.instantiate(cx.tcx, substs);\n                 let mut regions = vec![];\n                 let mut has_sized = false;\n@@ -3314,6 +3317,7 @@ impl Clean<Vec<Item>> for doctree::Struct {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         let name = self.name.clean(cx);\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n+        ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n \n         *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n@@ -3340,6 +3344,7 @@ impl Clean<Vec<Item>> for doctree::Union {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         let name = self.name.clean(cx);\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n+        ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n \n         *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n@@ -3393,6 +3398,7 @@ impl Clean<Vec<Item>> for doctree::Enum {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         let name = self.name.clean(cx);\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n+        ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n \n         *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n@@ -3545,7 +3551,7 @@ pub struct Path {\n \n impl Path {\n     pub fn last_name(&self) -> &str {\n-        self.segments.last().unwrap().name.as_str()\n+        self.segments.last().expect(\"segments were empty\").name.as_str()\n     }\n }\n \n@@ -3875,6 +3881,17 @@ pub fn get_auto_traits_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n     finder.get_with_def_id(id)\n }\n \n+pub fn get_blanket_impls_with_node_id(cx: &DocContext, id: ast::NodeId, name: String) -> Vec<Item> {\n+    let finder = BlanketImplFinder::new(cx);\n+    finder.get_with_node_id(id, name)\n+}\n+\n+pub fn get_blanket_impls_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n+    let finder = BlanketImplFinder::new(cx);\n+\n+    finder.get_with_def_id(id)\n+}\n+\n fn get_name_if_possible(cx: &DocContext, node: NodeId) -> Option<Name> {\n     match cx.tcx.hir.get(node) {\n         Node::NodeItem(_) |\n@@ -4196,7 +4213,7 @@ fn print_const(cx: &DocContext, n: &ty::Const) -> String {\n         },\n         _ => {\n             let mut s = String::new();\n-            ::rustc::mir::fmt_const_val(&mut s, n).unwrap();\n+            ::rustc::mir::fmt_const_val(&mut s, n).expect(\"fmt_const_val failed\");\n             // array lengths are obviously usize\n             if s.ends_with(\"usize\") {\n                 let n = s.len() - \"usize\".len();\n@@ -4257,7 +4274,8 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::TyForeign(i) => (i, TypeKind::Foreign),\n         Def::Const(i) => (i, TypeKind::Const),\n         Def::Static(i, _) => (i, TypeKind::Static),\n-        Def::Variant(i) => (cx.tcx.parent_def_id(i).unwrap(), TypeKind::Enum),\n+        Def::Variant(i) => (cx.tcx.parent_def_id(i).expect(\"cannot get parent def id\"),\n+                            TypeKind::Enum),\n         Def::Macro(i, _) => (i, TypeKind::Macro),\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n         Def::SelfTy(_, Some(impl_def_id)) => {\n@@ -4486,7 +4504,7 @@ pub fn path_to_def(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n     }\n }\n \n-fn get_path_for_type<F>(tcx: TyCtxt, def_id: DefId, def_ctor: F) -> hir::Path\n+pub fn get_path_for_type<F>(tcx: TyCtxt, def_id: DefId, def_ctor: F) -> hir::Path\n where F: Fn(DefId) -> Def {\n     struct AbsolutePathBuffer {\n         names: Vec<String>,"}, {"sha": "9ea8bc536352a2d61d8458f7ec4cca7e042a811d", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "patch": "@@ -96,7 +96,7 @@ pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n             if !trait_is_same_or_supertrait(cx, did, trait_did) {\n                 return false\n             }\n-            let last = path.segments.last_mut().unwrap();\n+            let last = path.segments.last_mut().expect(\"segments were empty\");\n             match last.args {\n                 PP::AngleBracketed { ref mut bindings, .. } => {\n                     bindings.push(clean::TypeBinding {"}, {"sha": "88faea9514f035adc00f1d4156e6d639220cd1b2", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 142, "deletions": 3, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "patch": "@@ -11,8 +11,10 @@\n use rustc_lint;\n use rustc_driver::{self, driver, target_features, abort_on_err};\n use rustc::session::{self, config};\n-use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n+use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CrateNum, LOCAL_CRATE};\n use rustc::hir::def::Def;\n+use rustc::hir::{self, HirVec};\n+use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt, AllArenas};\n use rustc::hir::map as hir_map;\n@@ -24,11 +26,14 @@ use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n use rustc_target::spec::TargetTriple;\n \n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::{self, Ident, Name, NodeId};\n use syntax::codemap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::json::JsonEmitter;\n+use syntax::ptr::P;\n+use syntax::symbol::keywords;\n+use syntax_pos::DUMMY_SP;\n use errors;\n use errors::emitter::{Emitter, EmitterWriter};\n \n@@ -40,7 +45,7 @@ use std::path::PathBuf;\n \n use visit_ast::RustdocVisitor;\n use clean;\n-use clean::Clean;\n+use clean::{get_path_for_type, Clean, MAX_DEF_ID};\n use html::render::RenderInfo;\n \n pub use rustc::session::config::{Input, Options, CodegenOptions};\n@@ -106,6 +111,140 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocContext<'a, 'tcx, 'rcx, 'cstore> {\n         *self.lt_substs.borrow_mut() = old_lts;\n         r\n     }\n+\n+    // This is an ugly hack, but it's the simplest way to handle synthetic impls without greatly\n+    // refactoring either librustdoc or librustc. In particular, allowing new DefIds to be\n+    // registered after the AST is constructed would require storing the defid mapping in a\n+    // RefCell, decreasing the performance for normal compilation for very little gain.\n+    //\n+    // Instead, we construct 'fake' def ids, which start immediately after the last DefId in\n+    // DefIndexAddressSpace::Low. In the Debug impl for clean::Item, we explicitly check for fake\n+    // def ids, as we'll end up with a panic if we use the DefId Debug impl for fake DefIds\n+    pub fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n+        let start_def_id = {\n+            let next_id = if crate_num == LOCAL_CRATE {\n+                self.tcx\n+                    .hir\n+                    .definitions()\n+                    .def_path_table()\n+                    .next_id(DefIndexAddressSpace::Low)\n+            } else {\n+                self.cstore\n+                    .def_path_table(crate_num)\n+                    .next_id(DefIndexAddressSpace::Low)\n+            };\n+\n+            DefId {\n+                krate: crate_num,\n+                index: next_id,\n+            }\n+        };\n+\n+        let mut fake_ids = self.fake_def_ids.borrow_mut();\n+\n+        let def_id = fake_ids.entry(crate_num).or_insert(start_def_id).clone();\n+        fake_ids.insert(\n+            crate_num,\n+            DefId {\n+                krate: crate_num,\n+                index: DefIndex::from_array_index(\n+                    def_id.index.as_array_index() + 1,\n+                    def_id.index.address_space(),\n+                ),\n+            },\n+        );\n+\n+        MAX_DEF_ID.with(|m| {\n+            m.borrow_mut()\n+                .entry(def_id.krate.clone())\n+                .or_insert(start_def_id);\n+        });\n+\n+        self.all_fake_def_ids.borrow_mut().insert(def_id);\n+\n+        def_id.clone()\n+    }\n+\n+    pub fn get_real_ty<F>(&self,\n+                          def_id: DefId,\n+                          def_ctor: &F,\n+                          real_name: &Option<Ident>,\n+                          generics: &ty::Generics,\n+    ) -> hir::Ty\n+    where F: Fn(DefId) -> Def {\n+        let path = get_path_for_type(self.tcx, def_id, def_ctor);\n+        let mut segments = path.segments.into_vec();\n+        let last = segments.pop().expect(\"segments were empty\");\n+\n+        segments.push(hir::PathSegment::new(\n+            real_name.unwrap_or(last.ident),\n+            self.generics_to_path_params(generics.clone()),\n+            false,\n+        ));\n+\n+        let new_path = hir::Path {\n+            span: path.span,\n+            def: path.def,\n+            segments: HirVec::from_vec(segments),\n+        };\n+\n+        hir::Ty {\n+            id: ast::DUMMY_NODE_ID,\n+            node: hir::TyKind::Path(hir::QPath::Resolved(None, P(new_path))),\n+            span: DUMMY_SP,\n+            hir_id: hir::DUMMY_HIR_ID,\n+        }\n+    }\n+\n+    pub fn generics_to_path_params(&self, generics: ty::Generics) -> hir::GenericArgs {\n+        let mut args = vec![];\n+\n+        for param in generics.params.iter() {\n+            match param.kind {\n+                ty::GenericParamDefKind::Lifetime => {\n+                    let name = if param.name == \"\" {\n+                        hir::ParamName::Plain(keywords::StaticLifetime.ident())\n+                    } else {\n+                        hir::ParamName::Plain(ast::Ident::from_interned_str(param.name))\n+                    };\n+\n+                    args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: DUMMY_SP,\n+                        name: hir::LifetimeName::Param(name),\n+                    }));\n+                }\n+                ty::GenericParamDefKind::Type {..} => {\n+                    args.push(hir::GenericArg::Type(self.ty_param_to_ty(param.clone())));\n+                }\n+            }\n+        }\n+\n+        hir::GenericArgs {\n+            args: HirVec::from_vec(args),\n+            bindings: HirVec::new(),\n+            parenthesized: false,\n+        }\n+    }\n+\n+    pub fn ty_param_to_ty(&self, param: ty::GenericParamDef) -> hir::Ty {\n+        debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n+        hir::Ty {\n+            id: ast::DUMMY_NODE_ID,\n+            node: hir::TyKind::Path(hir::QPath::Resolved(\n+                None,\n+                P(hir::Path {\n+                    span: DUMMY_SP,\n+                    def: Def::TyParam(param.def_id),\n+                    segments: HirVec::from_vec(vec![\n+                        hir::PathSegment::from_ident(Ident::from_interned_str(param.name))\n+                    ]),\n+                }),\n+            )),\n+            span: DUMMY_SP,\n+            hir_id: hir::DUMMY_HIR_ID,\n+        }\n+    }\n }\n \n pub trait DocAccessLevels {"}, {"sha": "46e02ed08e00a72e0ab2f26e8b2d1c2d9a576d04", "filename": "src/test/rustdoc/generic-impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Ftest%2Frustdoc%2Fgeneric-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Ftest%2Frustdoc%2Fgeneric-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fgeneric-impl.rs?ref=667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "patch": "@@ -17,6 +17,7 @@ pub struct Bar;\n \n // @has foo/struct.Foo.html '//h3[@id=\"impl-ToString\"]//code' 'impl<T> ToString for T'\n pub struct Foo;\n+// @has foo/struct.Foo.html '//div[@class=\"sidebar-links\"]/a[@href=\"#impl-ToString\"]' 'ToString'\n \n impl fmt::Display for Foo {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "b4351b8268c8b8afcef503df0df672ad81e3d9c8", "filename": "src/test/rustdoc/primitive-generic-impl.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Ftest%2Frustdoc%2Fprimitive-generic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Ftest%2Frustdoc%2Fprimitive-generic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive-generic-impl.rs?ref=667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+// we need to reexport something from libstd so that `all_trait_implementations` is called.\n+pub use std::string::String;\n+\n+include!(\"primitive/primitive-generic-impl.rs\");\n+\n+// @has foo/primitive.i32.html '//h3[@id=\"impl-ToString\"]//code' 'impl<T> ToString for T'"}, {"sha": "1ac1fc95338af9bf23b7d9c5296870420ad1a667", "filename": "src/test/rustdoc/primitive/primitive-generic-impl.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Ftest%2Frustdoc%2Fprimitive%2Fprimitive-generic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3/src%2Ftest%2Frustdoc%2Fprimitive%2Fprimitive-generic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive%2Fprimitive-generic-impl.rs?ref=667fdc1ce49aa5be2a11bf565f27f8118bd7c4d3", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[doc(primitive = \"i32\")]\n+/// Some useless docs, wouhou!\n+mod i32 {}"}]}