{"sha": "10c7698d4b43aa9bd9b30df5e0769189d3a83110", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYzc2OThkNGI0M2FhOWJkOWIzMGRmNWUwNzY5MTg5ZDNhODMxMTA=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-06T13:27:32Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-06T13:27:32Z"}, "message": "deque: Implement Clone and Eq for Deque", "tree": {"sha": "d2c1f8ebbe3bf04b541630c023e47418b5e6319e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2c1f8ebbe3bf04b541630c023e47418b5e6319e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10c7698d4b43aa9bd9b30df5e0769189d3a83110", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10c7698d4b43aa9bd9b30df5e0769189d3a83110", "html_url": "https://github.com/rust-lang/rust/commit/10c7698d4b43aa9bd9b30df5e0769189d3a83110", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10c7698d4b43aa9bd9b30df5e0769189d3a83110/comments", "author": null, "committer": null, "parents": [{"sha": "07e2775dff0643f0f8f66f5ecf92ab7ee163bce4", "url": "https://api.github.com/repos/rust-lang/rust/commits/07e2775dff0643f0f8f66f5ecf92ab7ee163bce4", "html_url": "https://github.com/rust-lang/rust/commit/07e2775dff0643f0f8f66f5ecf92ab7ee163bce4"}], "stats": {"total": 49, "additions": 49, "deletions": 0}, "files": [{"sha": "36ebf295aabaa1f8d9f6364b0ad0372f012a7528", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/10c7698d4b43aa9bd9b30df5e0769189d3a83110/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c7698d4b43aa9bd9b30df5e0769189d3a83110/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=10c7698d4b43aa9bd9b30df5e0769189d3a83110", "patch": "@@ -18,6 +18,7 @@ static INITIAL_CAPACITY: uint = 8u; // 2^3\n static MINIMUM_CAPACITY: uint = 2u;\n \n #[allow(missing_doc)]\n+#[deriving(Clone)]\n pub struct Deque<T> {\n     priv nelts: uint,\n     priv lo: uint,\n@@ -272,6 +273,16 @@ fn raw_index(lo: uint, len: uint, index: uint) -> uint {\n     }\n }\n \n+impl<A: Eq> Eq for Deque<A> {\n+    fn eq(&self, other: &Deque<A>) -> bool {\n+        self.nelts == other.nelts &&\n+            self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n+    }\n+    fn ne(&self, other: &Deque<A>) -> bool {\n+        !self.eq(other)\n+    }\n+}\n+\n impl<A, T: Iterator<A>> FromIterator<A, T> for Deque<A> {\n     fn from_iterator(iterator: &mut T) -> Deque<A> {\n         let mut deq = Deque::new();\n@@ -631,4 +642,42 @@ mod tests {\n         }\n         assert_eq!(deq.len(), 256);\n     }\n+\n+    #[test]\n+    fn test_clone() {\n+        let mut d = Deque::new();\n+        d.add_front(17);\n+        d.add_front(42);\n+        d.add_back(137);\n+        d.add_back(137);\n+        assert_eq!(d.len(), 4u);\n+        let mut e = d.clone();\n+        assert_eq!(e.len(), 4u);\n+        while !d.is_empty() {\n+            assert_eq!(d.pop_back(), e.pop_back());\n+        }\n+        assert_eq!(d.len(), 0u);\n+        assert_eq!(e.len(), 0u);\n+    }\n+\n+    #[test]\n+    fn test_eq() {\n+        let mut d = Deque::new();\n+        assert_eq!(&d, &Deque::with_capacity(0));\n+        d.add_front(137);\n+        d.add_front(17);\n+        d.add_front(42);\n+        d.add_back(137);\n+        let mut e = Deque::with_capacity(0);\n+        e.add_back(42);\n+        e.add_back(17);\n+        e.add_back(137);\n+        e.add_back(137);\n+        assert_eq!(&e, &d);\n+        e.pop_back();\n+        e.add_back(0);\n+        assert!(e != d);\n+        e.clear();\n+        assert_eq!(e, Deque::new());\n+    }\n }"}]}