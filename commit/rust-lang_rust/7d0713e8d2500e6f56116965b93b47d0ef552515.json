{"sha": "7d0713e8d2500e6f56116965b93b47d0ef552515", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMDcxM2U4ZDI1MDBlNmY1NjExNjk2NWI5M2I0N2QwZWY1NTI1MTU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-22T14:59:48Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-22T14:59:48Z"}, "message": "Merge #1575\n\n1575: Use the same lexer as `rustc` r=matklad a=matklad\n\nThis is :zap: !\r\n\r\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "20ee49ed4ee94e463cd81f3f8142d64cde0ca134", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20ee49ed4ee94e463cd81f3f8142d64cde0ca134"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d0713e8d2500e6f56116965b93b47d0ef552515", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d0713e8d2500e6f56116965b93b47d0ef552515", "html_url": "https://github.com/rust-lang/rust/commit/7d0713e8d2500e6f56116965b93b47d0ef552515", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d0713e8d2500e6f56116965b93b47d0ef552515/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "d690249bc81bc265cb3d1836c2922325f4fdb8af", "url": "https://api.github.com/repos/rust-lang/rust/commits/d690249bc81bc265cb3d1836c2922325f4fdb8af", "html_url": "https://github.com/rust-lang/rust/commit/d690249bc81bc265cb3d1836c2922325f4fdb8af"}, {"sha": "700669bbd0ab3ae0c5a56985ce13ca896d342a3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/700669bbd0ab3ae0c5a56985ce13ca896d342a3a", "html_url": "https://github.com/rust-lang/rust/commit/700669bbd0ab3ae0c5a56985ce13ca896d342a3a"}], "stats": {"total": 770, "additions": 175, "deletions": 595}, "files": [{"sha": "d5474d6e286f049bb271531720dc0e7c4480f25a", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0713e8d2500e6f56116965b93b47d0ef552515/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7d0713e8d2500e6f56116965b93b47d0ef552515/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7d0713e8d2500e6f56116965b93b47d0ef552515", "patch": "@@ -1308,12 +1308,21 @@ dependencies = [\n  \"serde_json 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ra_rustc_lexer\"\n+version = \"0.1.0-pre.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"ra_syntax\"\n version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_parser 0.1.0\",\n+ \"ra_rustc_lexer 0.1.0-pre.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_text_edit 0.1.0\",\n  \"rowan 0.6.0-pre.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2250,6 +2259,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum proptest 0.9.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf147e022eacf0c8a054ab864914a7602618adba841d800a9a9868a5237a529f\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quote 0.6.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ce23b6b870e8f94f81fb0a363d65d86675884b34a09043c81e5562f11c1f8e1\"\n+\"checksum ra_rustc_lexer 0.1.0-pre.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8d92772f822978a6c9c4657aa61af439e4e635180628b3354049b283b749f1e\"\n \"checksum ra_vfs 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fb7cd4e302032c5ab514f1c01c89727cd96fd950dd36f9ebee9252df45d9fb1a\"\n \"checksum rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca\"\n \"checksum rand 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d47eab0e83d9693d40f825f86948aa16eff6750ead4bdffc4ab95b8b3a7f052c\""}, {"sha": "9ef8dee5d68712bcc92f3bc54cc73f49cc34a04c", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=7d0713e8d2500e6f56116965b93b47d0ef552515", "patch": "@@ -11,6 +11,7 @@ repository = \"https://github.com/rust-analyzer/rust-analyzer\"\n unicode-xid = \"0.1.0\"\n itertools = \"0.8.0\"\n rowan = \"0.6.0-pre.1\"\n+ra_rustc_lexer = { version = \"0.1.0-pre.1\", features = [ \"unicode-xid\" ] }\n \n # ideally, `serde` should be enabled by `ra_lsp_server`, but we enable it here\n # to reduce number of compilations"}, {"sha": "2a4343b0a6599881123f3798de9e38590a28fd4d", "filename": "crates/ra_syntax/src/parsing/lexer.rs", "status": "modified", "additions": 120, "deletions": 151, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs?ref=7d0713e8d2500e6f56116965b93b47d0ef552515", "patch": "@@ -1,22 +1,6 @@\n-mod classes;\n-mod comments;\n-mod numbers;\n-mod ptr;\n-mod strings;\n-\n use crate::{\n     SyntaxKind::{self, *},\n-    TextUnit, T,\n-};\n-\n-use self::{\n-    classes::*,\n-    comments::{scan_comment, scan_shebang},\n-    numbers::scan_number,\n-    ptr::Ptr,\n-    strings::{\n-        is_string_literal_start, scan_byte_char_or_string, scan_char, scan_raw_string, scan_string,\n-    },\n+    TextUnit,\n };\n \n /// A token of Rust source.\n@@ -30,149 +14,134 @@ pub struct Token {\n \n /// Break a string up into its component tokens\n pub fn tokenize(text: &str) -> Vec<Token> {\n+    if text.is_empty() {\n+        return vec![];\n+    }\n     let mut text = text;\n     let mut acc = Vec::new();\n-    while !text.is_empty() {\n-        let token = next_token(text);\n-        acc.push(token);\n-        let len: u32 = token.len.into();\n-        text = &text[len as usize..];\n-    }\n-    acc\n-}\n-\n-/// Get the next token from a string\n-pub fn next_token(text: &str) -> Token {\n-    assert!(!text.is_empty());\n-    let mut ptr = Ptr::new(text);\n-    let c = ptr.bump().unwrap();\n-    let kind = next_token_inner(c, &mut ptr);\n-    let len = ptr.into_len();\n-    Token { kind, len }\n-}\n-\n-fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n-    if is_whitespace(c) {\n-        ptr.bump_while(is_whitespace);\n-        return WHITESPACE;\n+    if let Some(len) = ra_rustc_lexer::strip_shebang(text) {\n+        acc.push(Token { kind: SHEBANG, len: TextUnit::from_usize(len) });\n+        text = &text[len..];\n     }\n-\n-    match c {\n-        '#' => {\n-            if scan_shebang(ptr) {\n-                return SHEBANG;\n-            }\n-        }\n-        '/' => {\n-            if let Some(kind) = scan_comment(ptr) {\n-                return kind;\n-            }\n+    while !text.is_empty() {\n+        let rustc_token = ra_rustc_lexer::first_token(text);\n+        macro_rules! decompose {\n+            ($t1:expr, $t2:expr) => {{\n+                acc.push(Token { kind: $t1, len: 1.into() });\n+                acc.push(Token { kind: $t2, len: 1.into() });\n+                text = &text[2..];\n+                continue;\n+            }};\n+            ($t1:expr, $t2:expr, $t3:expr) => {{\n+                acc.push(Token { kind: $t1, len: 1.into() });\n+                acc.push(Token { kind: $t2, len: 1.into() });\n+                acc.push(Token { kind: $t3, len: 1.into() });\n+                text = &text[3..];\n+                continue;\n+            }};\n         }\n-        _ => (),\n-    }\n-\n-    let ident_start = is_ident_start(c) && !is_string_literal_start(c, ptr.current(), ptr.nth(1));\n-    if ident_start {\n-        return scan_ident(c, ptr);\n-    }\n-\n-    if is_dec_digit(c) {\n-        let kind = scan_number(c, ptr);\n-        scan_literal_suffix(ptr);\n-        return kind;\n-    }\n-\n-    // One-byte tokens.\n-    if let Some(kind) = SyntaxKind::from_char(c) {\n-        return kind;\n-    }\n-\n-    match c {\n-        // Possiblily multi-byte tokens,\n-        // but we only produce single byte token now\n-        // T![...], T![..], T![..=], T![.]\n-        '.' => return T![.],\n-        // T![::] T![:]\n-        ':' => return T![:],\n-        // T![==] FATARROW T![=]\n-        '=' => return T![=],\n-        // T![!=] T![!]\n-        '!' => return T![!],\n-        // T![->] T![-]\n-        '-' => return T![-],\n-\n-        // If the character is an ident start not followed by another single\n-        // quote, then this is a lifetime name:\n-        '\\'' => {\n-            return if ptr.at_p(is_ident_start) && !ptr.at_str(\"''\") {\n-                ptr.bump();\n-                while ptr.at_p(is_ident_continue) {\n-                    ptr.bump();\n+        let kind = match rustc_token.kind {\n+            ra_rustc_lexer::TokenKind::LineComment => COMMENT,\n+            ra_rustc_lexer::TokenKind::BlockComment { .. } => COMMENT,\n+            ra_rustc_lexer::TokenKind::Whitespace => WHITESPACE,\n+            ra_rustc_lexer::TokenKind::Ident => {\n+                let token_text = &text[..rustc_token.len];\n+                if token_text == \"_\" {\n+                    UNDERSCORE\n+                } else {\n+                    SyntaxKind::from_keyword(&text[..rustc_token.len]).unwrap_or(IDENT)\n                 }\n-                // lifetimes shouldn't end with a single quote\n-                // if we find one, then this is an invalid character literal\n-                if ptr.at('\\'') {\n-                    ptr.bump();\n-                    return CHAR;\n-                }\n-                LIFETIME\n-            } else {\n-                scan_char(ptr);\n-                scan_literal_suffix(ptr);\n-                CHAR\n-            };\n-        }\n-        'b' => {\n-            let kind = scan_byte_char_or_string(ptr);\n-            scan_literal_suffix(ptr);\n-            return kind;\n-        }\n-        '\"' => {\n-            scan_string(ptr);\n-            scan_literal_suffix(ptr);\n-            return STRING;\n-        }\n-        'r' => {\n-            scan_raw_string(ptr);\n-            scan_literal_suffix(ptr);\n-            return RAW_STRING;\n-        }\n-        _ => (),\n-    }\n-    ERROR\n-}\n-\n-fn scan_ident(c: char, ptr: &mut Ptr) -> SyntaxKind {\n-    let is_raw = match (c, ptr.current()) {\n-        ('r', Some('#')) => {\n-            ptr.bump();\n-            true\n-        }\n-        ('_', None) => return T![_],\n-        ('_', Some(c)) if !is_ident_continue(c) => return T![_],\n-        _ => false,\n-    };\n-    ptr.bump_while(is_ident_continue);\n-    if !is_raw {\n-        if let Some(kind) = SyntaxKind::from_keyword(ptr.current_token_text()) {\n-            return kind;\n-        }\n-    }\n-    IDENT\n-}\n-\n-fn scan_literal_suffix(ptr: &mut Ptr) {\n-    if ptr.at_p(is_ident_start) {\n-        ptr.bump();\n+            }\n+            ra_rustc_lexer::TokenKind::RawIdent => IDENT,\n+            ra_rustc_lexer::TokenKind::Literal { kind, .. } => match kind {\n+                ra_rustc_lexer::LiteralKind::Int { .. } => INT_NUMBER,\n+                ra_rustc_lexer::LiteralKind::Float { .. } => FLOAT_NUMBER,\n+                ra_rustc_lexer::LiteralKind::Char { .. } => CHAR,\n+                ra_rustc_lexer::LiteralKind::Byte { .. } => BYTE,\n+                ra_rustc_lexer::LiteralKind::Str { .. } => STRING,\n+                ra_rustc_lexer::LiteralKind::ByteStr { .. } => BYTE_STRING,\n+                ra_rustc_lexer::LiteralKind::RawStr { .. } => RAW_STRING,\n+                ra_rustc_lexer::LiteralKind::RawByteStr { .. } => RAW_BYTE_STRING,\n+            },\n+            ra_rustc_lexer::TokenKind::Lifetime { .. } => LIFETIME,\n+            ra_rustc_lexer::TokenKind::Semi => SEMI,\n+            ra_rustc_lexer::TokenKind::Comma => COMMA,\n+            ra_rustc_lexer::TokenKind::DotDotDot => decompose!(DOT, DOT, DOT),\n+            ra_rustc_lexer::TokenKind::DotDotEq => decompose!(DOT, DOT, EQ),\n+            ra_rustc_lexer::TokenKind::DotDot => decompose!(DOT, DOT),\n+            ra_rustc_lexer::TokenKind::Dot => DOT,\n+            ra_rustc_lexer::TokenKind::OpenParen => L_PAREN,\n+            ra_rustc_lexer::TokenKind::CloseParen => R_PAREN,\n+            ra_rustc_lexer::TokenKind::OpenBrace => L_CURLY,\n+            ra_rustc_lexer::TokenKind::CloseBrace => R_CURLY,\n+            ra_rustc_lexer::TokenKind::OpenBracket => L_BRACK,\n+            ra_rustc_lexer::TokenKind::CloseBracket => R_BRACK,\n+            ra_rustc_lexer::TokenKind::At => AT,\n+            ra_rustc_lexer::TokenKind::Pound => POUND,\n+            ra_rustc_lexer::TokenKind::Tilde => TILDE,\n+            ra_rustc_lexer::TokenKind::Question => QUESTION,\n+            ra_rustc_lexer::TokenKind::ColonColon => decompose!(COLON, COLON),\n+            ra_rustc_lexer::TokenKind::Colon => COLON,\n+            ra_rustc_lexer::TokenKind::Dollar => DOLLAR,\n+            ra_rustc_lexer::TokenKind::EqEq => decompose!(EQ, EQ),\n+            ra_rustc_lexer::TokenKind::Eq => EQ,\n+            ra_rustc_lexer::TokenKind::FatArrow => decompose!(EQ, R_ANGLE),\n+            ra_rustc_lexer::TokenKind::Ne => decompose!(EXCL, EQ),\n+            ra_rustc_lexer::TokenKind::Not => EXCL,\n+            ra_rustc_lexer::TokenKind::Le => decompose!(L_ANGLE, EQ),\n+            ra_rustc_lexer::TokenKind::LArrow => decompose!(COLON, MINUS),\n+            ra_rustc_lexer::TokenKind::Lt => L_ANGLE,\n+            ra_rustc_lexer::TokenKind::ShlEq => decompose!(L_ANGLE, L_ANGLE, EQ),\n+            ra_rustc_lexer::TokenKind::Shl => decompose!(L_ANGLE, L_ANGLE),\n+            ra_rustc_lexer::TokenKind::Ge => decompose!(R_ANGLE, EQ),\n+            ra_rustc_lexer::TokenKind::Gt => R_ANGLE,\n+            ra_rustc_lexer::TokenKind::ShrEq => decompose!(R_ANGLE, R_ANGLE, EQ),\n+            ra_rustc_lexer::TokenKind::Shr => decompose!(R_ANGLE, R_ANGLE),\n+            ra_rustc_lexer::TokenKind::RArrow => decompose!(MINUS, R_ANGLE),\n+            ra_rustc_lexer::TokenKind::Minus => MINUS,\n+            ra_rustc_lexer::TokenKind::MinusEq => decompose!(MINUS, EQ),\n+            ra_rustc_lexer::TokenKind::And => AMP,\n+            ra_rustc_lexer::TokenKind::AndAnd => decompose!(AMP, AMP),\n+            ra_rustc_lexer::TokenKind::AndEq => decompose!(AMP, EQ),\n+            ra_rustc_lexer::TokenKind::Or => PIPE,\n+            ra_rustc_lexer::TokenKind::OrOr => decompose!(PIPE, PIPE),\n+            ra_rustc_lexer::TokenKind::OrEq => decompose!(PIPE, EQ),\n+            ra_rustc_lexer::TokenKind::PlusEq => decompose!(PLUS, EQ),\n+            ra_rustc_lexer::TokenKind::Plus => PLUS,\n+            ra_rustc_lexer::TokenKind::StarEq => decompose!(STAR, EQ),\n+            ra_rustc_lexer::TokenKind::Star => STAR,\n+            ra_rustc_lexer::TokenKind::SlashEq => decompose!(SLASH, EQ),\n+            ra_rustc_lexer::TokenKind::Slash => SLASH,\n+            ra_rustc_lexer::TokenKind::CaretEq => decompose!(CARET, EQ),\n+            ra_rustc_lexer::TokenKind::Caret => CARET,\n+            ra_rustc_lexer::TokenKind::PercentEq => decompose!(PERCENT, EQ),\n+            ra_rustc_lexer::TokenKind::Percent => PERCENT,\n+            ra_rustc_lexer::TokenKind::Unknown => ERROR,\n+        };\n+        let token = Token { kind, len: TextUnit::from_usize(rustc_token.len) };\n+        acc.push(token);\n+        text = &text[rustc_token.len..];\n     }\n-    ptr.bump_while(is_ident_continue);\n+    acc\n }\n \n pub fn classify_literal(text: &str) -> Option<Token> {\n-    let tkn = next_token(text);\n-    if !tkn.kind.is_literal() || tkn.len.to_usize() != text.len() {\n+    let t = ra_rustc_lexer::first_token(text);\n+    if t.len != text.len() {\n         return None;\n     }\n-\n-    Some(tkn)\n+    let kind = match t.kind {\n+        ra_rustc_lexer::TokenKind::Literal { kind, .. } => match kind {\n+            ra_rustc_lexer::LiteralKind::Int { .. } => INT_NUMBER,\n+            ra_rustc_lexer::LiteralKind::Float { .. } => FLOAT_NUMBER,\n+            ra_rustc_lexer::LiteralKind::Char { .. } => CHAR,\n+            ra_rustc_lexer::LiteralKind::Byte { .. } => BYTE,\n+            ra_rustc_lexer::LiteralKind::Str { .. } => STRING,\n+            ra_rustc_lexer::LiteralKind::ByteStr { .. } => BYTE_STRING,\n+            ra_rustc_lexer::LiteralKind::RawStr { .. } => RAW_STRING,\n+            ra_rustc_lexer::LiteralKind::RawByteStr { .. } => RAW_BYTE_STRING,\n+        },\n+        _ => return None,\n+    };\n+    Some(Token { kind, len: TextUnit::from_usize(t.len) })\n }"}, {"sha": "4235d2648ad3a903ab9d71655d16bdf70323f7ba", "filename": "crates/ra_syntax/src/parsing/lexer/classes.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d690249bc81bc265cb3d1836c2922325f4fdb8af/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d690249bc81bc265cb3d1836c2922325f4fdb8af/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fclasses.rs?ref=d690249bc81bc265cb3d1836c2922325f4fdb8af", "patch": "@@ -1,26 +0,0 @@\n-use unicode_xid::UnicodeXID;\n-\n-pub fn is_ident_start(c: char) -> bool {\n-    (c >= 'a' && c <= 'z')\n-        || (c >= 'A' && c <= 'Z')\n-        || c == '_'\n-        || (c > '\\x7f' && UnicodeXID::is_xid_start(c))\n-}\n-\n-pub fn is_ident_continue(c: char) -> bool {\n-    (c >= 'a' && c <= 'z')\n-        || (c >= 'A' && c <= 'Z')\n-        || (c >= '0' && c <= '9')\n-        || c == '_'\n-        || (c > '\\x7f' && UnicodeXID::is_xid_continue(c))\n-}\n-\n-pub fn is_whitespace(c: char) -> bool {\n-    //FIXME: use is_pattern_whitespace\n-    //https://github.com/behnam/rust-unic/issues/192\n-    c.is_whitespace()\n-}\n-\n-pub fn is_dec_digit(c: char) -> bool {\n-    '0' <= c && c <= '9'\n-}"}, {"sha": "8bbbe659b35ea4a72035b56bdd9e148d2f708b73", "filename": "crates/ra_syntax/src/parsing/lexer/comments.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d690249bc81bc265cb3d1836c2922325f4fdb8af/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d690249bc81bc265cb3d1836c2922325f4fdb8af/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fcomments.rs?ref=d690249bc81bc265cb3d1836c2922325f4fdb8af", "patch": "@@ -1,57 +0,0 @@\n-use crate::parsing::lexer::ptr::Ptr;\n-\n-use crate::SyntaxKind::{self, *};\n-\n-pub(crate) fn scan_shebang(ptr: &mut Ptr) -> bool {\n-    if ptr.at_str(\"!/\") {\n-        ptr.bump();\n-        ptr.bump();\n-        bump_until_eol(ptr);\n-        true\n-    } else {\n-        false\n-    }\n-}\n-\n-fn scan_block_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n-    if ptr.at('*') {\n-        ptr.bump();\n-        let mut depth: u32 = 1;\n-        while depth > 0 {\n-            if ptr.at_str(\"*/\") {\n-                depth -= 1;\n-                ptr.bump();\n-                ptr.bump();\n-            } else if ptr.at_str(\"/*\") {\n-                depth += 1;\n-                ptr.bump();\n-                ptr.bump();\n-            } else if ptr.bump().is_none() {\n-                break;\n-            }\n-        }\n-        Some(COMMENT)\n-    } else {\n-        None\n-    }\n-}\n-\n-pub(crate) fn scan_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n-    if ptr.at('/') {\n-        bump_until_eol(ptr);\n-        Some(COMMENT)\n-    } else {\n-        scan_block_comment(ptr)\n-    }\n-}\n-\n-fn bump_until_eol(ptr: &mut Ptr) {\n-    loop {\n-        if ptr.at('\\n') || ptr.at_str(\"\\r\\n\") {\n-            return;\n-        }\n-        if ptr.bump().is_none() {\n-            break;\n-        }\n-    }\n-}"}, {"sha": "e53ae231b331a24e711f026b47e25d0d27f60326", "filename": "crates/ra_syntax/src/parsing/lexer/numbers.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d690249bc81bc265cb3d1836c2922325f4fdb8af/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fnumbers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d690249bc81bc265cb3d1836c2922325f4fdb8af/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fnumbers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fnumbers.rs?ref=d690249bc81bc265cb3d1836c2922325f4fdb8af", "patch": "@@ -1,66 +0,0 @@\n-use crate::parsing::lexer::{classes::*, ptr::Ptr};\n-\n-use crate::SyntaxKind::{self, *};\n-\n-pub(crate) fn scan_number(c: char, ptr: &mut Ptr) -> SyntaxKind {\n-    if c == '0' {\n-        match ptr.current().unwrap_or('\\0') {\n-            'b' | 'o' => {\n-                ptr.bump();\n-                scan_digits(ptr, false);\n-            }\n-            'x' => {\n-                ptr.bump();\n-                scan_digits(ptr, true);\n-            }\n-            '0'..='9' | '_' | '.' | 'e' | 'E' => {\n-                scan_digits(ptr, true);\n-            }\n-            _ => return INT_NUMBER,\n-        }\n-    } else {\n-        scan_digits(ptr, false);\n-    }\n-\n-    // might be a float, but don't be greedy if this is actually an\n-    // integer literal followed by field/method access or a range pattern\n-    // (`0..2` and `12.foo()`)\n-    if ptr.at('.') && !(ptr.at_str(\"..\") || ptr.nth_is_p(1, is_ident_start)) {\n-        // might have stuff after the ., and if it does, it needs to start\n-        // with a number\n-        ptr.bump();\n-        scan_digits(ptr, false);\n-        scan_float_exponent(ptr);\n-        return FLOAT_NUMBER;\n-    }\n-    // it might be a float if it has an exponent\n-    if ptr.at('e') || ptr.at('E') {\n-        scan_float_exponent(ptr);\n-        return FLOAT_NUMBER;\n-    }\n-    INT_NUMBER\n-}\n-\n-fn scan_digits(ptr: &mut Ptr, allow_hex: bool) {\n-    while let Some(c) = ptr.current() {\n-        match c {\n-            '_' | '0'..='9' => {\n-                ptr.bump();\n-            }\n-            'a'..='f' | 'A'..='F' if allow_hex => {\n-                ptr.bump();\n-            }\n-            _ => return,\n-        }\n-    }\n-}\n-\n-fn scan_float_exponent(ptr: &mut Ptr) {\n-    if ptr.at('e') || ptr.at('E') {\n-        ptr.bump();\n-        if ptr.at('-') || ptr.at('+') {\n-            ptr.bump();\n-        }\n-        scan_digits(ptr, false);\n-    }\n-}"}, {"sha": "c341c4176bbe85a74634fa44398383a9b80401ae", "filename": "crates/ra_syntax/src/parsing/lexer/ptr.rs", "status": "removed", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/d690249bc81bc265cb3d1836c2922325f4fdb8af/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d690249bc81bc265cb3d1836c2922325f4fdb8af/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fptr.rs?ref=d690249bc81bc265cb3d1836c2922325f4fdb8af", "patch": "@@ -1,162 +0,0 @@\n-use crate::TextUnit;\n-\n-use std::str::Chars;\n-\n-/// A simple view into the characters of a string.\n-pub(crate) struct Ptr<'s> {\n-    text: &'s str,\n-    len: TextUnit,\n-}\n-\n-impl<'s> Ptr<'s> {\n-    /// Creates a new `Ptr` from a string.\n-    pub fn new(text: &'s str) -> Ptr<'s> {\n-        Ptr { text, len: 0.into() }\n-    }\n-\n-    /// Gets the length of the remaining string.\n-    pub fn into_len(self) -> TextUnit {\n-        self.len\n-    }\n-\n-    /// Gets the current character, if one exists.\n-    pub fn current(&self) -> Option<char> {\n-        self.chars().next()\n-    }\n-\n-    /// Gets the nth character from the current.\n-    /// For example, 0 will return the current character, 1 will return the next, etc.\n-    pub fn nth(&self, n: u32) -> Option<char> {\n-        self.chars().nth(n as usize)\n-    }\n-\n-    /// Checks whether the current character is `c`.\n-    pub fn at(&self, c: char) -> bool {\n-        self.current() == Some(c)\n-    }\n-\n-    /// Checks whether the next characters match `s`.\n-    pub fn at_str(&self, s: &str) -> bool {\n-        let chars = self.chars();\n-        chars.as_str().starts_with(s)\n-    }\n-\n-    /// Checks whether the current character satisfies the predicate `p`.\n-    pub fn at_p<P: Fn(char) -> bool>(&self, p: P) -> bool {\n-        self.current().map(p) == Some(true)\n-    }\n-\n-    /// Checks whether the nth character satisfies the predicate `p`.\n-    pub fn nth_is_p<P: Fn(char) -> bool>(&self, n: u32, p: P) -> bool {\n-        self.nth(n).map(p) == Some(true)\n-    }\n-\n-    /// Moves to the next character.\n-    pub fn bump(&mut self) -> Option<char> {\n-        let ch = self.chars().next()?;\n-        self.len += TextUnit::of_char(ch);\n-        Some(ch)\n-    }\n-\n-    /// Moves to the next character as long as `pred` is satisfied.\n-    pub fn bump_while<F: Fn(char) -> bool>(&mut self, pred: F) {\n-        loop {\n-            match self.current() {\n-                Some(c) if pred(c) => {\n-                    self.bump();\n-                }\n-                _ => return,\n-            }\n-        }\n-    }\n-\n-    /// Returns the text up to the current point.\n-    pub fn current_token_text(&self) -> &str {\n-        let len: u32 = self.len.into();\n-        &self.text[..len as usize]\n-    }\n-\n-    /// Returns an iterator over the remaining characters.\n-    fn chars(&self) -> Chars {\n-        let len: u32 = self.len.into();\n-        self.text[len as usize..].chars()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_current() {\n-        let ptr = Ptr::new(\"test\");\n-        assert_eq!(ptr.current(), Some('t'));\n-    }\n-\n-    #[test]\n-    fn test_nth() {\n-        let ptr = Ptr::new(\"test\");\n-        assert_eq!(ptr.nth(0), Some('t'));\n-        assert_eq!(ptr.nth(1), Some('e'));\n-        assert_eq!(ptr.nth(2), Some('s'));\n-        assert_eq!(ptr.nth(3), Some('t'));\n-        assert_eq!(ptr.nth(4), None);\n-    }\n-\n-    #[test]\n-    fn test_at() {\n-        let ptr = Ptr::new(\"test\");\n-        assert!(ptr.at('t'));\n-        assert!(!ptr.at('a'));\n-    }\n-\n-    #[test]\n-    fn test_at_str() {\n-        let ptr = Ptr::new(\"test\");\n-        assert!(ptr.at_str(\"t\"));\n-        assert!(ptr.at_str(\"te\"));\n-        assert!(ptr.at_str(\"test\"));\n-        assert!(!ptr.at_str(\"tests\"));\n-        assert!(!ptr.at_str(\"rust\"));\n-    }\n-\n-    #[test]\n-    fn test_at_p() {\n-        let ptr = Ptr::new(\"test\");\n-        assert!(ptr.at_p(|c| c == 't'));\n-        assert!(!ptr.at_p(|c| c == 'e'));\n-    }\n-\n-    #[test]\n-    fn test_nth_is_p() {\n-        let ptr = Ptr::new(\"test\");\n-        assert!(ptr.nth_is_p(0, |c| c == 't'));\n-        assert!(!ptr.nth_is_p(1, |c| c == 't'));\n-        assert!(ptr.nth_is_p(3, |c| c == 't'));\n-        assert!(!ptr.nth_is_p(150, |c| c == 't'));\n-    }\n-\n-    #[test]\n-    fn test_bump() {\n-        let mut ptr = Ptr::new(\"test\");\n-        assert_eq!(ptr.current(), Some('t'));\n-        ptr.bump();\n-        assert_eq!(ptr.current(), Some('e'));\n-        ptr.bump();\n-        assert_eq!(ptr.current(), Some('s'));\n-        ptr.bump();\n-        assert_eq!(ptr.current(), Some('t'));\n-        ptr.bump();\n-        assert_eq!(ptr.current(), None);\n-        ptr.bump();\n-        assert_eq!(ptr.current(), None);\n-    }\n-\n-    #[test]\n-    fn test_bump_while() {\n-        let mut ptr = Ptr::new(\"test\");\n-        assert_eq!(ptr.current(), Some('t'));\n-        ptr.bump_while(|c| c != 's');\n-        assert_eq!(ptr.current(), Some('s'));\n-    }\n-}"}, {"sha": "f74acff9e21bac578f1e0f77d4288bb7eda2a0d1", "filename": "crates/ra_syntax/src/parsing/lexer/strings.rs", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d690249bc81bc265cb3d1836c2922325f4fdb8af/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d690249bc81bc265cb3d1836c2922325f4fdb8af/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer%2Fstrings.rs?ref=d690249bc81bc265cb3d1836c2922325f4fdb8af", "patch": "@@ -1,112 +0,0 @@\n-use crate::{\n-    parsing::lexer::ptr::Ptr,\n-    SyntaxKind::{self, *},\n-};\n-\n-pub(crate) fn is_string_literal_start(c: char, c1: Option<char>, c2: Option<char>) -> bool {\n-    match (c, c1, c2) {\n-        ('r', Some('\"'), _)\n-        | ('r', Some('#'), Some('\"'))\n-        | ('r', Some('#'), Some('#'))\n-        | ('b', Some('\"'), _)\n-        | ('b', Some('\\''), _)\n-        | ('b', Some('r'), Some('\"'))\n-        | ('b', Some('r'), Some('#')) => true,\n-        _ => false,\n-    }\n-}\n-\n-pub(crate) fn scan_char(ptr: &mut Ptr) {\n-    while let Some(c) = ptr.current() {\n-        match c {\n-            '\\\\' => {\n-                ptr.bump();\n-                if ptr.at('\\\\') || ptr.at('\\'') {\n-                    ptr.bump();\n-                }\n-            }\n-            '\\'' => {\n-                ptr.bump();\n-                return;\n-            }\n-            '\\n' => return,\n-            _ => {\n-                ptr.bump();\n-            }\n-        }\n-    }\n-}\n-\n-pub(crate) fn scan_byte_char_or_string(ptr: &mut Ptr) -> SyntaxKind {\n-    // unwrapping and not-exhaustive match are ok\n-    // because of string_literal_start\n-    let c = ptr.bump().unwrap();\n-    match c {\n-        '\\'' => {\n-            scan_byte(ptr);\n-            BYTE\n-        }\n-        '\"' => {\n-            scan_byte_string(ptr);\n-            BYTE_STRING\n-        }\n-        'r' => {\n-            scan_raw_string(ptr);\n-            RAW_BYTE_STRING\n-        }\n-        _ => unreachable!(),\n-    }\n-}\n-\n-pub(crate) fn scan_string(ptr: &mut Ptr) {\n-    while let Some(c) = ptr.current() {\n-        match c {\n-            '\\\\' => {\n-                ptr.bump();\n-                if ptr.at('\\\\') || ptr.at('\"') {\n-                    ptr.bump();\n-                }\n-            }\n-            '\"' => {\n-                ptr.bump();\n-                return;\n-            }\n-            _ => {\n-                ptr.bump();\n-            }\n-        }\n-    }\n-}\n-\n-pub(crate) fn scan_raw_string(ptr: &mut Ptr) {\n-    let mut hashes = 0;\n-    while ptr.at('#') {\n-        hashes += 1;\n-        ptr.bump();\n-    }\n-    if !ptr.at('\"') {\n-        return;\n-    }\n-    ptr.bump();\n-\n-    while let Some(c) = ptr.bump() {\n-        if c == '\"' {\n-            let mut hashes_left = hashes;\n-            while ptr.at('#') && hashes_left > 0 {\n-                hashes_left -= 1;\n-                ptr.bump();\n-            }\n-            if hashes_left == 0 {\n-                return;\n-            }\n-        }\n-    }\n-}\n-\n-fn scan_byte(ptr: &mut Ptr) {\n-    scan_char(ptr)\n-}\n-\n-fn scan_byte_string(ptr: &mut Ptr) {\n-    scan_string(ptr)\n-}"}, {"sha": "7bb89b8ae8e43563c02969f68f8e192cfec0bd3b", "filename": "crates/ra_syntax/tests/data/lexer/0004_numbers.txt", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2Ftests%2Fdata%2Flexer%2F0004_numbers.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2Ftests%2Fdata%2Flexer%2F0004_numbers.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Flexer%2F0004_numbers.txt?ref=7d0713e8d2500e6f56116965b93b47d0ef552515", "patch": "@@ -12,9 +12,9 @@ INT_NUMBER 2 \"0_\"\n WHITESPACE 1 \" \"\n FLOAT_NUMBER 2 \"0.\"\n WHITESPACE 1 \" \"\n-INT_NUMBER 2 \"0e\"\n+FLOAT_NUMBER 2 \"0e\"\n WHITESPACE 1 \" \"\n-INT_NUMBER 2 \"0E\"\n+FLOAT_NUMBER 2 \"0E\"\n WHITESPACE 1 \" \"\n INT_NUMBER 2 \"0z\"\n WHITESPACE 1 \"\\n\"\n@@ -32,9 +32,9 @@ INT_NUMBER 6 \"0_1279\"\n WHITESPACE 1 \" \"\n FLOAT_NUMBER 6 \"0.1279\"\n WHITESPACE 1 \" \"\n-INT_NUMBER 6 \"0e1279\"\n+FLOAT_NUMBER 6 \"0e1279\"\n WHITESPACE 1 \" \"\n-INT_NUMBER 6 \"0E1279\"\n+FLOAT_NUMBER 6 \"0E1279\"\n WHITESPACE 1 \"\\n\"\n INT_NUMBER 1 \"0\"\n DOT 1 \".\"\n@@ -47,9 +47,7 @@ IDENT 3 \"foo\"\n L_PAREN 1 \"(\"\n R_PAREN 1 \")\"\n WHITESPACE 1 \"\\n\"\n-INT_NUMBER 2 \"0e\"\n-PLUS 1 \"+\"\n-INT_NUMBER 1 \"1\"\n+FLOAT_NUMBER 4 \"0e+1\"\n WHITESPACE 1 \"\\n\"\n INT_NUMBER 1 \"0\"\n DOT 1 \".\""}, {"sha": "737a300ee788e05525b67a01cfc1b3e885df54c4", "filename": "crates/ra_syntax/tests/data/lexer/0014_unclosed_char.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2Ftests%2Fdata%2Flexer%2F0014_unclosed_char.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2Ftests%2Fdata%2Flexer%2F0014_unclosed_char.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Flexer%2F0014_unclosed_char.txt?ref=7d0713e8d2500e6f56116965b93b47d0ef552515", "patch": "@@ -1 +1 @@\n-CHAR 2 \"\\'1\"\n+LIFETIME 2 \"\\'1\""}, {"sha": "84867026f4d3bc033612b866fba7267956d5d804", "filename": "crates/ra_syntax/tests/data/parser/err/0002_duplicate_shebang.txt", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0002_duplicate_shebang.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0002_duplicate_shebang.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0002_duplicate_shebang.txt?ref=7d0713e8d2500e6f56116965b93b47d0ef552515", "patch": "@@ -1,7 +1,39 @@\n SOURCE_FILE@[0; 42)\n   SHEBANG@[0; 20) \"#!/use/bin/env rusti\"\n   WHITESPACE@[20; 21) \"\\n\"\n-  ERROR@[21; 41)\n-    SHEBANG@[21; 41) \"#!/use/bin/env rusti\"\n+  ATTR@[21; 23)\n+    POUND@[21; 22) \"#\"\n+    EXCL@[22; 23) \"!\"\n+  ERROR@[23; 24)\n+    SLASH@[23; 24) \"/\"\n+  USE_ITEM@[24; 28)\n+    USE_KW@[24; 27) \"use\"\n+    ERROR@[27; 28)\n+      SLASH@[27; 28) \"/\"\n+  MACRO_CALL@[28; 31)\n+    PATH@[28; 31)\n+      PATH_SEGMENT@[28; 31)\n+        NAME_REF@[28; 31)\n+          IDENT@[28; 31) \"bin\"\n+  ERROR@[31; 32)\n+    SLASH@[31; 32) \"/\"\n+  MACRO_CALL@[32; 41)\n+    PATH@[32; 35)\n+      PATH_SEGMENT@[32; 35)\n+        NAME_REF@[32; 35)\n+          IDENT@[32; 35) \"env\"\n+    WHITESPACE@[35; 36) \" \"\n+    NAME@[36; 41)\n+      IDENT@[36; 41) \"rusti\"\n   WHITESPACE@[41; 42) \"\\n\"\n-error 21: expected an item\n+error 23: expected `[`\n+error 23: expected an item\n+error 27: expected one of `*`, `::`, `{`, `self`, `super` or an indentifier\n+error 28: expected SEMI\n+error 31: expected EXCL\n+error 31: expected `{`, `[`, `(`\n+error 31: expected SEMI\n+error 31: expected an item\n+error 35: expected EXCL\n+error 41: expected `{`, `[`, `(`\n+error 41: expected SEMI"}, {"sha": "261aad1fb6b402f13d3a192bebcef9d28e963ea8", "filename": "crates/ra_syntax/tests/data/parser/ok/0030_string_suffixes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Fok%2F0030_string_suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Fok%2F0030_string_suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Fok%2F0030_string_suffixes.rs?ref=7d0713e8d2500e6f56116965b93b47d0ef552515", "previous_filename": "crates/ra_syntax/tests/data/parser/err/0030_string_suffixes.rs"}, {"sha": "4f7e809c5d44519c49067287d121bffa151ad2d4", "filename": "crates/ra_syntax/tests/data/parser/ok/0030_string_suffixes.txt", "status": "renamed", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Fok%2F0030_string_suffixes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7d0713e8d2500e6f56116965b93b47d0ef552515/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Fok%2F0030_string_suffixes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Fok%2F0030_string_suffixes.txt?ref=7d0713e8d2500e6f56116965b93b47d0ef552515", "patch": "@@ -11,22 +11,16 @@ SOURCE_FILE@[0; 112)\n     BLOCK@[10; 111)\n       L_CURLY@[10; 11) \"{\"\n       WHITESPACE@[11; 16) \"\\n    \"\n-      LET_STMT@[16; 27)\n+      LET_STMT@[16; 31)\n         LET_KW@[16; 19) \"let\"\n         WHITESPACE@[19; 20) \" \"\n         PLACEHOLDER_PAT@[20; 21)\n           UNDERSCORE@[20; 21) \"_\"\n         WHITESPACE@[21; 22) \" \"\n         EQ@[22; 23) \"=\"\n         WHITESPACE@[23; 24) \" \"\n-        LITERAL@[24; 27)\n-          CHAR@[24; 27) \"\\'c\\'\"\n-      EXPR_STMT@[27; 31)\n-        PATH_EXPR@[27; 30)\n-          PATH@[27; 30)\n-            PATH_SEGMENT@[27; 30)\n-              NAME_REF@[27; 30)\n-                IDENT@[27; 30) \"u32\"\n+        LITERAL@[24; 30)\n+          CHAR@[24; 30) \"\\'c\\'u32\"\n         SEMI@[30; 31) \";\"\n       WHITESPACE@[31; 36) \"\\n    \"\n       LET_STMT@[36; 60)\n@@ -67,4 +61,3 @@ SOURCE_FILE@[0; 112)\n       WHITESPACE@[109; 110) \"\\n\"\n       R_CURLY@[110; 111) \"}\"\n   WHITESPACE@[111; 112) \"\\n\"\n-error 27: expected SEMI", "previous_filename": "crates/ra_syntax/tests/data/parser/err/0030_string_suffixes.txt"}]}