{"sha": "73b97c7e7c9cfac4dfa4804654b1db6ab687b589", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYjk3YzdlN2M5Y2ZhYzRkZmE0ODA0NjU0YjFkYjZhYjY4N2I1ODk=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-03-27T09:57:00Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-03-27T09:57:00Z"}, "message": "Hide type declarations by default", "tree": {"sha": "f0ae4ba805b0c8cacb4b487992aa6b7e996849d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0ae4ba805b0c8cacb4b487992aa6b7e996849d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73b97c7e7c9cfac4dfa4804654b1db6ab687b589", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73b97c7e7c9cfac4dfa4804654b1db6ab687b589", "html_url": "https://github.com/rust-lang/rust/commit/73b97c7e7c9cfac4dfa4804654b1db6ab687b589", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73b97c7e7c9cfac4dfa4804654b1db6ab687b589/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "184156ed97a0a1256e80a17b8673749569407c94", "url": "https://api.github.com/repos/rust-lang/rust/commits/184156ed97a0a1256e80a17b8673749569407c94", "html_url": "https://github.com/rust-lang/rust/commit/184156ed97a0a1256e80a17b8673749569407c94"}], "stats": {"total": 303, "additions": 165, "deletions": 138}, "files": [{"sha": "6a1ce2c7974f14fa852732fb3aa90939a028937a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 150, "deletions": 135, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/73b97c7e7c9cfac4dfa4804654b1db6ab687b589/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b97c7e7c9cfac4dfa4804654b1db6ab687b589/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=73b97c7e7c9cfac4dfa4804654b1db6ab687b589", "patch": "@@ -1675,11 +1675,19 @@ impl<'a> Item<'a> {\n     }\n }\n \n+fn wrap_into_docblock<F>(w: &mut fmt::Formatter,\n+                         f: F) -> fmt::Result\n+where F: Fn(&mut fmt::Formatter) -> fmt::Result {\n+    write!(w, \"<div class=\\\"docblock type-decl\\\">\")?;\n+    f(w)?;\n+    write!(w, \"</div>\")\n+}\n+\n impl<'a> fmt::Display for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         debug_assert!(!self.item.is_stripped());\n         // Write the breadcrumb trail header for the top\n-        write!(fmt, \"\\n<h1 class='fqn'><span class='in-band'>\")?;\n+        write!(fmt, \"<h1 class='fqn'><span class='in-band'>\")?;\n         match self.item.inner {\n             clean::ModuleItem(ref m) => if m.is_crate {\n                     write!(fmt, \"Crate \")?;\n@@ -1741,14 +1749,11 @@ impl<'a> fmt::Display for Item<'a> {\n             }\n         }\n \n-        write!(fmt, \"</span>\")?; // out-of-band\n-\n-        write!(fmt, \"</h1>\\n\")?;\n+        write!(fmt, \"</span></h1>\")?; // out-of-band\n \n         match self.item.inner {\n-            clean::ModuleItem(ref m) => {\n-                item_module(fmt, self.cx, self.item, &m.items)\n-            }\n+            clean::ModuleItem(ref m) =>\n+                item_module(fmt, self.cx, self.item, &m.items),\n             clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n                 item_function(fmt, self.cx, self.item, f),\n             clean::TraitItem(ref t) => item_trait(fmt, self.cx, self.item, t),\n@@ -2306,79 +2311,81 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         }\n     }\n \n-    // Output the trait definition\n-    write!(w, \"<pre class='rust trait'>\")?;\n-    render_attributes(w, it)?;\n-    write!(w, \"{}{}{}trait {}{}{}\",\n-           VisSpace(&it.visibility),\n-           UnsafetySpace(t.unsafety),\n-           if t.is_auto { \"auto \" } else { \"\" },\n-           it.name.as_ref().unwrap(),\n-           t.generics,\n-           bounds)?;\n-\n-    if !t.generics.where_predicates.is_empty() {\n-        write!(w, \"{}\", WhereClause { gens: &t.generics, indent: 0, end_newline: true })?;\n-    } else {\n-        write!(w, \" \")?;\n-    }\n-\n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n     let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n     let provided = t.items.iter().filter(|m| m.is_method()).collect::<Vec<_>>();\n \n-    if t.items.is_empty() {\n-        write!(w, \"{{ }}\")?;\n-    } else {\n-        // FIXME: we should be using a derived_id for the Anchors here\n-        write!(w, \"{{\\n\")?;\n-        for t in &types {\n-            write!(w, \"    \")?;\n-            render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait)?;\n-            write!(w, \";\\n\")?;\n-        }\n-        if !types.is_empty() && !consts.is_empty() {\n-            w.write_str(\"\\n\")?;\n-        }\n-        for t in &consts {\n-            write!(w, \"    \")?;\n-            render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait)?;\n-            write!(w, \";\\n\")?;\n-        }\n-        if !consts.is_empty() && !required.is_empty() {\n-            w.write_str(\"\\n\")?;\n+    // Output the trait definition\n+    wrap_into_docblock(w, |w| {\n+        write!(w, \"<pre class='rust trait'>\")?;\n+        render_attributes(w, it)?;\n+        write!(w, \"{}{}{}trait {}{}{}\",\n+               VisSpace(&it.visibility),\n+               UnsafetySpace(t.unsafety),\n+               if t.is_auto { \"auto \" } else { \"\" },\n+               it.name.as_ref().unwrap(),\n+               t.generics,\n+               bounds)?;\n+\n+        if !t.generics.where_predicates.is_empty() {\n+            write!(w, \"{}\", WhereClause { gens: &t.generics, indent: 0, end_newline: true })?;\n+        } else {\n+            write!(w, \" \")?;\n         }\n-        for (pos, m) in required.iter().enumerate() {\n-            write!(w, \"    \")?;\n-            render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait)?;\n-            write!(w, \";\\n\")?;\n \n-            if pos < required.len() - 1 {\n-               write!(w, \"<div class='item-spacer'></div>\")?;\n+        if t.items.is_empty() {\n+            write!(w, \"{{ }}\")?;\n+        } else {\n+            // FIXME: we should be using a derived_id for the Anchors here\n+            write!(w, \"{{\\n\")?;\n+            for t in &types {\n+                write!(w, \"    \")?;\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait)?;\n+                write!(w, \";\\n\")?;\n             }\n-        }\n-        if !required.is_empty() && !provided.is_empty() {\n-            w.write_str(\"\\n\")?;\n-        }\n-        for (pos, m) in provided.iter().enumerate() {\n-            write!(w, \"    \")?;\n-            render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait)?;\n-            match m.inner {\n-                clean::MethodItem(ref inner) if !inner.generics.where_predicates.is_empty() => {\n-                    write!(w, \",\\n    {{ ... }}\\n\")?;\n-                },\n-                _ => {\n-                    write!(w, \" {{ ... }}\\n\")?;\n-                },\n+            if !types.is_empty() && !consts.is_empty() {\n+                w.write_str(\"\\n\")?;\n             }\n-            if pos < provided.len() - 1 {\n-               write!(w, \"<div class='item-spacer'></div>\")?;\n+            for t in &consts {\n+                write!(w, \"    \")?;\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait)?;\n+                write!(w, \";\\n\")?;\n             }\n+            if !consts.is_empty() && !required.is_empty() {\n+                w.write_str(\"\\n\")?;\n+            }\n+            for (pos, m) in required.iter().enumerate() {\n+                write!(w, \"    \")?;\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait)?;\n+                write!(w, \";\\n\")?;\n+\n+                if pos < required.len() - 1 {\n+                   write!(w, \"<div class='item-spacer'></div>\")?;\n+                }\n+            }\n+            if !required.is_empty() && !provided.is_empty() {\n+                w.write_str(\"\\n\")?;\n+            }\n+            for (pos, m) in provided.iter().enumerate() {\n+                write!(w, \"    \")?;\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait)?;\n+                match m.inner {\n+                    clean::MethodItem(ref inner) if !inner.generics.where_predicates.is_empty() => {\n+                        write!(w, \",\\n    {{ ... }}\\n\")?;\n+                    },\n+                    _ => {\n+                        write!(w, \" {{ ... }}\\n\")?;\n+                    },\n+                }\n+                if pos < provided.len() - 1 {\n+                   write!(w, \"<div class='item-spacer'></div>\")?;\n+                }\n+            }\n+            write!(w, \"}}\")?;\n         }\n-        write!(w, \"}}\")?;\n-    }\n-    write!(w, \"</pre>\")?;\n+        write!(w, \"</pre>\")\n+    })?;\n \n     // Trait documentation\n     document(w, cx, it)?;\n@@ -2717,16 +2724,18 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n \n fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                s: &clean::Struct) -> fmt::Result {\n-    write!(w, \"<pre class='rust struct'>\")?;\n-    render_attributes(w, it)?;\n-    render_struct(w,\n-                  it,\n-                  Some(&s.generics),\n-                  s.struct_type,\n-                  &s.fields,\n-                  \"\",\n-                  true)?;\n-    write!(w, \"</pre>\")?;\n+    wrap_into_docblock(w, |w| {\n+        write!(w, \"<pre class='rust struct'>\")?;\n+        render_attributes(w, it)?;\n+        render_struct(w,\n+                      it,\n+                      Some(&s.generics),\n+                      s.struct_type,\n+                      &s.fields,\n+                      \"\",\n+                      true)?;\n+        write!(w, \"</pre>\")\n+    })?;\n \n     document(w, cx, it)?;\n     let mut fields = s.fields.iter().filter_map(|f| {\n@@ -2769,15 +2778,17 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                s: &clean::Union) -> fmt::Result {\n-    write!(w, \"<pre class='rust union'>\")?;\n-    render_attributes(w, it)?;\n-    render_union(w,\n-                 it,\n-                 Some(&s.generics),\n-                 &s.fields,\n-                 \"\",\n-                 true)?;\n-    write!(w, \"</pre>\")?;\n+    wrap_into_docblock(w, |w| {\n+        write!(w, \"<pre class='rust union'>\")?;\n+        render_attributes(w, it)?;\n+        render_union(w,\n+                     it,\n+                     Some(&s.generics),\n+                     &s.fields,\n+                     \"\",\n+                     true)?;\n+        write!(w, \"</pre>\")\n+    })?;\n \n     document(w, cx, it)?;\n     let mut fields = s.fields.iter().filter_map(|f| {\n@@ -2807,56 +2818,58 @@ fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n-    write!(w, \"<pre class='rust enum'>\")?;\n-    render_attributes(w, it)?;\n-    write!(w, \"{}enum {}{}{}\",\n-           VisSpace(&it.visibility),\n-           it.name.as_ref().unwrap(),\n-           e.generics,\n-           WhereClause { gens: &e.generics, indent: 0, end_newline: true })?;\n-    if e.variants.is_empty() && !e.variants_stripped {\n-        write!(w, \" {{}}\")?;\n-    } else {\n-        write!(w, \" {{\\n\")?;\n-        for v in &e.variants {\n-            write!(w, \"    \")?;\n-            let name = v.name.as_ref().unwrap();\n-            match v.inner {\n-                clean::VariantItem(ref var) => {\n-                    match var.kind {\n-                        clean::VariantKind::CLike => write!(w, \"{}\", name)?,\n-                        clean::VariantKind::Tuple(ref tys) => {\n-                            write!(w, \"{}(\", name)?;\n-                            for (i, ty) in tys.iter().enumerate() {\n-                                if i > 0 {\n-                                    write!(w, \",&nbsp;\")?\n+    wrap_into_docblock(w, |w| {\n+        write!(w, \"<pre class='rust enum'>\")?;\n+        render_attributes(w, it)?;\n+        write!(w, \"{}enum {}{}{}\",\n+               VisSpace(&it.visibility),\n+               it.name.as_ref().unwrap(),\n+               e.generics,\n+               WhereClause { gens: &e.generics, indent: 0, end_newline: true })?;\n+        if e.variants.is_empty() && !e.variants_stripped {\n+            write!(w, \" {{}}\")?;\n+        } else {\n+            write!(w, \" {{\\n\")?;\n+            for v in &e.variants {\n+                write!(w, \"    \")?;\n+                let name = v.name.as_ref().unwrap();\n+                match v.inner {\n+                    clean::VariantItem(ref var) => {\n+                        match var.kind {\n+                            clean::VariantKind::CLike => write!(w, \"{}\", name)?,\n+                            clean::VariantKind::Tuple(ref tys) => {\n+                                write!(w, \"{}(\", name)?;\n+                                for (i, ty) in tys.iter().enumerate() {\n+                                    if i > 0 {\n+                                        write!(w, \",&nbsp;\")?\n+                                    }\n+                                    write!(w, \"{}\", *ty)?;\n                                 }\n-                                write!(w, \"{}\", *ty)?;\n+                                write!(w, \")\")?;\n+                            }\n+                            clean::VariantKind::Struct(ref s) => {\n+                                render_struct(w,\n+                                              v,\n+                                              None,\n+                                              s.struct_type,\n+                                              &s.fields,\n+                                              \"    \",\n+                                              false)?;\n                             }\n-                            write!(w, \")\")?;\n-                        }\n-                        clean::VariantKind::Struct(ref s) => {\n-                            render_struct(w,\n-                                          v,\n-                                          None,\n-                                          s.struct_type,\n-                                          &s.fields,\n-                                          \"    \",\n-                                          false)?;\n                         }\n                     }\n+                    _ => unreachable!()\n                 }\n-                _ => unreachable!()\n+                write!(w, \",\\n\")?;\n             }\n-            write!(w, \",\\n\")?;\n-        }\n \n-        if e.variants_stripped {\n-            write!(w, \"    // some variants omitted\\n\")?;\n+            if e.variants_stripped {\n+                write!(w, \"    // some variants omitted\\n\")?;\n+            }\n+            write!(w, \"}}\")?;\n         }\n-        write!(w, \"}}\")?;\n-    }\n-    write!(w, \"</pre>\")?;\n+        write!(w, \"</pre>\")\n+    })?;\n \n     document(w, cx, it)?;\n     if !e.variants.is_empty() {\n@@ -4043,11 +4056,13 @@ impl<'a> fmt::Display for Source<'a> {\n \n fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n-    w.write_str(&highlight::render_with_highlighting(&t.source,\n-                                                     Some(\"macro\"),\n-                                                     None,\n-                                                     None,\n-                                                     None))?;\n+    wrap_into_docblock(w, |w| {\n+        w.write_str(&highlight::render_with_highlighting(&t.source,\n+                                                         Some(\"macro\"),\n+                                                         None,\n+                                                         None,\n+                                                         None))\n+    })?;\n     document(w, cx, it)\n }\n "}, {"sha": "121e35dc70298387dc41bf7a4022497e503abd7b", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/73b97c7e7c9cfac4dfa4804654b1db6ab687b589/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/73b97c7e7c9cfac4dfa4804654b1db6ab687b589/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=73b97c7e7c9cfac4dfa4804654b1db6ab687b589", "patch": "@@ -1833,11 +1833,16 @@\n         onEach(e.getElementsByClassName('associatedconstant'), func);\n     });\n \n-    function createToggle() {\n+    function createToggle(otherMessage) {\n         var span = document.createElement('span');\n         span.className = 'toggle-label';\n         span.style.display = 'none';\n-        span.innerHTML = '&nbsp;Expand&nbsp;description';\n+        if (!otherMessage) {\n+            span.innerHTML = '&nbsp;Expand&nbsp;description';\n+        } else {\n+            span.innerHTML = otherMessage;\n+            span.style.fontSize = '20px';\n+        }\n \n         var mainToggle = toggle.cloneNode(true);\n         mainToggle.appendChild(span);\n@@ -1850,7 +1855,14 @@\n \n     onEach(document.getElementById('main').getElementsByClassName('docblock'), function(e) {\n         if (e.parentNode.id === \"main\") {\n-            e.parentNode.insertBefore(createToggle(), e);\n+            var otherMessage;\n+            if (hasClass(e, \"type-decl\")) {\n+                otherMessage = '&nbsp;Show&nbsp;type&nbsp;declaration';\n+            }\n+            e.parentNode.insertBefore(createToggle(otherMessage), e);\n+            if (otherMessage) {\n+                collapseDocs(e.previousSibling.childNodes[0], \"toggle\");\n+            }\n         }\n     });\n "}]}