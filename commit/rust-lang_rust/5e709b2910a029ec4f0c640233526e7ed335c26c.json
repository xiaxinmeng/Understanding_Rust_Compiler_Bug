{"sha": "5e709b2910a029ec4f0c640233526e7ed335c26c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNzA5YjI5MTBhMDI5ZWM0ZjBjNjQwMjMzNTI2ZTdlZDMzNWMyNmM=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-04-30T22:17:58Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-04-30T22:17:58Z"}, "message": "Refactor is_range_literal", "tree": {"sha": "a1c9408db292557e494a6e6c5fd041361a05e1b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1c9408db292557e494a6e6c5fd041361a05e1b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e709b2910a029ec4f0c640233526e7ed335c26c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e709b2910a029ec4f0c640233526e7ed335c26c", "html_url": "https://github.com/rust-lang/rust/commit/5e709b2910a029ec4f0c640233526e7ed335c26c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e709b2910a029ec4f0c640233526e7ed335c26c/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13962aff37bbe23e1c9063e2298318e1a9da8af2", "url": "https://api.github.com/repos/rust-lang/rust/commits/13962aff37bbe23e1c9063e2298318e1a9da8af2", "html_url": "https://github.com/rust-lang/rust/commit/13962aff37bbe23e1c9063e2298318e1a9da8af2"}], "stats": {"total": 41, "additions": 18, "deletions": 23}, "files": [{"sha": "736736fe48b1b0db53908e63cb34753caa0fe826", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5e709b2910a029ec4f0c640233526e7ed335c26c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e709b2910a029ec4f0c640233526e7ed335c26c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5e709b2910a029ec4f0c640233526e7ed335c26c", "patch": "@@ -5401,29 +5401,29 @@ fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body>) -> Vec<hir::BodyId> {\n     body_ids\n }\n \n-/// This function checks if the specified expression is a built-in range literal.\n+/// Checks if the specified expression is a built-in range literal.\n /// (See: `LoweringContext::lower_expr()`).\n pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n     use hir::{Path, QPath, ExprKind, TyKind};\n \n-    // We support `::std::ops::Range` and `::core::ops::Range` prefixes.\n-    let is_range_path = |path: &Path| {\n-        let mut segs = path.segments.iter().map(|seg| seg.ident.as_str());\n+    // Returns whether the given path represents a (desugared) range,\n+    // either in std or core, i.e. has either a `::std::ops::Range` or\n+    // `::core::ops::Range` prefix.\n+    fn is_range_path(path: &Path) -> bool {\n+        let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.as_str().to_string()).collect();\n+        let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n \n-        if let (Some(root), Some(std_core), Some(ops), Some(range), None) =\n-            (segs.next(), segs.next(), segs.next(), segs.next(), segs.next())\n-        {\n-            // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n-            root == \"{{root}}\" && (std_core == \"std\" || std_core == \"core\")\n-                && ops == \"ops\" && range.starts_with(\"Range\")\n+        // \"{{root}}\" is the equivalent of `::` prefix in `Path`.\n+        if let [\"{{root}}\", std_core, \"ops\", range] = segs.as_slice() {\n+            (*std_core == \"std\" || *std_core == \"core\") && range.starts_with(\"Range\")\n         } else {\n             false\n         }\n     };\n \n-    let span_is_range_literal = |span: &Span| {\n-        // Check whether a span corresponding to a range expression\n-        // is a range literal, rather than an explicit struct or `new()` call.\n+    // Check whether a span corresponding to a range expression is a\n+    // range literal, rather than an explicit struct or `new()` call.\n+    fn is_range_literal(sess: &Session, span: &Span) -> bool {\n         let source_map = sess.source_map();\n         let end_point = source_map.end_point(*span);\n \n@@ -5438,21 +5438,21 @@ pub fn is_range_literal(sess: &Session, expr: &hir::Expr) -> bool {\n         // All built-in range literals but `..=` and `..` desugar to `Struct`s.\n         ExprKind::Struct(ref qpath, _, _) => {\n             if let QPath::Resolved(None, ref path) = **qpath {\n-                return is_range_path(&path) && span_is_range_literal(&expr.span);\n+                return is_range_path(&path) && is_range_literal(sess, &expr.span);\n             }\n         }\n \n         // `..` desugars to its struct path.\n         ExprKind::Path(QPath::Resolved(None, ref path)) => {\n-            return is_range_path(&path) && span_is_range_literal(&expr.span);\n+            return is_range_path(&path) && is_range_literal(sess, &expr.span);\n         }\n \n         // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n         ExprKind::Call(ref func, _) => {\n             if let ExprKind::Path(QPath::TypeRelative(ref ty, ref segment)) = func.node {\n                 if let TyKind::Path(QPath::Resolved(None, ref path)) = ty.node {\n-                    let call_to_new = segment.ident.as_str() == \"new\";\n-                    return is_range_path(&path) && span_is_range_literal(&expr.span) && call_to_new;\n+                    let new_call = segment.ident.as_str() == \"new\";\n+                    return is_range_path(&path) && is_range_literal(sess, &expr.span) && new_call;\n                 }\n             }\n         }"}, {"sha": "5cafd3d676f3faa6c10da25f0c9b79edf192971a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e709b2910a029ec4f0c640233526e7ed335c26c/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e709b2910a029ec4f0c640233526e7ed335c26c/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=5e709b2910a029ec4f0c640233526e7ed335c26c", "patch": "@@ -92,12 +92,7 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n                     LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_owned(),\n                     _ => bug!(),\n                 };\n-                let suggestion = format!(\n-                    \"{}..={}{}\",\n-                    start,\n-                    lit_val - 1,\n-                    suffix,\n-                );\n+                let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n                 err.span_suggestion(\n                     parent_expr.span,\n                     &\"use an inclusive range instead\","}]}