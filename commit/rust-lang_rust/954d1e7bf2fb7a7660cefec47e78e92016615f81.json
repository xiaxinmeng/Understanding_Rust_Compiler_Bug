{"sha": "954d1e7bf2fb7a7660cefec47e78e92016615f81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NGQxZTdiZjJmYjdhNzY2MGNlZmVjNDdlNzhlOTIwMTY2MTVmODE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-18T15:10:02Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-22T08:54:32Z"}, "message": "Don't hardcode usize being 64 bit (fixes #8)", "tree": {"sha": "8c20c1ddfc2147b731fd7f6cdb4acceb4f12a143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c20c1ddfc2147b731fd7f6cdb4acceb4f12a143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/954d1e7bf2fb7a7660cefec47e78e92016615f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/954d1e7bf2fb7a7660cefec47e78e92016615f81", "html_url": "https://github.com/rust-lang/rust/commit/954d1e7bf2fb7a7660cefec47e78e92016615f81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/954d1e7bf2fb7a7660cefec47e78e92016615f81/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a1c86473c7e5d6437398e683ed2adcad164b535", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a1c86473c7e5d6437398e683ed2adcad164b535", "html_url": "https://github.com/rust-lang/rust/commit/8a1c86473c7e5d6437398e683ed2adcad164b535"}], "stats": {"total": 75, "additions": 43, "deletions": 32}, "files": [{"sha": "0b2b1807099ac17f8db89b1f167d36e742b2c1ec", "filename": "src/abi.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/954d1e7bf2fb7a7660cefec47e78e92016615f81/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/954d1e7bf2fb7a7660cefec47e78e92016615f81/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=954d1e7bf2fb7a7660cefec47e78e92016615f81", "patch": "@@ -13,11 +13,11 @@ enum PassMode {\n }\n \n impl PassMode {\n-    fn get_param_ty(self, _fx: &FunctionCx<impl Backend>) -> Type {\n+    fn get_param_ty(self, fx: &FunctionCx<impl Backend>) -> Type {\n         match self {\n             PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n             PassMode::ByVal(cton_type) => cton_type,\n-            PassMode::ByRef => types::I64,\n+            PassMode::ByRef => fx.module.pointer_type(),\n         }\n     }\n }\n@@ -74,7 +74,7 @@ pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(\n         .filter_map(|ty| match get_pass_mode(tcx, sig.abi, ty, false) {\n             PassMode::ByVal(cton_ty) => Some(cton_ty),\n             PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n-            PassMode::ByRef => Some(types::I64),\n+            PassMode::ByRef => Some(pointer_ty(tcx)),\n         });\n \n     let (params, returns) = match get_pass_mode(tcx, sig.abi, output, true) {\n@@ -85,7 +85,7 @@ pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(\n         ),\n         PassMode::ByRef => {\n             (\n-                Some(types::I64).into_iter() // First param is place to put return val\n+                Some(pointer_ty(tcx)).into_iter() // First param is place to put return val\n                     .chain(inputs)\n                     .map(AbiParam::new)\n                     .collect(),\n@@ -224,7 +224,7 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n         if let Some(val) = self.lib_call(name, input_tys, return_ty, &args) {\n             CValue::ByVal(val, return_layout)\n         } else {\n-            CValue::ByRef(self.bcx.ins().iconst(types::I64, 0), return_layout)\n+            CValue::ByRef(self.bcx.ins().iconst(self.module.pointer_type(), 0), return_layout)\n         }\n     }\n \n@@ -253,7 +253,7 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n     let ret_param = match output_pass_mode {\n         PassMode::NoPass => None,\n         PassMode::ByVal(_) => None,\n-        PassMode::ByRef => Some(fx.bcx.append_ebb_param(start_ebb, types::I64)),\n+        PassMode::ByRef => Some(fx.bcx.append_ebb_param(start_ebb, fx.module.pointer_type())),\n     };\n \n     enum ArgKind {\n@@ -305,7 +305,7 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n \n     match output_pass_mode {\n         PassMode::NoPass => {\n-            let null = fx.bcx.ins().iconst(types::I64, 0);\n+            let null = fx.bcx.ins().iconst(fx.module.pointer_type(), 0);\n             //unimplemented!(\"pass mode nopass\");\n             fx.local_map.insert(\n                 RETURN_PLACE,\n@@ -457,7 +457,7 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n         PassMode::NoPass => None,\n         PassMode::ByRef => match destination {\n             Some((place, _)) => Some(place.expect_addr()),\n-            None => Some(fx.bcx.ins().iconst(types::I64, 0)),\n+            None => Some(fx.bcx.ins().iconst(fx.module.pointer_type(), 0)),\n         },\n         PassMode::ByVal(_) => None,\n     };\n@@ -570,7 +570,7 @@ fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 \"copy\" | \"copy_nonoverlapping\" => {\n                     let elem_ty = substs.type_at(0);\n                     let elem_size: u64 = fx.layout_of(elem_ty).size.bytes();\n-                    let elem_size = fx.bcx.ins().iconst(types::I64, elem_size as i64);\n+                    let elem_size = fx.bcx.ins().iconst(fx.module.pointer_type(), elem_size as i64);\n                     assert_eq!(args.len(), 3);\n                     let src = args[0];\n                     let dst = args[1];"}, {"sha": "9880d39afc7e5591542c37a6df4aeeeb24d098da", "filename": "src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/954d1e7bf2fb7a7660cefec47e78e92016615f81/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/954d1e7bf2fb7a7660cefec47e78e92016615f81/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=954d1e7bf2fb7a7660cefec47e78e92016615f81", "patch": "@@ -477,7 +477,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                 Rvalue::Repeat(operand, times) => {\n                     let operand = trans_operand(fx, operand);\n                     for i in 0..*times {\n-                        let index = fx.bcx.ins().iconst(types::I64, i as i64);\n+                        let index = fx.bcx.ins().iconst(fx.module.pointer_type(), i as i64);\n                         let to = lval.place_index(fx, index);\n                         to.write_cvalue(fx, operand);\n                     }\n@@ -498,7 +498,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     AggregateKind::Array(_ty) => {\n                         for (i, operand) in operands.into_iter().enumerate() {\n                             let operand = trans_operand(fx, operand);\n-                            let index = fx.bcx.ins().iconst(types::I64, i as i64);\n+                            let index = fx.bcx.ins().iconst(fx.module.pointer_type(), i as i64);\n                             let to = lval.place_index(fx, index);\n                             to.write_cvalue(fx, operand);\n                         }"}, {"sha": "6c537d72f9b1c3ef8eab9acc096fb71d3bd44957", "filename": "src/common.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/954d1e7bf2fb7a7660cefec47e78e92016615f81/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/954d1e7bf2fb7a7660cefec47e78e92016615f81/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=954d1e7bf2fb7a7660cefec47e78e92016615f81", "patch": "@@ -10,6 +10,15 @@ pub fn mir_var(loc: Local) -> Variable {\n     Variable::with_u32(loc.index() as u32)\n }\n \n+pub fn pointer_ty(tcx: TyCtxt) -> types::Type {\n+    match tcx.data_layout.pointer_size.bits() {\n+        16 => types::I16,\n+        32 => types::I32,\n+        64 => types::I64,\n+        bits => bug!(\"ptr_sized_integer: unknown pointer bit size {}\", bits),\n+    }\n+}\n+\n pub fn cton_type_from_ty<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>,\n@@ -22,25 +31,25 @@ pub fn cton_type_from_ty<'a, 'tcx: 'a>(\n             UintTy::U32 => types::I32,\n             UintTy::U64 => types::I64,\n             UintTy::U128 => unimpl!(\"u128\"),\n-            UintTy::Usize => types::I64,\n+            UintTy::Usize => pointer_ty(tcx),\n         },\n         TypeVariants::TyInt(size) => match size {\n             IntTy::I8 => types::I8,\n             IntTy::I16 => types::I16,\n             IntTy::I32 => types::I32,\n             IntTy::I64 => types::I64,\n             IntTy::I128 => unimpl!(\"i128\"),\n-            IntTy::Isize => types::I64,\n+            IntTy::Isize => pointer_ty(tcx)\n         },\n         TypeVariants::TyChar => types::I32,\n         TypeVariants::TyFloat(size) => match size {\n             FloatTy::F32 => types::F32,\n             FloatTy::F64 => types::F64,\n         },\n-        TypeVariants::TyFnPtr(_) => types::I64,\n+        TypeVariants::TyFnPtr(_) => pointer_ty(tcx),\n         TypeVariants::TyRawPtr(TypeAndMut { ty, mutbl: _ }) | TypeVariants::TyRef(_, ty, _) => {\n             if ty.is_sized(tcx.at(DUMMY_SP), ParamEnv::reveal_all()) {\n-                types::I64\n+                pointer_ty(tcx)\n             } else {\n                 return None;\n             }\n@@ -59,7 +68,7 @@ fn codegen_field<'a, 'tcx: 'a>(\n     let field_offset = layout.fields.offset(field.index());\n     let field_ty = layout.field(&*fx, field.index());\n     if field_offset.bytes() > 0 {\n-        let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n+        let field_offset = fx.bcx.ins().iconst(fx.module.pointer_type(), field_offset.bytes() as i64);\n         (fx.bcx.ins().iadd(base, field_offset), field_ty)\n     } else {\n         (base, field_ty)\n@@ -93,7 +102,7 @@ impl<'tcx> CValue<'tcx> {\n                     offset: None,\n                 });\n                 fx.bcx.ins().stack_store(value, stack_slot, 0);\n-                fx.bcx.ins().stack_addr(types::I64, stack_slot, 0)\n+                fx.bcx.ins().stack_addr(fx.module.pointer_type(), stack_slot, 0)\n             }\n         }\n     }\n@@ -179,7 +188,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n             size: layout.size.bytes() as u32,\n             offset: None,\n         });\n-        CPlace::Addr(fx.bcx.ins().stack_addr(types::I64, stack_slot, 0), layout)\n+        CPlace::Addr(fx.bcx.ins().stack_addr(fx.module.pointer_type(), stack_slot, 0), layout)\n     }\n \n     pub fn from_stack_slot(\n@@ -188,7 +197,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> CPlace<'tcx> {\n         let layout = fx.layout_of(ty);\n-        CPlace::Addr(fx.bcx.ins().stack_addr(types::I64, stack_slot, 0), layout)\n+        CPlace::Addr(fx.bcx.ins().stack_addr(fx.module.pointer_type(), stack_slot, 0), layout)\n     }\n \n     pub fn to_cvalue(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> CValue<'tcx> {\n@@ -249,7 +258,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n                         let byte = fx\n                             .bcx\n                             .ins()\n-                            .load(types::I64, MemFlags::new(), from.0, offset);\n+                            .load(fx.module.pointer_type(), MemFlags::new(), from.0, offset);\n                         fx.bcx.ins().store(MemFlags::new(), byte, addr, offset);\n                         offset += 8;\n                     }\n@@ -299,7 +308,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n                 let size = fx\n                     .bcx\n                     .ins()\n-                    .iconst(types::I64, elem_layout.size.bytes() as i64);\n+                    .iconst(fx.module.pointer_type(), elem_layout.size.bytes() as i64);\n                 let offset = fx.bcx.ins().imul(size, index);\n                 CPlace::Addr(fx.bcx.ins().iadd(addr, offset), elem_layout)\n             }"}, {"sha": "5d7971bc23545bba7bcf686e616da3cc67410217", "filename": "src/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/954d1e7bf2fb7a7660cefec47e78e92016615f81/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/954d1e7bf2fb7a7660cefec47e78e92016615f81/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=954d1e7bf2fb7a7660cefec47e78e92016615f81", "patch": "@@ -109,7 +109,7 @@ fn trans_const_value<'a, 'tcx: 'a>(\n             let func_ref = fx.get_function_ref(\n                 Instance::resolve(fx.tcx, ParamEnv::reveal_all(), def_id, substs).unwrap(),\n             );\n-            let func_addr = fx.bcx.ins().func_addr(types::I64, func_ref);\n+            let func_addr = fx.bcx.ins().func_addr(fx.module.pointer_type(), func_ref);\n             CValue::ByVal(func_addr, layout)\n         }\n         _ => trans_const_place(fx, const_).to_cvalue(fx),\n@@ -152,7 +152,7 @@ fn cplace_for_dataid<'a, 'tcx: 'a>(\n     data_id: DataId,\n ) -> CPlace<'tcx> {\n     let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    let global_ptr = fx.bcx.ins().global_value(types::I64, local_data_id);\n+    let global_ptr = fx.bcx.ins().global_value(fx.module.pointer_type(), local_data_id);\n     let layout = fx.layout_of(fx.monomorphize(&ty));\n     CPlace::Addr(global_ptr, layout)\n }"}, {"sha": "d40c820a4f7d5bb0f802d3115095b02e618155d1", "filename": "src/lib.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/954d1e7bf2fb7a7660cefec47e78e92016615f81/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/954d1e7bf2fb7a7660cefec47e78e92016615f81/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=954d1e7bf2fb7a7660cefec47e78e92016615f81", "patch": "@@ -228,6 +228,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n \n         if std::env::var(\"SHOULD_RUN\").is_ok() {\n             let mut jit_module: Module<SimpleJITBackend> = Module::new(SimpleJITBuilder::new());\n+            assert_eq!(pointer_ty(tcx), jit_module.pointer_type());\n \n             codegen_mono_items(tcx, &mut jit_module, &mono_items);\n \n@@ -238,10 +239,10 @@ impl CodegenBackend for CraneliftCodegenBackend {\n \n             let sig = Signature {\n                 params: vec![\n-                    AbiParam::new(types::I64 /*usize*/),\n-                    AbiParam::new(types::I64 /* *const _*/),\n+                    AbiParam::new(jit_module.pointer_type()),\n+                    AbiParam::new(jit_module.pointer_type()),\n                 ],\n-                returns: vec![AbiParam::new(types::I64 /*isize*/)],\n+                returns: vec![AbiParam::new(jit_module.pointer_type() /*isize*/)],\n                 call_conv: CallConv::SystemV,\n                 argument_bytes: None,\n             };\n@@ -269,6 +270,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n                     FaerieBuilder::default_libcall_names(),\n                 ).unwrap(),\n             );\n+            assert_eq!(pointer_ty(tcx), faerie_module.pointer_type());\n \n             codegen_mono_items(tcx, &mut faerie_module, &mono_items);\n \n@@ -443,10 +445,10 @@ fn maybe_create_entry_wrapper(cx: &mut CodegenCx<impl Backend + 'static>) {\n \n         let cmain_sig = Signature {\n             params: vec![\n-                AbiParam::new(types::I64 /*usize*/),\n-                AbiParam::new(types::I64 /* *const _*/),\n+                AbiParam::new(m.pointer_type()),\n+                AbiParam::new(m.pointer_type()),\n             ],\n-            returns: vec![AbiParam::new(types::I64 /*isize*/)],\n+            returns: vec![AbiParam::new(m.pointer_type() /*isize*/)],\n             call_conv: CallConv::SystemV,\n             argument_bytes: None,\n         };\n@@ -471,8 +473,8 @@ fn maybe_create_entry_wrapper(cx: &mut CodegenCx<impl Backend + 'static>) {\n \n             let ebb = bcx.create_ebb();\n             bcx.switch_to_block(ebb);\n-            let arg_argc = bcx.append_ebb_param(ebb, types::I64 /*usize*/);\n-            let arg_argv = bcx.append_ebb_param(ebb, types::I64 /* *const _*/);\n+            let arg_argc = bcx.append_ebb_param(ebb, m.pointer_type());\n+            let arg_argv = bcx.append_ebb_param(ebb, m.pointer_type());\n \n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n@@ -490,7 +492,7 @@ fn maybe_create_entry_wrapper(cx: &mut CodegenCx<impl Backend + 'static>) {\n                     .declare_function(&start_name, Linkage::Import, &start_sig)\n                     .unwrap();\n \n-                let main_val = bcx.ins().func_addr(types::I64, main_func_ref);\n+                let main_val = bcx.ins().func_addr(m.pointer_type(), main_func_ref);\n \n                 let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n                 bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv])"}]}