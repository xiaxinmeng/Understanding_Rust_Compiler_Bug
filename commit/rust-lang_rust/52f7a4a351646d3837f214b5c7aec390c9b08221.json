{"sha": "52f7a4a351646d3837f214b5c7aec390c9b08221", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyZjdhNGEzNTE2NDZkMzgzN2YyMTRiNWM3YWVjMzkwYzliMDgyMjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-14T11:37:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-14T11:37:27Z"}, "message": "auto merge of #19338 : nikomatsakis/rust/unboxed-closure-purge-the-proc, r=acrichto\n\nThey are replaced with unboxed closures.\r\n\r\ncc @pcwalton @aturon \r\n\r\nThis is a [breaking-change]. Mostly, uses of `proc()` simply need to be converted to `move||` (unboxed closures), but in some cases the adaptations required are more complex (particularly for library authors). A detailed write-up can be found here: http://smallcultfollowing.com/babysteps/blog/2014/11/26/purging-proc/\r\n\r\nThe commits are ordered to emphasize the more important changes, but are not truly standalone.", "tree": {"sha": "f1d12edf0aa7adbb96bf09ea6cc56411898c949c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1d12edf0aa7adbb96bf09ea6cc56411898c949c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52f7a4a351646d3837f214b5c7aec390c9b08221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52f7a4a351646d3837f214b5c7aec390c9b08221", "html_url": "https://github.com/rust-lang/rust/commit/52f7a4a351646d3837f214b5c7aec390c9b08221", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52f7a4a351646d3837f214b5c7aec390c9b08221/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a9305ce823df267fb1afcce76ef06ca09e407ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a9305ce823df267fb1afcce76ef06ca09e407ff", "html_url": "https://github.com/rust-lang/rust/commit/3a9305ce823df267fb1afcce76ef06ca09e407ff"}, {"sha": "f6d60f32080314f1167dd3efb13d772528f500f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d60f32080314f1167dd3efb13d772528f500f0", "html_url": "https://github.com/rust-lang/rust/commit/f6d60f32080314f1167dd3efb13d772528f500f0"}], "stats": {"total": 2941, "additions": 1259, "deletions": 1682}, "files": [{"sha": "196c38215f463e3a865b9e8ee2bc4274b5a60f60", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_type = \"bin\"]\n-#![feature(phase, slicing_syntax, globs)]\n+#![feature(phase, slicing_syntax, globs, unboxed_closures)]\n \n #![deny(warnings)]\n \n@@ -23,6 +23,7 @@ use std::os;\n use std::io;\n use std::io::fs;\n use std::str::FromStr;\n+use std::thunk::{Thunk};\n use getopts::{optopt, optflag, reqopt};\n use common::Config;\n use common::{Pretty, DebugInfoGdb, DebugInfoLldb, Codegen};\n@@ -369,16 +370,16 @@ pub fn make_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let testfile = testfile.as_str().unwrap().to_string();\n-    test::DynTestFn(proc() {\n+    test::DynTestFn(Thunk::new(move || {\n         runtest::run(config, testfile)\n-    })\n+    }))\n }\n \n pub fn make_metrics_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let testfile = testfile.as_str().unwrap().to_string();\n-    test::DynMetricFn(proc(mm) {\n+    test::DynMetricFn(box move |: mm: &mut test::MetricMap| {\n         runtest::run_metrics(config, testfile, mm)\n     })\n }"}, {"sha": "ea6f180ec39acbff6bcfca3cd8b24bd47d2c3430", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -445,7 +445,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(Duration::milliseconds(1000));\n-                let result = task::try(proc() {\n+                let result = task::try(move || {\n                     tcp::TcpStream::connect(\"127.0.0.1:5039\").unwrap();\n                 });\n                 if result.is_err() {"}, {"sha": "4adca43be18e946baa973d260903aedad5af58a3", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -29,31 +29,37 @@ with a closure argument. `spawn` executes the closure in the new task.\n fn print_message() { println!(\"I am running in a different task!\"); }\n spawn(print_message);\n \n-// Alternatively, use a `proc` expression instead of a named function.\n-// The `proc` expression evaluates to an (unnamed) proc.\n-// That proc will call `println!(...)` when the spawned task runs.\n-spawn(proc() println!(\"I am also running in a different task!\") );\n+// Alternatively, use a `move ||` expression instead of a named function.\n+// `||` expressions evaluate to an unnamed closure. The `move` keyword\n+// indicates that the closure should take ownership of any variables it\n+// touches.\n+spawn(move || println!(\"I am also running in a different task!\"));\n ```\n \n In Rust, a task is not a concept that appears in the language semantics.\n Instead, Rust's type system provides all the tools necessary to implement safe\n concurrency: particularly, ownership. The language leaves the implementation\n details to the standard library.\n \n-The `spawn` function has a very simple type signature: `fn spawn(f: proc():\n-Send)`. Because it accepts only procs, and procs contain only owned data,\n-`spawn` can safely move the entire proc and all its associated state into an\n-entirely different task for execution. Like any closure, the function passed to\n-`spawn` may capture an environment that it carries across tasks.\n+The `spawn` function has the type signature: `fn\n+spawn<F:FnOnce()+Send>(f: F)`.  This indicates that it takes as\n+argument a closure (of type `F`) that it will run exactly once. This\n+closure is limited to capturing `Send`-able data from its environment\n+(that is, data which is deeply owned). Limiting the closure to `Send`\n+ensures that `spawn` can safely move the entire closure and all its\n+associated state into an entirely different task for execution.\n \n ```{rust}\n # use std::task::spawn;\n # fn generate_task_number() -> int { 0 }\n // Generate some state locally\n let child_task_number = generate_task_number();\n \n-spawn(proc() {\n-    // Capture it in the remote task\n+spawn(move || {\n+    // Capture it in the remote task. The `move` keyword indicates\n+    // that this closure should move `child_task_number` into its\n+    // environment, rather than capturing a reference into the\n+    // enclosing stack frame.\n     println!(\"I am child number {}\", child_task_number);\n });\n ```\n@@ -74,7 +80,7 @@ example of calculating two results concurrently:\n \n let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n \n-spawn(proc() {\n+spawn(move || {\n     let result = some_expensive_computation();\n     tx.send(result);\n });\n@@ -102,7 +108,7 @@ task.\n # use std::task::spawn;\n # fn some_expensive_computation() -> int { 42 }\n # let (tx, rx) = channel();\n-spawn(proc() {\n+spawn(move || {\n     let result = some_expensive_computation();\n     tx.send(result);\n });\n@@ -135,13 +141,13 @@ results across a number of tasks? The following program is ill-typed:\n # fn some_expensive_computation() -> int { 42 }\n let (tx, rx) = channel();\n \n-spawn(proc() {\n+spawn(move || {\n     tx.send(some_expensive_computation());\n });\n \n // ERROR! The previous spawn statement already owns the sender,\n // so the compiler will not allow it to be captured again\n-spawn(proc() {\n+spawn(move || {\n     tx.send(some_expensive_computation());\n });\n ```\n@@ -154,7 +160,7 @@ let (tx, rx) = channel();\n for init_val in range(0u, 3) {\n     // Create a new channel handle to distribute to the child task\n     let child_tx = tx.clone();\n-    spawn(proc() {\n+    spawn(move || {\n         child_tx.send(some_expensive_computation(init_val));\n     });\n }\n@@ -179,7 +185,7 @@ reference, written with multiple streams, it might look like the example below.\n // Create a vector of ports, one for each child task\n let rxs = Vec::from_fn(3, |init_val| {\n     let (tx, rx) = channel();\n-    spawn(proc() {\n+    spawn(move || {\n         tx.send(some_expensive_computation(init_val));\n     });\n     rx\n@@ -207,7 +213,7 @@ fn fib(n: u64) -> u64 {\n     12586269025\n }\n \n-let mut delayed_fib = Future::spawn(proc() fib(50));\n+let mut delayed_fib = Future::spawn(move || fib(50));\n make_a_sandwich();\n println!(\"fib(50) = {}\", delayed_fib.get())\n # }\n@@ -236,7 +242,7 @@ fn partial_sum(start: uint) -> f64 {\n }\n \n fn main() {\n-    let mut futures = Vec::from_fn(200, |ind| Future::spawn( proc() { partial_sum(ind) }));\n+    let mut futures = Vec::from_fn(200, |ind| Future::spawn(move || partial_sum(ind)));\n \n     let mut final_res = 0f64;\n     for ft in futures.iter_mut()  {\n@@ -278,7 +284,7 @@ fn main() {\n     for num in range(1u, 10) {\n         let task_numbers = numbers_arc.clone();\n \n-        spawn(proc() {\n+        spawn(move || {\n             println!(\"{}-norm = {}\", num, pnorm(task_numbers.as_slice(), num));\n         });\n     }\n@@ -312,7 +318,7 @@ if it were local.\n # let numbers_arc = Arc::new(numbers);\n # let num = 4;\n let task_numbers = numbers_arc.clone();\n-spawn(proc() {\n+spawn(move || {\n     // Capture task_numbers and use it as if it was the underlying vector\n     println!(\"{}-norm = {}\", num, pnorm(task_numbers.as_slice(), num));\n });\n@@ -344,7 +350,7 @@ result with an `int` field (representing a successful result) or an `Err` result\n # use std::task;\n # fn some_condition() -> bool { false }\n # fn calculate_result() -> int { 0 }\n-let result: Result<int, Box<std::any::Any + Send>> = task::try(proc() {\n+let result: Result<int, Box<std::any::Any + Send>> = task::try(move || {\n     if some_condition() {\n         calculate_result()\n     } else {"}, {"sha": "6e178a2648dbfb1ab20c2bb1db9c56b2c553a266", "filename": "src/doc/guide.md", "status": "modified", "additions": 34, "deletions": 51, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -4235,36 +4235,16 @@ fn main() {\n }\n ```\n \n-## Procs\n+## Moving closures\n \n-Rust has a second type of closure, called a **proc**. Procs are created\n-with the `proc` keyword:\n-\n-```{rust}\n-let x = 5i;\n-\n-let p = proc() { x * x };\n-println!(\"{}\", p()); // prints 25\n-```\n-\n-There is a big difference between procs and closures: procs may only be called once. This\n-will error when we try to compile:\n-\n-```{rust,ignore}\n-let x = 5i;\n-\n-let p = proc() { x * x };\n-println!(\"{}\", p());\n-println!(\"{}\", p()); // error: use of moved value `p`\n-```\n-\n-This restriction is important. Procs are allowed to consume values that they\n-capture, and thus have to be restricted to being called once for soundness\n-reasons: any value consumed would be invalid on a second call.\n-\n-Procs are most useful with Rust's concurrency features, and so we'll just leave\n-it at this for now. We'll talk about them more in the \"Tasks\" section of the\n-guide.\n+Rust has a second type of closure, called a **moving closure**. Moving\n+closures are indicated using the `move` keyword (e.g., `move || x *\n+x`). The difference between a moving closure and an ordinary closure\n+is that a moving closure always takes ownership of all variables that\n+it uses. Ordinary closures, in contrast, just create a reference into\n+the enclosing stack frame. Moving closures are most useful with Rust's\n+concurrency features, and so we'll just leave it at this for\n+now. We'll talk about them more in the \"Tasks\" section of the guide.\n \n ## Accepting closures as arguments\n \n@@ -5231,28 +5211,30 @@ concurrency libraries can be written for Rust to help in specific scenarios.\n Here's an example of creating a task:\n \n ```{rust}\n-spawn(proc() {\n+spawn(move || {\n     println!(\"Hello from a task!\");\n });\n ```\n \n-The `spawn` function takes a proc as an argument, and runs that proc in a new\n-task. A proc takes ownership of its entire environment, and so any variables\n-that you use inside the proc will not be usable afterward:\n+The `spawn` function takes a closure as an argument, and runs that\n+closure in a new task. Typically, you will want to use a moving\n+closure, so that the closure takes ownership of any variables that it\n+touches.  This implies that those variables are not usable from the\n+parent task after the child task is spawned:\n \n ```{rust,ignore}\n let mut x = vec![1i, 2i, 3i];\n \n-spawn(proc() {\n+spawn(move || {\n     println!(\"The value of x[0] is: {}\", x[0]);\n });\n \n println!(\"The value of x[0] is: {}\", x[0]); // error: use of moved value: `x`\n ```\n \n-`x` is now owned by the proc, and so we can't use it anymore. Many other\n-languages would let us do this, but it's not safe to do so. Rust's borrow\n-checker catches the error.\n+`x` is now owned by the closure, and so we can't use it anymore. Many\n+other languages would let us do this, but it's not safe to do\n+so. Rust's borrow checker catches the error.\n \n If tasks were only able to capture these values, they wouldn't be very useful.\n Luckily, tasks can communicate with each other through **channel**s. Channels\n@@ -5261,7 +5243,7 @@ work like this:\n ```{rust}\n let (tx, rx) = channel();\n \n-spawn(proc() {\n+spawn(move || {\n     tx.send(\"Hello from a task!\".to_string());\n });\n \n@@ -5281,7 +5263,7 @@ If you want to send messages to the task as well, create two channels!\n let (tx1, rx1) = channel();\n let (tx2, rx2) = channel();\n \n-spawn(proc() {\n+spawn(move || {\n     tx1.send(\"Hello from a task!\".to_string());\n     let message = rx2.recv();\n     println!(\"{}\", message);\n@@ -5293,8 +5275,9 @@ println!(\"{}\", message);\n tx2.send(\"Goodbye from main!\".to_string());\n ```\n \n-The proc has one sending end and one receiving end, and the main task has one\n-of each as well. Now they can talk back and forth in whatever way they wish.\n+The closure has one sending end and one receiving end, and the main\n+task has one of each as well. Now they can talk back and forth in\n+whatever way they wish.\n \n Notice as well that because `Sender` and `Receiver` are generic, while you can\n pass any kind of information through the channel, the ends are strongly typed.\n@@ -5310,34 +5293,34 @@ a useful thing to use:\n ```{rust}\n use std::sync::Future;\n \n-let mut delayed_value = Future::spawn(proc() {\n+let mut delayed_value = Future::spawn(move || {\n     // just return anything for examples' sake\n \n     12345i\n });\n println!(\"value = {}\", delayed_value.get());\n ```\n \n-Calling `Future::spawn` works just like `spawn()`: it takes a proc. In this\n-case, though, you don't need to mess with the channel: just have the proc\n-return the value.\n+Calling `Future::spawn` works just like `spawn()`: it takes a\n+closure. In this case, though, you don't need to mess with the\n+channel: just have the closure return the value.\n \n `Future::spawn` will return a value which we can bind with `let`. It needs\n to be mutable, because once the value is computed, it saves a copy of the\n value, and if it were immutable, it couldn't update itself.\n \n-The proc will go on processing in the background, and when we need the final\n-value, we can call `get()` on it. This will block until the result is done,\n-but if it's finished computing in the background, we'll just get the value\n-immediately.\n+The future will go on processing in the background, and when we need\n+the final value, we can call `get()` on it. This will block until the\n+result is done, but if it's finished computing in the background,\n+we'll just get the value immediately.\n \n ## Success and failure\n \n Tasks don't always succeed, they can also panic. A task that wishes to panic\n can call the `panic!` macro, passing a message:\n \n ```{rust}\n-spawn(proc() {\n+spawn(move || {\n     panic!(\"Nope.\");\n });\n ```\n@@ -5349,7 +5332,7 @@ notify other tasks that it has panicked. We can do this with `task::try`:\n use std::task;\n use std::rand;\n \n-let result = task::try(proc() {\n+let result = task::try(move || {\n     if rand::random() {\n         println!(\"OK\");\n     } else {"}, {"sha": "c0a1d5fa8816f7e9e6a2936bbc93b8389af3f13f", "filename": "src/doc/intro.md", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -391,26 +391,29 @@ Here's an example of a concurrent Rust program:\n ```{rust}\n fn main() {\n     for _ in range(0u, 10u) {\n-        spawn(proc() {\n+        spawn(move || {\n             println!(\"Hello, world!\");\n         });\n     }\n }\n ```\n \n-This program creates ten threads, who all print `Hello, world!`. The `spawn`\n-function takes one argument, a `proc`. 'proc' is short for 'procedure,' and is\n-a form of closure. This closure is executed in a new thread, created by `spawn`\n-itself.\n-\n-One common form of problem in concurrent programs is a 'data race.' This occurs\n-when two different threads attempt to access the same location in memory in a\n-non-synchronized way, where at least one of them is a write. If one thread is\n-attempting to read, and one thread is attempting to write, you cannot be sure\n-that your data will not be corrupted. Note the first half of that requirement:\n-two threads that attempt to access the same location in memory. Rust's\n-ownership model can track which pointers own which memory locations, which\n-solves this problem.\n+This program creates ten threads, who all print `Hello, world!`. The\n+`spawn` function takes one argument, a closure, indicated by the\n+double bars `||`. (The `move` keyword indicates that the closure takes\n+ownership of any data it uses; we'll have more on the significance of\n+this shortly.) This closure is executed in a new thread created by\n+`spawn`.\n+\n+One common form of problem in concurrent programs is a 'data race.'\n+This occurs when two different threads attempt to access the same\n+location in memory in a non-synchronized way, where at least one of\n+them is a write. If one thread is attempting to read, and one thread\n+is attempting to write, you cannot be sure that your data will not be\n+corrupted. Note the first half of that requirement: two threads that\n+attempt to access the same location in memory. Rust's ownership model\n+can track which pointers own which memory locations, which solves this\n+problem.\n \n Let's see an example. This Rust code will not compile:\n \n@@ -419,7 +422,7 @@ fn main() {\n     let mut numbers = vec![1i, 2i, 3i];\n \n     for i in range(0u, 3u) {\n-        spawn(proc() {\n+        spawn(move || {\n             for j in range(0, 3) { numbers[j] += 1 }\n         });\n     }\n@@ -432,20 +435,25 @@ It gives us this error:\n 6:71 error: capture of moved value: `numbers`\n     for j in range(0, 3) { numbers[j] += 1 }\n                ^~~~~~~\n-7:50 note: `numbers` moved into closure environment here because it has type `proc():Send`, which is non-copyable (perhaps you meant to use clone()?)\n-    spawn(proc() {\n+7:50 note: `numbers` moved into closure environment here\n+    spawn(move || {\n         for j in range(0, 3) { numbers[j] += 1 }\n     });\n 6:79 error: cannot assign to immutable dereference (dereference is implicit, due to indexing)\n         for j in range(0, 3) { numbers[j] += 1 }\n                            ^~~~~~~~~~~~~~~\n ```\n \n-It mentions that \"numbers moved into closure environment\". Because we referred\n-to `numbers` inside of our `proc`, and we create three `proc`s, we would have\n-three references. Rust detects this and gives us the error: we claim that\n-`numbers` has ownership, but our code tries to make three owners. This may\n-cause a safety problem, so Rust disallows it.\n+It mentions that \"numbers moved into closure environment\". Because we\n+declared the closure as a moving closure, and it referred to\n+`numbers`, the closure will try to take ownership of the vector. But\n+the closure itself is created in a loop, and hence we will actually\n+create three closures, one for every iteration of the loop. This means\n+that all three of those closures would try to own `numbers`, which is\n+impossible -- `numbers` must have just one owner. Rust detects this\n+and gives us the error: we claim that `numbers` has ownership, but our\n+code tries to make three owners. This may cause a safety problem, so\n+Rust disallows it.\n \n What to do here? Rust has two types that helps us: `Arc<T>` and `Mutex<T>`.\n \"Arc\" stands for \"atomically reference counted.\" In other words, an Arc will\n@@ -468,7 +476,7 @@ fn main() {\n \n     for i in range(0u, 3u) {\n         let number = numbers.clone();\n-        spawn(proc() {\n+        spawn(move || {\n             let mut array = number.lock();\n \n             (*array)[i] += 1;\n@@ -528,7 +536,7 @@ fn main() {\n     let vec = vec![1i, 2, 3];\n \n     for i in range(1u, 3) {\n-        spawn(proc() {\n+        spawn(move || {\n             println!(\"{}\", vec[i]);\n         });\n     }"}, {"sha": "c24cd6d8bf3911f9a1d5bc4527a67f27fd88910c", "filename": "src/doc/reference.md", "status": "modified", "additions": 12, "deletions": 41, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -187,19 +187,18 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n \n <p id=\"keyword-table-marker\"></p>\n \n-|          |          |          |          |        |\n-|----------|----------|----------|----------|--------|\n-| abstract | alignof  | as       | be       | box    |\n-| break    | const    | continue | crate    | do     |\n-| else     | enum     | extern   | false    | final  |\n-| fn       | for      | if       | impl     | in     |\n-| let      | loop     | match    | mod      | move   |\n-| mut      | offsetof | once     | override | priv   |\n-| proc     | pub      | pure     | ref      | return |\n-| sizeof   | static   | self     | struct   | super  |\n-| true     | trait    | type     | typeof   | unsafe |\n-| unsized  | use      | virtual  | where    | while  |\n-| yield    |          |          |          |        |\n+|          |          |          |          |         |\n+|----------|----------|----------|----------|---------|\n+| abstract | alignof  | as       | be       | box     |\n+| break    | const    | continue | crate    | do      |\n+| else     | enum     | extern   | false    | final   |\n+| fn       | for      | if       | impl     | in      |\n+| let      | loop     | match    | mod      | move    |\n+| mut      | offsetof | once     | override | priv    |\n+| pub      | pure     | ref      | return   | sizeof  |\n+| static   | self     | struct   | super    | true    |\n+| trait    | type     | typeof   | unsafe   | unsized |\n+| use      | virtual  | where    | while    | yield   |\n \n \n Each of these keywords has special meaning in its grammar, and all of them are\n@@ -3842,8 +3841,6 @@ x = bo(5,7);\n ```{.ebnf .notation}\n closure_type := [ 'unsafe' ] [ '<' lifetime-list '>' ] '|' arg-list '|'\n                 [ ':' bound-list ] [ '->' type ]\n-procedure_type := 'proc' [ '<' lifetime-list '>' ] '(' arg-list ')'\n-                  [ ':' bound-list ] [ '->' type ]\n lifetime-list := lifetime | lifetime ',' lifetime-list\n arg-list := ident ':' type | ident ':' type ',' arg-list\n bound-list := bound | bound '+' bound-list\n@@ -3852,8 +3849,6 @@ bound := path | lifetime\n \n The type of a closure mapping an input of type `A` to an output of type `B` is\n `|A| -> B`. A closure with no arguments or return values has type `||`.\n-Similarly, a procedure mapping `A` to `B` is `proc(A) -> B` and a no-argument\n-and no-return value closure has type `proc()`.\n \n An example of creating and calling a closure:\n \n@@ -3876,30 +3871,6 @@ call_closure(closure_no_args, closure_args);\n \n ```\n \n-Unlike closures, procedures may only be invoked once, but own their\n-environment, and are allowed to move out of their environment. Procedures are\n-allocated on the heap (unlike closures). An example of creating and calling a\n-procedure:\n-\n-```rust\n-let string = \"Hello\".to_string();\n-\n-// Creates a new procedure, passing it to the `spawn` function.\n-spawn(proc() {\n-  println!(\"{} world!\", string);\n-});\n-\n-// the variable `string` has been moved into the previous procedure, so it is\n-// no longer usable.\n-\n-\n-// Create an invoke a procedure. Note that the procedure is *moved* when\n-// invoked, so it cannot be invoked again.\n-let f = proc(n: int) { n + 22 };\n-println!(\"answer: {}\", f(20));\n-\n-```\n-\n ### Object types\n \n Every trait item (see [traits](#traits)) defines a type with the same name as"}, {"sha": "054552559dbec077fb5a1fd4533b3f0d40b83efb", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -210,11 +210,11 @@ that one can still write things like `#[deriving(Eq)]`).\n #\u00a0// what's actually being documented.\n #\u00a0fn fib(n: int) { n + 2 }\n \n-spawn(proc() { fib(200); })\n+spawn(move || { fib(200); })\n ```\n ~~~\n \n-The documentation online would look like `spawn(proc() { fib(200); })`, but when\n+The documentation online would look like `spawn(move || { fib(200); })`, but when\n testing this code, the `fib` function will be included (so it can compile).\n \n ## Running tests (advanced)"}, {"sha": "6917e9ee354eef895cb04b503371258f8b7daf2d", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -174,7 +174,7 @@\n     \"if\" \"impl\" \"in\"\n     \"let\" \"loop\"\n     \"match\" \"mod\" \"move\" \"mut\"\n-    \"priv\" \"proc\" \"pub\"\n+    \"priv\" \"pub\"\n     \"ref\" \"return\"\n     \"self\" \"static\" \"struct\" \"super\"\n     \"true\" \"trait\" \"type\""}, {"sha": "3bd2051c617ebf3330ded39b8fc162e47ac8cb82", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -24,7 +24,7 @@ syn keyword   rustKeyword     continue\n syn keyword   rustKeyword     extern nextgroup=rustExternCrate,rustObsoleteExternMod skipwhite skipempty\n syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite skipempty\n syn keyword   rustKeyword     for in if impl let\n-syn keyword   rustKeyword     loop once proc pub\n+syn keyword   rustKeyword     loop once pub\n syn keyword   rustKeyword     return super\n syn keyword   rustKeyword     unsafe virtual where while\n syn keyword   rustKeyword     use nextgroup=rustModPath skipwhite skipempty"}, {"sha": "1f1909fd33cc18add67dbce919ffd70dac1679b8", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -46,7 +46,7 @@ use heap::deallocate;\n ///     for _ in range(0u, 10) {\n ///         let child_numbers = shared_numbers.clone();\n ///\n-///         spawn(proc() {\n+///         spawn(move || {\n ///             let local_numbers = child_numbers.as_slice();\n ///\n ///             // Work with the local numbers\n@@ -358,7 +358,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n \n-        task::spawn(proc() {\n+        task::spawn(move || {\n             let arc_v: Arc<Vec<int>> = rx.recv();\n             assert_eq!((*arc_v)[3], 4);\n         });"}, {"sha": "df86ac96424b5529cf23f0e5edad29700f823066", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -1133,7 +1133,7 @@ mod tests {\n     #[test]\n     fn test_send() {\n         let n = list_from(&[1i,2,3]);\n-        spawn(proc() {\n+        spawn(move || {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n             assert_eq!(a, n.iter().collect::<Vec<&int>>());"}, {"sha": "be2f4e590a3590d61b81905c2db64352ab6ec089", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -40,15 +40,6 @@ pub struct Closure {\n \n impl Copy for Closure {}\n \n-/// The representation of a Rust procedure (`proc()`)\n-#[repr(C)]\n-pub struct Procedure {\n-    pub code: *mut (),\n-    pub env: *mut (),\n-}\n-\n-impl Copy for Procedure {}\n-\n /// The representation of a Rust trait object.\n ///\n /// This struct does not have a `Repr` implementation"}, {"sha": "2c8e5638e4949206aea08522c732f7f3c0031024", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -21,7 +21,7 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(phase)]\n+#![feature(phase, unboxed_closures)]\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n@@ -59,7 +59,7 @@ fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n                                              &mut outsz,\n                                              flags);\n         if !res.is_null() {\n-            Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res)))\n+            Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, move|:| libc::free(res)))\n         } else {\n             None\n         }\n@@ -84,7 +84,7 @@ fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n                                                &mut outsz,\n                                                flags);\n         if !res.is_null() {\n-            Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res)))\n+            Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, move|:| libc::free(res)))\n         } else {\n             None\n         }"}, {"sha": "8731f7084ed7d15db6595acc56cf7e160cffe4c8", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -165,7 +165,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(macro_rules)]\n+#![feature(macro_rules, unboxed_closures)]\n #![deny(missing_docs)]\n \n extern crate regex;\n@@ -422,7 +422,7 @@ fn init() {\n         DIRECTIVES = mem::transmute(box directives);\n \n         // Schedule the cleanup for the globals for when the runtime exits.\n-        rt::at_exit(proc() {\n+        rt::at_exit(move |:| {\n             assert!(!DIRECTIVES.is_null());\n             let _directives: Box<Vec<directive::LogDirective>> =\n                 mem::transmute(DIRECTIVES);"}, {"sha": "b6347278bffda63db464be532e936ee8bd1e2ffd", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -498,7 +498,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             ast::ExprMac(..) |\n             ast::ExprClosure(..) |\n-            ast::ExprProc(..) |\n             ast::ExprLit(..) |\n             ast::ExprPath(..) => {\n                 self.straightline(expr, pred, None::<ast::Expr>.iter())"}, {"sha": "c4ad089d76e6e84384c7ed1b96e62ff627d98bfc", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -52,8 +52,7 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n                 self.visit_expr(&**e);\n                 self.with_context(Loop, |v| v.visit_block(&**b));\n             }\n-            ast::ExprClosure(_, _, _, ref b) |\n-            ast::ExprProc(_, ref b) => {\n+            ast::ExprClosure(_, _, _, ref b) => {\n                 self.with_context(Closure, |v| v.visit_block(&**b));\n             }\n             ast::ExprBreak(_) => self.require_loop(\"break\", e.span),"}, {"sha": "6501d8d6eb4306db79a4049a22e9c2a73966a49c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -613,8 +613,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 self.consume_expr(&**count);\n             }\n \n-            ast::ExprClosure(..) |\n-            ast::ExprProc(..) => {\n+            ast::ExprClosure(..) => {\n                 self.walk_captures(expr)\n             }\n "}, {"sha": "0c346519672d84d3e2017e4468d14fc31ef40171", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -587,19 +587,6 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     sub,\n                     \"\");\n             }\n-            infer::ProcCapture(span, id) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    format!(\"captured variable `{}` must be 'static \\\n-                             to be captured in a proc\",\n-                            ty::local_var_name_str(self.tcx, id).get())\n-                        .as_slice());\n-                note_and_explain_region(\n-                    self.tcx,\n-                    \"captured variable is only valid for \",\n-                    sup,\n-                    \"\");\n-            }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_err(span,\n                                        \"index of slice outside its lifetime\");\n@@ -625,28 +612,6 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     sup,\n                     \"\");\n             }\n-            infer::RelateProcBound(span, var_node_id, ty) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    format!(\n-                        \"the type `{}` of captured variable `{}` \\\n-                         outlives the `proc()` it \\\n-                         is captured in\",\n-                        self.ty_to_string(ty),\n-                        ty::local_var_name_str(self.tcx,\n-                                               var_node_id)).as_slice());\n-                note_and_explain_region(\n-                    self.tcx,\n-                    \"`proc()` is valid for \",\n-                    sub,\n-                    \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n-                    format!(\"the type `{}` is only valid for \",\n-                            self.ty_to_string(ty)).as_slice(),\n-                    sup,\n-                    \"\");\n-            }\n             infer::RelateParamBound(span, ty) => {\n                 self.tcx.sess.span_err(\n                     span,\n@@ -1587,15 +1552,6 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                 self.tcx,\n                                 id).get().to_string()).as_slice());\n             }\n-            infer::ProcCapture(span, id) => {\n-                self.tcx.sess.span_note(\n-                    span,\n-                    format!(\"...so that captured variable `{}` \\\n-                            is 'static\",\n-                            ty::local_var_name_str(\n-                                self.tcx,\n-                                id).get()).as_slice());\n-            }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n@@ -1606,15 +1562,6 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"...so that it can be closed over into an object\");\n             }\n-            infer::RelateProcBound(span, var_node_id, _ty) => {\n-                self.tcx.sess.span_note(\n-                    span,\n-                    format!(\n-                        \"...so that the variable `{}` can be captured \\\n-                         into a proc\",\n-                        ty::local_var_name_str(self.tcx,\n-                                               var_node_id)).as_slice());\n-            }\n             infer::CallRcvr(span) => {\n                 self.tcx.sess.span_note(\n                     span,"}, {"sha": "2b1d8776365ecfb9ae4a0a43055a20db66a1a19b", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -175,20 +175,13 @@ pub enum SubregionOrigin<'tcx> {\n     // Closure bound must not outlive captured free variables\n     FreeVariable(Span, ast::NodeId),\n \n-    // Proc upvars must be 'static\n-    ProcCapture(Span, ast::NodeId),\n-\n     // Index into slice must be within its lifetime\n     IndexSlice(Span),\n \n     // When casting `&'a T` to an `&'b Trait` object,\n     // relating `'a` to `'b`\n     RelateObjectBound(Span),\n \n-    // When closing over a variable in a closure/proc, ensure that the\n-    // type of the variable outlives the lifetime bound.\n-    RelateProcBound(Span, ast::NodeId, Ty<'tcx>),\n-\n     // Some type parameter was instantiated with the given type,\n     // and that type must outlive some region.\n     RelateParamBound(Span, Ty<'tcx>),\n@@ -1089,10 +1082,8 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             InvokeClosure(a) => a,\n             DerefPointer(a) => a,\n             FreeVariable(a, _) => a,\n-            ProcCapture(a, _) => a,\n             IndexSlice(a) => a,\n             RelateObjectBound(a) => a,\n-            RelateProcBound(a, _, _) => a,\n             RelateParamBound(a, _) => a,\n             RelateRegionParamBound(a) => a,\n             RelateDefaultParamBound(a, _) => a,\n@@ -1128,21 +1119,12 @@ impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n             FreeVariable(a, b) => {\n                 format!(\"FreeVariable({}, {})\", a.repr(tcx), b)\n             }\n-            ProcCapture(a, b) => {\n-                format!(\"ProcCapture({}, {})\", a.repr(tcx), b)\n-            }\n             IndexSlice(a) => {\n                 format!(\"IndexSlice({})\", a.repr(tcx))\n             }\n             RelateObjectBound(a) => {\n                 format!(\"RelateObjectBound({})\", a.repr(tcx))\n             }\n-            RelateProcBound(a, b, c) => {\n-                format!(\"RelateProcBound({},{},{})\",\n-                        a.repr(tcx),\n-                        b,\n-                        c.repr(tcx))\n-            }\n             RelateParamBound(a, b) => {\n                 format!(\"RelateParamBound({},{})\",\n                         a.repr(tcx),"}, {"sha": "8d5528b3709ad1a7c608fc10810735acefd57aa6", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -114,6 +114,22 @@ impl LanguageItems {\n         }\n     }\n \n+    pub fn fn_trait_kind(&self, id: ast::DefId) -> Option<ty::UnboxedClosureKind> {\n+        let def_id_kinds = [\n+            (self.fn_trait(), ty::FnUnboxedClosureKind),\n+            (self.fn_mut_trait(), ty::FnMutUnboxedClosureKind),\n+            (self.fn_once_trait(), ty::FnOnceUnboxedClosureKind),\n+            ];\n+\n+        for &(opt_def_id, kind) in def_id_kinds.iter() {\n+            if Some(id) == opt_def_id {\n+                return Some(kind);\n+            }\n+        }\n+\n+        None\n+    }\n+\n     $(\n         #[allow(dead_code)]\n         pub fn $method(&self) -> Option<ast::DefId> {"}, {"sha": "31bcdff9cd59370705567f8a4bc8ddd994439654", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -461,7 +461,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         }\n         visit::walk_expr(ir, expr);\n       }\n-      ast::ExprClosure(..) | ast::ExprProc(..) => {\n+      ast::ExprClosure(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -981,9 +981,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ast::ExprClosure(_, _, _, ref blk) |\n-          ast::ExprProc(_, ref blk) => {\n-              debug!(\"{} is an ExprClosure or ExprProc\",\n+          ast::ExprClosure(_, _, _, ref blk) => {\n+              debug!(\"{} is an ExprClosure\",\n                      expr_to_string(expr));\n \n               /*\n@@ -1502,8 +1501,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ast::ExprBreak(..) | ast::ExprAgain(..) | ast::ExprLit(_) |\n       ast::ExprBlock(..) | ast::ExprMac(..) | ast::ExprAddrOf(..) |\n       ast::ExprStruct(..) | ast::ExprRepeat(..) | ast::ExprParen(..) |\n-      ast::ExprClosure(..) | ast::ExprProc(..) |\n-      ast::ExprPath(..) | ast::ExprBox(..) | ast::ExprSlice(..) => {\n+      ast::ExprClosure(..) | ast::ExprPath(..) | ast::ExprBox(..) | ast::ExprSlice(..) => {\n         visit::walk_expr(this, expr);\n       }\n       ast::ExprIfLet(..) => {"}, {"sha": "652847a63436defe3525fd2401d39d214a645857", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -555,8 +555,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n           ast::ExprAddrOf(..) | ast::ExprCall(..) |\n           ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n-          ast::ExprClosure(..) | ast::ExprProc(..) |\n-          ast::ExprRet(..) |\n+          ast::ExprClosure(..) | ast::ExprRet(..) |\n           ast::ExprUnary(..) | ast::ExprSlice(..) |\n           ast::ExprMethodCall(..) | ast::ExprCast(..) |\n           ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n@@ -728,7 +727,6 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 };\n \n                 match fn_expr.node {\n-                    ast::ExprProc(_, ref body) |\n                     ast::ExprClosure(_, _, _, ref body) => body.id,\n                     _ => unreachable!()\n                 }"}, {"sha": "f2c83291b79e7608fa774c0235f75a3aaab06a9d", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -51,7 +51,7 @@ use util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DeclItem, DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n-use syntax::ast::{ExprPath, ExprProc, ExprStruct, FnDecl};\n+use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemEnum, ItemFn, ItemForeignMod};\n use syntax::ast::{ItemImpl, ItemMac, ItemMod, ItemStatic, ItemStruct};\n@@ -64,7 +64,7 @@ use syntax::ast::{RegionTyParamBound, StmtDecl, StructField};\n use syntax::ast::{StructVariantKind, TraitRef, TraitTyParamBound};\n use syntax::ast::{TupleVariantKind, Ty, TyBool, TyChar, TyClosure, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt, TyObjectSum};\n-use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyPolyTraitRef, TyProc, TyQPath};\n+use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyPolyTraitRef, TyQPath};\n use syntax::ast::{TyRptr, TyStr, TyU, TyU8, TyU16, TyU32, TyU64, TyUint};\n use syntax::ast::{TypeImplItem, UnnamedField};\n use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n@@ -5027,7 +5027,7 @@ impl<'a> Resolver<'a> {\n                 self.resolve_trait_reference(ty.id, &*qpath.trait_ref, TraitQPath);\n             }\n \n-            TyClosure(ref c) | TyProc(ref c) => {\n+            TyClosure(ref c) => {\n                 self.resolve_type_parameter_bounds(\n                     ty.id,\n                     &c.bounds,\n@@ -5916,13 +5916,6 @@ impl<'a> Resolver<'a> {\n                                       &**block);\n             }\n \n-            ExprProc(ref fn_decl, ref block) => {\n-                self.capture_mode_map.insert(expr.id, ast::CaptureByValue);\n-                self.resolve_function(ClosureRibKind(expr.id, block.id),\n-                                      Some(&**fn_decl), NoTypeParameters,\n-                                      &**block);\n-            }\n-\n             ExprStruct(ref path, _, _) => {\n                 // Resolve the path to the structure it goes to. We don't\n                 // check to ensure that the path is actually a structure; that"}, {"sha": "ee0fc32702064c4d2df83de82b1be65043900886", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -141,7 +141,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n \n     fn visit_ty(&mut self, ty: &ast::Ty) {\n         match ty.node {\n-            ast::TyClosure(ref c) | ast::TyProc(ref c) => {\n+            ast::TyClosure(ref c)  => {\n                 // Careful, the bounds on a closure/proc are *not* within its binder.\n                 visit::walk_ty_param_bounds_helper(self, &c.bounds);\n                 visit::walk_lifetime_decls_helper(self, &c.lifetimes);"}, {"sha": "c3c4acd8191c08756545adc32b653f80857f27ad", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -746,8 +746,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => { return Ok(()); }\n         };\n \n-        debug!(\"assemble_unboxed_candidates: self_ty={} obligation={}\",\n+        debug!(\"assemble_unboxed_candidates: self_ty={} kind={} obligation={}\",\n                self_ty.repr(self.tcx()),\n+               kind,\n                obligation.repr(self.tcx()));\n \n         let closure_kind = match self.typer.unboxed_closures().borrow().get(&closure_def_id) {\n@@ -760,6 +761,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n+        debug!(\"closure_kind = {}\", closure_kind);\n+\n         if closure_kind == kind {\n             candidates.vec.push(UnboxedClosureCandidate(closure_def_id, substs.clone()));\n         }\n@@ -842,14 +845,24 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             candidate: &Candidate<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n-        debug!(\"winnow_candidate: candidate={}\", candidate.repr(self.tcx()));\n-        self.infcx.probe(|| {\n+        /*!\n+         * Further evaluate `candidate` to decide whether all type parameters match\n+         * and whether nested obligations are met. Returns true if `candidate` remains\n+         * viable after this further scrutiny.\n+         */\n+\n+        debug!(\"winnow_candidate: depth={} candidate={}\",\n+               stack.obligation.recursion_depth, candidate.repr(self.tcx()));\n+        let result = self.infcx.probe(|| {\n             let candidate = (*candidate).clone();\n             match self.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => self.winnow_selection(Some(stack), selection),\n                 Err(error) => EvaluatedToErr(error),\n             }\n-        })\n+        });\n+        debug!(\"winnow_candidate depth={} result={}\",\n+               stack.obligation.recursion_depth, result);\n+        result\n     }\n \n     fn winnow_selection<'o>(&mut self,\n@@ -1562,6 +1575,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             substs: substs,\n         });\n \n+        debug!(\"confirm_unboxed_closure_candidate(closure_def_id={}, trait_ref={})\",\n+               closure_def_id.repr(self.tcx()),\n+               trait_ref.repr(self.tcx()));\n+\n         self.confirm(obligation.cause,\n                      obligation.trait_ref.clone(),\n                      trait_ref)"}, {"sha": "98d4761508a284ab825b67f847430dfb2f8dc06b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -4236,7 +4236,6 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprIf(..) |\n         ast::ExprMatch(..) |\n         ast::ExprClosure(..) |\n-        ast::ExprProc(..) |\n         ast::ExprBlock(..) |\n         ast::ExprRepeat(..) |\n         ast::ExprVec(..) => {"}, {"sha": "f8276fa8f84d4e9ecb694fd75dda055ba3b366e7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -449,7 +449,14 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             let unboxed_closures = cx.unboxed_closures.borrow();\n             unboxed_closures.get(did).map(|cl| {\n                 closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n-            }).unwrap_or_else(|| \"closure\".to_string())\n+            }).unwrap_or_else(|| {\n+                if did.krate == ast::LOCAL_CRATE {\n+                    let span = cx.map.span(did.node);\n+                    format!(\"closure[{}]\", span.repr(cx))\n+                } else {\n+                    format!(\"closure\")\n+                }\n+            })\n         }\n         ty_vec(t, sz) => {\n             let inner_str = ty_to_string(cx, t);"}, {"sha": "116cff49153beecdad9be2d5c9117d5a0c77fd20", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -242,7 +242,6 @@ mod svh_visitor {\n         SawExprWhile,\n         SawExprMatch,\n         SawExprClosure,\n-        SawExprProc,\n         SawExprBlock,\n         SawExprAssign,\n         SawExprAssignOp(ast::BinOp),\n@@ -274,7 +273,6 @@ mod svh_visitor {\n             ExprLoop(_, id)          => SawExprLoop(id.map(content)),\n             ExprMatch(..)            => SawExprMatch,\n             ExprClosure(..)          => SawExprClosure,\n-            ExprProc(..)             => SawExprProc,\n             ExprBlock(..)            => SawExprBlock,\n             ExprAssign(..)           => SawExprAssign,\n             ExprAssignOp(op, _, _)   => SawExprAssignOp(op),"}, {"sha": "a3fb91aced007fc432e505b867a7c1b79664442e", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -337,7 +337,6 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n                         tcx: &ty::ctxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         ast_map::NodeExpr(expr) => match expr.node {\n-            ast::ExprProc(_, ref block) |\n             ast::ExprClosure(_, _, _, ref block) => {\n                 block.id\n             }"}, {"sha": "b0f8b3bdbe7df8970b367f2a93a00627570baef3", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -71,7 +71,7 @@ pub mod driver;\n pub mod pretty;\n \n pub fn run(args: Vec<String>) -> int {\n-    monitor(proc() run_compiler(args.as_slice()));\n+    monitor(move |:| run_compiler(args.as_slice()));\n     0\n }\n \n@@ -471,7 +471,7 @@ pub fn list_metadata(sess: &Session, path: &Path,\n ///\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n-pub fn monitor(f: proc():Send) {\n+pub fn monitor<F:FnOnce()+Send>(f: F) {\n     static STACK_SIZE: uint = 32000000; // 32MB\n \n     let (tx, rx) = channel();"}, {"sha": "24dfe600f2a56f2320bc5e665eac6d360789d153", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -842,18 +842,31 @@ pub fn run_passes(sess: &Session,\n     //if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n }\n \n-type WorkItem = proc(&CodegenContext):Send;\n+struct WorkItem {\n+    mtrans: ModuleTranslation,\n+    config: ModuleConfig,\n+    output_names: OutputFilenames,\n+    name_extra: String\n+}\n \n fn build_work_item(sess: &Session,\n                    mtrans: ModuleTranslation,\n                    config: ModuleConfig,\n                    output_names: OutputFilenames,\n-                   name_extra: String) -> WorkItem {\n+                   name_extra: String)\n+                   -> WorkItem\n+{\n     let mut config = config;\n     config.tm = create_target_machine(sess);\n+    WorkItem { mtrans: mtrans, config: config, output_names: output_names,\n+               name_extra: name_extra }\n+}\n \n-    proc(cgcx) unsafe {\n-        optimize_and_codegen(cgcx, mtrans, config, name_extra, output_names);\n+fn execute_work_item(cgcx: &CodegenContext,\n+                     work_item: WorkItem) {\n+    unsafe {\n+        optimize_and_codegen(cgcx, work_item.mtrans, work_item.config,\n+                             work_item.name_extra, work_item.output_names);\n     }\n }\n \n@@ -866,7 +879,7 @@ fn run_work_singlethreaded(sess: &Session,\n     // Since we're running single-threaded, we can pass the session to\n     // the proc, allowing `optimize_and_codegen` to perform LTO.\n     for work in Unfold::new((), |_| work_items.pop()) {\n-        work(&cgcx);\n+        execute_work_item(&cgcx, work);\n     }\n }\n \n@@ -883,7 +896,7 @@ fn run_work_multithreaded(sess: &Session,\n         let diag_emitter = diag_emitter.clone();\n         let remark = sess.opts.cg.remark.clone();\n \n-        let future = TaskBuilder::new().named(format!(\"codegen-{}\", i)).try_future(proc() {\n+        let future = TaskBuilder::new().named(format!(\"codegen-{}\", i)).try_future(move |:| {\n             let diag_handler = mk_handler(box diag_emitter);\n \n             // Must construct cgcx inside the proc because it has non-Send\n@@ -899,7 +912,7 @@ fn run_work_multithreaded(sess: &Session,\n                 let maybe_work = work_items_arc.lock().pop();\n                 match maybe_work {\n                     Some(work) => {\n-                        work(&cgcx);\n+                        execute_work_item(&cgcx, work);\n \n                         // Make sure to fail the worker so the main thread can\n                         // tell that there were errors."}, {"sha": "b2578fdbc054bb0c26241588a892ca734d423e18", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -1396,8 +1396,7 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n         }\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n-                ast::ExprClosure(_, _, _, ref blk) |\n-                ast::ExprProc(_, ref blk) => {\n+                ast::ExprClosure(_, _, _, ref blk) => {\n                     let mut explicit = CheckForNestedReturnsVisitor::explicit();\n                     let mut implicit = CheckForNestedReturnsVisitor::implicit();\n                     visit::walk_expr(&mut explicit, e);"}, {"sha": "67e1735d9a3b72d064b30ab329c3a8976d710248", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 149, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -19,8 +19,7 @@ pub use self::CalleeData::*;\n pub use self::CallArgs::*;\n \n use arena::TypedArena;\n-use back::abi;\n-use back::link;\n+use back::{abi,link};\n use session;\n use llvm::{ValueRef, get_param};\n use llvm;\n@@ -357,153 +356,6 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     llfn\n }\n \n-/// Translates the adapter that deconstructs a `Box<Trait>` object into\n-/// `Trait` so that a by-value self method can be called.\n-pub fn trans_unboxing_shim<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                       llshimmedfn: ValueRef,\n-                                       fty: &ty::BareFnTy<'tcx>,\n-                                       method_id: ast::DefId,\n-                                       substs: &subst::Substs<'tcx>)\n-                                       -> ValueRef {\n-    let _icx = push_ctxt(\"trans_unboxing_shim\");\n-    let ccx = bcx.ccx();\n-    let tcx = bcx.tcx();\n-\n-    let fty = fty.subst(tcx, substs);\n-\n-    // Transform the self type to `Box<self_type>`.\n-    let self_type = fty.sig.inputs[0];\n-    let boxed_self_type = ty::mk_uniq(tcx, self_type);\n-    let boxed_function_type = ty::FnSig {\n-        inputs: fty.sig.inputs.iter().enumerate().map(|(i, typ)| {\n-            if i == 0 {\n-                boxed_self_type\n-            } else {\n-                *typ\n-            }\n-        }).collect(),\n-        output: fty.sig.output,\n-        variadic: false,\n-    };\n-    let boxed_function_type = ty::BareFnTy {\n-        fn_style: fty.fn_style,\n-        abi: fty.abi,\n-        sig: boxed_function_type,\n-    };\n-    let boxed_function_type = ty::mk_bare_fn(tcx, boxed_function_type);\n-    let function_type = match fty.abi {\n-        synabi::RustCall => {\n-            // We're passing through to a RustCall ABI function, but\n-            // because the shim will already perform untupling, we\n-            // need to pretend the shimmed function does not use\n-            // RustCall so the untupled arguments can be passed\n-            // through verbatim.  This is kind of ugly.\n-            let fake_ty = ty::FnSig {\n-                inputs: type_of::untuple_arguments_if_necessary(ccx,\n-                                                                fty.sig.inputs.as_slice(),\n-                                                                fty.abi),\n-                output: fty.sig.output,\n-                variadic: false,\n-            };\n-            let fake_ty = ty::BareFnTy {\n-                fn_style: fty.fn_style,\n-                abi: synabi::Rust,\n-                sig: fake_ty,\n-            };\n-            ty::mk_bare_fn(tcx, fake_ty)\n-        }\n-        _ => {\n-            ty::mk_bare_fn(tcx, fty)\n-        }\n-    };\n-\n-    let function_name = ty::with_path(tcx, method_id, |path| {\n-        link::mangle_internal_name_by_path_and_seq(path, \"unboxing_shim\")\n-    });\n-    let llfn = decl_internal_rust_fn(ccx,\n-                                     boxed_function_type,\n-                                     function_name.as_slice());\n-\n-    let block_arena = TypedArena::new();\n-    let empty_param_substs = Substs::trans_empty();\n-    let return_type = ty::ty_fn_ret(boxed_function_type);\n-    let fcx = new_fn_ctxt(ccx,\n-                          llfn,\n-                          ast::DUMMY_NODE_ID,\n-                          false,\n-                          return_type,\n-                          &empty_param_substs,\n-                          None,\n-                          &block_arena);\n-    let mut bcx = init_function(&fcx, false, return_type);\n-\n-    // Create the substituted versions of the self type.\n-    let arg_scope = fcx.push_custom_cleanup_scope();\n-    let arg_scope_id = cleanup::CustomScope(arg_scope);\n-    let boxed_self_type = ty::ty_fn_args(boxed_function_type)[0];\n-    let arg_types = ty::ty_fn_args(function_type);\n-    let self_type = arg_types[0];\n-    let boxed_self_kind = arg_kind(&fcx, boxed_self_type);\n-\n-    // Create a datum for self.\n-    let llboxedself = get_param(fcx.llfn, fcx.arg_pos(0) as u32);\n-    let llboxedself = Datum::new(llboxedself,\n-                                 boxed_self_type,\n-                                 boxed_self_kind);\n-    let boxed_self =\n-        unpack_datum!(bcx,\n-                      llboxedself.to_lvalue_datum_in_scope(bcx,\n-                                                           \"boxedself\",\n-                                                           arg_scope_id));\n-\n-    // This `Load` is needed because lvalue data are always by-ref.\n-    let llboxedself = Load(bcx, boxed_self.val);\n-\n-    let llself = if type_is_immediate(ccx, self_type) {\n-        let llboxedself = Load(bcx, llboxedself);\n-        immediate_rvalue(llboxedself, self_type)\n-    } else {\n-        let llself = rvalue_scratch_datum(bcx, self_type, \"self\");\n-        memcpy_ty(bcx, llself.val, llboxedself, self_type);\n-        llself\n-    };\n-\n-    // Make sure we don't free the box twice!\n-    boxed_self.kind.post_store(bcx, boxed_self.val, boxed_self_type);\n-\n-    // Schedule a cleanup to free the box.\n-    fcx.schedule_free_value(arg_scope_id,\n-                            llboxedself,\n-                            cleanup::HeapExchange,\n-                            self_type);\n-\n-    // Now call the function.\n-    let mut llshimmedargs = vec!(llself.val);\n-    for i in range(1, arg_types.len()) {\n-        llshimmedargs.push(get_param(fcx.llfn, fcx.arg_pos(i) as u32));\n-    }\n-    assert!(!fcx.needs_ret_allocas);\n-    let dest = fcx.llretslotptr.get().map(|_|\n-        expr::SaveIn(fcx.get_ret_slot(bcx, return_type, \"ret_slot\"))\n-    );\n-    bcx = trans_call_inner(bcx,\n-                           None,\n-                           function_type,\n-                           |bcx, _| {\n-                               Callee {\n-                                   bcx: bcx,\n-                                   data: Fn(llshimmedfn),\n-                               }\n-                           },\n-                           ArgVals(llshimmedargs.as_slice()),\n-                           dest).bcx;\n-\n-    bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_scope);\n-    finish_fn(&fcx, bcx, return_type);\n-\n-    llfn\n-}\n-\n /// Translates a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n ///"}, {"sha": "66258f228cd7b8f2d35ef4bb46ecab1bd728ecae", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -1239,7 +1239,6 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ast_map::NodeExpr(ref expr) => {\n             match expr.node {\n-                ast::ExprProc(ref fn_decl, ref top_level_block) |\n                 ast::ExprClosure(_, _, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(name.as_slice());\n@@ -3588,7 +3587,6 @@ fn populate_scope_map(cx: &CrateContext,\n                 })\n             }\n \n-            ast::ExprProc(ref decl, ref block) |\n             ast::ExprClosure(_, _, ref decl, ref block) => {\n                 with_new_scope(cx,\n                                block.span,"}, {"sha": "5b9a1d499910e62f299c170819ff507f7e544a9e", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -1052,8 +1052,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprVec(..) | ast::ExprRepeat(..) => {\n             tvec::trans_fixed_vstore(bcx, expr, dest)\n         }\n-        ast::ExprClosure(_, _, ref decl, ref body) |\n-        ast::ExprProc(ref decl, ref body) => {\n+        ast::ExprClosure(_, _, ref decl, ref body) => {\n             // Check the side-table to see whether this is an unboxed\n             // closure or an older, legacy style closure. Store this\n             // into a variable to ensure the the RefCell-lock is"}, {"sha": "9a2bc38acdfdcb9841a3baeb9ba0825755df2603", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 65, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -550,68 +550,12 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 emit_vtable_methods(bcx, id, substs).into_iter()\n             }\n             traits::VtableUnboxedClosure(closure_def_id, substs) => {\n-                // Look up closure type\n-                let self_ty = ty::node_id_to_type(bcx.tcx(), closure_def_id.node);\n-                // Apply substitutions from closure param environment.\n-                // The substitutions should have no type parameters\n-                // remaining after passing through fulfill_obligation\n-                let self_ty = self_ty.subst(bcx.tcx(), &substs);\n-\n-                let mut llfn = trans_fn_ref_with_substs(\n+                let llfn = trans_fn_ref_with_substs(\n                     bcx,\n                     closure_def_id,\n                     ExprId(0),\n                     substs.clone());\n \n-                {\n-                    let unboxed_closures = bcx.tcx()\n-                                              .unboxed_closures\n-                                              .borrow();\n-                    let closure_info =\n-                        unboxed_closures.get(&closure_def_id)\n-                                        .expect(\"get_vtable(): didn't find \\\n-                                                 unboxed closure\");\n-                    if closure_info.kind == ty::FnOnceUnboxedClosureKind {\n-                        // Untuple the arguments and create an unboxing shim.\n-                        let (new_inputs, new_output) = match self_ty.sty {\n-                            ty::ty_unboxed_closure(_, _, ref substs) => {\n-                                let mut new_inputs = vec![self_ty.clone()];\n-                                match closure_info.closure_type.sig.inputs[0].sty {\n-                                    ty::ty_tup(ref elements) => {\n-                                        for element in elements.iter() {\n-                                            new_inputs.push(element.subst(bcx.tcx(), substs));\n-                                        }\n-                                    }\n-                                    _ => {\n-                                        bcx.tcx().sess.bug(\"get_vtable(): closure \\\n-                                                            type wasn't a tuple\")\n-                                    }\n-                                }\n-                                (new_inputs,\n-                                 closure_info.closure_type.sig.output.subst(bcx.tcx(), substs))\n-                            },\n-                            _ => bcx.tcx().sess.bug(\"get_vtable(): def wasn't an unboxed closure\")\n-                        };\n-\n-                        let closure_type = ty::BareFnTy {\n-                            fn_style: closure_info.closure_type.fn_style,\n-                            abi: Rust,\n-                            sig: ty::FnSig {\n-                                inputs: new_inputs,\n-                                output: new_output,\n-                                variadic: false,\n-                            },\n-                        };\n-                        debug!(\"get_vtable(): closure type is {}\",\n-                               closure_type.repr(bcx.tcx()));\n-                        llfn = trans_unboxing_shim(bcx,\n-                                                   llfn,\n-                                                   &closure_type,\n-                                                   closure_def_id,\n-                                                   &substs);\n-                    }\n-                }\n-\n                 (vec!(llfn)).into_iter()\n             }\n             traits::VtableFnPointer(bare_fn_ty) => {\n@@ -701,18 +645,15 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            token::get_name(name));\n                     Some(C_null(Type::nil(ccx).ptr_to())).into_iter()\n                 } else {\n-                    let mut fn_ref = trans_fn_ref_with_substs(\n+                    let fn_ref = trans_fn_ref_with_substs(\n                         bcx,\n                         m_id,\n                         ExprId(0),\n                         substs.clone());\n-                    if m.explicit_self == ty::ByValueExplicitSelfCategory {\n-                        fn_ref = trans_unboxing_shim(bcx,\n-                                                     fn_ref,\n-                                                     &m.fty,\n-                                                     m_id,\n-                                                     &substs);\n-                    }\n+\n+                    // currently, at least, by-value self is not object safe\n+                    assert!(m.explicit_self != ty::ByValueExplicitSelfCategory);\n+\n                     Some(fn_ref).into_iter()\n                 }\n             }"}, {"sha": "762aed3dfa8ea5504cc848ce1e40c232e11ed30a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -235,8 +235,9 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n             convert_angle_bracketed_parameters(this, rscope, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n-            span_err!(tcx.sess, path.span, E0169,\n-                      \"parenthesized parameters may only be used with a trait\");\n+            tcx.sess.span_err(\n+                path.span,\n+                \"parenthesized parameters may only be used with a trait\");\n             (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n         }\n     };\n@@ -581,6 +582,19 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n             convert_angle_bracketed_parameters(this, &shifted_rscope, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n+            // For now, require that parenthetical notation be used\n+            // only with `Fn()` etc.\n+            if !this.tcx().sess.features.borrow().unboxed_closures &&\n+                this.tcx().lang_items.fn_trait_kind(trait_def_id).is_none()\n+            {\n+                this.tcx().sess.span_err(path.span,\n+                                         \"parenthetical notation is only stable when \\\n+                                         used with the `Fn` family of traits\");\n+                span_help!(this.tcx().sess, path.span,\n+                           \"add `#![feature(unboxed_closures)]` to \\\n+                            the crate attributes to enable\");\n+            }\n+\n             (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n         }\n     };\n@@ -932,26 +946,6 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                             None);\n                 ty::mk_closure(tcx, fn_decl)\n             }\n-            ast::TyProc(ref f) => {\n-                // Use corresponding trait store to figure out default bounds\n-                // if none were specified.\n-                let bounds = conv_existential_bounds(this,\n-                                                     rscope,\n-                                                     ast_ty.span,\n-                                                     None,\n-                                                     f.bounds.as_slice());\n-\n-                let fn_decl = ty_of_closure(this,\n-                                            f.fn_style,\n-                                            f.onceness,\n-                                            bounds,\n-                                            ty::UniqTraitStore,\n-                                            &*f.decl,\n-                                            abi::Rust,\n-                                            None);\n-\n-                ty::mk_closure(tcx, fn_decl)\n-            }\n             ast::TyPolyTraitRef(ref bounds) => {\n                 conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds.as_slice())\n             }\n@@ -1058,7 +1052,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             }\n             ast::TyInfer => {\n                 // TyInfer also appears as the type of arguments or return\n-                // values in a ExprClosure or ExprProc, or as\n+                // values in a ExprClosure, or as\n                 // the type of local variables. Both of these cases are\n                 // handled specially and will not descend into this routine.\n                 this.ty_infer(ast_ty.span)"}, {"sha": "692bd31638e347a81f7743a9afd18a1de400a608", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 35, "deletions": 50, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -188,42 +188,35 @@ fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n     debug!(\"deduce_unboxed_closure_expectations_from_object_type({})\",\n            trait_ref.repr(tcx));\n \n-    let def_id_kinds = [\n-        (tcx.lang_items.fn_trait(), ty::FnUnboxedClosureKind),\n-        (tcx.lang_items.fn_mut_trait(), ty::FnMutUnboxedClosureKind),\n-        (tcx.lang_items.fn_once_trait(), ty::FnOnceUnboxedClosureKind),\n-    ];\n-\n-    for &(def_id, kind) in def_id_kinds.iter() {\n-        if Some(trait_ref.def_id) == def_id {\n-            debug!(\"found object type {}\", kind);\n-\n-            let arg_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n-            let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(arg_param_ty);\n-            debug!(\"arg_param_ty {}\", arg_param_ty.repr(tcx));\n-\n-            let input_tys = match arg_param_ty.sty {\n-                ty::ty_tup(ref tys) => { (*tys).clone() }\n-                _ => { continue; }\n-            };\n-            debug!(\"input_tys {}\", input_tys.repr(tcx));\n+    let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id) {\n+        Some(k) => k,\n+        None => { return None; }\n+    };\n \n-            let ret_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 1);\n-            let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(ret_param_ty);\n-            debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n+    debug!(\"found object type {}\", kind);\n \n-            let fn_sig = ty::FnSig {\n-                inputs: input_tys,\n-                output: ty::FnConverging(ret_param_ty),\n-                variadic: false\n-            };\n-            debug!(\"fn_sig {}\", fn_sig.repr(tcx));\n+    let arg_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n+    let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(arg_param_ty);\n+    debug!(\"arg_param_ty {}\", arg_param_ty.repr(tcx));\n \n-            return Some((fn_sig, kind));\n-        }\n-    }\n+    let input_tys = match arg_param_ty.sty {\n+        ty::ty_tup(ref tys) => { (*tys).clone() }\n+        _ => { return None; }\n+    };\n+    debug!(\"input_tys {}\", input_tys.repr(tcx));\n \n-    None\n+    let ret_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 1);\n+    let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(ret_param_ty);\n+    debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n+\n+    let fn_sig = ty::FnSig {\n+        inputs: input_tys,\n+        output: ty::FnConverging(ret_param_ty),\n+        variadic: false\n+    };\n+    debug!(\"fn_sig {}\", fn_sig.repr(tcx));\n+\n+    return Some((fn_sig, kind));\n }\n \n fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n@@ -257,12 +250,12 @@ fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n }\n \n \n-pub fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                    expr: &ast::Expr,\n-                                    store: ty::TraitStore,\n-                                    decl: &ast::FnDecl,\n-                                    body: &ast::Block,\n-                                    expected: Expectation<'tcx>) {\n+fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                expr: &ast::Expr,\n+                                store: ty::TraitStore,\n+                                decl: &ast::FnDecl,\n+                                body: &ast::Block,\n+                                expected: Expectation<'tcx>) {\n     let tcx = fcx.ccx.tcx;\n \n     // Find the expected input/output types (if any). Substitute\n@@ -300,18 +293,10 @@ pub fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             }\n             _ => {\n                 // Not an error! Means we're inferring the closure type\n-                let (bounds, onceness) = match expr.node {\n-                    ast::ExprProc(..) => {\n-                        let mut bounds = ty::region_existential_bound(ty::ReStatic);\n-                        bounds.builtin_bounds.insert(ty::BoundSend); // FIXME\n-                        (bounds, ast::Once)\n-                    }\n-                    _ => {\n-                        let region = fcx.infcx().next_region_var(\n-                            infer::AddrOfRegion(expr.span));\n-                        (ty::region_existential_bound(region), ast::Many)\n-                    }\n-                };\n+                let region = fcx.infcx().next_region_var(\n+                    infer::AddrOfRegion(expr.span));\n+                let bounds = ty::region_existential_bound(region);\n+                let onceness = ast::Many;\n                 (None, onceness, bounds)\n             }\n         }"}, {"sha": "d3879e49034b19df674b54cf13aa161b7135fa4b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -315,23 +315,6 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 get_method_index(tcx, &*new_trait_ref,\n                                  trait_ref.clone(), method_num);\n \n-            // FIXME Hacky. By-value `self` methods in objects ought to be\n-            // just a special case of passing ownership of a DST value\n-            // as a parameter. *But* we currently hack them in and tie them to\n-            // the particulars of the `Box` type. So basically for a `fn foo(self,...)`\n-            // method invoked on an object, we don't want the receiver type to be\n-            // `TheTrait`, but rather `Box<TheTrait>`. Yuck.\n-            let mut m = m;\n-            match m.explicit_self {\n-                ty::ByValueExplicitSelfCategory => {\n-                    let mut n = (*m).clone();\n-                    let self_ty = n.fty.sig.inputs[0];\n-                    n.fty.sig.inputs[0] = ty::mk_uniq(tcx, self_ty);\n-                    m = Rc::new(n);\n-                }\n-                _ => { }\n-            }\n-\n             let xform_self_ty =\n                 this.xform_self_ty(&m, &new_trait_ref.substs);\n "}, {"sha": "fdc57579d072bebf88bf139e8c28c2533194c979", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -136,7 +136,7 @@ mod callee;\n /// closures defined within the function.  For example:\n ///\n ///     fn foo() {\n-///         bar(proc() { ... })\n+///         bar(move|| { ... })\n ///     }\n ///\n /// Here, the function `foo()` and the closure passed to\n@@ -2122,14 +2122,6 @@ fn try_overloaded_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n         write_call(fcx, call_expression, output_type);\n \n-        if !fcx.tcx().sess.features.borrow().unboxed_closures {\n-            span_err!(fcx.tcx().sess, call_expression.span, E0056,\n-                \"overloaded calls are experimental\");\n-            span_help!(fcx.tcx().sess, call_expression.span,\n-                \"add `#![feature(unboxed_closures)]` to \\\n-                the crate attributes to enable\");\n-        }\n-\n         return true\n     }\n \n@@ -2666,7 +2658,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n         for (i, arg) in args.iter().take(t).enumerate() {\n             let is_block = match arg.node {\n-                ast::ExprClosure(..) | ast::ExprProc(..) => true,\n+                ast::ExprClosure(..) => true,\n                 _ => false\n             };\n \n@@ -3997,14 +3989,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprClosure(_, opt_kind, ref decl, ref body) => {\n           closure::check_expr_closure(fcx, expr, opt_kind, &**decl, &**body, expected);\n       }\n-      ast::ExprProc(ref decl, ref body) => {\n-          closure::check_boxed_closure(fcx,\n-                                       expr,\n-                                       ty::UniqTraitStore,\n-                                       &**decl,\n-                                       &**body,\n-                                       expected);\n-      }\n       ast::ExprBlock(ref b) => {\n         check_block_with_expected(fcx, &**b, expected);\n         fcx.write_ty(id, fcx.node_ty(b.id));\n@@ -5159,6 +5143,9 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n \n             ast::ParenthesizedParameters(ref data) => {\n+                fcx.tcx().sess.span_err(\n+                    span,\n+                    \"parenthesized parameters may only be used with a trait\");\n                 push_explicit_parenthesized_parameters_from_segment_to_substs(\n                     fcx, space, span, type_defs, data, substs);\n             }"}, {"sha": "9f75b9764ebd8581df6f83dc1d8da3d640eac2e7", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -714,7 +714,6 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr);\n         }\n \n-        ast::ExprProc(_, ref body) |\n         ast::ExprClosure(_, _, _, ref body) => {\n             check_expr_fn_block(rcx, expr, &**body);\n         }\n@@ -936,8 +935,9 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 let cause = traits::ObligationCause::new(freevar.span, rcx.fcx.body_id, code);\n                 rcx.fcx.register_builtin_bound(var_ty, builtin_bound, cause);\n             }\n+\n             type_must_outlive(\n-                rcx, infer::RelateProcBound(expr.span, var_node_id, var_ty),\n+                rcx, infer::FreeVariable(expr.span, var_node_id),\n                 var_ty, bounds.region_bound);\n         }\n     }"}, {"sha": "415a3d53fb28448c8a5f08fb2814b6fa67a98d70", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -149,14 +149,6 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  object_trait: &ty::TraitRef<'tcx>,\n                                  span: Span) {\n-    // Skip the fn_once lang item trait since only the compiler should call\n-    // `call_once` which is the method which takes self by value. What could go\n-    // wrong?\n-    match tcx.lang_items.fn_once_trait() {\n-        Some(def_id) if def_id == object_trait.def_id => return,\n-        _ => {}\n-    }\n-\n     let trait_items = ty::trait_items(tcx, object_trait.def_id);\n \n     let mut errors = Vec::new();"}, {"sha": "8d94cf5dd5e96f1fb3e03b3d2590e81bfbf23414", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -121,8 +121,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n                                     MethodCall::expr(e.id));\n \n         match e.node {\n-            ast::ExprClosure(_, _, ref decl, _) |\n-            ast::ExprProc(ref decl, _) => {\n+            ast::ExprClosure(_, _, ref decl, _) => {\n                 for input in decl.inputs.iter() {\n                     let _ = self.visit_node_id(ResolvingExpr(e.span),\n                                                input.id);"}, {"sha": "8045dab6c2d6780cd241b15bc02fcce7a2599705", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -1165,12 +1165,19 @@ pub enum Type {\n         mutability: Mutability,\n         type_: Box<Type>,\n     },\n+\n+    // <Type as Trait>::Name\n     QPath {\n         name: String,\n         self_type: Box<Type>,\n         trait_: Box<Type>\n     },\n-    // region, raw, other boxes, mutable\n+\n+    // _\n+    Infer,\n+\n+    // for<'a> Foo(&'a)\n+    PolyTraitRef(Vec<TyParamBound>),\n }\n \n #[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash)]\n@@ -1307,11 +1314,18 @@ impl Clean<Type> for ast::Ty {\n                 }\n             }\n             TyClosure(ref c) => Closure(box c.clean(cx)),\n-            TyProc(ref c) => Proc(box c.clean(cx)),\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyParen(ref ty) => ty.clean(cx),\n             TyQPath(ref qp) => qp.clean(cx),\n-            ref x => panic!(\"Unimplemented type {}\", x),\n+            TyPolyTraitRef(ref bounds) => {\n+                PolyTraitRef(bounds.clean(cx))\n+            },\n+            TyInfer(..) => {\n+                Infer\n+            },\n+            TyTypeof(..) => {\n+                panic!(\"Unimplemented type {}\", self.node)\n+            },\n         }\n     }\n }"}, {"sha": "cf92a71369fa33524d1e6ebaaa14f5ff22ff19fb", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -390,6 +390,16 @@ impl fmt::Show for clean::Type {\n                 try!(resolved_path(f, did, path, false));\n                 tybounds(f, typarams)\n             }\n+            clean::PolyTraitRef(ref bounds) => {\n+                for (i, bound) in bounds.iter().enumerate() {\n+                    if i != 0 {\n+                        try!(write!(f, \" + \"));\n+                    }\n+                    try!(write!(f, \"{}\", *bound));\n+                }\n+                Ok(())\n+            }\n+            clean::Infer => write!(f, \"_\"),\n             clean::Self(..) => f.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => primitive_link(f, prim, prim.to_string()),\n             clean::Closure(ref decl) => {"}, {"sha": "78117c9cb06d43b5c1249ada912af35317e13e83", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -342,7 +342,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n-    let (mut krate, analysis) = std::task::try(proc() {\n+    let (mut krate, analysis) = std::task::try(move |:| {\n         let cr = cr;\n         core::run_core(libs, cfgs, externs, &cr, triple)\n     }).map_err(|_| \"rustc failed\").unwrap();"}, {"sha": "0c64a0d29dffe71ba4caed1877535fdd4792e244", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -15,6 +15,7 @@ use std::io;\n use std::os;\n use std::str;\n use std::string::String;\n+use std::thunk::Thunk;\n \n use std::collections::{HashSet, HashMap};\n use testing;\n@@ -142,7 +143,7 @@ fn runtest(test: &str, cratename: &str, libs: Vec<Path>, externs: core::Externs,\n     let w1 = io::ChanWriter::new(tx);\n     let w2 = w1.clone();\n     let old = io::stdio::set_stderr(box w1);\n-    spawn(proc() {\n+    spawn(move |:| {\n         let mut p = io::ChanReader::new(rx);\n         let mut err = match old {\n             Some(old) => {\n@@ -282,15 +283,15 @@ impl Collector {\n                 ignore: should_ignore,\n                 should_fail: testing::ShouldFail::No, // compiler failures are test failures\n             },\n-            testfn: testing::DynTestFn(proc() {\n+            testfn: testing::DynTestFn(Thunk::new(move|| {\n                 runtest(test.as_slice(),\n                         cratename.as_slice(),\n                         libs,\n                         externs,\n                         should_fail,\n                         no_run,\n                         as_test_harness);\n-            }),\n+            }))\n         });\n     }\n "}, {"sha": "8be77d9b34dddff5fdd8d9c49e7cabd1b05c3814", "filename": "src/librustrt/at_exit_imp.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fat_exit_imp.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -18,10 +18,11 @@ use alloc::boxed::Box;\n use collections::vec::Vec;\n use core::atomic;\n use core::mem;\n+use thunk::{Thunk};\n \n use exclusive::Exclusive;\n \n-type Queue = Exclusive<Vec<proc():Send>>;\n+type Queue = Exclusive<Vec<Thunk>>;\n \n static QUEUE: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n static RUNNING: atomic::AtomicBool = atomic::INIT_ATOMIC_BOOL;\n@@ -34,7 +35,7 @@ pub fn init() {\n     }\n }\n \n-pub fn push(f: proc():Send) {\n+pub fn push(f: Thunk) {\n     unsafe {\n         // Note that the check against 0 for the queue pointer is not atomic at\n         // all with respect to `run`, meaning that this could theoretically be a\n@@ -59,6 +60,6 @@ pub fn run() {\n     };\n \n     for to_run in cur.into_iter() {\n-        to_run();\n+        to_run.invoke(());\n     }\n }"}, {"sha": "bba81383f7b2ec772fc51f8b06764edf452556cb", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -639,7 +639,7 @@ mod tests {\n \n     #[test]\n     fn test_to_c_str_fail() {\n-        assert!(task::try(proc() { \"he\\x00llo\".to_c_str() }).is_err());\n+        assert!(task::try(move|| { \"he\\x00llo\".to_c_str() }).is_err());\n     }\n \n     #[test]"}, {"sha": "9adcc0a844dffb072b6abf616fdbb7ec2af90269", "filename": "src/librustrt/exclusive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fexclusive.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -99,7 +99,7 @@ mod tests {\n                 let (tx, rx) = channel();\n                 futures.push(rx);\n \n-                task::spawn(proc() {\n+                task::spawn(move || {\n                     for _ in range(0u, count) {\n                         **total.lock() += 1;\n                     }"}, {"sha": "f12f8e49801191d6ffbbdcf86704f7e7fb61e480", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -46,6 +46,7 @@ mod thread_local_storage;\n mod util;\n mod libunwind;\n mod stack_overflow;\n+pub mod thunk;\n \n pub mod args;\n pub mod bookkeeping;\n@@ -95,8 +96,8 @@ pub fn init(argc: int, argv: *const *const u8) {\n ///\n /// It is forbidden for procedures to register more `at_exit` handlers when they\n /// are running, and doing so will lead to a process abort.\n-pub fn at_exit(f: proc():Send) {\n-    at_exit_imp::push(f);\n+pub fn at_exit<F:FnOnce()+Send>(f: F) {\n+    at_exit_imp::push(thunk::Thunk::new(f));\n }\n \n /// One-time runtime cleanup."}, {"sha": "df733d7ee225be4a3b71e9c7bdb20e7211732ed9", "filename": "src/librustrt/local.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -59,7 +59,7 @@ mod test {\n \n     #[test]\n     fn thread_local_task_smoke_test() {\n-        Thread::start(proc() {\n+        Thread::start(move|| {\n             let task = box Task::new(None, None);\n             Local::put(task);\n             let task: Box<Task> = Local::take();\n@@ -69,7 +69,7 @@ mod test {\n \n     #[test]\n     fn thread_local_task_two_instances() {\n-        Thread::start(proc() {\n+        Thread::start(move|| {\n             let task = box Task::new(None, None);\n             Local::put(task);\n             let task: Box<Task> = Local::take();\n@@ -83,7 +83,7 @@ mod test {\n \n     #[test]\n     fn borrow_smoke_test() {\n-        Thread::start(proc() {\n+        Thread::start(move|| {\n             let task = box Task::new(None, None);\n             Local::put(task);\n \n@@ -97,7 +97,7 @@ mod test {\n \n     #[test]\n     fn borrow_with_return() {\n-        Thread::start(proc() {\n+        Thread::start(move|| {\n             let task = box Task::new(None, None);\n             Local::put(task);\n \n@@ -112,7 +112,7 @@ mod test {\n \n     #[test]\n     fn try_take() {\n-        Thread::start(proc() {\n+        Thread::start(move|| {\n             let task = box Task::new(None, None);\n             Local::put(task);\n "}, {"sha": "cbfb86a6ac7b2ac7ada773d9afa131ae587108d4", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -680,7 +680,7 @@ mod test {\n         static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             let guard = LK.lock();\n-            let t = Thread::start(proc() {\n+            let t = Thread::start(move|| {\n                 let guard = LK.lock();\n                 guard.signal();\n             });\n@@ -705,7 +705,7 @@ mod test {\n         static LK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n             LK.lock_noguard();\n-            let t = Thread::start(proc() {\n+            let t = Thread::start(move|| {\n                 LK.lock_noguard();\n                 LK.signal_noguard();\n                 LK.unlock_noguard();"}, {"sha": "37632f509c14a089f166b3ab7d8ce22ba946cbeb", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -21,6 +21,7 @@ use core::any::Any;\n use core::atomic::{AtomicUint, SeqCst};\n use core::iter::{IteratorExt, Take};\n use core::kinds::marker;\n+use core::ops::FnOnce;\n use core::mem;\n use core::ops::FnMut;\n use core::prelude::{Clone, Drop, Err, Iterator, None, Ok, Option, Send, Some};\n@@ -34,6 +35,7 @@ use stack;\n use unwind;\n use unwind::Unwinder;\n use collections::str::SendStr;\n+use thunk::Thunk;\n \n /// State associated with Rust tasks.\n ///\n@@ -67,7 +69,7 @@ enum TaskState {\n \n pub struct TaskOpts {\n     /// Invoke this procedure with the result of the task when it finishes.\n-    pub on_exit: Option<proc(Result): Send>,\n+    pub on_exit: Option<Thunk<Result>>,\n     /// A name for the task-to-be, for identification in panic messages\n     pub name: Option<SendStr>,\n     /// The size of the stack for the spawned task\n@@ -92,7 +94,7 @@ pub enum BlockedTask {\n \n /// Per-task state related to task death, killing, panic, etc.\n pub struct Death {\n-    pub on_exit: Option<proc(Result):Send>,\n+    pub on_exit: Option<Thunk<Result>>,\n     marker: marker::NoCopy,\n }\n \n@@ -116,7 +118,13 @@ impl Task {\n         }\n     }\n \n-    pub fn spawn(opts: TaskOpts, f: proc():Send) {\n+    pub fn spawn<F>(opts: TaskOpts, f: F)\n+        where F : FnOnce(), F : Send\n+    {\n+        Task::spawn_thunk(opts, Thunk::new(f))\n+    }\n+\n+    fn spawn_thunk(opts: TaskOpts, f: Thunk) {\n         let TaskOpts { name, stack_size, on_exit } = opts;\n \n         let mut task = box Task::new(None, None);\n@@ -138,7 +146,7 @@ impl Task {\n         // because by the time that this function is executing we've already\n         // consumed at least a little bit of stack (we don't know the exact byte\n         // address at which our stack started).\n-        Thread::spawn_stack(stack, proc() {\n+        Thread::spawn_stack(stack, move|| {\n             let something_around_the_top_of_the_stack = 1;\n             let addr = &something_around_the_top_of_the_stack as *const int;\n             let my_stack = addr as uint;\n@@ -150,7 +158,7 @@ impl Task {\n             task.stack_bounds = (my_stack - stack + 1024, my_stack);\n \n             let mut f = Some(f);\n-            drop(task.run(|| { f.take().unwrap()() }).destroy());\n+            drop(task.run(|| { f.take().unwrap().invoke(()) }).destroy());\n             drop(token);\n         })\n     }\n@@ -241,7 +249,7 @@ impl Task {\n         //        reconsideration to whether it's a reasonable thing to let a\n         //        task to do or not.\n         match what_to_do {\n-            Some(f) => { f(result) }\n+            Some(f) => { f.invoke(result) }\n             None => { drop(result) }\n         }\n \n@@ -500,14 +508,13 @@ mod test {\n     use super::*;\n     use std::prelude::*;\n     use std::task;\n-    use unwind;\n \n     #[test]\n     fn unwind() {\n-        let result = task::try(proc()());\n+        let result = task::try(move|| ());\n         rtdebug!(\"trying first assert\");\n         assert!(result.is_ok());\n-        let result = task::try::<()>(proc() panic!());\n+        let result = task::try(move|| -> () panic!());\n         rtdebug!(\"trying second assert\");\n         assert!(result.is_err());\n     }"}, {"sha": "175e057c22f2ea3e5f70b3147a778a6dc17c24e9", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -22,6 +22,7 @@ use alloc::boxed::Box;\n use core::mem;\n use core::uint;\n use libc;\n+use thunk::{Thunk};\n \n use stack;\n use stack_overflow;\n@@ -60,8 +61,8 @@ fn start_thread(main: *mut libc::c_void) -> imp::rust_thread_return {\n     unsafe {\n         stack::record_os_managed_stack_bounds(0, uint::MAX);\n         let handler = stack_overflow::Handler::new();\n-        let f: Box<proc()> = mem::transmute(main);\n-        (*f)();\n+        let f: Box<Thunk> = mem::transmute(main);\n+        f.invoke(());\n         drop(handler);\n         mem::transmute(0 as imp::rust_thread_return)\n     }\n@@ -113,23 +114,29 @@ impl Thread<()> {\n     /// to finish executing. This means that even if `join` is not explicitly\n     /// called, when the `Thread` falls out of scope its destructor will block\n     /// waiting for the OS thread.\n-    pub fn start<T: Send>(main: proc():Send -> T) -> Thread<T> {\n+    pub fn start<T,F>(main: F) -> Thread<T>\n+        where T:Send, F:FnOnce() -> T, F:Send\n+    {\n         Thread::start_stack(DEFAULT_STACK_SIZE, main)\n     }\n \n     /// Performs the same functionality as `start`, but specifies an explicit\n     /// stack size for the new thread.\n-    pub fn start_stack<T: Send>(stack: uint, main: proc():Send -> T) -> Thread<T> {\n-\n+    pub fn start_stack<T, F>(stack: uint, main: F) -> Thread<T>\n+        where T:Send, F:FnOnce() -> T, F:Send\n+    {\n         // We need the address of the packet to fill in to be stable so when\n         // `main` fills it in it's still valid, so allocate an extra box to do\n         // so.\n         let packet = box None;\n         let packet2: *mut Option<T> = unsafe {\n             *mem::transmute::<&Box<Option<T>>, *const *mut Option<T>>(&packet)\n         };\n-        let main = proc() unsafe { *packet2 = Some(main()); };\n-        let native = unsafe { imp::create(stack, box main) };\n+        let native = unsafe {\n+            imp::create(stack, Thunk::new(move |:| {\n+                *packet2 = Some(main.call_once(()));\n+            }))\n+        };\n \n         Thread {\n             native: native,\n@@ -144,15 +151,19 @@ impl Thread<()> {\n     /// This corresponds to creating threads in the 'detached' state on unix\n     /// systems. Note that platforms may not keep the main program alive even if\n     /// there are detached thread still running around.\n-    pub fn spawn(main: proc():Send) {\n+    pub fn spawn<F>(main: F)\n+        where F : FnOnce() + Send\n+    {\n         Thread::spawn_stack(DEFAULT_STACK_SIZE, main)\n     }\n \n     /// Performs the same functionality as `spawn`, but explicitly specifies a\n     /// stack size for the new thread.\n-    pub fn spawn_stack(stack: uint, main: proc():Send) {\n+    pub fn spawn_stack<F>(stack: uint, main: F)\n+        where F : FnOnce() + Send\n+    {\n         unsafe {\n-            let handle = imp::create(stack, box main);\n+            let handle = imp::create(stack, Thunk::new(main));\n             imp::detach(handle);\n         }\n     }\n@@ -190,8 +201,6 @@ impl<T: Send> Drop for Thread<T> {\n #[cfg(windows)]\n #[allow(non_snake_case)]\n mod imp {\n-    use core::prelude::*;\n-\n     use alloc::boxed::Box;\n     use core::cmp;\n     use core::mem;\n@@ -200,6 +209,7 @@ mod imp {\n     use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n                                        LPVOID, DWORD, LPDWORD, HANDLE};\n     use stack::RED_ZONE;\n+    use thunk::Thunk;\n \n     pub type rust_thread = HANDLE;\n     pub type rust_thread_return = DWORD;\n@@ -217,8 +227,9 @@ mod imp {\n         }\n     }\n \n-    pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n-        let arg: *mut libc::c_void = mem::transmute(p);\n+    pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n+        let arg: *mut libc::c_void = mem::transmute(box p);\n+\n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n         // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n@@ -234,7 +245,7 @@ mod imp {\n \n         if ret as uint == 0 {\n             // be sure to not leak the closure\n-            let _p: Box<proc():Send> = mem::transmute(arg);\n+            let _p: Box<Thunk> = mem::transmute(arg);\n             panic!(\"failed to spawn native thread: {}\", ret);\n         }\n         return ret;\n@@ -279,6 +290,7 @@ mod imp {\n     use core::ptr;\n     use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n     use libc;\n+    use thunk::Thunk;\n \n     use stack::RED_ZONE;\n \n@@ -409,7 +421,7 @@ mod imp {\n         }\n     }\n \n-    pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n+    pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(pthread_attr_init(&mut attr), 0);\n@@ -437,13 +449,13 @@ mod imp {\n             },\n         };\n \n-        let arg: *mut libc::c_void = mem::transmute(p);\n+        let arg: *mut libc::c_void = mem::transmute(box p); // must box since sizeof(p)=2*uint\n         let ret = pthread_create(&mut native, &attr, super::thread_start, arg);\n         assert_eq!(pthread_attr_destroy(&mut attr), 0);\n \n         if ret != 0 {\n             // be sure to not leak the closure\n-            let _p: Box<proc():Send> = mem::transmute(arg);\n+            let _p: Box<Box<FnOnce()+Send>> = mem::transmute(arg);\n             panic!(\"failed to spawn native thread: {}\", ret);\n         }\n         native\n@@ -531,17 +543,17 @@ mod tests {\n     use super::Thread;\n \n     #[test]\n-    fn smoke() { Thread::start(proc (){}).join(); }\n+    fn smoke() { Thread::start(move|| {}).join(); }\n \n     #[test]\n-    fn data() { assert_eq!(Thread::start(proc () { 1i }).join(), 1); }\n+    fn data() { assert_eq!(Thread::start(move|| { 1i }).join(), 1); }\n \n     #[test]\n-    fn detached() { Thread::spawn(proc () {}) }\n+    fn detached() { Thread::spawn(move|| {}) }\n \n     #[test]\n     fn small_stacks() {\n-        assert_eq!(42i, Thread::start_stack(0, proc () 42i).join());\n-        assert_eq!(42i, Thread::start_stack(1, proc () 42i).join());\n+        assert_eq!(42i, Thread::start_stack(0, move|| 42i).join());\n+        assert_eq!(42i, Thread::start_stack(1, move|| 42i).join());\n     }\n }"}, {"sha": "42e784959909fab1fa561399b5ef5a3979191658", "filename": "src/librustrt/thunk.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibrustrt%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthunk.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc::boxed::Box;\n+use core::kinds::Send;\n+use core::ops::FnOnce;\n+\n+pub struct Thunk<A=(),R=()> {\n+    invoke: Box<Invoke<A,R>+Send>\n+}\n+\n+impl<R> Thunk<(),R> {\n+    pub fn new<F>(func: F) -> Thunk<(),R>\n+        where F : FnOnce() -> R, F : Send\n+    {\n+        Thunk::with_arg(move|: ()| func())\n+    }\n+}\n+\n+impl<A,R> Thunk<A,R> {\n+    pub fn with_arg<F>(func: F) -> Thunk<A,R>\n+        where F : FnOnce(A) -> R, F : Send\n+    {\n+        Thunk {\n+            invoke: box func\n+        }\n+    }\n+\n+    pub fn invoke(self, arg: A) -> R {\n+        self.invoke.invoke(arg)\n+    }\n+}\n+\n+pub trait Invoke<A=(),R=()> {\n+    fn invoke(self: Box<Self>, arg: A) -> R;\n+}\n+\n+impl<A,R,F> Invoke<A,R> for F\n+    where F : FnOnce(A) -> R\n+{\n+    fn invoke(self: Box<F>, arg: A) -> R {\n+        let f = *self;\n+        f(arg)\n+    }\n+}"}, {"sha": "44e7291150ef9e0a9c27567a08ab91828a3b27a9", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -37,27 +37,28 @@\n \n use kinds::Send;\n use mem;\n-use ops::Drop;\n+use ops::{Drop, FnOnce};\n use option::Option;\n use option::Option::{Some, None};\n use ptr::RawPtr;\n use ptr;\n use raw;\n use slice::AsSlice;\n+use thunk::{Thunk};\n \n /// The type representing a foreign chunk of memory\n pub struct CVec<T> {\n     base: *mut T,\n     len: uint,\n-    dtor: Option<proc():Send>,\n+    dtor: Option<Thunk>,\n }\n \n #[unsafe_destructor]\n impl<T> Drop for CVec<T> {\n     fn drop(&mut self) {\n         match self.dtor.take() {\n             None => (),\n-            Some(f) => f()\n+            Some(f) => f.invoke(())\n         }\n     }\n }\n@@ -90,15 +91,20 @@ impl<T> CVec<T> {\n     ///\n     /// * base - A foreign pointer to a buffer\n     /// * len - The number of elements in the buffer\n-    /// * dtor - A proc to run when the value is destructed, useful\n+    /// * dtor - A fn to run when the value is destructed, useful\n     ///          for freeing the buffer, etc.\n-    pub unsafe fn new_with_dtor(base: *mut T, len: uint,\n-                                dtor: proc():Send) -> CVec<T> {\n+    pub unsafe fn new_with_dtor<F>(base: *mut T,\n+                                   len: uint,\n+                                   dtor: F)\n+                                   -> CVec<T>\n+        where F : FnOnce(), F : Send\n+    {\n         assert!(base != ptr::null_mut());\n+        let dtor: Thunk = Thunk::new(dtor);\n         CVec {\n             base: base,\n             len: len,\n-            dtor: Some(dtor),\n+            dtor: Some(dtor)\n         }\n     }\n \n@@ -177,8 +183,9 @@ mod tests {\n             let mem = libc::malloc(n as libc::size_t);\n             if mem.is_null() { ::alloc::oom() }\n \n-            CVec::new_with_dtor(mem as *mut u8, n,\n-                proc() { libc::free(mem as *mut libc::c_void); })\n+            CVec::new_with_dtor(mem as *mut u8,\n+                                n,\n+                                move|| { libc::free(mem as *mut libc::c_void); })\n         }\n     }\n \n@@ -218,8 +225,9 @@ mod tests {\n     #[test]\n     fn test_unwrap() {\n         unsafe {\n-            let cv = CVec::new_with_dtor(1 as *mut int, 0,\n-                proc() { panic!(\"Don't run this destructor!\") });\n+            let cv = CVec::new_with_dtor(1 as *mut int,\n+                                         0,\n+                                         move|:| panic!(\"Don't run this destructor!\"));\n             let p = cv.unwrap();\n             assert_eq!(p, 1 as *mut int);\n         }"}, {"sha": "0a5b3e5771b79d8d10d32a5493d03242aeff320e", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -72,7 +72,7 @@\n //! ```\n //! // Create a simple streaming channel\n //! let (tx, rx) = channel();\n-//! spawn(proc() {\n+//! spawn(move|| {\n //!     tx.send(10i);\n //! });\n //! assert_eq!(rx.recv(), 10i);\n@@ -87,7 +87,7 @@\n //! let (tx, rx) = channel();\n //! for i in range(0i, 10i) {\n //!     let tx = tx.clone();\n-//!     spawn(proc() {\n+//!     spawn(move|| {\n //!         tx.send(i);\n //!     })\n //! }\n@@ -112,7 +112,7 @@\n //!\n //! ```\n //! let (tx, rx) = sync_channel::<int>(0);\n-//! spawn(proc() {\n+//! spawn(move|| {\n //!     // This will wait for the parent task to start receiving\n //!     tx.send(53);\n //! });\n@@ -465,7 +465,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// let (tx, rx) = channel();\n ///\n /// // Spawn off an expensive computation\n-/// spawn(proc() {\n+/// spawn(move|| {\n /// #   fn expensive_computation() {}\n ///     tx.send(expensive_computation());\n /// });\n@@ -504,7 +504,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// // this returns immediately\n /// tx.send(1i);\n ///\n-/// spawn(proc() {\n+/// spawn(move|| {\n ///     // this will block until the previous message has been received\n ///     tx.send(2i);\n /// });\n@@ -1065,7 +1065,7 @@ mod test {\n \n     test!(fn smoke_threads() {\n         let (tx, rx) = channel::<int>();\n-        spawn(proc() {\n+        spawn(move|| {\n             tx.send(1);\n         });\n         assert_eq!(rx.recv(), 1);\n@@ -1093,7 +1093,7 @@ mod test {\n \n     test!(fn port_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n-        spawn(proc() {\n+        spawn(move|| {\n             rx.recv();\n         });\n         loop { tx.send(1) }\n@@ -1102,7 +1102,7 @@ mod test {\n     test!(fn port_gone_concurrent_shared() {\n         let (tx, rx) = channel::<int>();\n         let tx2 = tx.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             rx.recv();\n         });\n         loop {\n@@ -1127,7 +1127,7 @@ mod test {\n \n     test!(fn chan_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n-        spawn(proc() {\n+        spawn(move|| {\n             tx.send(1);\n             tx.send(1);\n         });\n@@ -1136,7 +1136,7 @@ mod test {\n \n     test!(fn stress() {\n         let (tx, rx) = channel::<int>();\n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0u, 10000) { tx.send(1i); }\n         });\n         for _ in range(0u, 10000) {\n@@ -1150,7 +1150,7 @@ mod test {\n         let (tx, rx) = channel::<int>();\n         let (dtx, drx) = channel::<()>();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0, AMT * NTHREADS) {\n                 assert_eq!(rx.recv(), 1);\n             }\n@@ -1163,7 +1163,7 @@ mod test {\n \n         for _ in range(0, NTHREADS) {\n             let tx = tx.clone();\n-            spawn(proc() {\n+            spawn(move|| {\n                 for _ in range(0, AMT) { tx.send(1); }\n             });\n         }\n@@ -1177,15 +1177,15 @@ mod test {\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n         let tx4 = tx3.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             tx1.send(());\n             for _ in range(0i, 40) {\n                 assert_eq!(rx2.recv(), 1);\n             }\n             tx3.send(());\n         });\n         rx1.recv();\n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0i, 40) {\n                 tx2.send(1);\n             }\n@@ -1199,7 +1199,7 @@ mod test {\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<int>();\n         let (dtx, drx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0i, 40) {\n                 assert_eq!(rx.recv(), 1);\n             }\n@@ -1217,12 +1217,12 @@ mod test {\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n         let tx4 = tx3.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             assert_eq!(rx1.recv(), 1);\n             tx2.send(2);\n             tx4.send(());\n         });\n-        spawn(proc() {\n+        spawn(move|| {\n             tx1.send(1);\n             assert_eq!(rx2.recv(), 2);\n             tx3.send(());\n@@ -1252,7 +1252,7 @@ mod test {\n \n     test!(fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = task::try(proc() {\n+        let res = task::try(move|| {\n             let (tx, rx) = channel::<int>();\n             drop(tx);\n             rx.recv();\n@@ -1312,7 +1312,7 @@ mod test {\n \n     test!(fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<Box<int>>();\n-        spawn(proc() {\n+        spawn(move|| {\n             assert!(rx.recv() == box 10);\n         });\n \n@@ -1321,10 +1321,10 @@ mod test {\n \n     test!(fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = channel::<Box<int>>();\n-        spawn(proc() {\n+        spawn(move|| {\n             drop(tx);\n         });\n-        let res = task::try(proc() {\n+        let res = task::try(move|| {\n             assert!(rx.recv() == box 10);\n         });\n         assert!(res.is_err());\n@@ -1333,7 +1333,7 @@ mod test {\n     test!(fn oneshot_multi_thread_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n-            spawn(proc() {\n+            spawn(move|| {\n                 drop(rx);\n             });\n             drop(tx);\n@@ -1343,10 +1343,10 @@ mod test {\n     test!(fn oneshot_multi_thread_send_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n-            spawn(proc() {\n+            spawn(move|| {\n                 drop(rx);\n             });\n-            let _ = task::try(proc() {\n+            let _ = task::try(move|| {\n                 tx.send(1);\n             });\n         }\n@@ -1355,14 +1355,14 @@ mod test {\n     test!(fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n-            spawn(proc() {\n-                let res = task::try(proc() {\n+            spawn(move|| {\n+                let res = task::try(move|| {\n                     rx.recv();\n                 });\n                 assert!(res.is_err());\n             });\n-            spawn(proc() {\n-                spawn(proc() {\n+            spawn(move|| {\n+                spawn(move|| {\n                     drop(tx);\n                 });\n             });\n@@ -1372,10 +1372,10 @@ mod test {\n     test!(fn oneshot_multi_thread_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel();\n-            spawn(proc() {\n+            spawn(move|| {\n                 tx.send(box 10i);\n             });\n-            spawn(proc() {\n+            spawn(move|| {\n                 assert!(rx.recv() == box 10i);\n             });\n         }\n@@ -1391,7 +1391,7 @@ mod test {\n             fn send(tx: Sender<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                spawn(proc() {\n+                spawn(move|| {\n                     tx.send(box i);\n                     send(tx, i + 1);\n                 });\n@@ -1400,7 +1400,7 @@ mod test {\n             fn recv(rx: Receiver<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                spawn(proc() {\n+                spawn(move|| {\n                     assert!(rx.recv() == box i);\n                     recv(rx, i + 1);\n                 });\n@@ -1420,7 +1420,7 @@ mod test {\n         let total = stress_factor() + 100;\n         for _ in range(0, total) {\n             let tx = tx.clone();\n-            spawn(proc() {\n+            spawn(move|| {\n                 tx.send(());\n             });\n         }\n@@ -1434,7 +1434,7 @@ mod test {\n         let (tx, rx) = channel::<int>();\n         let (total_tx, total_rx) = channel::<int>();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n@@ -1453,7 +1453,7 @@ mod test {\n         let (tx, rx) = channel::<int>();\n         let (count_tx, count_rx) = channel();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -1477,7 +1477,7 @@ mod test {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             rx2.recv();\n             tx1.send(1);\n             tx3.send(());\n@@ -1501,7 +1501,7 @@ mod test {\n     test!(fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             rx.recv(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n             tx2.send(());\n@@ -1522,7 +1522,7 @@ mod test {\n         use rustrt::thread::Thread;\n \n         let (tx, rx) = channel();\n-        let t = Thread::start(proc() {\n+        let t = Thread::start(move|| {\n             for _ in range(0u, 1000) {\n                 tx.send(());\n             }\n@@ -1538,7 +1538,7 @@ mod test {\n \n         let (tx, rx) = channel();\n         let (cdone, pdone) = channel();\n-        let t = Thread::start(proc() {\n+        let t = Thread::start(move|| {\n             let mut hits = 0u;\n             while hits < 10 {\n                 match rx.try_recv() {\n@@ -1591,7 +1591,7 @@ mod sync_tests {\n \n     test!(fn smoke_threads() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(proc() {\n+        spawn(move|| {\n             tx.send(1);\n         });\n         assert_eq!(rx.recv(), 1);\n@@ -1613,7 +1613,7 @@ mod sync_tests {\n \n     test!(fn port_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(proc() {\n+        spawn(move|| {\n             rx.recv();\n         });\n         loop { tx.send(1) }\n@@ -1622,7 +1622,7 @@ mod sync_tests {\n     test!(fn port_gone_concurrent_shared() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             rx.recv();\n         });\n         loop {\n@@ -1647,7 +1647,7 @@ mod sync_tests {\n \n     test!(fn chan_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(proc() {\n+        spawn(move|| {\n             tx.send(1);\n             tx.send(1);\n         });\n@@ -1656,7 +1656,7 @@ mod sync_tests {\n \n     test!(fn stress() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0u, 10000) { tx.send(1); }\n         });\n         for _ in range(0u, 10000) {\n@@ -1670,7 +1670,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (dtx, drx) = sync_channel::<()>(0);\n \n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0, AMT * NTHREADS) {\n                 assert_eq!(rx.recv(), 1);\n             }\n@@ -1683,7 +1683,7 @@ mod sync_tests {\n \n         for _ in range(0, NTHREADS) {\n             let tx = tx.clone();\n-            spawn(proc() {\n+            spawn(move|| {\n                 for _ in range(0, AMT) { tx.send(1); }\n             });\n         }\n@@ -1712,7 +1712,7 @@ mod sync_tests {\n \n     test!(fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = task::try(proc() {\n+        let res = task::try(move|| {\n             let (tx, rx) = sync_channel::<int>(0);\n             drop(tx);\n             rx.recv();\n@@ -1777,7 +1777,7 @@ mod sync_tests {\n \n     test!(fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n-        spawn(proc() {\n+        spawn(move|| {\n             assert!(rx.recv() == box 10);\n         });\n \n@@ -1786,10 +1786,10 @@ mod sync_tests {\n \n     test!(fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n-        spawn(proc() {\n+        spawn(move|| {\n             drop(tx);\n         });\n-        let res = task::try(proc() {\n+        let res = task::try(move|| {\n             assert!(rx.recv() == box 10);\n         });\n         assert!(res.is_err());\n@@ -1798,7 +1798,7 @@ mod sync_tests {\n     test!(fn oneshot_multi_thread_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n-            spawn(proc() {\n+            spawn(move|| {\n                 drop(rx);\n             });\n             drop(tx);\n@@ -1808,10 +1808,10 @@ mod sync_tests {\n     test!(fn oneshot_multi_thread_send_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n-            spawn(proc() {\n+            spawn(move|| {\n                 drop(rx);\n             });\n-            let _ = task::try(proc() {\n+            let _ = task::try(move|| {\n                 tx.send(1);\n             });\n         }\n@@ -1820,14 +1820,14 @@ mod sync_tests {\n     test!(fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n-            spawn(proc() {\n-                let res = task::try(proc() {\n+            spawn(move|| {\n+                let res = task::try(move|| {\n                     rx.recv();\n                 });\n                 assert!(res.is_err());\n             });\n-            spawn(proc() {\n-                spawn(proc() {\n+            spawn(move|| {\n+                spawn(move|| {\n                     drop(tx);\n                 });\n             });\n@@ -1837,10 +1837,10 @@ mod sync_tests {\n     test!(fn oneshot_multi_thread_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n-            spawn(proc() {\n+            spawn(move|| {\n                 tx.send(box 10i);\n             });\n-            spawn(proc() {\n+            spawn(move|| {\n                 assert!(rx.recv() == box 10i);\n             });\n         }\n@@ -1856,7 +1856,7 @@ mod sync_tests {\n             fn send(tx: SyncSender<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                spawn(proc() {\n+                spawn(move|| {\n                     tx.send(box i);\n                     send(tx, i + 1);\n                 });\n@@ -1865,7 +1865,7 @@ mod sync_tests {\n             fn recv(rx: Receiver<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                spawn(proc() {\n+                spawn(move|| {\n                     assert!(rx.recv() == box i);\n                     recv(rx, i + 1);\n                 });\n@@ -1885,7 +1885,7 @@ mod sync_tests {\n         let total = stress_factor() + 100;\n         for _ in range(0, total) {\n             let tx = tx.clone();\n-            spawn(proc() {\n+            spawn(move|| {\n                 tx.send(());\n             });\n         }\n@@ -1899,7 +1899,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (total_tx, total_rx) = sync_channel::<int>(0);\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n@@ -1918,7 +1918,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -1942,7 +1942,7 @@ mod sync_tests {\n         let (tx1, rx1) = sync_channel::<int>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n         let (tx3, rx3) = sync_channel::<()>(1);\n-        spawn(proc() {\n+        spawn(move|| {\n             rx2.recv();\n             tx1.send(1);\n             tx3.send(());\n@@ -1966,7 +1966,7 @@ mod sync_tests {\n     test!(fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let (tx2, rx2) = sync_channel::<()>(0);\n-        spawn(proc() {\n+        spawn(move|| {\n             rx.recv(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n             tx2.send(());\n@@ -1988,7 +1988,7 @@ mod sync_tests {\n \n         let (tx, rx) = sync_channel::<()>(0);\n         let (cdone, pdone) = channel();\n-        let t = Thread::start(proc() {\n+        let t = Thread::start(move|| {\n             let mut hits = 0u;\n             while hits < 10 {\n                 match rx.try_recv() {\n@@ -2008,20 +2008,20 @@ mod sync_tests {\n \n     test!(fn send_opt1() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(proc() { rx.recv(); });\n+        spawn(move|| { rx.recv(); });\n         assert_eq!(tx.send_opt(1), Ok(()));\n     })\n \n     test!(fn send_opt2() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(proc() { drop(rx); });\n+        spawn(move|| { drop(rx); });\n         assert_eq!(tx.send_opt(1), Err(1));\n     })\n \n     test!(fn send_opt3() {\n         let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.send_opt(1), Ok(()));\n-        spawn(proc() { drop(rx); });\n+        spawn(move|| { drop(rx); });\n         assert_eq!(tx.send_opt(1), Err(1));\n     })\n \n@@ -2030,11 +2030,11 @@ mod sync_tests {\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             assert_eq!(tx.send_opt(1), Err(1));\n             done.send(());\n         });\n-        spawn(proc() {\n+        spawn(move|| {\n             assert_eq!(tx2.send_opt(2), Err(2));\n             done2.send(());\n         });\n@@ -2063,7 +2063,7 @@ mod sync_tests {\n \n     test!(fn try_send4() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0u, 1000) { task::deschedule(); }\n             assert_eq!(tx.try_send(1), Ok(()));\n         });\n@@ -2075,7 +2075,7 @@ mod sync_tests {\n             let (tx1, rx1) = sync_channel::<()>(3);\n             let (tx2, rx2) = sync_channel::<()>(3);\n \n-            spawn(proc() {\n+            spawn(move|| {\n                 rx1.recv();\n                 tx2.try_send(()).unwrap();\n             });"}, {"sha": "db4e3eac449507992df1bb8932c5ec6d6c732cf4", "filename": "src/libstd/comm/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fcomm%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fcomm%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmpsc_queue.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -178,7 +178,7 @@ mod tests {\n         for _ in range(0, nthreads) {\n             let tx = tx.clone();\n             let q = q.clone();\n-            spawn(proc() {\n+            spawn(move|| {\n                 for i in range(0, nmsgs) {\n                     q.push(i);\n                 }"}, {"sha": "e145b0df7f32acfafff418965f02fe4092a19e94", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -403,7 +403,7 @@ mod test {\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<int>();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0u, 20) { task::deschedule(); }\n             tx1.send(1);\n             rx3.recv();\n@@ -426,7 +426,7 @@ mod test {\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0u, 20) { task::deschedule(); }\n             tx1.send(1);\n             tx2.send(2);\n@@ -452,7 +452,7 @@ mod test {\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             for i in range(0, AMT) {\n                 if i % 2 == 0 {\n                     tx1.send(i);\n@@ -477,7 +477,7 @@ mod test {\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             rx3.recv();\n             tx1.clone();\n             assert_eq!(rx3.try_recv(), Err(Empty));\n@@ -498,7 +498,7 @@ mod test {\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             rx3.recv();\n             tx1.clone();\n             assert_eq!(rx3.try_recv(), Err(Empty));\n@@ -518,7 +518,7 @@ mod test {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let s = Select::new();\n             let mut h1 = s.handle(&rx1);\n             let mut h2 = s.handle(&rx2);\n@@ -624,7 +624,7 @@ mod test {\n     test!(fn oneshot_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             select! {\n                 () = rx1.recv() => {}\n             }\n@@ -643,7 +643,7 @@ mod test {\n         tx1.send(());\n         rx1.recv();\n         rx1.recv();\n-        spawn(proc() {\n+        spawn(move|| {\n             select! {\n                 () = rx1.recv() => {}\n             }\n@@ -661,7 +661,7 @@ mod test {\n         drop(tx1.clone());\n         tx1.send(());\n         rx1.recv();\n-        spawn(proc() {\n+        spawn(move|| {\n             select! {\n                 () = rx1.recv() => {}\n             }\n@@ -683,7 +683,7 @@ mod test {\n \n     test!(fn sync2() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0u, 100) { task::deschedule() }\n             tx.send(1);\n         });\n@@ -695,8 +695,8 @@ mod test {\n     test!(fn sync3() {\n         let (tx1, rx1) = sync_channel::<int>(0);\n         let (tx2, rx2): (Sender<int>, Receiver<int>) = channel();\n-        spawn(proc() { tx1.send(1); });\n-        spawn(proc() { tx2.send(2); });\n+        spawn(move|| { tx1.send(1); });\n+        spawn(move|| { tx2.send(2); });\n         select! {\n             n = rx1.recv() => {\n                 assert_eq!(n, 1);"}, {"sha": "db8fff772a4d3a6b97e432b23fd911b38a1e7ada", "filename": "src/libstd/comm/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fcomm%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fcomm%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fspsc_queue.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -316,7 +316,7 @@ mod test {\n \n             let (tx, rx) = channel();\n             let q2 = q.clone();\n-            spawn(proc() {\n+            spawn(move|| {\n                 for _ in range(0u, 100000) {\n                     loop {\n                         match q2.pop() {"}, {"sha": "308dc0941013818b619adf070da157988b193ebf", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -161,7 +161,7 @@ mod test {\n     #[test]\n     fn test_rx_reader() {\n         let (tx, rx) = channel();\n-        task::spawn(proc() {\n+        task::spawn(move|| {\n           tx.send(vec![1u8, 2u8]);\n           tx.send(vec![]);\n           tx.send(vec![3u8, 4u8]);\n@@ -203,7 +203,7 @@ mod test {\n     #[test]\n     fn test_rx_buffer() {\n         let (tx, rx) = channel();\n-        task::spawn(proc() {\n+        task::spawn(move|| {\n           tx.send(b\"he\".to_vec());\n           tx.send(b\"llo wo\".to_vec());\n           tx.send(b\"\".to_vec());\n@@ -229,7 +229,7 @@ mod test {\n         writer.write_be_u32(42).unwrap();\n \n         let wanted = vec![0u8, 0u8, 0u8, 42u8];\n-        let got = match task::try(proc() { rx.recv() }) {\n+        let got = match task::try(move|| { rx.recv() }) {\n             Ok(got) => got,\n             Err(_) => panic!(),\n         };"}, {"sha": "d21e0f57b07067b02a8dfcb0bba6f57f3f140372", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -119,7 +119,7 @@\n //!     for stream in acceptor.incoming() {\n //!         match stream {\n //!             Err(e) => { /* connection failed */ }\n-//!             Ok(stream) => spawn(proc() {\n+//!             Ok(stream) => spawn(move|| {\n //!                 // connection succeeded\n //!                 handle_client(stream)\n //!             })"}, {"sha": "9f2f41c002108425e16c3eaa3e9bd2602ee272a8", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -273,13 +273,16 @@ mod tests {\n     use io::fs::PathExtensions;\n     use time::Duration;\n \n-    pub fn smalltest(server: proc(UnixStream):Send, client: proc(UnixStream):Send) {\n+    pub fn smalltest<F,G>(server: F, client: G)\n+        where F : FnOnce(UnixStream), F : Send,\n+              G : FnOnce(UnixStream), G : Send\n+    {\n         let path1 = next_test_unix();\n         let path2 = path1.clone();\n \n         let mut acceptor = UnixListener::bind(&path1).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             match UnixStream::connect(&path2) {\n                 Ok(c) => client(c),\n                 Err(e) => panic!(\"failed connect: {}\", e),\n@@ -321,30 +324,30 @@ mod tests {\n \n     #[test]\n     fn smoke() {\n-        smalltest(proc(mut server) {\n+        smalltest(move |mut server| {\n             let mut buf = [0];\n             server.read(&mut buf).unwrap();\n             assert!(buf[0] == 99);\n-        }, proc(mut client) {\n+        }, move|mut client| {\n             client.write(&[99]).unwrap();\n         })\n     }\n \n     #[cfg_attr(windows, ignore)] // FIXME(#12516)\n     #[test]\n     fn read_eof() {\n-        smalltest(proc(mut server) {\n+        smalltest(move|mut server| {\n             let mut buf = [0];\n             assert!(server.read(&mut buf).is_err());\n             assert!(server.read(&mut buf).is_err());\n-        }, proc(_client) {\n+        }, move|_client| {\n             // drop the client\n         })\n     }\n \n     #[test]\n     fn write_begone() {\n-        smalltest(proc(mut server) {\n+        smalltest(move|mut server| {\n             let buf = [0];\n             loop {\n                 match server.write(&buf) {\n@@ -358,7 +361,7 @@ mod tests {\n                     }\n                 }\n             }\n-        }, proc(_client) {\n+        }, move|_client| {\n             // drop the client\n         })\n     }\n@@ -374,7 +377,7 @@ mod tests {\n             Err(e) => panic!(\"failed listen: {}\", e),\n         };\n \n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0u, times) {\n                 let mut stream = UnixStream::connect(&path2);\n                 match stream.write(&[100]) {\n@@ -408,7 +411,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             let mut buf = [0, 0];\n             debug!(\"client reading\");\n@@ -424,7 +427,7 @@ mod tests {\n \n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s2 = s2;\n             rx1.recv();\n             debug!(\"writer writing\");\n@@ -447,7 +450,7 @@ mod tests {\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             s.write(&[1]).unwrap();\n             rx.recv();\n@@ -459,7 +462,7 @@ mod tests {\n         let s2 = s1.clone();\n \n         let (done, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n             s2.read(&mut buf).unwrap();\n@@ -478,7 +481,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             let buf = &mut [0, 1];\n             s.read(buf).unwrap();\n@@ -489,7 +492,7 @@ mod tests {\n         let s2 = s1.clone();\n \n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s2 = s2;\n             s2.write(&[1]).unwrap();\n             tx.send(());\n@@ -536,7 +539,7 @@ mod tests {\n         // continue to receive any pending connections.\n         let (tx, rx) = channel();\n         let addr2 = addr.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             tx.send(UnixStream::connect(&addr2).unwrap());\n         });\n         let l = rx.recv();\n@@ -554,7 +557,7 @@ mod tests {\n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n         let addr2 = addr.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             drop(UnixStream::connect(&addr2).unwrap());\n         });\n         a.accept().unwrap();\n@@ -592,7 +595,7 @@ mod tests {\n         let addr = next_test_unix();\n         let a = UnixListener::bind(&addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv_opt();\n@@ -629,7 +632,7 @@ mod tests {\n         let addr = next_test_unix();\n         let a = UnixListener::bind(&addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv_opt();\n@@ -638,7 +641,7 @@ mod tests {\n         let mut s = UnixStream::connect(&addr).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_err());\n             tx.send(());\n@@ -655,7 +658,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv();\n             assert!(s.write(&[0]).is_ok());\n@@ -693,7 +696,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv();\n             let mut amt = 0;\n@@ -722,7 +725,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv();\n             assert!(s.write(&[0]).is_ok());\n@@ -749,7 +752,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv();\n             assert!(s.write(&[0]).is_ok());\n@@ -759,7 +762,7 @@ mod tests {\n         let mut s = a.accept().unwrap();\n         let s2 = s.clone();\n         let (tx2, rx2) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_ok());\n             tx2.send(());\n@@ -781,10 +784,10 @@ mod tests {\n         let mut a2 = a.clone();\n \n         let addr2 = addr.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             let _ = UnixStream::connect(&addr2);\n         });\n-        spawn(proc() {\n+        spawn(move|| {\n             let _ = UnixStream::connect(&addr);\n         });\n \n@@ -804,14 +807,14 @@ mod tests {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n \n-        spawn(proc() { let mut a = a; tx.send(a.accept()) });\n-        spawn(proc() { let mut a = a2; tx2.send(a.accept()) });\n+        spawn(move|| { let mut a = a; tx.send(a.accept()) });\n+        spawn(move|| { let mut a = a2; tx2.send(a.accept()) });\n \n         let addr2 = addr.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             let _ = UnixStream::connect(&addr2);\n         });\n-        spawn(proc() {\n+        spawn(move|| {\n             let _ = UnixStream::connect(&addr);\n         });\n \n@@ -837,7 +840,7 @@ mod tests {\n         let mut a2 = a.clone();\n \n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut a = a;\n             tx.send(a.accept());\n         });"}, {"sha": "3c38e23183fe7e3e840ef920a15f44d6cde2afd0", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -140,7 +140,7 @@ impl TcpStream {\n     /// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n     /// let stream2 = stream.clone();\n     ///\n-    /// spawn(proc() {\n+    /// spawn(move|| {\n     ///     // close this stream after one second\n     ///     timer::sleep(Duration::seconds(1));\n     ///     let mut stream = stream2;\n@@ -293,7 +293,7 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n /// for stream in acceptor.incoming() {\n ///     match stream {\n ///         Err(e) => { /* connection failed */ }\n-///         Ok(stream) => spawn(proc() {\n+///         Ok(stream) => spawn(move|| {\n ///             // connection succeeded\n ///             handle_client(stream)\n ///         })\n@@ -420,7 +420,7 @@ impl TcpAcceptor {\n     /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n     /// let a2 = a.clone();\n     ///\n-    /// spawn(proc() {\n+    /// spawn(move|| {\n     ///     let mut a2 = a2;\n     ///     for socket in a2.incoming() {\n     ///         match socket {\n@@ -509,7 +509,7 @@ mod test {\n         let listener = TcpListener::bind(socket_addr);\n         let mut acceptor = listener.listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut stream = TcpStream::connect((\"localhost\", socket_addr.port));\n             stream.write(&[144]).unwrap();\n         });\n@@ -525,7 +525,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut stream = TcpStream::connect((\"localhost\", addr.port));\n             stream.write(&[64]).unwrap();\n         });\n@@ -541,7 +541,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut stream = TcpStream::connect((\"127.0.0.1\", addr.port));\n             stream.write(&[44]).unwrap();\n         });\n@@ -557,7 +557,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut stream = TcpStream::connect((\"::1\", addr.port));\n             stream.write(&[66]).unwrap();\n         });\n@@ -573,7 +573,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut stream = TcpStream::connect(addr);\n             stream.write(&[99]).unwrap();\n         });\n@@ -589,7 +589,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut stream = TcpStream::connect(addr);\n             stream.write(&[99]).unwrap();\n         });\n@@ -605,7 +605,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -621,7 +621,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -637,7 +637,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -661,7 +661,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -686,7 +686,7 @@ mod test {\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             drop(TcpStream::connect(addr));\n             tx.send(());\n         });\n@@ -711,7 +711,7 @@ mod test {\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             drop(TcpStream::connect(addr));\n             tx.send(());\n         });\n@@ -736,7 +736,7 @@ mod test {\n         let max = 10u;\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0, max) {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write(&[99]).unwrap();\n@@ -756,7 +756,7 @@ mod test {\n         let max = 10u;\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0, max) {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write(&[99]).unwrap();\n@@ -776,11 +776,11 @@ mod test {\n         static MAX: int = 10;\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut acceptor = acceptor;\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                spawn(proc() {\n+                spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -795,7 +795,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            spawn(proc() {\n+            spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -812,11 +812,11 @@ mod test {\n         static MAX: int = 10;\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut acceptor = acceptor;\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                spawn(proc() {\n+                spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -831,7 +831,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            spawn(proc() {\n+            spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -848,11 +848,11 @@ mod test {\n         let addr = next_test_ip4();\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut acceptor = acceptor;\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                spawn(proc() {\n+                spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -867,7 +867,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            spawn(proc() {\n+            spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -884,11 +884,11 @@ mod test {\n         let addr = next_test_ip6();\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut acceptor = acceptor;\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                spawn(proc() {\n+                spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -903,7 +903,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            spawn(proc() {\n+            spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -926,7 +926,7 @@ mod test {\n \n     pub fn peer_name(addr: SocketAddr) {\n         let acceptor = TcpListener::bind(addr).listen();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut acceptor = acceptor;\n             acceptor.accept().unwrap();\n         });\n@@ -961,7 +961,7 @@ mod test {\n     fn partial_read() {\n         let addr = next_test_ip4();\n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut srv = TcpListener::bind(addr).listen().unwrap();\n             tx.send(());\n             let mut cl = srv.accept().unwrap();\n@@ -998,7 +998,7 @@ mod test {\n         let addr = next_test_ip4();\n         let (tx, rx) = channel();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             rx.recv();\n             let _stream = TcpStream::connect(addr).unwrap();\n             // Close\n@@ -1023,7 +1023,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 0];\n             assert_eq!(s.read(&mut buf), Ok(1));\n@@ -1036,7 +1036,7 @@ mod test {\n \n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s2 = s2;\n             rx1.recv();\n             s2.write(&[1]).unwrap();\n@@ -1055,7 +1055,7 @@ mod test {\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             s.write(&[1]).unwrap();\n             rx.recv();\n@@ -1067,7 +1067,7 @@ mod test {\n         let s2 = s1.clone();\n \n         let (done, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n             s2.read(&mut buf).unwrap();\n@@ -1086,7 +1086,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 1];\n             s.read(&mut buf).unwrap();\n@@ -1097,7 +1097,7 @@ mod test {\n         let s2 = s1.clone();\n \n         let (done, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s2 = s2;\n             s2.write(&[1]).unwrap();\n             done.send(());\n@@ -1111,7 +1111,7 @@ mod test {\n     fn shutdown_smoke() {\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).unwrap().listen();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut a = a;\n             let mut c = a.accept().unwrap();\n             assert_eq!(c.read_to_end(), Ok(vec!()));\n@@ -1145,7 +1145,7 @@ mod test {\n         //        flakiness.\n         if !cfg!(target_os = \"freebsd\") {\n             let (tx, rx) = channel();\n-            spawn(proc() {\n+            spawn(move|| {\n                 tx.send(TcpStream::connect(addr).unwrap());\n             });\n             let _l = rx.recv();\n@@ -1162,7 +1162,7 @@ mod test {\n \n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n-        spawn(proc() {\n+        spawn(move|| {\n             drop(TcpStream::connect(addr).unwrap());\n         });\n         a.accept().unwrap();\n@@ -1173,7 +1173,7 @@ mod test {\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv_opt();\n@@ -1210,7 +1210,7 @@ mod test {\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv_opt();\n@@ -1219,7 +1219,7 @@ mod test {\n         let mut s = TcpStream::connect(addr).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_err());\n             tx.send(());\n@@ -1236,7 +1236,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             assert!(s.write(&[0]).is_ok());\n@@ -1269,7 +1269,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             let mut amt = 0;\n@@ -1298,7 +1298,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             assert!(s.write(&[0]).is_ok());\n@@ -1326,7 +1326,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             assert_eq!(s.write(&[0]), Ok(()));\n@@ -1336,7 +1336,7 @@ mod test {\n         let mut s = a.accept().unwrap();\n         let s2 = s.clone();\n         let (tx2, rx2) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut s2 = s2;\n             assert_eq!(s2.read(&mut [0]), Ok(1));\n             tx2.send(());\n@@ -1359,7 +1359,7 @@ mod test {\n         let (tx, rx) = channel();\n         let (txdone, rxdone) = channel();\n         let txdone2 = txdone.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut tcp = TcpStream::connect(addr).unwrap();\n             rx.recv();\n             tcp.write_u8(0).unwrap();\n@@ -1370,7 +1370,7 @@ mod test {\n         let tcp = accept.accept().unwrap();\n         let tcp2 = tcp.clone();\n         let txdone3 = txdone.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut tcp2 = tcp2;\n             tcp2.read_u8().unwrap();\n             txdone3.send(());\n@@ -1396,10 +1396,10 @@ mod test {\n         let mut a = l.listen().unwrap();\n         let mut a2 = a.clone();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n-        spawn(proc() {\n+        spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n \n@@ -1417,13 +1417,13 @@ mod test {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n \n-        spawn(proc() { let mut a = a; tx.send(a.accept()) });\n-        spawn(proc() { let mut a = a2; tx2.send(a.accept()) });\n+        spawn(move|| { let mut a = a; tx.send(a.accept()) });\n+        spawn(move|| { let mut a = a2; tx2.send(a.accept()) });\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n-        spawn(proc() {\n+        spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n \n@@ -1449,7 +1449,7 @@ mod test {\n         let mut a2 = a.clone();\n \n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut a = a;\n             tx.send(a.accept());\n         });"}, {"sha": "78951b8dae2b041246689810491fd256f90dbfa5", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -272,7 +272,7 @@ mod test {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n                     rx1.recv();\n@@ -307,7 +307,7 @@ mod test {\n         let client_ip = next_test_ip6();\n         let (tx, rx) = channel::<()>();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n                     rx.recv();\n@@ -343,7 +343,7 @@ mod test {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let send_as = |ip, val: &[u8]| {\n                 match UdpSocket::bind(ip) {\n                     Ok(client) => {\n@@ -387,7 +387,7 @@ mod test {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             match UdpSocket::bind(client_ip) {\n                 Ok(client) => {\n                     let client = box client;\n@@ -449,7 +449,7 @@ mod test {\n         let mut sock1 = UdpSocket::bind(addr1).unwrap();\n         let sock2 = UdpSocket::bind(addr2).unwrap();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut sock2 = sock2;\n             let mut buf = [0, 0];\n             assert_eq!(sock2.recv_from(&mut buf), Ok((1, addr1)));\n@@ -461,7 +461,7 @@ mod test {\n \n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut sock3 = sock3;\n             rx1.recv();\n             sock3.send_to(&[1], addr2).unwrap();\n@@ -482,7 +482,7 @@ mod test {\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut sock2 = sock2;\n             sock2.send_to(&[1], addr1).unwrap();\n             rx.recv();\n@@ -493,7 +493,7 @@ mod test {\n         let sock3 = sock1.clone();\n \n         let (done, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut sock3 = sock3;\n             let mut buf = [0, 0];\n             sock3.recv_from(&mut buf).unwrap();\n@@ -517,7 +517,7 @@ mod test {\n         let (tx, rx) = channel();\n         let (serv_tx, serv_rx) = channel();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let mut sock2 = sock2;\n             let mut buf = [0, 1];\n \n@@ -533,7 +533,7 @@ mod test {\n \n         let (done, rx) = channel();\n         let tx2 = tx.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut sock3 = sock3;\n             match sock3.send_to(&[1], addr2) {\n                 Ok(..) => { let _ = tx2.send_opt(()); }\n@@ -560,7 +560,7 @@ mod test {\n \n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut a = UdpSocket::bind(addr2).unwrap();\n             assert_eq!(a.recv_from(&mut [0]), Ok((1, addr1)));\n             assert_eq!(a.send_to(&[0], addr1), Ok(()));"}, {"sha": "73a893c4f2dcddd64196f5719af557e3ec42e034", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -123,7 +123,7 @@ mod test {\n         let out = PipeStream::open(writer);\n         let mut input = PipeStream::open(reader);\n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut out = out;\n             out.write(&[10]).unwrap();\n             rx.recv(); // don't close the pipe until the other read has finished"}, {"sha": "9ba6381c8c3b3941b78400eccf0e3882c7407ff1", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -693,7 +693,7 @@ impl Process {\n         fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n             let (tx, rx) = channel();\n             match stream {\n-                Some(stream) => spawn(proc() {\n+                Some(stream) => spawn(move |:| {\n                     let mut stream = stream;\n                     tx.send(stream.read_to_end())\n                 }),\n@@ -1155,14 +1155,14 @@ mod tests {\n     fn wait_timeout2() {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut p = sleeper();\n             p.set_timeout(Some(10));\n             assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n             p.signal_kill().unwrap();\n             tx.send(());\n         });\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut p = sleeper();\n             p.set_timeout(Some(10));\n             assert_eq!(p.wait().err().unwrap().kind, TimedOut);"}, {"sha": "344012a09a0e39d99e4d445e04db3400a5d445dc", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -528,7 +528,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n-        spawn(proc() {\n+        spawn(move|| {\n             set_stdout(box w);\n             println!(\"hello!\");\n         });\n@@ -542,7 +542,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n-        spawn(proc() {\n+        spawn(move|| {\n             ::realstd::io::stdio::set_stderr(box w);\n             panic!(\"my special message\");\n         });"}, {"sha": "79048c37ab5bbb5bb22017ea965c0ce52149736b", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -357,7 +357,7 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let _ = timer_rx.recv_opt();\n         });\n \n@@ -371,7 +371,7 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let _ = timer_rx.recv_opt();\n         });\n \n@@ -384,7 +384,7 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let _ = timer_rx.recv_opt();\n         });\n "}, {"sha": "e99aba9b673804db7736d9508a4b581286ffb85d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -171,6 +171,8 @@ pub use rustrt::c_str;\n \n pub use unicode::char;\n \n+pub use rustrt::thunk;\n+\n /* Exported macros */\n \n pub mod macros;"}, {"sha": "900c223c70bd319319818abe3a4ed6b3e00bce4e", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -358,8 +358,8 @@ macro_rules! vec[\n /// # fn long_running_task() {}\n /// # fn calculate_the_answer() -> int { 42i }\n ///\n-/// spawn(proc() { long_running_task(); tx1.send(()) });\n-/// spawn(proc() { tx2.send(calculate_the_answer()) });\n+/// spawn(move|| { long_running_task(); tx1.send(()) });\n+/// spawn(move|| { tx2.send(calculate_the_answer()) });\n ///\n /// select! (\n ///     () = rx1.recv() => println!(\"the long running task finished first\"),"}, {"sha": "4041a6f60d71d06ebd1c8f450db56bd95879a16b", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -515,17 +515,17 @@ mod tests {\n     #[test]\n     fn test_null_byte() {\n         use task;\n-        let result = task::try(proc() {\n+        let result = task::try(move|| {\n             Path::new(b\"foo/bar\\0\")\n         });\n         assert!(result.is_err());\n \n-        let result = task::try(proc() {\n+        let result = task::try(move|| {\n             Path::new(\"test\").set_filename(b\"f\\0o\")\n         });\n         assert!(result.is_err());\n \n-        let result = task::try(proc() {\n+        let result = task::try(move|| {\n             Path::new(\"test\").push(b\"f\\0o\");\n         });\n         assert!(result.is_err());"}, {"sha": "3983e365ae1f6cb6a7b89d54afbbd3a40d4165e1", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -1299,17 +1299,17 @@ mod tests {\n     #[test]\n     fn test_null_byte() {\n         use task;\n-        let result = task::try(proc() {\n+        let result = task::try(move|| {\n             Path::new(b\"foo/bar\\0\")\n         });\n         assert!(result.is_err());\n \n-        let result = task::try(proc() {\n+        let result = task::try(move|| {\n             Path::new(\"test\").set_filename(b\"f\\0o\")\n         });\n         assert!(result.is_err());\n \n-        let result = task::try(proc() {\n+        let result = task::try(move|| {\n             Path::new(\"test\").push(b\"f\\0o\");\n         });\n         assert!(result.is_err());"}, {"sha": "5405892535cfec99e99d1dd335c4521c78ac5e51", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -355,7 +355,7 @@ mod test {\n         for _ in range(0u, 20) {\n             let (tx, rx) = channel();\n             txs.push(tx);\n-            task::spawn(proc() {\n+            task::spawn(move|| {\n                 // wait until all the tasks are ready to go.\n                 rx.recv();\n "}, {"sha": "eb517047ddc0b84011a98db9017c9cf4e17fc5ee", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -52,6 +52,7 @@ use borrow::IntoCow;\n use failure;\n use rustrt;\n use os;\n+use thunk::Thunk;\n \n // Reexport some of our utilities which are expected by other crates.\n pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n@@ -87,10 +88,10 @@ static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n #[lang = \"start\"]\n fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     use mem;\n-    start(argc, argv, proc() {\n+    start(argc, argv, Thunk::new(move|| {\n         let main: extern \"Rust\" fn() = unsafe { mem::transmute(main) };\n         main();\n-    })\n+    }))\n }\n \n /// Executes the given procedure after initializing the runtime with the given\n@@ -102,7 +103,7 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n ///\n /// This function will only return once *all* native threads in the system have\n /// exited.\n-pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n+pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n     use prelude::*;\n     use rt;\n     use rustrt::task::Task;\n@@ -144,7 +145,7 @@ pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n         unsafe {\n             rustrt::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n         }\n-        (main.take().unwrap())();\n+        (main.take().unwrap()).invoke(());\n         exit_code = Some(os::get_exit_status());\n     }).destroy());\n     unsafe { rt::cleanup(); }"}, {"sha": "fe5b962fa4b7499d402d16987b47c0a0aaf10c7d", "filename": "src/libstd/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomic.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -47,7 +47,7 @@\n //!     let spinlock = Arc::new(AtomicUint::new(1));\n //!\n //!     let spinlock_clone = spinlock.clone();\n-//!     spawn(proc() {\n+//!     spawn(move|| {\n //!         spinlock_clone.store(0, SeqCst);\n //!     });\n //!\n@@ -68,7 +68,7 @@\n //!     let shared_big_object = Arc::new(AtomicOption::empty());\n //!\n //!     let shared_big_object_clone = shared_big_object.clone();\n-//!     spawn(proc() {\n+//!     spawn(move|| {\n //!         let unwrapped_big_object = shared_big_object_clone.take(SeqCst);\n //!         if unwrapped_big_object.is_some() {\n //!             println!(\"got a big object from another task\");"}, {"sha": "1b8574604a0c1a8d22ea046d02d7b40990cfa77c", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -21,7 +21,7 @@ use sync::{Mutex, Condvar};\n ///     let c = barrier.clone();\n ///     // The same messages will be printed together.\n ///     // You will NOT see any interleaving.\n-///     spawn(proc() {\n+///     spawn(move|| {\n ///         println!(\"before wait\");\n ///         c.wait();\n ///         println!(\"after wait\");\n@@ -94,7 +94,7 @@ mod tests {\n         for _ in range(0u, 9) {\n             let c = barrier.clone();\n             let tx = tx.clone();\n-            spawn(proc() {\n+            spawn(move|| {\n                 c.wait();\n                 tx.send(true);\n             });"}, {"sha": "3bdab261e1957c21c8fe3e249d33de046d5748aa", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -41,7 +41,7 @@ use time::Duration;\n /// let pair2 = pair.clone();\n ///\n /// // Inside of our lock, spawn a new thread, and then wait for it to start\n-/// spawn(proc() {\n+/// spawn(move|| {\n ///     let &(ref lock, ref cvar) = &*pair2;\n ///     let mut started = lock.lock();\n ///     *started = true;\n@@ -282,7 +282,7 @@ mod tests {\n         static M: StaticMutex = MUTEX_INIT;\n \n         let g = M.lock();\n-        spawn(proc() {\n+        spawn(move|| {\n             let _g = M.lock();\n             C.notify_one();\n         });\n@@ -300,7 +300,7 @@ mod tests {\n         for _ in range(0, N) {\n             let data = data.clone();\n             let tx = tx.clone();\n-            spawn(proc() {\n+            spawn(move|| {\n                 let &(ref lock, ref cond) = &*data;\n                 let mut cnt = lock.lock();\n                 *cnt += 1;\n@@ -334,7 +334,7 @@ mod tests {\n \n         let g = M.lock();\n         assert!(!C.wait_timeout(&g, Duration::nanoseconds(1000)));\n-        spawn(proc() {\n+        spawn(move|| {\n             let _g = M.lock();\n             C.notify_one();\n         });\n@@ -351,7 +351,7 @@ mod tests {\n         static C: StaticCondvar = CONDVAR_INIT;\n \n         let g = M1.lock();\n-        spawn(proc() {\n+        spawn(move|| {\n             let _g = M1.lock();\n             C.notify_one();\n         });"}, {"sha": "e5a1e09967ce9d33913ad42826abfd33066a9a02", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -17,7 +17,7 @@\n //! use std::sync::Future;\n //! # fn fib(n: uint) -> uint {42};\n //! # fn make_a_sandwich() {};\n-//! let mut delayed_fib = Future::spawn(proc() { fib(5000) });\n+//! let mut delayed_fib = Future::spawn(move|| { fib(5000) });\n //! make_a_sandwich();\n //! println!(\"fib(5000) = {}\", delayed_fib.get())\n //! ```\n@@ -30,14 +30,15 @@ use core::mem::replace;\n use self::FutureState::*;\n use comm::{Receiver, channel};\n use task::spawn;\n+use thunk::{Thunk};\n \n /// A type encapsulating the result of a computation which may not be complete\n pub struct Future<A> {\n     state: FutureState<A>,\n }\n \n enum FutureState<A> {\n-    Pending(proc():Send -> A),\n+    Pending(Thunk<(),A>),\n     Evaluating,\n     Forced(A)\n }\n@@ -78,7 +79,7 @@ impl<A> Future<A> {\n                 match replace(&mut self.state, Evaluating) {\n                     Forced(_) | Evaluating => panic!(\"Logic error.\"),\n                     Pending(f) => {\n-                        self.state = Forced(f());\n+                        self.state = Forced(f.invoke(()));\n                         self.get_ref()\n                     }\n                 }\n@@ -97,7 +98,9 @@ impl<A> Future<A> {\n         Future {state: Forced(val)}\n     }\n \n-    pub fn from_fn(f: proc():Send -> A) -> Future<A> {\n+    pub fn from_fn<F>(f: F) -> Future<A>\n+        where F : FnOnce() -> A, F : Send\n+    {\n         /*!\n          * Create a future from a function.\n          *\n@@ -106,7 +109,7 @@ impl<A> Future<A> {\n          * function. It is not spawned into another task.\n          */\n \n-        Future {state: Pending(f)}\n+        Future {state: Pending(Thunk::new(f))}\n     }\n }\n \n@@ -119,12 +122,14 @@ impl<A:Send> Future<A> {\n          * waiting for the result to be received on the port.\n          */\n \n-        Future::from_fn(proc() {\n+        Future::from_fn(move|:| {\n             rx.recv()\n         })\n     }\n \n-    pub fn spawn(blk: proc():Send -> A) -> Future<A> {\n+    pub fn spawn<F>(blk: F) -> Future<A>\n+        where F : FnOnce() -> A, F : Send\n+    {\n         /*!\n          * Create a future from a unique closure.\n          *\n@@ -134,7 +139,7 @@ impl<A:Send> Future<A> {\n \n         let (tx, rx) = channel();\n \n-        spawn(proc() {\n+        spawn(move |:| {\n             // Don't panic if the other end has hung up\n             let _ = tx.send_opt(blk());\n         });\n@@ -166,7 +171,7 @@ mod test {\n \n     #[test]\n     fn test_from_fn() {\n-        let mut f = Future::from_fn(proc() \"brail\".to_string());\n+        let mut f = Future::from_fn(move|| \"brail\".to_string());\n         assert_eq!(f.get(), \"brail\");\n     }\n \n@@ -190,23 +195,23 @@ mod test {\n \n     #[test]\n     fn test_spawn() {\n-        let mut f = Future::spawn(proc() \"bale\".to_string());\n+        let mut f = Future::spawn(move|| \"bale\".to_string());\n         assert_eq!(f.get(), \"bale\");\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_future_panic() {\n-        let mut f = Future::spawn(proc() panic!());\n+        let mut f = Future::spawn(move|| panic!());\n         let _x: String = f.get();\n     }\n \n     #[test]\n     fn test_sendable_future() {\n         let expected = \"schlorf\";\n         let (tx, rx) = channel();\n-        let f = Future::spawn(proc() { expected });\n-        task::spawn(proc() {\n+        let f = Future::spawn(move|| { expected });\n+        task::spawn(move|| {\n             let mut f = f;\n             tx.send(f.get());\n         });"}, {"sha": "33f8d254c71a41e1e1f2197dbd8eef9bac45fdef", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -47,7 +47,7 @@ use sys_common::mutex as sys;\n /// let (tx, rx) = channel();\n /// for _ in range(0u, 10) {\n ///     let (data, tx) = (data.clone(), tx.clone());\n-///     spawn(proc() {\n+///     spawn(move|| {\n ///         // The shared static can only be accessed once the lock is held.\n ///         // Our non-atomic increment is safe because we're the only thread\n ///         // which can access the shared state when the lock is held.\n@@ -313,9 +313,9 @@ mod test {\n         let (tx, rx) = channel();\n         for _ in range(0, K) {\n             let tx2 = tx.clone();\n-            spawn(proc() { inc(); tx2.send(()); });\n+            spawn(move|| { inc(); tx2.send(()); });\n             let tx2 = tx.clone();\n-            spawn(proc() { inc(); tx2.send(()); });\n+            spawn(move|| { inc(); tx2.send(()); });\n         }\n \n         drop(tx);\n@@ -339,7 +339,7 @@ mod test {\n         let arc = Arc::new((Mutex::new(false), Condvar::new()));\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             // wait until parent gets in\n             rx.recv();\n             let &(ref lock, ref cvar) = &*arc2;\n@@ -364,7 +364,7 @@ mod test {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             rx.recv();\n             let &(ref lock, ref cvar) = &*arc2;\n             let _g = lock.lock();\n@@ -386,7 +386,7 @@ mod test {\n     fn test_mutex_arc_poison() {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n+        let _ = task::try(move|| {\n             let lock = arc2.lock();\n             assert_eq!(*lock, 2);\n         });\n@@ -401,7 +401,7 @@ mod test {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = Arc::new(Mutex::new(arc));\n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let lock = arc2.lock();\n             let lock2 = lock.deref().lock();\n             assert_eq!(*lock2, 1);\n@@ -414,7 +414,7 @@ mod test {\n     fn test_mutex_arc_access_in_unwind() {\n         let arc = Arc::new(Mutex::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try::<()>(proc() {\n+        let _ = task::try(move|| -> () {\n             struct Unwinder {\n                 i: Arc<Mutex<int>>,\n             }"}, {"sha": "263937c5cbec75e3941a8556301a1e4c98aa67cb", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -142,7 +142,7 @@ mod test {\n         let (tx, rx) = channel();\n         for _ in range(0u, 10) {\n             let tx = tx.clone();\n-            spawn(proc() {\n+            spawn(move|| {\n                 for _ in range(0u, 4) { task::deschedule() }\n                 unsafe {\n                     O.doit(|| {"}, {"sha": "b6d6aa989c58e7e163531a1f07176c21ed5a4726", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -387,7 +387,7 @@ mod tests {\n         let (tx, rx) = channel::<()>();\n         for _ in range(0, N) {\n             let tx = tx.clone();\n-            spawn(proc() {\n+            spawn(move|| {\n                 let mut rng = rand::task_rng();\n                 for _ in range(0, M) {\n                     if rng.gen_weighted_bool(N) {\n@@ -409,7 +409,7 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n+        let _ = task::try(move|| {\n             let lock = arc2.write();\n             assert_eq!(*lock, 2);\n         });\n@@ -422,7 +422,7 @@ mod tests {\n     fn test_rw_arc_poison_ww() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n+        let _ = task::try(move|| {\n             let lock = arc2.write();\n             assert_eq!(*lock, 2);\n         });\n@@ -434,7 +434,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n+        let _ = task::try(move|| {\n             let lock = arc2.read();\n             assert_eq!(*lock, 2);\n         });\n@@ -445,7 +445,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n+        let _ = task::try(move|| {\n             let lock = arc2.read();\n             assert_eq!(*lock, 2);\n         });\n@@ -459,7 +459,7 @@ mod tests {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        task::spawn(proc() {\n+        task::spawn(move|| {\n             let mut lock = arc2.write();\n             for _ in range(0u, 10) {\n                 let tmp = *lock;\n@@ -474,7 +474,7 @@ mod tests {\n         let mut children = Vec::new();\n         for _ in range(0u, 5) {\n             let arc3 = arc.clone();\n-            children.push(task::try_future(proc() {\n+            children.push(task::try_future(move|| {\n                 let lock = arc3.read();\n                 assert!(*lock >= 0);\n             }));\n@@ -495,7 +495,7 @@ mod tests {\n     fn test_rw_arc_access_in_unwind() {\n         let arc = Arc::new(RWLock::new(1i));\n         let arc2 = arc.clone();\n-        let _ = task::try::<()>(proc() {\n+        let _ = task::try(move|| -> () {\n             struct Unwinder {\n                 i: Arc<RWLock<int>>,\n             }"}, {"sha": "574b0f22bee00ab40e30ac3219553f5fab90ceba", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -127,7 +127,7 @@ mod tests {\n     fn test_sem_as_mutex() {\n         let s = Arc::new(Semaphore::new(1));\n         let s2 = s.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             let _g = s2.access();\n         });\n         let _g = s.access();\n@@ -139,7 +139,7 @@ mod tests {\n         let (tx, rx) = channel();\n         let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             s2.acquire();\n             tx.send(());\n         });\n@@ -150,7 +150,7 @@ mod tests {\n         let (tx, rx) = channel();\n         let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             s2.release();\n             let _ = rx.recv();\n         });\n@@ -166,7 +166,7 @@ mod tests {\n         let s2 = s.clone();\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             let _g = s2.access();\n             let _ = rx2.recv();\n             tx1.send(());\n@@ -183,7 +183,7 @@ mod tests {\n         let (tx, rx) = channel();\n         {\n             let _g = s.access();\n-            spawn(proc() {\n+            spawn(move|| {\n                 tx.send(());\n                 drop(s2.access());\n                 tx.send(());"}, {"sha": "fa5b62a202bfdcb9223125010f6da41fd47efb33", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,17 +12,18 @@\n \n use core::prelude::*;\n \n-use task::spawn;\n+use task::{spawn};\n use comm::{channel, Sender, Receiver};\n use sync::{Arc, Mutex};\n+use thunk::Thunk;\n \n struct Sentinel<'a> {\n-    jobs: &'a Arc<Mutex<Receiver<proc(): Send>>>,\n+    jobs: &'a Arc<Mutex<Receiver<Thunk>>>,\n     active: bool\n }\n \n impl<'a> Sentinel<'a> {\n-    fn new(jobs: &Arc<Mutex<Receiver<proc(): Send>>>) -> Sentinel {\n+    fn new(jobs: &Arc<Mutex<Receiver<Thunk>>>) -> Sentinel {\n         Sentinel {\n             jobs: jobs,\n             active: true\n@@ -60,7 +61,7 @@ impl<'a> Drop for Sentinel<'a> {\n /// let (tx, rx) = channel();\n /// for _ in range(0, 8u) {\n ///     let tx = tx.clone();\n-///     pool.execute(proc() {\n+///     pool.execute(move|| {\n ///         tx.send(1u);\n ///     });\n /// }\n@@ -72,7 +73,7 @@ pub struct TaskPool {\n     //\n     // This is the only such Sender, so when it is dropped all subtasks will\n     // quit.\n-    jobs: Sender<proc(): Send>\n+    jobs: Sender<Thunk>\n }\n \n impl TaskPool {\n@@ -84,7 +85,7 @@ impl TaskPool {\n     pub fn new(tasks: uint) -> TaskPool {\n         assert!(tasks >= 1);\n \n-        let (tx, rx) = channel::<proc(): Send>();\n+        let (tx, rx) = channel::<Thunk>();\n         let rx = Arc::new(Mutex::new(rx));\n \n         // Taskpool tasks.\n@@ -96,13 +97,15 @@ impl TaskPool {\n     }\n \n     /// Executes the function `job` on a task in the pool.\n-    pub fn execute(&self, job: proc():Send) {\n-        self.jobs.send(job);\n+    pub fn execute<F>(&self, job: F)\n+        where F : FnOnce(), F : Send\n+    {\n+        self.jobs.send(Thunk::new(job));\n     }\n }\n \n-fn spawn_in_pool(jobs: Arc<Mutex<Receiver<proc(): Send>>>) {\n-    spawn(proc() {\n+fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n+    spawn(move |:| {\n         // Will spawn a new task on panic unless it is cancelled.\n         let sentinel = Sentinel::new(&jobs);\n \n@@ -115,7 +118,7 @@ fn spawn_in_pool(jobs: Arc<Mutex<Receiver<proc(): Send>>>) {\n             };\n \n             match message {\n-                Ok(job) => job(),\n+                Ok(job) => job.invoke(()),\n \n                 // The Taskpool was dropped.\n                 Err(..) => break\n@@ -144,7 +147,7 @@ mod test {\n         let (tx, rx) = channel();\n         for _ in range(0, TEST_TASKS) {\n             let tx = tx.clone();\n-            pool.execute(proc() {\n+            pool.execute(move|| {\n                 tx.send(1u);\n             });\n         }\n@@ -166,14 +169,14 @@ mod test {\n \n         // Panic all the existing tasks.\n         for _ in range(0, TEST_TASKS) {\n-            pool.execute(proc() { panic!() });\n+            pool.execute(move|| -> () { panic!() });\n         }\n \n         // Ensure new tasks were spawned to compensate.\n         let (tx, rx) = channel();\n         for _ in range(0, TEST_TASKS) {\n             let tx = tx.clone();\n-            pool.execute(proc() {\n+            pool.execute(move|| {\n                 tx.send(1u);\n             });\n         }\n@@ -191,7 +194,7 @@ mod test {\n         // Panic all the existing tasks in a bit.\n         for _ in range(0, TEST_TASKS) {\n             let waiter = waiter.clone();\n-            pool.execute(proc() {\n+            pool.execute(move|| {\n                 waiter.wait();\n                 panic!();\n             });"}, {"sha": "96b4accd4bd03e9da10f262a7b1afe2be4f42bee", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -83,15 +83,15 @@ impl<M: Send> Helper<M> {\n                 *self.signal.get() = send as uint;\n \n                 let t = f();\n-                task::spawn(proc() {\n+                task::spawn(move |:| {\n                     bookkeeping::decrement();\n                     helper(receive, rx, t);\n                     let _g = self.lock.lock();\n                     *self.shutdown.get() = true;\n                     self.cond.notify_one()\n                 });\n \n-                rustrt::at_exit(proc() { self.shutdown() });\n+                rustrt::at_exit(move|:| { self.shutdown() });\n                 *self.initialized.get() = true;\n             }\n         }"}, {"sha": "4ef1757cc3acae855d46e4d28cc78556ee1d66ba", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -94,8 +94,8 @@ impl Process {\n             mem::transmute::<&ProcessConfig<K,V>,&'static ProcessConfig<K,V>>(cfg)\n         };\n \n-        with_envp(cfg.env(), proc(envp) {\n-            with_argv(cfg.program(), cfg.args(), proc(argv) unsafe {\n+        with_envp(cfg.env(), move|: envp: *const c_void| {\n+            with_argv(cfg.program(), cfg.args(), move|: argv: *const *const libc::c_char| unsafe {\n                 let (input, mut output) = try!(sys::os::pipe());\n \n                 // We may use this in the child, so perform allocations before the\n@@ -531,8 +531,11 @@ impl Process {\n     }\n }\n \n-fn with_argv<T>(prog: &CString, args: &[CString],\n-                cb: proc(*const *const libc::c_char) -> T) -> T {\n+fn with_argv<T,F>(prog: &CString, args: &[CString],\n+                  cb: F)\n+                  -> T\n+    where F : FnOnce(*const *const libc::c_char) -> T\n+{\n     let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n \n     // Convert the CStrings into an array of pointers. Note: the\n@@ -549,9 +552,12 @@ fn with_argv<T>(prog: &CString, args: &[CString],\n     cb(ptrs.as_ptr())\n }\n \n-fn with_envp<K, V, T>(env: Option<&collections::HashMap<K, V>>,\n-                      cb: proc(*const c_void) -> T) -> T\n-    where K: BytesContainer + Eq + Hash, V: BytesContainer\n+fn with_envp<K,V,T,F>(env: Option<&collections::HashMap<K, V>>,\n+                      cb: F)\n+                      -> T\n+    where F : FnOnce(*const c_void) -> T,\n+          K : BytesContainer + Eq + Hash,\n+          V : BytesContainer\n {\n     // On posixy systems we can pass a char** for envp, which is a\n     // null-terminated array of \"k=v\\0\" strings. Since we must create"}, {"sha": "969b322af991f0a81a29675394e1fdb9dbc0393a", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -131,7 +131,7 @@ fn init_dtors() {\n         DTORS = mem::transmute(dtors);\n     }\n \n-    rustrt::at_exit(proc() unsafe {\n+    rustrt::at_exit(move|| unsafe {\n         mem::transmute::<_, Box<Exclusive<Vec<(Key, Dtor)>>>>(DTORS);\n         DTORS = 0 as *mut _;\n     });"}, {"sha": "340e283708a484a18f94555f098712a109fb9072", "filename": "src/libstd/task.rs", "status": "modified", "additions": 70, "deletions": 58, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -35,7 +35,7 @@\n //! ## Example\n //!\n //! ```rust\n-//! spawn(proc() {\n+//! spawn(move|| {\n //!     println!(\"Hello, World!\");\n //! })\n //! ```\n@@ -47,6 +47,7 @@ use any::Any;\n use borrow::IntoCow;\n use boxed::Box;\n use comm::channel;\n+use core::ops::FnOnce;\n use io::{Writer, stdio};\n use kinds::{Send, marker};\n use option::Option;\n@@ -57,6 +58,7 @@ use rustrt::task::Task;\n use rustrt::task;\n use str::SendStr;\n use string::{String, ToString};\n+use thunk::{Thunk};\n use sync::Future;\n \n /// The task builder type.\n@@ -80,7 +82,7 @@ pub struct TaskBuilder {\n     // Task-local stderr\n     stderr: Option<Box<Writer + Send>>,\n     // Optionally wrap the eventual task body\n-    gen_body: Option<proc(v: proc():Send):Send -> proc():Send>,\n+    gen_body: Option<Thunk<Thunk, Thunk>>,\n     nocopy: marker::NoCopy,\n }\n \n@@ -129,41 +131,46 @@ impl TaskBuilder {\n     }\n \n     // Where spawning actually happens (whether yielding a future or not)\n-    fn spawn_internal(self, f: proc():Send,\n-                      on_exit: Option<proc(Result<(), Box<Any + Send>>):Send>) {\n+    fn spawn_internal(\n+        self,\n+        f: Thunk,\n+        on_exit: Option<Thunk<task::Result>>)\n+    {\n         let TaskBuilder {\n             name, stack_size, stdout, stderr, mut gen_body, nocopy: _\n         } = self;\n+\n         let f = match gen_body.take() {\n-            Some(gen) => gen(f),\n+            Some(gen) => gen.invoke(f),\n             None => f\n         };\n+\n         let opts = task::TaskOpts {\n             on_exit: on_exit,\n             name: name,\n             stack_size: stack_size,\n         };\n         if stdout.is_some() || stderr.is_some() {\n-            Task::spawn(opts, proc() {\n+            Task::spawn(opts, move|:| {\n                 let _ = stdout.map(stdio::set_stdout);\n                 let _ = stderr.map(stdio::set_stderr);\n-                f();\n-            })\n+                f.invoke(());\n+            });\n         } else {\n-            Task::spawn(opts, f)\n+            Task::spawn(opts, move|:| f.invoke(()))\n         }\n     }\n \n     /// Creates and executes a new child task.\n     ///\n     /// Sets up a new task with its own call stack and schedules it to run\n-    /// the provided proc. The task has the properties and behavior\n+    /// the provided function. The task has the properties and behavior\n     /// specified by the `TaskBuilder`.\n-    pub fn spawn(self, f: proc():Send) {\n-        self.spawn_internal(f, None)\n+    pub fn spawn<F:FnOnce()+Send>(self, f: F) {\n+        self.spawn_internal(Thunk::new(f), None)\n     }\n \n-    /// Execute a proc in a newly-spawned task and return a future representing\n+    /// Execute a function in a newly-spawned task and return a future representing\n     /// the task's result. The task has the properties and behavior\n     /// specified by the `TaskBuilder`.\n     ///\n@@ -178,28 +185,32 @@ impl TaskBuilder {\n     /// `result::Result::Err` containing the argument to `panic!(...)` as an\n     /// `Any` trait object.\n     #[experimental = \"Futures are experimental.\"]\n-    pub fn try_future<T:Send>(self, f: proc():Send -> T)\n-                              -> Future<Result<T, Box<Any + Send>>> {\n-        // currently, the on_exit proc provided by librustrt only works for unit\n+    pub fn try_future<T:Send,F:FnOnce()->(T)+Send>(self, f: F)\n+                                                   -> Future<Result<T, Box<Any + Send>>> {\n+        // currently, the on_exit fn provided by librustrt only works for unit\n         // results, so we use an additional side-channel to communicate the\n         // result.\n \n         let (tx_done, rx_done) = channel(); // signal that task has exited\n         let (tx_retv, rx_retv) = channel(); // return value from task\n \n-        let on_exit = proc(res) { let _ = tx_done.send_opt(res); };\n-        self.spawn_internal(proc() { let _ = tx_retv.send_opt(f()); },\n+        let on_exit: Thunk<task::Result> = Thunk::with_arg(move |: res: task::Result| {\n+            let _ = tx_done.send_opt(res);\n+        });\n+        self.spawn_internal(Thunk::new(move |:| { let _ = tx_retv.send_opt(f()); }),\n                             Some(on_exit));\n \n-        Future::from_fn(proc() {\n+        Future::from_fn(move|:| {\n             rx_done.recv().map(|_| rx_retv.recv())\n         })\n     }\n \n     /// Execute a function in a newly-spawnedtask and block until the task\n     /// completes or panics. Equivalent to `.try_future(f).unwrap()`.\n     #[unstable = \"Error type may change.\"]\n-    pub fn try<T:Send>(self, f: proc():Send -> T) -> Result<T, Box<Any + Send>> {\n+    pub fn try<T,F>(self, f: F) -> Result<T, Box<Any + Send>>\n+        where F : FnOnce() -> T, F : Send, T : Send\n+    {\n         self.try_future(f).into_inner()\n     }\n }\n@@ -212,7 +223,7 @@ impl TaskBuilder {\n /// the provided unique closure.\n ///\n /// This function is equivalent to `TaskBuilder::new().spawn(f)`.\n-pub fn spawn(f: proc(): Send) {\n+pub fn spawn<F:FnOnce()+Send>(f: F) {\n     TaskBuilder::new().spawn(f)\n }\n \n@@ -221,7 +232,9 @@ pub fn spawn(f: proc(): Send) {\n ///\n /// This is equivalent to `TaskBuilder::new().try`.\n #[unstable = \"Error type may change.\"]\n-pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> {\n+pub fn try<T,F>(f: F) -> Result<T, Box<Any + Send>>\n+    where T : Send, F : FnOnce() -> T, F : Send\n+{\n     TaskBuilder::new().try(f)\n }\n \n@@ -230,11 +243,12 @@ pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> {\n ///\n /// This is equivalent to `TaskBuilder::new().try_future`.\n #[experimental = \"Futures are experimental.\"]\n-pub fn try_future<T:Send>(f: proc():Send -> T) -> Future<Result<T, Box<Any + Send>>> {\n+pub fn try_future<T,F>(f: F) -> Future<Result<T, Box<Any + Send>>>\n+    where T:Send, F:FnOnce()->T, F:Send\n+{\n     TaskBuilder::new().try_future(f)\n }\n \n-\n /* Lifecycle functions */\n \n /// Read the name of the current task.\n@@ -274,62 +288,64 @@ mod test {\n     use result;\n     use std::io::{ChanReader, ChanWriter};\n     use string::String;\n+    use thunk::Thunk;\n+    use prelude::*;\n     use super::*;\n \n     // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n     // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n \n     #[test]\n     fn test_unnamed_task() {\n-        try(proc() {\n+        try(move|| {\n             assert!(name().is_none());\n         }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_owned_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".to_string()).try(proc() {\n+        TaskBuilder::new().named(\"ada lovelace\".to_string()).try(move|| {\n             assert!(name().unwrap() == \"ada lovelace\");\n         }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_static_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\").try(proc() {\n+        TaskBuilder::new().named(\"ada lovelace\").try(move|| {\n             assert!(name().unwrap() == \"ada lovelace\");\n         }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_send_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".into_cow()).try(proc() {\n+        TaskBuilder::new().named(\"ada lovelace\".into_cow()).try(move|| {\n             assert!(name().unwrap() == \"ada lovelace\");\n         }).map_err(|_| ()).unwrap();\n     }\n \n     #[test]\n     fn test_run_basic() {\n         let (tx, rx) = channel();\n-        TaskBuilder::new().spawn(proc() {\n+        TaskBuilder::new().spawn(move|| {\n             tx.send(());\n         });\n         rx.recv();\n     }\n \n     #[test]\n     fn test_try_future() {\n-        let result = TaskBuilder::new().try_future(proc() {});\n+        let result = TaskBuilder::new().try_future(move|| {});\n         assert!(result.unwrap().is_ok());\n \n-        let result = TaskBuilder::new().try_future(proc() -> () {\n+        let result = TaskBuilder::new().try_future(move|| -> () {\n             panic!();\n         });\n         assert!(result.unwrap().is_err());\n     }\n \n     #[test]\n     fn test_try_success() {\n-        match try(proc() {\n+        match try(move|| {\n             \"Success!\".to_string()\n         }).as_ref().map(|s| s.as_slice()) {\n             result::Result::Ok(\"Success!\") => (),\n@@ -339,7 +355,7 @@ mod test {\n \n     #[test]\n     fn test_try_panic() {\n-        match try(proc() {\n+        match try(move|| {\n             panic!()\n         }) {\n             result::Result::Err(_) => (),\n@@ -355,7 +371,7 @@ mod test {\n \n         fn f(i: int, tx: Sender<()>) {\n             let tx = tx.clone();\n-            spawn(proc() {\n+            spawn(move|| {\n                 if i == 0 {\n                     tx.send(());\n                 } else {\n@@ -372,8 +388,8 @@ mod test {\n     fn test_spawn_sched_childs_on_default_sched() {\n         let (tx, rx) = channel();\n \n-        spawn(proc() {\n-            spawn(proc() {\n+        spawn(move|| {\n+            spawn(move|| {\n                 tx.send(());\n             });\n         });\n@@ -382,43 +398,39 @@ mod test {\n     }\n \n     fn avoid_copying_the_body<F>(spawnfn: F) where\n-        F: FnOnce(proc():Send),\n+        F: FnOnce(Thunk),\n     {\n         let (tx, rx) = channel::<uint>();\n \n         let x = box 1;\n         let x_in_parent = (&*x) as *const int as uint;\n \n-        spawnfn(proc() {\n+        spawnfn(Thunk::new(move|| {\n             let x_in_child = (&*x) as *const int as uint;\n             tx.send(x_in_child);\n-        });\n+        }));\n \n         let x_in_child = rx.recv();\n         assert_eq!(x_in_parent, x_in_child);\n     }\n \n     #[test]\n     fn test_avoid_copying_the_body_spawn() {\n-        avoid_copying_the_body(spawn);\n+        avoid_copying_the_body(|t| spawn(move|| t.invoke(())));\n     }\n \n     #[test]\n     fn test_avoid_copying_the_body_task_spawn() {\n         avoid_copying_the_body(|f| {\n             let builder = TaskBuilder::new();\n-            builder.spawn(proc() {\n-                f();\n-            });\n+            builder.spawn(move|| f.invoke(()));\n         })\n     }\n \n     #[test]\n     fn test_avoid_copying_the_body_try() {\n         avoid_copying_the_body(|f| {\n-            let _ = try(proc() {\n-                f()\n-            });\n+            let _ = try(move|| f.invoke(()));\n         })\n     }\n \n@@ -429,24 +441,24 @@ mod test {\n         // (well, it would if the constant were 8000+ - I lowered it to be more\n         // valgrind-friendly. try this at home, instead..!)\n         static GENERATIONS: uint = 16;\n-        fn child_no(x: uint) -> proc(): Send {\n-            return proc() {\n+        fn child_no(x: uint) -> Thunk {\n+            return Thunk::new(move|| {\n                 if x < GENERATIONS {\n-                    TaskBuilder::new().spawn(child_no(x+1));\n+                    TaskBuilder::new().spawn(move|| child_no(x+1).invoke(()));\n                 }\n-            }\n+            });\n         }\n-        TaskBuilder::new().spawn(child_no(0));\n+        TaskBuilder::new().spawn(|| child_no(0).invoke(()));\n     }\n \n     #[test]\n     fn test_simple_newsched_spawn() {\n-        spawn(proc()())\n+        spawn(move|| ())\n     }\n \n     #[test]\n     fn test_try_panic_message_static_str() {\n-        match try(proc() {\n+        match try(move|| {\n             panic!(\"static string\");\n         }) {\n             Err(e) => {\n@@ -460,7 +472,7 @@ mod test {\n \n     #[test]\n     fn test_try_panic_message_owned_str() {\n-        match try(proc() {\n+        match try(move|| {\n             panic!(\"owned string\".to_string());\n         }) {\n             Err(e) => {\n@@ -474,7 +486,7 @@ mod test {\n \n     #[test]\n     fn test_try_panic_message_any() {\n-        match try(proc() {\n+        match try(move|| {\n             panic!(box 413u16 as Box<Any + Send>);\n         }) {\n             Err(e) => {\n@@ -492,7 +504,7 @@ mod test {\n     fn test_try_panic_message_unit_struct() {\n         struct Juju;\n \n-        match try(proc() {\n+        match try(move|| {\n             panic!(Juju)\n         }) {\n             Err(ref e) if e.is::<Juju>() => {}\n@@ -507,7 +519,7 @@ mod test {\n         let stdout = ChanWriter::new(tx);\n \n         let r = TaskBuilder::new().stdout(box stdout as Box<Writer + Send>)\n-                                  .try(proc() {\n+                                  .try(move|| {\n                 print!(\"Hello, world!\");\n             });\n         assert!(r.is_ok());\n@@ -527,7 +539,7 @@ fn task_abort_no_kill_runtime() {\n     use mem;\n \n     let tb = TaskBuilder::new();\n-    let rx = tb.try_future(proc() {});\n+    let rx = tb.try_future(move|| {});\n     mem::drop(rx);\n     timer::sleep(Duration::milliseconds(1000));\n }"}, {"sha": "2d5766c2393c97831ce5fe94334ae9d13fa135ef", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -77,7 +77,7 @@ pub mod scoped;\n /// });\n ///\n /// // each thread starts out with the initial value of 1\n-/// spawn(proc() {\n+/// spawn(move|| {\n ///     FOO.with(|f| {\n ///         assert_eq!(*f.borrow(), 1);\n ///         *f.borrow_mut() = 3;\n@@ -471,7 +471,7 @@ mod tests {\n             *f.get() = 2;\n         });\n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             FOO.with(|f| unsafe {\n                 assert_eq!(*f.get(), 1);\n             });\n@@ -491,7 +491,7 @@ mod tests {\n         })\n \n         let (tx, rx) = channel();\n-        spawn(proc() unsafe {\n+        spawn(move|| unsafe {\n             let mut tx = Some(tx);\n             FOO.with(|f| {\n                 *f.get() = Some(Foo(tx.take().unwrap()));\n@@ -539,7 +539,7 @@ mod tests {\n             }\n         }\n \n-        Thread::start(proc() {\n+        Thread::start(move|| {\n             drop(S1);\n         }).join();\n     }\n@@ -557,7 +557,7 @@ mod tests {\n             }\n         }\n \n-        Thread::start(proc() unsafe {\n+        Thread::start(move|| unsafe {\n             K1.with(|s| *s.get() = Some(S1));\n         }).join();\n     }\n@@ -584,7 +584,7 @@ mod tests {\n         }\n \n         let (tx, rx) = channel();\n-        spawn(proc() unsafe {\n+        spawn(move|| unsafe {\n             let mut tx = Some(tx);\n             K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n         });"}, {"sha": "ae7a2127e9f605349fd7a68c608ab1fc024c720e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -719,7 +719,6 @@ pub enum Expr_ {\n     ExprLoop(P<Block>, Option<Ident>),\n     ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n     ExprClosure(CaptureClause, Option<UnboxedClosureKind>, P<FnDecl>, P<Block>),\n-    ExprProc(P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(P<Expr>, P<Expr>),\n@@ -1225,8 +1224,6 @@ pub enum Ty_ {\n     TyRptr(Option<Lifetime>, MutTy),\n     /// A closure (e.g. `|uint| -> bool`)\n     TyClosure(P<ClosureTy>),\n-    /// A procedure (e.g `proc(uint) -> bool`)\n-    TyProc(P<ClosureTy>),\n     /// A bare function (e.g. `fn(uint) -> bool`)\n     TyBareFn(P<BareFnTy>),\n     /// A tuple (`(A, B, C, D,...)`)"}, {"sha": "5462918b662831f3dd60b93b4cb83b7bd3f25a6a", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -37,7 +37,7 @@ use visit;\n ///\n /// More specifically, it is one of either:\n ///   - A function item,\n-///   - A closure expr (i.e. an ExprClosure or ExprProc), or\n+///   - A closure expr (i.e. an ExprClosure), or\n ///   - The default implementation for a trait method.\n ///\n /// To construct one, use the `Code::from_node` function.\n@@ -73,7 +73,7 @@ impl MaybeFnLike for ast::TraitItem {\n impl MaybeFnLike for ast::Expr {\n     fn is_fn_like(&self) -> bool {\n         match self.node {\n-            ast::ExprClosure(..) | ast::ExprProc(..) => true,\n+            ast::ExprClosure(..) => true,\n             _ => false,\n         }\n     }\n@@ -222,8 +222,6 @@ impl<'a> FnLikeNode<'a> {\n             ast_map::NodeExpr(e) => match e.node {\n                 ast::ExprClosure(_, _, ref decl, ref block) =>\n                     closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n-                ast::ExprProc(ref decl, ref block) =>\n-                    closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n                 _ => panic!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => panic!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "6f1d2d39b30493df204cf7ea185292f60586c3fc", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -859,7 +859,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n     fn visit_ty(&mut self, ty: &'ast Ty) {\n         match ty.node {\n-            TyClosure(ref fd) | TyProc(ref fd) => {\n+            TyClosure(ref fd) => {\n                 self.visit_fn_decl(&*fd.decl);\n             }\n             TyBareFn(ref fd) => {"}, {"sha": "1a004ca7c44cc6c2d352e6dcdce1d048e38597b3", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -217,13 +217,6 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)})\n         }\n \n-        ast::ExprProc(fn_decl, block) => {\n-            let (rewritten_fn_decl, rewritten_block)\n-                = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n-            let new_node = ast::ExprProc(rewritten_fn_decl, rewritten_block);\n-            P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)})\n-        }\n-\n         _ => {\n             P(noop_fold_expr(ast::Expr {\n                 id: id,\n@@ -1576,17 +1569,6 @@ mod test {\n             0)\n     }\n \n-    // closure arg hygiene (ExprProc)\n-    // expands to fn f(){(proc(x_1 : int) {(x_2 + x_1)})(3);}\n-    #[test] fn closure_arg_hygiene_2(){\n-        run_renaming_test(\n-            &(\"macro_rules! inject_x (()=>(x))\n-              fn f(){ (proc(x : int){(inject_x!() + x)})(3); }\",\n-              vec!(vec!(1)),\n-              true),\n-            0)\n-    }\n-\n     // macro_rules in method position. Sadly, unimplemented.\n     #[test] fn macro_in_method_posn(){\n         expand_crate_str("}, {"sha": "66fe672c3e5e82e7b97e0d6ad636ca346513fa91", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -306,12 +306,6 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprClosure(_, Some(_), _, _) => {\n-                self.gate_feature(\"unboxed_closures\",\n-                                  e.span,\n-                                  \"unboxed closures are a work-in-progress \\\n-                                   feature with known bugs\");\n-            }\n             ast::ExprSlice(..) => {\n                 self.gate_feature(\"slicing_syntax\",\n                                   e.span,\n@@ -374,19 +368,6 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n         }\n         visit::walk_fn(self, fn_kind, fn_decl, block, span);\n     }\n-\n-    fn visit_path_parameters(&mut self, path_span: Span, parameters: &'v ast::PathParameters) {\n-        match *parameters {\n-            ast::ParenthesizedParameters(..) => {\n-                self.gate_feature(\"unboxed_closures\",\n-                                  path_span,\n-                                  \"parenthetical parameter notation is subject to change\");\n-            }\n-            ast::AngleBracketedParameters(..) => { }\n-        }\n-\n-        visit::walk_path_parameters(self, path_span, parameters)\n-    }\n }\n \n pub fn check_crate(span_handler: &SpanHandler, krate: &ast::Crate) -> (Features, Vec<Span>) {"}, {"sha": "611faa2c2c9091da6bb4d0ecb9643867a4a7f3da", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -425,17 +425,6 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                     }\n                 }))\n             }\n-            TyProc(f) => {\n-                TyProc(f.map(|ClosureTy {fn_style, onceness, bounds, decl, lifetimes}| {\n-                    ClosureTy {\n-                        fn_style: fn_style,\n-                        onceness: onceness,\n-                        bounds: fld.fold_bounds(bounds),\n-                        decl: fld.fold_fn_decl(decl),\n-                        lifetimes: fld.fold_lifetime_defs(lifetimes)\n-                    }\n-                }))\n-            }\n             TyBareFn(f) => {\n                 TyBareFn(f.map(|BareFnTy {lifetimes, fn_style, abi, decl}| BareFnTy {\n                     lifetimes: fld.fold_lifetime_defs(lifetimes),\n@@ -1360,10 +1349,6 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                         arms.move_map(|x| folder.fold_arm(x)),\n                         source)\n             }\n-            ExprProc(decl, body) => {\n-                ExprProc(folder.fold_fn_decl(decl),\n-                         folder.fold_block(body))\n-            }\n             ExprClosure(capture_clause, opt_kind, decl, body) => {\n                 ExprClosure(capture_clause,\n                             opt_kind,"}, {"sha": "3a7cc77515dbefc8d86394de73a3cfbf8c2aa8c7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -32,6 +32,8 @@ pub enum ObsoleteSyntax {\n     ObsoleteImportRenaming,\n     ObsoleteSubsliceMatch,\n     ObsoleteExternCrateRenaming,\n+    ObsoleteProcType,\n+    ObsoleteProcExpr,\n }\n \n impl Copy for ObsoleteSyntax {}\n@@ -55,6 +57,14 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     /// Reports an obsolete syntax non-fatal error.\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {\n+            ObsoleteProcType => (\n+                \"the `proc` type\",\n+                \"use unboxed closures instead\",\n+            ),\n+            ObsoleteProcExpr => (\n+                \"`proc` expression\",\n+                \"use a `move ||` expression instead\",\n+            ),\n             ObsoleteOwnedType => (\n                 \"`~` notation for owned pointers\",\n                 \"use `Box<T>` in `std::owned` instead\""}, {"sha": "381942a3e622f6eb2ec2329f4d2391cc28743620", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -27,10 +27,10 @@ use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast};\n use ast::{ExprField, ExprTupField, ExprClosure, ExprIf, ExprIfLet, ExprIndex, ExprSlice};\n use ast::{ExprLit, ExprLoop, ExprMac};\n-use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n+use ast::{ExprMethodCall, ExprParen, ExprPath};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n-use ast::{Once, Many};\n+use ast::{Many};\n use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod, FunctionRetTy};\n@@ -54,7 +54,7 @@ use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{TtDelimited, TtSequence, TtToken};\n use ast::{TupleVariantKind, Ty, Ty_, TypeBinding};\n-use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n+use ast::{TypeField, TyFixedLengthVec, TyClosure, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n@@ -1064,7 +1064,6 @@ impl<'a> Parser<'a> {\n         Deprecated:\n \n         - for <'lt> |S| -> T\n-        - for <'lt> proc(S) -> T\n \n         Eventually:\n \n@@ -1158,26 +1157,21 @@ impl<'a> Parser<'a> {\n          |     |    |    Bounds\n          |     |  Argument types\n          |   Legacy lifetimes\n-        the `proc` keyword\n+        the `proc` keyword (already consumed)\n \n         */\n \n-        let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n-        let (inputs, variadic) = self.parse_fn_args(false, false);\n-        let bounds = self.parse_colon_then_ty_param_bounds();\n-        let ret_ty = self.parse_ret_ty();\n-        let decl = P(FnDecl {\n-            inputs: inputs,\n-            output: ret_ty,\n-            variadic: variadic\n-        });\n-        TyProc(P(ClosureTy {\n-            fn_style: NormalFn,\n-            onceness: Once,\n-            bounds: bounds,\n-            decl: decl,\n-            lifetimes: lifetime_defs,\n-        }))\n+        let proc_span = self.last_span;\n+\n+        // To be helpful, parse the proc as ever\n+        let _ = self.parse_legacy_lifetime_defs(lifetime_defs);\n+        let _ = self.parse_fn_args(false, false);\n+        let _ = self.parse_colon_then_ty_param_bounds();\n+        let _ = self.parse_ret_ty();\n+\n+        self.obsolete(proc_span, ObsoleteProcType);\n+\n+        TyInfer\n     }\n \n     /// Parses an optional unboxed closure kind (`&:`, `&mut:`, or `:`).\n@@ -2294,17 +2288,10 @@ impl<'a> Parser<'a> {\n                     return self.parse_lambda_expr(CaptureByValue);\n                 }\n                 if self.eat_keyword(keywords::Proc) {\n-                    let decl = self.parse_proc_decl();\n-                    let body = self.parse_expr();\n-                    let fakeblock = P(ast::Block {\n-                            id: ast::DUMMY_NODE_ID,\n-                            view_items: Vec::new(),\n-                            stmts: Vec::new(),\n-                            rules: DefaultBlock,\n-                            span: body.span,\n-                            expr: Some(body),\n-                        });\n-                    return self.mk_expr(lo, fakeblock.span.hi, ExprProc(decl, fakeblock));\n+                    let span = self.last_span;\n+                    let _ = self.parse_proc_decl();\n+                    let _ = self.parse_expr();\n+                    return self.obsolete_expr(span, ObsoleteProcExpr);\n                 }\n                 if self.eat_keyword(keywords::If) {\n                     return self.parse_if_expr();"}, {"sha": "87905db22f349b857ded5af646c21d70cf2d0187", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 47, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -450,7 +450,7 @@ pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> String {\n fn needs_parentheses(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprAssign(..) | ast::ExprBinary(..) |\n-        ast::ExprClosure(..) | ast::ExprProc(..) |\n+        ast::ExprClosure(..) |\n         ast::ExprAssignOp(..) | ast::ExprCast(..) => true,\n         _ => false,\n     }\n@@ -734,25 +734,6 @@ impl<'a> State<'a> {\n                                       Some(&generics),\n                                       None));\n             }\n-            ast::TyProc(ref f) => {\n-                let generics = ast::Generics {\n-                    lifetimes: f.lifetimes.clone(),\n-                    ty_params: OwnedSlice::empty(),\n-                    where_clause: ast::WhereClause {\n-                        id: ast::DUMMY_NODE_ID,\n-                        predicates: Vec::new(),\n-                    },\n-                };\n-                try!(self.print_ty_fn(None,\n-                                      Some('~'),\n-                                      f.fn_style,\n-                                      f.onceness,\n-                                      &*f.decl,\n-                                      None,\n-                                      &f.bounds,\n-                                      Some(&generics),\n-                                      None));\n-            }\n             ast::TyPath(ref path, _) => {\n                 try!(self.print_path(path, false));\n             }\n@@ -1696,33 +1677,6 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 try!(self.ibox(0));\n             }\n-            ast::ExprProc(ref decl, ref body) => {\n-                // in do/for blocks we don't want to show an empty\n-                // argument list, but at this point we don't know which\n-                // we are inside.\n-                //\n-                // if !decl.inputs.is_empty() {\n-                try!(self.print_proc_args(&**decl));\n-                try!(space(&mut self.s));\n-                // }\n-                assert!(body.stmts.is_empty());\n-                assert!(body.expr.is_some());\n-                // we extract the block, so as not to create another set of boxes\n-                match body.expr.as_ref().unwrap().node {\n-                    ast::ExprBlock(ref blk) => {\n-                        try!(self.print_block_unclosed(&**blk));\n-                    }\n-                    _ => {\n-                        // this is a bare expression\n-                        try!(self.print_expr(body.expr.as_ref().map(|e| &**e).unwrap()));\n-                        try!(self.end()); // need to close a box\n-                    }\n-                }\n-                // a box will be closed by print_expr, but we didn't want an overall\n-                // wrapper so we closed the corresponding opening. so create an\n-                // empty box to satisfy the close.\n-                try!(self.ibox(0));\n-            }\n             ast::ExprBlock(ref blk) => {\n                 // containing cbox, will be closed by print-block at }\n                 try!(self.cbox(indent_unit));\n@@ -2010,6 +1964,7 @@ impl<'a> State<'a> {\n                 match data.output {\n                     None => { }\n                     Some(ref ty) => {\n+                        try!(self.space_if_not_bol());\n                         try!(self.word_space(\"->\"));\n                         try!(self.print_type(&**ty));\n                     }"}, {"sha": "eca99df8e5561c2985015a75bcdb47d0dcefc4c0", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -389,14 +389,6 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             walk_ty_param_bounds_helper(visitor, &function_declaration.bounds);\n             walk_lifetime_decls_helper(visitor, &function_declaration.lifetimes);\n         }\n-        TyProc(ref function_declaration) => {\n-            for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(&*argument.ty)\n-            }\n-            walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n-            walk_ty_param_bounds_helper(visitor, &function_declaration.bounds);\n-            walk_lifetime_decls_helper(visitor, &function_declaration.lifetimes);\n-        }\n         TyBareFn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&*argument.ty)\n@@ -831,13 +823,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                              expression.span,\n                              expression.id)\n         }\n-        ExprProc(ref function_declaration, ref body) => {\n-            visitor.visit_fn(FkFnBlock,\n-                             &**function_declaration,\n-                             &**body,\n-                             expression.span,\n-                             expression.id)\n-        }\n         ExprBlock(ref block) => visitor.visit_block(&**block),\n         ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n             visitor.visit_expr(&**right_hand_expression);"}, {"sha": "211c5906f4533b774cd1d7153b63d6e1d73ccd5a", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -32,7 +32,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(asm, macro_rules, phase, globs, slicing_syntax)]\n-#![feature(unboxed_closures)]\n+#![feature(unboxed_closures, default_type_params)]\n \n extern crate getopts;\n extern crate regex;\n@@ -71,6 +71,7 @@ use std::str::FromStr;\n use std::string::String;\n use std::task::TaskBuilder;\n use std::time::Duration;\n+use std::thunk::{Thunk, Invoke};\n \n // to be used by rustc to compile tests in libtest\n pub mod test {\n@@ -149,9 +150,9 @@ pub trait TDynBenchFn {\n pub enum TestFn {\n     StaticTestFn(fn()),\n     StaticBenchFn(fn(&mut Bencher)),\n-    StaticMetricFn(proc(&mut MetricMap):'static),\n-    DynTestFn(proc():Send),\n-    DynMetricFn(proc(&mut MetricMap):'static),\n+    StaticMetricFn(fn(&mut MetricMap)),\n+    DynTestFn(Thunk),\n+    DynMetricFn(Box<for<'a> Invoke<&'a mut MetricMap>+'static>),\n     DynBenchFn(Box<TDynBenchFn+'static>)\n }\n \n@@ -1119,8 +1120,8 @@ pub fn run_test(opts: &TestOpts,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: Sender<MonitorMsg>,\n                       nocapture: bool,\n-                      testfn: proc():Send) {\n-        spawn(proc() {\n+                      testfn: Thunk) {\n+        spawn(move || {\n             let (tx, rx) = channel();\n             let mut reader = ChanReader::new(rx);\n             let stdout = ChanWriter::new(tx.clone());\n@@ -1135,7 +1136,7 @@ pub fn run_test(opts: &TestOpts,\n                 task = task.stdout(box stdout as Box<Writer + Send>);\n                 task = task.stderr(box stderr as Box<Writer + Send>);\n             }\n-            let result_future = task.try_future(testfn);\n+            let result_future = task.try_future(move || testfn.invoke(()));\n \n             let stdout = reader.read_to_end().unwrap().into_iter().collect();\n             let task_result = result_future.into_inner();\n@@ -1157,7 +1158,7 @@ pub fn run_test(opts: &TestOpts,\n         }\n         DynMetricFn(f) => {\n             let mut mm = MetricMap::new();\n-            f(&mut mm);\n+            f.invoke(&mut mm);\n             monitor_ch.send((desc, TrMetrics(mm), Vec::new()));\n             return;\n         }\n@@ -1169,7 +1170,7 @@ pub fn run_test(opts: &TestOpts,\n         }\n         DynTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture, f),\n         StaticTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture,\n-                                          proc() f())\n+                                          Thunk::new(move|| f()))\n     }\n }\n \n@@ -1467,6 +1468,7 @@ mod tests {\n                Improvement, Regression, LikelyNoise,\n                StaticTestName, DynTestName, DynTestFn, ShouldFail};\n     use std::io::TempDir;\n+    use std::thunk::Thunk;\n \n     #[test]\n     pub fn do_not_run_ignored_tests() {\n@@ -1477,7 +1479,7 @@ mod tests {\n                 ignore: true,\n                 should_fail: ShouldFail::No,\n             },\n-            testfn: DynTestFn(proc() f()),\n+            testfn: DynTestFn(Thunk::new(move|| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1494,7 +1496,7 @@ mod tests {\n                 ignore: true,\n                 should_fail: ShouldFail::No,\n             },\n-            testfn: DynTestFn(proc() f()),\n+            testfn: DynTestFn(Thunk::new(move|| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1511,7 +1513,7 @@ mod tests {\n                 ignore: false,\n                 should_fail: ShouldFail::Yes(None)\n             },\n-            testfn: DynTestFn(proc() f()),\n+            testfn: DynTestFn(Thunk::new(move|| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1528,7 +1530,7 @@ mod tests {\n                 ignore: false,\n                 should_fail: ShouldFail::Yes(Some(\"error message\"))\n             },\n-            testfn: DynTestFn(proc() f()),\n+            testfn: DynTestFn(Thunk::new(move|| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1545,7 +1547,7 @@ mod tests {\n                 ignore: false,\n                 should_fail: ShouldFail::Yes(Some(\"foobar\"))\n             },\n-            testfn: DynTestFn(proc() f()),\n+            testfn: DynTestFn(Thunk::new(move|| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1562,7 +1564,7 @@ mod tests {\n                 ignore: false,\n                 should_fail: ShouldFail::Yes(None)\n             },\n-            testfn: DynTestFn(proc() f()),\n+            testfn: DynTestFn(Thunk::new(move|| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1608,15 +1610,15 @@ mod tests {\n                     ignore: true,\n                     should_fail: ShouldFail::No,\n                 },\n-                testfn: DynTestFn(proc() {}),\n+                testfn: DynTestFn(Thunk::new(move|| {})),\n             },\n             TestDescAndFn {\n                 desc: TestDesc {\n                     name: StaticTestName(\"2\"),\n                     ignore: false,\n                     should_fail: ShouldFail::No,\n                 },\n-                testfn: DynTestFn(proc() {}),\n+                testfn: DynTestFn(Thunk::new(move|| {})),\n             });\n         let filtered = filter_tests(&opts, tests);\n \n@@ -1652,7 +1654,7 @@ mod tests {\n                         ignore: false,\n                         should_fail: ShouldFail::No,\n                     },\n-                    testfn: DynTestFn(testfn),\n+                    testfn: DynTestFn(Thunk::new(testfn)),\n                 };\n                 tests.push(test);\n             }\n@@ -1693,7 +1695,7 @@ mod tests {\n                     ignore: false,\n                     should_fail: ShouldFail::No,\n                 },\n-                testfn: DynTestFn(test_fn)\n+                testfn: DynTestFn(Thunk::new(test_fn))\n             }\n         }).collect();\n         let filtered = filter_tests(&opts, tests);"}, {"sha": "1cccb0f7ccbe66b75a83c6c2ee2bd432fb5e54a3", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,7 +12,7 @@ use std::task;\n \n pub fn foo<T:Send + Clone>(x: T) -> Receiver<T> {\n     let (tx, rx) = channel();\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         tx.send(x.clone());\n     });\n     rx"}, {"sha": "f20fb8d0cd75e3322a0c8980dc17cddbc14bb2f3", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -64,15 +64,15 @@ fn run(args: &[String]) {\n         let mut worker_results = Vec::new();\n         for _ in range(0u, workers) {\n             let to_child = to_child.clone();\n-            worker_results.push(task::try_future(proc() {\n+            worker_results.push(task::try_future(move|| {\n                 for _ in range(0u, size / workers) {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(request::bytes(num_bytes));\n                 }\n                 //println!(\"worker {} exiting\", i);\n             }));\n         }\n-        task::spawn(proc() {\n+        task::spawn(move|| {\n             server(&from_parent, &to_parent);\n         });\n "}, {"sha": "179011be8bf4efd8749d79df88dc10b07ca1aa37", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -58,7 +58,7 @@ fn run(args: &[String]) {\n         let mut worker_results = Vec::new();\n         let from_parent = if workers == 1 {\n             let (to_child, from_parent) = channel();\n-            worker_results.push(task::try_future(proc() {\n+            worker_results.push(task::try_future(move|| {\n                 for _ in range(0u, size / workers) {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(request::bytes(num_bytes));\n@@ -70,7 +70,7 @@ fn run(args: &[String]) {\n             let (to_child, from_parent) = channel();\n             for _ in range(0u, workers) {\n                 let to_child = to_child.clone();\n-                worker_results.push(task::try_future(proc() {\n+                worker_results.push(task::try_future(move|| {\n                     for _ in range(0u, size / workers) {\n                         //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                         to_child.send(request::bytes(num_bytes));\n@@ -80,7 +80,7 @@ fn run(args: &[String]) {\n             }\n             from_parent\n         };\n-        task::spawn(proc() {\n+        task::spawn(move|| {\n             server(&from_parent, &to_parent);\n         });\n "}, {"sha": "49f53bf9d3883ec555497d40fd3dc23c6f5be2da", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -89,7 +89,7 @@ fn main() {\n             //println!(\"spawning %?\", i);\n             let (new_chan, num_port) = init();\n             let num_chan_2 = num_chan.clone();\n-            let new_future = Future::spawn(proc() {\n+            let new_future = Future::spawn(move|| {\n                 thread_ring(i, msg_per_task, num_chan_2, num_port)\n             });\n             futures.push(new_future);"}, {"sha": "73d54372b274f0aa0330bf89f7e3a2e508360912", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -34,15 +34,15 @@ fn ping_pong_bench(n: uint, m: uint) {\n         // Create a stream B->A\n         let (btx, brx) = channel::<()>();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let (tx, rx) = (atx, brx);\n             for _ in range(0, n) {\n                 tx.send(());\n                 rx.recv();\n             }\n         });\n \n-        spawn(proc() {\n+        spawn(move|| {\n             let (tx, rx) = (btx, arx);\n             for _ in range(0, n) {\n                 rx.recv();"}, {"sha": "bdf22cd7395889aa8647f252189a6aeb8674f73c", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -21,7 +21,7 @@ fn parfib(n: uint) -> uint {\n     }\n \n     let (tx, rx) = channel();\n-    spawn(proc() {\n+    spawn(move|| {\n         tx.send(parfib(n-1));\n     });\n     let m2 = parfib(n-2);"}, {"sha": "0b16e8011e8323975d96ef792b8070b18aff1610", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -95,7 +95,7 @@ fn main() {\n     let mut messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n             use std::num::Int;\n             let iterations = 2i.pow((max_depth - depth + min_depth) as uint);\n-            Future::spawn(proc() {\n+            Future::spawn(move|| {\n                 let mut chk = 0;\n                 for i in range(1, iterations + 1) {\n                     let arena = TypedArena::new();"}, {"sha": "dcdb90a11c88ca89f48261efc52dc48d5c60a596", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -188,7 +188,7 @@ fn rendezvous(nn: uint, set: Vec<Color>) {\n             let to_rendezvous = to_rendezvous.clone();\n             let to_rendezvous_log = to_rendezvous_log.clone();\n             let (to_creature, from_rendezvous) = channel();\n-            spawn(proc() {\n+            spawn(move|| {\n                 creature(ii,\n                          col,\n                          from_rendezvous,"}, {"sha": "4849421a3f01eceaebe07fdab4cbed2afadb1ef1", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -168,7 +168,7 @@ fn fannkuch(n: i32) -> (i32, i32) {\n     for (i, j) in range(0, N).zip(iter::count(0, k)) {\n         let max = cmp::min(j+k, perm.max());\n \n-        futures.push(Future::spawn(proc() {\n+        futures.push(Future::spawn(move|| {\n             work(perm, j as uint, max as uint)\n         }))\n     }"}, {"sha": "8c11c3673d5274ebc4bf2b990fae29a47760c0f0", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -168,7 +168,7 @@ fn main() {\n \n         let (to_child, from_parent) = channel();\n \n-        spawn(proc() {\n+        spawn(move|| {\n             make_sequence_processor(sz, &from_parent, &to_parent_);\n         });\n "}, {"sha": "d112fe60674dadc4fec5d379cffbbe2cbd00c145", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -303,11 +303,11 @@ fn main() {\n \n     let nb_freqs: Vec<(uint, Future<Table>)> = range(1u, 3).map(|i| {\n         let input = input.clone();\n-        (i, Future::spawn(proc() generate_frequencies(input.as_slice(), i)))\n+        (i, Future::spawn(move|| generate_frequencies(input.as_slice(), i)))\n     }).collect();\n     let occ_freqs: Vec<Future<Table>> = OCCURRENCES.iter().map(|&occ| {\n         let input = input.clone();\n-        Future::spawn(proc() generate_frequencies(input.as_slice(), occ.len()))\n+        Future::spawn(move|| generate_frequencies(input.as_slice(), occ.len()))\n     }).collect();\n \n     for (i, freq) in nb_freqs.into_iter() {"}, {"sha": "bb0e09370d8e9e7b3492e6ea4906f20ef2acdddb", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -82,7 +82,7 @@ fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n     let mut precalc_i = Vec::with_capacity(h);\n \n     let precalc_futures = Vec::from_fn(WORKERS, |i| {\n-        Future::spawn(proc () {\n+        Future::spawn(move|| {\n             let mut rs = Vec::with_capacity(w / WORKERS);\n             let mut is = Vec::with_capacity(w / WORKERS);\n \n@@ -123,7 +123,7 @@ fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n         let vec_init_r = arc_init_r.clone();\n         let vec_init_i = arc_init_i.clone();\n \n-        Future::spawn(proc () {\n+        Future::spawn(move|| {\n             let mut res: Vec<u8> = Vec::with_capacity((chunk_size * w) / 8);\n             let init_r_slice = vec_init_r.as_slice();\n "}, {"sha": "9a3b6953062b4464e42effd44e77d84fa87ef300", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -310,7 +310,7 @@ fn par_search(masks: Vec<Vec<Vec<u64>>>) -> Data {\n         let masks = masks.clone();\n         let tx = tx.clone();\n         let m = *m;\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut data = Data::new();\n             search(&*masks, m, 1, List::Cons(m, &List::Nil), &mut data);\n             tx.send(data);"}, {"sha": "fae6d2cc3aa65c72359f9a5d96f529fd786caed2", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -34,15 +34,15 @@ fn fib(n: int) -> int {\n         } else {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n-            task::spawn(proc() pfib(&tx2, n - 1));\n+            task::spawn(move|| pfib(&tx2, n - 1));\n             let tx2 = tx1.clone();\n-            task::spawn(proc() pfib(&tx2, n - 2));\n+            task::spawn(move|| pfib(&tx2, n - 2));\n             tx.send(rx.recv() + rx.recv());\n         }\n     }\n \n     let (tx, rx) = channel();\n-    spawn(proc() pfib(&tx, n) );\n+    spawn(move|| pfib(&tx, n) );\n     rx.recv()\n }\n \n@@ -77,7 +77,7 @@ fn stress_task(id: int) {\n fn stress(num_tasks: int) {\n     let mut results = Vec::new();\n     for i in range(0, num_tasks) {\n-        results.push(task::try_future(proc() {\n+        results.push(task::try_future(move|| {\n             stress_task(i);\n         }));\n     }"}, {"sha": "9b8fd51c1c5dd8974acd199dfbb650bee9fb28bc", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -72,7 +72,7 @@ fn main() {\n     let seq_arc = Arc::new(seq.clone()); // copy before it moves\n     let clen = seq.len();\n \n-    let mut seqlen = Future::spawn(proc() {\n+    let mut seqlen = Future::spawn(move|| {\n         let substs = vec![\n             (regex!(\"B\"), \"(c|g|t)\"),\n             (regex!(\"D\"), \"(a|g|t)\"),\n@@ -108,7 +108,7 @@ fn main() {\n     for variant in variants.into_iter() {\n         let seq_arc_copy = seq_arc.clone();\n         variant_strs.push(variant.to_string());\n-        counts.push(Future::spawn(proc() {\n+        counts.push(Future::spawn(move|| {\n             count_matches(seq_arc_copy.as_slice(), &variant)\n         }));\n     }"}, {"sha": "312ee2dd27e4d3c0306d5263ad15047beabb7ec7", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -236,7 +236,7 @@ fn parallel<'a, I, T, F>(mut iter: I, f: F)\n         // boundary.\n         let f = &f as *const F as *const uint;\n         let raw = chunk.repr();\n-        spawn(proc() {\n+        spawn(move|| {\n             let f = f as *const F;\n             unsafe { (*f)(mem::transmute(raw)) }\n             drop(tx)"}, {"sha": "647c47b00a0b725e4f679db5a95775755e01ecd4", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -124,7 +124,7 @@ fn parallel<'a, T, F>(v: &'a mut [T], f: F)\n         // boundary.\n         let f = &f as *const _ as *const uint;\n         let raw = chunk.repr();\n-        spawn(proc() {\n+        spawn(move|| {\n             let f = f as *const F;\n             unsafe { (*f)(i * size, mem::transmute(raw)) }\n             drop(tx)"}, {"sha": "111a92b083aa38aa4d74cb2f4af9a9a183981f15", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -43,10 +43,10 @@ fn start(n_tasks: int, token: int) {\n     tx.send(token);\n     for i in range(2, n_tasks + 1) {\n         let (tx, next_rx) = channel();\n-        spawn(proc() roundtrip(i, tx, rx));\n+        spawn(move|| roundtrip(i, tx, rx));\n         rx = next_rx;\n     }\n-    spawn(proc() roundtrip(1, tx, rx));\n+    spawn(move|| roundtrip(1, tx, rx));\n }\n \n fn roundtrip(id: int, tx: Sender<int>, rx: Receiver<int>) {"}, {"sha": "ca36d99014cf4b530b8a2805ed9c683da7df13ba", "filename": "src/test/bench/spawnone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fspawnone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Fspawnone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fspawnone.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -10,5 +10,5 @@\n \n // Useful for checking syscall usage of baseline scheduler usage\n fn main() {\n-    spawn(proc() {});\n+    spawn(move|| {});\n }"}, {"sha": "8bcf30b4859ff0852fedc99318f6c12821938229", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -36,7 +36,7 @@ fn main() {\n fn run(repeat: int, depth: int) {\n     for _ in range(0, repeat) {\n         let dur = Duration::span(|| {\n-            task::try(proc() {\n+            task::try(move|| {\n                 recurse_or_panic(depth, None)\n             });\n         });"}, {"sha": "789ccb6142a118ee238c47b7e2ab1b2915e8106e", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -26,7 +26,7 @@ fn child_generation(gens_left: uint, tx: comm::Sender<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n-    spawn(proc() {\n+    spawn(move|| {\n         if gens_left & 1 == 1 {\n             task::deschedule(); // shake things up a bit\n         }"}, {"sha": "e3b51cb6b5bfd2405967e3c8f983021bf9b75db5", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -21,7 +21,7 @@ fn calc(children: uint, parent_wait_chan: &Sender<Sender<Sender<int>>>) {\n \n     let wait_ports: Vec<Reciever<Sender<Sender<int>>>> = vec::from_fn(children, |_| {\n         let (wait_port, wait_chan) = stream::<Sender<Sender<int>>>();\n-        task::spawn(proc() {\n+        task::spawn(move|| {\n             calc(children / 2, &wait_chan);\n         });\n         wait_port\n@@ -58,7 +58,7 @@ fn main() {\n \n     let children = from_str::<uint>(args[1]).unwrap();\n     let (wait_port, wait_chan) = stream();\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         calc(children, &wait_chan);\n     });\n "}, {"sha": "a6852d396d9cf2f3c7bb721e386eb548c9a11863", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -15,7 +15,7 @@ use std::uint;\n fn f(n: uint) {\n     let mut i = 0u;\n     while i < n {\n-        task::try(proc() g());\n+        task::try(move|| g());\n         i += 1u;\n     }\n }\n@@ -33,5 +33,5 @@ fn main() {\n     };\n     let n = from_str::<uint>(args[1].as_slice()).unwrap();\n     let mut i = 0u;\n-    while i < n { task::spawn(proc() f(n) ); i += 1u; }\n+    while i < n { task::spawn(move|| f(n) ); i += 1u; }\n }"}, {"sha": "eb2ea6b3de42ffcf91120e764b8185d578033364", "filename": "src/test/compile-fail/borrowck-call-sendfn.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3a9305ce823df267fb1afcce76ef06ca09e407ff/src%2Ftest%2Fcompile-fail%2Fborrowck-call-sendfn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a9305ce823df267fb1afcce76ef06ca09e407ff/src%2Ftest%2Fcompile-fail%2Fborrowck-call-sendfn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-sendfn.rs?ref=3a9305ce823df267fb1afcce76ef06ca09e407ff", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Foo {\n-    f: proc():'static\n-}\n-\n-fn call(x: Foo) {\n-    x.f(); //~ ERROR does not implement any method in scope named `f`\n-}\n-\n-fn main() {}"}, {"sha": "cecb8a09c665ad1486e6a2a4bc02670fe82f7ca2", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -17,7 +17,7 @@ fn borrow(v: &int, f: |x: &int|) {\n fn box_imm() {\n     let v = box 3i;\n     let _w = &v;\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         println!(\"v={}\", *v);\n         //~^ ERROR cannot move `v` into closure\n     });\n@@ -26,7 +26,7 @@ fn box_imm() {\n fn box_imm_explicit() {\n     let v = box 3i;\n     let _w = &v;\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         println!(\"v={}\", *v);\n         //~^ ERROR cannot move\n     });"}, {"sha": "aae661e5c537937bbd6849e1385c4b288eafbb32", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,6 +11,6 @@\n pub fn main() {\n     let bar = box 3;\n     let _g = || {\n-        let _h: proc() -> int = proc() *bar; //~ ERROR cannot move out of captured outer variable\n+        let _h = move|| -> int { *bar }; //~ ERROR cannot move out of captured outer variable\n     };\n }"}, {"sha": "ca484738cb6c887a2611536469a2cee41307cc1f", "filename": "src/test/compile-fail/borrowck-move-moved-value-into-closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fborrowck-move-moved-value-into-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fborrowck-move-moved-value-into-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-moved-value-into-closure.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn call_f(f: proc() -> int) -> int {\n+fn call_f<F:FnOnce() -> int>(f: F) -> int {\n     f()\n }\n \n fn main() {\n     let t = box 3;\n \n-    call_f(proc() { *t + 1 });\n-    call_f(proc() { *t + 1 }); //~ ERROR capture of moved value\n+    call_f(move|| { *t + 1 });\n+    call_f(move|| { *t + 1 }); //~ ERROR capture of moved value\n }"}, {"sha": "a9c368fb052583331d9ccff96ade666c1ad63394", "filename": "src/test/compile-fail/borrowck-multiple-captures.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -17,7 +17,7 @@ fn different_vars_after_borrows() {\n     let p1 = &x1;\n     let x2 = box 2i;\n     let p2 = &x2;\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         drop(x1); //~ ERROR cannot move `x1` into closure because it is borrowed\n         drop(x2); //~ ERROR cannot move `x2` into closure because it is borrowed\n     });\n@@ -30,7 +30,7 @@ fn different_vars_after_moves() {\n     drop(x1);\n     let x2 = box 2i;\n     drop(x2);\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         drop(x1); //~ ERROR capture of moved value: `x1`\n         drop(x2); //~ ERROR capture of moved value: `x2`\n     });\n@@ -39,7 +39,7 @@ fn different_vars_after_moves() {\n fn same_var_after_borrow() {\n     let x = box 1i;\n     let p = &x;\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         drop(x); //~ ERROR cannot move `x` into closure because it is borrowed\n         drop(x); //~ ERROR use of moved value: `x`\n     });\n@@ -49,7 +49,7 @@ fn same_var_after_borrow() {\n fn same_var_after_move() {\n     let x = box 1i;\n     drop(x);\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         drop(x); //~ ERROR capture of moved value: `x`\n         drop(x); //~ ERROR use of moved value: `x`\n     });"}, {"sha": "143e78e5d9f00f7fdc7dcffcbbe69a2bbaf3225b", "filename": "src/test/compile-fail/cannot-mutate-captured-non-mut-var.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -10,10 +10,10 @@\n \n fn main() {\n     let x = 1i;\n-    proc() { x = 2; };\n-    //~^ ERROR: cannot assign to immutable captured outer variable in a proc `x`\n+    move|:| { x = 2; };\n+    //~^ ERROR: cannot assign to immutable captured outer variable\n \n     let s = std::io::stdin();\n-    proc() { s.read_to_end(); };\n-    //~^ ERROR: cannot borrow immutable captured outer variable in a proc `s` as mutable\n+    move|:| { s.read_to_end(); };\n+    //~^ ERROR: cannot borrow immutable captured outer variable\n }"}, {"sha": "27e339180a6cffe2b4f4c26bf088ad7d584fcc61", "filename": "src/test/compile-fail/coerce-bare-fn-to-closure-and-proc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,10 +12,8 @@ fn foo() {}\n \n fn main() {\n     let f = foo;\n+\n     let f_closure: || = f;\n     //~^ ERROR: cannot coerce non-statically resolved bare fn to closure\n     //~^^ HELP: consider embedding the function in a closure\n-    let f_proc: proc() = f;\n-    //~^ ERROR: cannot coerce non-statically resolved bare fn to closure\n-    //~^^ HELP: consider embedding the function in a closure\n }"}, {"sha": "c90f064bf904c7acf6ed1e352a35e3a275cae959", "filename": "src/test/compile-fail/issue-10398.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fissue-10398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fissue-10398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10398.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let x = box 1i;\n-    let f: proc() = proc() {\n+    let f = move|:| {\n         let _a = x;\n         drop(x);\n         //~^ ERROR: use of moved value: `x`"}, {"sha": "46fcb2ec340f9cafdf017d823802006ca28bc644", "filename": "src/test/compile-fail/issue-11515.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fissue-11515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fissue-11515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11515.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n struct Test<'s> {\n-    func: ||: 's,\n+    func: Box<FnMut()+'static>\n }\n \n fn main() {\n-    let test = box Test { func: proc() {} };\n-    //~^ ERROR: expected `||`, found `proc()`\n+    let closure: Box<Fn()+'static> = box || ();\n+    let test = box Test { func: closure }; //~ ERROR mismatched types\n }"}, {"sha": "c561f0a696a9f33f7f9c73365b81027589e53646", "filename": "src/test/compile-fail/issue-11925.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fissue-11925.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fissue-11925.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11925.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let r = {\n         let x = box 42i;\n-        let f = proc() &x; //~ ERROR: `x` does not live long enough\n+        let f = move|:| &x; //~ ERROR: `x` does not live long enough\n         f()\n     };\n "}, {"sha": "1878b5f5dea8d670c561eeacdf4c1bb59200b66b", "filename": "src/test/compile-fail/issue-12041.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let (tx, rx) = channel();\n-    spawn(proc() {\n+    spawn(move|| {\n         loop {\n             let tx = tx;\n             //~^ ERROR: use of moved value: `tx`"}, {"sha": "5f2837d28755de1c5969e9f2ee3bce9108683d9a", "filename": "src/test/compile-fail/issue-12127.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fissue-12127.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fissue-12127.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12127.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+fn do_it(x: &int) { }\n+\n fn main() {\n-    let f = proc() {};\n-    (proc() {\n+    let x = box 22;\n+    let f = move|:| do_it(&*x);\n+    (move|:| {\n         f();\n         f();\n         //~^ ERROR: use of moved value: `f`"}, {"sha": "eee23f1feba277915c394d233d5e5699af858591", "filename": "src/test/compile-fail/issue-13599.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3a9305ce823df267fb1afcce76ef06ca09e407ff/src%2Ftest%2Fcompile-fail%2Fissue-13599.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a9305ce823df267fb1afcce76ef06ca09e407ff/src%2Ftest%2Fcompile-fail%2Fissue-13599.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13599.rs?ref=3a9305ce823df267fb1afcce76ef06ca09e407ff", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that a mismatched proc / closure type is correctly reported.\n-\n-fn expect_closure(_: ||) {}\n-\n-fn expect_proc(_: proc()) {}\n-\n-fn main() {\n-    expect_closure(proc() {});\n-    //~^ ERROR mismatched types: expected `||`, found `proc()` (expected closure, found proc)\n-\n-    expect_proc(|| {});\n-    //~^ ERROR mismatched types: expected `proc()`, found `||` (expected proc, found closure)\n-}"}, {"sha": "c96054afc2f311c8ba09f92fb166dcc913adbe5b", "filename": "src/test/compile-fail/kindck-nonsendable-1.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -13,14 +13,10 @@ use std::rc::Rc;\n \n fn foo(_x: Rc<uint>) {}\n \n-fn bar() {\n-    let x = Rc::new(3u);\n-    let _: proc():Send = proc() foo(x); //~ ERROR `core::kinds::Send` is not implemented\n-}\n+fn bar<F:FnOnce() + Send>(_: F) { }\n \n-fn bar2() {\n+fn main() {\n     let x = Rc::new(3u);\n-    let _: proc() = proc() foo(x);\n+    bar(move|| foo(x)); //~ ERROR `core::kinds::Send` is not implemented\n }\n \n-fn main() { }"}, {"sha": "3b67e98f42ca81d55e51967c243fa74a41952ef5", "filename": "src/test/compile-fail/kindck-send-object.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -27,18 +27,13 @@ fn box_object_with_no_bound_not_ok<'a>() {\n     assert_send::<Box<Dummy>>(); //~ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n-fn proc_with_no_bound_not_ok<'a>() {\n-    assert_send::<proc()>(); //~ ERROR the trait `core::kinds::Send` is not implemented\n-}\n-\n fn closure_with_no_bound_not_ok<'a>() {\n     assert_send::<||:'static>(); //~ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n fn object_with_send_bound_ok() {\n     assert_send::<&'static (Dummy+Send)>();\n     assert_send::<Box<Dummy+Send>>();\n-    assert_send::<proc():Send>;\n     assert_send::<||:Send>;\n }\n "}, {"sha": "d83a8031c45db51c016cb01553f53f006139d237", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -35,11 +35,6 @@ fn test61() {\n \n // closure and object types can have lifetime bounds which make\n // them not ok\n-fn test_70<'a>() {\n-    assert_send::<proc():'a>();\n-    //~^ ERROR the trait `core::kinds::Send` is not implemented\n-}\n-\n fn test_71<'a>() {\n     assert_send::<Box<Dummy+'a>>();\n     //~^ ERROR the trait `core::kinds::Send` is not implemented"}, {"sha": "458e2aaf451a0483e183b7addfc0b20951d359f0", "filename": "src/test/compile-fail/moves-based-on-type-capture-clause-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,7 +12,7 @@ use std::task;\n \n fn main() {\n     let x = \"Hello world!\".to_string();\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         println!(\"{}\", x);\n     });\n     println!(\"{}\", x); //~ ERROR use of moved value"}, {"sha": "2cf7618d92dbc93f96d063d156fdaafdb3d19cb4", "filename": "src/test/compile-fail/moves-sru-moved-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-type Noncopyable = proc():'static;\n+type Noncopyable = Box<int>;\n \n struct Foo {\n     copied: int,"}, {"sha": "affe979268d21c85d28bc0167b531f7d28d6f981", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     let v = vec!(1i, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     let arc_v = Arc::new(v);\n \n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         assert_eq!((*arc_v)[3], 4);\n     });\n "}, {"sha": "60982a84b791e9e48a35474e778c63014b431312", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -15,7 +15,7 @@ fn main() {\n     let v = vec!(1i, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     let arc_v = Arc::new(v);\n \n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         assert_eq!((*arc_v)[3], 4);\n     });\n "}, {"sha": "e1ba36de7c0324357766cd392cb559521a59432d", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -35,9 +35,9 @@ fn main() {\n \n     let x = foo(Port(Rc::new(())));\n \n-    task::spawn(proc() {\n-        let y = x;\n+    task::spawn(move|| {\n         //~^ ERROR `core::kinds::Send` is not implemented\n+        let y = x;\n         println!(\"{}\", y);\n     });\n }"}, {"sha": "5208cdb6ad23191f5577b9cad0203f7a078d974f", "filename": "src/test/compile-fail/obsolete-proc.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fobsolete-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fobsolete-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobsolete-proc.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,13 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn is_static<T: 'static>() {}\n+// Test that we generate obsolete syntax errors around usages of `proc`.\n \n-fn foo<'a>() {\n-    is_static::<proc():'a>();\n-    //~^ ERROR declared lifetime bound not satisfied\n+fn foo(p: proc()) { } //~ ERROR obsolete syntax: the `proc` type\n \n-    is_static::<proc():'static>();\n-}\n+fn bar() { proc() 1; } //~ ERROR obsolete syntax: `proc` expression\n \n fn main() { }", "previous_filename": "src/test/compile-fail/regions-proc-bounds.rs"}, {"sha": "6441f308f29c6f079f4bce6c163f83d856b35bb1", "filename": "src/test/compile-fail/once-cant-call-twice-on-heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -14,14 +14,14 @@\n #![feature(once_fns)]\n use std::sync::Arc;\n \n-fn foo(blk: proc()) {\n+fn foo<F:FnOnce()>(blk: F) {\n     blk();\n     blk(); //~ ERROR use of moved value\n }\n \n fn main() {\n     let x = Arc::new(true);\n-    foo(proc() {\n+    foo(move|| {\n         assert!(*x);\n         drop(x);\n     });"}, {"sha": "67655f323f06533ca91e12571b3147cfaff4521f", "filename": "src/test/compile-fail/regions-bounded-by-send.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -66,11 +66,6 @@ fn object_with_send_bound_not_ok<'a>() {\n     //~^ ERROR declared lifetime bound not satisfied\n }\n \n-fn proc_with_lifetime_not_ok<'a>() {\n-    assert_send::<proc():'a>();\n-    //~^ ERROR not implemented\n-}\n-\n fn closure_with_lifetime_not_ok<'a>() {\n     assert_send::<||:'a>();\n     //~^ ERROR not implemented"}, {"sha": "8b2fdfe7cdd1547c1b3abb712cc06fb2bbc6ae54", "filename": "src/test/compile-fail/regions-infer-proc-static-upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fregions-infer-proc-static-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fregions-infer-proc-static-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-proc-static-upvar.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,22 +11,22 @@\n // Test that, when a variable of type `&T` is captured inside a proc,\n // we correctly infer/require that its lifetime is 'static.\n \n-fn foo(_p: proc():'static) { }\n+fn foo<F:FnOnce()+'static>(_p: F) { }\n \n static i: int = 3;\n \n fn capture_local() {\n     let x = 3i;\n     let y = &x; //~ ERROR `x` does not live long enough\n-    foo(proc() {\n+    foo(move|| {\n         let _a = *y;\n     });\n }\n \n fn capture_static() {\n     // Legal because &i can have static lifetime:\n     let y = &i;\n-    foo(proc() {\n+    foo(move|| {\n         let _a = *y;\n     });\n }"}, {"sha": "0841c1852f8830120f7095a5ffab70084e77e434", "filename": "src/test/compile-fail/regions-proc-bound-capture.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,19 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn borrowed_proc<'a>(x: &'a int) -> proc():'a -> int {\n+fn borrowed_proc<'a>(x: &'a int) -> Box<FnMut()->(int) + 'a> {\n     // This is legal, because the region bound on `proc`\n     // states that it captures `x`.\n-    proc() {\n-        *x\n-    }\n+    box move|| { *x }\n }\n \n-fn static_proc<'a>(x: &'a int) -> proc():'static -> int {\n+fn static_proc(x: &int) -> Box<FnMut()->(int) + 'static> {\n     // This is illegal, because the region bound on `proc` is 'static.\n-    proc() { //~ ERROR captured variable `x` outlives the `proc()`\n-        *x\n-    }\n+    box move|| { *x } //~ ERROR cannot infer\n }\n \n fn main() { }"}, {"sha": "6cc45090b9024a70b73bb0273e326a1c57838ec2", "filename": "src/test/compile-fail/spawn-non-nil-fn.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: mismatched types\n-\n use std::task;\n \n-fn main() { task::spawn(|| -> int { 10 }); }\n+fn main() {\n+    // We get an error because return type is `->int` and not `->()`.\n+    task::spawn(|| -> int { 10 });\n+    //~^ ERROR type mismatch\n+}"}, {"sha": "9bb8037e2c3441c88df29575ba44bb894356bcbf", "filename": "src/test/compile-fail/unboxed-closure-feature-gate.rs", "status": "renamed", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Funboxed-closure-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Funboxed-closure-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-feature-gate.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,10 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Check that parenthetical notation is feature-gated except with the\n+// `Fn` traits.\n+\n+trait Foo<A,R> {\n+}\n+\n fn main() {\n-    if true {\n-        proc(_) {}\n-    } else {\n-        proc(_: &mut ()) {}\n-    };\n+    let x: Box<Foo(int)>;\n+    //~^ ERROR parenthetical notation is only stable when used with the `Fn` family\n+\n+    // No errors with these:\n+    let x: Box<Fn(int)>;\n+    let x: Box<FnMut(int)>;\n+    let x: Box<FnOnce(int)>;\n }", "previous_filename": "src/test/run-pass/issue-14039.rs"}, {"sha": "a6184caf68b1f9ebb12da83bcb0bad003d3942b2", "filename": "src/test/compile-fail/unboxed-closure-sugar-used-on-struct-1.rs", "status": "renamed", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-1.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,15 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn is_send<T: Send>() {}\n-fn is_freeze<T: Sync>() {}\n \n-fn foo<'a>() {\n-    is_send::<proc()>();\n-    //~^ ERROR: the trait `core::kinds::Send` is not implemented\n+// Test that parentheses form doesn't work with struct types appearing in local variables.\n \n-    is_freeze::<proc()>();\n-    //~^ ERROR: the trait `core::kinds::Sync` is not implemented\n+struct Bar<A,R> {\n+    f: A, r: R\n+}\n+\n+fn bar() {\n+    let x: Box<Bar()> = panic!();\n+    //~^ ERROR parenthesized parameters may only be used with a trait\n }\n \n fn main() { }\n+", "previous_filename": "src/test/compile-fail/kindck-proc-bounds.rs"}, {"sha": "5e16adc4e424777fb661aba9a673558ded53dd24", "filename": "src/test/compile-fail/unboxed-closure-sugar-used-on-struct-3.rs", "status": "renamed", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-3.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,12 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that we don't ICE due to encountering unsubstituted type\n-// parameters when untupling FnOnce parameters during translation of\n-// an unboxing shim.\n+// Test that parentheses form doesn't work in expression paths.\n \n-#![feature(unboxed_closures)]\n+struct Bar<A,R> {\n+    f: A, r: R\n+}\n+\n+impl<A,B> Bar<A,B> {\n+    fn new() -> Bar<A,B> { panic!() }\n+}\n \n-fn main() {\n-    let _: Box<FnOnce<(),()>> = box move |&mut:| {};\n+fn bar() {\n+    let b = Box::Bar::<int,uint>::new(); // OK\n+\n+    let b = Box::Bar::()::new();\n+    //~^ ERROR expected ident, found `(`\n }\n+\n+fn main() { }\n+", "previous_filename": "src/test/run-pass/issue-18883.rs"}, {"sha": "d5fb505715e90e046b9671474dbb6e62aa9735fc", "filename": "src/test/compile-fail/unboxed-closure-sugar-used-on-struct.rs", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures)]\n+// Test that parentheses form doesn't work with struct types appearing in argument types.\n \n-use std::ops::FnOnce;\n+struct Bar<A,R> {\n+    f: A, r: R\n+}\n \n-fn main() {\n-    let task: Box<FnOnce(int) -> int> = box |: x| x;\n-    assert!(task.call_once((1234i,)) == 1234i);\n+fn foo(b: Box<Bar()>) {\n+    //~^ ERROR parenthesized parameters may only be used with a trait\n }\n \n+fn main() { }\n+", "previous_filename": "src/test/run-pass/unboxed-closures-unboxing-shim.rs"}, {"sha": "ddd2649a3fee5f52ae7efe51ba880eb026b84d23", "filename": "src/test/compile-fail/unboxed-closures-static-call-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,6 +12,6 @@\n \n fn main() {\n     let mut_ = |&mut: x| x;\n-    mut_.call((0i, )); //~ ERROR type `closure` does not implement\n+    mut_.call((0i, )); //~ ERROR does not implement any method in scope named `call`\n }\n "}, {"sha": "2c000e03ce43aaa069dd111f7bc9e6df7d5c4f00", "filename": "src/test/compile-fail/unused-mut-warning-captured-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Funused-mut-warning-captured-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fcompile-fail%2Funused-mut-warning-captured-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-mut-warning-captured-var.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -13,5 +13,5 @@\n fn main() {\n     let mut x = 1i;\n     //~^ ERROR: variable does not need to be mutable\n-    proc() { println!(\"{}\", x); };\n+    move|:| { println!(\"{}\", x); };\n }"}, {"sha": "fa7822495d5f15ede8117880cc1b546583fbd752", "filename": "src/test/debuginfo/lexical-scope-in-unique-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-unique-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-unique-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-unique-closure.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -77,7 +77,7 @@ fn main() {\n     zzz(); // #break\n     sentinel();\n \n-    let unique_closure: proc(int) = proc(x) {\n+    let unique_closure = |: x:int| {\n         zzz(); // #break\n         sentinel();\n "}, {"sha": "d72b080409e1d43fa4dc942b99ab30a8de397bf1", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -167,9 +167,6 @@\n \n \n // CLOSURES\n-// gdb-command:whatis some_proc\n-// gdb-check:type = struct (once proc(int, u8) -> (int, u8), uint)\n-\n // gdb-command:whatis stack_closure1\n // gdb-check:type = struct (&mut|int|, uint)\n \n@@ -322,8 +319,6 @@ fn main() {\n     // how that maps to rustc's internal representation of these forms.\n     // Once closures have reached their 1.0 form, the tests below should\n     // probably be expanded.\n-    let some_proc = (proc(a:int, b:u8) (a, b), 0u);\n-\n     let stack_closure1 = (|x:int| {}, 0u);\n     let stack_closure2 = (|x:i8, y: f32| { (x as f32) + y }, 0u);\n "}, {"sha": "328d4245eb61011acc5edbff4e2998a7356c513d", "filename": "src/test/pretty/closure-reform-pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fclosure-reform-pretty.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -13,7 +13,7 @@\n \n // pp-exact\n \n-fn call_it(f: proc(String) -> String) { }\n+fn call_it(f: Box<FnMut(String) -> String>) { }\n \n fn call_this(f: |&str|: Send) { }\n "}, {"sha": "1313af2df3d88c742a5b11f7b9658ca6519157e4", "filename": "src/test/pretty/fn-types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fpretty%2Ffn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Fpretty%2Ffn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ffn-types.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,5 +12,4 @@\n \n fn from_foreign_fn(_x: fn()) { }\n fn from_stack_closure(_x: ||) { }\n-fn from_unique_closure(_x: proc()) { }\n fn main() { }"}, {"sha": "e7c6dcc2df7e7530fad6dfff4ebe7b72d7198a3b", "filename": "src/test/run-fail/extern-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-fail%2Fextern-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-fail%2Fextern-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fextern-panic.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -42,7 +42,7 @@ fn count(n: uint) -> uint {\n \n fn main() {\n     for _ in range(0, 10u) {\n-        task::spawn(proc() {\n+        task::spawn(move|| {\n             let result = count(5u);\n             println!(\"result = %?\", result);\n             panic!();"}, {"sha": "b36383859320970a3b30f740110a6f9d9e5cdca1", "filename": "src/test/run-fail/panic-task-name-none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -13,7 +13,7 @@\n use std::task;\n \n fn main() {\n-    let r: Result<int,_> = task::try(proc() {\n+    let r: Result<int,_> = task::try(move|| {\n         panic!(\"test\");\n         1i\n     });"}, {"sha": "3c442861a44a3bad32cebe64751ad96c070fae0c", "filename": "src/test/run-fail/panic-task-name-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -14,7 +14,7 @@ use std::task::TaskBuilder;\n \n fn main() {\n     let r: Result<int,_> = TaskBuilder::new().named(\"owned name\".to_string())\n-                                             .try(proc() {\n+                                             .try(move|| {\n         panic!(\"test\");\n         1i\n     });"}, {"sha": "92ebb3b4587af6b277a3cfb8f71ecb6c482d8a60", "filename": "src/test/run-fail/panic-task-name-send-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-fail%2Fpanic-task-name-send-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-fail%2Fpanic-task-name-send-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-send-str.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -13,7 +13,7 @@\n fn main() {\n     let r: Result<int,_> =\n         ::std::task::TaskBuilder::new().named(\"send name\".into_cow())\n-                                       .try(proc() {\n+                                       .try(move|| {\n             panic!(\"test\");\n             3i\n         });"}, {"sha": "f8dfe9245b4389345a491d62428d84d5e7852509", "filename": "src/test/run-fail/panic-task-name-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-fail%2Fpanic-task-name-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-fail%2Fpanic-task-name-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-static.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,7 +12,7 @@\n \n fn main() {\n     let r: Result<int,_> =\n-        ::std::task::TaskBuilder::new().named(\"static name\").try(proc() {\n+        ::std::task::TaskBuilder::new().named(\"static name\").try(move|| {\n             panic!(\"test\");\n         });\n     assert!(r.is_ok());"}, {"sha": "58de34e92a09d3b8885b28c2f818ee1c8de24dcf", "filename": "src/test/run-fail/rt-set-exit-status-panic2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -36,7 +36,7 @@ fn r(x:int) -> r {\n \n fn main() {\n     error!(\"whatever\");\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n       let _i = r(5);\n     });\n     panic!();"}, {"sha": "d2fd5393834ebfbd32ae83308bc9af0902448528", "filename": "src/test/run-make/bootstrap-from-c-with-native/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,12 +12,13 @@\n #![crate_type=\"dylib\"]\n \n use std::rt;\n+use std::thunk::Thunk;\n \n #[no_mangle] // this needs to get called from C\n pub extern \"C\" fn foo(argc: int, argv: *const *const u8) -> int {\n-    rt::start(argc, argv, proc() {\n-        spawn(proc() {\n+    rt::start(argc, argv, Thunk::new(move|| {\n+        spawn(move|| {\n             println!(\"hello\");\n         });\n-    })\n+    }))\n }"}, {"sha": "e2cca4d11f9a93c24858270773804786fbf6a442", "filename": "src/test/run-make/static-unwinding/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-make%2Fstatic-unwinding%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-make%2Fstatic-unwinding%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstatic-unwinding%2Fmain.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -22,7 +22,7 @@ impl Drop for A {\n }\n \n fn main() {\n-    task::try(proc() {\n+    task::try(move|| {\n         let _a = A;\n         lib::callback(|| panic!());\n         1i"}, {"sha": "b4e366296517416d9be41076e3c208f8b47cd8dd", "filename": "src/test/run-pass/block-arg-call-as.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,17 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn asSendfn(f: proc() -> uint) -> uint {\n-   return f();\n-}\n-\n fn asBlock(f: || -> uint) -> uint {\n    return f();\n }\n \n pub fn main() {\n-   let x = asSendfn(proc() 22u);\n-   assert_eq!(x, 22u);\n    let x = asBlock(|| 22u);\n    assert_eq!(x, 22u);\n }"}, {"sha": "d017a0dbf9a3bb65d5e4a262efb5ac3015f4b506", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,14 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn inty(fun: proc(int) -> int) -> int {\n-    fun(100)\n-}\n-\n-fn booly(fun: proc(bool) -> bool) -> bool {\n-    fun(true)\n-}\n-\n // Check usage and precedence of block arguments in expressions:\n pub fn main() {\n     let v = vec!(-1.0f64, 0.0, 1.0, 2.0, 3.0);"}, {"sha": "a6b142bb12654afeb387b0cb92530f291433b187", "filename": "src/test/run-pass/borrowck-move-by-capture-ok.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fborrowck-move-by-capture-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fborrowck-move-by-capture-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-move-by-capture-ok.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,8 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unboxed_closures)]\n+\n pub fn main() {\n     let bar = box 3;\n-    let h: proc() -> int = proc() *bar;\n+    let h = |:| -> int *bar;\n     assert_eq!(h(), 3);\n }\n+"}, {"sha": "f2df5ef38c382025e99b05302095b45ed58259a3", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -32,7 +32,7 @@ impl Logger for MyWriter {\n fn main() {\n     let (tx, rx) = channel();\n     let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n-    spawn(proc() {\n+    spawn(move|| {\n         set_logger(box MyWriter(w) as Box<Logger+Send>);\n         debug!(\"debug\");\n         info!(\"info\");"}, {"sha": "bdd92919ef05bfb23466daddfe1b9bd7ae42279b", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -15,5 +15,5 @@ use std::task;\n fn child2(_s: String) { }\n \n pub fn main() {\n-    let _x = task::spawn(proc() child2(\"hi\".to_string()));\n+    let _x = task::spawn(move|| child2(\"hi\".to_string()));\n }"}, {"sha": "d3c703b258f73e3ec2978178bb714ff08256dd2d", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -18,10 +18,8 @@ struct Pair {\n pub fn main() {\n     let z = box Pair { a : 10, b : 12};\n \n-    let f: proc():Send = proc() {\n+    spawn(move|| {\n         assert_eq!(z.a, 10);\n         assert_eq!(z.b, 12);\n-    };\n-\n-    spawn(f);\n+    });\n }"}, {"sha": "cdcdad47ea49782a7c5ac98ef013c535409478fb", "filename": "src/test/run-pass/closure-bounds-can-capture-chan.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,15 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unboxed_closures)]\n+\n use std::comm;\n \n-fn foo(blk: proc()) {\n+fn foo<F:FnOnce()+Send>(blk: F) {\n     blk();\n }\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    foo(proc() {\n+    foo(move || {\n         tx.send(());\n     });\n     rx.recv();"}, {"sha": "03d9511b41c78c31f95a897b81c0816154e6c1a8", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,10 +11,14 @@\n /* Any copyright is dedicated to the Public Domain.\n  * http://creativecommons.org/publicdomain/zero/1.0/ */\n \n+#![feature(unboxed_closures)]\n+\n use std::mem;\n use std::io::stdio::println;\n \n-fn call_it(f: proc(String) -> String) {\n+fn call_it<F>(f: F)\n+    where F : FnOnce(String) -> String\n+{\n     println!(\"{}\", f(\"Fred\".to_string()))\n }\n \n@@ -49,15 +53,15 @@ pub fn main() {\n     // Procs\n \n     let greeting = \"Hello \".to_string();\n-    call_it(proc(s) {\n+    call_it(|s| {\n         format!(\"{}{}\", greeting, s)\n     });\n \n     let greeting = \"Goodbye \".to_string();\n-    call_it(proc(s) format!(\"{}{}\", greeting, s));\n+    call_it(|s| format!(\"{}{}\", greeting, s));\n \n     let greeting = \"How's life, \".to_string();\n-    call_it(proc(s: String) -> String {\n+    call_it(|s: String| -> String {\n         format!(\"{}{}\", greeting, s)\n     });\n "}, {"sha": "4caa234ac7ae325688aba6005c35beaa612b7101", "filename": "src/test/run-pass/closure-syntax.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -15,35 +15,23 @@\n \n fn foo<T>() {}\n \n-trait Bar1 {}\n-impl Bar1 for proc():'static {}\n-\n-trait Bar2 {}\n-impl Bar2 for proc():Send {}\n-\n trait Bar3 {}\n impl<'b> Bar3 for <'a>|&'a int|: 'b + Send -> &'a int {}\n \n-trait Bar4 {}\n-impl Bar4 for proc<'a>(&'a int):'static -> &'a int {}\n-\n struct Foo<'a> {\n     a: ||: 'a,\n     b: ||: 'static,\n     c: <'b>||: 'a,\n     d: ||: 'a + Sync,\n     e: <'b>|int|: 'a + Sync -> &'b f32,\n-    f: proc():'static,\n-    g: proc():'static+Sync,\n-    h: proc<'b>(int):'static+Sync -> &'b f32,\n }\n \n fn f<'a>(a: &'a int, f: <'b>|&'b int| -> &'b int) -> &'a int {\n     f(a)\n }\n \n-fn g<'a>(a: &'a int, f: proc<'b>(&'b int) -> &'b int) -> &'a int {\n-    f(a)\n+fn g<'a>(a: &'a int) -> &'a int {\n+    a\n }\n \n struct A;\n@@ -60,11 +48,6 @@ fn bar<'b>() {\n     foo::<||:'b + Sync>();\n     foo::<||:Sync>();\n     foo::< <'a>|int, f32, &'a int|:'b + Sync -> &'a int>();\n-    foo::<proc()>();\n-    foo::<proc() -> ()>();\n-    foo::<proc():'static>();\n-    foo::<proc():Sync>();\n-    foo::<proc<'a>(int, f32, &'a int):'static + Sync -> &'a int>();\n \n     foo::<<'a>||>();\n \n@@ -84,7 +67,6 @@ fn bar<'b>() {\n \n     // issue #13490\n     let _ = || -> ! loop {};\n-    let _ = proc() -> ! loop {};\n \n     // issue #17021\n     let c = box |&:| {};"}, {"sha": "5a1b401177e01707fc4e51041754347209ad605f", "filename": "src/test/run-pass/coerce-to-closure-and-proc.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unboxed_closures)]\n+\n fn id<T>(x: T) -> T {\n     x\n }\n@@ -24,24 +26,12 @@ pub fn main() {\n     let f: |int| -> int = id;\n     assert_eq!(f(5), 5);\n \n-    let f: proc(int) -> int = id;\n-    assert_eq!(f(5), 5);\n-\n     let f: |int| -> Foo<int> = Foo;\n     assert_eq!(f(5), Foo(5));\n \n-    let f: proc(int) -> Foo<int> = Foo;\n-    assert_eq!(f(5), Foo(5));\n-\n     let f: |int| -> Bar<int> = Bar::Baz;\n     assert_eq!(f(5), Bar::Baz(5));\n \n-    let f: proc(int) -> Bar<int> = Bar::Baz;\n-    assert_eq!(f(5), Bar::Baz(5));\n-\n     let f: |int| -> Option<int> = Some;\n     assert_eq!(f(5), Some(5));\n-\n-    let f: proc(int) -> Option<int> = Some;\n-    assert_eq!(f(5), Some(5));\n }"}, {"sha": "edd4d5642b5bf9ac7e58d0fde35ad6c13f8ce593", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,7 +12,7 @@ use std::task;\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _t = task::spawn(proc() { child(&tx) });\n+    let _t = task::spawn(move|| { child(&tx) });\n     let y = rx.recv();\n     println!(\"received\");\n     println!(\"{}\", y);"}, {"sha": "4e625ce1d1f96646d305a3d39177070eace1a753", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -84,7 +84,7 @@ pub fn test_destroy_actually_kills(force: bool) {\n     let (tx, rx1) = channel();\n     let mut t = timer::Timer::new().unwrap();\n     let rx2 = t.oneshot(Duration::milliseconds(1000));\n-    spawn(proc() {\n+    spawn(move|| {\n         select! {\n             () = rx2.recv() => unsafe { libc::exit(1) },\n             () = rx1.recv() => {}"}, {"sha": "24915d84e7eb1970d61a4b976b9cde878c9d4cdf", "filename": "src/test/run-pass/drop-trait-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -65,15 +65,15 @@ pub fn main() {\n     assert_eq!(receiver.recv_opt().ok(), None);\n \n     let (sender, receiver) = channel();\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         let v = Foo::FailingVariant { on_drop: SendOnDrop { sender: sender } };\n     });\n     assert_eq!(receiver.recv(), Message::Dropped);\n     assert_eq!(receiver.recv_opt().ok(), None);\n \n     let (sender, receiver) = channel();\n     {\n-        task::spawn(proc() {\n+        task::spawn(move|| {\n             let mut v = Foo::NestedVariant(box 42u, SendOnDrop {\n                 sender: sender.clone()\n             }, sender.clone());"}, {"sha": "2d4819231fad0a9fb7d1be6e065446e4bcff64a6", "filename": "src/test/run-pass/enum-null-pointer-opt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -14,8 +14,7 @@ use std::mem::size_of;\n trait Trait {}\n \n fn main() {\n-    // Closures - || / proc()\n-    assert_eq!(size_of::<proc()>(), size_of::<Option<proc()>>());\n+    // Closures - ||\n     assert_eq!(size_of::<||>(), size_of::<Option<||>>());\n \n     // Functions"}, {"sha": "87f1adba8ddcf494e24eb01a865591e1970a0fb9", "filename": "src/test/run-pass/explicit-self-generic.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-generic.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,14 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/**\n- * A function that returns a hash of a value\n- *\n- * The hash should concentrate entropy in the lower bits.\n- */\n-type HashFn<K> = proc(K):'static -> uint;\n-type EqFn<K> = proc(K, K):'static -> bool;\n-\n struct LM { resize_at: uint, size: uint }\n \n impl Copy for LM {}"}, {"sha": "aed1392c8b68b9d9739b3c42387b6e365b0c33cc", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -40,7 +40,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n pub fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         let result = count(1000);\n         println!(\"result = {}\", result);\n         assert_eq!(result, 1000);"}, {"sha": "3f5faabe595983755f3ef090f32c7240625b0585", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -44,7 +44,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n pub fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         let result = count(12);\n         println!(\"result = {}\", result);\n         assert_eq!(result, 2048);"}, {"sha": "8b080712b966191230376da7f5b3f80b3c0ef134", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -42,7 +42,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n \n pub fn main() {\n     for _ in range(0u, 100) {\n-        task::spawn(proc() {\n+        task::spawn(move|| {\n             assert_eq!(count(5), 16);\n         });\n     }"}, {"sha": "1c89d8ae1ce9d2934f977d794b269b76f3b28b5c", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -39,7 +39,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n \n pub fn main() {\n     for _ in range(0, 10u) {\n-        task::spawn(proc() {\n+        task::spawn(move|| {\n             let result = count(5);\n             println!(\"result = {}\", result);\n             assert_eq!(result, 16);"}, {"sha": "3f659f1dbfbf7fb93584a2bba9155b61e9b627b0", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -22,7 +22,7 @@ extern {\n \n pub fn main() {\n     unsafe {\n-        Thread::start(proc() {\n+        Thread::start(move|| {\n             let i = &100i;\n             rust_dbg_call(callback, mem::transmute(i));\n         }).join();"}, {"sha": "a92b361dd3355cd95933f941f2aa5048d74e3194", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -37,7 +37,7 @@ mod map_reduce {\n         for i in inputs.iter() {\n             let ctrl = ctrl.clone();\n             let i = i.clone();\n-            task::spawn(proc() map_task(ctrl.clone(), i.clone()) );\n+            task::spawn(move|| map_task(ctrl.clone(), i.clone()) );\n         }\n     }\n "}, {"sha": "53749f09f741e86207186f9d84b20e9ee03f541a", "filename": "src/test/run-pass/hrtb-parse.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -43,7 +43,5 @@ fn foo23(t: for<'a> unsafe extern \"C\" fn(int) -> int) { }\n fn foo30(t: for<'a> |int| -> int) { }\n fn foo31(t: for<'a> unsafe |int| -> int) { }\n \n-//fn foo40(t: for<'a> proc(int) -> int) { }\n-\n fn main() {\n }"}, {"sha": "e4168ea145212aa9afc0f219171b68c0a959cbb9", "filename": "src/test/run-pass/infinite-loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Finfinite-loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Finfinite-loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finfinite-loops.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -15,13 +15,13 @@\n // ignore-test\n \n fn loopy(n: int) {\n-    if n > 0 { spawn(proc() { loopy(n - 1) }); spawn(proc() { loopy(n - 1) }); }\n+    if n > 0 { spawn(move|| { loopy(n - 1) }); spawn(move|| { loopy(n - 1) }); }\n     loop { }\n }\n \n pub fn main() {\n     // Commenting this out, as this will hang forever otherwise.\n     // Even after seeing the comment above, I'm not sure what the\n     // intention of this test is.\n-    // spawn(proc() { loopy(5) });\n+    // spawn(move|| { loopy(5) });\n }"}, {"sha": "fd0ad1ef47ecbf9c782557081cc71c727aba6c0a", "filename": "src/test/run-pass/issue-10682.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-10682.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-10682.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10682.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,11 +11,10 @@\n // Regression test for issue #10682\n // Nested `proc` usage can't use outer owned data\n \n-\n fn work(_: Box<int>) {}\n-fn foo(_: proc()) {}\n+fn foo<F:FnOnce()>(_: F) {}\n \n pub fn main() {\n   let a = box 1;\n-  foo(proc() { foo(proc() { work(a) }) })\n+  foo(move|| { foo(move|| { work(a) }) })\n }"}, {"sha": "71b4cbe933427fc9175e6c395d85585bf2da4a08", "filename": "src/test/run-pass/issue-10718.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-10718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-10718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10718.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(p: proc()) {\n+#![feature(unboxed_closures)]\n+\n+fn f<F:FnOnce()>(p: F) {\n     p();\n }\n \n pub fn main() {\n-    let p = proc() ();\n+    let p = |:| ();\n     f(p);\n }"}, {"sha": "f9d79567932971a6569347f1f9dd91656ef4ebc8", "filename": "src/test/run-pass/issue-11709.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-11709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-11709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11709.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -15,14 +15,17 @@\n // when this bug was opened. The cases where the compiler\n // panics before the fix have a comment.\n \n-struct S {x:()}\n+#![feature(default_type_params)]\n+\n+use std::thunk::Thunk;\n \n+struct S {x:()}\n \n-fn test(slot: &mut Option<proc() -> proc()>, _: proc()) -> () {\n+fn test(slot: &mut Option<Thunk<(),Thunk>>) -> () {\n   let a = slot.take();\n   let _a = match a {\n     // `{let .. a(); }` would break\n-    Some(a) => { let _a = a(); },\n+    Some(a) => { let _a = a.invoke(()); },\n     None => (),\n   };\n }\n@@ -41,7 +44,7 @@ pub fn main() {\n     let _r = {};\n     let mut slot = None;\n     // `{ test(...); }` would break\n-    let _s : S  = S{ x: { test(&mut slot, proc() {}); } };\n+    let _s : S  = S{ x: { test(&mut slot); } };\n \n     let _b = not(true);\n }"}, {"sha": "13177880c5ab7da2d6c18498406ae2025351d2d1", "filename": "src/test/run-pass/issue-11958.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-11958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-11958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11958.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -16,7 +16,9 @@\n // We shouldn't need to rebind a moved upvar as mut if it's already\n // marked as mut\n \n+use std::thunk::Thunk;\n+\n pub fn main() {\n     let mut x = 1i;\n-    proc() { x = 2; };\n+    let _thunk = Thunk::new(move|| { x = 2; });\n }"}, {"sha": "e24cf5a0f26707d30cd760de1c8a0f793583af3b", "filename": "src/test/run-pass/issue-12684.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12684.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,7 +11,7 @@\n use std::time::Duration;\n \n fn main() {\n-    std::task::spawn(proc() customtask());\n+    std::task::spawn(move|| customtask());\n }\n \n fn customtask() {"}, {"sha": "46a81301dc3cf47926fb62f831006eb10fdc4aea", "filename": "src/test/run-pass/issue-13352.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-13352.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-13352.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13352.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -10,7 +10,9 @@\n \n extern crate libc;\n \n-fn foo(_: proc()) {}\n+use std::thunk::Thunk;\n+\n+fn foo(_: Thunk) {}\n \n fn main() {\n     foo(loop {"}, {"sha": "be851ddefc6451e0e8c4426b3d6555697def0fc9", "filename": "src/test/run-pass/issue-13494.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13494.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -19,7 +19,7 @@ fn helper(rx: Receiver<Sender<()>>) {\n \n fn main() {\n     let (tx, rx) = channel();\n-    spawn(proc() { helper(rx) });\n+    spawn(move|| { helper(rx) });\n     let (snd, rcv) = channel::<int>();\n     for _ in range(1i, 100000i) {\n         snd.send(1i);"}, {"sha": "03d18cf8c9815ceff651701620f195976f5096f3", "filename": "src/test/run-pass/issue-15571.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-15571.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-15571.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15571.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -45,15 +45,16 @@ fn match_on_binding() {\n \n fn match_on_upvar() {\n     let mut foo = Some(box 8i);\n-    (proc() {\n+    let f = move|:| {\n         match foo {\n             None => {},\n             Some(x) => {\n                 foo = Some(x);\n             }\n         }\n         println!(\"'{}'\", foo.unwrap());\n-    })();\n+    };\n+    f();\n }\n \n fn main() {"}, {"sha": "f329e7eed0d5d5f823046b9db08efa3763118db3", "filename": "src/test/run-pass/issue-16560.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-16560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-16560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16560.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -19,7 +19,7 @@ fn main() {\n     // Check that both closures are capturing by value\n     assert_eq!(1, mem::size_of_val(&closure));\n \n-    spawn(proc() {\n+    spawn(move|| {\n         let ok = closure;\n     })\n }"}, {"sha": "c695a9e8f9abc9bfb6eb2e8e48e0d12b1124a040", "filename": "src/test/run-pass/issue-16671.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16671.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -20,7 +20,7 @@\n \n pub fn main() {\n     let mut stdin = std::io::stdin();\n-    spawn(proc() {\n+    spawn(move|| {\n         let _ = stdin.read_to_end();\n     });\n }"}, {"sha": "552ce565f6b173f748544e25d951c274b54dee03", "filename": "src/test/run-pass/issue-16739.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-16739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-16739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16739.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,29 +11,29 @@\n #![feature(unboxed_closures)]\n \n // Test that unboxing shim for calling rust-call ABI methods through a\n-// trait box works and does not cause an ICE\n+// trait box works and does not cause an ICE.\n \n struct Foo { foo: uint }\n \n-impl FnOnce<(), uint> for Foo {\n-    extern \"rust-call\" fn call_once(self, _: ()) -> uint { self.foo }\n+impl FnMut<(), uint> for Foo {\n+    extern \"rust-call\" fn call_mut(&mut self, _: ()) -> uint { self.foo }\n }\n \n-impl FnOnce<(uint,), uint> for Foo {\n-    extern \"rust-call\" fn call_once(self, (x,): (uint,)) -> uint { self.foo + x }\n+impl FnMut<(uint,), uint> for Foo {\n+    extern \"rust-call\" fn call_mut(&mut self, (x,): (uint,)) -> uint { self.foo + x }\n }\n \n-impl FnOnce<(uint, uint), uint> for Foo {\n-    extern \"rust-call\" fn call_once(self, (x, y): (uint, uint)) -> uint { self.foo + x + y }\n+impl FnMut<(uint, uint), uint> for Foo {\n+    extern \"rust-call\" fn call_mut(&mut self, (x, y): (uint, uint)) -> uint { self.foo + x + y }\n }\n \n fn main() {\n-    let f = box Foo { foo: 42 } as Box<FnOnce<(), uint>>;\n-    assert_eq!(f.call_once(()), 42);\n+    let mut f = box Foo { foo: 42 } as Box<FnMut<(), uint>>;\n+    assert_eq!(f.call_mut(()), 42);\n \n-    let f = box Foo { foo: 40 } as Box<FnOnce<(uint,), uint>>;\n-    assert_eq!(f.call_once((2,)), 42);\n+    let mut f = box Foo { foo: 40 } as Box<FnMut<(uint,), uint>>;\n+    assert_eq!(f.call_mut((2,)), 42);\n \n-    let f = box Foo { foo: 40 } as Box<FnOnce<(uint, uint), uint>>;\n-    assert_eq!(f.call_once((1, 1)), 42);\n+    let mut f = box Foo { foo: 40 } as Box<FnMut<(uint, uint), uint>>;\n+    assert_eq!(f.call_mut((1, 1)), 42);\n }"}, {"sha": "3554f2e8f0c315253073189ac178cc88ad7de5b0", "filename": "src/test/run-pass/issue-2190-1.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -9,19 +9,20 @@\n // except according to those terms.\n \n use std::task::TaskBuilder;\n+use std::thunk::Thunk;\n \n static generations: uint = 1024+256+128+49;\n \n-fn spawn(f: proc():Send) {\n-    TaskBuilder::new().stack_size(32 * 1024).spawn(f)\n+fn spawn(f: Thunk) {\n+    TaskBuilder::new().stack_size(32 * 1024).spawn(move|| f.invoke(()))\n }\n \n-fn child_no(x: uint) -> proc():Send {\n-    proc() {\n+fn child_no(x: uint) -> Thunk {\n+    Thunk::new(move|| {\n         if x < generations {\n             spawn(child_no(x+1));\n         }\n-    }\n+    })\n }\n \n pub fn main() {"}, {"sha": "651315ea6417347bbd1868d0104f64535b3409ab", "filename": "src/test/run-pass/issue-3424.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3424.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,20 +11,23 @@\n \n // rustc --test ignores2.rs && ./ignores2\n \n+#![feature(unboxed_closures)]\n+\n use std::path::{Path};\n use std::path;\n use std::result;\n+use std::thunk::Thunk;\n \n-type rsrc_loader = proc(path: &Path):'static -> result::Result<String, String>;\n+type rsrc_loader = Box<FnMut(&Path) -> (result::Result<String, String>) + 'static>;\n \n fn tester()\n {\n-    let loader: rsrc_loader = proc(_path) {\n+    let mut loader: rsrc_loader = box move|_path| {\n         result::Result::Ok(\"more blah\".to_string())\n     };\n \n     let path = path::Path::new(\"blah\");\n-    assert!(loader(&path).is_ok());\n+    assert!(loader.call_mut((&path,)).is_ok());\n }\n \n pub fn main() {}"}, {"sha": "f17f9411d15e803ab345fdd07b0dea36aad3f89f", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -8,24 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(default_type_params)]\n+\n use std::task;\n+use std::thunk::Invoke;\n \n type RingBuffer = Vec<f64> ;\n-type SamplesFn = proc(samples: &RingBuffer):Send;\n+type SamplesFn = Box<FnMut(&RingBuffer) + Send>;\n \n enum Msg\n {\n     GetSamples(String, SamplesFn), // sample set name, callback which receives samples\n }\n \n fn foo(name: String, samples_chan: Sender<Msg>) {\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         let mut samples_chan = samples_chan;\n-        let callback: SamplesFn = proc(buffer) {\n+\n+        // `box() (...)` syntax is needed to make pretty printer converge in one try:\n+        let callback: SamplesFn = box() (move |buffer| {\n             for i in range(0u, buffer.len()) {\n                 println!(\"{}: {}\", i, buffer[i])\n             }\n-        };\n+        });\n+\n         samples_chan.send(Msg::GetSamples(name.clone(), callback));\n     });\n }"}, {"sha": "daa80aec28c049ec2b668bea0ae90a3f6c04c4c6", "filename": "src/test/run-pass/issue-4446.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4446.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n \n     tx.send(\"hello, world\");\n \n-    spawn(proc() {\n+    spawn(move|| {\n         println(rx.recv());\n     });\n }"}, {"sha": "3ea968c416f454f4643a586e51ecf560cc01e96d", "filename": "src/test/run-pass/issue-4448.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4448.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -13,7 +13,7 @@ use std::task;\n pub fn main() {\n     let (tx, rx) = channel::<&'static str>();\n \n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         assert_eq!(rx.recv(), \"hello, world\");\n     });\n "}, {"sha": "b9b365e3e660a3a648813b0c5c97e78b28986780", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,24 +12,24 @@ use std::{int, i8, i16, i32, i64};\n use std::task;\n \n fn main() {\n-    assert!(task::try(proc() int::MIN / -1).is_err());\n-    assert!(task::try(proc() i8::MIN / -1).is_err());\n-    assert!(task::try(proc() i16::MIN / -1).is_err());\n-    assert!(task::try(proc() i32::MIN / -1).is_err());\n-    assert!(task::try(proc() i64::MIN / -1).is_err());\n-    assert!(task::try(proc() 1i / 0).is_err());\n-    assert!(task::try(proc() 1i8 / 0).is_err());\n-    assert!(task::try(proc() 1i16 / 0).is_err());\n-    assert!(task::try(proc() 1i32 / 0).is_err());\n-    assert!(task::try(proc() 1i64 / 0).is_err());\n-    assert!(task::try(proc() int::MIN % -1).is_err());\n-    assert!(task::try(proc() i8::MIN % -1).is_err());\n-    assert!(task::try(proc() i16::MIN % -1).is_err());\n-    assert!(task::try(proc() i32::MIN % -1).is_err());\n-    assert!(task::try(proc() i64::MIN % -1).is_err());\n-    assert!(task::try(proc() 1i % 0).is_err());\n-    assert!(task::try(proc() 1i8 % 0).is_err());\n-    assert!(task::try(proc() 1i16 % 0).is_err());\n-    assert!(task::try(proc() 1i32 % 0).is_err());\n-    assert!(task::try(proc() 1i64 % 0).is_err());\n+    assert!(task::try(move|| int::MIN / -1).is_err());\n+    assert!(task::try(move|| i8::MIN / -1).is_err());\n+    assert!(task::try(move|| i16::MIN / -1).is_err());\n+    assert!(task::try(move|| i32::MIN / -1).is_err());\n+    assert!(task::try(move|| i64::MIN / -1).is_err());\n+    assert!(task::try(move|| 1i / 0).is_err());\n+    assert!(task::try(move|| 1i8 / 0).is_err());\n+    assert!(task::try(move|| 1i16 / 0).is_err());\n+    assert!(task::try(move|| 1i32 / 0).is_err());\n+    assert!(task::try(move|| 1i64 / 0).is_err());\n+    assert!(task::try(move|| int::MIN % -1).is_err());\n+    assert!(task::try(move|| i8::MIN % -1).is_err());\n+    assert!(task::try(move|| i16::MIN % -1).is_err());\n+    assert!(task::try(move|| i32::MIN % -1).is_err());\n+    assert!(task::try(move|| i64::MIN % -1).is_err());\n+    assert!(task::try(move|| 1i % 0).is_err());\n+    assert!(task::try(move|| 1i8 % 0).is_err());\n+    assert!(task::try(move|| 1i16 % 0).is_err());\n+    assert!(task::try(move|| 1i32 % 0).is_err());\n+    assert!(task::try(move|| 1i64 % 0).is_err());\n }"}, {"sha": "7397ad744950e5246e2402ea7576c61bef81b3df", "filename": "src/test/run-pass/issue-8827.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-8827.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-8827.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8827.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -10,7 +10,7 @@\n \n fn periodical(n: int) -> Receiver<bool> {\n     let (chan, port) = channel();\n-    spawn(proc() {\n+    spawn(move|| {\n         loop {\n             for _ in range(1, n) {\n                 match chan.send_opt(false) {\n@@ -29,7 +29,7 @@ fn periodical(n: int) -> Receiver<bool> {\n \n fn integers() -> Receiver<int> {\n     let (chan, port) = channel();\n-    spawn(proc() {\n+    spawn(move|| {\n         let mut i = 1;\n         loop {\n             match chan.send_opt(i) {"}, {"sha": "588e0c1cf16cf28408369c965ff80e508303cba0", "filename": "src/test/run-pass/issue-9396.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9396.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -14,7 +14,7 @@ use std::time::Duration;\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    spawn(proc (){\n+    spawn(move||{\n         let mut timer = Timer::new().unwrap();\n         timer.sleep(Duration::milliseconds(10));\n         tx.send(());"}, {"sha": "1f7edcf43b887f5f71cc3c679a4d2ccfb2c2ba5f", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -18,7 +18,7 @@ fn producer(tx: &Sender<Vec<u8>>) {\n \n pub fn main() {\n     let (tx, rx) = channel::<Vec<u8>>();\n-    let _prod = task::spawn(proc() {\n+    let _prod = task::spawn(move|| {\n         producer(&tx)\n     });\n "}, {"sha": "d745226af44082ab3a271be09c60ed5c8116d799", "filename": "src/test/run-pass/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -16,7 +16,7 @@ fn foo() {\n     // Here, i is *copied* into the proc (heap closure).\n     // Requires allocation.  The proc's copy is not mutable.\n     let mut i = 0;\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         user(i);\n         println!(\"spawned {}\", i)\n     });\n@@ -29,7 +29,7 @@ fn bar() {\n     // mutable outside of the proc.\n     let mut i = 0;\n     while i < 10 {\n-        task::spawn(proc() {\n+        task::spawn(move|| {\n             user(i);\n         });\n         i += 1;\n@@ -40,7 +40,7 @@ fn car() {\n     // Here, i must be shadowed in the proc to be mutable.\n     let mut i = 0;\n     while i < 10 {\n-        task::spawn(proc() {\n+        task::spawn(move|| {\n             let mut i = i;\n             i += 1;\n             user(i);"}, {"sha": "1e05c05cc0dd101b0f5afcfb7a00dbaad48220c0", "filename": "src/test/run-pass/logging-only-prints-once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -27,7 +27,7 @@ impl fmt::Show for Foo {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    spawn(proc() {\n+    spawn(move|| {\n         let mut f = Foo(Cell::new(0));\n         println!(\"{}\", f);\n         let Foo(ref mut f) = f;"}, {"sha": "8b59f26d86976ab94dd318a6b3c40b26de65d3ff", "filename": "src/test/run-pass/macro-with-braces-in-expr-position.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -14,7 +14,7 @@ macro_rules! expr (($e: expr) => { $e })\n \n macro_rules! spawn {\n     ($($code: tt)*) => {\n-        expr!(spawn(proc() {$($code)*}))\n+        expr!(spawn(move|| {$($code)*}))\n     }\n }\n "}, {"sha": "e5694aefdf4c34b78ca8002d48543e22cc651f40", "filename": "src/test/run-pass/moves-based-on-type-capture-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,7 +12,7 @@ use std::task;\n \n pub fn main() {\n     let x = \"Hello world!\".to_string();\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         println!(\"{}\", x);\n     });\n }"}, {"sha": "d74f1349506c1de9fe96f80a5296ed8203519481", "filename": "src/test/run-pass/newlambdas-ret-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,7 +11,7 @@\n // Test that the lambda kind is inferred correctly as a return\n // expression\n \n-fn unique() -> proc():'static { return proc() (); }\n+fn unique() -> Box<FnMut()+'static> { return box || (); }\n \n pub fn main() {\n }"}, {"sha": "43a6ac296e9dc366b3ff3e56180c3c6028689d14", "filename": "src/test/run-pass/newlambdas-ret-infer2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,7 +11,7 @@\n // Test that the lambda kind is inferred correctly as a return\n // expression\n \n-fn unique() -> proc():'static { proc() () }\n+fn unique() -> Box<FnMut()+'static> { box || () }\n \n pub fn main() {\n }"}, {"sha": "e8bf366df957db5f73803f9fe9ced4486a5fe521", "filename": "src/test/run-pass/no-landing-pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fno-landing-pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fno-landing-pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fno-landing-pads.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -23,7 +23,7 @@ impl Drop for A {\n }\n \n fn main() {\n-    task::try::<()>(proc() {\n+    task::try(move|| -> () {\n         let _a = A;\n         panic!();\n     });"}, {"sha": "8fe57a655aa5334b3400e93bd0042ac74af28c67", "filename": "src/test/run-pass/once-move-out-on-heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -13,13 +13,13 @@\n \n use std::sync::Arc;\n \n-fn foo(blk: proc()) {\n+fn foo<F:FnOnce()>(blk: F) {\n     blk();\n }\n \n pub fn main() {\n     let x = Arc::new(true);\n-    foo(proc() {\n+    foo(move|| {\n         assert!(*x);\n         drop(x);\n     });"}, {"sha": "49396d800297a7af76abf24eb297dcbd2dffa9e1", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -73,6 +73,7 @@ pub fn main() {\n     assert_eq!(q.y, !(p.y));\n \n     // Issue #1733\n-    let result: proc(int) = proc(_)();\n     result(p[true]);\n }\n+\n+fn result(i: int) { }"}, {"sha": "419d9b5d824b14ad7406684b56afd988a2cba948", "filename": "src/test/run-pass/out-of-stack-new-thread-no-split.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -37,7 +37,7 @@ fn main() {\n     let args = args.as_slice();\n     if args.len() > 1 && args[1].as_slice() == \"recurse\" {\n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        spawn(move|| {\n             recurse();\n             tx.send(());\n         });"}, {"sha": "39252d6b1426818522f7bcda9663d49b9534927c", "filename": "src/test/run-pass/panic-in-dtor-drops-fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fpanic-in-dtor-drops-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fpanic-in-dtor-drops-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-in-dtor-drops-fields.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -33,7 +33,7 @@ impl Drop for B {\n }\n \n pub fn main() {\n-    let ret = task::try(proc() {\n+    let ret = task::try(move|| {\n         let _a = A { b: B { foo: 3 } };\n     });\n     assert!(ret.is_err());"}, {"sha": "bcfc39ee7e4e65c947d8247af0adf5eb6b0ce219", "filename": "src/test/run-pass/preempt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fpreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fpreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpreempt.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -26,7 +26,7 @@ pub fn main() {\n     let (port, chan) = stream();\n \n     println!(\"main started\");\n-    spawn(proc() {\n+    spawn(move|| {\n         starve_main(port);\n     });\n     let mut i: int = 0;"}, {"sha": "7241b0b88b96b66e04a2b0b1c9ad5b5fb1007d68", "filename": "src/test/run-pass/proc-bounds.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3a9305ce823df267fb1afcce76ef06ca09e407ff/src%2Ftest%2Frun-pass%2Fproc-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a9305ce823df267fb1afcce76ef06ca09e407ff/src%2Ftest%2Frun-pass%2Fproc-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fproc-bounds.rs?ref=3a9305ce823df267fb1afcce76ef06ca09e407ff", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn foo<T>() {}\n-fn bar<T>(_: T) {}\n-\n-fn is_send<T: Send>() {}\n-fn is_freeze<T: Sync>() {}\n-fn is_static<T: 'static>() {}\n-\n-pub fn main() {\n-    foo::<proc()>();\n-    foo::<proc()>();\n-    foo::<proc():Send>();\n-    foo::<proc():Send + Sync>();\n-    foo::<proc():'static + Send + Sync>();\n-\n-    is_send::<proc():Send>();\n-    is_freeze::<proc():Sync>();\n-    is_static::<proc():'static>();\n-\n-\n-    let a = 3i;\n-    bar::<proc()>(proc() {\n-        let b = &a;\n-        println!(\"{}\", *b);\n-    });\n-}"}, {"sha": "9174b53be86e6bd595834e25e92d0e169f9fcbc0", "filename": "src/test/run-pass/regions-infer-region-in-fn-but-not-type.rs", "status": "renamed", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fregions-infer-region-in-fn-but-not-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fregions-infer-region-in-fn-but-not-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-region-in-fn-but-not-type.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,9 +11,12 @@\n \n // check that the &int here does not cause us to think that `foo`\n // contains region pointers\n-struct foo(proc(x: &int):'static);\n+struct foo(Box<FnMut(&int)+'static>);\n \n-fn take_foo(x: foo<'static>) {} //~ ERROR wrong number of lifetime parameters\n+fn take_foo<T:'static>(x: T) {}\n \n-fn main() {\n+fn have_foo(f: foo) {\n+    take_foo(f);\n }\n+\n+fn main() {}", "previous_filename": "src/test/compile-fail/regions-infer-region-in-fn-but-not-type.rs"}, {"sha": "cb45b8e131d284f2414a565beebebd28efa90d1a", "filename": "src/test/run-pass/regions-infer-static-from-proc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fregions-infer-static-from-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fregions-infer-static-from-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-static-from-proc.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -13,11 +13,11 @@\n // give `x` a very short lifetime).\n \n static i: uint = 3;\n-fn foo(_: proc():'static) {}\n+fn foo<F:FnOnce()+'static>(_: F) {}\n fn read(_: uint) { }\n pub fn main() {\n     let x = &i;\n-    foo(proc() {\n+    foo(move|| {\n         read(*x);\n     });\n }"}, {"sha": "b905ebf52fcb3da1ba9af5b270ca18ffdfa861a2", "filename": "src/test/run-pass/return-from-closure.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Freturn-from-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Freturn-from-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freturn-from-closure.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -23,8 +23,7 @@ fn surrounding() {\n     return_works(10);\n     return_works(20);\n \n-\n-    let return_works_proc = proc(n: int) {\n+    let return_works_proc = |: n: int| {\n         unsafe { calls += 1 }\n \n         if n >= 0 { return; }"}, {"sha": "36b90a9168f7174eb36e4888e553f7d274c97c4a", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -14,6 +14,7 @@ use std::io::process::{Command, ProcessOutput};\n use std::os;\n use std::str;\n use std::rt;\n+use std::thunk::Thunk;\n \n use rustrt::unwind::try;\n \n@@ -26,15 +27,15 @@ fn start(argc: int, argv: *const *const u8) -> int {\n                 2 => println!(\"foo\"),\n                 3 => assert!(try(|| {}).is_ok()),\n                 4 => assert!(try(|| panic!()).is_err()),\n-                5 => assert!(try(|| spawn(proc() {})).is_err()),\n+                5 => assert!(try(|| spawn(move|| {})).is_err()),\n                 6 => assert!(Command::new(\"test\").spawn().is_err()),\n                 _ => panic!()\n             }\n         }\n         return 0\n     }\n \n-    rt::start(argc, argv, main)\n+    rt::start(argc, argv, Thunk::new(main))\n }\n \n fn main() {"}, {"sha": "88d30318f2a99c52ea473a860ac9db2b7a0b46aa", "filename": "src/test/run-pass/rust-log-filter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frust-log-filter.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -34,7 +34,7 @@ impl log::Logger for ChannelLogger {\n pub fn main() {\n     let (logger, rx) = ChannelLogger::new();\n \n-    spawn(proc() {\n+    spawn(move|| {\n         log::set_logger(logger);\n \n         // our regex is \"f.o\""}, {"sha": "6001c360ab99f64e86255bd881c64668dfc1c695", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -27,7 +27,7 @@ fn test(f: int) -> test {\n pub fn main() {\n     let (tx, rx) = channel();\n \n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         let (tx2, rx2) = channel();\n         tx.send(tx2);\n "}, {"sha": "838c627040dbcab0fbc543d52c044a61171ad57f", "filename": "src/test/run-pass/sendfn-spawn-with-fn-arg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,17 +12,17 @@ use std::task;\n \n pub fn main() { test05(); }\n \n-fn test05_start(f: proc(int)) {\n+fn test05_start<F:FnOnce(int)>(f: F) {\n     f(22);\n }\n \n fn test05() {\n     let three = box 3;\n-    let fn_to_send: proc(int):Send = proc(n) {\n+    let fn_to_send = move|: n:int| {\n         println!(\"{}\", *three + n); // will copy x into the closure\n         assert_eq!(*three, 3);\n     };\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         test05_start(fn_to_send);\n     });\n }"}, {"sha": "ccebfa72384f971736a3e891ff51d81a2c5461a4", "filename": "src/test/run-pass/sepcomp-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fsepcomp-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fsepcomp-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-unwind.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -34,5 +34,5 @@ mod b {\n }\n \n fn main() {\n-    std::task::try(proc() { ::b::g() }).unwrap_err();\n+    std::task::try(move|| { ::b::g() }).unwrap_err();\n }"}, {"sha": "b66641affc9100bae6e0f4b1a311b01eebd99a43", "filename": "src/test/run-pass/slice-panic-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -28,6 +28,6 @@ fn foo() {\n }\n \n fn main() {\n-    let _ = task::try(proc() foo());\n+    let _ = task::try(move|| foo());\n     unsafe { assert!(DTOR_COUNT == 2); }\n }"}, {"sha": "f7e241554c1e8598bb39b23f902d3c0dad83ed3a", "filename": "src/test/run-pass/slice-panic-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -32,6 +32,6 @@ fn foo() {\n }\n \n fn main() {\n-    let _ = task::try(proc() foo());\n+    let _ = task::try(move|| foo());\n     unsafe { assert!(DTOR_COUNT == 2); }\n }"}, {"sha": "b632bc77c7582005488bee0b89847b1b43504caf", "filename": "src/test/run-pass/spawn-fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -16,9 +16,9 @@ fn x(s: String, n: int) {\n }\n \n pub fn main() {\n-    task::spawn(proc() x(\"hello from first spawned fn\".to_string(), 65) );\n-    task::spawn(proc() x(\"hello from second spawned fn\".to_string(), 66) );\n-    task::spawn(proc() x(\"hello from third spawned fn\".to_string(), 67) );\n+    task::spawn(move|| x(\"hello from first spawned fn\".to_string(), 65) );\n+    task::spawn(move|| x(\"hello from second spawned fn\".to_string(), 66) );\n+    task::spawn(move|| x(\"hello from third spawned fn\".to_string(), 67) );\n     let mut i: int = 30;\n     while i > 0 {\n         i = i - 1;"}, {"sha": "9b533c69f32091b1b16a2a72cfde8e3d9612fd5e", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -24,5 +24,5 @@ fn iotask(_tx: &ctx, ip: String) {\n \n pub fn main() {\n     let (tx, _rx) = channel::<int>();\n-    task::spawn(proc() iotask(&tx, \"localhost\".to_string()) );\n+    task::spawn(move|| iotask(&tx, \"localhost\".to_string()) );\n }"}, {"sha": "cfc1967ae24f1f2000c5c140f1944f350f188899", "filename": "src/test/run-pass/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,7 +11,7 @@\n use std::task;\n \n pub fn main() {\n-    task::spawn(proc() child(10) );\n+    task::spawn(move|| child(10) );\n }\n \n fn child(i: int) { println!(\"{}\", i); assert!((i == 10)); }"}, {"sha": "72db4de2c8d409283af57419f8c17504cfbb1c7c", "filename": "src/test/run-pass/spawn2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fspawn2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fspawn2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn2.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -10,7 +10,7 @@\n \n use std::task;\n \n-pub fn main() { task::spawn(proc() child((10, 20, 30, 40, 50, 60, 70, 80, 90)) ); }\n+pub fn main() { task::spawn(move|| child((10, 20, 30, 40, 50, 60, 70, 80, 90)) ); }\n \n fn child(args: (int, int, int, int, int, int, int, int, int)) {\n     let (i1, i2, i3, i4, i5, i6, i7, i8, i9) = args;"}, {"sha": "0f12827e60ef4b955fc7d38074180f93af514b7c", "filename": "src/test/run-pass/spawning-with-debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawning-with-debug.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -17,5 +17,5 @@ use std::task::TaskBuilder;\n \n pub fn main() {\n     let mut t = TaskBuilder::new();\n-    t.spawn(proc() ());\n+    t.spawn(move|| ());\n }"}, {"sha": "b25b350aa4b72320ae95ae8a75be596b0cbf4056", "filename": "src/test/run-pass/swap-overlapping.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-overlapping.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -18,7 +18,7 @@ pub fn main() {\n             name: TestName::DynTestName(\"test\".to_string()),\n             should_fail: false\n         },\n-        testfn: TestFn::DynTestFn(proc() ()),\n+        testfn: TestFn::DynTestFn(22),\n     };\n     do_swap(&mut test);\n }\n@@ -34,8 +34,8 @@ pub enum TestName {\n }\n \n pub enum TestFn {\n-    DynTestFn(proc():'static),\n-    DynBenchFn(proc(&mut int):'static)\n+    DynTestFn(int),\n+    DynBenchFn(int),\n }\n \n pub struct TestDesc {"}, {"sha": "9e3511ba6034f7ddc0592834b0f20074c56ad532", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -24,7 +24,7 @@ fn test05_start(tx : &Sender<int>) {\n \n fn test05() {\n     let (tx, rx) = channel();\n-    task::spawn(proc() { test05_start(&tx) });\n+    task::spawn(move|| { test05_start(&tx) });\n     let mut value: int = rx.recv();\n     println!(\"{}\", value);\n     value = rx.recv();"}, {"sha": "4117f201547b136b662c08292e9f96d1addf1d07", "filename": "src/test/run-pass/task-comm-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -15,6 +15,6 @@ pub fn main() { test00(); }\n fn start() { println!(\"Started / Finished task.\"); }\n \n fn test00() {\n-    task::try(proc() start() );\n+    task::try(move|| start() );\n     println!(\"Completing.\");\n }"}, {"sha": "dd3c90991f627a5ac9ef887c5da21f04cc0e4a24", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -27,7 +27,7 @@ fn start(tx: &Sender<Sender<String>>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _child = task::spawn(proc() { start(&tx) });\n+    let _child = task::spawn(move|| { start(&tx) });\n \n     let mut c = rx.recv();\n     c.send(\"A\".to_string());"}, {"sha": "aefc91df4e780281c7bddad238a7a5d5f8d97406", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -18,7 +18,7 @@ fn start(tx: &Sender<Sender<int>>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _child = task::spawn(proc() {\n+    let _child = task::spawn(move|| {\n         start(&tx)\n     });\n     let _tx = rx.recv();"}, {"sha": "d950eb8aec45048ed27ba15bffb5515a1c674c83", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -16,7 +16,7 @@ fn start(_task_number: int) { println!(\"Started / Finished task.\"); }\n \n fn test00() {\n     let i: int = 0;\n-    let mut result = task::try_future(proc() {\n+    let mut result = task::try_future(move|| {\n         start(i)\n     });\n "}, {"sha": "c6c0691b74989874c75f73201a6bdc1b763d9d41", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -19,6 +19,6 @@ fn start(tx: &Sender<int>, start: int, number_of_messages: int) {\n pub fn main() {\n     println!(\"Check that we don't deadlock.\");\n     let (tx, rx) = channel();\n-    task::try(proc() { start(&tx, 0, 10) });\n+    task::try(move|| { start(&tx, 0, 10) });\n     println!(\"Joined task\");\n }"}, {"sha": "0e48381366555fd626dd596be065f39e2e0211a9", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -19,7 +19,7 @@ pub fn main() {\n     while (i > 0) {\n         println!(\"{}\", i);\n         let tx = tx.clone();\n-        task::spawn({let i = i; proc() { child(i, &tx) }});\n+        task::spawn({let i = i; move|| { child(i, &tx) }});\n         i = i - 1;\n     }\n "}, {"sha": "3095c2098ff339a1cb1760564c65aeb657906be0", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -25,7 +25,7 @@ pub fn main() {\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n     let (tx, rx) = channel();\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         start(&tx, 10)\n     });\n     rx.recv();"}, {"sha": "3a591d12864af124381c6bad381c03666dedd5d8", "filename": "src/test/run-pass/task-comm-17.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -18,5 +18,5 @@ fn f() {\n }\n \n pub fn main() {\n-    task::spawn(proc() f() );\n+    task::spawn(move|| f() );\n }"}, {"sha": "2908ec1e561159aada05cc0c686a7027c13b03aa", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -41,7 +41,7 @@ fn test00() {\n         let tx = tx.clone();\n         results.push(task::try_future({\n             let i = i;\n-            proc() {\n+            move|| {\n                 test00_start(&tx, i, number_of_messages)\n             }\n         }));"}, {"sha": "9d8caa426269b9248989cc0baf4493bff27012cf", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -28,19 +28,19 @@ fn test00() {\n     let number_of_messages: int = 10;\n \n     let tx2 = tx.clone();\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         test00_start(&tx2, number_of_messages * 0, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         test00_start(&tx2, number_of_messages * 1, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         test00_start(&tx2, number_of_messages * 2, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    task::spawn(proc() {\n+    task::spawn(move|| {\n         test00_start(&tx2, number_of_messages * 3, number_of_messages);\n     });\n "}, {"sha": "1c197e823f2a4620387ff50ba5d60f59deaa1c90", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -23,7 +23,7 @@ fn test00() {\n     let (tx, rx) = channel();\n     let number_of_messages: int = 10;\n \n-    let result = task::try_future(proc() {\n+    let result = task::try_future(move|| {\n         test00_start(&tx, number_of_messages);\n     });\n "}, {"sha": "5c73f44f2d66abe61a10d0646a3c5ea868d7601e", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -11,7 +11,7 @@\n use std::task;\n \n pub fn main() {\n-    task::spawn(proc() child(\"Hello\".to_string()) );\n+    task::spawn(move|| child(\"Hello\".to_string()) );\n }\n \n fn child(_s: String) {"}, {"sha": "8d6b6005a63bad6eb40f551d15a681e2a48469fa", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n     let x = box 1;\n     let x_in_parent = &(*x) as *const int as uint;\n \n-    task::spawn(proc() {\n+    task::spawn(move || {\n         let x_in_child = &(*x) as *const int as uint;\n         tx.send(x_in_child);\n     });"}, {"sha": "72cf7599f89f97a0013c1f3fe0aae05c0c58a7ad", "filename": "src/test/run-pass/task-stderr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-stderr.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -16,7 +16,7 @@ fn main() {\n     let mut reader = ChanReader::new(rx);\n     let stderr = ChanWriter::new(tx);\n \n-    let res = TaskBuilder::new().stderr(box stderr as Box<Writer + Send>).try(proc() -> () {\n+    let res = TaskBuilder::new().stderr(box stderr as Box<Writer + Send>).try(move|| -> () {\n         panic!(\"Hello, world!\")\n     });\n     assert!(res.is_err());"}, {"sha": "780cf23446639b414fb2550af3008825520e17e4", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -35,7 +35,7 @@ fn test() {\n         let a = a.clone();\n         let cnt = cnt.clone();\n         let srv_tx = srv_tx.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             let mut a = a;\n             loop {\n                 match a.accept() {\n@@ -54,7 +54,7 @@ fn test() {\n \n     for _ in range(0, N) {\n         let cli_tx = cli_tx.clone();\n-        spawn(proc() {\n+        spawn(move|| {\n             for _ in range(0, M) {\n                 let _s = TcpStream::connect(addr).unwrap();\n             }"}, {"sha": "2e4b9da691e3941dd37d28b11fc8d0fc5677a871", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -34,7 +34,7 @@ fn eventual_timeout() {\n \n     let (tx1, rx1) = channel();\n     let (_tx2, rx2) = channel::<()>();\n-    std::task::spawn(proc() {\n+    std::task::spawn(move|| {\n         let _l = TcpListener::bind(addr).unwrap().listen();\n         tx1.send(());\n         let _ = rx2.recv_opt();"}, {"sha": "4d691dd252656aab3657fde8f74757c99b261747", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -24,15 +24,15 @@ use std::time::Duration;\n \n fn main() {\n     // This test has a chance to time out, try to not let it time out\n-    spawn(proc() {\n+    spawn(move|| {\n         use std::io::timer;\n         timer::sleep(Duration::milliseconds(30 * 1000));\n         println!(\"timed out!\");\n         unsafe { libc::exit(1) }\n     });\n \n     let (tx, rx) = channel();\n-    spawn(proc() {\n+    spawn(move|| {\n         let mut listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n         tx.send(listener.socket_name().unwrap());\n         let mut acceptor = listener.listen();\n@@ -53,7 +53,7 @@ fn main() {\n     let (tx, rx) = channel();\n     for _ in range(0u, 1000) {\n         let tx = tx.clone();\n-        TaskBuilder::new().stack_size(64 * 1024).spawn(proc() {\n+        TaskBuilder::new().stack_size(64 * 1024).spawn(move|| {\n             match TcpStream::connect(addr) {\n                 Ok(stream) => {\n                     let mut stream = stream;"}, {"sha": "a866f497b8615ec0e523144bd005ce5b32b544d1", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -36,7 +36,7 @@ fn test_tempdir() {\n \n fn test_rm_tempdir() {\n     let (tx, rx) = channel();\n-    let f: proc():Send = proc() {\n+    let f = move|:| -> () {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n         tx.send(tmp.path().clone());\n         panic!(\"panic to unwind past `tmp`\");\n@@ -47,7 +47,7 @@ fn test_rm_tempdir() {\n \n     let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n     let path = tmp.path().clone();\n-    let f: proc():Send = proc() {\n+    let f = move|:| -> () {\n         let _tmp = tmp;\n         panic!(\"panic to unwind past `tmp`\");\n     };\n@@ -56,7 +56,7 @@ fn test_rm_tempdir() {\n \n     let path;\n     {\n-        let f = proc() {\n+        let f = move|:| {\n             TempDir::new(\"test_rm_tempdir\").unwrap()\n         };\n         let tmp = task::try(f).ok().expect(\"test_rm_tmdir\");\n@@ -77,7 +77,7 @@ fn test_rm_tempdir() {\n \n fn test_rm_tempdir_close() {\n     let (tx, rx) = channel();\n-    let f: proc():Send = proc() {\n+    let f = move|:| -> () {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n         tx.send(tmp.path().clone());\n         tmp.close();\n@@ -89,7 +89,7 @@ fn test_rm_tempdir_close() {\n \n     let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n     let path = tmp.path().clone();\n-    let f: proc():Send = proc() {\n+    let f = move|:| -> () {\n         let tmp = tmp;\n         tmp.close();\n         panic!(\"panic when unwinding past `tmp`\");\n@@ -99,7 +99,7 @@ fn test_rm_tempdir_close() {\n \n     let path;\n     {\n-        let f = proc() {\n+        let f = move|:| {\n             TempDir::new(\"test_rm_tempdir\").unwrap()\n         };\n         let tmp = task::try(f).ok().expect(\"test_rm_tmdir\");\n@@ -176,7 +176,7 @@ pub fn test_rmdir_recursive_ok() {\n }\n \n pub fn dont_double_panic() {\n-    let r: Result<(), _> = task::try(proc() {\n+    let r: Result<(), _> = task::try(move|| {\n         let tmpdir = TempDir::new(\"test\").unwrap();\n         // Remove the temporary directory so that TempDir sees\n         // an error on drop"}, {"sha": "28bbac1d0871c09feb92b307c8308accf564b0d2", "filename": "src/test/run-pass/terminate-in-initializer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fterminate-in-initializer.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -22,13 +22,13 @@ fn test_ret() { let _x: Box<int> = return; }\n \n fn test_panic() {\n     fn f() { let _x: Box<int> = panic!(); }\n-    task::try(proc() f() );\n+    task::try(move|| f() );\n }\n \n fn test_panic_indirect() {\n     fn f() -> ! { panic!(); }\n     fn g() { let _x: Box<int> = f(); }\n-    task::try(proc() g() );\n+    task::try(move|| g() );\n }\n \n pub fn main() {"}, {"sha": "71adf16c0511a0c480654f17b1019ec8ce3d6ec6", "filename": "src/test/run-pass/threads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -12,7 +12,7 @@ use std::task;\n \n pub fn main() {\n     let mut i = 10;\n-    while i > 0 { task::spawn({let i = i; proc() child(i)}); i = i - 1; }\n+    while i > 0 { task::spawn({let i = i; move|| child(i)}); i = i - 1; }\n     println!(\"main thread exiting\");\n }\n "}, {"sha": "d2c1461d65d0b0b86a925af15e925366e66c5200", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -77,13 +77,13 @@ pub fn main() {\n                             box dogge2 as Box<Pet+Sync+Send>));\n     let (tx1, rx1) = channel();\n     let arc1 = arc.clone();\n-    task::spawn(proc() { check_legs(arc1); tx1.send(()); });\n+    task::spawn(move|| { check_legs(arc1); tx1.send(()); });\n     let (tx2, rx2) = channel();\n     let arc2 = arc.clone();\n-    task::spawn(proc() { check_names(arc2); tx2.send(()); });\n+    task::spawn(move|| { check_names(arc2); tx2.send(()); });\n     let (tx3, rx3) = channel();\n     let arc3 = arc.clone();\n-    task::spawn(proc() { check_pedigree(arc3); tx3.send(()); });\n+    task::spawn(move|| { check_pedigree(arc3); tx3.send(()); });\n     rx1.recv();\n     rx2.recv();\n     rx3.recv();"}, {"sha": "dfc234e87cda1853b5b957a22252910c8d4f995c", "filename": "src/test/run-pass/unboxed-closures-monomorphization.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Funboxed-closures-monomorphization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Funboxed-closures-monomorphization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-monomorphization.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -14,26 +14,26 @@\n #![feature(unboxed_closures)]\n \n fn main(){\n-    fn bar<'a, T:'a> (t: T) -> Box<FnOnce<(),T> + 'a> {\n-        box move |:| t\n+    fn bar<'a, T:Clone+'a> (t: T) -> Box<FnMut<(),T> + 'a> {\n+        box move |&mut:| t.clone()\n     }\n \n-    let f = bar(42u);\n-    assert_eq!(f.call_once(()), 42);\n+    let mut f = bar(42u);\n+    assert_eq!(f.call_mut(()), 42);\n \n-    let f = bar(\"forty-two\");\n-    assert_eq!(f.call_once(()), \"forty-two\");\n+    let mut f = bar(\"forty-two\");\n+    assert_eq!(f.call_mut(()), \"forty-two\");\n \n     let x = 42u;\n-    let f = bar(&x);\n-    assert_eq!(f.call_once(()), &x);\n+    let mut f = bar(&x);\n+    assert_eq!(f.call_mut(()), &x);\n \n-    #[deriving(Show, PartialEq)]\n+    #[deriving(Clone, Show, PartialEq)]\n     struct Foo(uint, &'static str);\n \n     impl Copy for Foo {}\n \n     let x = Foo(42, \"forty-two\");\n-    let f = bar(x);\n-    assert_eq!(f.call_once(()), x);\n+    let mut f = bar(x);\n+    assert_eq!(f.call_mut(()), x);\n }"}, {"sha": "e31ef169e16eb2ff5ee5b3e8b83f33605be13f04", "filename": "src/test/run-pass/unboxed-closures-prelude.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -13,7 +13,16 @@\n #![feature(unboxed_closures)]\n \n fn main() {\n-    let task: Box<FnOnce(int) -> int> = box |: x| x;\n-    task.call_once((0i, ));\n+    let task: Box<Fn(int) -> int> = box |&: x| x;\n+    task.call((0i, ));\n+\n+    let mut task: Box<FnMut(int) -> int> = box |&mut: x| x;\n+    task.call_mut((0i, ));\n+\n+    call(|:x| x, 22);\n+}\n+\n+fn call<F:FnOnce(int) -> int>(f: F, x: int) -> int {\n+    f.call_once((x,))\n }\n "}, {"sha": "672cd2d00e8bd4eb97fa3939174724ae3e62d90c", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -20,7 +20,7 @@ pub fn main() {\n     let mut expected = 0u;\n     for i in range(0u, n) {\n         let tx = tx.clone();\n-        task::spawn(proc() {\n+        task::spawn(move|| {\n             child(&tx, i)\n         });\n         expected += i;"}, {"sha": "e3cd694c0de6b910ac0c0076ef60bff7adf5703c", "filename": "src/test/run-pass/unit-like-struct-drop-run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -22,7 +22,7 @@ impl Drop for Foo {\n }\n \n pub fn main() {\n-    let x = task::try(proc() {\n+    let x = task::try(move|| {\n         let _b = Foo;\n     });\n "}, {"sha": "9789deef636490e9425ffe98689d8b856642640f", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -37,7 +37,7 @@ fn f(tx: Sender<bool>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    task::spawn(proc() f(tx.clone()));\n+    task::spawn(move|| f(tx.clone()));\n     println!(\"hiiiiiiiii\");\n     assert!(rx.recv());\n }"}, {"sha": "c969e66957ccb752d4aa4f2a1c39b2aaa8bfe991", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -77,7 +77,7 @@ pub fn main() {\n \n                 let v = main.clone();\n \n-                let _ = task::try(proc() {\n+                let _ = task::try(move|| {\n                         let mut v = v;\n                         let mut panic_countdown = panic_countdown;\n                         v.as_mut_slice().sort_by(|a, b| {"}, {"sha": "87226eedfdcbfc2376af564b72634e8f9a56fa0b", "filename": "src/test/run-pass/weak-lang-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f7a4a351646d3837f214b5c7aec390c9b08221/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs?ref=52f7a4a351646d3837f214b5c7aec390c9b08221", "patch": "@@ -15,7 +15,7 @@ extern crate \"weak-lang-items\" as other;\n use std::task;\n \n fn main() {\n-    let _ = task::try(proc() {\n+    let _ = task::try(move|| {\n         other::foo()\n     });\n }"}]}