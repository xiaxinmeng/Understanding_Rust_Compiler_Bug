{"sha": "aed7c30e4f794bc285aeca36dd9e2cc02cef2754", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZDdjMzBlNGY3OTRiYzI4NWFlY2EzNmRkOWUyY2MwMmNlZjI3NTQ=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-04-02T01:53:00Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-04-14T01:58:11Z"}, "message": "Use clearer message when obligation is caused by await expr", "tree": {"sha": "c5158b1f439ee02f3b1fafffe8212af8ade85a34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5158b1f439ee02f3b1fafffe8212af8ade85a34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aed7c30e4f794bc285aeca36dd9e2cc02cef2754", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aed7c30e4f794bc285aeca36dd9e2cc02cef2754", "html_url": "https://github.com/rust-lang/rust/commit/aed7c30e4f794bc285aeca36dd9e2cc02cef2754", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aed7c30e4f794bc285aeca36dd9e2cc02cef2754/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6edfd66c5db78a4672e054c7a9a8207da64e98f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6edfd66c5db78a4672e054c7a9a8207da64e98f6", "html_url": "https://github.com/rust-lang/rust/commit/6edfd66c5db78a4672e054c7a9a8207da64e98f6"}], "stats": {"total": 172, "additions": 126, "deletions": 46}, "files": [{"sha": "2fc58efbf0e7fda71a4da46510e12c937b2d2d8a", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aed7c30e4f794bc285aeca36dd9e2cc02cef2754/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aed7c30e4f794bc285aeca36dd9e2cc02cef2754/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=aed7c30e4f794bc285aeca36dd9e2cc02cef2754", "patch": "@@ -590,6 +590,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             await_span,\n             self.allow_gen_future.clone(),\n         );\n+        let expr = self.lower_expr(expr);\n \n         let pinned_ident = Ident::with_dummy_span(sym::pinned);\n         let (pinned_pat, pinned_pat_hid) =\n@@ -671,7 +672,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let unit = self.expr_unit(span);\n             let yield_expr = self.expr(\n                 span,\n-                hir::ExprKind::Yield(unit, hir::YieldSource::Await),\n+                hir::ExprKind::Yield(unit, hir::YieldSource::Await { expr: Some(expr.hir_id) }),\n                 ThinVec::new(),\n             );\n             let yield_expr = self.arena.alloc(yield_expr);\n@@ -704,7 +705,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // match <expr> {\n         //     mut pinned => loop { .. }\n         // }\n-        let expr = self.lower_expr(expr);\n         hir::ExprKind::Match(expr, arena_vec![self; pinned_arm], hir::MatchSource::AwaitDesugar)\n     }\n "}, {"sha": "440fdc662862ee93a030ee1f5fde4e10080660ae", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aed7c30e4f794bc285aeca36dd9e2cc02cef2754/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aed7c30e4f794bc285aeca36dd9e2cc02cef2754/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=aed7c30e4f794bc285aeca36dd9e2cc02cef2754", "patch": "@@ -1736,15 +1736,24 @@ pub struct Destination {\n #[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub enum YieldSource {\n     /// An `<expr>.await`.\n-    Await,\n+    Await { expr: Option<HirId> },\n     /// A plain `yield`.\n     Yield,\n }\n \n+impl YieldSource {\n+    pub fn is_await(&self) -> bool {\n+        match self {\n+            YieldSource::Await { .. } => true,\n+            YieldSource::Yield => false,\n+        }\n+    }\n+}\n+\n impl fmt::Display for YieldSource {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(match self {\n-            YieldSource::Await => \"`await`\",\n+            YieldSource::Await { .. } => \"`await`\",\n             YieldSource::Yield => \"`yield`\",\n         })\n     }\n@@ -1755,7 +1764,7 @@ impl From<GeneratorKind> for YieldSource {\n         match kind {\n             // Guess based on the kind of the current generator.\n             GeneratorKind::Gen => Self::Yield,\n-            GeneratorKind::Async(_) => Self::Await,\n+            GeneratorKind::Async(_) => Self::Await { expr: None },\n         }\n     }\n }"}, {"sha": "f81992e19c967fac295221f87c2743f615d58a70", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 108, "deletions": 34, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/aed7c30e4f794bc285aeca36dd9e2cc02cef2754/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aed7c30e4f794bc285aeca36dd9e2cc02cef2754/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=aed7c30e4f794bc285aeca36dd9e2cc02cef2754", "patch": "@@ -127,13 +127,14 @@ pub trait InferCtxtExt<'tcx> {\n         scope_span: &Option<Span>,\n         expr: Option<hir::HirId>,\n         snippet: String,\n-        inner_generator: DefId,\n+        inner_generator_body: Option<&hir::Body<'_>>,\n         outer_generator: Option<DefId>,\n         trait_ref: ty::TraitRef<'_>,\n         target_ty: Ty<'tcx>,\n         tables: &ty::TypeckTables<'_>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n+        from_awaited_ty: Option<Span>,\n     );\n \n     fn note_obligation_cause_code<T>(\n@@ -1203,6 +1204,17 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n+        let generator_body = self.tcx\n+            .hir()\n+            .as_local_hir_id(generator_did)\n+            .and_then(|hir_id| self.tcx.hir().maybe_body_owned_by(hir_id))\n+            .map(|body_id| self.tcx.hir().body(body_id));\n+        let mut visitor = AwaitsVisitor::default();\n+        if let Some(body) = generator_body {\n+            visitor.visit_body(body);\n+        }\n+        debug!(\"maybe_note_obligation_cause_for_async_await: awaits = {:?}\", visitor.awaits);\n+\n         // Look for a type inside the generator interior that matches the target type to get\n         // a span.\n         let target_ty_erased = self.tcx.erase_regions(&target_ty);\n@@ -1232,29 +1244,48 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 );\n                 eq\n             })\n-            .map(|ty::GeneratorInteriorTypeCause { span, scope_span, expr, .. }| {\n-                (span, source_map.span_to_snippet(*span), scope_span, expr)\n+            .map(|cause| {\n+                // Check to see if any awaited expressions have the target type.\n+                let from_awaited_ty = visitor.awaits.into_iter()\n+                    .map(|id| self.tcx.hir().expect_expr(id))\n+                    .find(|expr| {\n+                        let ty = tables.expr_ty_adjusted(&expr);\n+                        // Compare types using the same logic as above.\n+                        let ty_erased = self.tcx.erase_late_bound_regions(&ty::Binder::bind(ty));\n+                        let ty_erased = self.tcx.erase_regions(&ty_erased);\n+                        let eq = ty::TyS::same_type(ty_erased, target_ty_erased);\n+                        debug!(\n+                            \"maybe_note_obligation_cause_for_async_await: await_expr={:?} \\\n+                            await_ty_erased={:?}  target_ty_erased={:?} eq={:?}\",\n+                            expr, ty_erased, target_ty_erased, eq\n+                        );\n+                        eq\n+                    })\n+                    .map(|expr| expr.span);\n+                let ty::GeneratorInteriorTypeCause { span, scope_span, expr, .. } = cause;\n+                (span, source_map.span_to_snippet(*span), scope_span, expr, from_awaited_ty)\n             });\n \n         debug!(\n             \"maybe_note_obligation_cause_for_async_await: target_ty={:?} \\\n                 generator_interior_types={:?} target_span={:?}\",\n             target_ty, tables.generator_interior_types, target_span\n         );\n-        if let Some((target_span, Ok(snippet), scope_span, expr)) = target_span {\n+        if let Some((target_span, Ok(snippet), scope_span, expr, from_awaited_ty)) = target_span {\n             self.note_obligation_cause_for_async_await(\n                 err,\n                 *target_span,\n                 scope_span,\n                 *expr,\n                 snippet,\n-                generator_did,\n+                generator_body,\n                 outer_generator,\n                 trait_ref,\n                 target_ty,\n                 tables,\n                 obligation,\n                 next_code,\n+                from_awaited_ty,\n             );\n             true\n         } else {\n@@ -1271,22 +1302,18 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         scope_span: &Option<Span>,\n         expr: Option<hir::HirId>,\n         snippet: String,\n-        inner_generator: DefId,\n+        inner_generator_body: Option<&hir::Body<'_>>,\n         outer_generator: Option<DefId>,\n         trait_ref: ty::TraitRef<'_>,\n         target_ty: Ty<'tcx>,\n         tables: &ty::TypeckTables<'_>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n+        from_awaited_ty: Option<Span>,\n     ) {\n         let source_map = self.tcx.sess.source_map();\n \n-        let is_async = self\n-            .tcx\n-            .hir()\n-            .as_local_hir_id(inner_generator)\n-            .and_then(|hir_id| self.tcx.hir().maybe_body_owned_by(hir_id))\n-            .map(|body_id| self.tcx.hir().body(body_id))\n+        let is_async = inner_generator_body\n             .and_then(|body| body.generator_kind())\n             .map(|generator_kind| match generator_kind {\n                 hir::GeneratorKind::Async(..) => true,\n@@ -1345,33 +1372,57 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             )\n         };\n \n-        // Look at the last interior type to get a span for the `.await`.\n-        let await_span = tables.generator_interior_types.iter().map(|t| t.span).last().unwrap();\n-        let mut span = MultiSpan::from_span(await_span);\n-        span.push_span_label(\n-            await_span,\n-            format!(\"{} occurs here, with `{}` maybe used later\", await_or_yield, snippet),\n-        );\n+        let push_target_span = |span: &mut MultiSpan| {\n+            if target_ty.is_impl_trait() {\n+                // It's not very useful to tell the user the type if it's opaque.\n+                span.push_span_label(target_span, \"created here\".to_string());\n+            } else {\n+                span.push_span_label(target_span, format!(\"has type `{}`\", target_ty));\n+            }\n+        };\n \n-        if target_ty.is_impl_trait() {\n-            // It's not very useful to tell the user the type if it's opaque.\n-            span.push_span_label(target_span, \"created here\".to_string());\n-        } else {\n-            span.push_span_label(target_span, format!(\"has type `{}`\", target_ty));\n-        }\n+        if let Some(await_span) = from_awaited_ty {\n+            // The type causing this obligation is one being awaited at await_span.\n+            let mut span = MultiSpan::from_span(await_span);\n+            span.push_span_label(\n+                await_span,\n+                \"await occurs here\".to_string(),\n+            );\n+\n+            push_target_span(&mut span);\n \n-        // If available, use the scope span to annotate the drop location.\n-        if let Some(scope_span) = scope_span {\n+            err.span_note(\n+                span,\n+                &format!(\"{} as this value is used in an await\", trait_explanation),\n+            );\n+        } else {\n+            // Look at the last interior type to get a span for the `.await`.\n+            debug!(\n+                \"note_obligation_cause_for_async_await generator_interior_types: {:#?}\",\n+                tables.generator_interior_types\n+            );\n+            let await_span = tables.generator_interior_types.iter().map(|t| t.span).last().unwrap();\n+            let mut span = MultiSpan::from_span(await_span);\n             span.push_span_label(\n-                source_map.end_point(*scope_span),\n-                format!(\"`{}` is later dropped here\", snippet),\n+                await_span,\n+                format!(\"{} occurs here, with `{}` maybe used later\", await_or_yield, snippet),\n             );\n-        }\n \n-        err.span_note(\n-            span,\n-            &format!(\"{} as this value is used across an {}\", trait_explanation, await_or_yield),\n-        );\n+            push_target_span(&mut span);\n+\n+            // If available, use the scope span to annotate the drop location.\n+            if let Some(scope_span) = scope_span {\n+                span.push_span_label(\n+                    source_map.end_point(*scope_span),\n+                    format!(\"`{}` is later dropped here\", snippet),\n+                );\n+            }\n+\n+            err.span_note(\n+                span,\n+                &format!(\"{} as this value is used across an {}\", trait_explanation, await_or_yield),\n+            );\n+        }\n \n         if let Some(expr_id) = expr {\n             let expr = hir.expect_expr(expr_id);\n@@ -1716,6 +1767,29 @@ impl<'v> Visitor<'v> for ReturnsVisitor<'v> {\n     }\n }\n \n+/// Collect all the awaited expressions within the input expression.\n+#[derive(Default)]\n+struct AwaitsVisitor {\n+    awaits: Vec<hir::HirId>,\n+}\n+\n+impl<'v> Visitor<'v> for AwaitsVisitor {\n+    type Map = hir::intravisit::ErasedMap<'v>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        match ex.kind {\n+            hir::ExprKind::Yield(_, hir::YieldSource::Await { expr: Some(id) }) =>\n+                self.awaits.push(id),\n+            _ => (),\n+        }\n+        hir::intravisit::walk_expr(self, ex)\n+    }\n+}\n+\n pub trait NextTypeParamName {\n     fn next_type_param_name(&self, name: Option<&str>) -> String;\n }"}, {"sha": "7cb51b4d6d833d8d6fa13978de7c2efa623e2bf3", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aed7c30e4f794bc285aeca36dd9e2cc02cef2754/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aed7c30e4f794bc285aeca36dd9e2cc02cef2754/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=aed7c30e4f794bc285aeca36dd9e2cc02cef2754", "patch": "@@ -1797,7 +1797,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // we know that the yield type must be `()`; however, the context won't contain this\n             // information. Hence, we check the source of the yield expression here and check its\n             // value's type against `()` (this check should always hold).\n-            None if src == &hir::YieldSource::Await => {\n+            None if src.is_await() => {\n                 self.check_expr_coercable_to_type(&value, self.tcx.mk_unit());\n                 self.tcx.mk_unit()\n             }"}, {"sha": "f79908110c4d4fe0f58412e488f113e7f881b586", "filename": "src/test/ui/async-await/issue-68112.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aed7c30e4f794bc285aeca36dd9e2cc02cef2754/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aed7c30e4f794bc285aeca36dd9e2cc02cef2754/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-68112.stderr?ref=aed7c30e4f794bc285aeca36dd9e2cc02cef2754", "patch": "@@ -8,16 +8,13 @@ LL |     require_send(send_fut);\n    |     ^^^^^^^^^^^^ future created by async block is not `Send`\n    |\n    = help: the trait `std::marker::Sync` is not implemented for `std::cell::RefCell<i32>`\n-note: future is not `Send` as this value is used across an await\n-  --> $DIR/issue-68112.rs:32:9\n+note: future is not `Send` as this value is used in an await\n+  --> $DIR/issue-68112.rs:31:17\n    |\n LL |         let non_send_fut = make_non_send_future1();\n    |             ------------ created here\n LL |         let _ = non_send_fut.await;\n-LL |         ready(0).await;\n-   |         ^^^^^^^^ await occurs here, with `non_send_fut` maybe used later\n-LL |     };\n-   |     - `non_send_fut` is later dropped here\n+   |                 ^^^^^^^^^^^^ await occurs here\n \n error[E0277]: `std::cell::RefCell<i32>` cannot be shared between threads safely\n   --> $DIR/issue-68112.rs:49:5"}]}