{"sha": "dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b", "node_id": "C_kwDOAAsO6NoAKGRkYTJhMGVjYTRhNzBhY2JkZDJiNjVmNWZjNWU0Y2QzOGMzOTM1MWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-21T10:33:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-21T10:33:15Z"}, "message": "Auto merge of #89045 - oli-obk:lazy_normalization_in_opaque_types, r=nikomatsakis\n\nRegister normalization obligations instead of immediately normalizing in opaque type instantiation\n\nFor lazy TAIT we will need to instantiate opaque types from within `rustc_infer`, which cannot invoke normalization methods (they are in `rustc_trait_resolution`). So before we move the logic over to `rustc_infer`, we need make sure no normalization happens anymore. This PR resolves that by just registering normalization obligations and continuing.\n\nThis PR is best reviewed commit by commit\n\nI also included f7ad36e which is just an independent cleanup that touches the same code and reduces diagnostics noise a bit\n\nr? `@nikomatsakis` cc `@spastorino`", "tree": {"sha": "d27b21c4eda7a9a8b3e6a144493d95cedcc3d833", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d27b21c4eda7a9a8b3e6a144493d95cedcc3d833"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b", "html_url": "https://github.com/rust-lang/rust/commit/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49c0861ed0fa1d95186d88df0cd4310103e70957", "url": "https://api.github.com/repos/rust-lang/rust/commits/49c0861ed0fa1d95186d88df0cd4310103e70957", "html_url": "https://github.com/rust-lang/rust/commit/49c0861ed0fa1d95186d88df0cd4310103e70957"}, {"sha": "afb7472bcca54bffcab6841345cbf58e9f5dfa33", "url": "https://api.github.com/repos/rust-lang/rust/commits/afb7472bcca54bffcab6841345cbf58e9f5dfa33", "html_url": "https://github.com/rust-lang/rust/commit/afb7472bcca54bffcab6841345cbf58e9f5dfa33"}], "stats": {"total": 154, "additions": 78, "deletions": 76}, "files": [{"sha": "43d3730c04931a46aa1b28bec3b7bdcc9aa1c0fe", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b", "patch": "@@ -64,6 +64,7 @@ mod lub;\n pub mod nll_relate;\n pub mod opaque_types;\n pub mod outlives;\n+mod projection;\n pub mod region_constraints;\n pub mod resolve;\n mod sub;"}, {"sha": "9b53ab72b00dea078ce8b58767994a7622f77ff2", "filename": "compiler/rustc_infer/src/infer/projection.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs?ref=dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b", "patch": "@@ -0,0 +1,39 @@\n+use rustc_middle::traits::ObligationCause;\n+use rustc_middle::ty::{self, ToPredicate, Ty};\n+\n+use crate::traits::{Obligation, PredicateObligation};\n+\n+use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use super::InferCtxt;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    /// Instead of normalizing an associated type projection,\n+    /// this function generates an inference variable and registers\n+    /// an obligation that this inference variable must be the result\n+    /// of the given projection. This allows us to proceed with projections\n+    /// while they cannot be resolved yet due to missing information or\n+    /// simply due to the lack of access to the trait resolution machinery.\n+    pub fn infer_projection(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        recursion_depth: usize,\n+        obligations: &mut Vec<PredicateObligation<'tcx>>,\n+    ) -> Ty<'tcx> {\n+        let def_id = projection_ty.item_def_id;\n+        let ty_var = self.next_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::NormalizeProjectionType,\n+            span: self.tcx.def_span(def_id),\n+        });\n+        let projection = ty::Binder::dummy(ty::ProjectionPredicate { projection_ty, ty: ty_var });\n+        let obligation = Obligation::with_depth(\n+            cause,\n+            recursion_depth,\n+            param_env,\n+            projection.to_predicate(self.tcx),\n+        );\n+        obligations.push(obligation);\n+        ty_var\n+    }\n+}"}, {"sha": "c01faae5d6a51c039f088df9aff6f0a7b5e782a7", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 31, "deletions": 40, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b", "patch": "@@ -1,4 +1,3 @@\n-use crate::infer::InferCtxtExt as _;\n use crate::traits::{self, ObligationCause, PredicateObligation};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -863,7 +862,6 @@ struct Instantiator<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n-    #[instrument(level = \"debug\", skip(self))]\n     fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n         let tcx = self.infcx.tcx;\n         value.fold_with(&mut BottomUpFolder {\n@@ -954,6 +952,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         })\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn fold_opaque_ty(\n         &mut self,\n         ty: Ty<'tcx>,\n@@ -964,25 +963,18 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n-        debug!(\"instantiate_opaque_types: Opaque(def_id={:?}, substs={:?})\", def_id, substs);\n-\n         // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n         if let Some(opaque_defn) = infcx.inner.borrow().opaque_types.get(&opaque_type_key) {\n-            debug!(\"instantiate_opaque_types: returning concrete ty {:?}\", opaque_defn.concrete_ty);\n+            debug!(\"re-using cached concrete type {:?}\", opaque_defn.concrete_ty.kind());\n             return opaque_defn.concrete_ty;\n         }\n+\n         let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::TypeInference,\n             span: self.value_span,\n         });\n \n-        // Make sure that we are in fact defining the *entire* type\n-        // (e.g., `type Foo<T: Bound> = impl Bar;` needs to be\n-        // defined by a function like `fn foo<T: Bound>() -> Foo<T>`).\n-        debug!(\"instantiate_opaque_types: param_env={:#?}\", self.param_env,);\n-        debug!(\"instantiate_opaque_types: generics={:#?}\", tcx.generics_of(def_id),);\n-\n         // Ideally, we'd get the span where *this specific `ty` came\n         // from*, but right now we just use the span from the overall\n         // value being folded. In simple cases like `-> impl Foo`,\n@@ -999,43 +991,40 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             infcx.opaque_types_vars.insert(ty_var, ty);\n         }\n \n-        debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n-        self.compute_opaque_type_obligations(opaque_type_key);\n-\n-        ty_var\n-    }\n-\n-    fn compute_opaque_type_obligations(&mut self, opaque_type_key: OpaqueTypeKey<'tcx>) {\n-        let infcx = self.infcx;\n-        let tcx = infcx.tcx;\n-        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n+        debug!(\"generated new type inference var {:?}\", ty_var.kind());\n \n         let item_bounds = tcx.explicit_item_bounds(def_id);\n-        debug!(\"instantiate_opaque_types: bounds={:#?}\", item_bounds);\n-        let bounds: Vec<_> =\n-            item_bounds.iter().map(|(bound, _)| bound.subst(tcx, substs)).collect();\n-\n-        let param_env = tcx.param_env(def_id);\n-        let InferOk { value: bounds, obligations } = infcx.partially_normalize_associated_types_in(\n-            ObligationCause::misc(self.value_span, self.body_id),\n-            param_env,\n-            bounds,\n-        );\n-        self.obligations.extend(obligations);\n \n-        debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n+        self.obligations.reserve(item_bounds.len());\n+        for (predicate, _) in item_bounds {\n+            debug!(?predicate);\n+            let predicate = predicate.subst(tcx, substs);\n+            debug!(?predicate);\n+\n+            // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n+            let predicate = predicate.fold_with(&mut BottomUpFolder {\n+                tcx,\n+                ty_op: |ty| match ty.kind() {\n+                    ty::Projection(projection_ty) => infcx.infer_projection(\n+                        self.param_env,\n+                        *projection_ty,\n+                        ObligationCause::misc(self.value_span, self.body_id),\n+                        0,\n+                        &mut self.obligations,\n+                    ),\n+                    _ => ty,\n+                },\n+                lt_op: |lt| lt,\n+                ct_op: |ct| ct,\n+            });\n+            debug!(?predicate);\n \n-        for predicate in &bounds {\n             if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n                 if projection.ty.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n-                    return;\n+                    return tcx.ty_error();\n                 }\n             }\n-        }\n-\n-        self.obligations.reserve(bounds.len());\n-        for predicate in bounds {\n             // Change the predicate to refer to the type variable,\n             // which will be the concrete type instead of the opaque type.\n             // This also instantiates nested instances of `impl Trait`.\n@@ -1045,9 +1034,11 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                 traits::ObligationCause::new(self.value_span, self.body_id, traits::OpaqueType);\n \n             // Require that the predicate holds for the concrete type.\n-            debug!(\"instantiate_opaque_types: predicate={:?}\", predicate);\n+            debug!(?predicate);\n             self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n+\n+        ty_var\n     }\n }\n "}, {"sha": "873c058c55c18f906a3e63ad503f7a3ad39ab62a", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b", "patch": "@@ -810,17 +810,7 @@ pub fn normalize_projection_type<'a, 'b, 'tcx>(\n         // and a deferred predicate to resolve this when more type\n         // information is available.\n \n-        let tcx = selcx.infcx().tcx;\n-        let def_id = projection_ty.item_def_id;\n-        let ty_var = selcx.infcx().next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::NormalizeProjectionType,\n-            span: tcx.def_span(def_id),\n-        });\n-        let projection = ty::Binder::dummy(ty::ProjectionPredicate { projection_ty, ty: ty_var });\n-        let obligation =\n-            Obligation::with_depth(cause, depth + 1, param_env, projection.to_predicate(tcx));\n-        obligations.push(obligation);\n-        ty_var\n+        selcx.infcx().infer_projection(param_env, projection_ty, cause, depth + 1, obligations)\n     })\n }\n "}, {"sha": "df2ca025705d3955fae6c9b1a0d7333e29f39684", "filename": "src/test/ui/async-await/issues/issue-65159.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.rs?ref=dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b", "patch": "@@ -6,7 +6,6 @@ async fn copy() -> Result<()>\n //~^ ERROR this enum takes 2 generic arguments\n {\n     Ok(())\n-    //~^ ERROR type annotations needed\n }\n \n fn main() { }"}, {"sha": "45f5ec40cd758b08f914aabdce72e0d85bd7996f", "filename": "src/test/ui/async-await/issues/issue-65159.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr?ref=dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b", "patch": "@@ -16,13 +16,6 @@ help: add missing generic argument\n LL | async fn copy() -> Result<(), E>\n    |                             +++\n \n-error[E0282]: type annotations needed\n-  --> $DIR/issue-65159.rs:8:5\n-   |\n-LL |     Ok(())\n-   |     ^^ cannot infer type for type parameter `E` declared on the enum `Result`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0107, E0282.\n-For more information about an error, try `rustc --explain E0107`.\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "dd0320bc53ba7d79d1151e7b34ea1ba3e85d845a", "filename": "src/test/ui/borrowck/issue-82126-mismatched-subst-and-hir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/src%2Ftest%2Fui%2Fborrowck%2Fissue-82126-mismatched-subst-and-hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/src%2Ftest%2Fui%2Fborrowck%2Fissue-82126-mismatched-subst-and-hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-82126-mismatched-subst-and-hir.rs?ref=dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b", "patch": "@@ -17,7 +17,6 @@ async fn buy_lock(generator: &Mutex<MarketMultiplier>) -> LockedMarket<'_> {\n     //~^ ERROR this struct takes 0 lifetime arguments but 1 lifetime argument was supplied\n     //~^^ ERROR this struct takes 1 generic argument but 0 generic arguments were supplied\n     LockedMarket(generator.lock().unwrap().buy())\n-    //~^ ERROR cannot return value referencing temporary value\n }\n \n struct LockedMarket<T>(T);"}, {"sha": "d2b927fb664c66b1958dbdfd914b771b95b1d2d1", "filename": "src/test/ui/borrowck/issue-82126-mismatched-subst-and-hir.stderr", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/src%2Ftest%2Fui%2Fborrowck%2Fissue-82126-mismatched-subst-and-hir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b/src%2Ftest%2Fui%2Fborrowck%2Fissue-82126-mismatched-subst-and-hir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-82126-mismatched-subst-and-hir.stderr?ref=dda2a0eca4a70acbdd2b65f5fc5e4cd38c39351b", "patch": "@@ -7,7 +7,7 @@ LL | async fn buy_lock(generator: &Mutex<MarketMultiplier>) -> LockedMarket<'_>\n    |                                                           expected 0 lifetime arguments\n    |\n note: struct defined here, with 0 lifetime parameters\n-  --> $DIR/issue-82126-mismatched-subst-and-hir.rs:23:8\n+  --> $DIR/issue-82126-mismatched-subst-and-hir.rs:22:8\n    |\n LL | struct LockedMarket<T>(T);\n    |        ^^^^^^^^^^^^\n@@ -19,7 +19,7 @@ LL | async fn buy_lock(generator: &Mutex<MarketMultiplier>) -> LockedMarket<'_>\n    |                                                           ^^^^^^^^^^^^ expected 1 generic argument\n    |\n note: struct defined here, with 1 generic parameter: `T`\n-  --> $DIR/issue-82126-mismatched-subst-and-hir.rs:23:8\n+  --> $DIR/issue-82126-mismatched-subst-and-hir.rs:22:8\n    |\n LL | struct LockedMarket<T>(T);\n    |        ^^^^^^^^^^^^ -\n@@ -28,16 +28,6 @@ help: add missing generic argument\n LL | async fn buy_lock(generator: &Mutex<MarketMultiplier>) -> LockedMarket<'_, T> {\n    |                                                                          +++\n \n-error[E0515]: cannot return value referencing temporary value\n-  --> $DIR/issue-82126-mismatched-subst-and-hir.rs:19:5\n-   |\n-LL |     LockedMarket(generator.lock().unwrap().buy())\n-   |     ^^^^^^^^^^^^^-------------------------^^^^^^^\n-   |     |            |\n-   |     |            temporary value created here\n-   |     returns a value referencing data owned by the current function\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0107, E0515.\n-For more information about an error, try `rustc --explain E0107`.\n+For more information about this error, try `rustc --explain E0107`."}]}