{"sha": "4507fdaaa27ea2fb59a41df2ce7d1f290da53dae", "node_id": "C_kwDOAAsO6NoAKDQ1MDdmZGFhYTI3ZWEyZmI1OWE0MWRmMmNlN2QxZjI5MGRhNTNkYWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-18T20:12:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-18T20:12:35Z"}, "message": "Auto merge of #106241 - Sp00ph:vec_deque_iter_methods, r=the8472\n\nImplement more methods for `vec_deque::IntoIter`\n\nThis implements a couple `Iterator` methods on `vec_deque::IntoIter` (`(try_)fold`, `(try_)rfold` `advance_(back_)by`, `next_chunk`, `count` and `last`) to allow these to be more efficient than their default implementations, also allowing many other `Iterator` methods that use these under the hood to take advantage of these manual implementations. `vec::IntoIter` has similar implementations for many of these methods. This PR does not yet implement `TrustedRandomAccess` and friends, as I'm not very familiar with the required safety guarantees.\n\nr? `@the8472` (since you also took over my last PR)", "tree": {"sha": "cdec774afdda97f68ca74ade01ec93274deb65c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdec774afdda97f68ca74ade01ec93274deb65c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4507fdaaa27ea2fb59a41df2ce7d1f290da53dae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4507fdaaa27ea2fb59a41df2ce7d1f290da53dae", "html_url": "https://github.com/rust-lang/rust/commit/4507fdaaa27ea2fb59a41df2ce7d1f290da53dae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4507fdaaa27ea2fb59a41df2ce7d1f290da53dae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53709aedba198874ee50769f19f1e9ab00798bb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/53709aedba198874ee50769f19f1e9ab00798bb5", "html_url": "https://github.com/rust-lang/rust/commit/53709aedba198874ee50769f19f1e9ab00798bb5"}, {"sha": "ccba6c51511a86cd36af52dc4f51cd3a0df95909", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccba6c51511a86cd36af52dc4f51cd3a0df95909", "html_url": "https://github.com/rust-lang/rust/commit/ccba6c51511a86cd36af52dc4f51cd3a0df95909"}], "stats": {"total": 331, "additions": 329, "deletions": 2}, "files": [{"sha": "313a97ed1ffcc34d5c78edd23e18bd21b032976e", "filename": "library/alloc/benches/vec_deque.rs", "status": "modified", "additions": 145, "deletions": 1, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/4507fdaaa27ea2fb59a41df2ce7d1f290da53dae/library%2Falloc%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4507fdaaa27ea2fb59a41df2ce7d1f290da53dae/library%2Falloc%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec_deque.rs?ref=4507fdaaa27ea2fb59a41df2ce7d1f290da53dae", "patch": "@@ -1,4 +1,8 @@\n-use std::collections::VecDeque;\n+use core::iter::Iterator;\n+use std::{\n+    collections::{vec_deque, VecDeque},\n+    mem,\n+};\n use test::{black_box, Bencher};\n \n #[bench]\n@@ -53,6 +57,146 @@ fn bench_try_fold(b: &mut Bencher) {\n     b.iter(|| black_box(ring.iter().try_fold(0, |a, b| Some(a + b))))\n }\n \n+/// does the memory bookkeeping to reuse the buffer of the Vec between iterations.\n+/// `setup` must not modify its argument's length or capacity. `g` must not move out of its argument.\n+fn into_iter_helper<\n+    T: Copy,\n+    F: FnOnce(&mut VecDeque<T>),\n+    G: FnOnce(&mut vec_deque::IntoIter<T>),\n+>(\n+    v: &mut Vec<T>,\n+    setup: F,\n+    g: G,\n+) {\n+    let ptr = v.as_mut_ptr();\n+    let len = v.len();\n+    // ensure that the vec is full, to make sure that any wrapping from the deque doesn't\n+    // access uninitialized memory.\n+    assert_eq!(v.len(), v.capacity());\n+\n+    let mut deque = VecDeque::from(mem::take(v));\n+    setup(&mut deque);\n+\n+    let mut it = deque.into_iter();\n+    g(&mut it);\n+\n+    mem::forget(it);\n+\n+    // SAFETY: the provided functions are not allowed to modify the allocation, so the buffer is still alive.\n+    // len and capacity are accurate due to the above assertion.\n+    // All the elements in the buffer are still valid, because of `T: Copy` which implies `T: !Drop`.\n+    mem::forget(mem::replace(v, unsafe { Vec::from_raw_parts(ptr, len, len) }));\n+}\n+\n+#[bench]\n+fn bench_into_iter(b: &mut Bencher) {\n+    let len = 1024;\n+    // we reuse this allocation for every run\n+    let mut vec: Vec<usize> = (0..len).collect();\n+    vec.shrink_to_fit();\n+\n+    b.iter(|| {\n+        let mut sum = 0;\n+        into_iter_helper(\n+            &mut vec,\n+            |_| {},\n+            |it| {\n+                for i in it {\n+                    sum += i;\n+                }\n+            },\n+        );\n+        black_box(sum);\n+\n+        let mut sum = 0;\n+        // rotating a full deque doesn't move any memory.\n+        into_iter_helper(\n+            &mut vec,\n+            |d| d.rotate_left(len / 2),\n+            |it| {\n+                for i in it {\n+                    sum += i;\n+                }\n+            },\n+        );\n+        black_box(sum);\n+    });\n+}\n+\n+#[bench]\n+fn bench_into_iter_fold(b: &mut Bencher) {\n+    let len = 1024;\n+\n+    // because `fold` takes ownership of the iterator,\n+    // we can't prevent it from dropping the memory,\n+    // so we have to bite the bullet and reallocate\n+    // for every iteration.\n+    b.iter(|| {\n+        let deque: VecDeque<usize> = (0..len).collect();\n+        assert_eq!(deque.len(), deque.capacity());\n+        let sum = deque.into_iter().fold(0, |a, b| a + b);\n+        black_box(sum);\n+\n+        // rotating a full deque doesn't move any memory.\n+        let mut deque: VecDeque<usize> = (0..len).collect();\n+        assert_eq!(deque.len(), deque.capacity());\n+        deque.rotate_left(len / 2);\n+        let sum = deque.into_iter().fold(0, |a, b| a + b);\n+        black_box(sum);\n+    });\n+}\n+\n+#[bench]\n+fn bench_into_iter_try_fold(b: &mut Bencher) {\n+    let len = 1024;\n+    // we reuse this allocation for every run\n+    let mut vec: Vec<usize> = (0..len).collect();\n+    vec.shrink_to_fit();\n+\n+    // Iterator::any uses Iterator::try_fold under the hood\n+    b.iter(|| {\n+        let mut b = false;\n+        into_iter_helper(&mut vec, |_| {}, |it| b = it.any(|i| i == len - 1));\n+        black_box(b);\n+\n+        into_iter_helper(&mut vec, |d| d.rotate_left(len / 2), |it| b = it.any(|i| i == len - 1));\n+        black_box(b);\n+    });\n+}\n+\n+#[bench]\n+fn bench_into_iter_next_chunk(b: &mut Bencher) {\n+    let len = 1024;\n+    // we reuse this allocation for every run\n+    let mut vec: Vec<usize> = (0..len).collect();\n+    vec.shrink_to_fit();\n+\n+    b.iter(|| {\n+        let mut buf = [0; 64];\n+        into_iter_helper(\n+            &mut vec,\n+            |_| {},\n+            |it| {\n+                while let Ok(a) = it.next_chunk() {\n+                    buf = a;\n+                }\n+            },\n+        );\n+        black_box(buf);\n+\n+        into_iter_helper(\n+            &mut vec,\n+            |d| d.rotate_left(len / 2),\n+            |it| {\n+                while let Ok(a) = it.next_chunk() {\n+                    buf = a;\n+                }\n+            },\n+        );\n+        black_box(buf);\n+    });\n+}\n+\n #[bench]\n fn bench_from_array_1000(b: &mut Bencher) {\n     const N: usize = 1000;"}, {"sha": "34bc0ce9177c402723a1ab6cd2eb02e1a4d439b4", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "modified", "additions": 184, "deletions": 1, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/4507fdaaa27ea2fb59a41df2ce7d1f290da53dae/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4507fdaaa27ea2fb59a41df2ce7d1f290da53dae/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=4507fdaaa27ea2fb59a41df2ce7d1f290da53dae", "patch": "@@ -1,5 +1,5 @@\n-use core::fmt;\n use core::iter::{FusedIterator, TrustedLen};\n+use core::{array, fmt, mem::MaybeUninit, ops::Try, ptr};\n \n use crate::alloc::{Allocator, Global};\n \n@@ -52,6 +52,126 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n         let len = self.inner.len();\n         (len, Some(len))\n     }\n+\n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        if self.inner.len < n {\n+            let len = self.inner.len;\n+            self.inner.clear();\n+            Err(len)\n+        } else {\n+            self.inner.drain(..n);\n+            Ok(())\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.inner.len\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, mut init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        struct Guard<'a, T, A: Allocator> {\n+            deque: &'a mut VecDeque<T, A>,\n+            // `consumed <= deque.len` always holds.\n+            consumed: usize,\n+        }\n+\n+        impl<'a, T, A: Allocator> Drop for Guard<'a, T, A> {\n+            fn drop(&mut self) {\n+                self.deque.len -= self.consumed;\n+                self.deque.head = self.deque.to_physical_idx(self.consumed);\n+            }\n+        }\n+\n+        let mut guard = Guard { deque: &mut self.inner, consumed: 0 };\n+\n+        let (head, tail) = guard.deque.as_slices();\n+\n+        init = head\n+            .iter()\n+            .map(|elem| {\n+                guard.consumed += 1;\n+                // SAFETY: Because we incremented `guard.consumed`, the\n+                // deque effectively forgot the element, so we can take\n+                // ownership\n+                unsafe { ptr::read(elem) }\n+            })\n+            .try_fold(init, &mut f)?;\n+\n+        tail.iter()\n+            .map(|elem| {\n+                guard.consumed += 1;\n+                // SAFETY: Same as above.\n+                unsafe { ptr::read(elem) }\n+            })\n+            .try_fold(init, &mut f)\n+    }\n+\n+    #[inline]\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        match self.try_fold(init, |b, item| Ok::<B, !>(f(b, item))) {\n+            Ok(b) => b,\n+            Err(e) => match e {},\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.inner.pop_back()\n+    }\n+\n+    fn next_chunk<const N: usize>(\n+        &mut self,\n+    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>> {\n+        let mut raw_arr = MaybeUninit::uninit_array();\n+        let raw_arr_ptr = raw_arr.as_mut_ptr().cast();\n+        let (head, tail) = self.inner.as_slices();\n+\n+        if head.len() >= N {\n+            // SAFETY: By manually adjusting the head and length of the deque, we effectively\n+            // make it forget the first `N` elements, so taking ownership of them is safe.\n+            unsafe { ptr::copy_nonoverlapping(head.as_ptr(), raw_arr_ptr, N) };\n+            self.inner.head = self.inner.to_physical_idx(N);\n+            self.inner.len -= N;\n+            // SAFETY: We initialized the entire array with items from `head`\n+            return Ok(unsafe { raw_arr.transpose().assume_init() });\n+        }\n+\n+        // SAFETY: Same argument as above.\n+        unsafe { ptr::copy_nonoverlapping(head.as_ptr(), raw_arr_ptr, head.len()) };\n+        let remaining = N - head.len();\n+\n+        if tail.len() >= remaining {\n+            // SAFETY: Same argument as above.\n+            unsafe {\n+                ptr::copy_nonoverlapping(tail.as_ptr(), raw_arr_ptr.add(head.len()), remaining)\n+            };\n+            self.inner.head = self.inner.to_physical_idx(N);\n+            self.inner.len -= N;\n+            // SAFETY: We initialized the entire array with items from `head` and `tail`\n+            Ok(unsafe { raw_arr.transpose().assume_init() })\n+        } else {\n+            // SAFETY: Same argument as above.\n+            unsafe {\n+                ptr::copy_nonoverlapping(tail.as_ptr(), raw_arr_ptr.add(head.len()), tail.len())\n+            };\n+            let init = head.len() + tail.len();\n+            // We completely drained all the deques elements.\n+            self.inner.head = 0;\n+            self.inner.len = 0;\n+            // SAFETY: We copied all elements from both slices to the beginning of the array, so\n+            // the given range is initialized.\n+            Err(unsafe { array::IntoIter::new_unchecked(raw_arr, 0..init) })\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -60,10 +180,73 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let len = self.inner.len;\n+        if len >= n {\n+            self.inner.truncate(len - n);\n+            Ok(())\n+        } else {\n+            self.inner.clear();\n+            Err(len)\n+        }\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, mut init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        struct Guard<'a, T, A: Allocator> {\n+            deque: &'a mut VecDeque<T, A>,\n+            // `consumed <= deque.len` always holds.\n+            consumed: usize,\n+        }\n+\n+        impl<'a, T, A: Allocator> Drop for Guard<'a, T, A> {\n+            fn drop(&mut self) {\n+                self.deque.len -= self.consumed;\n+            }\n+        }\n+\n+        let mut guard = Guard { deque: &mut self.inner, consumed: 0 };\n+\n+        let (head, tail) = guard.deque.as_slices();\n+\n+        init = tail\n+            .iter()\n+            .map(|elem| {\n+                guard.consumed += 1;\n+                // SAFETY: See `try_fold`'s safety comment.\n+                unsafe { ptr::read(elem) }\n+            })\n+            .try_rfold(init, &mut f)?;\n+\n+        head.iter()\n+            .map(|elem| {\n+                guard.consumed += 1;\n+                // SAFETY: Same as above.\n+                unsafe { ptr::read(elem) }\n+            })\n+            .try_rfold(init, &mut f)\n+    }\n+\n+    #[inline]\n+    fn rfold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        match self.try_rfold(init, |b, item| Ok::<B, !>(f(b, item))) {\n+            Ok(b) => b,\n+            Err(e) => match e {},\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n+    #[inline]\n     fn is_empty(&self) -> bool {\n         self.inner.is_empty()\n     }"}]}