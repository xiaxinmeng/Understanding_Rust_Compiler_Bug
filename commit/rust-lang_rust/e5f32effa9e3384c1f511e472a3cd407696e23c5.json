{"sha": "e5f32effa9e3384c1f511e472a3cd407696e23c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZjMyZWZmYTllMzM4NGMxZjUxMWU0NzJhM2NkNDA3Njk2ZTIzYzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-08T18:36:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-08T18:36:40Z"}, "message": "add comment", "tree": {"sha": "6722281074a2dad51a73db6a60041ed200105ad7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6722281074a2dad51a73db6a60041ed200105ad7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5f32effa9e3384c1f511e472a3cd407696e23c5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbazg4CRBK7hj4Ov3rIwAAdHIIAIdzKXJ2q98XdgPDwe31gGBB\n2sib3ZSqN1VZ0NhH9lIRrt5k8mMaZRkZXPDvRrpkr74F1OAFtyPTrkBXYKFF13PY\nRK/gaFY9Gla/7LPqp/djskcFt0FNJv8aSFaOJBmiVqBSA15yWV9z8kPGyoz9Wk8S\nv85AcnMWSgcOhq8wnTLoir+Ytxhodq/WkBmUifFMuEIV7u6OGM7vJZBAd4GQQjaf\nvw30+QG8csThHgunAi8aAvuHXrJiScW/KmX02Yj8WjWNsW/iIq8FL/u4UNA1c9M2\nBfH09FP1FxGQNOO0yJZ8TDXr4rfj1fZbxFui7Vkd1Wzc1MmnxmAaLIIsB488wAI=\n=dlET\n-----END PGP SIGNATURE-----\n", "payload": "tree 6722281074a2dad51a73db6a60041ed200105ad7\nparent ffe336d07b73d391563775220a913b01e1d17d1f\nauthor Niko Matsakis <niko@alum.mit.edu> 1533753400 -0400\ncommitter GitHub <noreply@github.com> 1533753400 -0400\n\nadd comment"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f32effa9e3384c1f511e472a3cd407696e23c5", "html_url": "https://github.com/rust-lang/rust/commit/e5f32effa9e3384c1f511e472a3cd407696e23c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5f32effa9e3384c1f511e472a3cd407696e23c5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffe336d07b73d391563775220a913b01e1d17d1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffe336d07b73d391563775220a913b01e1d17d1f", "html_url": "https://github.com/rust-lang/rust/commit/ffe336d07b73d391563775220a913b01e1d17d1f"}], "stats": {"total": 24, "additions": 24, "deletions": 0}, "files": [{"sha": "0798a45b3becd61b67152259afad683242b04bd2", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e5f32effa9e3384c1f511e472a3cd407696e23c5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f32effa9e3384c1f511e472a3cd407696e23c5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=e5f32effa9e3384c1f511e472a3cd407696e23c5", "patch": "@@ -645,6 +645,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n+    /// Invoked when we have some type-test (e.g., `T: 'X`) that we cannot\n+    /// prove to be satisfied. If this is a closure, we will attempt to\n+    /// \"promote\" this type-test into our `ClosureRegionRequirements` and\n+    /// hence pass it up the creator. To do this, we have to phrase the\n+    /// type-test in terms of external free regions, as local free\n+    /// regions are not nameable by the closure's creator.\n+    ///\n+    /// Promotion works as follows: we first check that the type `T`\n+    /// contains only regions that the creator knows about. If this is\n+    /// true, then -- as a consequence -- we know that all regions in\n+    /// the type `T` are free regions that outlive the closure body. If\n+    /// false, then promotion fails.\n+    ///\n+    /// Once we've promoted T, we have to \"promote\" `'X` to some region\n+    /// that is \"external\" to the closure. Generally speaking, a region\n+    /// may be the union of some points in the closure body as well as\n+    /// various free lifetimes. We can ignore the points in the closure\n+    /// body: if the type T can be expressed in terms of external regions,\n+    /// we know it outlives the points in the closure body. That\n+    /// just leaves the free regions.\n+    ///\n+    /// The idea then is to lower the `T: 'X` constraint into multiple\n+    /// bounds -- e.g., if `'X` is the union of two free lifetimes,\n+    /// `'1` and `'2`, then we would create `T: '1` and `T: '2`.\n     fn try_promote_type_test<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,"}]}