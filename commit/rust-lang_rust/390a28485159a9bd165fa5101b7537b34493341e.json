{"sha": "390a28485159a9bd165fa5101b7537b34493341e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MGEyODQ4NTE1OWE5YmQxNjVmYTUxMDFiNzUzN2IzNDQ5MzM0MWU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-05-14T06:01:53Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-05-14T06:10:46Z"}, "message": "Give a deprecation warning on `rustfmt_skip` and an error on `rustfmt::` other than `skip`", "tree": {"sha": "f618d253bf5294305db164bda2698a9bcafaf2aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f618d253bf5294305db164bda2698a9bcafaf2aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/390a28485159a9bd165fa5101b7537b34493341e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/390a28485159a9bd165fa5101b7537b34493341e", "html_url": "https://github.com/rust-lang/rust/commit/390a28485159a9bd165fa5101b7537b34493341e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/390a28485159a9bd165fa5101b7537b34493341e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51f566062fefc2262dd3b56f7e385f1dd749bd8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/51f566062fefc2262dd3b56f7e385f1dd749bd8b", "html_url": "https://github.com/rust-lang/rust/commit/51f566062fefc2262dd3b56f7e385f1dd749bd8b"}], "stats": {"total": 127, "additions": 102, "deletions": 25}, "files": [{"sha": "46cb952a0cb9c4d02c0e78cf1f255ebd7103718c", "filename": "src/lib.rs", "status": "modified", "additions": 56, "deletions": 21, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/390a28485159a9bd165fa5101b7537b34493341e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390a28485159a9bd165fa5101b7537b34493341e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=390a28485159a9bd165fa5101b7537b34493341e", "patch": "@@ -37,6 +37,7 @@ extern crate term;\n extern crate toml;\n extern crate unicode_segmentation;\n \n+use std::cell::RefCell;\n use std::collections::HashMap;\n use std::fmt;\n use std::io::{self, stdout, Write};\n@@ -47,7 +48,7 @@ use std::time::Duration;\n \n use syntax::ast;\n pub use syntax::codemap::FileName;\n-use syntax::codemap::{CodeMap, FilePathMapping};\n+use syntax::codemap::{CodeMap, FilePathMapping, Span};\n use syntax::errors::emitter::{ColorConfig, EmitterWriter};\n use syntax::errors::{DiagnosticBuilder, Handler};\n use syntax::parse::{self, ParseSess};\n@@ -125,9 +126,14 @@ pub enum ErrorKind {\n     // License check has failed\n     #[fail(display = \"license check failed\")]\n     LicenseCheck,\n+    // Used deprecated skip attribute\n+    #[fail(display = \"`rustfmt_skip` is deprecated; use `rustfmt::skip`\")]\n+    DeprecatedAttr,\n+    // Used a rustfmt:: attribute other than skip\n+    #[fail(display = \"invalid attribute\")]\n+    BadAttr,\n }\n \n-// Formatting errors that are identified *after* rustfmt has run.\n struct FormattingError {\n     line: usize,\n     kind: ErrorKind,\n@@ -137,11 +143,28 @@ struct FormattingError {\n }\n \n impl FormattingError {\n+    fn from_span(span: &Span, codemap: &CodeMap, kind: ErrorKind) -> FormattingError {\n+        FormattingError {\n+            line: codemap.lookup_char_pos(span.lo()).line,\n+            kind,\n+            is_comment: false,\n+            is_string: false,\n+            line_buffer: codemap\n+                .span_to_lines(*span)\n+                .ok()\n+                .and_then(|fl| {\n+                    fl.file\n+                        .get_line(fl.lines[0].line_index)\n+                        .map(|l| l.into_owned())\n+                })\n+                .unwrap_or_else(|| String::new()),\n+        }\n+    }\n     fn msg_prefix(&self) -> &str {\n         match self.kind {\n             ErrorKind::LineOverflow(..) | ErrorKind::TrailingWhitespace => \"internal error:\",\n-            ErrorKind::LicenseCheck => \"error:\",\n-            ErrorKind::BadIssue(_) => \"warning:\",\n+            ErrorKind::LicenseCheck | ErrorKind::BadAttr => \"error:\",\n+            ErrorKind::BadIssue(_) | ErrorKind::DeprecatedAttr => \"warning:\",\n         }\n     }\n \n@@ -158,7 +181,7 @@ impl FormattingError {\n     fn format_len(&self) -> (usize, usize) {\n         match self.kind {\n             ErrorKind::LineOverflow(found, max) => (max, found - max),\n-            ErrorKind::TrailingWhitespace => {\n+            ErrorKind::TrailingWhitespace | ErrorKind::DeprecatedAttr | ErrorKind::BadAttr => {\n                 let trailing_ws_start = self\n                     .line_buffer\n                     .rfind(|c: char| !c.is_whitespace())\n@@ -174,20 +197,30 @@ impl FormattingError {\n     }\n }\n \n+#[derive(Clone)]\n pub struct FormatReport {\n     // Maps stringified file paths to their associated formatting errors.\n-    file_error_map: HashMap<FileName, Vec<FormattingError>>,\n+    file_error_map: Rc<RefCell<HashMap<FileName, Vec<FormattingError>>>>,\n }\n \n impl FormatReport {\n     fn new() -> FormatReport {\n         FormatReport {\n-            file_error_map: HashMap::new(),\n+            file_error_map: Rc::new(RefCell::new(HashMap::new())),\n         }\n     }\n \n+    fn append(&self, f: FileName, mut v: Vec<FormattingError>) {\n+        self.file_error_map\n+            .borrow_mut()\n+            .entry(f)\n+            .and_modify(|fe| fe.append(&mut v))\n+            .or_insert(v);\n+    }\n+\n     fn warning_count(&self) -> usize {\n         self.file_error_map\n+            .borrow()\n             .iter()\n             .map(|(_, errors)| errors.len())\n             .sum()\n@@ -201,7 +234,7 @@ impl FormatReport {\n         &self,\n         mut t: Box<term::Terminal<Output = io::Stderr>>,\n     ) -> Result<(), term::Error> {\n-        for (file, errors) in &self.file_error_map {\n+        for (file, errors) in &*self.file_error_map.borrow() {\n             for error in errors {\n                 let prefix_space_len = error.line.to_string().len();\n                 let prefix_spaces = \" \".repeat(1 + prefix_space_len);\n@@ -247,7 +280,7 @@ impl FormatReport {\n             }\n         }\n \n-        if !self.file_error_map.is_empty() {\n+        if !self.file_error_map.borrow().is_empty() {\n             t.attr(term::Attr::Bold)?;\n             write!(t, \"warning: \")?;\n             t.reset()?;\n@@ -271,7 +304,7 @@ fn target_str(space_len: usize, target_len: usize) -> String {\n impl fmt::Display for FormatReport {\n     // Prints all the formatting errors.\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        for (file, errors) in &self.file_error_map {\n+        for (file, errors) in &*self.file_error_map.borrow() {\n             for error in errors {\n                 let prefix_space_len = error.line.to_string().len();\n                 let prefix_spaces = \" \".repeat(1 + prefix_space_len);\n@@ -310,7 +343,7 @@ impl fmt::Display for FormatReport {\n                 )?;\n             }\n         }\n-        if !self.file_error_map.is_empty() {\n+        if !self.file_error_map.borrow().is_empty() {\n             writeln!(\n                 fmt,\n                 \"warning: rustfmt may have failed to format. See previous {} errors.\",\n@@ -336,10 +369,11 @@ fn format_ast<F>(\n     parse_session: &mut ParseSess,\n     main_file: &FileName,\n     config: &Config,\n+    report: FormatReport,\n     mut after_file: F,\n ) -> Result<(FileMap, bool), io::Error>\n where\n-    F: FnMut(&FileName, &mut String, &[(usize, usize)]) -> Result<bool, io::Error>,\n+    F: FnMut(&FileName, &mut String, &[(usize, usize)], &FormatReport) -> Result<bool, io::Error>,\n {\n     let mut result = FileMap::new();\n     // diff mode: check if any files are differing\n@@ -357,7 +391,8 @@ where\n             .file;\n         let big_snippet = filemap.src.as_ref().unwrap();\n         let snippet_provider = SnippetProvider::new(filemap.start_pos, big_snippet);\n-        let mut visitor = FmtVisitor::from_codemap(parse_session, config, &snippet_provider);\n+        let mut visitor =\n+            FmtVisitor::from_codemap(parse_session, config, &snippet_provider, report.clone());\n         // Format inner attributes if available.\n         if !krate.attrs.is_empty() && path == *main_file {\n             visitor.skip_empty_lines(filemap.end_pos);\n@@ -377,8 +412,7 @@ where\n             ::utils::count_newlines(&visitor.buffer)\n         );\n \n-        let filename = path.clone();\n-        has_diff |= match after_file(&filename, &mut visitor.buffer, &visitor.skipped_range) {\n+        has_diff |= match after_file(&path, &mut visitor.buffer, &visitor.skipped_range, &report) {\n             Ok(result) => result,\n             Err(e) => {\n                 // Create a new error with path_str to help users see which files failed\n@@ -387,7 +421,7 @@ where\n             }\n         };\n \n-        result.push((filename, visitor.buffer));\n+        result.push((path.clone(), visitor.buffer));\n     }\n \n     Ok((result, has_diff))\n@@ -426,7 +460,7 @@ fn format_lines(\n     name: &FileName,\n     skipped_range: &[(usize, usize)],\n     config: &Config,\n-    report: &mut FormatReport,\n+    report: &FormatReport,\n ) {\n     let mut trims = vec![];\n     let mut last_wspace: Option<usize> = None;\n@@ -540,7 +574,7 @@ fn format_lines(\n         }\n     }\n \n-    report.file_error_map.insert(name.clone(), errors);\n+    report.append(name.clone(), errors);\n }\n \n fn parse_input<'sess>(\n@@ -757,19 +791,20 @@ fn format_input_inner<T: Write>(\n     ));\n     parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n \n-    let mut report = FormatReport::new();\n+    let report = FormatReport::new();\n \n     let format_result = format_ast(\n         &krate,\n         &mut parse_session,\n         &main_file,\n         config,\n-        |file_name, file, skipped_range| {\n+        report.clone(),\n+        |file_name, file, skipped_range, report| {\n             // For some reason, the codemap does not include terminating\n             // newlines so we must add one on for each file. This is sad.\n             filemap::append_newline(file);\n \n-            format_lines(file, file_name, skipped_range, config, &mut report);\n+            format_lines(file, file_name, skipped_range, config, report);\n \n             if let Some(ref mut out) = out {\n                 return filemap::write_file(file, file_name, out, config);"}, {"sha": "7c7bb060fd3b8f97ae6ca4c090a73649d3da88c4", "filename": "src/rewrite.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/390a28485159a9bd165fa5101b7537b34493341e/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390a28485159a9bd165fa5101b7537b34493341e/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=390a28485159a9bd165fa5101b7537b34493341e", "patch": "@@ -16,6 +16,7 @@ use syntax::parse::ParseSess;\n use config::{Config, IndentStyle};\n use shape::Shape;\n use visitor::SnippetProvider;\n+use FormatReport;\n \n use std::cell::RefCell;\n \n@@ -38,6 +39,7 @@ pub struct RewriteContext<'a> {\n     // When rewriting chain, veto going multi line except the last element\n     pub force_one_line_chain: RefCell<bool>,\n     pub snippet_provider: &'a SnippetProvider<'a>,\n+    pub report: FormatReport,\n }\n \n impl<'a> RewriteContext<'a> {"}, {"sha": "991ebf16bf22bdb9744835b01566da056e66d8a0", "filename": "src/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/390a28485159a9bd165fa5101b7537b34493341e/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390a28485159a9bd165fa5101b7537b34493341e/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=390a28485159a9bd165fa5101b7537b34493341e", "patch": "@@ -22,8 +22,8 @@ use config::Color;\n use rewrite::RewriteContext;\n use shape::Shape;\n \n-const DEPR_SKIP_ANNOTATION: &str = \"rustfmt_skip\";\n-const SKIP_ANNOTATION: &str = \"rustfmt::skip\";\n+pub const DEPR_SKIP_ANNOTATION: &str = \"rustfmt_skip\";\n+pub const SKIP_ANNOTATION: &str = \"rustfmt::skip\";\n \n // Computes the length of a string's last line, minus offset.\n pub fn extra_offset(text: &str, shape: Shape) -> usize {"}, {"sha": "ec1890035a72f28e7c05769fc676d9952b806123", "filename": "src/visitor.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/390a28485159a9bd165fa5101b7537b34493341e/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390a28485159a9bd165fa5101b7537b34493341e/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=390a28485159a9bd165fa5101b7537b34493341e", "patch": "@@ -26,7 +26,11 @@ use macros::{rewrite_macro, rewrite_macro_def, MacroPosition};\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use spanned::Spanned;\n-use utils::{self, contains_skip, count_newlines, inner_attributes, mk_sp, ptr_vec_to_ref_vec};\n+use utils::{\n+    self, contains_skip, count_newlines, inner_attributes, mk_sp, ptr_vec_to_ref_vec,\n+    DEPR_SKIP_ANNOTATION,\n+};\n+use {ErrorKind, FormatReport, FormattingError};\n \n use std::cell::RefCell;\n \n@@ -66,6 +70,7 @@ pub struct FmtVisitor<'a> {\n     pub snippet_provider: &'a SnippetProvider<'a>,\n     pub line_number: usize,\n     pub skipped_range: Vec<(usize, usize)>,\n+    pub report: FormatReport,\n }\n \n impl<'b, 'a: 'b> FmtVisitor<'a> {\n@@ -552,13 +557,19 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     }\n \n     pub fn from_context(ctx: &'a RewriteContext) -> FmtVisitor<'a> {\n-        FmtVisitor::from_codemap(ctx.parse_session, ctx.config, ctx.snippet_provider)\n+        FmtVisitor::from_codemap(\n+            ctx.parse_session,\n+            ctx.config,\n+            ctx.snippet_provider,\n+            ctx.report.clone(),\n+        )\n     }\n \n     pub fn from_codemap(\n         parse_session: &'a ParseSess,\n         config: &'a Config,\n         snippet_provider: &'a SnippetProvider,\n+        report: FormatReport,\n     ) -> FmtVisitor<'a> {\n         FmtVisitor {\n             parse_session,\n@@ -571,6 +582,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             snippet_provider,\n             line_number: 0,\n             skipped_range: vec![],\n+            report,\n         }\n     }\n \n@@ -584,6 +596,33 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n     // Returns true if we should skip the following item.\n     pub fn visit_attrs(&mut self, attrs: &[ast::Attribute], style: ast::AttrStyle) -> bool {\n+        for attr in attrs {\n+            if attr.name() == DEPR_SKIP_ANNOTATION {\n+                let file_name = self.codemap.span_to_filename(attr.span);\n+                self.report.append(\n+                    file_name,\n+                    vec![FormattingError::from_span(\n+                        &attr.span,\n+                        &self.codemap,\n+                        ErrorKind::DeprecatedAttr,\n+                    )],\n+                );\n+            } else if attr.path.segments[0].ident.to_string() == \"rustfmt\" {\n+                if attr.path.segments.len() == 1\n+                    || attr.path.segments[1].ident.to_string() != \"skip\"\n+                {\n+                    let file_name = self.codemap.span_to_filename(attr.span);\n+                    self.report.append(\n+                        file_name,\n+                        vec![FormattingError::from_span(\n+                            &attr.span,\n+                            &self.codemap,\n+                            ErrorKind::BadAttr,\n+                        )],\n+                    );\n+                }\n+            }\n+        }\n         if contains_skip(attrs) {\n             return true;\n         }\n@@ -711,6 +750,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             is_if_else_block: RefCell::new(false),\n             force_one_line_chain: RefCell::new(false),\n             snippet_provider: self.snippet_provider,\n+            report: self.report.clone(),\n         }\n     }\n }"}]}