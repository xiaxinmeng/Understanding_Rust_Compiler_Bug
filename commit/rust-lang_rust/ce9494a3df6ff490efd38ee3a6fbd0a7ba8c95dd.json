{"sha": "ce9494a3df6ff490efd38ee3a6fbd0a7ba8c95dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlOTQ5NGEzZGY2ZmY0OTBlZmQzOGVlM2E2ZmJkMGE3YmE4Yzk1ZGQ=", "commit": {"author": {"name": "pJunger", "email": "pJunger@users.noreply.github.com", "date": "2019-05-14T19:39:12Z"}, "committer": {"name": "pJunger", "email": "pJunger@users.noreply.github.com", "date": "2019-05-18T07:34:56Z"}, "message": "Changed impl to use symbols.", "tree": {"sha": "226bf7bc3783d6f0e2cdae6f2a444b0a5334cd88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/226bf7bc3783d6f0e2cdae6f2a444b0a5334cd88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce9494a3df6ff490efd38ee3a6fbd0a7ba8c95dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce9494a3df6ff490efd38ee3a6fbd0a7ba8c95dd", "html_url": "https://github.com/rust-lang/rust/commit/ce9494a3df6ff490efd38ee3a6fbd0a7ba8c95dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce9494a3df6ff490efd38ee3a6fbd0a7ba8c95dd/comments", "author": {"login": "pJunger", "id": 16426009, "node_id": "MDQ6VXNlcjE2NDI2MDA5", "avatar_url": "https://avatars.githubusercontent.com/u/16426009?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pJunger", "html_url": "https://github.com/pJunger", "followers_url": "https://api.github.com/users/pJunger/followers", "following_url": "https://api.github.com/users/pJunger/following{/other_user}", "gists_url": "https://api.github.com/users/pJunger/gists{/gist_id}", "starred_url": "https://api.github.com/users/pJunger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pJunger/subscriptions", "organizations_url": "https://api.github.com/users/pJunger/orgs", "repos_url": "https://api.github.com/users/pJunger/repos", "events_url": "https://api.github.com/users/pJunger/events{/privacy}", "received_events_url": "https://api.github.com/users/pJunger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pJunger", "id": 16426009, "node_id": "MDQ6VXNlcjE2NDI2MDA5", "avatar_url": "https://avatars.githubusercontent.com/u/16426009?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pJunger", "html_url": "https://github.com/pJunger", "followers_url": "https://api.github.com/users/pJunger/followers", "following_url": "https://api.github.com/users/pJunger/following{/other_user}", "gists_url": "https://api.github.com/users/pJunger/gists{/gist_id}", "starred_url": "https://api.github.com/users/pJunger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pJunger/subscriptions", "organizations_url": "https://api.github.com/users/pJunger/orgs", "repos_url": "https://api.github.com/users/pJunger/repos", "events_url": "https://api.github.com/users/pJunger/events{/privacy}", "received_events_url": "https://api.github.com/users/pJunger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00a5ef64a20c0b188ac27b5ba935cb291ea3bf85", "url": "https://api.github.com/repos/rust-lang/rust/commits/00a5ef64a20c0b188ac27b5ba935cb291ea3bf85", "html_url": "https://github.com/rust-lang/rust/commit/00a5ef64a20c0b188ac27b5ba935cb291ea3bf85"}], "stats": {"total": 76, "additions": 45, "deletions": 31}, "files": [{"sha": "351928ca784c94b96c9fc296138d582f2e127053", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ce9494a3df6ff490efd38ee3a6fbd0a7ba8c95dd/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9494a3df6ff490efd38ee3a6fbd0a7ba8c95dd/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=ce9494a3df6ff490efd38ee3a6fbd0a7ba8c95dd", "patch": "@@ -1,12 +1,15 @@\n //! lint on manually implemented checked conversions that could be transformed into `try_from`\n \n use if_chain::if_chain;\n+use lazy_static::lazy_static;\n use rustc::hir::*;\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n-use crate::utils::{span_lint_and_sugg, snippet_with_applicability, SpanlessEq};\n+use syntax::symbol::Symbol;\n+\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg, sym, SpanlessEq};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for explicit bounds checking when casting.\n@@ -101,7 +104,7 @@ fn double_check<'a>(cx: &LateContext<'_, '_>, left: &'a Expr, right: &'a Expr) -\n struct Conversion<'a> {\n     cvt: ConversionType,\n     expr_to_cast: &'a Expr,\n-    to_type: Option<String>,\n+    to_type: Option<Symbol>,\n }\n \n /// The kind of conversion that is checked\n@@ -137,8 +140,8 @@ impl<'a> Conversion<'a> {\n     }\n \n     /// Try to construct a new conversion if the conversion type is valid\n-    fn try_new<'b>(expr_to_cast: &'a Expr, from_type: &'b str, to_type: String) -> Option<Conversion<'a>> {\n-        ConversionType::try_new(from_type, &to_type).map(|cvt| Conversion {\n+    fn try_new<'b>(expr_to_cast: &'a Expr, from_type: Symbol, to_type: Symbol) -> Option<Conversion<'a>> {\n+        ConversionType::try_new(from_type, to_type).map(|cvt| Conversion {\n             cvt,\n             expr_to_cast,\n             to_type: Some(to_type),\n@@ -157,13 +160,13 @@ impl<'a> Conversion<'a> {\n \n impl ConversionType {\n     /// Creates a conversion type if the type is allowed & conversion is valid\n-    fn try_new(from: &str, to: &str) -> Option<Self> {\n-        if UNSIGNED_TYPES.contains(&from) {\n+    fn try_new(from: Symbol, to: Symbol) -> Option<Self> {\n+        if UINTS.contains(&from) {\n             Some(ConversionType::FromUnsigned)\n-        } else if SIGNED_TYPES.contains(&from) {\n-            if UNSIGNED_TYPES.contains(&to) {\n+        } else if SINTS.contains(&from) {\n+            if UINTS.contains(&to) {\n                 Some(ConversionType::SignedToUnsigned)\n-            } else if SIGNED_TYPES.contains(&to) {\n+            } else if SINTS.contains(&to) {\n                 Some(ConversionType::SignedToSigned)\n             } else {\n                 None\n@@ -179,10 +182,10 @@ fn check_upper_bound(expr: &Expr) -> Option<Conversion<'_>> {\n     if_chain! {\n          if let ExprKind::Binary(ref op, ref left, ref right) = &expr.node;\n          if let Some((candidate, check)) = normalize_le_ge(op, left, right);\n-         if let Some((from, to)) = get_types_from_cast(check, \"max_value\", INT_TYPES);\n+         if let Some((from, to)) = get_types_from_cast(check, *sym::max_value, &*INTS);\n \n          then {\n-             Conversion::try_new(candidate, &from, to)\n+             Conversion::try_new(candidate, from, to)\n          } else {\n             None\n         }\n@@ -219,31 +222,31 @@ fn check_lower_bound_zero<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Co\n \n /// Check for `expr >= (to_type::min_value() as from_type)`\n fn check_lower_bound_min<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Conversion<'a>> {\n-    if let Some((from, to)) = get_types_from_cast(check, \"min_value\", SIGNED_TYPES) {\n-        Conversion::try_new(candidate, &from, to)\n+    if let Some((from, to)) = get_types_from_cast(check, *sym::min_value, &*SINTS) {\n+        Conversion::try_new(candidate, from, to)\n     } else {\n         None\n     }\n }\n \n /// Tries to extract the from- and to-type from a cast expression\n-fn get_types_from_cast(expr: &Expr, func: &str, types: &[&str]) -> Option<(String, String)> {\n+fn get_types_from_cast(expr: &Expr, func: Symbol, types: &[Symbol]) -> Option<(Symbol, Symbol)> {\n     // `to_type::maxmin_value() as from_type`\n-    let call_from_cast: Option<(&Expr, String)> = if_chain! {\n+    let call_from_cast: Option<(&Expr, Symbol)> = if_chain! {\n         // to_type::maxmin_value(), from_type\n         if let ExprKind::Cast(ref limit, ref from_type) = &expr.node;\n         if let TyKind::Path(ref from_type_path) = &from_type.node;\n-        if let Some(from_type_str) = int_ty_to_str(from_type_path);\n+        if let Some(from_sym) = int_ty_to_sym(from_type_path);\n \n         then {\n-            Some((limit, from_type_str.to_string()))\n+            Some((limit, from_sym))\n         } else {\n             None\n         }\n     };\n \n     // `from_type::from(to_type::maxmin_value())`\n-    let limit_from: Option<(&Expr, String)> = call_from_cast.or_else(|| {\n+    let limit_from: Option<(&Expr, Symbol)> = call_from_cast.or_else(|| {\n         if_chain! {\n             // `from_type::from, to_type::maxmin_value()`\n             if let ExprKind::Call(ref from_func, ref args) = &expr.node;\n@@ -252,10 +255,10 @@ fn get_types_from_cast(expr: &Expr, func: &str, types: &[&str]) -> Option<(Strin\n             if let limit = &args[0];\n             // `from_type::from`\n             if let ExprKind::Path(ref path) = &from_func.node;\n-            if let Some(from_type) = get_implementing_type(path, INT_TYPES, \"from\");\n+            if let Some(from_sym) = get_implementing_type(path, &*INTS, *sym::from);\n \n             then {\n-                Some((limit, from_type))\n+                Some((limit, from_sym))\n             } else {\n                 None\n             }\n@@ -282,33 +285,33 @@ fn get_types_from_cast(expr: &Expr, func: &str, types: &[&str]) -> Option<(Strin\n }\n \n /// Gets the type which implements the called function\n-fn get_implementing_type(path: &QPath, candidates: &[&str], function: &str) -> Option<String> {\n+fn get_implementing_type(path: &QPath, candidates: &[Symbol], function: Symbol) -> Option<Symbol> {\n     if_chain! {\n         if let QPath::TypeRelative(ref ty, ref path) = &path;\n         if path.ident.name == function;\n         if let TyKind::Path(QPath::Resolved(None, ref tp)) = &ty.node;\n         if let [int] = &*tp.segments;\n-        let name = int.ident.as_str().get();\n+        let name = int.ident.name;\n         if candidates.contains(&name);\n \n         then {\n-            Some(name.to_string())\n+            Some(name)\n         } else {\n             None\n         }\n     }\n }\n \n /// Gets the type as a string, if it is a supported integer\n-fn int_ty_to_str(path: &QPath) -> Option<&str> {\n+fn int_ty_to_sym(path: &QPath) -> Option<Symbol> {\n     if_chain! {\n         if let QPath::Resolved(_, ref path) = *path;\n         if let [ty] = &*path.segments;\n \n         then {\n-            INT_TYPES\n+            INTS\n                 .iter()\n-                .find(|c| (&ty.ident.name) == *c)\n+                .find(|c| ty.ident.name == **c)\n                 .cloned()\n         } else {\n             None\n@@ -333,8 +336,19 @@ fn normalize_le_ge<'a>(op: &'a BinOp, left: &'a Expr, right: &'a Expr) -> Option\n     }\n }\n \n-const UNSIGNED_TYPES: &[&str] = &[\"u8\", \"u16\", \"u32\", \"u64\", \"u128\", \"usize\"];\n-const SIGNED_TYPES: &[&str] = &[\"i8\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\"];\n-const INT_TYPES: &[&str] = &[\n-    \"u8\", \"u16\", \"u32\", \"u64\", \"u128\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\",\n-];\n+lazy_static! {\n+    static ref UINTS: [Symbol; 5] = [*sym::u8, *sym::u16, *sym::u32, *sym::u64, *sym::usize];\n+    static ref SINTS: [Symbol; 5] = [*sym::i8, *sym::i16, *sym::i32, *sym::i64, *sym::isize];\n+    static ref INTS: [Symbol; 10] = [\n+        *sym::u8,\n+        *sym::u16,\n+        *sym::u32,\n+        *sym::u64,\n+        *sym::usize,\n+        *sym::i8,\n+        *sym::i16,\n+        *sym::i32,\n+        *sym::i64,\n+        *sym::isize\n+    ];\n+}"}]}