{"sha": "16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZTI1ZjBlYTNjYjkzY2FjODVmNjEwN2NlNjJhNWQ0YWRiYjNlODQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-11-03T12:36:59Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-19T09:16:08Z"}, "message": "rustc: use LocalDefId instead of DefIndex in hir::map::definitions.", "tree": {"sha": "721005f395aaf957869f5cd3f991f434792bd627", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/721005f395aaf957869f5cd3f991f434792bd627"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "html_url": "https://github.com/rust-lang/rust/commit/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b0a21ead15c3651f78b3203c56ccf02c31aacb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b0a21ead15c3651f78b3203c56ccf02c31aacb2", "html_url": "https://github.com/rust-lang/rust/commit/2b0a21ead15c3651f78b3203c56ccf02c31aacb2"}], "stats": {"total": 282, "additions": 137, "deletions": 145}, "files": [{"sha": "de0cc61118fed9abe8142d2b1359c85287a9d956", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "patch": "@@ -98,7 +98,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         definitions: &'a definitions::Definitions,\n         mut hcx: StableHashingContext<'a>,\n     ) -> NodeCollector<'a, 'hir> {\n-        let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n+        let root_mod_def_path_hash =\n+            definitions.def_path_hash(LocalDefId { local_def_index: CRATE_DEF_INDEX });\n \n         let mut hir_body_nodes = Vec::new();\n \n@@ -244,8 +245,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             assert_eq!(self.definitions.node_to_hir_id(node_id), hir_id);\n \n             if hir_id.owner != self.current_dep_node_owner {\n-                let node_str = match self.definitions.opt_def_index(node_id) {\n-                    Some(def_index) => self.definitions.def_path(def_index).to_string_no_crate(),\n+                let node_str = match self.definitions.opt_local_def_id(node_id) {\n+                    Some(def_id) => self.definitions.def_path(def_id).to_string_no_crate(),\n                     None => format!(\"{:?}\", node),\n                 };\n \n@@ -261,11 +262,9 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?}){}\",\n                     self.source_map.span_to_string(span),\n                     node_str,\n-                    self.definitions\n-                        .def_path(self.current_dep_node_owner.local_def_index)\n-                        .to_string_no_crate(),\n+                    self.definitions.def_path(self.current_dep_node_owner).to_string_no_crate(),\n                     self.current_dep_node_owner,\n-                    self.definitions.def_path(hir_id.owner.local_def_index).to_string_no_crate(),\n+                    self.definitions.def_path(hir_id.owner).to_string_no_crate(),\n                     hir_id.owner,\n                     forgot_str,\n                 )\n@@ -293,7 +292,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     ) {\n         let prev_owner = self.current_dep_node_owner;\n \n-        let def_path_hash = self.definitions.def_path_hash(dep_node_owner.local_def_index);\n+        let def_path_hash = self.definitions.def_path_hash(dep_node_owner);\n \n         let hash = hash_body(&mut self.hcx, def_path_hash, item_like, &mut self.hir_body_nodes);\n \n@@ -342,8 +341,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n         debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(\n-            i.hir_id.owner.local_def_index,\n-            self.definitions.opt_def_index(self.definitions.hir_to_node_id(i.hir_id)).unwrap()\n+            i.hir_id.owner,\n+            self.definitions.opt_local_def_id(self.definitions.hir_to_node_id(i.hir_id)).unwrap()\n         );\n         self.with_dep_node_owner(i.hir_id.owner, i, |this, hash| {\n             this.insert_with_hash(i.span, i.hir_id, Node::Item(i), hash);\n@@ -374,8 +373,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n         debug_assert_eq!(\n-            ti.hir_id.owner.local_def_index,\n-            self.definitions.opt_def_index(self.definitions.hir_to_node_id(ti.hir_id)).unwrap()\n+            ti.hir_id.owner,\n+            self.definitions.opt_local_def_id(self.definitions.hir_to_node_id(ti.hir_id)).unwrap()\n         );\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this, hash| {\n             this.insert_with_hash(ti.span, ti.hir_id, Node::TraitItem(ti), hash);\n@@ -388,8 +387,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n         debug_assert_eq!(\n-            ii.hir_id.owner.local_def_index,\n-            self.definitions.opt_def_index(self.definitions.hir_to_node_id(ii.hir_id)).unwrap()\n+            ii.hir_id.owner,\n+            self.definitions.opt_local_def_id(self.definitions.hir_to_node_id(ii.hir_id)).unwrap()\n         );\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this, hash| {\n             this.insert_with_hash(ii.span, ii.hir_id, Node::ImplItem(ii), hash);"}, {"sha": "aa4742ea891bb7e19580f139ddc67d327e74d0e4", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 77, "deletions": 81, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "patch": "@@ -5,11 +5,10 @@\n //! expressions) that are mostly just leftovers.\n \n use rustc_ast::ast;\n-use rustc_ast::node_id::NodeMap;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_index::vec::IndexVec;\n use rustc_session::CrateDisambiguator;\n use rustc_span::hygiene::ExpnId;\n@@ -78,25 +77,29 @@ impl DefPathTable {\n #[derive(Clone, Default)]\n pub struct Definitions {\n     table: DefPathTable,\n-    node_to_def_index: NodeMap<DefIndex>,\n-    def_index_to_node: IndexVec<DefIndex, ast::NodeId>,\n \n-    pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n-    /// The reverse mapping of `node_to_hir_id`.\n-    pub(super) hir_to_node_id: FxHashMap<hir::HirId, ast::NodeId>,\n+    def_id_to_span: IndexVec<LocalDefId, Span>,\n+\n+    // FIXME(eddyb) don't go through `ast::NodeId` to convert between `HirId`\n+    // and `LocalDefId` - ideally all `LocalDefId`s would be HIR owners.\n+    node_id_to_def_id: FxHashMap<ast::NodeId, LocalDefId>,\n+    def_id_to_node_id: IndexVec<LocalDefId, ast::NodeId>,\n+\n+    pub(super) node_id_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n+    /// The reverse mapping of `node_id_to_hir_id`.\n+    pub(super) hir_id_to_node_id: FxHashMap<hir::HirId, ast::NodeId>,\n \n     /// If `ExpnId` is an ID of some macro expansion,\n     /// then `DefId` is the normal module (`mod`) in which the expanded macro was defined.\n     parent_modules_of_macro_defs: FxHashMap<ExpnId, DefId>,\n-    /// Item with a given `DefIndex` was defined during macro expansion with ID `ExpnId`.\n-    expansions_that_defined: FxHashMap<DefIndex, ExpnId>,\n-    next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n-    def_index_to_span: FxHashMap<DefIndex, Span>,\n+    /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n+    expansions_that_defined: FxHashMap<LocalDefId, ExpnId>,\n+    next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n     /// When collecting definitions from an AST fragment produced by a macro invocation `ExpnId`\n     /// we know what parent node that fragment should be attached to thanks to this table.\n-    invocation_parents: FxHashMap<ExpnId, DefIndex>,\n+    invocation_parents: FxHashMap<ExpnId, LocalDefId>,\n     /// Indices of unnamed struct or variant fields with unresolved attributes.\n-    placeholder_field_indices: NodeMap<usize>,\n+    placeholder_field_indices: FxHashMap<ast::NodeId, usize>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -296,43 +299,41 @@ impl Definitions {\n         self.table.index_to_key.len()\n     }\n \n-    pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.table.def_key(index)\n+    pub fn def_key(&self, id: LocalDefId) -> DefKey {\n+        self.table.def_key(id.local_def_index)\n     }\n \n     #[inline(always)]\n-    pub fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n-        self.table.def_path_hash(index)\n+    pub fn def_path_hash(&self, id: LocalDefId) -> DefPathHash {\n+        self.table.def_path_hash(id.local_def_index)\n     }\n \n     /// Returns the path from the crate root to `index`. The root\n     /// nodes are not included in the path (i.e., this will be an\n     /// empty vector for the crate root). For an inlined item, this\n     /// will be the path of the item in the external crate (but the\n     /// path will begin with the path to the external crate).\n-    pub fn def_path(&self, index: DefIndex) -> DefPath {\n-        DefPath::make(LOCAL_CRATE, index, |p| self.def_key(p))\n+    pub fn def_path(&self, id: LocalDefId) -> DefPath {\n+        DefPath::make(LOCAL_CRATE, id.local_def_index, |index| {\n+            self.def_key(LocalDefId { local_def_index: index })\n+        })\n     }\n \n     #[inline]\n-    pub fn opt_def_index(&self, node: ast::NodeId) -> Option<DefIndex> {\n-        self.node_to_def_index.get(&node).copied()\n-    }\n-\n-    #[inline]\n-    pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<DefId> {\n-        self.opt_def_index(node).map(DefId::local)\n+    pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<LocalDefId> {\n+        self.node_id_to_def_id.get(&node).copied()\n     }\n \n+    // FIXME(eddyb) this function can and should return `LocalDefId`.\n     #[inline]\n     pub fn local_def_id(&self, node: ast::NodeId) -> DefId {\n-        self.opt_local_def_id(node).unwrap()\n+        self.opt_local_def_id(node).unwrap().to_def_id()\n     }\n \n     #[inline]\n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n-        if def_id.krate == LOCAL_CRATE {\n-            let node_id = self.def_index_to_node[def_id.index];\n+        if let Some(def_id) = def_id.as_local() {\n+            let node_id = self.def_id_to_node_id[def_id];\n             if node_id != ast::DUMMY_NODE_ID {\n                 return Some(node_id);\n             }\n@@ -342,47 +343,44 @@ impl Definitions {\n \n     #[inline]\n     pub fn as_local_hir_id(&self, def_id: DefId) -> Option<hir::HirId> {\n-        if def_id.krate == LOCAL_CRATE {\n-            let hir_id = self.def_index_to_hir_id(def_id.index);\n+        if let Some(def_id) = def_id.as_local() {\n+            let hir_id = self.local_def_id_to_hir_id(def_id);\n             if hir_id != hir::DUMMY_HIR_ID { Some(hir_id) } else { None }\n         } else {\n             None\n         }\n     }\n \n+    // FIXME(eddyb) rename to `hir_id_to_node_id`.\n     #[inline]\n     pub fn hir_to_node_id(&self, hir_id: hir::HirId) -> ast::NodeId {\n-        self.hir_to_node_id[&hir_id]\n+        self.hir_id_to_node_id[&hir_id]\n     }\n \n+    // FIXME(eddyb) rename to `node_id_to_hir_id`.\n     #[inline]\n     pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n-        self.node_to_hir_id[node_id]\n+        self.node_id_to_hir_id[node_id]\n     }\n \n     #[inline]\n-    pub fn def_index_to_hir_id(&self, def_index: DefIndex) -> hir::HirId {\n-        let node_id = self.def_index_to_node[def_index];\n-        self.node_to_hir_id[node_id]\n+    pub fn local_def_id_to_hir_id(&self, id: LocalDefId) -> hir::HirId {\n+        let node_id = self.def_id_to_node_id[id];\n+        self.node_id_to_hir_id[node_id]\n     }\n \n-    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate, the span exists\n-    /// and it's not `DUMMY_SP`.\n+    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n-        if def_id.krate == LOCAL_CRATE {\n-            self.def_index_to_span.get(&def_id.index).copied()\n-        } else {\n-            None\n-        }\n+        if let Some(def_id) = def_id.as_local() { Some(self.def_id_to_span[def_id]) } else { None }\n     }\n \n     /// Adds a root definition (no parent) and a few other reserved definitions.\n     pub fn create_root_def(\n         &mut self,\n         crate_name: &str,\n         crate_disambiguator: CrateDisambiguator,\n-    ) -> DefIndex {\n+    ) -> LocalDefId {\n         let key = DefKey {\n             parent: None,\n             disambiguated_data: DisambiguatedDefPathData {\n@@ -395,36 +393,38 @@ impl Definitions {\n         let def_path_hash = key.compute_stable_hash(parent_hash);\n \n         // Create the definition.\n-        let root_index = self.table.allocate(key, def_path_hash);\n-        assert_eq!(root_index, CRATE_DEF_INDEX);\n-        assert!(self.def_index_to_node.is_empty());\n-        self.def_index_to_node.push(ast::CRATE_NODE_ID);\n-        self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n-        self.set_invocation_parent(ExpnId::root(), root_index);\n+        let root = LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) };\n+        assert_eq!(root.local_def_index, CRATE_DEF_INDEX);\n+\n+        assert_eq!(self.def_id_to_node_id.push(ast::CRATE_NODE_ID), root);\n+        assert_eq!(self.def_id_to_span.push(rustc_span::DUMMY_SP), root);\n+\n+        self.node_id_to_def_id.insert(ast::CRATE_NODE_ID, root);\n+        self.set_invocation_parent(ExpnId::root(), root);\n \n-        root_index\n+        root\n     }\n \n     /// Adds a definition with a parent definition.\n     pub fn create_def_with_parent(\n         &mut self,\n-        parent: DefIndex,\n+        parent: LocalDefId,\n         node_id: ast::NodeId,\n         data: DefPathData,\n         expn_id: ExpnId,\n         span: Span,\n-    ) -> DefIndex {\n+    ) -> LocalDefId {\n         debug!(\n             \"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n             parent, node_id, data\n         );\n \n         assert!(\n-            !self.node_to_def_index.contains_key(&node_id),\n+            !self.node_id_to_def_id.contains_key(&node_id),\n             \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n             node_id,\n             data,\n-            self.table.def_key(self.node_to_def_index[&node_id])\n+            self.table.def_key(self.node_id_to_def_id[&node_id].local_def_index),\n         );\n \n         // The root node must be created with `create_root_def()`.\n@@ -439,59 +439,55 @@ impl Definitions {\n         };\n \n         let key = DefKey {\n-            parent: Some(parent),\n+            parent: Some(parent.local_def_index),\n             disambiguated_data: DisambiguatedDefPathData { data, disambiguator },\n         };\n \n-        let parent_hash = self.table.def_path_hash(parent);\n+        let parent_hash = self.table.def_path_hash(parent.local_def_index);\n         let def_path_hash = key.compute_stable_hash(parent_hash);\n \n         debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n-        let index = self.table.allocate(key, def_path_hash);\n-        assert_eq!(index.index(), self.def_index_to_node.len());\n-        self.def_index_to_node.push(node_id);\n+        let def_id = LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) };\n \n-        // Some things for which we allocate `DefIndex`es don't correspond to\n+        assert_eq!(self.def_id_to_node_id.push(node_id), def_id);\n+        assert_eq!(self.def_id_to_span.push(span), def_id);\n+\n+        // Some things for which we allocate `LocalDefId`s don't correspond to\n         // anything in the AST, so they don't have a `NodeId`. For these cases\n-        // we don't need a mapping from `NodeId` to `DefIndex`.\n+        // we don't need a mapping from `NodeId` to `LocalDefId`.\n         if node_id != ast::DUMMY_NODE_ID {\n-            debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n-            self.node_to_def_index.insert(node_id, index);\n+            debug!(\"create_def_with_parent: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n+            self.node_id_to_def_id.insert(node_id, def_id);\n         }\n \n         if expn_id != ExpnId::root() {\n-            self.expansions_that_defined.insert(index, expn_id);\n-        }\n-\n-        // The span is added if it isn't dummy.\n-        if !span.is_dummy() {\n-            self.def_index_to_span.insert(index, span);\n+            self.expansions_that_defined.insert(def_id, expn_id);\n         }\n \n-        index\n+        def_id\n     }\n \n     /// Initializes the `ast::NodeId` to `HirId` mapping once it has been generated during\n     /// AST to HIR lowering.\n     pub fn init_node_id_to_hir_id_mapping(&mut self, mapping: IndexVec<ast::NodeId, hir::HirId>) {\n         assert!(\n-            self.node_to_hir_id.is_empty(),\n+            self.node_id_to_hir_id.is_empty(),\n             \"trying to initialize `NodeId` -> `HirId` mapping twice\"\n         );\n-        self.node_to_hir_id = mapping;\n+        self.node_id_to_hir_id = mapping;\n \n-        // Build the reverse mapping of `node_to_hir_id`.\n-        self.hir_to_node_id = self\n-            .node_to_hir_id\n+        // Build the reverse mapping of `node_id_to_hir_id`.\n+        self.hir_id_to_node_id = self\n+            .node_id_to_hir_id\n             .iter_enumerated()\n             .map(|(node_id, &hir_id)| (hir_id, node_id))\n             .collect();\n     }\n \n-    pub fn expansion_that_defined(&self, index: DefIndex) -> ExpnId {\n-        self.expansions_that_defined.get(&index).copied().unwrap_or(ExpnId::root())\n+    pub fn expansion_that_defined(&self, id: LocalDefId) -> ExpnId {\n+        self.expansions_that_defined.get(&id).copied().unwrap_or(ExpnId::root())\n     }\n \n     pub fn parent_module_of_macro_def(&self, expn_id: ExpnId) -> DefId {\n@@ -502,13 +498,13 @@ impl Definitions {\n         self.parent_modules_of_macro_defs.insert(expn_id, module);\n     }\n \n-    pub fn invocation_parent(&self, invoc_id: ExpnId) -> DefIndex {\n+    pub fn invocation_parent(&self, invoc_id: ExpnId) -> LocalDefId {\n         self.invocation_parents[&invoc_id]\n     }\n \n-    pub fn set_invocation_parent(&mut self, invoc_id: ExpnId, parent: DefIndex) {\n+    pub fn set_invocation_parent(&mut self, invoc_id: ExpnId, parent: LocalDefId) {\n         let old_parent = self.invocation_parents.insert(invoc_id, parent);\n-        assert!(old_parent.is_none(), \"parent `DefIndex` is reset for an invocation\");\n+        assert!(old_parent.is_none(), \"parent `LocalDefId` is reset for an invocation\");\n     }\n \n     pub fn placeholder_field_index(&self, node_id: ast::NodeId) -> usize {"}, {"sha": "36cb19c6c37c727f8c30adb1bf28adbd2a134c24", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "patch": "@@ -9,7 +9,7 @@ use crate::ty::TyCtxt;\n use rustc_ast::ast::{self, Name, NodeId};\n use rustc_data_structures::svh::Svh;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::print::Nested;\n@@ -189,17 +189,18 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn def_key(&self, def_id: LocalDefId) -> DefKey {\n-        self.tcx.definitions.def_key(def_id.local_def_index)\n+        self.tcx.definitions.def_key(def_id)\n     }\n \n     pub fn def_path_from_hir_id(&self, id: HirId) -> Option<DefPath> {\n         self.opt_local_def_id(id).map(|def_id| self.def_path(def_id.expect_local()))\n     }\n \n     pub fn def_path(&self, def_id: LocalDefId) -> DefPath {\n-        self.tcx.definitions.def_path(def_id.local_def_index)\n+        self.tcx.definitions.def_path(def_id)\n     }\n \n+    // FIXME(eddyb) this function can and should return `LocalDefId`.\n     #[inline]\n     pub fn local_def_id_from_node_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id_from_node_id(node).unwrap_or_else(|| {\n@@ -212,6 +213,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n+    // FIXME(eddyb) this function can and should return `LocalDefId`.\n     #[inline]\n     pub fn local_def_id(&self, hir_id: HirId) -> DefId {\n         self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n@@ -226,12 +228,12 @@ impl<'hir> Map<'hir> {\n     #[inline]\n     pub fn opt_local_def_id(&self, hir_id: HirId) -> Option<DefId> {\n         let node_id = self.hir_to_node_id(hir_id);\n-        self.tcx.definitions.opt_local_def_id(node_id)\n+        self.opt_local_def_id_from_node_id(node_id)\n     }\n \n     #[inline]\n     pub fn opt_local_def_id_from_node_id(&self, node: NodeId) -> Option<DefId> {\n-        self.tcx.definitions.opt_local_def_id(node)\n+        Some(self.tcx.definitions.opt_local_def_id(node)?.to_def_id())\n     }\n \n     #[inline]\n@@ -254,14 +256,9 @@ impl<'hir> Map<'hir> {\n         self.tcx.definitions.node_to_hir_id(node_id)\n     }\n \n-    #[inline]\n-    pub fn def_index_to_hir_id(&self, def_index: DefIndex) -> HirId {\n-        self.tcx.definitions.def_index_to_hir_id(def_index)\n-    }\n-\n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n-        self.tcx.definitions.def_index_to_hir_id(def_id.local_def_index)\n+        self.tcx.definitions.local_def_id_to_hir_id(def_id)\n     }\n \n     pub fn def_kind(&self, hir_id: HirId) -> Option<DefKind> {\n@@ -404,6 +401,7 @@ impl<'hir> Map<'hir> {\n         parent\n     }\n \n+    // FIXME(eddyb) this function can and should return `LocalDefId`.\n     pub fn body_owner_def_id(&self, id: BodyId) -> DefId {\n         self.local_def_id(self.body_owner(id))\n     }\n@@ -776,6 +774,7 @@ impl<'hir> Map<'hir> {\n         scope\n     }\n \n+    // FIXME(eddyb) this function can and should return `LocalDefId`.\n     pub fn get_parent_did(&self, id: HirId) -> DefId {\n         self.local_def_id(self.get_parent_item(id))\n     }"}, {"sha": "ba3763f6ee0bd8818ede3eb30b8063bf1b7a5d5c", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "patch": "@@ -132,7 +132,7 @@ impl<'a> StableHashingContext<'a> {\n \n     #[inline]\n     pub fn local_def_path_hash(&self, def_id: LocalDefId) -> DefPathHash {\n-        self.definitions.def_path_hash(def_id.local_def_index)\n+        self.definitions.def_path_hash(def_id)\n     }\n \n     #[inline]"}, {"sha": "742d57fb58a51bfb6d9170813f2b939117f5f1d7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "patch": "@@ -1288,7 +1288,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline]\n     pub fn def_path_hash(self, def_id: DefId) -> hir_map::DefPathHash {\n         if let Some(def_id) = def_id.as_local() {\n-            self.definitions.def_path_hash(def_id.local_def_index)\n+            self.definitions.def_path_hash(def_id)\n         } else {\n             self.cstore.def_path_hash(def_id)\n         }\n@@ -2753,18 +2753,15 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n \n     providers.lookup_stability = |tcx, id| {\n-        assert_eq!(id.krate, LOCAL_CRATE);\n-        let id = tcx.hir().definitions().def_index_to_hir_id(id.index);\n+        let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n         tcx.stability().local_stability(id)\n     };\n     providers.lookup_const_stability = |tcx, id| {\n-        assert_eq!(id.krate, LOCAL_CRATE);\n-        let id = tcx.hir().definitions().def_index_to_hir_id(id.index);\n+        let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n         tcx.stability().local_const_stability(id)\n     };\n     providers.lookup_deprecation_entry = |tcx, id| {\n-        assert_eq!(id.krate, LOCAL_CRATE);\n-        let id = tcx.hir().definitions().def_index_to_hir_id(id.index);\n+        let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n         tcx.stability().local_deprecation_entry(id)\n     };\n     providers.extern_mod_stmt_cnum = |tcx, id| {"}, {"sha": "9e3853c51af13cb04afeb63fd9ad8d6b8058bfc8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "patch": "@@ -3096,9 +3096,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     fn expansion_that_defined(self, scope: DefId) -> ExpnId {\n-        match scope.krate {\n-            LOCAL_CRATE => self.hir().definitions().expansion_that_defined(scope.index),\n-            _ => ExpnId::root(),\n+        match scope.as_local() {\n+            Some(scope) => self.hir().definitions().expansion_that_defined(scope),\n+            None => ExpnId::root(),\n         }\n     }\n "}, {"sha": "dcedcd51f5063d4e8705b9878906372b678b4635", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "patch": "@@ -412,7 +412,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     UseTreeKind::Simple(_, id1, id2) => {\n                         for &id in &[id1, id2] {\n                             self.lctx.resolver.definitions().create_def_with_parent(\n-                                owner.local_def_index,\n+                                owner,\n                                 id,\n                                 DefPathData::Misc,\n                                 ExpnId::root(),\n@@ -642,15 +642,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             debug_assert!(local_id != HIR_ID_COUNTER_LOCKED);\n \n             *local_id_counter += 1;\n-            let owner = this\n-                .resolver\n-                .definitions()\n-                .opt_local_def_id(owner)\n-                .expect(\n-                    \"you forgot to call `create_def_with_parent` or are lowering node-IDs \\\n-                     that do not belong to the current owner\",\n-                )\n-                .expect_local();\n+            let owner = this.resolver.definitions().opt_local_def_id(owner).expect(\n+                \"you forgot to call `create_def_with_parent` or are lowering node-IDs \\\n+                 that do not belong to the current owner\",\n+            );\n \n             hir::HirId { owner, local_id: hir::ItemLocalId::from_u32(local_id) }\n         })\n@@ -777,7 +772,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         // Add a definition for the in-band lifetime def.\n         self.resolver.definitions().create_def_with_parent(\n-            parent_def_id.local_def_index,\n+            parent_def_id,\n             node_id,\n             DefPathData::LifetimeNs(str_name),\n             ExpnId::root(),\n@@ -1056,7 +1051,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     let impl_trait_node_id = self.resolver.next_node_id();\n                     let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n                     self.resolver.definitions().create_def_with_parent(\n-                        parent_def_id.local_def_index,\n+                        parent_def_id,\n                         impl_trait_node_id,\n                         DefPathData::ImplTrait,\n                         ExpnId::root(),\n@@ -1122,7 +1117,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                             // Add a definition for the in-band const def.\n                             self.resolver.definitions().create_def_with_parent(\n-                                parent_def_id.local_def_index,\n+                                parent_def_id,\n                                 node_id,\n                                 DefPathData::AnonConst,\n                                 ExpnId::root(),\n@@ -1560,7 +1555,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     let hir_id =\n                         self.context.lower_node_id_with_owner(def_node_id, self.opaque_ty_id);\n                     self.context.resolver.definitions().create_def_with_parent(\n-                        self.parent.local_def_index,\n+                        self.parent,\n                         def_node_id,\n                         DefPathData::LifetimeNs(name.ident().name),\n                         ExpnId::root(),"}, {"sha": "f20cdfcba15ca9b1e77fdb5026f1e93f0630aed1", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "patch": "@@ -870,11 +870,11 @@ impl<'a> CrateLoader<'a> {\n                 let cnum = self.resolve_crate(name, item.span, dep_kind, None);\n \n                 let def_id = definitions.opt_local_def_id(item.id).unwrap();\n-                let path_len = definitions.def_path(def_id.index).data.len();\n+                let path_len = definitions.def_path(def_id).data.len();\n                 self.update_extern_crate(\n                     cnum,\n                     ExternCrate {\n-                        src: ExternCrateSource::Extern(def_id),\n+                        src: ExternCrateSource::Extern(def_id.to_def_id()),\n                         span: item.span,\n                         path_len,\n                         dependency_of: LOCAL_CRATE,"}, {"sha": "6280fd62de9a828617caa8afa206e42443e48f2e", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "patch": "@@ -1438,8 +1438,8 @@ impl EncodeContext<'tcx> {\n             .into_iter()\n             .map(|(trait_def_id, mut impls)| {\n                 // Bring everything into deterministic order for hashing\n-                impls.sort_by_cached_key(|&def_index| {\n-                    tcx.hir().definitions().def_path_hash(def_index)\n+                impls.sort_by_cached_key(|&index| {\n+                    tcx.hir().definitions().def_path_hash(LocalDefId { local_def_index: index })\n                 });\n \n                 TraitImpls {"}, {"sha": "05d4fc8880e406dc8fb6194353e504e1c90041ac", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "patch": "@@ -2008,7 +2008,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 &traits::Obligation::new(\n                                     ObligationCause::new(\n                                         span,\n-                                        self.tcx().hir().def_index_to_hir_id(self.mir_def_id.index),\n+                                        self.tcx()\n+                                            .hir()\n+                                            .local_def_id_to_hir_id(self.mir_def_id.expect_local()),\n                                         traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                     ),\n                                     self.param_env,"}, {"sha": "505cd331a25099f5debc4e96d1a632d52dbd9d2d", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::ast::*;\n use rustc_ast::token::{self, Token};\n use rustc_ast::visit::{self, FnKind};\n use rustc_expand::expand::AstFragment;\n-use rustc_hir::def_id::DefIndex;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n@@ -21,18 +21,18 @@ crate fn collect_definitions(\n /// Creates `DefId`s for nodes in the AST.\n struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n-    parent_def: DefIndex,\n+    parent_def: LocalDefId,\n     expansion: ExpnId,\n }\n \n impl<'a> DefCollector<'a> {\n-    fn create_def(&mut self, node_id: NodeId, data: DefPathData, span: Span) -> DefIndex {\n+    fn create_def(&mut self, node_id: NodeId, data: DefPathData, span: Span) -> LocalDefId {\n         let parent_def = self.parent_def;\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n         self.definitions.create_def_with_parent(parent_def, node_id, data, self.expansion, span)\n     }\n \n-    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n+    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: LocalDefId, f: F) {\n         let orig_parent_def = std::mem::replace(&mut self.parent_def, parent_def);\n         f(self);\n         self.parent_def = orig_parent_def;"}, {"sha": "4a2a2a296faea32bb1405be9d09a02ae19e0ecd8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "patch": "@@ -37,7 +37,7 @@ use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX};\n use rustc_hir::PrimTy::{self, Bool, Char, Float, Int, Str, Uint};\n use rustc_hir::{GlobMap, TraitMap};\n use rustc_metadata::creader::{CStore, CrateLoader};\n@@ -1015,9 +1015,9 @@ impl<'a> AsMut<Resolver<'a>> for Resolver<'a> {\n \n impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n-        match id.krate {\n-            LOCAL_CRATE => self.definitions.def_key(id.index).parent,\n-            _ => self.cstore().def_key(id).parent,\n+        match id.as_local() {\n+            Some(id) => self.definitions.def_key(id).parent,\n+            None => self.cstore().def_key(id).parent,\n         }\n         .map(|index| DefId { index, ..id })\n     }\n@@ -1027,7 +1027,11 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n /// the resolver is no longer needed as all the relevant information is inline.\n impl rustc_ast_lowering::Resolver for Resolver<'_> {\n     fn def_key(&mut self, id: DefId) -> DefKey {\n-        if id.is_local() { self.definitions().def_key(id.index) } else { self.cstore().def_key(id) }\n+        if let Some(id) = id.as_local() {\n+            self.definitions().def_key(id)\n+        } else {\n+            self.cstore().def_key(id)\n+        }\n     }\n \n     fn item_generics_num_lifetimes(&self, def_id: DefId, sess: &Session) -> usize {"}]}